AL,
                        "AcceptSecurityContext: %lx.%lx: Neither DNS or netbios domain name specified (fatal)\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Convert to unicode
            //  Note: this is bogus since the clients OEM code page may be different
            //  than ours.
            //

            UnicodeDomainName = NetpAllocWStrFromStr( OemDomainName );

            if ( UnicodeDomainName == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot alloc domain name %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        OemDomainName ));
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

            //
            // Look the name up.
            //

            DomainInfo = NlFindNetbiosDomain( UnicodeDomainName, FALSE );

            if ( DomainInfo == NULL ) {

                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot find domain %ws (fatal)\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        UnicodeDomainName ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }
        }

        //
        // Get the name of the client machine.
        //
        // If the client computer passed us its DnsHostName,
        //  use that.
        //

        if ( DnsHostName != NULL ) {

            UnicodeComputerName = NetpAllocWStrFromUtf8Str( DnsHostName );

            if ( UnicodeComputerName == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot alloc DNS computer name %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        DnsHostName ));
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

        //
        // If the client computer passed us its Netbios name in UTF-8,
        //  use that.
        //

        } else if ( Utf8ComputerName != NULL ) {

            UnicodeComputerName = NetpAllocWStrFromUtf8Str( Utf8ComputerName );

            if ( UnicodeComputerName == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot alloc utf8 computer name %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        Utf8ComputerName ));
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

        //
        // If the client computer passed us its Netbios name in OEM,
        //  use that.
        //  OEM is bad since the clients code page might be different than ours.
        //
        } else if ( OemComputerName != NULL ) {
            UnicodeComputerName = NetpAllocWStrFromStr( OemComputerName );

            if ( UnicodeComputerName == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot alloc oem computer name %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        OemComputerName ));
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

        //
        // At this point it is fatal if we don't know the client computer name
        //

        } else {

            NlPrint((NL_CRITICAL,
                    "AcceptSecurityContext: %lx.%lx: Don't know client computer name.\n",
                    CurrentHandle.dwUpper, CurrentHandle.dwLower ));
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }


        //
        // Find the server session containing the session key
        //  and make a copy of it.
        //

        NlPrint((NL_SESSION_MORE,
                "AcceptSecurityContext: %lx.%lx: from %ws\n",
                CurrentHandle.dwUpper, CurrentHandle.dwLower,
                UnicodeComputerName ));

        LOCK_SERVER_SESSION_TABLE( DomainInfo );
        ServerSession = NlFindNamedServerSession( DomainInfo, UnicodeComputerName );
        if (ServerSession == NULL) {
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            NlPrint((NL_CRITICAL,
                    "AcceptSecurityContext: %lx.%lx: Can't NlFindNamedServerSession for %ws\n",
                    CurrentHandle.dwUpper, CurrentHandle.dwLower,
                    UnicodeComputerName ));

            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        SessionInfo.SessionKey = ServerSession->SsSessionKey;
        SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );


        //
        // Build a new context.
        //

        Context = AllocateContext( fContextReq );

        if (Context == NULL) {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }

        Context->State = FirstAccept;
        Context->Inbound = TRUE;
        Context->SessionInfo = SessionInfo;

        //
        // Build an output token.
        //

        Message = (PNL_AUTH_MESSAGE) OutputBuffer->pvBuffer;
        Message->MessageType = NegotiateResponse;
        Message->Flags = 0;
        Message->Buffer[0] = '\0';
        OutputBuffer->cbBuffer = sizeof(NL_AUTH_MESSAGE);



        //
        // Tell the caller he need not call us back.
        //

        *phNewContext = Context->ContextHandle;
        CurrentHandle = *phNewContext;
        *pfContextAttr = fContextReq;
        *ptsExpiry = Forever;

        SecStatus = SEC_E_OK;

    //
    // We asked the caller to not call us back.
    //
    } else {
        NlAssert( FALSE );
        NlPrint((NL_CRITICAL,
                "AcceptSecurityContext: Second accept called.\n" ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

Cleanup:

    if ( DnsDomainName != NULL ) {
        NetpMemoryFree( DnsDomainName );
    }
    if ( DnsHostName != NULL ) {
        NetpMemoryFree( DnsHostName );
    }
    if ( Utf8ComputerName != NULL ) {
        NetpMemoryFree( Utf8ComputerName );
    }
    if ( UnicodeComputerName != NULL ) {
        NetApiBufferFree( UnicodeComputerName );
    }
    if ( UnicodeDomainName != NULL ) {
        NetApiBufferFree( UnicodeDomainName );
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    NlPrint(( NL_SESSION_MORE,
              "AcceptSecurityContext: %lx.%lx: returns 0x%lx\n",
              CurrentHandle.dwUpper, CurrentHandle.dwLower,
              SecStatus ));

    // Let netlogon service exit.
    NlEndNetlogonCall();
    return SecStatus;

    UNREFERENCED_PARAMETER( TargetDataRep );
    UNREFERENCED_PARAMETER( pOutput );

}








SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    )
/*++

Routine Description:

    Routine to delete client or server side security context.

Arguments:

    Standard.

Return Value:



--*/
{
    NlPrint(( NL_SESSION_MORE,
              "DeleteSecurityContext: %lx.%lx: called\n",
              phContext->dwUpper, phContext->dwLower ));

    //
    // Don't require that Netlogon be running.  Some security contexts are
    //  deleted as Netlogon is shutting down.
    //
    if ( DeleteContext( phContext )) {
        return(SEC_E_OK);
    } else {
        return(SEC_E_INVALID_HANDLE);
    }
}






SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    )
/*++

Routine Description:

    Routine to return a description of all the security packages implemented
    by this DLL.

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;

    SecStatus = QuerySecurityPackageInfoW(
                    PACKAGE_NAME,
                    ppPackageInfo
                    );
    if (SecStatus == SEC_E_OK) {
        *pcPackages = 1;
    }

    return(SecStatus);

}





SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(
    LPWSTR                      pszPackageName,     // Name of package
    PSecPkgInfoW SEC_FAR *      ppPackageInfo        // Receives package info
    )
/*++

Routine Description:

    Routine to return the description of the named security package.

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;
    PSecPkgInfoW PackageInfo;
    ULONG PackageInfoSize;
    PUCHAR Where;

    if (_wcsicmp(pszPackageName, PACKAGE_NAME)) {
        SecStatus = SEC_E_SECPKG_NOT_FOUND;
        goto Cleanup;
    }

    PackageInfoSize = sizeof(SecPkgInfoW) +
                        (wcslen(PACKAGE_NAME) + 1 +
                         wcslen(PACKAGE_COMMENT) + 1) * sizeof(WCHAR);

    PackageInfo = (PSecPkgInfoW) LocalAlloc(0,PackageInfoSize);
    if (PackageInfo == NULL) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }
    PackageInfo->fCapabilities = PACAKGE_CAPABILITIES;
    PackageInfo->wVersion = PACKAGE_VERSION;
    PackageInfo->wRPCID = PACKAGE_RPCID;
    PackageInfo->cbMaxToken = PACKAGE_MAXTOKEN;

    Where = (PUCHAR) (PackageInfo + 1);
    PackageInfo->Name = (LPWSTR) Where;
    Where += (wcslen(PACKAGE_NAME) + 1) * sizeof(WCHAR);
    wcscpy(PackageInfo->Name, PACKAGE_NAME);

    PackageInfo->Comment = (LPWSTR) Where;
    Where += (wcslen(PACKAGE_COMMENT) + 1) * sizeof(WCHAR);
    wcscpy(PackageInfo->Comment, PACKAGE_COMMENT);

    NlAssert((Where - (PBYTE) PackageInfo) == (LONG) PackageInfoSize);

    *ppPackageInfo = PackageInfo;
    SecStatus = SEC_E_OK;

Cleanup:

    NlPrint(( NL_SESSION_MORE,
        "QuerySecurityPackageInfo: returns 0x%lx\n", SecStatus ));

    return SecStatus;
}







SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
/*++

Routine Description:

    Routine to free a context buffer.

Arguments:

    Standard.

Return Value:



--*/
{
    LocalFree(pvContextBuffer);
    return(SEC_E_OK);
}







SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
/*++

Routine Description:

    Server side routine to impersonate an authenticated user.

Arguments:

    Standard.

Return Value:



--*/
{
    NTSTATUS Status;

    Status = RtlImpersonateSelf(SecurityImpersonation);
    if (NT_SUCCESS(Status)) {
        return(SEC_E_OK);
    } else {
        return(SEC_E_NO_IMPERSONATION);
    }
    UNREFERENCED_PARAMETER( phContext );
}





SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
/*++

Routine Description:

    Server side routine to undo a previous imperonation.

Arguments:

    Standard.

Return Value:



--*/
{

    RevertToSelf();
    return(SEC_E_OK);
    UNREFERENCED_PARAMETER( phContext );
}





SECURITY_STATUS SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
/*++

Routine Description:

    Routine to return information about a context.

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;
    PNL_AUTH_CONTEXT Context;
    PSecPkgContext_Sizes ContextSizes;
    PSecPkgContext_NamesW ContextNames;
    PSecPkgContext_Lifespan ContextLifespan;
    PSecPkgContext_DceInfo  ContextDceInfo;

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }

    //
    // Locate the context and make sure this is a client side call.
    //

    Context = LocateContext( phContext );
    if (Context == NULL) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }



    //
    //
    //
    switch(ulAttribute) {
    case SECPKG_ATTR_SIZES:
        ContextSizes = (PSecPkgContext_Sizes) pBuffer;
        ContextSizes->cbMaxSignature = PACKAGE_SIGNATURE_SIZE;
        if ((Context->ContextFlags & ISC_REQ_CONFIDENTIALITY) != 0) {
            ContextSizes->cbSecurityTrailer = PACKAGE_SIGNATURE_SIZE;
            ContextSizes->cbBlockSize = 1;
        } else {
            ContextSizes->cbSecurityTrailer = 0;
            ContextSizes->cbBlockSize = 0;
        }
        ContextSizes->cbMaxToken = PACKAGE_MAXTOKEN;
        break;
#ifdef notdef // Only support the ones RPC uses
    case SECPKG_ATTR_NAMES:
        ContextNames = (PSecPkgContext_Names) pBuffer;
        ContextNames->sUserName = (LPWSTR) LocalAlloc(0,sizeof(L"dummy user"));
        if (ContextNames->sUserName == NULL) {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }
        wcscpy(ContextNames->sUserName, L"dummy user");
        break;
    case SECPKG_ATTR_LIFESPAN:
        ContextLifespan = (PSecPkgContext_Lifespan) pBuffer;
        ContextLifespan->tsStart = Never;
        ContextLifespan->tsExpiry = Forever;
        break;
    case SECPKG_ATTR_DCE_INFO:
        ContextDceInfo = (PSecPkgContext_DceInfo) pBuffer;
        ContextDceInfo->AuthzSvc = 0;
        ContextDceInfo->pPac = (PVOID) LocalAlloc(0,sizeof(L"dummy user"));
        if (ContextDceInfo->pPac == NULL) {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }
        wcscpy((LPWSTR) ContextDceInfo->pPac, L"dummy user");

        break;
#endif // notdef // Only support the ones RPC uses
    default:
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    SecStatus = SEC_E_OK;

Cleanup:


    NlPrint(( NL_SESSION_MORE,
              "QueryContextAttributes: %lx.%lx: %ld returns 0x%lx\n",
              phContext->dwUpper, phContext->dwLower,
              ulAttribute,
              SecStatus ));

    // Let netlogon service exit.
    NlEndNetlogonCall();
    return SecStatus;
    UNREFERENCED_PARAMETER( pBuffer );
}


SECURITY_STATUS
KerbMapNtStatusToSecStatus(
    IN NTSTATUS Status
    )
{
    SECURITY_STATUS SecStatus;

    //
    // Check for security status and let them through
    //

    if (HRESULT_FACILITY(Status) == FACILITY_SECURITY )
    {
        return(Status);
    }
    switch(Status) {
    case STATUS_SUCCESS:
        SecStatus = SEC_E_OK;
        break;
    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_NO_MEMORY:
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        break;
    case STATUS_NETLOGON_NOT_STARTED:
    case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
    case STATUS_NO_LOGON_SERVERS:
    case STATUS_NO_SUCH_DOMAIN:
        SecStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        break;
    case STATUS_NO_SUCH_LOGON_SESSION:
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        break;
    case STATUS_INVALID_PARAMETER:
        SecStatus = SEC_E_INVALID_TOKEN;
        break;
    case STATUS_PRIVILEGE_NOT_HELD:
        SecStatus = SEC_E_NOT_OWNER;
        break;
    case STATUS_INVALID_HANDLE:
        SecStatus = SEC_E_INVALID_HANDLE;
        break;
    case STATUS_BUFFER_TOO_SMALL:
        // ???: there should be a better code
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        break;
    case STATUS_NOT_SUPPORTED:
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        break;
    case STATUS_OBJECT_NAME_NOT_FOUND:
        SecStatus = SEC_E_TARGET_UNKNOWN;
        break;
    case STATUS_LOGON_FAILURE:
    case STATUS_NO_SUCH_USER:
    case STATUS_ACCOUNT_DISABLED:
    case STATUS_ACCOUNT_RESTRICTION:
    case STATUS_ACCOUNT_LOCKED_OUT:
    case STATUS_WRONG_PASSWORD:
    case STATUS_ACCOUNT_EXPIRED:
    case STATUS_PASSWORD_EXPIRED:
        SecStatus = SEC_E_LOGON_DENIED;
        break;
    case STATUS_NO_TRUST_SAM_ACCOUNT:
        SecStatus = SEC_E_TARGET_UNKNOWN;
        break;
    case STATUS_BAD_NETWORK_PATH:
    case STATUS_TRUST_FAILURE:
    case STATUS_TRUSTED_RELATIONSHIP_FAILURE:

        // ???: what should this be?
        SecStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        break;
    case STATUS_NAME_TOO_LONG:
    case STATUS_ILL_FORMED_PASSWORD:

        // ???: what should this be?
        SecStatus = SEC_E_INVALID_TOKEN;
        break;
    case STATUS_INTERNAL_ERROR:
        SecStatus = SEC_E_INTERNAL_ERROR;
        break;
    default:
        NlPrint(( NL_CRITICAL, "\n\n\n Unable to map error code 0x%x\n\n\n\n",Status));
        SecStatus = SEC_E_INTERNAL_ERROR;

    }
    return(SecStatus);
}



SECURITY_STATUS
NlpSignOrSeal(
    IN PCtxtHandle phContext,
    IN ULONG fQOP,
    IN OUT PSecBufferDesc MessageBuffers,
    IN ULONG MessageSeqNo,
    IN BOOLEAN SealIt
    )
/*++

Routine Description:

    Common routine to sign or seal a message (Client or server side)

Arguments:

    Standard.

    SealIt - True to seal the message.
        FALSE to sign the message.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus = SEC_E_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    PCHECKSUM_FUNCTION Check;
    PCRYPTO_SYSTEM CryptSystem;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;

    ULONG Index;
    PSecBuffer SignatureBuffer = NULL;

    PNL_AUTH_SIGNATURE Signature;
    UCHAR LocalChecksum[24]; // ??? need better constant
    NETLOGON_SESSION_KEY EncryptionSessionKey;
    ULONG OutputSize;

    PNL_AUTH_CONTEXT Context;

    //
    // Locate the context.
    //

    Context = LocateContext( phContext );
    if (Context == NULL) {
        NlPrint(( NL_CRITICAL,
                  "NlpSignOrSeal: %lx.%lx: Cannot LocateContext\n",
                  phContext->dwUpper, phContext->dwLower ));
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Find a buffer to put the signature in.
    //

    SignatureBuffer = LocateSigBuffer( MessageBuffers );

    if (SignatureBuffer == NULL) {
        NlPrint(( NL_CRITICAL,
                  "NlpSignOrSeal: %lx.%lx: No signature buffer found\n",
                  phContext->dwUpper, phContext->dwLower ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }
    if ( SealIt ) {
        if ( SignatureBuffer->cbBuffer < sizeof(PACKAGE_SIGNATURE_SIZE) ) {
            NlPrint(( NL_CRITICAL,
                      "NlpVerifyOrUnseal: %lx.%lx: buffer too small for sealing\n",
                      phContext->dwUpper, phContext->dwLower ));
            SecStatus = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }

    //
    // Build the signature.

    Signature = (PNL_AUTH_SIGNATURE) SignatureBuffer->pvBuffer;
    Signature->SignatureAlgorithm[0] = (UCHAR) NL_AUTH_CHECKSUM;
    Signature->SignatureAlgorithm[1] = 0;

    if ( SealIt ) {
        Signature->SealAlgorithm[0] = (UCHAR) NL_AUTH_ETYPE;
        Signature->SealAlgorithm[1] = 0;
        memset(Signature->SealFiller, 0xff, sizeof(Signature->SealFiller));
        NlGenerateRandomBits( Signature->Confounder, NL_AUTH_CONFOUNDER_SIZE );
        SignatureBuffer->cbBuffer = PACKAGE_SIGNATURE_SIZE;
    } else {
        memset(Signature->SignFiller, 0xff, sizeof(Signature->SignFiller));
        SignatureBuffer->cbBuffer = PACKAGE_SIGNATURE_SIZE - NL_AUTH_CONFOUNDER_SIZE;
    }

    Signature->Flags[0] = 0;
    Signature->Flags[1] = 0;

    Signature->SequenceNumber[0] = (UCHAR) ((Context->Nonce.LowPart & 0xff000000) >> 24);
    Signature->SequenceNumber[1] = (UCHAR) ((Context->Nonce.LowPart & 0x00ff0000) >> 16);
    Signature->SequenceNumber[2] = (UCHAR) ((Context->Nonce.LowPart & 0x0000ff00) >> 8);
    Signature->SequenceNumber[3] = (UCHAR)  (Context->Nonce.LowPart & 0x000000ff);
    Signature->SequenceNumber[4] = (UCHAR) ((Context->Nonce.HighPart & 0xff000000) >> 24);
    Signature->SequenceNumber[5] = (UCHAR) ((Context->Nonce.HighPart & 0x00ff0000) >> 16);
    Signature->SequenceNumber[6] = (UCHAR) ((Context->Nonce.HighPart & 0x0000ff00) >> 8);
    Signature->SequenceNumber[7] = (UCHAR)  (Context->Nonce.HighPart & 0x000000ff);

    if ( !Context->Inbound ) {
        Signature->SequenceNumber[4] |= 0x80;  // Discriminate between inbound and outbound messages
    }

    Context->Nonce.QuadPart ++;


    //
    // Initialize the checksum routines.
    //

    Status = CDLocateCheckSum( (ULONG)NL_AUTH_CHECKSUM, &Check);
    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpSignOrSeal: %lx.%lx: Failed to load checksum routines: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    NlAssert(Check->CheckSumSize <= sizeof(LocalChecksum));

    NlPrint(( NL_ENCRYPT,
              "NlpSignOrSeal: %lx.%lx: Session Key: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, &Context->SessionInfo.SessionKey, sizeof( Context->SessionInfo.SessionKey) );

    Status = Check->InitializeEx(
                (LPBYTE)&Context->SessionInfo.SessionKey,
                sizeof( Context->SessionInfo.SessionKey),
                0,              // no message type
                &CheckBuffer );

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpSignOrSeal: %lx.%lx: Failed to initialize checksum routines: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }


    //
    // Locate the encryption routines.
    //

    Status = CDLocateCSystem( (ULONG)NL_AUTH_ETYPE, &CryptSystem);
    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpSignOrSeal: %lx.%lx: Failed to load crypt system: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }


    //
    // Sum first several bytes of the signature
    //

    Check->Sum( CheckBuffer,
                NL_AUTH_SIGNED_BYTES,
                (PUCHAR)Signature );



    //
    // Sum and encrypt the confounder
    //

    if ( SealIt ) {

        //
        // Sum the confounder
        //
        Check->Sum(
            CheckBuffer,
            NL_AUTH_CONFOUNDER_SIZE,
            Signature->Confounder );

        //
        // Create the encryption key by xoring the session key with 0xf0f0f0f0
        //

        for ( Index=0; Index < sizeof(EncryptionSessionKey); Index++ ) {
            ((LPBYTE)(&EncryptionSessionKey))[Index] =
                ((LPBYTE)(&Context->SessionInfo.SessionKey))[Index] ^0xf0f0f0f0;
        }

        //
        // Pass the key to the encryption routines.
        //

        Status = CryptSystem->Initialize(
                    (LPBYTE)&EncryptionSessionKey,
                    sizeof( EncryptionSessionKey ),
                    0,                                      // no message type
                    &CryptBuffer );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,
                      "NlpSignOrSeal: %lx.%lx: Failed to initialize crypt routines: 0x%x\n",
                      phContext->dwUpper, phContext->dwLower,
                      Status));
            goto Cleanup;
        }

        //
        // Set the initial vector to ensure the key is different for each message
        //

        Status = CryptSystem->Control(
                    CRYPT_CONTROL_SET_INIT_VECT,
                    CryptBuffer,
                    Signature->SequenceNumber,
                    sizeof(Signature->SequenceNumber) );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,
                      "NlpSignOrSeal: %lx.%lx: Failed to set IV: 0x%x\n",
                      phContext->dwUpper, phContext->dwLower,
                      Status));
            goto Cleanup;
        }

        //
        // Encrypt the confounder
        //

        Status = CryptSystem->Encrypt(
                    CryptBuffer,
                    Signature->Confounder,
                    NL_AUTH_CONFOUNDER_SIZE,
                    Signature->Confounder,
                    &OutputSize );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,
                      "NlpSignOrSeal: %lx.%lx: Failed to encrypt confounder: 0x%x\n",
                      phContext->dwUpper, phContext->dwLower,
                      Status));
            goto Cleanup;
        }

        NlAssert( OutputSize == NL_AUTH_CONFOUNDER_SIZE );
    }

    //
    // Sum and encrypt the caller's message.
    //

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ ) {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0)) {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer );

            //
            // Now encrypt the buffer
            //

            if ( SealIt ) {
                Status = CryptSystem->Encrypt(
                            CryptBuffer,
                            (PUCHAR) MessageBuffers->pBuffers[Index].pvBuffer,
                            MessageBuffers->pBuffers[Index].cbBuffer,
                            (PUCHAR) MessageBuffers->pBuffers[Index].pvBuffer,
                            &OutputSize );

                if (!NT_SUCCESS(Status)) {
                    NlPrint(( NL_CRITICAL,
                              "NlpSignOrSeal: %lx.%lx: Failed to encrypt buffer: 0x%x\n",
                              phContext->dwUpper, phContext->dwLower,
                              Status));
                    goto Cleanup;
                }

                NlAssert(OutputSize == MessageBuffers->pBuffers[Index].cbBuffer);
            }

        }
    }

    //
    // Finish the checksum
    //

    (void) Check->Finalize(CheckBuffer, LocalChecksum);

#ifdef notdef
    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,"NlpSignOrSeal: Failed to finish checksum: 0x%x\n", Status));
        goto Cleanup;
    }
    CheckBuffer = NULL;
#endif //  notdef


    //
    // Copy the checksum into the message.
    //

    NlAssert( sizeof(LocalChecksum) >= sizeof(Signature->Checksum) );
    RtlCopyMemory( Signature->Checksum, LocalChecksum, sizeof(Signature->Checksum) );


    //
    // Always encrypt the sequence number, using the checksum as the IV
    //

    if ( SealIt ) {
        CryptSystem->Discard( &CryptBuffer );
        CryptBuffer = NULL;
    }

    Status = CryptSystem->Initialize(
                (LPBYTE)&Context->SessionInfo.SessionKey,
                sizeof( Context->SessionInfo.SessionKey),
                0,                                      // no message type
                &CryptBuffer );

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpSignOrSeal: %lx.%lx: Failed initialize crypt routines: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    NlPrint(( NL_ENCRYPT,
              "NlpSignOrSeal: %lx.%lx: IV: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, Signature->Checksum, sizeof(Signature->Checksum) );

    Status = CryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                Signature->Checksum,
                sizeof(Signature->Checksum) );

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpSignOrSeal: %lx.%lx: Failed to set IV: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    NlPrint(( NL_ENCRYPT,
              "NlpSignOrSeal: %lx.%lx: Clear Seq: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, Signature->SequenceNumber, sizeof(Signature->SequenceNumber) );

    Status = CryptSystem->Encrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                sizeof(Signature->SequenceNumber),
                Signature->SequenceNumber,
                &OutputSize
                );
    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpSignOrSeal: %lx.%lx: Failed to encrypt sequence number: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    NlPrint(( NL_ENCRYPT,
              "NlpSignOrSeal: %lx.%lx: Encrypted Seq: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, Signature->SequenceNumber, sizeof(Signature->SequenceNumber) );

    NlAssert(OutputSize == sizeof(Signature->SequenceNumber));


Cleanup:
    if (CryptBuffer != NULL) {
        CryptSystem->Discard(&CryptBuffer);
    }

    if (CheckBuffer != NULL) {
        Check->Finish(&CheckBuffer);
    }

    if ( SecStatus == SEC_E_OK ) {
        SecStatus = KerbMapNtStatusToSecStatus(Status);
    }

    return SecStatus;
    UNREFERENCED_PARAMETER( MessageSeqNo );
    UNREFERENCED_PARAMETER( fQOP );
}



SECURITY_STATUS
NlpVerifyOrUnseal(
    IN PCtxtHandle phContext,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection,
    IN BOOLEAN UnsealIt
    )
/*++

Routine Description:

    Common routine to verify or unseal a message (Client or server side)

Arguments:

    Standard.

    UnSealIt - True to unseal the message.
        FALSE to verify the message.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus = SEC_E_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    PCHECKSUM_FUNCTION Check;
    PCRYPTO_SYSTEM CryptSystem;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;

    ULONG Index;
    PSecBuffer SignatureBuffer = NULL;
    PNL_AUTH_SIGNATURE Signature;

    UCHAR LocalChecksum[24]; // ??? need better constant
    BYTE LocalNonce[ NL_AUTH_SEQUENCE_SIZE ];
    NETLOGON_SESSION_KEY EncryptionSessionKey;

    ULONG OutputSize;

    PNL_AUTH_CONTEXT Context;


    //
    // Locate the context.
    //

    Context = LocateContext( phContext );
    if (Context == NULL) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Cannot LocateContext\n",
                  phContext->dwUpper, phContext->dwLower ));
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Find a buffer to put the signature in.
    //

    SignatureBuffer = LocateSigBuffer( MessageBuffers );

    if (SignatureBuffer == NULL) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: No signature buffer found\n",
                  phContext->dwUpper, phContext->dwLower ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }



    //
    // Verify the signature.
    //

    Signature = (PNL_AUTH_SIGNATURE) SignatureBuffer->pvBuffer;
    if ( Signature->SignatureAlgorithm[0] != (BYTE)NL_AUTH_CHECKSUM ||
         Signature->SignatureAlgorithm[1] != 0 ) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: signature alg different\n",
                  phContext->dwUpper, phContext->dwLower ));
        SecStatus = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    if ( UnsealIt ) {
        if ( SignatureBuffer->cbBuffer < sizeof(PACKAGE_SIGNATURE_SIZE) ) {
            NlPrint(( NL_CRITICAL,
                      "NlpVerifyOrUnseal: %lx.%lx: buffer too small for sealing\n",
                      phContext->dwUpper, phContext->dwLower ));
            SecStatus = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
        if ( Signature->SealAlgorithm[0] != (BYTE)NL_AUTH_ETYPE ||
             Signature->SealAlgorithm[1] != 0 ) {
            NlPrint(( NL_CRITICAL,
                      "NlpVerifyOrUnseal: %lx.%lx: seal alg different\n",
                      phContext->dwUpper, phContext->dwLower ));
            SecStatus = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
        if ( *((USHORT UNALIGNED *)Signature->SealFiller) != 0xffff) {
            NlPrint(( NL_CRITICAL,
                      "NlpVerifyOrUnseal: %lx.%lx: Filler different\n",
                      phContext->dwUpper, phContext->dwLower ));
            SecStatus = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    } else {
        if ( *((ULONG UNALIGNED *) Signature->SignFiller) != 0xffffffff) {
            NlPrint(( NL_CRITICAL,
                      "NlpVerifyOrUnseal: %lx.%lx: Filler different\n",
                      phContext->dwUpper, phContext->dwLower ));
            SecStatus = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }


    //
    // Verify the sequence number.
    //
    // It is sent encrypted using the checksum as the IV, so decrypt it before
    // checking it.
    //
    // Locate the encryption routines.
    //

    Status = CDLocateCSystem( (ULONG)NL_AUTH_ETYPE, &CryptSystem);
    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Failed to load crypt system: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    NlPrint(( NL_ENCRYPT,
              "NlpVerifyOrUnseal: %lx.%lx: Session Key: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, &Context->SessionInfo.SessionKey, sizeof( Context->SessionInfo.SessionKey) );

    Status = CryptSystem->Initialize(
                (LPBYTE)&Context->SessionInfo.SessionKey,
                sizeof( Context->SessionInfo.SessionKey),
                0,                                      // no message type
                &CryptBuffer );

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Failed initialize crypt routines: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    NlPrint(( NL_ENCRYPT,
              "NlpVerifyOrUnseal: %lx.%lx: IV: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, Signature->Checksum, sizeof(Signature->Checksum) );

    Status = CryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                Signature->Checksum,
                sizeof(Signature->Checksum) );

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Failed to set IV: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    //
    // Now decrypt the sequence number
    //

    NlPrint(( NL_ENCRYPT,
              "NlpVerifyOrUnseal: %lx.%lx: Encrypted Seq: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, Signature->SequenceNumber, sizeof(Signature->SequenceNumber) );

    Status = CryptSystem->Decrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                sizeof(Signature->SequenceNumber),
                Signature->SequenceNumber,
                &OutputSize );

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Cannot decrypt sequence number: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    NlPrint(( NL_ENCRYPT,
              "NlpVerifyOrUnseal: %lx.%lx: Clear Seq: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, Signature->SequenceNumber, sizeof(Signature->SequenceNumber) );



    LocalNonce[0] = (UCHAR) ((Context->Nonce.LowPart & 0xff000000) >> 24);
    LocalNonce[1] = (UCHAR) ((Context->Nonce.LowPart & 0x00ff0000) >> 16);
    LocalNonce[2] = (UCHAR) ((Context->Nonce.LowPart & 0x0000ff00) >> 8);
    LocalNonce[3] = (UCHAR)  (Context->Nonce.LowPart & 0x000000ff);
    LocalNonce[4] = (UCHAR) ((Context->Nonce.HighPart & 0xff000000) >> 24);
    LocalNonce[5] = (UCHAR) ((Context->Nonce.HighPart & 0x00ff0000) >> 16);
    LocalNonce[6] = (UCHAR) ((Context->Nonce.HighPart & 0x0000ff00) >> 8);
    LocalNonce[7] = (UCHAR)  (Context->Nonce.HighPart & 0x000000ff);

    if ( Context->Inbound ) {
        LocalNonce[4] |= 0x80;  // Discriminate between inbound and outbound messages
    }


    if (!RtlEqualMemory( LocalNonce,
                         Signature->SequenceNumber,
                         NL_AUTH_SEQUENCE_SIZE )) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Out of sequence\n",
                  phContext->dwUpper, phContext->dwLower ));
        NlPrint(( NL_CRITICAL,"NlpVerifyOrUnseal: Local Sequence:  " ));
        NlpDumpBuffer(NL_CRITICAL, LocalNonce, NL_AUTH_SEQUENCE_SIZE );
        NlPrint(( NL_CRITICAL,"NlpVerifyOrUnseal: Remote Sequence: " ));
        NlpDumpBuffer(NL_CRITICAL, Signature->SequenceNumber, NL_AUTH_SEQUENCE_SIZE );
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    Context->Nonce.QuadPart ++;


    //
    // Now compute the checksum and verify it
    //
    //
    // Initialize the checksum routines.
    //

    Status = CDLocateCheckSum( (ULONG)NL_AUTH_CHECKSUM, &Check);
    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Failed to load checksum routines: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }

    NlAssert(Check->CheckSumSize <= sizeof(LocalChecksum));

    Status = Check->InitializeEx(
                (LPBYTE)&Context->SessionInfo.SessionKey,
                sizeof( Context->SessionInfo.SessionKey),
                0,                                              // no message type
                &CheckBuffer );

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Failed to initialize checksum routines: 0x%x\n",
                  phContext->dwUpper, phContext->dwLower,
                  Status));
        goto Cleanup;
    }


    //
    // Sum first several bytes of the signature
    //
    NlPrint(( NL_ENCRYPT,
              "NlpVerifyOrUnseal: %lx.%lx: First Several of signature: ",
              phContext->dwUpper, phContext->dwLower ));
    NlpDumpBuffer(NL_ENCRYPT, Signature, NL_AUTH_SIGNED_BYTES );

    Check->Sum( CheckBuffer,
                NL_AUTH_SIGNED_BYTES,
                (PUCHAR)Signature );





    //
    // Sum and decrypt the confounder
    //

    if ( UnsealIt ) {

        //
        // Discard the previous CryptBuffer
        //
        CryptSystem->Discard( &CryptBuffer );
        CryptBuffer = NULL;

        //
        // Create the encryption key by xoring the session key with 0xf0f0f0f0
        //

        for ( Index=0; Index < sizeof(EncryptionSessionKey); Index++ ) {
            ((LPBYTE)(&EncryptionSessionKey))[Index] =
                ((LPBYTE)(&Context->SessionInfo.SessionKey))[Index] ^0xf0f0f0f0;
        }

        //
        // Pass the key to the encryption routines.
        //

        Status = CryptSystem->Initialize(
                    (LPBYTE)&EncryptionSessionKey,
                    sizeof( EncryptionSessionKey ),
                    0,                                      // no message type
                    &CryptBuffer );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,
                      "NlpVerifyOrUnseal: %lx.%lx: Failed to initialize crypt routines: 0x%x\n",
                      phContext->dwUpper, phContext->dwLower,
                      Status));
            goto Cleanup;
        }

        //
        // Set the initial vector to ensure the key is different for each message
        //

        Status = CryptSystem->Control(
                    CRYPT_CONTROL_SET_INIT_VECT,
                    CryptBuffer,
                    Signature->SequenceNumber,
                    sizeof(Signature->SequenceNumber) );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,
                      "NlpVerifyOrUnseal: %lx.%lx: Failed to set IV: 0x%x\n",
                      phContext->dwUpper, phContext->dwLower,
                      Status));
            goto Cleanup;
        }

        //
        // Decrypt the confounder
        //

        Status = CryptSystem->Decrypt(
                    CryptBuffer,
                    Signature->Confounder,
                    NL_AUTH_CONFOUNDER_SIZE,
                    Signature->Confounder,
                    &OutputSize );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,
                      "NlpVerifyOrUnseal: %lx.%lx: Failed to encrypt confounder: 0x%x\n",
                      phContext->dwUpper, phContext->dwLower,
                      Status));
            goto Cleanup;
        }

        NlAssert( OutputSize == NL_AUTH_CONFOUNDER_SIZE );

        //
        // Sum the decrypted confounder
        //
        Check->Sum(
            CheckBuffer,
            NL_AUTH_CONFOUNDER_SIZE,
            Signature->Confounder );
    }

    //
    // Sum and decrypt the caller's message.
    //

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ ) {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0)) {

            //
            // Now decrypt the buffer
            //

            if ( UnsealIt ) {
                Status = CryptSystem->Decrypt(
                            CryptBuffer,
                            (PUCHAR) MessageBuffers->pBuffers[Index].pvBuffer,
                            MessageBuffers->pBuffers[Index].cbBuffer,
                            (PUCHAR) MessageBuffers->pBuffers[Index].pvBuffer,
                            &OutputSize );

                if (!NT_SUCCESS(Status)) {
                    NlPrint(( NL_CRITICAL,
                              "NlpVerifyOrUnseal: %lx.%lx: Failed to encrypt buffer: 0x%x\n",
                              phContext->dwUpper, phContext->dwLower,
                              Status));
                    goto Cleanup;
                }

                NlAssert(OutputSize == MessageBuffers->pBuffers[Index].cbBuffer);
            }

            //
            // Checksum the decrypted buffer.
            //
            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer );

        }
    }


    //
    // Finish the checksum
    //

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    if (!RtlEqualMemory(
            LocalChecksum,
            Signature->Checksum,
            sizeof(Signature->Checksum) )) {

        NlPrint(( NL_CRITICAL,
                  "NlpVerifyOrUnseal: %lx.%lx: Checksum mismatch\n",
                  phContext->dwUpper, phContext->dwLower ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

Cleanup:
    if (CheckBuffer != NULL) {
        Check->Finish(&CheckBuffer);
    }
    if (CryptBuffer != NULL) {
        CryptSystem->Discard(&CryptBuffer);
    }

    if ( SecStatus == SEC_E_OK ) {
        SecStatus = KerbMapNtStatusToSecStatus(Status);
    }

    return SecStatus;
    UNREFERENCED_PARAMETER( QualityOfProtection );
    UNREFERENCED_PARAMETER( MessageSequenceNumber );
}



SECURITY_STATUS SEC_ENTRY
MakeSignature(  PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
/*++

Routine Description:

    Routine to sign a message (Client or server side)

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }

    SecStatus = NlpSignOrSeal(
                    phContext,
                    fQOP,
                    pMessage,
                    MessageSeqNo,
                    FALSE );    // Just sign the message

    NlPrint(( NL_SESSION_MORE,
              "MakeSignature: %lx.%lx: returns 0x%lx\n",
              phContext->dwUpper, phContext->dwLower,
              SecStatus ));

    // Let netlogon service exit.
    NlEndNetlogonCall();

    return SecStatus;

}



SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                ULONG *         pfQOP)
/*++

Routine Description:

    Routine to verify a signed message (Client or server side)

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }

    SecStatus = NlpVerifyOrUnseal(
                    phContext,
                    pMessage,
                    MessageSeqNo,
                    pfQOP,
                    FALSE );    // Just verify the signature

    NlPrint(( NL_SESSION_MORE,
              "VerifySignature: %lx.%lx: returns 0x%lx\n",
              phContext->dwUpper, phContext->dwLower,
              SecStatus ));

    // Let netlogon service exit.
    NlEndNetlogonCall();

    return SecStatus;
}



SECURITY_STATUS SEC_ENTRY
SealMessage(    PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
/*++

Routine Description:

    Routine to encrypt a message (Client or server side)

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }

    SecStatus = NlpSignOrSeal(
                    phContext,
                    fQOP,
                    pMessage,
                    MessageSeqNo,
                    TRUE );    // Seal the message

    NlPrint(( NL_SESSION_MORE,
              "SealMessage: %lx.%lx: returns 0x%lx\n",
              phContext->dwUpper, phContext->dwLower,
              SecStatus ));

    // Let netlogon service exit.
    NlEndNetlogonCall();

    return SecStatus;
}



SECURITY_STATUS SEC_ENTRY
UnsealMessage(  PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                ULONG *             pfQOP)
/*++

Routine Description:

    Routine to un-encrypt a message (client or server side)

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }

    SecStatus = NlpVerifyOrUnseal(
                    phContext,
                    pMessage,
                    MessageSeqNo,
                    pfQOP,
                    TRUE );    // unseal the message

    NlPrint(( NL_SESSION_MORE,
              "UnsealMessage: %lx.%lx: returns 0x%lx\n",
              phContext->dwUpper, phContext->dwLower,
              SecStatus ));

    // Let netlogon service exit.
    NlEndNetlogonCall();

    return SecStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\rgroups.c ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    rgroups.c

Abstract:

    Routines to expand transitive group membership.

Author:

    Mike Swift (mikesw) 8-May-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:


--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop




PSID
NlpCopySid(
    IN  PSID Sid
    )

/*++

Routine Description:

    Given a SID allocatees space for a new SID from the LSA heap and copies
    the original SID.

Arguments:

    Sid - The original SID.

Return Value:

    Sid - Returns a pointer to a buffer allocated from the LsaHeap
            containing the resultant Sid.

--*/
{
    PSID NewSid;
    ULONG Size;

    Size = RtlLengthSid( Sid );



    if ((NewSid = MIDL_user_allocate( Size )) == NULL ) {
        return NULL;
    }


    if ( !NT_SUCCESS( RtlCopySid( Size, NewSid, Sid ) ) ) {
        MIDL_user_free( NewSid );
        return NULL;
    }


    return NewSid;
}


NTSTATUS
NlpBuildPacSidList(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 UserInfo,
    OUT PSAMPR_PSID_ARRAY Sids
    )
/*++

Routine Description:

    Given the validation information for a user, expands the group member-
    ships and user id into a list of sids

Arguments:

    UserInfo - user's validation information
    Sids - receives an array of all the user's group sids and user id

Return Value:


    STATUS_INSUFFICIENT_RESOURCES - there wasn't enough memory to
        create the list of sids.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NET_API_STATUS NetStatus;
    ULONG Size = 0, i;

    Sids->Count = 0;
    Sids->Sids = NULL;


    if (UserInfo->UserId != 0) {
        Size += sizeof(SAMPR_SID_INFORMATION);
    }

    Size += UserInfo->GroupCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);


    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        Size += UserInfo->SidCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);
    }



    Sids->Sids = (PSAMPR_SID_INFORMATION) MIDL_user_allocate( Size );

    if ( Sids->Sids == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        Sids->Sids,
        Size
        );


    //
    // Start copying SIDs into the structure
    //

    i = 0;

    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId ) {
        NetStatus = NetpDomainIdToSid(
                        UserInfo->LogonDomainId,
                        UserInfo->UserId,
                        (PSID *) &Sids->Sids[0].SidPointer
                        );

        if( NetStatus != ERROR_SUCCESS ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Sids->Count++;
    }

    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        NetStatus = NetpDomainIdToSid(
                        UserInfo->LogonDomainId,
                        UserInfo->GroupIds[i].RelativeId,
                        (PSID *) &Sids->Sids[Sids->Count].SidPointer
                        );
        if( NetStatus != ERROR_SUCCESS ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Sids->Count++;
    }


    //
    // Add in the extra SIDs
    //

    //
    // ???: no need to allocate these
    //
    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {


        for ( i = 0; i < UserInfo->SidCount; i++ ) {


            Sids->Sids[Sids->Count].SidPointer = NlpCopySid(
                                                    UserInfo->ExtraSids[i].Sid
                                                    );
            if (Sids->Sids[Sids->Count].SidPointer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }


            Sids->Count++;
        }
    }


    //
    // Deallocate any memory we've allocated
    //

Cleanup:
    if (!NT_SUCCESS(Status)) {
        if (Sids->Sids != NULL) {
            for (i = 0; i < Sids->Count ;i++ ) {
                if (Sids->Sids[i].SidPointer != NULL) {
                    MIDL_user_free(Sids->Sids[i].SidPointer);
                }
            }
            MIDL_user_free(Sids->Sids);
            Sids->Sids = NULL;
            Sids->Count = 0;
        }
    }
    return Status;

}


NTSTATUS
NlpAddResourceGroupsToSamInfo (
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 *ValidationInformation,
    IN PSAMPR_PSID_ARRAY ResourceGroups
)
/*++

Routine Description:

    This function converts a NETLOGON_VALIDATION_SAM_INFO version 1, 2, or 4 to
    a NETLOGON_VALIDATION_SAM_INFO version 4 and optionally adds in an array of
    ResourceGroup sids.

    Since version 4 is a superset of the other two levels, the returned structure can
    be used even though one of the other info levels are needed.


Arguments:

    ValidationLevel -- Specifies the level of information passed as input in
        ValidationInformation.  Must be NetlogonValidationSamInfo or
        NetlogonValidationSamInfo2, NetlogonValidationSamInfo4

        NetlogonValidationSamInfo4 is always returned on output.

    ValidationInformation -- Specifies the NETLOGON_VALIDATION_SAM_INFO
        to convert.

    ResourceGroups - The list of resource groups to add to the structure.
        If NULL, no resource groups are added.


Return Value:

    STATUS_INSUFFICIENT_RESOURCES: not enough memory to allocate the new
            structure.

--*/
{
    ULONG Length;
    PNETLOGON_VALIDATION_SAM_INFO4 SamInfo = *ValidationInformation;
    PNETLOGON_VALIDATION_SAM_INFO4 SamInfo4;
    PBYTE Where;
    ULONG Index;
    ULONG GroupIndex;
    ULONG ExtraSids = 0;

    //
    // Calculate the size of the new structure
    //

    Length = sizeof( NETLOGON_VALIDATION_SAM_INFO4 )
            + SamInfo->GroupCount * sizeof(GROUP_MEMBERSHIP)
            + RtlLengthSid( SamInfo->LogonDomainId );


    //
    // Add space for extra sids & resource groups
    //

    if ( ValidationLevel != NetlogonValidationSamInfo &&
         (SamInfo->UserFlags & LOGON_EXTRA_SIDS) != 0 ) {

        for (Index = 0; Index < SamInfo->SidCount ; Index++ ) {
            Length += sizeof(NETLOGON_SID_AND_ATTRIBUTES) + RtlLengthSid(SamInfo->ExtraSids[Index].Sid);
        }
        ExtraSids += SamInfo->SidCount;
    }

    if ( ResourceGroups != NULL ) {
        for (Index = 0; Index < ResourceGroups->Count ; Index++ ) {
            Length += sizeof(NETLOGON_SID_AND_ATTRIBUTES) + RtlLengthSid(ResourceGroups->Sids[Index].SidPointer);
        }
        ExtraSids += ResourceGroups->Count;
    }

    //
    // Round up now to take into account the round up in the
    // middle of marshalling
    //

    Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->LogonDomainName.Length + sizeof(WCHAR)
            + SamInfo->LogonServer.Length + sizeof(WCHAR)
            + SamInfo->EffectiveName.Length + sizeof(WCHAR)
            + SamInfo->FullName.Length + sizeof(WCHAR)
            + SamInfo->LogonScript.Length + sizeof(WCHAR)
            + SamInfo->ProfilePath.Length + sizeof(WCHAR)
            + SamInfo->HomeDirectory.Length + sizeof(WCHAR)
            + SamInfo->HomeDirectoryDrive.Length + sizeof(WCHAR);

    if ( ValidationLevel == NetlogonValidationSamInfo4 ) {
        Length += SamInfo->DnsLogonDomainName.Length + sizeof(WCHAR)
            + SamInfo->Upn.Length + sizeof(WCHAR);

        //
        // The ExpansionStrings may be used to transport byte aligned data
        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString1.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString2.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString3.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString4.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString5.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString6.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString7.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString8.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString9.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString10.Length + sizeof(WCHAR);
    }

    Length = ROUND_UP_COUNT( Length, sizeof(WCHAR) );

    SamInfo4 = (PNETLOGON_VALIDATION_SAM_INFO4) MIDL_user_allocate( Length );

    if ( !SamInfo4 ) {
        *ValidationInformation = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // First copy the whole structure, since most parts are the same
    //

    RtlCopyMemory( SamInfo4, SamInfo, sizeof(NETLOGON_VALIDATION_SAM_INFO));
    RtlZeroMemory( &((LPBYTE)SamInfo4)[sizeof(NETLOGON_VALIDATION_SAM_INFO)],
                   sizeof(NETLOGON_VALIDATION_SAM_INFO4) - sizeof(NETLOGON_VALIDATION_SAM_INFO) );

    //
    // Copy all the variable length data
    //

    Where = (PBYTE) (SamInfo4 + 1);

    RtlCopyMemory(
        Where,
        SamInfo->GroupIds,
        SamInfo->GroupCount * sizeof( GROUP_MEMBERSHIP) );

    SamInfo4->GroupIds = (PGROUP_MEMBERSHIP) Where;
    Where += SamInfo->GroupCount * sizeof( GROUP_MEMBERSHIP );

    //
    // Copy the extra groups
    //

    if (ExtraSids != 0) {

        ULONG SidLength;

        SamInfo4->ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) Where;
        Where += sizeof(NETLOGON_SID_AND_ATTRIBUTES) * ExtraSids;

        GroupIndex = 0;

        if ( ValidationLevel != NetlogonValidationSamInfo &&
             (SamInfo->UserFlags & LOGON_EXTRA_SIDS) != 0 ) {

            for (Index = 0; Index < SamInfo->SidCount ; Index++ ) {

                SamInfo4->ExtraSids[GroupIndex].Attributes = SamInfo->ExtraSids[Index].Attributes;
                SamInfo4->ExtraSids[GroupIndex].Sid = (PSID) Where;
                SidLength = RtlLengthSid(SamInfo->ExtraSids[Index].Sid);
                RtlCopyMemory(
                    Where,
                    SamInfo->ExtraSids[Index].Sid,
                    SidLength

                    );
                Where += SidLength;
                GroupIndex++;
            }
        }

        //
        // Add the resource groups
        //


        if ( ResourceGroups != NULL ) {
            for (Index = 0; Index < ResourceGroups->Count ; Index++ ) {

                SamInfo4->ExtraSids[GroupIndex].Attributes = SE_GROUP_MANDATORY |
                                                   SE_GROUP_ENABLED |
                                                   SE_GROUP_ENABLED_BY_DEFAULT;

                SamInfo4->ExtraSids[GroupIndex].Sid = (PSID) Where;
                SidLength = RtlLengthSid(ResourceGroups->Sids[Index].SidPointer);
                RtlCopyMemory(
                    Where,
                    ResourceGroups->Sids[Index].SidPointer,
                    SidLength
                    );
                Where += SidLength;
                GroupIndex++;
            }
        }
        SamInfo4->SidCount = GroupIndex;
        NlAssert(GroupIndex == ExtraSids);


    }

    RtlCopyMemory(
        Where,
        SamInfo->LogonDomainId,
        RtlLengthSid( SamInfo->LogonDomainId ) );

    SamInfo4->LogonDomainId = (PSID) Where;
    Where += RtlLengthSid( SamInfo->LogonDomainId );

    //
    // Copy the WCHAR-aligned data
    //
    Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

    NlpPutString(   &SamInfo4->EffectiveName,
                    &SamInfo->EffectiveName,
                    &Where );

    NlpPutString(   &SamInfo4->FullName,
                    &SamInfo->FullName,
                    &Where );

    NlpPutString(   &SamInfo4->LogonScript,
                    &SamInfo->LogonScript,
                    &Where );

    NlpPutString(   &SamInfo4->ProfilePath,
                    &SamInfo->ProfilePath,
                    &Where );

    NlpPutString(   &SamInfo4->HomeDirectory,
                    &SamInfo->HomeDirectory,
                    &Where );

    NlpPutString(   &SamInfo4->HomeDirectoryDrive,
                    &SamInfo->HomeDirectoryDrive,
                    &Where );

    NlpPutString(   &SamInfo4->LogonServer,
                    &SamInfo->LogonServer,
                    &Where );

    NlpPutString(   &SamInfo4->LogonDomainName,
                    &SamInfo->LogonDomainName,
                    &Where );

    if ( ValidationLevel == NetlogonValidationSamInfo4 ) {

        NlpPutString(   &SamInfo4->DnsLogonDomainName,
                        &SamInfo->DnsLogonDomainName,
                        &Where );

        NlpPutString(   &SamInfo4->Upn,
                        &SamInfo->Upn,
                        &Where );

        NlpPutString(   &SamInfo4->ExpansionString1,
                        &SamInfo->ExpansionString1,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString2,
                        &SamInfo->ExpansionString2,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString3,
                        &SamInfo->ExpansionString3,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString4,
                        &SamInfo->ExpansionString4,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString5,
                        &SamInfo->ExpansionString5,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString6,
                        &SamInfo->ExpansionString6,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString7,
                        &SamInfo->ExpansionString7,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString8,
                        &SamInfo->ExpansionString8,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString9,
                        &SamInfo->ExpansionString9,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString10,
                        &SamInfo->ExpansionString10,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

    }


    MIDL_user_free(SamInfo);

    *ValidationInformation =  SamInfo4;

    return STATUS_SUCCESS;

}



NTSTATUS
NlpExpandResourceGroupMembership(
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 * UserInfo,
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Given the validation information for a user, expands the group member-
    ships and user id into a list of sids

Arguments:

    ValidationLevel -- Specifies the level of information passed as input in
        UserInfo.  Must be NetlogonValidationSamInfo or
        NetlogonValidationSamInfo2, NetlogonValidationSamInfo4

        NetlogonValidationSamInfo4 is always returned on output.

    UserInfo - user's validation information
        This structure is updated to include the resource groups that the user is a member of

    DomainInfo - Structure identifying the hosted domain used to determine the group membership.

Return Value:


    STATUS_INSUFFICIENT_RESOURCES - there wasn't enough memory to
        create the list of sids.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_PSID_ARRAY SidList = {0};
    PSAMPR_PSID_ARRAY ResourceGroups = NULL;
    ULONG Index;


    Status = NlpBuildPacSidList(
                *UserInfo,
                &SidList
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    //
    // Call SAM to get the sids
    //

    Status = SamIGetResourceGroupMembershipsTransitive(
                DomainInfo->DomSamAccountDomainHandle,
                &SidList,
                0,              // no flags
                &ResourceGroups
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Build a new validation information structure
    //

    if (ResourceGroups->Count != 0) {

        Status = NlpAddResourceGroupsToSamInfo(
                    ValidationLevel,
                    UserInfo,
                    ResourceGroups
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

Cleanup:

    SamIFreeSidArray(
        ResourceGroups
        );

    if (SidList.Sids != NULL) {
        for (Index = 0; Index < SidList.Count ;Index++ ) {
            if (SidList.Sids[Index].SidPointer != NULL) {
                MIDL_user_free(SidList.Sids[Index].SidPointer);
            }
        }
        MIDL_user_free(SidList.Sids);
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\srvsess.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    srvsess.c

Abstract:

    Routines for managing the ServerSession structure.

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    12-Jul-1991 (cliffv)
        Ported to NT.  Converted to NT style.

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//

#include <lmaudit.h>
#include <lmshare.h>
#include <nbtioctl.h>
#include <kerberos.h>   // KERB_UPDATE_ADDRESSES_REQUEST

#define MAX_WOC_INTERROGATE     8           // 2 hours
#define KILL_SESSION_TIME       (4*4*24)    // 4 Days


//
// Registry key where SocketAddressList is saved across reboots
//
#define NETLOGON_KEYWORD_SOCKETADDRESSLIST   TEXT("SocketAddressList")




DWORD
NlGetHashVal(
    IN LPSTR UpcaseOemComputerName,
    IN DWORD HashTableSize
    )
/*++

Routine Description:

    Generate a HashTable index for the specified ComputerName.

    Notice that all sessions for a particular ComputerName hash to the same
    value.  The ComputerName make a suitable hash key all by itself.
    Also, at times we visit all the session entries for a particular
    ComputerName.  By using only the ComputerName as the hash key, I
    can limit my search to the single hash chain.

Arguments:

    UpcaseOemComputerName - The upper case OEM name of the computer on
        the client side of the secure channel setup.

    HashTableSize - Number of entries in the hash table (must be a power of 2)

Return Value:

    Returns an index into the HashTable.

--*/
{
    UCHAR c;
    DWORD value = 0;

    while (c = *UpcaseOemComputerName++) {
        value += (DWORD) c;
    }

    return (value & (HashTableSize-1));
}


NTSTATUS
NlGetTdoNameHashVal(
    IN PUNICODE_STRING TdoName,
    OUT PUNICODE_STRING CanonicalTdoName,
    OUT PULONG HashIndex
    )
/*++

Routine Description:

    Generate a HashTable index for the specified TdoName

Arguments:

    TdoName - The name of the TDO this secure channel is for

    CanonicalTdoName - Returns the canonical TDO name corresponding to TdoName
        The caller must free this buffer using RtlFreeUnicodeString

    HashIndex - Returns the index into the DomServerSessionTdoNameHashTable

Return Value:

    Status of the operation

--*/
{
    NTSTATUS Status;
    ULONG Index;
    WCHAR c;
    DWORD value = 0;


    //
    // Convert the TdoName to lower case to ensure all versions hash to the same value
    //

    Status = RtlDowncaseUnicodeString(
                CanonicalTdoName,
                TdoName,
                TRUE );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }


    //
    // Canonicalize the TdoName
    //
    //
    // Ditch the trailing . from DNS names
    //

    if ( CanonicalTdoName->Length > sizeof(WCHAR)  &&
         CanonicalTdoName->Buffer[(CanonicalTdoName->Length-sizeof(WCHAR))/sizeof(WCHAR)] == L'.' ) {

        CanonicalTdoName->Length -= sizeof(WCHAR);
        CanonicalTdoName->MaximumLength -= sizeof(WCHAR);
    }



    //
    // Compute the hash
    //
    for ( Index=0; Index < (CanonicalTdoName->Length/sizeof(WCHAR)); Index++ ) {
        value += (DWORD) CanonicalTdoName->Buffer[Index];
    }

    *HashIndex = (value & (SERVER_SESSION_TDO_NAME_HASH_TABLE_SIZE-1));
    return STATUS_SUCCESS;
}



NTSTATUS
NlCheckServerSession(
    IN ULONG ServerRid,
    IN PUNICODE_STRING AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType
    )
/*++

Routine Description:

    Create a server session to represent this BDC account.

Arguments:

    ServerRid - Rid of server to add to list.

    AccountName - Specifies the account name of the account.

    SecureChannelType - Specifies the secure channel type of the account.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    WCHAR LocalServerName[CNLEN+1];
    LONG LocalServerNameSize;
    PSERVER_SESSION ServerSession;


    //
    // Build a zero terminated server name.
    //
    // Strip the trailing postfix.
    //
    // Ignore servers with malformed names.  They aren't really DCs so don't
    // cloud the issue by failing to start netlogon.
    //

    LOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );

    LocalServerNameSize = AccountName->Length -
        SSI_ACCOUNT_NAME_POSTFIX_LENGTH * sizeof(WCHAR);

    if ( LocalServerNameSize < 0 ||
         LocalServerNameSize + sizeof(WCHAR) > sizeof(LocalServerName) ) {

        NlPrint((NL_SERVER_SESS,
                "NlCheckServerSession: %wZ: Skipping add of invalid server name\n",
                AccountName ));
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    if ( AccountName->Buffer[LocalServerNameSize / sizeof(WCHAR)] != SSI_ACCOUNT_NAME_POSTFIX_CHAR ) {

        NlPrint((NL_SERVER_SESS,
                "NlCheckServerSession: %wZ: Skipping add of server name without $\n",
                AccountName ));
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    RtlCopyMemory( LocalServerName, AccountName->Buffer, LocalServerNameSize );
    LocalServerName[ LocalServerNameSize / sizeof(WCHAR) ] = L'\0';



    //
    // Don't add ourselves to the list.
    //

    if ( NlNameCompare( LocalServerName,
                        NlGlobalUnicodeComputerName,
                        NAMETYPE_COMPUTER ) == 0 ) {

        NlPrint((NL_SERVER_SESS,
                "NlCheckServerSession: " FORMAT_LPWSTR
                ": Skipping add of ourself\n",
                LocalServerName ));

        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Check that any existing secure channel has the secure channel type.
    //

    ServerSession = NlFindNamedServerSession( NlGlobalDomainInfo, LocalServerName);
    if (ServerSession != NULL) {

        //
        // If the type is wrong,
        //  ditch the server session.
        //

        if ( ServerSession->SsSecureChannelType != NullSecureChannel &&
             ServerSession->SsSecureChannelType != SecureChannelType ) {
            NlPrint((NL_SERVER_SESS,
                    "NlCheckServerSession: %ws: Server session of type %ld already exists (deleting it)\n",
                     LocalServerName,
                     ServerSession->SsSecureChannelType ));
            NlFreeNamedServerSession( NlGlobalDomainInfo, LocalServerName, TRUE );
        }

    }


    //
    // On a PDC,
    //  pre-create the server session structure so the PDC can keep track of
    //  its BDCs.
    //

    if ( SecureChannelType == ServerSecureChannel &&
         NlGlobalDomainInfo->DomRole == RolePrimary ) {

        // Always force a pulse to a newly created server.
        Status = NlInsertServerSession(
                    NlGlobalDomainInfo,
                    LocalServerName,
                    NULL,           // not an interdomain trust account
                    NullSecureChannel,
                    SS_FORCE_PULSE | SS_BDC,
                    ServerRid,
                    0,        // negotiated flags
                    NULL,     // transport
                    NULL,     // session key
                    NULL );   // authentication seed

        if ( !NT_SUCCESS(Status) ) {
            NlPrint((NL_CRITICAL,
                    "NlCheckServerSession: " FORMAT_LPWSTR
                    ": Couldn't create server session entry (0x%lx)\n",
                    LocalServerName,
                    Status ));
            goto Cleanup;
        }

        NlPrint((NL_SERVER_SESS,
                "NlCheckServerSession: " FORMAT_LPWSTR ": Added NT BDC account\n",
                 LocalServerName ));
    }

    Status = STATUS_SUCCESS;

Cleanup:
    UNLOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );

    return Status;
}



NTSTATUS
NlBuildLmBdcList(
    PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Get the list of all Lanman DC's in this domain from SAM.

    Log an event warning that such DCs are not supported.

Arguments:

    DomainInfo - Domain Bdc list is to be enumerated for

Return Value:

    Status of the operation.
--*/
{
    NTSTATUS Status;

    SAMPR_ULONG_ARRAY RelativeIdArray = {0, NULL};
    SAMPR_ULONG_ARRAY UseArray = {0, NULL};
    RPC_UNICODE_STRING GroupNameString;
    SAMPR_HANDLE GroupHandle = NULL;
    ULONG ServersGroupRid;

    PSAMPR_GET_MEMBERS_BUFFER MembersBuffer = NULL;

    ULONG i;


    //
    // Determine the RID of the Servers group.
    //

    RtlInitUnicodeString( (PUNICODE_STRING)&GroupNameString,
                            SSI_SERVER_GROUP_W );

    Status = SamrLookupNamesInDomain(
                DomainInfo->DomSamAccountDomainHandle,
                1,
                &GroupNameString,
                &RelativeIdArray,
                &UseArray );

    if ( !NT_SUCCESS(Status) ) {
        RelativeIdArray.Element = NULL;
        UseArray.Element = NULL;
        // Its OK if the SERVERS group doesn't exist
        if ( Status == STATUS_NONE_MAPPED ) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // We should get back exactly one entry of info back.
    //

    NlAssert( UseArray.Count == 1 );
    NlAssert( UseArray.Element != NULL );
    NlAssert( RelativeIdArray.Count == 1 );
    NlAssert( RelativeIdArray.Element != NULL );

    if ( UseArray.Element[0] != SidTypeGroup ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    ServersGroupRid = RelativeIdArray.Element[0];



    //
    // Open the SERVERS group
    //

    Status = SamrOpenGroup( DomainInfo->DomSamAccountDomainHandle,
                            0, // No desired access
                            ServersGroupRid,
                            &GroupHandle );

    if ( !NT_SUCCESS(Status) ) {
        GroupHandle = NULL;
        goto Cleanup;
    }


    //
    // Enumerate members in the SERVERS group.
    //

    Status = SamrGetMembersInGroup( GroupHandle, &MembersBuffer );

    if (!NT_SUCCESS(Status)) {
        MembersBuffer = NULL;
        goto Cleanup;
    }


    //
    // For each member of the SERVERS group,
    //  add an entry in the downlevel servers table.
    //

    if ( MembersBuffer->MemberCount > 0 ) {
        LPWSTR MsgStrings[1];

        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NlBuildLmBdcList: %s: Members of SERVERS group detected (and ignored).\n" ));
        MsgStrings[0] = DomainInfo->DomUnicodeDomainName;

        NlpWriteEventlog(
                    NELOG_NetlogonLanmanBdcsNotAllowed,
                    EVENTLOG_ERROR_TYPE,
                    NULL,
                    0,
                    MsgStrings,
                    1 );

    }


    //
    // Success
    //

    Status = STATUS_SUCCESS;



    //
    // Free locally used resources.
    //

Cleanup:

    SamIFree_SAMPR_ULONG_ARRAY( &RelativeIdArray );
    SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

    if ( MembersBuffer != NULL ) {
        SamIFree_SAMPR_GET_MEMBERS_BUFFER( MembersBuffer );
    }

    if( GroupHandle != NULL ) {
        (VOID) SamrCloseHandle( &GroupHandle );
    }

    return Status;
}



//
// Number of machine accounts read from SAM on each call
//
#define MACHINES_PER_PASS 250


NTSTATUS
NlBuildNtBdcList(
    PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Get the list of all Nt Bdc DC's in this domain from SAM.

Arguments:

    None

Return Value:

    Status of the operation.
--*/
{
    NTSTATUS Status;
    NTSTATUS SamStatus;

    SAMPR_DISPLAY_INFO_BUFFER DisplayInformation;
    PDOMAIN_DISPLAY_MACHINE MachineInformation = NULL;
    ULONG SamIndex;
    BOOL UseDisplayServer = TRUE;



    //
    // Loop building a list of BDC names from SAM.
    //
    // On each iteration of the loop,
    //  get the next several machine accounts from SAM.
    //  determine which of those names are DC names.
    //  Merge the DC names into the list we're currently building of all DCs.
    //

    SamIndex = 0;
    DisplayInformation.MachineInformation.Buffer = NULL;
    do {
        //
        // Arguments to SamrQueryDisplayInformation
        //
        ULONG TotalBytesAvailable;
        ULONG BytesReturned;
        ULONG EntriesRead;

        DWORD i;

        //
        // Sam is so slow that we want to avoid having the service controller time us out
        if ( !GiveInstallHints( FALSE ) ) {
            return STATUS_NO_MEMORY;
        }

        //
        // Get the list of machine accounts from SAM
        //

        NlPrint((NL_SESSION_MORE,
                "SamrQueryDisplayInformation with index: %ld\n",
                SamIndex ));

        if ( UseDisplayServer ) {
            SamStatus = SamrQueryDisplayInformation(
                        DomainInfo->DomSamAccountDomainHandle,
                        DomainDisplayServer,
                        SamIndex,
                        MACHINES_PER_PASS,
                        0xFFFFFFFF,
                        &TotalBytesAvailable,
                        &BytesReturned,
                        &DisplayInformation );

            // If this PDC is running a registry based SAM (as in the case of
            //  upgrade from NT 4.0), avoid DomainDisplayServer.

            if ( SamStatus == STATUS_INVALID_INFO_CLASS ) {
                UseDisplayServer = FALSE;
            }
        }

        if ( !UseDisplayServer ) {
            SamStatus = SamrQueryDisplayInformation(
                        DomainInfo->DomSamAccountDomainHandle,
                        DomainDisplayMachine,
                        SamIndex,
                        MACHINES_PER_PASS,
                        0xFFFFFFFF,
                        &TotalBytesAvailable,
                        &BytesReturned,
                        &DisplayInformation );
        }

        if ( !NT_SUCCESS(SamStatus) ) {
            Status = SamStatus;
            NlPrint((NL_CRITICAL,
                    "SamrQueryDisplayInformation failed: 0x%08lx\n",
                    Status));
            goto Cleanup;
        }

        MachineInformation = (PDOMAIN_DISPLAY_MACHINE)
            DisplayInformation.MachineInformation.Buffer;
        EntriesRead = DisplayInformation.MachineInformation.EntriesRead;


        NlPrint((NL_SESSION_MORE,
                "SamrQueryDisplayInformation Completed: 0x%08lx %ld\n",
                SamStatus,
                EntriesRead ));

        //
        // Set up for the next call to Sam.
        //

        if ( SamStatus == STATUS_MORE_ENTRIES ) {
            SamIndex = MachineInformation[EntriesRead-1].Index;
        }


        //
        // Loop though the list of machine accounts finding the Server accounts.
        //

        for ( i=0; i<EntriesRead; i++ ) {


            NlPrint((NL_SESSION_MORE,
                    "%ld %ld %wZ 0x%lx 0x%lx\n",
                    i,
                    MachineInformation[i].Index,
                    &MachineInformation[i].Machine,
                    MachineInformation[i].AccountControl,
                    MachineInformation[i].Rid ));

            //
            // Ensure the machine account is a server account.
            //

            if ( MachineInformation[i].AccountControl &
                    USER_SERVER_TRUST_ACCOUNT ) {


                //
                // Insert the server session.
                //

                Status = NlCheckServerSession(
                            MachineInformation[i].Rid,
                            &MachineInformation[i].Machine,
                            ServerSecureChannel );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

            }
        }

        //
        // Free the buffer returned from SAM.
        //
        SamIFree_SAMPR_DISPLAY_INFO_BUFFER( &DisplayInformation,
                                            DomainDisplayMachine );
        DisplayInformation.MachineInformation.Buffer = NULL;

    } while ( SamStatus == STATUS_MORE_ENTRIES );

    //
    // Success
    //

    Status = STATUS_SUCCESS;



    //
    // Free locally used resources.
    //
Cleanup:

    SamIFree_SAMPR_DISPLAY_INFO_BUFFER( &DisplayInformation,
                                        DomainDisplayMachine );

    return Status;
}

NET_API_STATUS
I_NetLogonGetIpAddresses(
    OUT PULONG IpAddressCount,
    OUT LPBYTE *IpAddresses
    )
/*++

Routine Description:

    Returns all of the IP Addresses assigned to this machine.

Arguments:


    IpAddressCount - Returns the number of IP addresses assigned to this machine.

    IpAddresses - Returns a buffer containing an array of SOCKET_ADDRESS
        structures.
        This buffer should be freed using I_NetLogonFree().

Return Value:

    NO_ERROR - Success

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the operation.

    ERROR_NETLOGON_NOT_STARTED - Netlogon is not started

--*/
{
    NET_API_STATUS NetStatus;
    ULONG BufferSize;


    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return ERROR_NETLOGON_NOT_STARTED;
    }

    //
    // Get the IP addresses.
    //

    *IpAddresses = NULL;
    *IpAddressCount = 0;

    *IpAddressCount = NlTransportGetIpAddresses(
                            0,  // No special header,
                            FALSE,  // Return pointers
                            (PSOCKET_ADDRESS *)IpAddresses,
                            &BufferSize );

    if ( *IpAddressCount == 0 ) {
        if ( *IpAddresses != NULL ) {
            NetpMemoryFree( *IpAddresses );
        }
        *IpAddresses = NULL;
    }

    NetStatus = NO_ERROR;

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return NetStatus;
}


ULONG
NlTransportGetIpAddresses(
    IN ULONG HeaderSize,
    IN BOOLEAN ReturnOffsets,
    OUT PSOCKET_ADDRESS *RetIpAddresses,
    OUT PULONG RetIpAddressSize
    )
/*++

Routine Description:

    Return all of the IP Addresses assigned to this machine.

Arguments:

    HeaderSize - Size (in bytes) of a header to leave at the front of the returned
        buffer.

    ReturnOffsets - If TRUE, indicates that all returned pointers should
        be offsets.

    RetIpAddresses - Returns a buffer containing the IP Addresses
        This buffer should be freed using NetpMemoryFree().

    RetIpAddressSize - Size (in bytes) of RetIpAddresses

Return Value:

    Returns the number of IP Addresses returned.

--*/
{
    ULONG IpAddressCount;
    ULONG IpAddressSize;
    ULONG i;

    PLIST_ENTRY ListEntry;
    PNL_TRANSPORT TransportEntry = NULL;
    PSOCKET_ADDRESS SocketAddresses;
    LPBYTE OrigBuffer;
    LPBYTE Where;

    //
    // Allocate a buffer that will be large enough.
    //

    *RetIpAddresses = NULL;
    *RetIpAddressSize = 0;

    EnterCriticalSection( &NlGlobalTransportCritSect );
    if ( HeaderSize + NlGlobalWinsockPnpAddressSize == 0 ) {
        LeaveCriticalSection( &NlGlobalTransportCritSect );
        return 0;
    }

    OrigBuffer = NetpMemoryAllocate( HeaderSize + NlGlobalWinsockPnpAddressSize );

    if ( OrigBuffer == NULL ) {
        LeaveCriticalSection( &NlGlobalTransportCritSect );
        return 0;
    }

    if ( NlGlobalWinsockPnpAddressSize == 0 ) {
        LeaveCriticalSection( &NlGlobalTransportCritSect );
        *RetIpAddresses = (PSOCKET_ADDRESS)OrigBuffer;
        *RetIpAddressSize = HeaderSize;
        return 0;
    }

    SocketAddresses = (PSOCKET_ADDRESS)(OrigBuffer + HeaderSize);
    *RetIpAddressSize = HeaderSize + NlGlobalWinsockPnpAddressSize;
    Where = (LPBYTE)&SocketAddresses[NlGlobalWinsockPnpAddresses->iAddressCount];


    //
    // Loop through the list of addresses learned via winsock.
    //

    IpAddressCount = NlGlobalWinsockPnpAddresses->iAddressCount;
    for ( i=0; i<IpAddressCount; i++ ) {

        SocketAddresses[i].iSockaddrLength = NlGlobalWinsockPnpAddresses->Address[i].iSockaddrLength;
        if ( ReturnOffsets ) {
            SocketAddresses[i].lpSockaddr = (PSOCKADDR)(Where-OrigBuffer);
        } else {
            SocketAddresses[i].lpSockaddr = (PSOCKADDR)Where;
        }

        RtlCopyMemory( Where,
                       NlGlobalWinsockPnpAddresses->Address[i].lpSockaddr,
                       NlGlobalWinsockPnpAddresses->Address[i].iSockaddrLength );

        Where += NlGlobalWinsockPnpAddresses->Address[i].iSockaddrLength;

    }

    LeaveCriticalSection( &NlGlobalTransportCritSect );

    *RetIpAddresses = (PSOCKET_ADDRESS)OrigBuffer;
    return IpAddressCount;

}

BOOLEAN
NlTransportGetIpAddress(
    IN LPWSTR TransportName,
    OUT PULONG IpAddress
    )
/*++

Routine Description:

    Get the IP Address associated with the specified transport.

Arguments:

    TransportName - Name of the transport to query.

    IpAddress - IP address of the transport.
        Zero if the transport currently has no address or
            if the transport is not IP.

Return Value:

    TRUE: transport is an IP transport

--*/
{
    NTSTATUS Status;
    BOOLEAN RetVal = FALSE;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING TransportNameString;
    HANDLE TransportHandle = NULL;
    ULONG IpAddresses[NBT_MAXIMUM_BINDINGS+1];
    ULONG BytesReturned;

    //
    // Open the transport device directly.
    //

    *IpAddress = 0;

    RtlInitUnicodeString( &TransportNameString, TransportName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &TransportNameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    Status = NtOpenFile(
                   &TransportHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   0 );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;

    }

    if (! NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL,
                  "NlTransportGetIpAddress: %ws Cannot NtOpenFile %lx\n",
                  TransportName,
                  Status ));
        goto Cleanup;
    }

    //
    // Query the IP Address
    //

    if (!DeviceIoControl( TransportHandle,
                          IOCTL_NETBT_GET_IP_ADDRS,
                          NULL,
                          0,
                          IpAddresses,
                          sizeof(IpAddresses),
                          &BytesReturned,
                          NULL)) {

        Status = NetpApiStatusToNtStatus(GetLastError());
        if ( Status != STATUS_NOT_IMPLEMENTED ) {
            NlPrint(( NL_CRITICAL,
                      "NlTransportGetIpAddress: %ws Cannot DeviceIoControl %lx\n",
                      TransportName,
                      Status ));
        }
        goto Cleanup;
    }

    //
    // Return IP Address
    //  (Netbt returns the address in host order.)
    //

    *IpAddress = htonl(*IpAddresses);
    RetVal = TRUE;


Cleanup:

    if ( TransportHandle != NULL ) {
        (VOID) NtClose( TransportHandle );
    }

    return RetVal;
}

VOID
NlNotifyKerberosOfIpAddresses(
    VOID
    )
/*++

Routine Description:

    Call the Kerberos package to let it know the IP addresses of the machine.

Arguments:

    None.

Return Value:

    none

--*/
{
    PKERB_UPDATE_ADDRESSES_REQUEST UpdateRequest = NULL;
    ULONG UpdateRequestSize;

    ULONG SocketAddressCount;

    UNICODE_STRING KerberosPackageName;

    NTSTATUS SubStatus;
    PVOID OutputBuffer = NULL;
    ULONG OutputBufferSize = 0;

    //
    // Initialization.
    //
    RtlInitUnicodeString(
        &KerberosPackageName,
        MICROSOFT_KERBEROS_NAME_W
        );

    //
    // Grab a copy of the list so we don't call Kerberos with anything
    //  locked.
    //
    //
    //

    SocketAddressCount = NlTransportGetIpAddresses(
                            offsetof(KERB_UPDATE_ADDRESSES_REQUEST,Addresses),
                            FALSE,
                            (PSOCKET_ADDRESS *)&UpdateRequest,
                            &UpdateRequestSize );

    if ( UpdateRequest == NULL ) {
        return;
    }


    //
    // Fill in the header.
    //

    UpdateRequest->MessageType = KerbUpdateAddressesMessage;
    UpdateRequest->AddressCount = SocketAddressCount;


    //
    // Pass them to Kerberos.
    //

    (VOID) LsaICallPackage(
                &KerberosPackageName,
                UpdateRequest,
                UpdateRequestSize,
                &OutputBuffer,
                &OutputBufferSize,
                &SubStatus );

    NetpMemoryFree( UpdateRequest );

}



VOID
NlReadRegSocketAddressList(
    VOID
    )
/*++

Routine Description:

    Read the Socket address list from the registry and save them in the globals

Arguments:

    None

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;

    LPSOCKET_ADDRESS_LIST SocketAddressList = NULL;
    HKEY ParmHandle = NULL;
    ULONG SocketAddressSize = 0;

    int i;
    DWORD LocalEntryCount;
    DWORD RegType;

    //
    // Open the key for Netlogon\Private
    //

    ParmHandle = NlOpenNetlogonKey( NL_PRIVATE_KEY );

    if (ParmHandle == NULL) {
        NlPrint(( NL_CRITICAL,
                  "Cannot NlOpenNetlogonKey to get socket address list.\n" ));
        goto Cleanup;
    }

    //
    // Read the entry from the registry
    //

    SocketAddressSize = 0;
    NetStatus = RegQueryValueExW( ParmHandle,
                                  NETLOGON_KEYWORD_SOCKETADDRESSLIST,
                                  0,              // Reserved
                                  &RegType,
                                  NULL,
                                  &SocketAddressSize );

    if ( NetStatus == NO_ERROR || NetStatus == ERROR_MORE_DATA) {
        SocketAddressList = LocalAlloc( 0, SocketAddressSize );

        if ( SocketAddressList == NULL ) {
            goto Cleanup;
        }

        NetStatus = RegQueryValueExW( ParmHandle,
                                      NETLOGON_KEYWORD_SOCKETADDRESSLIST,
                                      0,              // Reserved
                                      &RegType,
                                      (LPBYTE)SocketAddressList,
                                      &SocketAddressSize );

    }

    if ( NetStatus != NO_ERROR ) {
        if ( NetStatus != ERROR_FILE_NOT_FOUND ) {
            NlPrint(( NL_CRITICAL,
                      "Cannot RegQueryValueExW to get socket address list. %ld\n",
                      NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Validate the data.
    //

    if ( RegType != REG_BINARY ) {
        NlPrint(( NL_CRITICAL,
                  "SocketAddressList isn't REG_BINARY %ld.\n",
                  RegType ));
        goto Cleanup;
    }

    if ( SocketAddressSize < offsetof(SOCKET_ADDRESS_LIST, Address) ) {
        NlPrint(( NL_CRITICAL,
                  "SocketAddressList is too small %ld.\n",
                  SocketAddressSize ));
        goto Cleanup;
    }

    if ( SocketAddressList->iAddressCount * sizeof(SOCKET_ADDRESS) >
         SocketAddressSize - offsetof(SOCKET_ADDRESS_LIST, Address) ) {
        NlPrint(( NL_CRITICAL,
                  "SocketAddressList size wrong %ld %ld.\n",
                  SocketAddressList->iAddressCount * sizeof(SOCKET_ADDRESS),
                  SocketAddressSize - offsetof(SOCKET_ADDRESS_LIST, Address) ));
        goto Cleanup;
    }

    //
    // Convert all offsets to pointers
    //

    for ( i=0; i<SocketAddressList->iAddressCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;

        //
        // Ensure the offset and lengths are valid
        //

        SocketAddress = &SocketAddressList->Address[i];

        if ( ((DWORD_PTR)SocketAddress->lpSockaddr) >= SocketAddressSize ||
             (DWORD)SocketAddress->iSockaddrLength >= SocketAddressSize ||
             ((DWORD_PTR)SocketAddress->lpSockaddr)+SocketAddress->iSockaddrLength > SocketAddressSize ) {
            NlPrint(( NL_CRITICAL,
                      "SocketAddressEntry bad %ld %p %ld.\n",
                      i,
                      ((DWORD_PTR)SocketAddress->lpSockaddr),
                      SocketAddress->iSockaddrLength ));
            goto Cleanup;
        }

        SocketAddress->lpSockaddr = (LPSOCKADDR)
            (((LPBYTE)SocketAddressList) + ((DWORD_PTR)SocketAddress->lpSockaddr) );

        //
        // If the address isn't valid,
        //  blow it away.
        //
        SocketAddress = &SocketAddressList->Address[i];

        if ( SocketAddress->iSockaddrLength == 0 ||
             SocketAddress->lpSockaddr == NULL ||
             SocketAddress->lpSockaddr->sa_family != AF_INET ||
             ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr == 0 ) {
            NlPrint(( NL_CRITICAL,
                      "SocketAddressEntry bogus.\n" ));
            goto Cleanup;
        }

    }

    //
    // Swap the new list into the global.
    //

    EnterCriticalSection( &NlGlobalTransportCritSect );
    NlAssert( NlGlobalWinsockPnpAddresses == NULL );
    SocketAddressSize -= offsetof(SOCKET_ADDRESS_LIST, Address);
    if ( SocketAddressSize > 0 ) {
        NlGlobalWinsockPnpAddresses = SocketAddressList;
        SocketAddressList = NULL;
    }
    NlGlobalWinsockPnpAddressSize = SocketAddressSize;
    LeaveCriticalSection( &NlGlobalTransportCritSect );

Cleanup:
    if ( SocketAddressList != NULL ) {
        LocalFree( SocketAddressList );
    }

    if ( ParmHandle != NULL ) {
        RegCloseKey( ParmHandle );
    }

    return;
}



BOOLEAN
NlHandleWsaPnp(
    VOID
    )
/*++

Routine Description:

    Handle a WSA PNP event that IP addresses have changed

Arguments:

    None

Return Value:

    TRUE if the address list has changed

--*/
{
    NET_API_STATUS NetStatus;
    BOOLEAN RetVal = FALSE;
    DWORD BytesReturned;
    LPSOCKET_ADDRESS_LIST SocketAddressList = NULL;
    HKEY ParmHandle = NULL;
    LPSOCKET_ADDRESS_LIST RegBuffer = NULL;
    ULONG SocketAddressSize = 0;
    int i;
    int j;
    int MaxAddressCount;

    //
    // Ask for notification of address changes.
    //

    if ( NlGlobalWinsockPnpSocket == INVALID_SOCKET ) {
        return FALSE;
    }

    NetStatus = WSAIoctl( NlGlobalWinsockPnpSocket,
                          SIO_ADDRESS_LIST_CHANGE,
                          NULL, // No input buffer
                          0,    // No input buffer
                          NULL, // No output buffer
                          0,    // No output buffer
                          &BytesReturned,
                          NULL, // No overlapped,
                          NULL );   // Not async

    if ( NetStatus != 0 ) {
        NetStatus = WSAGetLastError();
        if ( NetStatus != WSAEWOULDBLOCK) {
            NlPrint(( NL_CRITICAL,
                      "NlHandleWsaPnp: Cannot WSAIoctl SIO_ADDRESS_LIST_CHANGE %ld\n",
                      NetStatus ));
            return FALSE;
        }
    }

    //
    // Get the list of IP addresses for this machine.
    //

    BytesReturned = 150; // Initial guess
    for (;;) {

        //
        // Allocate a buffer that should be big enough.
        //

        if ( SocketAddressList != NULL ) {
            LocalFree( SocketAddressList );
        }

        SocketAddressList = LocalAlloc( 0, BytesReturned );

        if ( SocketAddressList == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            NlPrint(( NL_CRITICAL,
                      "NlHandleWsaPnp: Cannot allocate buffer for WSAIoctl SIO_ADDRESS_LIST_QUERY %ld\n",
                      NetStatus ));
            goto Cleanup;
        }


        //
        // Get the list of IP addresses
        //

        NetStatus = WSAIoctl( NlGlobalWinsockPnpSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL, // No input buffer
                              0,    // No input buffer
                              (PVOID) SocketAddressList,
                              BytesReturned,
                              &BytesReturned,
                              NULL, // No overlapped,
                              NULL );   // Not async

        if ( NetStatus != 0 ) {
            NetStatus = WSAGetLastError();
            //
            // If the buffer isn't big enough, try again.
            //
            if ( NetStatus == WSAEFAULT ) {
                continue;
            }

            NlPrint(( NL_CRITICAL,
                      "NlHandleWsaPnp: Cannot WSAIoctl SIO_ADDRESS_LIST_QUERY %ld %ld\n",
                      NetStatus,
                      BytesReturned ));
            goto Cleanup;
        }

        break;
    }


    //
    // Weed out any zero IP addresses and other invalid addresses
    //

    EnterCriticalSection( &NlGlobalTransportCritSect );
    j=0;
    NlPrint(( NL_SERVER_SESS, "Winsock Addrs:" ));
    for ( i=0; i<SocketAddressList->iAddressCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;

        //
        // Copy this address to the front of the list.
        //
        SocketAddressList->Address[j] = SocketAddressList->Address[i];

        //
        // If the address isn't valid,
        //  skip it.
        //
        SocketAddress = &SocketAddressList->Address[j];

        if ( SocketAddress->iSockaddrLength == 0 ||
             SocketAddress->lpSockaddr == NULL ||
             SocketAddress->lpSockaddr->sa_family != AF_INET ||
             ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr == 0 ) {


        //
        // Otherwise keep it.
        //
        } else {

#if  NETLOGONDBG
            ULONG IpAddress;
            CHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1];
            IpAddress = ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr;
            NetpIpAddressToStr( IpAddress, IpAddressString );
            NlPrint(( NL_SERVER_SESS, " %s", IpAddressString ));
#endif // NETLOGONDBG

            SocketAddressSize += sizeof(SOCKET_ADDRESS) + SocketAddress->iSockaddrLength;
            j++;
        }

    }
    SocketAddressList->iAddressCount = j;
    NlPrint(( NL_SERVER_SESS, " (%ld) ", j ));

    //
    // See if the list has changed
    //

    if ( NlGlobalWinsockPnpAddresses == NULL ) {
        if ( SocketAddressSize > 0) {
            NlPrint(( NL_SERVER_SESS, "List used to be empty." ));
            RetVal = TRUE;
        }

    } else if ( SocketAddressSize == 0 ) {
        NlPrint(( NL_SERVER_SESS, "List is now empty." ));
        RetVal = TRUE;

    } else if ( NlGlobalWinsockPnpAddresses->iAddressCount !=
                SocketAddressList->iAddressCount ) {
        NlPrint(( NL_SERVER_SESS, "List size changed %ld %ld.",
                    NlGlobalWinsockPnpAddresses->iAddressCount,
                    SocketAddressList->iAddressCount ));
        RetVal = TRUE;

    } else {
        for ( i=0; i<SocketAddressList->iAddressCount; i++ ) {
            if ( SocketAddressList->Address[i].iSockaddrLength !=
                 NlGlobalWinsockPnpAddresses->Address[i].iSockaddrLength ) {
                NlPrint(( NL_SERVER_SESS, "Sockaddrlen changed." ));
                RetVal = TRUE;
                break;
            }
            if ( !RtlEqualMemory(
                    SocketAddressList->Address[i].lpSockaddr,
                    NlGlobalWinsockPnpAddresses->Address[i].lpSockaddr,
                    SocketAddressList->Address[i].iSockaddrLength ) ) {
                NlPrint(( NL_SERVER_SESS, "Address changed." ));
                RetVal = TRUE;
                break;
            }

        }
    }
    NlPrint(( NL_SERVER_SESS, "\n" ));


    //
    // Swap the new list into the global.
    //
    if ( NlGlobalWinsockPnpAddresses != NULL ) {
        LocalFree( NlGlobalWinsockPnpAddresses );
        NlGlobalWinsockPnpAddresses = NULL;
    }
    if ( SocketAddressSize > 0 ) {
        NlGlobalWinsockPnpAddresses = SocketAddressList;
        SocketAddressList = NULL;
    }
    NlGlobalWinsockPnpAddressSize = SocketAddressSize;
    LeaveCriticalSection( &NlGlobalTransportCritSect );

    //
    // Notify Kerberos of the list of addresses.
    //

    if ( RetVal ) {
        NlNotifyKerberosOfIpAddresses();
    }

    //
    // If the list changed,
    //  save it in the registry
    //

    if ( RetVal ) {
        ULONG RegBufferSize;
        ULONG RegEntryCount;

        //
        // Grab a copy of the address list with relative offsets and a header.
        //

        RegEntryCount = NlTransportGetIpAddresses(
                                offsetof(SOCKET_ADDRESS_LIST, Address),
                                TRUE,   // Return offsets and not pointers
                                (PSOCKET_ADDRESS *)&RegBuffer,
                                &RegBufferSize );

        //
        // If we have no IP addresses, NlTransportGetIpAddresses has allocated
        //  the header only and returned the size of the header as the size of the
        //  allocated buffer. In this case, set the size of the buffer to 0 in
        //  order to clean up the registry value.
        //

        if ( RegBufferSize == offsetof(SOCKET_ADDRESS_LIST, Address) ) {
            RegBufferSize = 0;
        }

        if ( RegBuffer != NULL ) {

            //
            // Fill in the header.
            //

            RegBuffer->iAddressCount = RegEntryCount;

            //
            // Open the key for Netlogon\Private
            //

            ParmHandle = NlOpenNetlogonKey( NL_PRIVATE_KEY );

            if (ParmHandle == NULL) {
                NlPrint(( NL_CRITICAL,
                          "Cannot NlOpenNetlogonKey to save IP address list.\n" ));
            } else {

                NetStatus = RegSetValueExW( ParmHandle,
                                            NETLOGON_KEYWORD_SOCKETADDRESSLIST,
                                            0,              // Reserved
                                            REG_BINARY,
                                            (LPBYTE)RegBuffer,
                                            RegBufferSize );

                if ( NetStatus != ERROR_SUCCESS ) {
                    NlPrint(( NL_CRITICAL,
                              "Cannot write '%ws' key to registry %ld.\n",
                              NETLOGON_KEYWORD_SOCKETADDRESSLIST,
                              NetStatus ));
                }
            }

        }

    }


Cleanup:
    if ( SocketAddressList != NULL ) {
        LocalFree( SocketAddressList );
    }

    if ( ParmHandle != NULL ) {
        RegCloseKey( ParmHandle );
    }

    if ( RegBuffer != NULL ) {
        NetpMemoryFree( RegBuffer );
    }

    return RetVal;
}




NET_API_STATUS
NlTransportOpen(
    VOID
    )
/*++

Routine Description:

    Initialize the list of transports

Arguments:

    None

Return Value:

    Status of the operation

--*/
{
    NET_API_STATUS NetStatus;
    PLMDR_TRANSPORT_LIST TransportList;
    PLMDR_TRANSPORT_LIST TransportEntry;

    //
    // Enumerate the transports supported by the server.
    //

    NetStatus = NlBrowserGetTransportList( &TransportList );

    if ( NetStatus != NERR_Success ) {
        NlPrint(( NL_CRITICAL, "Cannot NlBrowserGetTransportList %ld\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Loop through the list of transports building a local list.
    //

    TransportEntry = TransportList;

    while (TransportEntry != NULL) {
        BOOLEAN IpTransportChanged;
        (VOID) NlTransportAddTransportName(
                    TransportEntry->TransportName,
                    &IpTransportChanged );

        if (TransportEntry->NextEntryOffset == 0) {
            TransportEntry = NULL;
        } else {
            TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+
                                TransportEntry->NextEntryOffset);
        }

    }

    MIDL_user_free(TransportList);

    //
    // Open a socket to get winsock PNP notifications on.
    //

    NlGlobalWinsockPnpSocket = WSASocket( AF_INET,
                           SOCK_DGRAM,
                           0, // PF_INET,
                           NULL,
                           0,
                           0 );

    if ( NlGlobalWinsockPnpSocket == INVALID_SOCKET ) {
        NetStatus = WSAGetLastError();

        //
        // If the address family isn't supported,
        //  we're done here.
        //
        if ( NetStatus == WSAEAFNOSUPPORT ) {
            NetStatus = NO_ERROR;
            goto Cleanup;
        }
        NlPrint(( NL_CRITICAL, "Can't WSASocket %ld\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Open an event to wait on.
    //

    NlGlobalWinsockPnpEvent = CreateEvent(
                                  NULL,     // No security ettibutes
                                  FALSE,    // Auto reset
                                  FALSE,    // Initially not signaled
                                  NULL);    // No Name

    if ( NlGlobalWinsockPnpEvent == NULL ) {
        NetStatus = GetLastError();
        NlPrint((NL_CRITICAL, "Cannot create Winsock PNP event %ld\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Associate the event with new addresses becoming available on the socket.
    //

    NetStatus = WSAEventSelect( NlGlobalWinsockPnpSocket, NlGlobalWinsockPnpEvent, FD_ADDRESS_LIST_CHANGE );

    if ( NetStatus != 0 ) {
        NetStatus = WSAGetLastError();
        NlPrint(( NL_CRITICAL, "Can't WSAEventSelect %ld\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Grab the addresses from the registry (So we can properly detect if the list changed)
    //

    NlReadRegSocketAddressList();

    //
    // Get the initial list of IP addresses
    //

    if ( NlHandleWsaPnp() ) {

        NlPrint(( NL_CRITICAL, "Address list changed since last boot. (Forget DynamicSiteName.)\n" ));

        //
        // Indicate that we no longer know what site we're in.
        //
        NlSetDynamicSiteName( NULL );
    }

Cleanup:
    return NetStatus;
}

BOOL
NlTransportAddTransportName(
    IN LPWSTR TransportName,
    OUT PBOOLEAN IpTransportChanged
    )
/*++

Routine Description:

    Adds a transport name to the list of transports.

Arguments:

    TransportName - Name of the transport to add

    IpTransportChanged - Returns TRUE if an IP transport is added or
        the IP address of the transport changes.

Return Value:

    TRUE - Success

    FALSE - memory allocation failure.

--*/
{
    DWORD TransportNameLength;
    PLIST_ENTRY ListEntry;
    PNL_TRANSPORT TransportEntry = NULL;
    ULONG OldIpAddress;
    BOOLEAN WasIpTransport;

    //
    // Initialization.
    //

    *IpTransportChanged = FALSE;

    //
    // If the entry already exists, use it.
    //

    EnterCriticalSection( &NlGlobalTransportCritSect );
    for ( ListEntry = NlGlobalTransportList.Flink ;
          ListEntry != &NlGlobalTransportList ;
          ListEntry = ListEntry->Flink) {


        TransportEntry = CONTAINING_RECORD( ListEntry, NL_TRANSPORT, Next );

        if ( _wcsicmp( TransportName, TransportEntry->TransportName ) == 0 ) {
            break;
        }

        TransportEntry = NULL;
    }

    //
    // If there isn't already a transport entry,
    //  allocate and initialize one.
    //

    if ( TransportEntry == NULL ) {

        //
        // Allocate a buffer for the new entry.
        //

        TransportNameLength = wcslen( TransportName );
        TransportEntry = LocalAlloc( 0,
                                     sizeof(NL_TRANSPORT) +
                                         TransportNameLength * sizeof(WCHAR) );

        if ( TransportEntry == NULL ) {
            LeaveCriticalSection( &NlGlobalTransportCritSect );
            NlPrint(( NL_CRITICAL, "NlTransportAddTransportName: no memory\n" ));
            return FALSE;
        }

        //
        // Build the new entry and link it onto the tail of the list.
        //

        wcscpy( TransportEntry->TransportName, TransportName );
        TransportEntry->IpAddress = 0;
        TransportEntry->IsIpTransport = FALSE;
        TransportEntry->DeviceHandle = INVALID_HANDLE_VALUE;

        //
        // Flag NwLnkIpx since it is poorly behaved.
        //
        // 1) The redir doesn't support it.
        // 2) A datagram sent to it doesn't support the 0x1C name.
        //

        if ( _wcsicmp( TransportName, L"\\Device\\NwlnkIpx" ) == 0 ) {
            TransportEntry->DirectHostIpx = TRUE;
        } else {
            TransportEntry->DirectHostIpx = FALSE;
        }


        InsertTailList( &NlGlobalTransportList, &TransportEntry->Next );
    }

    //
    // Under all circumstances, update the IP address.
    //

    TransportEntry->TransportEnabled = TRUE;

    OldIpAddress = TransportEntry->IpAddress;
    WasIpTransport = TransportEntry->IsIpTransport;

    TransportEntry->IsIpTransport = NlTransportGetIpAddress(
                                        TransportName,
                                        &TransportEntry->IpAddress );

    if ( TransportEntry->IsIpTransport ) {

        //
        // If this is a new IP transport,
        //  count it.
        //

        if ( !WasIpTransport ) {
            NlGlobalIpTransportCount ++;
            *IpTransportChanged = TRUE;
        }

        //
        // If the transport was just added,
        //  Indicate so.
        //

        if ( OldIpAddress == 0 ) {
#if  NETLOGONDBG
            CHAR IpAddress[NL_IP_ADDRESS_LENGTH+1];
            NetpIpAddressToStr( TransportEntry->IpAddress, IpAddress );
            NlPrint(( NL_SERVER_SESS, "%ws: Transport Added (%s)\n", TransportName, IpAddress ));
#endif // NETLOGONDBG
            *IpTransportChanged = TRUE;

        //
        // If the IP address hasn't changed,
        //  this is simply a superfluous PNP notification.
        //
        } else if ( OldIpAddress == TransportEntry->IpAddress ) {
#if  NETLOGONDBG
            CHAR IpAddress[NL_IP_ADDRESS_LENGTH+1];
            NetpIpAddressToStr( TransportEntry->IpAddress, IpAddress );
            NlPrint(( NL_SERVER_SESS, "%ws: Transport Address is still (%s)\n", TransportName, IpAddress ));
#endif // NETLOGONDBG

        //
        // If the IP Address changed,
        //  let the caller know.
        //
        } else {
#if  NETLOGONDBG
            CHAR IpAddress[NL_IP_ADDRESS_LENGTH+1];
            CHAR OldIpAddressString[NL_IP_ADDRESS_LENGTH+1];
            NetpIpAddressToStr( OldIpAddress, OldIpAddressString );
            NetpIpAddressToStr( TransportEntry->IpAddress, IpAddress );
            NlPrint(( NL_SERVER_SESS,
                      "%ws: Transport Ip Address changed from (%s) to (%s)\n",
                      TransportName,
                      OldIpAddressString,
                      IpAddress ));
#endif // NETLOGONDBG
            *IpTransportChanged = TRUE;
        }

    //
    // For non-IP transports,
    //  there's not much to do.
    //

    } else {

        //
        // If the transport used to be an IP transport,
        //  that doesn't seem possible (but) ...
        //

        if ( WasIpTransport ) {
            NlGlobalIpTransportCount --;
            *IpTransportChanged = TRUE;
        }

        NlPrint(( NL_SERVER_SESS, "%ws: Transport Added\n", TransportName ));
    }

    LeaveCriticalSection( &NlGlobalTransportCritSect );

    return TRUE;;
}

BOOLEAN
NlTransportDisableTransportName(
    IN LPWSTR TransportName
    )
/*++

Routine Description:

    Disables a transport name on the list of transports.

    The TransportName is never removed thus preventing us from having to
    maintain reference counts.

Arguments:

    TransportName - Name of the transport to disable.

Return Value:

    Returns TRUE if an IP transport is disabled.

--*/
{
    PLIST_ENTRY ListEntry;

    //
    // Find this transport in the list of transports.
    //

    EnterCriticalSection( &NlGlobalTransportCritSect );
    for ( ListEntry = NlGlobalTransportList.Flink ;
          ListEntry != &NlGlobalTransportList ;
          ListEntry = ListEntry->Flink) {

        PNL_TRANSPORT TransportEntry;

        TransportEntry = CONTAINING_RECORD( ListEntry, NL_TRANSPORT, Next );

        if ( TransportEntry->TransportEnabled &&
             _wcsicmp( TransportName, TransportEntry->TransportName ) == 0 ) {
            ULONG OldIpAddress;

            TransportEntry->TransportEnabled = FALSE;
            OldIpAddress = TransportEntry->IpAddress;
            TransportEntry->IpAddress = 0;
            if ( TransportEntry->DeviceHandle != INVALID_HANDLE_VALUE ) {
                NtClose( TransportEntry->DeviceHandle );
                TransportEntry->DeviceHandle = INVALID_HANDLE_VALUE;
            }
            LeaveCriticalSection( &NlGlobalTransportCritSect );

            NlPrint(( NL_SERVER_SESS, "%ws: Transport Removed\n", TransportName ));
            return (OldIpAddress != 0);
        }
    }
    LeaveCriticalSection( &NlGlobalTransportCritSect );

    return FALSE;
}

PNL_TRANSPORT
NlTransportLookupTransportName(
    IN LPWSTR TransportName
    )
/*++

Routine Description:

    Returns a transport name equal to the one passed in.  However, the
    returned transport name is static and need not be freed.

Arguments:

    TransportName - Name of the transport to look up

Return Value:

    NULL - on any error

    Otherwise, returns a pointer to the transport structure.

--*/
{
    PLIST_ENTRY ListEntry;

    //
    // If we're not initialized yet,
    //  just return
    //

    if ( TransportName == NULL ) {
        return NULL;
    }

    //
    // Find this transport in the list of transports.
    //

    EnterCriticalSection( &NlGlobalTransportCritSect );
    for ( ListEntry = NlGlobalTransportList.Flink ;
          ListEntry != &NlGlobalTransportList ;
          ListEntry = ListEntry->Flink) {

        PNL_TRANSPORT TransportEntry;

        TransportEntry = CONTAINING_RECORD( ListEntry, NL_TRANSPORT, Next );

        if ( TransportEntry->TransportEnabled &&
             _wcsicmp( TransportName, TransportEntry->TransportName ) == 0 ) {
            LeaveCriticalSection( &NlGlobalTransportCritSect );
            return TransportEntry;
        }
    }
    LeaveCriticalSection( &NlGlobalTransportCritSect );

    return NULL;
}

PNL_TRANSPORT
NlTransportLookup(
    IN LPWSTR ClientName
    )
/*++

Routine Description:

    Determine what transport the specified client is using to access this
    server.

Arguments:

    ClientName - Name of the client connected to this server.

Return Value:

    NULL - The client isn't currently connected

    Otherwise, returns a pointer to the transport structure

--*/
{
    NET_API_STATUS NetStatus;
    PSESSION_INFO_502 SessionInfo502;
    DWORD EntriesRead;
    DWORD TotalEntries;
    DWORD i;
    DWORD BestTime;
    DWORD BestEntry;
    PNL_TRANSPORT Transport;

    WCHAR UncClientName[UNCLEN+1];


    //
    // Enumerate all the sessions from the particular client.
    //

    UncClientName[0] = '\\';
    UncClientName[1] = '\\';
    wcscpy( &UncClientName[2], ClientName );

    NetStatus = NetSessionEnum(
                    NULL,           // local
                    UncClientName,  // Client to query
                    NULL,           // user name
                    502,
                    (LPBYTE *)&SessionInfo502,
                    1024,           // PrefMaxLength
                    &EntriesRead,
                    &TotalEntries,
                    NULL );         // No resume handle

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
        NlPrint(( NL_CRITICAL,
                  "NlTransportLookup: " FORMAT_LPWSTR ": Cannot NetSessionEnum %ld\n",
                  UncClientName,
                  NetStatus ));
        return NULL;
    }

    if ( EntriesRead == 0 ) {
        NlPrint(( NL_CRITICAL,
                  "NlTransportLookup: " FORMAT_LPWSTR ": No session exists.\n",
                  UncClientName ));
        (VOID) NetApiBufferFree( SessionInfo502 );
        return NULL;
    }

    //
    // Loop through the list of transports finding the best one.
    //

    BestTime = 0xFFFFFFFF;

    for ( i=0; i<EntriesRead; i++ ) {
#ifdef notdef
        //
        // We're only looking for null sessions
        //
        if ( SessionInfo502[i].sesi502_username != NULL ) {
            continue;
        }

         NlPrint(( NL_SERVER_SESS, "NlTransportLookup: "
                   FORMAT_LPWSTR " as " FORMAT_LPWSTR " on " FORMAT_LPWSTR "\n",
                   UncClientName,
                   SessionInfo502[i].sesi502_username,
                   SessionInfo502[i].sesi502_transport ));
#endif // notdef

        //
        // Find the latest session
        //

        if ( BestTime > SessionInfo502[i].sesi502_idle_time ) {

            // NlPrint(( NL_SERVER_SESS, "NlTransportLookup: Best Entry\n" ));
            BestEntry = i;
            BestTime = SessionInfo502[i].sesi502_idle_time;
        }
    }

    //
    // If an entry was found,
    //  Find this transport in the list of transports.
    //

    if ( BestTime != 0xFFFFFFFF ) {
        Transport = NlTransportLookupTransportName(
                            SessionInfo502[BestEntry].sesi502_transport );
        if ( Transport == NULL ) {
            NlPrint(( NL_CRITICAL,
                      "NlTransportLookup: " FORMAT_LPWSTR ": Transport not found\n",
                      SessionInfo502[BestEntry].sesi502_transport ));
        } else {
            NlPrint(( NL_SERVER_SESS,
                      "NlTransportLookup: " FORMAT_LPWSTR ": Use Transport " FORMAT_LPWSTR "\n",
                      UncClientName,
                      Transport->TransportName ));
        }
    } else {
        Transport = NULL;
    }

    (VOID) NetApiBufferFree( SessionInfo502 );
    return Transport;
}


VOID
NlTransportClose(
    VOID
    )
/*++

Routine Description:

    Free the list of transports

Arguments:

    None

Return Value:

    Status of the operation

--*/
{
    PLIST_ENTRY ListEntry;
    PNL_TRANSPORT TransportEntry;

    //
    // Close the winsock PNP socket and event
    //
    EnterCriticalSection( &NlGlobalTransportCritSect );
    if ( NlGlobalWinsockPnpSocket != INVALID_SOCKET ) {
        closesocket( NlGlobalWinsockPnpSocket );
        NlGlobalWinsockPnpSocket = INVALID_SOCKET;
    }

    if ( NlGlobalWinsockPnpEvent != NULL ) {
        (VOID) CloseHandle( NlGlobalWinsockPnpEvent );
        NlGlobalWinsockPnpEvent = NULL;
    }

    if ( NlGlobalWinsockPnpAddresses != NULL ) {
        LocalFree( NlGlobalWinsockPnpAddresses );
        NlGlobalWinsockPnpAddresses = NULL;
    }
    NlGlobalWinsockPnpAddressSize = 0;

    //
    // Delete all of the TransportNames.
    //
    EnterCriticalSection( &NlGlobalTransportCritSect );
    while ( !IsListEmpty( &NlGlobalTransportList )) {
        ListEntry = RemoveHeadList( &NlGlobalTransportList );
        TransportEntry = CONTAINING_RECORD( ListEntry, NL_TRANSPORT, Next );
        if ( TransportEntry->DeviceHandle != INVALID_HANDLE_VALUE ) {
            NtClose( TransportEntry->DeviceHandle );
            TransportEntry->DeviceHandle = INVALID_HANDLE_VALUE;
        }
        LocalFree( TransportEntry );
    }
    NlGlobalIpTransportCount = 0;
    LeaveCriticalSection( &NlGlobalTransportCritSect );

}




PSERVER_SESSION
NlFindNamedServerSession(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR ComputerName
    )
/*++

Routine Description:

    Find the specified entry in the Server Session Table.

    Enter with the ServerSessionTable Sem locked


Arguments:

    DomainInfo - Hosted domain with session to this computer.

    ComputerName - The name of the computer on the client side of the
        secure channel.

Return Value:

    Returns a pointer to pointer to the found entry.  If there is no such
    entry, return a pointer to NULL.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    DWORD Index;
    CHAR UpcaseOemComputerName[CNLEN+1];
    ULONG OemComputerNameSize;

    //
    // Ensure the ServerSession Table is initialized.
    //

    if (DomainInfo->DomServerSessionHashTable == NULL) {
        return NULL;
    }


    //
    // Convert the computername to uppercase OEM for easier comparison.
    //

    Status = RtlUpcaseUnicodeToOemN(
                UpcaseOemComputerName,
                sizeof(UpcaseOemComputerName)-1,
                &OemComputerNameSize,
                ComputerName,
                wcslen(ComputerName)*sizeof(WCHAR) );

    if ( !NT_SUCCESS(Status) ) {
        return NULL;
    }

    UpcaseOemComputerName[OemComputerNameSize] = '\0';



    //
    // Loop through this hash chain trying the find the right entry.
    //

    Index = NlGetHashVal( UpcaseOemComputerName, SERVER_SESSION_HASH_TABLE_SIZE );

    for ( ListEntry = DomainInfo->DomServerSessionHashTable[Index].Flink ;
          ListEntry != &DomainInfo->DomServerSessionHashTable[Index] ;
          ListEntry = ListEntry->Flink) {

        PSERVER_SESSION ServerSession;

        ServerSession = CONTAINING_RECORD( ListEntry, SERVER_SESSION, SsHashList );

        //
        // Compare the worstation name
        //

        if ( lstrcmpA( UpcaseOemComputerName,
                       ServerSession->SsComputerName ) != 0 ) {
            continue;
        }

        return ServerSession;
    }

    return NULL;
}


VOID
NlSetServerSessionAttributesByTdoName(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING TdoName,
    IN ULONG TrustAttributes
    )
/*++

Routine Description:

    The function sets the specified TrustAttributes on all the server sessions
    from the domain specified by TdoName.

Arguments:

    DomainInfo - Hosted domain with session to this computer.

    TdoName - The Dns name of the TDO for the secure channel to find.

    TrustAttributes - TrustAttributes to set

Return Value:

    None

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    DWORD Index;
    UNICODE_STRING CanonicalTdoName;
    PSERVER_SESSION ServerSession;

    //
    // Initialization
    //

    RtlInitUnicodeString( &CanonicalTdoName, NULL );
    LOCK_SERVER_SESSION_TABLE( DomainInfo );

    //
    // Ensure the ServerSession Table is initialized.
    //

    if (DomainInfo->DomServerSessionTdoNameHashTable == NULL) {
        goto Cleanup;
    }

    //
    // Compute the canonical form of the name and the index into the hash table
    //

    Status = NlGetTdoNameHashVal( TdoName,
                                  &CanonicalTdoName,
                                  &Index );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Loop through this hash chain trying the find the right entries
    //

    for ( ListEntry = DomainInfo->DomServerSessionTdoNameHashTable[Index].Flink ;
          ListEntry != &DomainInfo->DomServerSessionTdoNameHashTable[Index] ;
          ListEntry = ListEntry->Flink) {

        ServerSession = CONTAINING_RECORD( ListEntry, SERVER_SESSION, SsTdoNameHashList );

        //
        // Compare the TDO name
        //  A case insensitive compare is done since the names are already canonicalized to compute the hash index
        //

        if ( RtlEqualUnicodeString( &CanonicalTdoName,
                                    &ServerSession->SsTdoName,
                                    FALSE ) ) {

            if ( TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) {
                if ( (ServerSession->SsFlags & SS_FOREST_TRANSITIVE) == 0 ) {
                    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                             "%wZ: server session from %s is now cross forest.\n",
                             &CanonicalTdoName,
                             ServerSession->SsComputerName ));
                }
                ServerSession->SsFlags |=  SS_FOREST_TRANSITIVE;
            } else {
                if ( ServerSession->SsFlags & SS_FOREST_TRANSITIVE ) {
                    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                             "%wZ: server session from %s is now NOT cross forest.\n",
                             &CanonicalTdoName,
                             ServerSession->SsComputerName ));
                }
                ServerSession->SsFlags &=  ~SS_FOREST_TRANSITIVE;
            }

        }

    }


Cleanup:
    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
    RtlFreeUnicodeString( &CanonicalTdoName );
    return;
}


NTSTATUS
NlInsertServerSession(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR ComputerName,
    IN LPWSTR TdoName OPTIONAL,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN DWORD Flags,
    IN ULONG AccountRid,
    IN ULONG NegotiatedFlags,
    IN PNL_TRANSPORT Transport OPTIONAL,
    IN PNETLOGON_SESSION_KEY SessionKey OPTIONAL,
    IN PNETLOGON_CREDENTIAL AuthenticationSeed OPTIONAL
    )
/*++

Routine Description:

    Inserts the described entry into the ServerSession Table.

    The server session entry is created for two reasons: 1) it represents
    the server side of a secure channel, and 2) on a PDC, it represents the
    BDC account for a BDC in the domain.  In the first role, it exists for
    the duration of the secure channel (and this routine is called when the
    client gets authenticated).  In the second role, it exists as
    long as the machine account exists (and this routine is called during
    netlogon startup for each BDC account).

    If an entry matching this ComputerName already exists
    in the ServerSession Table, that entry will be overwritten.

Arguments:

    DomainInfo - Hosted domain for this server session

    ComputerName - The name of the computer on the client side of the
        secure channel.

    TdoName - The name of the interdomain trust account.  This parameter is
        ignored if the SecureChannelType indicates this is not an uplevel interdomain trust.

    SecureChannelType - The type of the secure channel.

    Flags - Specifies the initial SsFlags to associate with the entry.
        If the SS_BDC bit is set, the structure is considered to represent
        a BDC account in the SAM database.

    AccountRid - Specifies the RID of the client account.

    NegotiatedFlags - Specifies the flags negotiated between the client
        and this server.

    Transport -- If this is a BDC secure channel, specifies the transport
        to use to communicate with the BDC.

    SessionKey -- Specifies th esession key to be used in the secure
        communication with the client.

    AuthenticationSeed - Specifies the Client Credential established as
        a result of the client authentication.

Return Value:

    NT STATUS code.

--*/
{
    NTSTATUS Status;
    PSERVER_SESSION ServerSession = NULL;
    UNICODE_STRING CanonicalTdoName;
    ULONG TdoNameIndex;

    //
    // Initialization
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    RtlInitUnicodeString( &CanonicalTdoName, NULL );


    //
    // Canonicalize the TdoName
    //

    if ( SecureChannelType == TrustedDnsDomainSecureChannel ) {
        UNICODE_STRING TdoNameString;

         //
         // Compute the canonical form of the name and the index into the hash table
         //

         RtlInitUnicodeString( &TdoNameString, TdoName );

         Status = NlGetTdoNameHashVal( &TdoNameString,
                                       &CanonicalTdoName,
                                       &TdoNameIndex );

         if ( !NT_SUCCESS(Status) ) {
             goto Cleanup;
         }
    }


    //
    // If we already have a server session for this client,
    //  check that the passed info is consistent with the
    //  existent one
    //

    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName);

    if ( ServerSession != NULL ) {
        BOOLEAN DeleteExistingSession = FALSE;

        //
        // Beware of server with two concurrent calls outstanding
        //  (must have rebooted.)
        // Namely, if the entry is currently locked, return an
        //  appropriate error.
        //
        if ( ServerSession->SsFlags & SS_LOCKED ) {
            NlPrint(( NL_CRITICAL,
                      "NlInsertServerSession: server session locked for %ws\n",
                      ComputerName ));

            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        //
        // If there is a mismatch in the type of the account,
        //  simply note that fact and override the existing
        //  one. The mismatch can happen if
        //
        // * The client has been authenticated as a BDC but the
        //   current session is for a non-BDC. This may occur
        //   if we haven't yet processed a SAM notification about
        //   the new BDC account or SAM hasn't notified us yet.
        // * The client has been authenticated as a non-BDC
        //   but the current session is for a BDC. This can
        //   occur if a machine had a BDC account and then later
        //   has been demoted or converted to a DC in another domain.
        // * This is a insertion of a new BDC account (that is not yet
        //   authenticated) but the current session is for a non-BDC.
        //   This can happen if the client was an authenticated  member
        //   server/workstation and has now been promoted to a BDC.
        //
        if ( SecureChannelType == ServerSecureChannel ) {
            //
            // Client comes in as a BDC but the current session
            //  is not for a BDC.
            //
            if ( (ServerSession->SsFlags & SS_BDC) == 0 ) {
                NlPrint(( NL_CRITICAL,
                   "NlInsertServerSession: BDC connecting on non-BDC channel %ws\n",
                   ComputerName ));
            }
        } else if ( ServerSession->SsFlags & SS_BDC ) {
            //
            // Client comes in as a non-BDC but the current session
            //  is for a BDC.
            //
            if ( SecureChannelType != NullSecureChannel ) {
                NlPrint(( NL_CRITICAL,
                    "NlInsertServerSession: non-BDC %ld connecting on BDC channel %ws\n",
                    SecureChannelType,
                    ComputerName ));
            }
        }

        //
        // If this is an interdomain secure channel,
        //  ensure the existing structure has the correct TDO name.
        //


       if ( SecureChannelType == TrustedDnsDomainSecureChannel ) {

            if ( ServerSession->SsSecureChannelType != TrustedDnsDomainSecureChannel ) {
                DeleteExistingSession = TRUE;
            } else {

                if ( !RtlEqualUnicodeString( &CanonicalTdoName,
                                             &ServerSession->SsTdoName,
                                             FALSE ) ) {
                      DeleteExistingSession = TRUE;
                }

            }
        }

        //
        // If the existing session is inadequate,
        //  delete it and create a new one.
        //

        if ( DeleteExistingSession ) {
            if ( !NlFreeServerSession( ServerSession )) {
                NlPrint(( NL_CRITICAL,
                          "NlInsertServerSession: server session cannot be freed %ws\n",
                          ComputerName ));

                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }
            ServerSession = NULL;
        }
    }

    //
    // If there is no current Server Session table entry,
    //  allocate one.
    //

    if ( ServerSession == NULL ) {
        DWORD Index;
        ULONG ComputerNameSize;
        ULONG Size;


        //
        // Allocate the ServerSession Entry
        //

        Size = sizeof(SERVER_SESSION);
        if ( SecureChannelType == TrustedDnsDomainSecureChannel ) {
            Size += CanonicalTdoName.Length+sizeof(WCHAR);
        }

        ServerSession = NetpMemoryAllocate( Size );

        if (ServerSession == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlZeroMemory( ServerSession, Size );


        //
        // Fill in the fields of the ServerSession entry.
        //

        ServerSession->SsSecureChannelType = NullSecureChannel;
        ServerSession->SsSync = NULL;
        InitializeListHead( &ServerSession->SsBdcList );
        InitializeListHead( &ServerSession->SsPendingBdcList );
        ServerSession->SsDomainInfo = DomainInfo;

        //
        // Convert the computername to uppercase OEM for easier comparison.
        //

        Status = RtlUpcaseUnicodeToOemN(
                    ServerSession->SsComputerName,
                    sizeof(ServerSession->SsComputerName)-1,
                    &ComputerNameSize,
                    ComputerName,
                    wcslen(ComputerName)*sizeof(WCHAR) );

        if ( !NT_SUCCESS(Status) ) {
            NetpMemoryFree( ServerSession );
            goto Cleanup;
        }

        ServerSession->SsComputerName[ComputerNameSize] = '\0';

        //
        // Allocate a hash table if there isn't one yet.
        //

        if ( DomainInfo->DomServerSessionHashTable == NULL ) {
            DWORD i;

            DomainInfo->DomServerSessionHashTable = (PLIST_ENTRY)
                NetpMemoryAllocate( sizeof(LIST_ENTRY) *SERVER_SESSION_HASH_TABLE_SIZE);

            if ( DomainInfo->DomServerSessionHashTable == NULL ) {
                NetpMemoryFree( ServerSession );
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            for ( i=0; i< SERVER_SESSION_HASH_TABLE_SIZE; i++ ) {
                InitializeListHead( &DomainInfo->DomServerSessionHashTable[i] );
            }

        }

        //
        // Do interdomain trust specific initialization
        //

        if ( SecureChannelType == TrustedDnsDomainSecureChannel ) {
            LPBYTE Where;

            //
            // Copy the TDO name into the buffer.
            //  Copy it in canonical form for faster comparison later.
            //

            Where = (LPBYTE)(ServerSession+1);

            ServerSession->SsTdoName.Buffer = (LPWSTR)Where;
            ServerSession->SsTdoName.MaximumLength = CanonicalTdoName.Length + sizeof(WCHAR);
            ServerSession->SsTdoName.Length = CanonicalTdoName.Length;

            RtlCopyMemory( Where, CanonicalTdoName.Buffer, CanonicalTdoName.Length + sizeof(WCHAR) );
            ServerSession->SsTdoName.Buffer[ CanonicalTdoName.Length/sizeof(WCHAR) ] = '\0';


            //
            // Allocate a TdoName hash table if there isn't one yet.
            //

            if ( DomainInfo->DomServerSessionTdoNameHashTable == NULL ) {
                DWORD i;

                DomainInfo->DomServerSessionTdoNameHashTable = (PLIST_ENTRY)
                    NetpMemoryAllocate( sizeof(LIST_ENTRY) *SERVER_SESSION_TDO_NAME_HASH_TABLE_SIZE);

                if ( DomainInfo->DomServerSessionTdoNameHashTable == NULL ) {
                    NetpMemoryFree( ServerSession );
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                for ( i=0; i< SERVER_SESSION_TDO_NAME_HASH_TABLE_SIZE; i++ ) {
                    InitializeListHead( &DomainInfo->DomServerSessionTdoNameHashTable[i] );
                }

            }

            //
            // Insert the entry in the TDO name hash table.
            //

            InsertHeadList( &DomainInfo->DomServerSessionTdoNameHashTable[TdoNameIndex],
                            &ServerSession->SsTdoNameHashList );

        }


        //
        // Link the allocated entry into the head of hash table.
        //
        // The theory is we lookup new entries more frequently than older
        // entries.
        //

        Index = NlGetHashVal( ServerSession->SsComputerName, SERVER_SESSION_HASH_TABLE_SIZE );

        InsertHeadList( &DomainInfo->DomServerSessionHashTable[Index],
                        &ServerSession->SsHashList );

        //
        // Link this entry onto the tail of the Sequential ServerSessionTable.
        //

        InsertTailList( &DomainInfo->DomServerSessionTable, &ServerSession->SsSeqList );
    }

    //
    // Initialize BDC specific fields.
    //

    if ( Flags & SS_BDC ) {

        //
        // If we don't yet have this entry on the BDC list,
        //  add it.
        //
        if ( (ServerSession->SsFlags & SS_BDC) == 0 ) {

            //
            // Insert this entry at the front of the list of BDCs
            //
            InsertHeadList( &NlGlobalBdcServerSessionList,
                            &ServerSession->SsBdcList );
            NlGlobalBdcServerSessionCount ++;
        }
    }

    //
    // Initialize other fields
    //

    ServerSession->SsFlags |= Flags;

    // NlAssert( ServerSession->SsAccountRid == 0 ||
    //           ServerSession->SsAccountRid == AccountRid );
    // if ( AccountRid != 0 ) {
        ServerSession->SsAccountRid = AccountRid;
    // }

    //
    // If we're doing a new session setup,
    //  set the field that we learned from the session setup.
    //

    if ( AuthenticationSeed != NULL ) {

        ServerSession->SsCheck = 0;

        ServerSession->SsSecureChannelType = SecureChannelType;
        ServerSession->SsNegotiatedFlags = NegotiatedFlags;
        ServerSession->SsTransport = Transport;

        ServerSession->SsFlags = ((USHORT) Flags) |
            (ServerSession->SsFlags & SS_PERMANENT_FLAGS);

        ServerSession->SsAuthenticationSeed = *AuthenticationSeed;
    }

    if ( SessionKey != NULL ) {
        NlAssert( sizeof(*SessionKey) <= sizeof(ServerSession->SsSessionKey) );
        RtlCopyMemory( &ServerSession->SsSessionKey,
                       SessionKey,
                       sizeof( *SessionKey ) );
    }

    Status = STATUS_SUCCESS;

Cleanup:
    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

    RtlFreeUnicodeString( &CanonicalTdoName );
    return Status;
}


BOOLEAN
NlFreeServerSession(
    IN PSERVER_SESSION ServerSession
    )
/*++

Routine Description:

    Free the specified Server Session table entry.

    This routine is called with the Server Session table locked.

Arguments:

    ServerSession - Specifies a pointer to the server session entry
        to delete.

Return Value:

    TRUE - the structure was deleted now
    FALSE - the structure will be deleted later

--*/
{


    //
    // If someone has an outstanding pointer to this entry,
    //  delay the deletion for now.
    //

    if ( ServerSession->SsFlags & SS_LOCKED ) {
        ServerSession->SsFlags |= SS_DELETE_ON_UNLOCK;
        NlPrintDom((NL_SERVER_SESS, ServerSession->SsDomainInfo,
                "NlFreeServerSession: %s: Tried to free locked server session\n",
                ServerSession->SsComputerName ));
        return FALSE;
    }

    //
    // If this entry represents a BDC account,
    //  don't delete the entry until the account is deleted.
    //

    if ( (ServerSession->SsFlags & SS_BDC) != 0 &&
         (ServerSession->SsFlags & SS_BDC_FORCE_DELETE) == 0 ) {
        NlPrint((NL_SERVER_SESS,
                "NlFreeServerSession: %s: Didn't delete server session with BDC account.\n",
                 ServerSession->SsComputerName ));
        return FALSE;
    }

    NlPrintDom((NL_SERVER_SESS, ServerSession->SsDomainInfo,
             "NlFreeServerSession: %s: Freed server session\n",
             ServerSession->SsComputerName ));

    //
    // Delink the entry from the computername hash list.
    //

    RemoveEntryList( &ServerSession->SsHashList );

    //
    // Delink the entry from the TdoName hash list.
    //

    if ( ServerSession->SsSecureChannelType == TrustedDnsDomainSecureChannel ) {
        RemoveEntryList( &ServerSession->SsTdoNameHashList );
    }

    //
    // Delink the entry from the sequential list.
    //

    RemoveEntryList( &ServerSession->SsSeqList );


    //
    // Handle special cleanup for the BDC_SERVER_SESSION
    //

    if ( ServerSession->SsFlags & SS_BDC ) {

        //
        // Remove the entry from the list of BDCs
        //

        RemoveEntryList( &ServerSession->SsBdcList );
        NlGlobalBdcServerSessionCount --;

        //
        // Remove the entry from the list of pending BDCs
        //

        if ( ServerSession->SsFlags & SS_PENDING_BDC ) {
            NlRemovePendingBdc( ServerSession );
        }


        //
        // Clean up an sync context for this entry.
        //

        if ( ServerSession->SsSync != NULL ) {
            CLEAN_SYNC_CONTEXT( ServerSession->SsSync );
            NetpMemoryFree( ServerSession->SsSync );
        }

    }

    //
    // Delete the entry
    //

    NetpMemoryFree( ServerSession );

    return TRUE;

}


VOID
NlUnlockServerSession(
    IN PSERVER_SESSION ServerSession
    )
/*++

Routine Description:

    Unlock the specified Server Session table entry.

Arguments:

    ServerSession - Specifies a pointer to the server session entry to unlock.

Return Value:

--*/
{

    LOCK_SERVER_SESSION_TABLE( ServerSession->SsDomainInfo );

    //
    // Unlock the entry.
    //

    NlAssert( ServerSession->SsFlags & SS_LOCKED );
    ServerSession->SsFlags &= ~SS_LOCKED;

    //
    // If someone wanted to delete the entry while we had it locked,
    //  finish the deletion.
    //

    if ( ServerSession->SsFlags & SS_DELETE_ON_UNLOCK ) {
        NlFreeServerSession( ServerSession );
    //
    // Indicate activity from the BDC
    //

    } else if (ServerSession->SsFlags & SS_PENDING_BDC) {
        NlQuerySystemTime( &ServerSession->SsLastPulseTime );
    }

    UNLOCK_SERVER_SESSION_TABLE( ServerSession->SsDomainInfo );

}





VOID
NlFreeNamedServerSession(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR ComputerName,
    IN BOOLEAN AccountBeingDeleted
    )
/*++

Routine Description:

    Frees the specified entry in the ServerSession Table.

Arguments:

    DomainInfo - Hosted domain this session is for

    ComputerName - The name of the computer on the client side of the
        secure channel.

    AccountBeingDeleted - True to indicate that the account for this server
        session is being deleted.

Return Value:

    An NT status code.

--*/
{
    PSERVER_SESSION ServerSession;

    LOCK_SERVER_SESSION_TABLE( DomainInfo );

    //
    // Find the entry to delete.
    //

    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if ( ServerSession == NULL ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        return;
    }

    //
    // If the BDC account is being deleted,
    //  indicate that it's OK to delete this session structure.
    //

    if ( AccountBeingDeleted &&
         (ServerSession->SsFlags & SS_BDC) != 0 ) {
        ServerSession->SsFlags |= SS_BDC_FORCE_DELETE;
    }

    //
    // Actually delete the entry.
    //

    NlFreeServerSession( ServerSession );

    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

}



VOID
NlFreeServerSessionForAccount(
    IN PUNICODE_STRING AccountName
    )
/*++

Routine Description:

    Frees the specified entry in the ServerSession Table.

Arguments:

    AccountName - The name of the Account describing trust relationship being
        deleted.

Return Value:

    None

--*/
{
    WCHAR ComputerName[CNLEN+2];  // Extra for $ and \0

    //
    // Convert account name to a computer name by stripping the trailing
    // postfix.
    //

    if ( AccountName->Length + sizeof(WCHAR) > sizeof(ComputerName) ||
         AccountName->Length < SSI_ACCOUNT_NAME_POSTFIX_LENGTH * sizeof(WCHAR)){
            return;
    }

    RtlCopyMemory( ComputerName, AccountName->Buffer, AccountName->Length );
    ComputerName[ AccountName->Length / sizeof(WCHAR) -
        SSI_ACCOUNT_NAME_POSTFIX_LENGTH ] = L'\0';

    //
    // Free the named server session (if any)
    //

    NlFreeNamedServerSession( NlGlobalDomainInfo, ComputerName, TRUE );

}



VOID
NlServerSessionScavenger(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Scavenge the ServerSession Table.

    For now, just clean up the SyncContext if a client doesn't use it
    for a while.

Arguments:

    DomainInfo - Hosted domain to scavenge

Return Value:

    None.

--*/
{
    PLIST_ENTRY ListEntry;

    //
    // Find the next table entry that needs to be scavenged
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );

    for ( ListEntry = DomainInfo->DomServerSessionTable.Flink ;
          ListEntry != &DomainInfo->DomServerSessionTable ;
          ) {

        PSERVER_SESSION ServerSession;

        ServerSession =
            CONTAINING_RECORD(ListEntry, SERVER_SESSION, SsSeqList);


        //
        // Grab a pointer to the next entry before deleting this one
        //

        ListEntry = ListEntry->Flink;

        //
        // Increment the number of times this entry has been checked.
        //

        ServerSession->SsCheck ++;


        //
        // If this entry in the Server Session table has been around for many
        //  days without the client calling,
        //  free it.
        //
        // We wait several days before deleting an old entry.  If an entry is
        // deleted, the client has to rediscover us which may cause a lot of
        // net traffic.  After several days, that additional traffic isn't
        // significant.
        //

        if (ServerSession->SsCheck > KILL_SESSION_TIME ) {

            NlPrintDom((NL_SERVER_SESS, DomainInfo,
                    "NlServerSessionScavenger: %s: Free Server Session.\n",
                    ServerSession->SsComputerName ));

            NlFreeServerSession( ServerSession );


        //
        // If this entry in the Server Session table has timed out,
        //  Clean up the SAM resources.
        //

        } else if (ServerSession->SsCheck > MAX_WOC_INTERROGATE) {

            //
            // Clean up the SYNC context for this session freeing up
            //  the SAM resources.
            //
            //  We shouldn't timeout if the ServerSession Entry is locked,
            //  but we'll be careful anyway.
            //

            if ( (ServerSession->SsFlags & SS_LOCKED) == 0 &&
                  ServerSession->SsFlags & SS_BDC ) {

                if ( ServerSession->SsSync != NULL ) {

                    NlPrintDom((NL_SERVER_SESS, DomainInfo,
                            "NlServerSessionScavenger: %s: Cleanup Sync context.\n",
                            ServerSession->SsComputerName ));

                    CLEAN_SYNC_CONTEXT( ServerSession->SsSync );
                    NetpMemoryFree( ServerSession->SsSync );
                    ServerSession->SsSync = NULL;
                }
            }


        }

    } // end for

    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\ssiapi.h ===
/*++

Copyright (c) 1991-1996 Microsoft Corporation

Module Name:

    ssiapi.h

Abstract:

    Declartions of APIs used between Netlogon Services for the NT to NT case.

Author:

    Cliff Van Dyke (cliffv) 25-Jul-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

//////////////////////////////////////////////////////////////////////
//
// API Interfaces used only between Netlogon and itself.
//
//////////////////////////////////////////////////////////////////////


NTSTATUS
I_NetDatabaseDeltas (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN OUT PNLPR_MODIFIED_COUNT DomainModifiedCount,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArray,
    IN DWORD PreferredMaximumLength
    );

NTSTATUS
I_NetDatabaseSync (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN OUT PULONG SamSyncContext,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArray,
    IN DWORD PreferredMaximumLength
    );

NTSTATUS
I_NetDatabaseSync2 (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN SYNC_STATE RestartState,
    IN OUT PULONG SamSyncContext,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArray,
    IN DWORD PreferredMaximumLength
    );

NTSTATUS
I_NetDatabaseRedo (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN LPBYTE ChangeLogEntry,
    IN DWORD ChangeLogEntrySize,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArray
    );

//
// Indexes for data items returned in the generic RPC data
//  structure by I_NetServerGetTrustInfo.
//

#define NL_GENERIC_RPC_TRUST_ATTRIB_INDEX  0

NTSTATUS
I_NetServerGetTrustInfo(
    IN LPWSTR TrustedDcName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNewOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword,
    OUT PNL_GENERIC_RPC_DATA *TrustInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\ssiapi.c ===
/*++


Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    ssiapi.c

Abstract:

    Authentication and replication API routines (server side).

Author:

    Cliff Van Dyke (cliffv) 28-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.
--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//


#include "lsarepl.h"    // PackLsa ..
#include <ssiapi.h>
#include <netlogp.h>
#include <kerbcon.h>
#include <winldap.h>

#include <loghours.h>
#include <dnssrv.h>     // NetpSrv...
#include <ntldap.h>     // LDAP_SERVER_PERMISSIVE_MODIFY_OID_W

//
// Define the maximum number of deltas returned on any single call
//
//  Theoretically, MaxNumDeltas should be some function of
//  PreferredMaximumLength.  However, by the time you allow for
//  the large swing in PreferredMaximumLength allowed by the BDC replication
//  Governor and then not wanting this buffer to be ridiculously large
//  when the full 128K is asked for, we find that 1000 entries is always
//  a reasonable compromise.
//

#define MAX_DELTA_COUNT 1000

//
// Maximum number of deltas that can be generated by a single change log entry.
//
#define MAX_DELTAS_PER_CHANGELOG 4


//
// Host prefix for SPNs
//

#define NL_HOST_PREFIX  L"HOST/"

//
// work record for SPN update:
//

typedef struct _NL_SPN_UPDATE {
    BOOLEAN SetSpn;
    BOOLEAN SetDnsHostName;
    BOOLEAN WriteEventLogOnFailure;
    LPWSTR DnsHostName;
    LPWSTR NetbiosComputerName;
    LPWSTR UncDcName;
    LPWSTR NetbiosDomainName;
    LPWSTR DnsDomainName;
} NL_SPN_UPDATE, * PNL_SPN_UPDATE ;


//
// Challenge data struct and relevant defines
//

typedef struct _NL_CHALLENGE {

    //
    // Link to next challenge entry in NlGlobalChallengeList
    //  (Serialized by NlGlobalChallengeCritSect)
    //

    LIST_ENTRY ChNext;

    //
    // Challenge sent by the client
    //
    NETLOGON_CREDENTIAL ChClientChallenge;

    //
    // Challenge returned by the server (us)
    //
    NETLOGON_CREDENTIAL ChServerChallenge;

    //
    // Time stampt when the challenge entry got created
    //
    ULONG ChSetTime;

    //
    // Name(s) of the account that the client used to
    //  unsuccessfully authenticate on this challenge.
    //  May be NULL.
    //
    LPWSTR ChFailedAccountName;

    //
    // The name of the client (must be the last field)
    //
    WCHAR ChClientName[ANYSIZE_ARRAY];

} NL_CHALLENGE, *PNL_CHALLENGE;


// Lifetime of a challenge entry in the global list of
//  outstanding challenges
#define NL_CHALLENGE_TIMEOUT              120000  // 2*60*1000 = 2 minutes

// Maximum number of challenges we are going to keep
//  before we start throwing away existing ones at random
#define NL_MAX_CHALLENGE_COUNT            100000

// Number of challenges at which we reschedule the scavenger
//  to run soon (as given by NL_LARGE_CHALLENGE_TIMEOUT).
//  Running the scavenger soon will prevent us from commiting
//  a lot of memory for an extended period for challenges coming
//  from a malicious client making tons of challenge requests.
//
#define NL_LARGE_CHALLENGE_COUNT          5000

// Timeout when the scavenger will be rescheduled to run
//  upon detection of current large number of outstanding
//  challenges (provided the scavenger isn't already sheduled
//  to run earlier).
#define NL_LARGE_CHALLENGE_COUNT_TIMEOUT  120000  // 2*60*1000 = 2 minutes


VOID
NlScavengeOldChallenges(
    VOID
    )
/*++

Routine Description:

    This function removes all expired challenge entries
    from the global list of outstanding challenges.

Arguments:

    None

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_ACCESS_DENIED;
    PLIST_ENTRY ChallengeEntry = NULL;
    PNL_CHALLENGE Challenge = NULL;
    ULONG CurrentTime;
    ULONG ElapsedTime;
    LPWSTR MsgStrings[3];

    CurrentTime = GetTickCount();

    EnterCriticalSection( &NlGlobalChallengeCritSect );

    ChallengeEntry = NlGlobalChallengeList.Flink;
    while ( ChallengeEntry != &NlGlobalChallengeList ) {
        Challenge = CONTAINING_RECORD( ChallengeEntry, NL_CHALLENGE, ChNext );
        ChallengeEntry = ChallengeEntry->Flink;

        //
        // If time has wrapped, account for it
        //
        if ( CurrentTime >= Challenge->ChSetTime ) {
            ElapsedTime = CurrentTime - Challenge->ChSetTime;
        } else {
            ElapsedTime = (0xFFFFFFFF - Challenge->ChSetTime) + CurrentTime;
        }

        //
        // The list of challenges is sorted by the time stampt.
        // So if this entry is old, remove it. Otherwise, we have
        // removed all expired entries, so break from the loop.
        //
        if ( ElapsedTime >= NL_CHALLENGE_TIMEOUT ) {

            //
            // Write the event log stating that this client
            //  failed to authenticate. Note that since we avoid
            //  duplicate event logs, there will be only one
            //  message (which is good) for multiple challenges
            //  from the same client for the same account.
            //
            MsgStrings[0] = Challenge->ChClientName;

            //
            // If the account name is available, log it
            //
            if ( Challenge->ChFailedAccountName != NULL ) {
                MsgStrings[1] = Challenge->ChFailedAccountName;
                MsgStrings[2] = (LPWSTR) LongToPtr( Status );

                NlpWriteEventlog( NELOG_NetlogonServerAuthFailed,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) & Status,
                                  sizeof(Status),
                                  MsgStrings,
                                  3 | NETP_LAST_MESSAGE_IS_NTSTATUS );
            } else {
                MsgStrings[1] = (LPWSTR) LongToPtr( Status );

                NlpWriteEventlog( NELOG_NetlogonServerAuthFailedNoAccount,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) & Status,
                                  sizeof(Status),
                                  MsgStrings,
                                  2 | NETP_LAST_MESSAGE_IS_NTSTATUS );
            }

            //
            // Delink and free this entry
            //
            if ( Challenge->ChFailedAccountName != NULL ) {
                LocalFree( Challenge->ChFailedAccountName );
            }
            RemoveEntryList(&Challenge->ChNext);
            LocalFree( Challenge );
            NlGlobalChallengeCount --;

        } else {
            break;
        }
    }

    LeaveCriticalSection( &NlGlobalChallengeCritSect );
}

NTSTATUS
NlInsertChallenge(
    IN LPWSTR ClientName,
    IN PNETLOGON_CREDENTIAL ClientChallenge,
    IN PNETLOGON_CREDENTIAL ServerChallenge
    )
/*++

Routine Description:

    This function inserts a pair of client/server challenges into the
    global list of outstanding challenges.

Arguments:

    ClientName -- Name of the client supplying the client challenge.

    ClientCredential -- 64 bit challenge supplied by the client.

    ServerCredential -- Server challenge response returned by us

Return Value:

    STATUS_SUCCESS -- A new challenge entry was successfully added

    STATUS_NO_MEMORY -- The was not enough memory

--*/

{
    PLIST_ENTRY ChallengeEntry = NULL;
    PNL_CHALLENGE NewChallenge = NULL;
    PNL_CHALLENGE Challenge = NULL;
    BOOL RescheduleScavenger = FALSE;

    //
    // Allocate a new challenge entry
    //

    NewChallenge = LocalAlloc( LMEM_ZEROINIT, sizeof(NL_CHALLENGE) +
                                  (wcslen(ClientName) + 1) * sizeof(WCHAR) );
    if ( NewChallenge == NULL ) {
        return STATUS_NO_MEMORY;
    }

    //
    // Fill it in
    //

    NewChallenge->ChSetTime = GetTickCount();
    RtlCopyMemory( &NewChallenge->ChClientName, ClientName, (wcslen(ClientName) + 1) * sizeof(WCHAR) );
    NewChallenge->ChClientChallenge = *ClientChallenge;
    NewChallenge->ChServerChallenge = *ServerChallenge;


    EnterCriticalSection( &NlGlobalChallengeCritSect );

    //
    // First scavenge old entries
    //

    NlScavengeOldChallenges();

    //
    // Now determine if we have exceeded the limit
    // on the total number of outstanding challenges
    //

    if ( NlGlobalChallengeCount >= NL_MAX_CHALLENGE_COUNT ) {
        ULONG Index = 0;
        ULONG RemoveEntryNumber;

        //
        // Pick up an entry at random and free it
        //
        RemoveEntryNumber = rand() % NL_MAX_CHALLENGE_COUNT;

        //
        // Locate that entry in the list and remove it
        //
        for ( ChallengeEntry = NlGlobalChallengeList.Flink;
              ChallengeEntry != &NlGlobalChallengeList;
              ChallengeEntry = ChallengeEntry->Flink ) {

            if ( Index == RemoveEntryNumber ) {
                Challenge = CONTAINING_RECORD( ChallengeEntry, NL_CHALLENGE, ChNext );
                NlPrint(( NL_CRITICAL,
                          "NlInsertChallenge: Removing challenge %ld for %ws\n",
                          Index,
                          Challenge->ChClientName ));
                RemoveEntryList( &Challenge->ChNext );
                LocalFree( Challenge );
                NlGlobalChallengeCount --;
                break;
            }
            Index ++;
        }
    }

    //
    // Finally insert into the list at the tail to keep the list
    //  sorted by the tick count.
    //
    // Note that the tick count can't be reset, so the list will
    //  stay always sorted. The tick count can wrap, however,
    //  but we will take care of it when we calculate the elapsed time.
    //

    InsertTailList( &NlGlobalChallengeList, &NewChallenge->ChNext );
    NlGlobalChallengeCount ++;

    //
    // If we have too many challenges,
    // reschedule the scavenger to run soon.
    // This way we don't commit large amount of
    // memory for an extended period of time for tons
    // of challenges comming from a malicious caller.
    //

    if ( NlGlobalChallengeCount >= NL_LARGE_CHALLENGE_COUNT ) {
        RescheduleScavenger = TRUE;
        NlPrint(( NL_CRITICAL,
                  "NlInsertChallenge: Too many challenges: %lu. Will start scavenger in 2 mins\n",
                  NlGlobalChallengeCount ));
    }

    LeaveCriticalSection( &NlGlobalChallengeCritSect );

    //
    // Reschedule the scavenger as needed
    //

    if ( RescheduleScavenger ) {
        LARGE_INTEGER TimeNow;
        DWORD Timeout = 0xFFFFFFFF;

        EnterCriticalSection( &NlGlobalScavengerCritSect );
        NlQuerySystemTime( &TimeNow );
        if ( !TimerExpired(&NlGlobalScavengerTimer, &TimeNow, &Timeout) ) {
            if ( Timeout > NL_LARGE_CHALLENGE_COUNT_TIMEOUT ) {
                NlGlobalScavengerTimer.Period -= (Timeout - NL_LARGE_CHALLENGE_COUNT_TIMEOUT);

                if ( !SetEvent( NlGlobalTimerEvent ) ) {
                    NlPrint(( NL_CRITICAL,
                              "NlInsertChallenge: SetEvent failed %ld\n",
                              GetLastError() ));
                }
            }
        }
        LeaveCriticalSection( &NlGlobalScavengerCritSect );
    }

    return STATUS_SUCCESS;
}

VOID
NlRemoveChallenge(
    IN LPWSTR ClientName OPTIONAL,
    IN LPWSTR AccountName OPTIONAL,
    IN BOOL InterdomainTrustAccount
    )
/*++

Routine Description:

    This function removes challenge entries from the
    global list of outstanding challenges.

Arguments:

    ClientName -- Name of the client whose associated
        challenges entries will be removed. If NULL, all
        entries in the list will be removed.

    AccountName -- Name of teh account used by the client
        to athenticate with this server. Used only if
        ClinetName is specified.

    InterdomainTrustAccount -- TRUE if the client used an
        interdomain trust account to set up a secure channel.
        Used only if ClientName is specified.

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_ACCESS_DENIED;
    PLIST_ENTRY ChallengeEntry = NULL;
    PNL_CHALLENGE Challenge = NULL;
    ULONG SameAccountChallengeCount = 0;
    BOOLEAN LogEvent = FALSE;
    LPWSTR MsgStrings[3];

    //
    // First scavenge old entries from the head of the list
    // Skip this step if we are removing all entries anyway
    //

    EnterCriticalSection( &NlGlobalChallengeCritSect );

    if ( ClientName != NULL ) {
        NlScavengeOldChallenges();
    }

    //
    // Next remove all entries in the list associated with client name
    //

    ChallengeEntry = NlGlobalChallengeList.Flink;
    while ( ChallengeEntry != &NlGlobalChallengeList ) {
        Challenge = CONTAINING_RECORD( ChallengeEntry, NL_CHALLENGE, ChNext );
        ChallengeEntry = ChallengeEntry->Flink;

        //
        // If the client name is NULL, we are shutting down,
        //  so just delink and free all entries
        //
        if ( ClientName == NULL ) {
            if ( Challenge->ChFailedAccountName != NULL ) {
                LocalFree( Challenge->ChFailedAccountName );
            }
            RemoveEntryList(&Challenge->ChNext);
            LocalFree( Challenge );
            NlGlobalChallengeCount --;

        //
        // If this entry is for the specified client,
        //  process it
        //
        } else if ( NlNameCompare(ClientName,
                                  Challenge->ChClientName,
                                  NAMETYPE_COMPUTER) == 0 ) {

            MsgStrings[0] = Challenge->ChClientName;

            //
            // If this entry has an account different from
            //  the specied one, log an event for it.
            //  Note that since we avoid duplicate event logs,
            //  there will be only one message (which is good)
            //  for multiple challenges from the same client
            //  for the same account.
            //
            if ( AccountName != NULL &&
                 Challenge->ChFailedAccountName != NULL &&
                 _wcsicmp(Challenge->ChFailedAccountName, AccountName) != 0 ) {

                MsgStrings[1] = Challenge->ChFailedAccountName;
                MsgStrings[2] = (LPWSTR) LongToPtr( Status );

                NlpWriteEventlog( NELOG_NetlogonServerAuthFailed,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) & Status,
                                  sizeof(Status),
                                  MsgStrings,
                                  3 | NETP_LAST_MESSAGE_IS_NTSTATUS );
            //
            // Otherwise, count this entry in the number
            //  of challenges with the specified or empty
            //  account names (a challenge may have an empty
            //  account name if we haven't reached it in the
            //  authentication try loop).
            //
            } else {
                SameAccountChallengeCount ++;
            }

            //
            // Delink this entry and free it
            //
            if ( Challenge->ChFailedAccountName != NULL ) {
                LocalFree( Challenge->ChFailedAccountName );
            }
            RemoveEntryList(&Challenge->ChNext);
            LocalFree( Challenge );
            NlGlobalChallengeCount --;
        }
    }

    LeaveCriticalSection( &NlGlobalChallengeCritSect );

    //
    // If there are more than a certain number of challenges
    //  with the specified or emppty account, some other
    //  (possibly  malicious) client attempted to authenticate
    //  using this account. Log an event for this. Don't specify
    //  the account name as we don't know which account that
    //  client would specify.
    //
    // For interdomain trust, the client may legitimately
    //  try up to 3 times (passwords new, old, from PDC).
    //  Otherwise, it gets 2 tries (new and old pwd).
    //

    if ( InterdomainTrustAccount ) {
        if ( SameAccountChallengeCount > 3 ) {
            LogEvent = TRUE;
        }
    } else {
        if ( SameAccountChallengeCount > 2 ) {
            LogEvent = TRUE;
        }
    }

    if ( LogEvent ) {
        MsgStrings[0] = ClientName;
        MsgStrings[1] = (LPWSTR) LongToPtr( Status );

        NlpWriteEventlog( NELOG_NetlogonServerAuthFailedNoAccount,
                          EVENTLOG_ERROR_TYPE,
                          (LPBYTE) & Status,
                          sizeof(Status),
                          MsgStrings,
                          2 | NETP_LAST_MESSAGE_IS_NTSTATUS );
    }

}


NTSTATUS
NetrServerReqChallenge(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientChallenge,
    OUT PNETLOGON_CREDENTIAL ServerChallenge
    )
/*++

Routine Description:

    This is the server side of I_NetServerReqChallenge.

    I_NetServerReqChallenge is the first of two functions used by a client
    Netlogon service to authenticate with another Netlogon service.
    (See I_NetServerAuthenticate below.)

    This function passes a challenge to the DC and the DC passes a challenge
    back to the caller.

Arguments:

    PrimaryName -- Supplies the name of the DC we wish to authenticate with.

    ComputerName -- Name of the machine making the call.

    ClientCredential -- 64 bit challenge supplied by the BDC or member server.

    ServerCredential -- Receives 64 bit challenge from the PDC.

Return Value:

    The status of the operation.

--*/

{
#ifdef _WKSTA_NETLOGON
    return ERROR_NOT_SUPPORTED;
    UNREFERENCED_PARAMETER( PrimaryName );
    UNREFERENCED_PARAMETER( ComputerName );
    UNREFERENCED_PARAMETER( ClientChallenge );
    UNREFERENCED_PARAMETER( ServerChallenge );
#endif // _WKSTA_NETLOGON
#ifdef _DC_NETLOGON
    NTSTATUS Status;

    PDOMAIN_INFO DomainInfo = NULL;

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Lookup which domain this call pertains to.
    //
    DomainInfo = NlFindDomainByServerName( PrimaryName );

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }


    NlPrint((NL_CHALLENGE_RES,
            "NetrServerReqChallenge: ClientChallenge = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, ClientChallenge, sizeof(*ClientChallenge) );


    //
    // Compute ServerChallenge to pass back to requestor
    //

    NlComputeChallenge(ServerChallenge);


    NlPrint((NL_CHALLENGE_RES,
            "NetrServerReqChallenge: ServerChallenge = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, ServerChallenge, sizeof(*ServerChallenge) );


    //
    // Add this entry into the challenge list.
    //
    // Remember both challenges until the corresponding I_NetAuthenticate call.
    // Notice that both challenges are not yet SessionKey-encrypted
    //

    Status = NlInsertChallenge( ComputerName,
                                ClientChallenge,
                                ServerChallenge );

    //
    // Common exit point
    //

Cleanup:

    //
    // If the request failed, be carefull to not leak authentication
    // information.
    //

    if ( !NT_SUCCESS(Status) )  {
        RtlZeroMemory( ServerChallenge, sizeof(*ServerChallenge) );
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return Status;
#endif // _DC_NETLOGON
}


NTSTATUS
NetrServerAuthenticate3(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential,
    IN OUT PULONG NegotiatedFlags,
    OUT PULONG AccountRid
    )
/*++

Routine Description:

    This is the server side of I_NetServerAuthenticate

    I_NetServerAuthenticate is the second of two functions used by a client
    Netlogon service to authenticate with another Netlogon service.
    (See I_NetServerReqChallenge above.)  Both a SAM or UAS server authenticates
    using this function.

    This function passes a credential to the DC and the DC passes a credential
    back to the caller.


Arguments:

    PrimaryName -- Supplies the name of the DC we wish to authenticate with.

    AccountName -- Name of the Account to authenticate with.

    SecureChannelType -- The type of the account being accessed.  This field must
        be set to UasServerSecureChannel to indicate a call from downlevel (LanMan
        2.x and below) BDC or member server.

    ComputerName -- Name of the BDC or member server making the call.

    ClientCredential -- 64 bit credential supplied by the BDC or member server.

    ServerCredential -- Receives 64 bit credential from the PDC.

    NegotiatedFlags -- Specifies flags indicating what features the BDC supports.
        Returns a subset of those flags indicating what features the PDC supports.
        The PDC/BDC should ignore any bits that it doesn't understand.

    AccountRid -- Returns the RID of the account identified by AccountName

Return Value:

    The status of the operation.

--*/

{
#ifdef _WKSTA_NETLOGON
    return ERROR_NOT_SUPPORTED;
    UNREFERENCED_PARAMETER( PrimaryName );
    UNREFERENCED_PARAMETER( AccountName );
    UNREFERENCED_PARAMETER( SecureChannelType );
    UNREFERENCED_PARAMETER( ComputerName );
    UNREFERENCED_PARAMETER( ClientCredential );
    UNREFERENCED_PARAMETER( ServerCredential );
    UNREFERENCED_PARAMETER( NegotiatedFlags );
#endif // _WKSTA_NETLOGON
#ifdef _DC_NETLOGON
    NTSTATUS Status = STATUS_SUCCESS;
    PDOMAIN_INFO DomainInfo = NULL;
    ULONG LoopCount;

    NETLOGON_CREDENTIAL LocalClientCredential;
    NETLOGON_SESSION_KEY SessionKey;

    NT_OWF_PASSWORD OwfPassword;
    NT_OWF_PASSWORD OwfPreviousPassword;
    NT_OWF_PASSWORD LocalOwfPassword;
    NETLOGON_CREDENTIAL ServerChallenge;
    NETLOGON_CREDENTIAL ClientChallenge;
    BOOL IsInterdomainTrustAccount = FALSE;
    ULONG TrustAttributes;
    BOOL ClientAuthenticated = FALSE;

    PLIST_ENTRY ChallengeEntry;
    PNL_CHALLENGE Challenge;
    ULONG ChallengeCount = 0;

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Start the WMI trace of server authentication
    //

    NlpTraceServerAuthEvent( EVENT_TRACE_TYPE_START,
                             ComputerName,
                             AccountName,
                             SecureChannelType,
                             NegotiatedFlags,
                             STATUS_SUCCESS ); // Status isn't used at start

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( PrimaryName );

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrServerAuthenticate entered: %ws on account %ws (Negot: %lx)\n",
            ComputerName, AccountName, *NegotiatedFlags ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Disallow this function for Lanman 2.X servers.
    //

    if ( SecureChannelType == UasServerSecureChannel ) {

        NlPrint((NL_CRITICAL,"NetrServerAuthenticate "
                     "from LM 2.x (disallowed).\n"));

        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Compute the NegotiatedFlags both sides support
    //

    *NegotiatedFlags &= NETLOGON_SUPPORTS_MASK |
        NETLOGON_SUPPORTS_DNS_DOMAIN_TRUST |
        NETLOGON_SUPPORTS_STRONG_KEY |
        NETLOGON_SUPPORTS_NT4EMULATOR_NEUTRALIZER |
#ifdef ENABLE_AUTH_RPC
        (NlGlobalServerSupportsAuthRpc ? (NETLOGON_SUPPORTS_AUTH_RPC|NETLOGON_SUPPORTS_LSA_AUTH_RPC) : 0 ) |
#endif // ENABLE_AUTH_RPC
        (NlGlobalParameters.AvoidSamRepl ? NETLOGON_SUPPORTS_AVOID_SAM_REPL : 0) |
        (NlGlobalParameters.AvoidLsaRepl ? NETLOGON_SUPPORTS_AVOID_LSA_REPL : 0);

    //
    // If we are emulating NT4.0 domain and the client
    //  didn't indicate to neutralize the emulation,
    //  treat the client as NT4.0 client. That way we
    //  won't leak NT5.0 specific info to the client.
    //  In fact, the client won't even ask for NT5.0
    //  specific info after receiving such negotiated
    //  from us.
    //

    if ( NlGlobalParameters.Nt4Emulator &&
         ((*NegotiatedFlags) & NETLOGON_SUPPORTS_NT4EMULATOR_NEUTRALIZER) == 0 ) {

        //
        // Pick up only those flags which existed in NT4.0
        //
        *NegotiatedFlags &= NETLOGON_SUPPORTS_NT4_MASK;
    }

    //
    // Get the password for the account. For interdomain trust
    //  trust account, get both current and previous passwords
    //

    if ( IsDomainSecureChannelType( SecureChannelType ) ) {
        IsInterdomainTrustAccount = TRUE;
    }

    Status = NlGetIncomingPassword(
                    DomainInfo,
                    AccountName,
                    SecureChannelType,
                    0,      // Let routine figure out bits from SecureChannelType
                    TRUE,   // Fail for disabled accounts
                    &OwfPassword,
                    IsInterdomainTrustAccount ?
                        &OwfPreviousPassword :  // Get previous password for interdomain account
                        NULL,
                    AccountRid,
                    &TrustAttributes,
                    NULL );  // Don't need the account type

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                "NetrServerAuthenticate: Can't NlGetIncomingPassword for %ws 0x%lx.\n",
                AccountName,
                Status ));
        goto Cleanup;
    }

    //
    // Output the passwords as needed
    //

    NlPrint((NL_CHALLENGE_RES,"NetrServerAuthenticate: Password for account %ws = ", AccountName ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &OwfPassword, sizeof(OwfPassword) );
    if ( IsInterdomainTrustAccount ) {
        NlPrint((NL_CHALLENGE_RES,"NetrServerAuthenticate: Previous Password for account %ws = ", AccountName ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &OwfPreviousPassword, sizeof(OwfPreviousPassword) );
    }

    //
    // Loop through all challenge entries for this client
    //  and try to authenticate it against any one of the challenges.
    //

    EnterCriticalSection( &NlGlobalChallengeCritSect );

    //
    // First, take this opportunity to clean up expired challenge entries
    //

    NlScavengeOldChallenges();

    //
    // Now try all challenges for this client
    //

    for ( ChallengeEntry = NlGlobalChallengeList.Flink;
          ChallengeEntry != &NlGlobalChallengeList;
          ChallengeEntry = ChallengeEntry->Flink ) {

        Challenge = CONTAINING_RECORD( ChallengeEntry, NL_CHALLENGE, ChNext );

        //
        // Skip entries which are not for this client
        //
        if ( NlNameCompare(ComputerName,
                           Challenge->ChClientName,
                           NAMETYPE_COMPUTER) != 0 ) {
            continue;
        }

        ChallengeCount ++;

        //
        // Grab a copy of the Client and Server challenges.
        //

        RtlCopyMemory( &ServerChallenge,
                       &Challenge->ChServerChallenge,
                       sizeof(ServerChallenge) );

        RtlCopyMemory( &ClientChallenge,
                       &Challenge->ChClientChallenge,
                       sizeof(ClientChallenge) );

        NlPrint((NL_CHALLENGE_RES,"NetrServerAuthenticate: ClientChallenge %lu = ", ChallengeCount ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &ClientChallenge, sizeof(ClientChallenge) );

        NlPrint((NL_CHALLENGE_RES,"NetrServerAuthenticate: ServerChallenge %lu = ", ChallengeCount ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &ServerChallenge, sizeof(ServerChallenge) );

        //
        // Loop trying the local current password, then the local previous password
        // provided this is an interdomain trust account.
        //

        for ( LoopCount=0; LoopCount<2; LoopCount++ ) {

            //
            // On the first iteration, use the current password
            //
            if ( LoopCount == 0 ) {
                LocalOwfPassword = OwfPassword;

            //
            // On the second iteration, if this is an interdomain trust account,
            //  use the previous password
            //
            } else if ( LoopCount == 1 && IsInterdomainTrustAccount ) {

                LocalOwfPassword = OwfPreviousPassword;

            //
            // Otherwise, try the next challenge, if any
            //
            } else {
                break;
            }

            //
            // Compute the session key given the two challenges and the
            //  password.
            //

            Status = NlMakeSessionKey(
                           *NegotiatedFlags,
                           &LocalOwfPassword,
                           &ClientChallenge,
                           &ServerChallenge,
                           &SessionKey );

            if (!NT_SUCCESS(Status)) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NetrServerAuthenticate: Can't NlMakeSessionKey for %ws 0x%lx.\n",
                        AccountName,
                        Status ));
                LeaveCriticalSection( &NlGlobalChallengeCritSect );
                goto Cleanup;
            }


            NlPrint((NL_CHALLENGE_RES,"NetrServerAuthenticate: SessionKey %lu = ", LoopCount ));
            NlpDumpBuffer(NL_CHALLENGE_RES, &SessionKey, sizeof(SessionKey) );


            //
            // Compute ClientCredential to verify the one supplied by ComputerName
            //

            NlComputeCredentials( &ClientChallenge,
                                  &LocalClientCredential,
                                  &SessionKey);


            NlPrint((NL_CHALLENGE_RES,"NetrServerAuthenticate: ClientCredential %lu GOT  = ", LoopCount ));
            NlpDumpBuffer(NL_CHALLENGE_RES, ClientCredential, sizeof(*ClientCredential) );


            NlPrint((NL_CHALLENGE_RES,"NetrServerAuthenticate: ClientCredential %lu MADE = ", LoopCount ));
            NlpDumpBuffer(NL_CHALLENGE_RES, &LocalClientCredential, sizeof(LocalClientCredential) );


            //
            // Verify the computed credentials with those supplied
            //

            if( RtlEqualMemory( ClientCredential,
                                &LocalClientCredential,
                                sizeof(LocalClientCredential)) ) {
                ClientAuthenticated = TRUE;
                break;
            }

            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NetrServerAuthenticate: Bad password %lu for %ws on account %ws\n",
                    LoopCount, ComputerName, AccountName ));

        }

        if ( ClientAuthenticated ) {
            break;
        }

        //
        // This challenge entry failed to authenticate.
        //  Remember the account name as specified by the
        //  client in this challenge entry if this account
        //  isn't already on the entry.
        //
        if ( Challenge->ChFailedAccountName == NULL ||
             wcsstr(Challenge->ChFailedAccountName, AccountName) == NULL ) {

            ULONG OldLength = 0;
            LPWSTR TmpStorage = NULL;

            //
            // If there is already an account name,
            //  allocate space for it
            //
            if ( Challenge->ChFailedAccountName != NULL ) {
                // add storage for a comma and a space
                OldLength = wcslen( Challenge->ChFailedAccountName ) + 2;
            }

            //
            // Allocate space for old (if any) and new account names
            //
            TmpStorage = LocalAlloc( LMEM_ZEROINIT,
                                     (OldLength+wcslen(AccountName)+1)*sizeof(WCHAR) );
            if ( TmpStorage != NULL ) {

                //
                // Copy old name(s), if any.
                // Separate names with a comma and a space.
                //
                if ( OldLength > 0 ) {
                    RtlCopyMemory( TmpStorage,
                                   Challenge->ChFailedAccountName,
                                   (OldLength-2)*sizeof(WCHAR) );
                    wcscat( TmpStorage, L", ");
                }

                //
                // Append the new account name
                //
                wcscat(TmpStorage, AccountName);

                //
                // Free the old name(s) and keep the new one
                //
                if ( Challenge->ChFailedAccountName != NULL ) {
                    LocalFree( Challenge->ChFailedAccountName );
                }
                Challenge->ChFailedAccountName = TmpStorage;
            }
        }
    }

    LeaveCriticalSection( &NlGlobalChallengeCritSect );

    //
    // Error out if we didn't authenticate the client
    //

    if ( !ClientAuthenticated ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
           "NetrServerAuthenticate: Failed to authenticate %ws on account %ws\n",
           ComputerName, AccountName ));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Cleanup all challenges for this client
    //

    NlRemoveChallenge( ComputerName, AccountName, IsInterdomainTrustAccount );

    //
    // Create the server session for this client
    //

    Status = NlInsertServerSession(
                     DomainInfo,
                     ComputerName,
                     AccountName,
                     SecureChannelType,
                     // Only replicate those databases that negotiation says to replicate
                     SS_AUTHENTICATED |
                        NlMaxReplMask(*NegotiatedFlags) |
                        ((TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) ?
                            SS_FOREST_TRANSITIVE :
                            0 ),
                     *AccountRid,
                     *NegotiatedFlags,
                     (SecureChannelType == ServerSecureChannel) ?
                        NlTransportLookup( ComputerName ) :
                        NULL,
                     &SessionKey,
                     &LocalClientCredential );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
           "NetrServerAuthenticate: NlInsertServerSession failed for %ws on account %ws\n",
           ComputerName, AccountName ));
        goto Cleanup;
    }

    //
    // Compute ServerCredential from ServerChallenge to be returned to caller
    //

    NlComputeCredentials( &ServerChallenge,
                          ServerCredential,
                          &SessionKey );

    NlPrint((NL_CHALLENGE_RES,"NetrServerAuthenticate: ServerCredential SEND = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, ServerCredential, sizeof(*ServerCredential) );


    //
    // If the client is a pre NT 5 member workstation or BDC,
    //  update the DS.
    //

    if ( !IsInterdomainTrustAccount &&
         ((*NegotiatedFlags) & ~NETLOGON_SUPPORTS_NT4_MASK) == 0 ) {
        OSVERSIONINFOEXW OsVersionInfoEx;

        //
        // Build the OsVersionInfo structure.
        //

        RtlZeroMemory( &OsVersionInfoEx, sizeof(OsVersionInfoEx) );
        OsVersionInfoEx.dwOSVersionInfoSize = sizeof(OsVersionInfoEx);

        //
        // Differentiate between NT 3 and NT 4.
        //

        if ( *NegotiatedFlags == 0 ) {
            OsVersionInfoEx.dwMajorVersion = 3;
            OsVersionInfoEx.dwMinorVersion = 1;
        } else if ( ((*NegotiatedFlags) & ~NETLOGON_SUPPORTS_NT351_MASK) == 0 ) {
            OsVersionInfoEx.dwMajorVersion = 3;
            OsVersionInfoEx.dwMinorVersion = 5;
        } else {
            OsVersionInfoEx.dwMajorVersion = 4;
        }

        NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                "NetrServerAuthenticate: %ws is running NT %ld.%ld\n",
                ComputerName,
                OsVersionInfoEx.dwMajorVersion,
                OsVersionInfoEx.dwMinorVersion ));

        //
        // Set the DnsHostName on the computer object.
        //
        Status = LsaISetClientDnsHostName(
                    ComputerName,
                    NULL,       // No DnsHostName
                    &OsVersionInfoEx,
                    L"Windows NT",
                    NULL );     // Not interested in returning DnsHostName

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NetrServerAuthenticate: Cannot set client DNS host name %lx (ignoring)\n",
                    Status ));
            // This isn't fatal
        }
    }


    //
    // Success!!!
    //

    Status = STATUS_SUCCESS;

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrServerAuthenticate returns Success: %ws on account %ws (Negot: %lx)\n",
            ComputerName, AccountName, *NegotiatedFlags ));

    //
    // Common exit point
    //

Cleanup:

    //
    // Return more appropriate error
    //

    if ( Status == STATUS_NO_SUCH_USER ) {
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
    }

    //
    // Handle failure
    //

    if ( !NT_SUCCESS( Status ) ) {
        LPWSTR MsgStrings[3];

        //
        // Be careful to not leak authentication information.
        //

        RtlZeroMemory( ServerCredential, sizeof(*ServerCredential) );
        *AccountRid = 0;

        //
        // Write event log as appropriate
        //

        MsgStrings[0] = ComputerName;
        MsgStrings[1] = AccountName;

        if (Status == STATUS_NO_TRUST_SAM_ACCOUNT) {

            NlpWriteEventlog( NELOG_NetlogonServerAuthNoTrustSamAccount,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE) & Status,
                              sizeof(Status),
                              MsgStrings,
                              2 );

        //
        // If this attempt failed with access denied and we tried challenges for
        //  this client, the event log has already been output as appropriate
        //
        } else if ( !(Status == STATUS_ACCESS_DENIED && ChallengeCount > 0) ) {
            MsgStrings[2] = (LPWSTR) LongToPtr( Status );

            NlpWriteEventlog( NELOG_NetlogonServerAuthFailed,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE) & Status,
                              sizeof(Status),
                              MsgStrings,
                              3 | NETP_LAST_MESSAGE_IS_NTSTATUS );
        }
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    //
    // End the WMI trace of server authentication
    //

    NlpTraceServerAuthEvent( EVENT_TRACE_TYPE_END,
                             ComputerName,
                             AccountName,
                             SecureChannelType,
                             NegotiatedFlags,
                             Status );

    return Status;
#endif // _DC_NETLOGON
}


NTSTATUS
NetrServerAuthenticate2(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential,
    IN OUT PULONG NegotiatedFlags
    )
/*++

Routine Description:


    This is the NT 3.5x and NT 4.x version of I_NetServerAuthenicate3.
    I_NetServerAuthenticate3 was introduced in NT 5.0 (December 1996).

Arguments:

Return Value:

    The status of the operation.

--*/

{
    ULONG AccountRid;

    return NetrServerAuthenticate3( PrimaryName,
                                    AccountName,
                                    SecureChannelType,
                                    ComputerName,
                                    ClientCredential,
                                    ServerCredential,
                                    NegotiatedFlags,
                                    &AccountRid );

}


NTSTATUS
NetrServerAuthenticate(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential
    )
/*++

Routine Description:


    This is the NT 3.1 version of I_NetServerAuthenicate2.
    I_NetServerAuthenticate2 was introduced in NT 3.5 (December 1993).

Arguments:

Return Value:

    The status of the operation.

--*/

{
    ULONG NegotiatedFlags = 0;

    return NetrServerAuthenticate2( PrimaryName,
                                    AccountName,
                                    SecureChannelType,
                                    ComputerName,
                                    ClientCredential,
                                    ServerCredential,
                                    &NegotiatedFlags );

}


NTSTATUS
NetpServerPasswordSet(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PENCRYPTED_LM_OWF_PASSWORD UasNewPassword OPTIONAL,
    IN PNL_TRUST_PASSWORD ClearNewPassword OPTIONAL

    )
/*++

Routine Description:

    This function is used to change the password for the account being
    used to maintain a secure channel.  This function can only be called
    by a server which has previously authenticated with a DC by calling
    I_NetServerAuthenticate.

    The call is made depending on the account type:

      *  A domain account password is changed from the PDC in the
         trusting domain.  The I_NetServerPasswordSet call is made to any
         DC in the trusted domain.

      *  A server account password is changed from the specific server.
         The I_NetServerPasswordSet call is made to the PDC in the domain
         the server belongs to.

      *  A workstation account password is changed from the specific
         workstation.  The I_NetServerPasswordSet call is made to a DC in
         the domain the server belongs to.

    This function uses RPC to contact the DC named by PrimaryName.

Arguments:

    PrimaryName -- Name of the PDC to change the servers password
        with.  NULL indicates this call is a local call being made on
        behalf of a UAS server by the XACT server.

    AccountName -- Name of the account to change the password for.

    AccountType -- The type of account being accessed.

    ComputerName -- Name of the BDC or member making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    UasNewPassword -- The new OWF password for the server.

    ClearNewPassword -- The new cleartext password for the server.
        Either, UasNewPassword or ClearNewPassword will be NULL.

Return Value:

    NT status code.

    STATUS_WRONG_PASSWORD - Indicates the server refuses to allow the password
        to be changed.  The client should continue to use the prior password.

--*/
{
#ifdef _WKSTA_NETLOGON
    return ERROR_NOT_SUPPORTED;
    UNREFERENCED_PARAMETER( PrimaryName );
    UNREFERENCED_PARAMETER( AccountName );
    UNREFERENCED_PARAMETER( AccountType );
    UNREFERENCED_PARAMETER( ComputerName );
    UNREFERENCED_PARAMETER( Authenticator );
    UNREFERENCED_PARAMETER( ReturnAuthenticator );
    UNREFERENCED_PARAMETER( UasNewPassword );
#endif // _WKSTA_NETLOGON
#ifdef _DC_NETLOGON
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;

    PSERVER_SESSION ServerSession;
    SESSION_INFO SessionInfo;
    LM_OWF_PASSWORD OwfPassword;
    UNICODE_STRING NewPassword;

    DWORD ClearVersionNumber = 0;

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If the DS is recovering from a backup,
    //  avoid changing the DS.
    //

    if ( NlGlobalDsPaused ) {
        NlPrint((NL_CRITICAL,
                 "NetrServerPasswordSet: DsIsPaused.\n"));
        Status = STATUS_DS_BUSY;
        goto Cleanup;
    }


    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( PrimaryName );

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrServerPasswordSet: Comp=%ws Acc=%ws Entered\n",
            ComputerName,
            AccountName ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the Session key for this session.
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    SessionInfo.SessionKey = ServerSession->SsSessionKey;
    SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;


    //
    // now verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator( ServerSession,
                                   Authenticator,
                                   ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        goto Cleanup;
    }


    //
    // Check if we're refusing password changes
    //
    // Only refuse password changes if the client is a workstation and the
    // client supports password changing.
    //
    // If this is a PDC and the request was passed-through a BDC,
    // we don't have access to the NETLOGON_SUPPORTS flag of the workstation.
    // As such, we'll simply not check the NETLOGON_SUPPORTS flag in that
    // case and assume the client can handle it.
    //

    if ( NlGlobalParameters.RefusePasswordChange &&
         AccountType == WorkstationSecureChannel &&
         (ServerSession->SsSecureChannelType == ServerSecureChannel ||
         (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_REFUSE_CHANGE_PWD) != 0 )){

        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_WRONG_PASSWORD;
        goto Cleanup;
    }
    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

    //
    // If the caller passed a cleartext password,
    //  decrypt it.
    //

    if ( ClearNewPassword != NULL ) {
        NL_TRUST_PASSWORD LocalClearNewPassword;
        NL_PASSWORD_VERSION PasswordVersion;

        //
        // Simply decrypt using the session key
        //

        LocalClearNewPassword = *ClearNewPassword;
        NlDecryptRC4( &LocalClearNewPassword, sizeof(LocalClearNewPassword), &SessionInfo );

        //
        // Sanity check the length.
        //
        if ( IsDomainSecureChannelType( AccountType )) {

            if ( (LocalClearNewPassword.Length >= sizeof(LocalClearNewPassword.Buffer)-sizeof(PasswordVersion)) ||
                 (LocalClearNewPassword.Length % sizeof(WCHAR)) != 0 ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                         "NetrServerPasswordSet: Decrypted interdomain password is too long %ld\n",
                         LocalClearNewPassword.Length ));
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }
        } else {
            if ( (LocalClearNewPassword.Length >= sizeof(LocalClearNewPassword.Buffer)) ||
                 (LocalClearNewPassword.Length % sizeof(WCHAR)) != 0 ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                         "NetrServerPasswordSet: Decrypted password is too long %ld\n",
                         LocalClearNewPassword.Length ));
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }
        }

        //
        // Convert the new password into a unicode string.
        //

        NewPassword.Buffer = (LPWSTR)(((LPBYTE)LocalClearNewPassword.Buffer) +
                    NL_MAX_PASSWORD_LENGTH * sizeof(WCHAR) -
                    LocalClearNewPassword.Length);
        ;
        NewPassword.MaximumLength =
            NewPassword.Length = (USHORT)LocalClearNewPassword.Length;

        //
        // Get the password version number for an interdomain trust
        // account (may be absent)
        //

        if ( IsDomainSecureChannelType( AccountType ) ) {

            RtlCopyMemory( &PasswordVersion,
                           ((LPBYTE)LocalClearNewPassword.Buffer) +
                                NL_MAX_PASSWORD_LENGTH * sizeof(WCHAR) -
                                LocalClearNewPassword.Length -
                                sizeof(PasswordVersion),
                            sizeof(PasswordVersion) );

            if ( PasswordVersion.PasswordVersionPresent == PASSWORD_VERSION_NUMBER_PRESENT &&
                 PasswordVersion.PasswordVersionNumber > 0 ) {
                ClearVersionNumber = PasswordVersion.PasswordVersionNumber;
                NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                        "NetrServerPasswordSet: Got password version number 0x%lx\n",
                        ClearVersionNumber ));
            } else {
                NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                        "NetrServerPasswordSet: Got no password version number\n" ));
            }
        }

    //
    // If the caller passed an OWF password,
    //  decrypt it.
    //
    } else if ( UasNewPassword != NULL ) {
        //
        //  decrypt the sessionkey from password
        //  i.e. OwfPassword = D2((E2(E1(STD_TXT, PW), SK)), SK)
        //                   = E1(STD_TXT, PW)
        //  OwfPassword = One Way Function of the cleartext password.
        //

        if (Status = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                UasNewPassword,
                                (PLM_OWF_PASSWORD) &SessionInfo.SessionKey,
                                &OwfPassword )) {

            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
            goto Cleanup;
        }

    //
    // Internal error
    } else {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NetrServerPasswordSet: Neither clear nor OWF password.\n"));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }



    //
    //  Do the request locally.
    //

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrServerPasswordSet: Comp=%ws Acc=%ws Changing password locally\n",
            ComputerName,
            AccountName ));

    //
    // Set the password on the account.
    //

    Status = NlSetIncomingPassword(
                            DomainInfo,
                            AccountName,
                            AccountType,
                            ClearNewPassword == NULL ? NULL : &NewPassword,
                            ClearVersionNumber,
                            ClearNewPassword == NULL ? &OwfPassword : NULL );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

    //
    // Common exit point
    //

Cleanup:

    //
    // If the request failed, be carefull to not leak authentication
    // information.
    //

    if ( Status == STATUS_ACCESS_DENIED )  {
        RtlZeroMemory( ReturnAuthenticator, sizeof(*ReturnAuthenticator) );
    }

    //
    // Also zero out automatic variables which store passwords to avoid
    // having these on the stack for indefinite time.
    //

    RtlZeroMemory( &OwfPassword, sizeof(OwfPassword) );
    RtlZeroMemory( &NewPassword, sizeof(NewPassword) );


    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrServerPasswordSet: Comp=%ws Acc=%ws returns 0x%lX\n",
            ComputerName,
            AccountName,
            Status ));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return Status;
#endif // _DC_NETLOGON
}


NTSTATUS
NetrServerPasswordGet(
    IN LPWSTR PrimaryName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    This function is used to by a BDC to get a machine account password
    from the PDC in the doamin.

    This function can only be called by a server which has previously
    authenticated with a DC by calling I_NetServerAuthenticate.

    This function uses RPC to contact the DC named by PrimaryName.

Arguments:

    PrimaryName -- Computer name of the PDC to remote the call to.

    AccountName -- Name of the account to get the password for.

    AccountType -- The type of account being accessed.

    ComputerName -- Name of the BDC making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    EncryptedNtOwfPassword -- Returns the OWF password of the account.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;

    PSERVER_SESSION ServerSession;
    SESSION_INFO SessionInfo;
    NT_OWF_PASSWORD OwfPassword;

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( PrimaryName );

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrServerPasswordGet: Comp=%ws Acc=%ws Entered\n",
            ComputerName,
            AccountName ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // This call is only allowed to a PDC.
    //

    if ( DomainInfo->DomRole != RolePrimary ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NetrServerPasswordGet: Call only valid to a PDC.\n" ));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Get the Session key for this session.
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    SessionInfo.SessionKey = ServerSession->SsSessionKey;
    // SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;


    //
    // now verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator( ServerSession,
                                   Authenticator,
                                   ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        goto Cleanup;
    }


    //
    // Call is only allowed from a BDC.
    //

    if ( ServerSession->SsSecureChannelType != ServerSecureChannel ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NetrServerPasswordGet: Call only valid from a BDC.\n" ));
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }
    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );


    //
    // Get the password for the account.
    //

    Status = NlGetIncomingPassword(
                            DomainInfo,
                            AccountName,
                            AccountType,
                            0,      // Let routine compute from AccountType
                            TRUE,   // Fail if account is disabled
                            &OwfPassword,
                            NULL,   // Don't return the previous password
                            NULL,   // Don't return the account RID
                            NULL,   // Don't return the trust attributes
                            NULL ); // Don't need the account type

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Encrypt the password again with the session key.
    //  The BDC will decrypt it on the other side.
    //

    Status = RtlEncryptNtOwfPwdWithNtOwfPwd(
                        &OwfPassword,
                        (PNT_OWF_PASSWORD) &SessionInfo.SessionKey,
                        EncryptedNtOwfPassword) ;

    if ( !NT_SUCCESS( Status )) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrServerPasswordGet: Cannot RtlEncryptNtOwfPwdWithNtOwfPwd %lX\n",
                Status));
        goto Cleanup;
    }


    Status = STATUS_SUCCESS;

    //
    // Common exit point
    //

Cleanup:

    //
    // If the request failed, be carefull to not leak authentication
    // information.
    //

    if ( Status == STATUS_ACCESS_DENIED )  {
        RtlZeroMemory( ReturnAuthenticator, sizeof(*ReturnAuthenticator) );
        RtlZeroMemory( EncryptedNtOwfPassword, sizeof(*EncryptedNtOwfPassword) );
    }

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrServerPasswordGet: Comp=%ws Acc=%ws returns 0x%lX\n",
            ComputerName,
            AccountName,
            Status ));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return Status;
}


NTSTATUS
NetrServerGetTrustInfo(
    IN LPWSTR TrustedDcName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNewOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword,
    OUT PNL_GENERIC_RPC_DATA *TrustInfo
    )
/*++

Routine Description:

    This function is used by a trusting side DC/workstation to get the
    trust info (new and old passwords and trust attributes) from the
    trusted side. The account name requested must match the account
    name used at the secure channel setup time unless the call is made
    by a BDC to its PDC; the BDC has full access to the entire trust info.

    This function can only be called by a server which has previously
    authenticated with a DC by calling I_NetServerAuthenticate.

    This function uses RPC to contact the DC named by TrustedDcName.

Arguments:

    TrustedDcName -- Computer name of the DC to remote the call to.

    AccountName -- Name of the account to get the password for.

    AccountType -- The type of account being accessed.

    ComputerName -- Name of the DC making the call.

    Authenticator -- supplied by this server.

    ReturnAuthenticator -- Receives an authenticator returned by the
        trusted side DC.

    EncryptedNewOwfPassword -- Returns the new OWF password of the account.

    EncryptedOldOwfPassword -- Returns the old OWF password of the account.

    TrustInfo -- Returns trust info data (currently trust attributes).
        Must be freed by calling NetApiBufferFree.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;

    PSERVER_SESSION ServerSession;
    SESSION_INFO SessionInfo;
    NT_OWF_PASSWORD NewOwfPassword;
    NT_OWF_PASSWORD OldOwfPassword;
    ULONG AccountRid;
    ULONG TrustAttributes = 0;
    ULONG ServerSessionAccountRid;
    BOOLEAN VerifyAccountMatch = FALSE;
    BOOLEAN GetBothPasswords = FALSE;

    PNL_GENERIC_RPC_DATA LocalTrustInfo = NULL;

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( TrustedDcName );

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the Session key for this session.
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    SessionInfo.SessionKey = ServerSession->SsSessionKey;
    // SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;


    //
    // now verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator( ServerSession,
                                   Authenticator,
                                   ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        goto Cleanup;
    }

    //
    // Check if we need to verify whether the trusted side
    // is allowed to get passwords for this particular account.
    // For our BDC, we allow full access to trust info.
    //

    if ( ServerSession->SsSecureChannelType != ServerSecureChannel ) {
        ServerSessionAccountRid = ServerSession->SsAccountRid;
        VerifyAccountMatch = TRUE;
    }

    //
    // See if we need to get both new and previous passwords
    //

    if ( IsDomainSecureChannelType( AccountType ) ) {
        GetBothPasswords = TRUE;
    }
    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

    //
    // Get the password for the account.
    //

    Status = NlGetIncomingPassword(
                            DomainInfo,
                            AccountName,
                            AccountType,
                            0,      // Let routine compute from AccountType
                            TRUE,   // Fail if account is disabled
                            &NewOwfPassword,
                            GetBothPasswords ?
                                &OldOwfPassword :
                                NULL,
                            &AccountRid,
                            &TrustAttributes,  // Get trust attributes
                            NULL ); // Don't need the account type

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // See if we need to verify that the account requested is
    // the one for which this server session was created.
    //

    if ( VerifyAccountMatch && ServerSessionAccountRid != AccountRid ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
            "NetrServerTrustPasswordsGet: %ws with AccountRid %lu asked for wrong account %ws and Rid %lu.\n",
            ComputerName,
            ServerSessionAccountRid,
            AccountName,
            AccountRid ));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Encrypt the passwords again with the session key.
    //  The trusting side DC will decrypt it on the other side.
    //

    Status = RtlEncryptNtOwfPwdWithNtOwfPwd(
                        &NewOwfPassword,
                        (PNT_OWF_PASSWORD) &SessionInfo.SessionKey,
                        EncryptedNewOwfPassword) ;

    if ( !NT_SUCCESS( Status )) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrServerTrustPasswordsGet: Cannot RtlEncryptNtOwfPwdWithNtOwfPwd 0x%lx\n",
                Status));
        goto Cleanup;
    }

    //
    // If no password exists on the account,
    //  return a blank password.
    //

    if ( !GetBothPasswords ) {
        UNICODE_STRING TempUnicodeString;

        RtlInitUnicodeString( &TempUnicodeString, NULL );
        Status = RtlCalculateNtOwfPassword( &TempUnicodeString,
                                            &OldOwfPassword );
        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NetrServerTrustPasswordsGet: %ws: cannot RtlCalculateNtOwfPassword (NULL) 0x%lx\n",
                    AccountName,
                    Status ));
            goto Cleanup;
        }
    }

    Status = RtlEncryptNtOwfPwdWithNtOwfPwd(
                        &OldOwfPassword,
                        (PNT_OWF_PASSWORD) &SessionInfo.SessionKey,
                        EncryptedOldOwfPassword) ;

    if ( !NT_SUCCESS( Status )) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrServerTrustPasswordsGet: Cannot RtlEncryptNtOwfPwdWithNtOwfPwd 0x%lx\n",
                Status));
        goto Cleanup;
    }

    //
    // Return the trust attributes if requested.
    //  Must be the first item on the list of
    //  ULONGs returned.
    //

    if ( TrustInfo != NULL ) {
        NET_API_STATUS NetStatus;

        NetStatus = NetApiBufferAllocate( sizeof(NL_GENERIC_RPC_DATA)+sizeof(ULONG),
                                          &LocalTrustInfo );
        if ( NetStatus != NO_ERROR ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlZeroMemory( LocalTrustInfo, sizeof(NL_GENERIC_RPC_DATA)+sizeof(ULONG) );

        LocalTrustInfo->UlongEntryCount = 1;
        LocalTrustInfo->UlongData = (PULONG)(LocalTrustInfo+1);
        *( (PULONG)(LocalTrustInfo+1) ) = TrustAttributes;

        *TrustInfo = LocalTrustInfo;
    }

    Status = STATUS_SUCCESS;

    //
    // Common exit point
    //

Cleanup:

    //
    // If the request failed, be carefull to not leak authentication
    // information.
    //

    if ( !NT_SUCCESS( Status ) )  {
        RtlZeroMemory( ReturnAuthenticator, sizeof(*ReturnAuthenticator) );
        RtlZeroMemory( EncryptedNewOwfPassword, sizeof(*EncryptedNewOwfPassword) );
        RtlZeroMemory( EncryptedOldOwfPassword, sizeof(*EncryptedOldOwfPassword) );

        if ( LocalTrustInfo != NULL ) {
            NetApiBufferFree( LocalTrustInfo );
        }
    }

    NlPrintDom((NL_MISC, DomainInfo,
            "NetrServerPasswordGet: Comp=%ws Acc=%ws returns 0x%lX\n",
            ComputerName,
            AccountName,
            Status ));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return Status;
}


NTSTATUS
NetrServerTrustPasswordsGet(
    IN LPWSTR TrustedDcName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNewOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword
    )
/*++

Routine Description:

    This function is used by a trusting side DC/workstation to get the
    new and old passwords from the trusted side. The account name
    requested must match the account name used at the secure channel
    setup time unless the call is made by a BDC to its PDC; the BDC
    has full access to the entire trust info.

    This function can only be called by a server which has previously
    authenticated with a DC by calling I_NetServerAuthenticate.

    This function uses RPC to contact the DC named by TrustedDcName.

Arguments:

    TrustedDcName -- Computer name of the DC to remote the call to.

    AccountName -- Name of the account to get the password for.

    AccountType -- The type of account being accessed.

    ComputerName -- Name of the machine making the call.

    Authenticator -- supplied by the server making the call.

    ReturnAuthenticator -- Receives an authenticator returned by the
        trusted side DC.

    EncryptedNewOwfPassword -- Returns the new OWF password of the account.

    EncryptedOldOwfPassword -- Returns the old OWF password of the account.

Return Value:

    NT status code.

--*/
{
    return NetrServerGetTrustInfo(
                    TrustedDcName,
                    AccountName,
                    AccountType,
                    ComputerName,
                    Authenticator,
                    ReturnAuthenticator,
                    EncryptedNewOwfPassword,
                    EncryptedOldOwfPassword,
                    NULL );  // no trust attributes
}


NTSTATUS
NetrServerPasswordSet(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PENCRYPTED_LM_OWF_PASSWORD UasNewPassword
    )
/*++

Routine Description:

    See NetpServerPasswordSet.

Arguments:

    See NetpServerPasswordSet.

Return Value:

    See NetpServerPasswordSet.

--*/
{
    return NetpServerPasswordSet( PrimaryName,
                                  AccountName,
                                  AccountType,
                                  ComputerName,
                                  Authenticator,
                                  ReturnAuthenticator,
                                  UasNewPassword,
                                  NULL );   // No clear password
}



NTSTATUS
NetrServerPasswordSet2(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PNL_TRUST_PASSWORD ClearNewPassword
    )
/*++

Routine Description:

    See NetpServerPasswordSet.

Arguments:

    See NetpServerPasswordSet.

Return Value:

    See NetpServerPasswordSet.

--*/
{
    return NetpServerPasswordSet( PrimaryName,
                                  AccountName,
                                  AccountType,
                                  ComputerName,
                                  Authenticator,
                                  ReturnAuthenticator,
                                  NULL, // No OWF password
                                  ClearNewPassword );
}


NTSTATUS
NlPackSerialNumber (
    IN PLARGE_INTEGER SerialNumber,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN LPDWORD BufferSize,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    Pack the specified serial number as a delta.

Arguments:

    SerialNumber - The serial number to pack.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

    SessionInfo: Info describing BDC that's calling us

Return Value:

    NT status code.

--*/
{
    PNLPR_MODIFIED_COUNT DeltaSerialNumberSkip;
    PSAMPR_USER_INFO_BUFFER UserAll = NULL;

    //
    // Only pack this delta if the BDC expects it.
    //

    NlAssert( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_BDC_CHANGELOG);
    UNREFERENCED_PARAMETER(SessionInfo);

    NlPrint(( NL_SYNC_MORE,
              "Packing skip to serial number delta: %lx %lx\n",
              SerialNumber->HighPart,
              SerialNumber->LowPart ));

    *BufferSize = 0;

    Delta->DeltaType = SerialNumberSkip;
    Delta->DeltaID.Rid = 0;
    Delta->DeltaUnion.DeltaSerialNumberSkip = NULL;

    //
    // Allocate a buffer to return to the caller.
    //

    DeltaSerialNumberSkip = (PNLPR_MODIFIED_COUNT)
        MIDL_user_allocate( sizeof(*DeltaSerialNumberSkip) );

    if (DeltaSerialNumberSkip == NULL) {
        return STATUS_NO_MEMORY;
    }

    *BufferSize += sizeof(*DeltaSerialNumberSkip);

    //
    // Copy the serial number into the buffer.
    //

    RtlCopyMemory( &DeltaSerialNumberSkip->ModifiedCount,
                   SerialNumber,
                   sizeof( DeltaSerialNumberSkip->ModifiedCount ) );

    Delta->DeltaUnion.DeltaSerialNumberSkip = DeltaSerialNumberSkip;


    //
    // All Done
    //

    return STATUS_SUCCESS;
}



NTSTATUS
NlPackSingleDelta (
    IN PCHANGELOG_ENTRY ChangeLogEntry,
    IN OUT PNETLOGON_DELTA_ENUM_ARRAY DeltaArray,
    OUT LPDWORD BufferConsumed,
    IN PSESSION_INFO SessionInfo,
    IN BOOLEAN ReturnSerialNumberDeltas
    )
/*++

Routine Description:

    Pack the deltas for a single change log entry.

Arguments:

    ChangeLogEntry - The Change Log Entry describing the account to pack.

    DeltaArray - Describes the array of deltas.  The appropriate deltas will
        be added to the end of this array.  The caller has guaranteed that
        that is room for at least MAX_DELTAS_PER_CHANGELOG - 1
        deltas to be added to the array.

    BufferConsumed - returns the size of MIDL buffer that is consumed for the
        returned deltas

    SessionInfo: Info describing BDC that's calling us

    ReturnSerialNumberDeltas -- True if serial number deltas should be returned
        when needed.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PDB_INFO DBInfo;
    DWORD BufferSize;

    UNICODE_STRING UnicodeSecretName;
    LPWSTR AccountName;
    PSID Sid;

    //
    // Initialization
    //

    DBInfo = &NlGlobalDBInfoArray[ChangeLogEntry->DBIndex];
    *BufferConsumed = 0;

    //
    // Macro to account for another delta array entry being consumed/returned
    //

#   define MoveToNextDeltaArrayEntry( _BufferSize ) \
        *BufferConsumed += (sizeof(NETLOGON_DELTA_ENUM) + _BufferSize); \
        (DeltaArray->CountReturned)++;

    //
    // Put the data for the changelog entry into the user's buffer.
    //

    switch ( ChangeLogEntry->DeltaType ) {
    case AddOrChangeDomain:
        Status = NlPackSamDomain(
                    &((DeltaArray->Deltas)
                        [DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );
        break;

    //
    // The DS can't distinguish between a membership change and a property change.
    //  always replicate all aspects of the group.
    //

    case AddOrChangeGroup:
    case ChangeGroupMembership:
    case RenameGroup:

        //
        // we treat the rename as three deltas.
        //  1. AddorChangeGroup delta.
        //      Backup deletes the account with old name and creates
        //      an account with new name.
        //
        //  2. Delta to tell the BDC that delta (3) below is for the
        //     same serial number as delta (1) above.
        //
        //  3. ChangeGroupMembership delta.
        //      Backup readds all members to new group.
        //

        Status = NlPackSamGroup( ChangeLogEntry->ObjectRid,
                    &((DeltaArray->Deltas)
                        [DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );

        if( !NT_SUCCESS( Status ) ) {
            break;
        }

        MoveToNextDeltaArrayEntry( BufferSize );


        if ( ReturnSerialNumberDeltas ) {

            Status = NlPackSerialNumber(
                        &ChangeLogEntry->SerialNumber,
                        &((DeltaArray->Deltas)
                            [DeltaArray->CountReturned]),
                        &BufferSize,
                        SessionInfo );

            if( !NT_SUCCESS( Status ) ) {
                break;
            }

            MoveToNextDeltaArrayEntry( BufferSize );
        }

        Status = NlPackSamGroupMember( ChangeLogEntry->ObjectRid,
                    &((DeltaArray->Deltas)
                        [DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );

        break;

    case AddOrChangeUser:
    case RenameUser:
        Status = NlPackSamUser( ChangeLogEntry->ObjectRid,
                    &((DeltaArray->Deltas)
                        [DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize,
                    SessionInfo );

        break;


    //
    // The DS can't distinguish between a membership change and a property change.
    //  always replicate all aspects of the alias.
    //
    case AddOrChangeAlias:
    case ChangeAliasMembership:
    case RenameAlias:

        //
        // we treat the rename as two deltas.
        //  1. AddorChangeAlias delta.
        //      Backup deletes the account with old name and creates
        //      an account with new name.
        //
        //  2. Delta to tell the BDC that delta (3) below is for the
        //     same serial number as delta (1) above.
        //
        //  3. ChangeAliasMembership delta.
        //      Backup readds all members to new alias.
        //

        Status = NlPackSamAlias( ChangeLogEntry->ObjectRid,
                    &((DeltaArray->Deltas)
                        [DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );

        if( !NT_SUCCESS( Status ) ) {
            break;
        }

        MoveToNextDeltaArrayEntry( BufferSize );

        if ( ReturnSerialNumberDeltas ) {

            Status = NlPackSerialNumber(
                        &ChangeLogEntry->SerialNumber,
                        &((DeltaArray->Deltas)
                            [DeltaArray->CountReturned]),
                        &BufferSize,
                        SessionInfo );

            if( !NT_SUCCESS( Status ) ) {
                break;
            }

            MoveToNextDeltaArrayEntry( BufferSize );
        }

        Status = NlPackSamAliasMember( ChangeLogEntry->ObjectRid,
                    &((DeltaArray->Deltas)
                        [DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );

        break;

    case AddOrChangeLsaPolicy:

        Status = NlPackLsaPolicy(
            &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
            DBInfo,
            &BufferSize );

        break;

    case AddOrChangeLsaTDomain:

        NlAssert( ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED );

        if( (ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED) == 0 ) {
            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            break;
        }

        Status = NlPackLsaTDomain(
            (PSID) ((LPBYTE)ChangeLogEntry + sizeof(CHANGELOG_ENTRY)),
            &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
            DBInfo,
            &BufferSize );

        break;

    case AddOrChangeLsaAccount:

        NlAssert( ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED );

        if( (ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED) == 0 ) {
            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            break;
        }

        Status = NlPackLsaAccount(
            (PSID) ((LPBYTE)ChangeLogEntry + sizeof(CHANGELOG_ENTRY)),
            &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
            DBInfo,
            &BufferSize,
            SessionInfo );

        break;

    case AddOrChangeLsaSecret:

        NlAssert( ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED );

        if( (ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED) == 0 ) {
            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            break;
        }

        RtlInitUnicodeString(
            &UnicodeSecretName,
            (LPWSTR) ((LPBYTE)ChangeLogEntry + sizeof(CHANGELOG_ENTRY)) );

        Status = NlPackLsaSecret(
            &UnicodeSecretName,
            &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
            DBInfo,
            &BufferSize,
            SessionInfo );

        break;

    case DeleteGroup:
    case DeleteGroupByName:
    case DeleteUser:
    case DeleteUserByName:

        //
        // If this is an NT 3.5 BDC,
        //  send the account name upon account deletion.

        if ( ReturnSerialNumberDeltas ) {

            //
            // Send the NT 3.5 BDC a special delta type indicating the
            //  Name is attached.
            //
            if ( ChangeLogEntry->DeltaType == DeleteGroup ) {
                (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaType =
                    DeleteGroupByName;
            } else if ( ChangeLogEntry->DeltaType == DeleteUser ) {
                (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaType =
                    DeleteUserByName;
            } else {
                (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaType =
                    ChangeLogEntry->DeltaType;
            }

            (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaID.Rid =
                ChangeLogEntry->ObjectRid;


            //
            // Add the account name to the entry.
            //

            NlAssert(ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED);

            if( (ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED) == 0 ) {
                Status = STATUS_SYNCHRONIZATION_REQUIRED;
                break;
            }

            BufferSize = (wcslen(
                            (LPWSTR) ((LPBYTE)ChangeLogEntry +
                                sizeof(CHANGELOG_ENTRY))) + 1 ) *
                            sizeof(WCHAR);

            AccountName = (LPWSTR) MIDL_user_allocate( BufferSize );

            if (AccountName == NULL) {
                Status = STATUS_NO_MEMORY;
                break;
            }

            wcscpy( AccountName,
                    (LPWSTR) ((LPBYTE)ChangeLogEntry + sizeof(CHANGELOG_ENTRY)));

            (DeltaArray->Deltas)[DeltaArray->CountReturned].
                DeltaUnion.DeltaDeleteGroup =
                MIDL_user_allocate(sizeof(struct _NETLOGON_DELTA_DELETE));

            if ((DeltaArray->Deltas)[DeltaArray->CountReturned].
                    DeltaUnion.DeltaDeleteGroup == NULL ) {
                MIDL_user_free(AccountName);
                Status = STATUS_NO_MEMORY;
                break;
            }

            INIT_PLACE_HOLDER( (DeltaArray->Deltas)[DeltaArray->CountReturned].
                DeltaUnion.DeltaDeleteGroup );
            (DeltaArray->Deltas)[DeltaArray->CountReturned].
                DeltaUnion.DeltaDeleteGroup->AccountName = AccountName;

            break;  // out of switch
        }

        /* Drop through to handle NT 3.1 case. */

    case DeleteAlias:

        (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaType =
            ChangeLogEntry->DeltaType;
        (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaID.Rid =
            ChangeLogEntry->ObjectRid;

        BufferSize = 0;

        break;

    case DeleteLsaTDomain:
    case DeleteLsaAccount:

        NlAssert( ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED );

        if( (ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED) == 0 ) {
            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            break;
        }

        BufferSize =
            RtlLengthSid( (PSID)((LPBYTE)ChangeLogEntry + sizeof(CHANGELOG_ENTRY)));

        Sid = (PSID) MIDL_user_allocate( BufferSize );

        if( Sid == NULL ) {
            Status = STATUS_NO_MEMORY;
            break;
        }

        Status = RtlCopySid (
                    BufferSize,
                    Sid,
                    (PSID) ((LPBYTE)ChangeLogEntry + sizeof(CHANGELOG_ENTRY)));

        if( !NT_SUCCESS( Status ) ) {
            MIDL_user_free( Sid );
            break;
        }


        (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaType =
            ChangeLogEntry->DeltaType;
        (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaID.Sid =
            Sid;

        break;

    case DeleteLsaSecret:

        NlAssert(ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED);

        if( (ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED) == 0 ) {
            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            break;
        }

        BufferSize = (wcslen(
                        (LPWSTR) ((LPBYTE)ChangeLogEntry +
                            sizeof(CHANGELOG_ENTRY))) + 1 ) *
                        sizeof(WCHAR);

        AccountName = (LPWSTR) MIDL_user_allocate( BufferSize );

        if (AccountName == NULL) {
            Status = STATUS_NO_MEMORY;
            break;
        }

        wcscpy( AccountName,
                (LPWSTR) ((LPBYTE)ChangeLogEntry + sizeof(CHANGELOG_ENTRY)));

        (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaType =
            ChangeLogEntry->DeltaType;
        (DeltaArray->Deltas)[DeltaArray->CountReturned].DeltaID.Name =
            AccountName;

        break;

    default:
        NlPrint((NL_CRITICAL, "NlPackSingleDelta: Invalid delta type in change log\n"));

        Status = STATUS_SYNCHRONIZATION_REQUIRED;
        break;
    }

    if ( NT_SUCCESS(Status) ) {
        MoveToNextDeltaArrayEntry( BufferSize );
    }

    return Status;
#undef MoveToNextDeltaArrayEntry
}


NTSTATUS
NetrDatabaseDeltas (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN OUT PNLPR_MODIFIED_COUNT NlDomainModifiedCount,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArrayRet,
    IN DWORD PreferredMaximumLength
    )
/*++

Routine Description:

    This function is used by a SAM BDC to
    request SAM-style account delta information from a SAM PDC.  This
    function can only be called by a server which has previously
    authenticated with the PDC by calling I_NetServerAuthenticate.  This
    function uses RPC to contact the Netlogon service on the PDC.

    This function returns a list of deltas.  A delta describes an
    individual domain, user or group and all of the field values for that
    object.  The PDC maintains a list of deltas not including all of the
    field values for that object.  Rather, the PDC retrieves the field
    values from SAM and returns those values from this call.  The PDC
    optimizes the data returned on this call by only returning the field
    values for a particular object once on a single invocation of this
    function.  This optimizes the typical case where multiple deltas
    exist for a single object (e.g., an application modified many fields
    of the same user during a short period of time using different calls
    to the SAM service).

Arguments:

    PrimaryName -- Name of the PDC to retrieve the deltas from.

    ComputerName -- Name of the BDC or member server making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    DatabaseID -- Identifies the databse for which the deltas are requested.
        For SAM database the ID is 0, for Builtin Domain the ID is 1. Other
        databases may be defined later.

    NlDomainModifiedCount -- Specifies the DomainModifiedCount of the
        last delta retrieved by the server.  Returns the
        DomainModifiedCount of the last delta returned from the PDC
        on this call.

    Deltas -- Receives a pointer to a buffer where the information is
        placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

    PreferredMaximumLength - Preferred maximum length of returned
        data (in 8-bit bytes).  This is not a hard upper limit, but
        serves as a guide to the server.  Due to data conversion
        between systems with different natural data sizes, the actual
        amount of data returned may be greater than this value.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_SYNCHRONIZATION_REQUIRED -- The replicant is totally out of sync and
        should call I_NetDataSync to do a full synchronization with
        the PDC.

    STATUS_MORE_ENTRIES -- The replicant should call again to get more
        data.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.


--*/
{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;
    PSERVER_SESSION ServerSession = NULL;
    PCHANGELOG_ENTRY ChangeLogEntry = NULL;
    BOOLEAN PackThisEntry = TRUE;

    BOOL ChangelogLocked = FALSE;

    PDB_INFO DBInfo;
    LARGE_INTEGER RunningSerialNumber;
    LARGE_INTEGER PackedSerialNumber;
    LARGE_INTEGER OriginalSerialNumber;

    DWORD BufferConsumed = 0;
    DWORD BufferSize = 0;

    PNETLOGON_DELTA_ENUM_ARRAY DeltaArray;


    SESSION_INFO SessionInfo;

    DEFSSIAPITIMER;

    INITSSIAPITIMER;
    STARTSSIAPITIMER;

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation || !NlGlobalPdcDoReplication ) {
        NlPrint((NL_CRITICAL,
                "NetrDatabaseDeltas: called from %ws.  This machine doesn't support replication.\n",
                ComputerName ));
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If the DS is recovering from a backup,
    //  avoid changing the DS.
    //

    if ( NlGlobalDsPaused ) {
        NlPrint((NL_CRITICAL,
                 "NetrDatabaseDeltas: DsIsPaused.\n"));
        // Don't return a new status code since NT 4 DC would do a full sync
        return STATUS_ACCESS_DENIED;
    }

    //
    // Gross hack because of RPC implementation.
    //
    // Rpc executes API calls in an I/O completion port thread.  If this thread
    //  goes CPU bound, then no other RPC will be allowed to start.  Even worse,
    //  there is only one outstanding listen, so the 'second' coming RPC call
    //  gets RPC_S_SERVER_TOO_BUSY.
    //
    // By sleeping here (even for a short period) the I/O completion port releases
    // another thread since it thinks this thread went I/O bound.
    //
    // We've seen this thread go CPU bound doing a full sync of a database with
    // 1000's of LSA account objects.
    //

    RpcServerYield();

    //
    // Initialization
    //
    if ( DatabaseID >= NUM_DBS ) {
        return STATUS_INVALID_LEVEL;
    }

    *DeltaArrayRet = DeltaArray = (PNETLOGON_DELTA_ENUM_ARRAY)
            MIDL_user_allocate( sizeof(NETLOGON_DELTA_ENUM_ARRAY) );

    if( DeltaArray == NULL ) {
        return STATUS_NO_MEMORY;
    }

    DeltaArray->CountReturned = 0;
    DeltaArray->Deltas = NULL;
    SessionInfo.NegotiatedFlags = 0;


    DBInfo = &NlGlobalDBInfoArray[DatabaseID];


    RtlCopyMemory( &RunningSerialNumber,
                   &NlDomainModifiedCount->ModifiedCount,
                   sizeof(RunningSerialNumber));

    OriginalSerialNumber.QuadPart = RunningSerialNumber.QuadPart;
    PackedSerialNumber.QuadPart = RunningSerialNumber.QuadPart;



    //
    // Find the domain this API was made to.
    //

    DomainInfo = NlFindDomainByServerName( PrimaryName );

    NlPrintDom((NL_SYNC, DomainInfo,
            "NetrDatabaseDeltas: " FORMAT_LPWSTR " partial sync called by " FORMAT_LPWSTR
            " SerialNumber:%lx %lx.\n",
            DBInfo->DBName,
            ComputerName,
            RunningSerialNumber.HighPart,
            RunningSerialNumber.LowPart ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    if ( !IsPrimaryDomain( DomainInfo )) {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }



    //
    // Retrieve the requestor's entry to get sessionkey
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        NlPrint((NL_CRITICAL,
                 "NetrDatabaseDeltas: No server session.\n"));
        // Don't log this event since it happens in nature after a reboot
        // or after we scavenge the server session.
        goto CleanupNoEventlog;
    }

    //
    // Allow this call only on ServerSecureChannel.
    //

    if( ServerSession->SsSecureChannelType != ServerSecureChannel ) {

        //
        // If the only preblem is that this BDC hasn't authenticated,
        //  silently ask it to authenticate.
        //
        if ( ServerSession->SsSecureChannelType == NullSecureChannel ) {
            NlPrint((NL_CRITICAL,
                     "NetrDatabaseDeltas: No authenticated server session.\n"));
            ServerSession = NULL;
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            // Don't log this event since it happens in nature after a reboot
            // or after we scavenge the server session.
            Status = STATUS_ACCESS_DENIED;
            goto CleanupNoEventlog;
        } else {
            NlPrint((NL_CRITICAL,
                     "NetrDatabaseDeltas: SecureChannel type isn't BDC. %ld\n",
                     ServerSession->SsSecureChannelType ));
            ServerSession = NULL;
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }
    }

    //
    // Verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator( ServerSession,
                                   Authenticator,
                                   ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

        NlPrint((NL_CRITICAL, "NetrDatabaseDeltas: authentication failed.\n" ));

        ServerSession = NULL;
        goto Cleanup;
    }


    //
    // Prevent entry from being deleted, but drop the global lock.
    //
    // Beware of server with two concurrent calls outstanding
    //  (must have rebooted.)
    //

    if (ServerSession->SsFlags & SS_LOCKED ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

        NlPrint((NL_CRITICAL, "NetrDatabaseDeltas: Concurrent call detected.\n" ));

        Status = STATUS_ACCESS_DENIED;
        ServerSession = NULL;
        goto Cleanup;
    }
    ServerSession->SsFlags |= SS_LOCKED;

    SessionInfo.SessionKey = ServerSession->SsSessionKey;
    SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;

    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );


    //
    // If the BDC is in sync,
    //  simply return.
    //

    LOCK_CHANGELOG();
    ChangelogLocked = TRUE;

    if ( RunningSerialNumber.QuadPart ==
             NlGlobalChangeLogDesc.SerialNumber[DatabaseID].QuadPart ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Get a copy of the appropriate entry in the change_log.
    // Note that the record_id contains last record received by client.
    //

    if ((ChangeLogEntry = NlGetNextUniqueChangeLogEntry(
                                &NlGlobalChangeLogDesc,
                                RunningSerialNumber,
                                DBInfo->DBIndex,
                                NULL ))== NULL) {

        //
        // Handle the case where the BDC has more recent changes than we do.
        //
        // Just return our newest change log entry with the same promotion count.
        // The BDC will realize what's going on and un-do its newer changes.
        //
        // Only do this if our PromotionCount is greater than the BDCs.  If
        // our promotion count is equal to that of the BDC, either our change log
        // has wrapped, or the BDC is royally confused.
        //
        // Don't be tempted to return a change log entry with an
        // older promotion count.  We'd have no way of knowing which delta
        // to actually return to the caller.
        //

        if ( ((NlGlobalChangeLogDesc.SerialNumber[DatabaseID].HighPart &
                    NlGlobalChangeLogPromotionMask) >
              (RunningSerialNumber.HighPart & NlGlobalChangeLogPromotionMask)) &&
             (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_REDO) ) {

            ChangeLogEntry = NlFindPromotionChangeLogEntry(
                                &NlGlobalChangeLogDesc,
                                RunningSerialNumber,
                                DBInfo->DBIndex );

            //
            // Don't actually pack this change log entry.  We've found it
            // so we can pack a "serial number" delta.  But the BDC already
            // has this particular change.
            //

            PackThisEntry = FALSE;
        }

        if ( ChangeLogEntry == NULL ) {
            NlPrint((NL_CRITICAL,
                    "NetrDatabaseDeltas: "
                    "delta not found in cache, returning full required.\n" ));

            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            goto Cleanup;
        } else {
            NlPrint((NL_SYNC, "NetrDatabaseDeltas: BDC more recent than PDC (recovering).\n" ));
        }
    }

    UNLOCK_CHANGELOG();
    ChangelogLocked = FALSE;

    //
    // Allocate memory for delta buffer.
    //

    DeltaArray->Deltas = (PNETLOGON_DELTA_ENUM) MIDL_user_allocate(
                    MAX_DELTA_COUNT * sizeof(NETLOGON_DELTA_ENUM) );

    if( DeltaArray->Deltas == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaArray->Deltas,
                    MAX_DELTA_COUNT * sizeof(NETLOGON_DELTA_ENUM) );


    //
    // Loop packing deltas as long as there is room for more deltas
    //
    // In some cases we pack multiple deltas on the wire for one entry in the
    // change log, we want to ensure that all of these deltas are sent to
    // the BDC on a single call.
    //

    while ( DeltaArray->CountReturned + MAX_DELTAS_PER_CHANGELOG <= MAX_DELTA_COUNT ) {

        //
        // If the serial number of the delta being packed isn't the one
        // expected by the BDC, tell the BDC what the serial number is.
        //

        if ( ChangeLogEntry->SerialNumber.QuadPart !=
                PackedSerialNumber.QuadPart + 1 ) {

            if ( SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_BDC_CHANGELOG){

                Status = NlPackSerialNumber(
                            &ChangeLogEntry->SerialNumber,
                            &((DeltaArray->Deltas)
                                [DeltaArray->CountReturned]),
                            &BufferSize,
                            &SessionInfo );
                if( !NT_SUCCESS( Status ) ) {
                    goto Cleanup;
                }

                BufferConsumed += BufferSize;
                DeltaArray->CountReturned ++;

                //
                // If we're not really going to pack the entry,
                //  pretend that we already have.
                //
                if ( !PackThisEntry) {
                    PackedSerialNumber.QuadPart = ChangeLogEntry->SerialNumber.QuadPart;
                }
            }

        }


        if ( PackThisEntry ) {

            //
            // Put the data for the changelog entry into the user's buffer.
            //

            Status = NlPackSingleDelta( ChangeLogEntry,
                                        DeltaArray,
                                        &BufferSize,
                                        &SessionInfo,
                                        (BOOLEAN)((SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_BDC_CHANGELOG) != 0) );

            //
            // If we successfully put the delta into the delta array,
            //  do the bookwork
            //

            if ( NT_SUCCESS( Status ) ) {

                BufferConsumed += BufferSize;

                PackedSerialNumber.QuadPart = ChangeLogEntry->SerialNumber.QuadPart;

                NlPrint((NL_SYNC_MORE,
                        "NetrDatabaseDeltas: Modified count of the "
                        "packed record: %lx %lx\n",
                            ChangeLogEntry->SerialNumber.HighPart,
                            ChangeLogEntry->SerialNumber.LowPart ));


            //
            // In the case where an user/group/alias record was
            // added and deleted before the delta was made we will
            // trace the change log and see there is correpondance
            // delete log.  If we found one then ignore this delta
            // and proceed to the next delta.  If we couldn't find
            // one then return error STATUS_SYNCHRONIZATION_REQUIRED.
            //

            } else if ( IsObjectNotFoundStatus( ChangeLogEntry->DeltaType, Status ) ) {

                if( !NlRecoverChangeLog(ChangeLogEntry) ) {

                    NlPrint((NL_CRITICAL,
                            "NetrDatabaseDeltas: object not found in database, and no delete delta found (%lx).\n",
                            Status ));

#ifdef notdef
                    Status = STATUS_SYNCHRONIZATION_REQUIRED;

                    IF_NL_DEBUG( BREAKPOINT ) {
                        NlAssert( FALSE );
                    }

                    goto Cleanup;
#else // notdef

                    //
                    // NT 5.0 SAM doesn't hold the write lock while determining if
                    //  the object exists.  So, the object might have been deleted and
                    //  the but the delete delta hasn't been written to the change log yet.
                    //  So, assume that the delete delta will appear sooner or later.
                    //
                    // REVIEW: I could just pack a delete delta.
                    //

                    Status = STATUS_SUCCESS;
#endif // notdef

                } else {

                    //
                    // We found a delete delta, so ignore the original delta.
                    //

                    Status = STATUS_SUCCESS;
                }

            //
            // All other errors are fatal
            //

            } else {
                goto Cleanup;
            }
        }

        PackThisEntry = TRUE;


        //
        // Free up used temp. record
        //

        RunningSerialNumber.QuadPart = ChangeLogEntry->SerialNumber.QuadPart;
        NetpMemoryFree(ChangeLogEntry);
        ChangeLogEntry = NULL;

        //
        // If we've returned all the entries, we're all done.
        //

        LOCK_CHANGELOG();
        ChangelogLocked = TRUE;

        if ((ChangeLogEntry = NlGetNextUniqueChangeLogEntry(
                                &NlGlobalChangeLogDesc,
                                RunningSerialNumber,
                                DBInfo->DBIndex,
                                NULL )) == NULL) {
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        UNLOCK_CHANGELOG();
        ChangelogLocked = FALSE;


        //
        // Don't return more data to the caller than he wants.
        //

        if( BufferConsumed >= PreferredMaximumLength) {
            Status = STATUS_MORE_ENTRIES;
            goto Cleanup;
        }

        //
        // If we're debugging replication, return only one change to the caller.
        //
#if NETLOGONDBG
        if ( NlGlobalParameters.DbFlag & NL_ONECHANGE_REPL ) {
            Status = STATUS_MORE_ENTRIES;
            goto Cleanup;
        }
#endif // NETLOGONDBG


        //
        // If the service is going down, stop packing deltas and
        // return to the caller.
        //

        if( NlGlobalTerminate ) {

            NlPrint((NL_CRITICAL, "NetrDatabaseDeltas is asked to return "
                        "when the service is going down.\n"));
            Status = STATUS_MORE_ENTRIES;
            goto Cleanup;
        }

    }

    Status = STATUS_MORE_ENTRIES;

Cleanup:

    //
    // write event log
    //

    if ( !NT_SUCCESS( Status ) ) {

        LPWSTR MsgStrings[2];

        MsgStrings[0] = ComputerName;
        MsgStrings[1] = (LPWSTR) LongToPtr( Status );

        NlpWriteEventlog(
            NELOG_NetlogonPartialSyncCallFailed,
            EVENTLOG_WARNING_TYPE,
            (LPBYTE)&Status,
            sizeof(Status),
            MsgStrings,
            2 | NETP_LAST_MESSAGE_IS_NTSTATUS | NETP_ALLOW_DUPLICATE_EVENTS );

    } else {

        //
        // Log the successful replication only if deltas have been returned
        // to the caller.
        //
        if ( DeltaArray->CountReturned != 0 ) {
            LPWSTR MsgStrings[2];
            WCHAR CountBuffer[20]; // random size

            MsgStrings[0] = ComputerName;

            ultow( DeltaArray->CountReturned, CountBuffer, 10);
            MsgStrings[1] = CountBuffer;

            NlpWriteEventlog(
                NELOG_NetlogonPartialSyncCallSuccess,
                EVENTLOG_INFORMATION_TYPE,
                NULL,
                0,
                MsgStrings,
                2 | NETP_ALLOW_DUPLICATE_EVENTS );
        }

    }


    //
    // Free up locally allocated resources.
    //

CleanupNoEventlog:

    //
    // Copy the serial number back to the caller
    //

    if ( NT_SUCCESS(Status)) {

        RtlCopyMemory( &NlDomainModifiedCount->ModifiedCount,
                       &PackedSerialNumber,
                       sizeof(PackedSerialNumber));


        //
        // If this is an NT 3.1 BDC,
        //  Only remember the latest Serial Number it asked for, AND
        //  force it the call back once it has updated the SerialNumber
        //  so we know what that serial number is.
        //
        // NT 3.5 BDCs "persistently" try to update their database to the
        // PDCs version once they get a pulse indicating their database is
        // out of date.
        //

        if ( (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_PERSISTENT_BDC) == 0 ) {

            //
            // Use the SerialNumber the BDC originally passed us.
            //

            PackedSerialNumber.QuadPart = OriginalSerialNumber.QuadPart;

            //
            // If we're returning any deltas at all,
            //  force the BDC to call us back.
            //

            if ( Status == STATUS_SUCCESS && DeltaArray->CountReturned != 0 ) {
                Status = STATUS_MORE_ENTRIES;
            }

        }

    //
    // If we weren't successful,
    //  Don't return any deltas.
    //

    } else {
        if ( DeltaArray->Deltas != NULL ) {
            NlFreeDBDeltaArray( DeltaArray->Deltas, DeltaArray->CountReturned );
            DeltaArray->Deltas = NULL;
        }
        DeltaArray->CountReturned = 0;

    }

    if ( ChangelogLocked ) {
        UNLOCK_CHANGELOG();
    }

    if( ChangeLogEntry != NULL) {
        NetpMemoryFree( ChangeLogEntry );
    }

    //
    // Unlock the server session entry if we've locked it.
    //

    if ( ServerSession != NULL ) {

        //
        // If we are successfully returning these deltas to the BDC,
        //  update our tables to reflect the changes.
        //

        if ( Status == STATUS_SUCCESS ) {
            NlPrimaryAnnouncementFinish( ServerSession,
                                         DatabaseID,
                                         &PackedSerialNumber );

        }
        NlUnlockServerSession( ServerSession );
    }

    //
    // If the BDC called us just as SAM was shutting down,
    //  map the status to prevent the BDC from full syncing.
    //

    if ( Status == STATUS_INVALID_SERVER_STATE ) {
        Status = STATUS_ACCESS_DENIED;
    }


    NlPrint((NL_SYNC,
            "NetrDatabaseDeltas: " FORMAT_LPWSTR " returning (0x%lx) to "
            FORMAT_LPWSTR "\n",
            DBInfo->DBName,
            Status,
            ComputerName ));

    STOPSSIAPITIMER;

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    NlPrint((NL_REPL_TIME,"NetrDatabaseDeltas Time:\n"));
    PRINTSSIAPITIMER;

    return Status;

}



NTSTATUS
NlSyncSamDatabase(
    IN PSERVER_SESSION ServerSession,
    IN DWORD DatabaseID,
    IN SYNC_STATE RestartState,
    IN OUT PULONG SyncContext,
    IN OUT PNETLOGON_DELTA_ENUM_ARRAY DeltaArray,
    IN DWORD PreferredMaximumLength,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    This function is a real worker for the NetrDatabaseSync function and
    retrieves a SAM database in the delta buffer.

    This function uses the find-first find-next model to return portions
    of the SAM database at a time.  The SAM database is returned as a
    list of deltas like those returned from I_NetDatabaseDeltas.  The
    following deltas are returned for each domain:

    *  One AddOrChangeDomain delta, followed by

    *  One AddOrChangeGroup delta for each group, followed by,

    *  One AddOrChangeUser delta for each user, followed by

    *  One ChangeGroupMembership delta for each group followed by,

    *  One AddOrChangeAlias delta for each alias, followed by,

    *  One ChangeAliasMembership delta for each alias.


Arguments:

    ServerSession -- pointer to connection context.

    DatabaseID -- Identifies the databse for which the deltas are requested.
        For SAM database the ID is 0, for Builtin Domain the ID is 1. Other
        databases may be defined later.

    RestartState -- Specifies whether this is a restart of the full sync and how
        to interpret SyncContext.  This value should be NormalState unless this
        is the restart of a full sync.

        However, if the caller is continuing a full sync after a reboot,
        the following values are used:

            GroupState - SyncContext is the global group rid to continue with.
            UserState - SyncContext is the user rid to continue with
            GroupMemberState - SyncContext is the global group rid to continue with
            AliasState - SyncContext should be zero to restart at first alias
            AliasMemberState - SyncContext should be zero to restart at first alias

        One cannot continue the LSA database in this way.

    SyncContext -- Specifies context needed to continue the
        operation.  The caller should treat this as an opaque
        value.  The value should be zero before the first call.

    DeltaArray -- Pointer to a buffer where the information
    is placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

    PreferredMaximumLength - Preferred maximum length of returned
        data (in 8-bit bytes).  This is not a hard upper limit, but
        serves as a guide to the server.  Due to data conversion
        between systems with different natural data sizes, the actual
        amount of data returned may be greater than this value.

    SessionInfo - Information shared between PDC and BDC.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_MORE_ENTRIES -- The replicant should call again to get more
        data.

--*/
{
    NTSTATUS Status;

    PSAM_SYNC_CONTEXT SamDBContext;

    PDB_INFO DBInfo;

    DWORD BufferConsumed = 0;
    DWORD BufferSize;

    DBInfo = &NlGlobalDBInfoArray[DatabaseID];


    //
    // Allocate memory for delta buffer.
    //

    DeltaArray->Deltas = (PNETLOGON_DELTA_ENUM) MIDL_user_allocate(
                    MAX_DELTA_COUNT * sizeof(NETLOGON_DELTA_ENUM) );

    if( DeltaArray->Deltas == NULL ) {


        NlPrint((NL_CRITICAL,
                "NlSyncSamDatabase: Can't allocate %d bytes\n",
                 MAX_DELTA_COUNT * sizeof(NETLOGON_DELTA_ENUM) ));

        return( STATUS_NO_MEMORY );
    }


    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaArray->Deltas,
                    MAX_DELTA_COUNT * sizeof(NETLOGON_DELTA_ENUM) );


    //
    // If this is the first call or an explicit restart call,
    //  allocate and initialize the sync context.
    //

    if ( *SyncContext == 0 || RestartState != NormalState ) {

        //
        // If there already is a sync context,
        //  delete it.
        //

        if ( ServerSession->SsSync != NULL ) {
            CLEAN_SYNC_CONTEXT( ServerSession->SsSync );
        } else {

            ServerSession->SsSync = NetpMemoryAllocate( sizeof(SYNC_CONTEXT) );
            if ( ServerSession->SsSync == NULL ) {

                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }
        }

        //
        // Initialize all the fields in the newly allocated resume handle
        //  to indicate that SAM has never yet been called.
        //

        INIT_SYNC_CONTEXT( ServerSession->SsSync, SamDBContextType );

        SamDBContext = &(ServerSession->SsSync->DBContext.Sam);
        SamDBContext->SyncSerial = 1;

        //
        // Compute the continuation state based on the input parameters
        //

        switch ( RestartState ) {
        case NormalState:

            //
            // Put the description of the Domain at the front of the buffer for the
            //  first call.
            //

            Status = NlPackSamDomain( &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                                        DBInfo,
                                        &BufferSize );

            (DeltaArray->CountReturned)++;
            BufferConsumed += BufferSize;

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            SamDBContext->SyncState = GroupState;
            SamDBContext->SamEnumHandle = 0;
            break;

        case AliasState:
        case AliasMemberState:
            if ( *SyncContext != 0 ) {
                NlPrint(( NL_CRITICAL,
                          "NlSyncSamDatabase: Cannot restart alias enumeration.\n" ));

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }
            /* Drop Through */

        case GroupState:
        case UserState:
        case GroupMemberState:
            SamDBContext->SyncState = RestartState;
            SamDBContext->SamEnumHandle = *SyncContext;
            break;

        default:
            NlPrint(( NL_CRITICAL,
                      "NlSyncSamDatabase: Invalid RestartState passed %ld.\n",
                      RestartState ));

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;


        }

    } else {

        // NlAssert( ServerSession->SsSync != NULL);

        if( ServerSession->SsSync == NULL)  {

            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            goto Cleanup;
        }

        NlAssert( ServerSession->SsSync->DBContextType ==
                        SamDBContextType);

        if(  ServerSession->SsSync->DBContextType !=
                SamDBContextType ) {

            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            goto Cleanup;
        }

        SamDBContext = &(ServerSession->SsSync->DBContext.Sam);

        NlAssert( SamDBContext->SyncSerial == *SyncContext );

        if( SamDBContext->SyncSerial != *SyncContext ) {

            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            goto Cleanup;
        }

        SamDBContext->SyncSerial++;
    }

    //
    // Loop for each entry placed in the output buffer
    //
    // Each iteration of the loop below puts one more entry into the array
    // returned to the caller.  The algorithm is split into 2 parts.  The
    // first part checks to see if we need to retrieve more information from
    // SAM and gets the description of several users or group from SAM in a
    // single call.  The second part puts a single entry into the buffer
    // returned to the caller.
    //

    while ( SamDBContext->SyncState != SamDoneState ) {

        //
        // If we've filled out pre-allocated array,
        //  return now.
        //
        if ( DeltaArray->CountReturned + MAX_DELTAS_PER_CHANGELOG > MAX_DELTA_COUNT ) {
            Status = STATUS_MORE_ENTRIES;
            goto Cleanup;
        }


        //
        // Get more information from SAM
        //
        // Handle when we've not yet called SAM or we've already consumed
        // all of the information returned on a previous call to SAM.
        //
        // This is a 'while' rather than an 'if' to handle the case
        // where SAM returns zero entries.
        //

        while ( SamDBContext->Index >= SamDBContext->Count ) {

            //
            // Free any previous buffer returned from SAM.
            //

            if ( ServerSession->SsSync != NULL ) {
                CLEAN_SYNC_CONTEXT( ServerSession->SsSync );
            }

            //
            // If we've already gotten everything from SAM,
            //  we've finished all of the groups,
            //
            // If we've just done the groups,
            //      go on to do the users.
            //
            // If we've just done the users,
            //      go on to do the group memberships.
            //
            // If we've just done the group memberships,
            //      go on to do the alias.
            //
            // If we've just done the alias,
            //      go on to do the alias membership.
            //
            // If we've just done the alias memberships,
            //      we're all done.
            //

            if ( SamDBContext->SamAllDone ) {

                SamDBContext->SamEnumHandle = 0;
                SamDBContext->Index = 0;
                SamDBContext->Count = 0;
                SamDBContext->SamAllDone = FALSE;

                if (SamDBContext->SyncState == GroupState ) {


                    NlPrint((NL_SYNC,
                            "NlSyncSamDatabase: packing user records.\n"));

                    SamDBContext->SyncState = UserState;
                } else if (SamDBContext->SyncState == UserState ) {

                    NlPrint((NL_SYNC,
                            "NlSyncSamDatabase: "
                            "packing groupmember records.\n"));

                    SamDBContext->SyncState = GroupMemberState;
                } else if (SamDBContext->SyncState == GroupMemberState ){

                    NlPrint((NL_SYNC,
                            "NlSyncSamDatabase: packing alias records.\n"));

                    SamDBContext->SyncState = AliasState;
                } else if (SamDBContext->SyncState == AliasState ){

                    NlPrint((NL_SYNC,
                            "NlSyncSamDatabase: "
                            " packing aliasmember records.\n"));

                    SamDBContext->SyncState = AliasMemberState ;
                } else if (SamDBContext->SyncState == AliasMemberState ){

                    NlPrint((NL_SYNC,
                            "NlSyncSamDatabase: packing done.\n"));

                    SamDBContext->SyncState = SamDoneState;
                    Status = STATUS_SUCCESS;
                }

                break;
            }

            //
            // Do the actual enumeration
            //

            if (SamDBContext->SyncState == GroupState ||
                SamDBContext->SyncState == GroupMemberState ) {

                Status = SamIEnumerateAccountRids(
                            DBInfo->DBHandle,
                            SAM_GLOBAL_GROUP_ACCOUNT,
                            SamDBContext->SamEnumHandle,   // Return RIDs greater than this
                            SAM_SYNC_PREF_MAX,
                            &SamDBContext->Count,
                            &SamDBContext->RidArray );

                if ( !NT_SUCCESS( Status ) ) {
                    SamDBContext->RidArray = NULL;
                    goto Cleanup;
                }

                if ( SamDBContext->Count != 0 ) {
                    SamDBContext->SamEnumHandle =
                        SamDBContext->RidArray[SamDBContext->Count-1];
                }

            } else if (SamDBContext->SyncState == UserState ) {


                Status = SamIEnumerateAccountRids(
                            DBInfo->DBHandle,
                            SAM_USER_ACCOUNT,
                            SamDBContext->SamEnumHandle,   // Return RIDs greater than this
                            SAM_SYNC_PREF_MAX,
                            &SamDBContext->Count,
                            &SamDBContext->RidArray );

                if ( !NT_SUCCESS( Status ) ) {
                    SamDBContext->RidArray = NULL;
                    goto Cleanup;
                }

                if ( SamDBContext->Count != 0 ) {
                    SamDBContext->SamEnumHandle =
                        SamDBContext->RidArray[SamDBContext->Count-1];
                }

            } else if (SamDBContext->SyncState == AliasState ||
                        SamDBContext->SyncState == AliasMemberState ) {

                Status = SamrEnumerateAliasesInDomain(
                                DBInfo->DBHandle,
                                &SamDBContext->SamEnumHandle,
                                &SamDBContext->SamEnum,
                                SAM_SYNC_PREF_MAX,
                                &SamDBContext->Count );

                if ( !NT_SUCCESS( Status ) ) {
                    SamDBContext->SamEnum = NULL;
                    goto Cleanup;
                }

                NlAssert( SamDBContext->Count ==
                        SamDBContext->SamEnum->EntriesRead );

            }


            //
            // If SAM says there is more information,
            //  just ensure he returned something to us on this call.
            //

            if ( Status == STATUS_MORE_ENTRIES ) {
                // NlAssert( SamDBContext->Count != 0 );

            //
            // If SAM says he's returned all of the information,
            //  remember not to ask SAM for more.
            //

            } else {
                SamDBContext->SamAllDone = TRUE;
            }

            SamDBContext->Index = 0;
        }

        //
        // Place this entry into the return buffer.
        //

        if ( SamDBContext->Count > 0 ) {

            if (SamDBContext->SyncState == GroupState ) {
                Status = NlPackSamGroup(
                            SamDBContext->RidArray[SamDBContext->Index],
                            &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                            DBInfo,
                            &BufferSize );

            } else if (SamDBContext->SyncState == UserState ) {
                Status = NlPackSamUser(
                    SamDBContext->RidArray[SamDBContext->Index],
                    &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize,
                    SessionInfo );

            } else if (SamDBContext->SyncState == GroupMemberState ) {
                Status = NlPackSamGroupMember(
                    SamDBContext->RidArray[SamDBContext->Index],
                    &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );

            } else if (SamDBContext->SyncState == AliasState ) {
                Status = NlPackSamAlias(
                    SamDBContext->SamEnum->
                        Buffer[SamDBContext->Index].RelativeId,
                    &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );

            } else if (SamDBContext->SyncState == AliasMemberState ) {
                Status = NlPackSamAliasMember(
                    SamDBContext->SamEnum->
                        Buffer[SamDBContext->Index].RelativeId,
                    &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );
            }

            //
            // If there was a real error or this group didn't fit,
            //  return to the caller.
            //

            if ( Status != STATUS_SUCCESS ) {
                goto Cleanup;
            }

            SamDBContext->Index ++;
            (DeltaArray->CountReturned)++;
            BufferConsumed +=
                (sizeof(NETLOGON_DELTA_ENUM) + BufferSize);

            if( BufferConsumed >= PreferredMaximumLength) {
                Status = STATUS_MORE_ENTRIES;
                goto Cleanup;
            }

            //
            // If we're debugging replication, return only one change to the caller.
            //
#if NETLOGONDBG
            if ( NlGlobalParameters.DbFlag & NL_ONECHANGE_REPL ) {
                Status = STATUS_MORE_ENTRIES;
                goto Cleanup;
            }
#endif // NETLOGONDBG

            //
            // if the service is going down, stop packing records and
            // return to the caller.
            //
            // Don't alarm the caller with the status code.  He'll find out
            // on the next call that we're no longer here.
            //

            if( NlGlobalTerminate ) {

                NlPrint((NL_CRITICAL, "NetrDatabaseSync is asked to return "
                            "when the service is going down.\n"));
                Status = STATUS_MORE_ENTRIES;
                goto Cleanup;
            }

        }
    }

Cleanup:

    //
    // Set the return parameters to the proper values.
    //

    if ( NT_SUCCESS( Status ) ) {
        *SyncContext = SamDBContext->SyncSerial;

    } else {
        if ( DeltaArray->Deltas != NULL ) {
            NlFreeDBDeltaArray( DeltaArray->Deltas, DeltaArray->CountReturned );
            DeltaArray->Deltas = NULL;
        }
        DeltaArray->CountReturned = 0;
        *SyncContext = 0;

        NlPrint((NL_CRITICAL,
                "NlSyncSamDatabase: returning unsuccessful (%lx).\n",
                Status));

    }


    return Status;

}


NTSTATUS
NlSyncLsaDatabase(
    IN PSERVER_SESSION ServerSession,
    IN OUT PULONG SyncContext,
    IN OUT PNETLOGON_DELTA_ENUM_ARRAY DeltaArray,
    IN DWORD PreferredMaximumLength,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    This function is a real worker for the NetrDatabaseSync function and
    retrieves the LSA database in the delta buffer.

    This function uses the find-first find-next model to return portions
    of the SAM database at a time.  The SAM database is returned as a
    list of deltas like those returned from I_NetDatabaseDeltas.  The
    following deltas are returned for each domain:

    *  One AddOrChangeLsaPolicy delta, followed by,

    *  One AddOrChangeLsaAccounts delta for each lsa account, followed by,

    *  One AddOrChangeLsaTDomain delta for each trusted domain, followed by,

    *  One AddOrChangeLsaSecret delta for each lsa secret.


Arguments:

    ServerSession -- pointer to connection context.

    SyncContext -- Specifies context needed to continue the
        operation.  The caller should treat this as an opaque
        value.  The value should be zero before the first call.

    DeltaArray -- Pointer to a buffer where the information
        is placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

    PreferredMaximumLength - Preferred maximum length of returned
        data (in 8-bit bytes).  This is not a hard upper limit, but
        serves as a guide to the server.  Due to data conversion
        between systems with different natural data sizes, the actual
        amount of data returned may be greater than this value.

    SessionInfo - Information shared between PDC and BDC.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_MORE_ENTRIES -- The replicant should call again to get more
        data.

--*/
{
    NTSTATUS Status;

    PLSA_SYNC_CONTEXT LsaDBContext;

    PDB_INFO DBInfo;

    DWORD BufferConsumed = 0;
    DWORD BufferSize;
    BOOL IgnoreDeltaObject = FALSE;

    DBInfo = &NlGlobalDBInfoArray[LSA_DB];


    //
    // Allocate memory for delta buffer.
    //

    DeltaArray->Deltas = (PNETLOGON_DELTA_ENUM) MIDL_user_allocate(
                    MAX_DELTA_COUNT * sizeof(NETLOGON_DELTA_ENUM) );

    if( DeltaArray->Deltas == NULL ) {

        NlPrint((NL_CRITICAL,
                "NlSyncLsaDatabase: Can't allocate %d bytes\n",
                 MAX_DELTA_COUNT * sizeof(NETLOGON_DELTA_ENUM) ));

        return( STATUS_NO_MEMORY );
    }


    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaArray->Deltas,
                    MAX_DELTA_COUNT * sizeof(NETLOGON_DELTA_ENUM) );

    //
    // If this is the first call, allocate and initialize the sync context.
    //

    if ( *SyncContext == 0 ) {

        //
        // If there already is a sync context,
        //  delete it.
        //

        if ( ServerSession->SsSync != NULL ) {
            CLEAN_SYNC_CONTEXT( ServerSession->SsSync );
        } else {

            ServerSession->SsSync = NetpMemoryAllocate( sizeof(SYNC_CONTEXT) );
            if ( ServerSession->SsSync == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }
        }

        //
        // Initialize all the fields in the newly allocated resume handle
        //  to indicate that SAM has never yet been called.
        //

        INIT_SYNC_CONTEXT( ServerSession->SsSync, LsaDBContextType );

        LsaDBContext = &(ServerSession->SsSync->DBContext.Lsa);

        LsaDBContext->SyncState = AccountState;
        LsaDBContext->SyncSerial = 1;
        LsaDBContext->LsaEnumBufferType = EmptyEnumBuffer;


        NlPrint((NL_SYNC,
                "NlSyncLsaDatabase: "
                "Starting full sync, packing lsa account records\n"));

        //
        // Put the description of the Policy at the front of the buffer for the
        //  first call.
        //

        Status = NlPackLsaPolicy(
                    &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );

        (DeltaArray->CountReturned)++;
        BufferConsumed += BufferSize;

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

    } else {

        if( ServerSession->SsSync == NULL ) {

            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            goto Cleanup;
        }

        NlAssert( ServerSession->SsSync->DBContextType == LsaDBContextType);

        if( ServerSession->SsSync->DBContextType != LsaDBContextType) {
            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            goto Cleanup;
        }

        LsaDBContext = &(ServerSession->SsSync->DBContext.Lsa);

        NlAssert( LsaDBContext->SyncSerial == *SyncContext );

        if( LsaDBContext->SyncSerial != *SyncContext ) {
            Status = STATUS_SYNCHRONIZATION_REQUIRED;
            goto Cleanup;
        }

        LsaDBContext->SyncSerial++;
    }

    //
    // Loop for each entry placed in the output buffer
    //
    // Each iteration of the loop below puts one more entry into the array
    // returned to the caller.  The algorithm is split into 2 parts.
    // The first part checks to see if we need to retrieve more information
    // from LSA and gets the description of several accounts, TDomain or
    // Secret from LSA in a single call.  The second part puts a single
    // entry into the buffer returned to the caller.
    //

    while ( LsaDBContext->SyncState != LsaDoneState ) {

        //
        // If we've filled out pre-allocated array,
        //  return now.
        //
        if ( DeltaArray->CountReturned + MAX_DELTAS_PER_CHANGELOG > MAX_DELTA_COUNT ) {
            Status = STATUS_MORE_ENTRIES;
            goto Cleanup;
        }

        //
        // Get more information from LSA
        //
        // Handle when we've not yet called LSA or we've already consumed
        // all of the information returned on a previous call to SAM.
        //
        // This is a 'while' rather than an 'if' to handle the case
        // where LSA returns zero entries.
        //

        while ( LsaDBContext->Index >= LsaDBContext->Count ) {

            //
            // Free any previous buffer returned from SAM.
            //

            if ( ServerSession->SsSync != NULL ) {
                CLEAN_SYNC_CONTEXT( ServerSession->SsSync );
            }


            //
            // If we've already gotten everything from LSA,
            //  we've finished all of the accounts,
            //
            // If we've just done the accounts,
            //      go on to do the TDomains.
            //
            // If we've just done the TDomains,
            //      go on to do the Secrets
            //
            // If we've just done the Secret,
            //      we're all done.
            //

            if ( LsaDBContext->LsaAllDone ) {

                LsaDBContext->LsaEnumHandle = 0;
                LsaDBContext->Index = 0;
                LsaDBContext->Count = 0;
                LsaDBContext->LsaAllDone = FALSE;

                if (LsaDBContext->SyncState == AccountState ) {


                    NlPrint((NL_SYNC,
                            "NlSyncLsaDatabase: "
                            " packing TDomain records.\n"));

                    LsaDBContext->SyncState = TDomainState;
                } else if (LsaDBContext->SyncState == TDomainState ) {

                    NlPrint((NL_SYNC,
                            "NlSyncLsaDatabase: packing secret records.\n"));

                    LsaDBContext->SyncState = SecretState;
                } else if (LsaDBContext->SyncState == SecretState ) {


                    NlPrint((NL_SYNC,
                            "NlSyncLsaDatabase: packing done.\n"));

                    LsaDBContext->SyncState = LsaDoneState;
                    LsaDBContext->LsaEnumBufferType = EmptyEnumBuffer;
                    Status = STATUS_SUCCESS;
                }

                break;
            }

            if (LsaDBContext->SyncState == AccountState ) {

                LsaDBContext->LsaEnumBufferType = AccountEnumBuffer;

                Status = LsarEnumerateAccounts(
                            DBInfo->DBHandle,
                            &LsaDBContext->LsaEnumHandle,
                            &LsaDBContext->LsaEnum.Account,
                            SAM_SYNC_PREF_MAX);

                if (Status == STATUS_SUCCESS || Status == STATUS_MORE_ENTRIES ) {
                    LsaDBContext->Count =
                        LsaDBContext->LsaEnum.Account.EntriesRead;
                }

            } else if (LsaDBContext->SyncState == TDomainState ) {

                LsaDBContext->LsaEnumBufferType = TDomainEnumBuffer;

                Status = LsarEnumerateTrustedDomains(
                                DBInfo->DBHandle,
                                &LsaDBContext->LsaEnumHandle,
                                &LsaDBContext->LsaEnum.TDomain,
                                SAM_SYNC_PREF_MAX);

                if (Status == STATUS_SUCCESS || Status == STATUS_MORE_ENTRIES ) {
                    LsaDBContext->Count =
                        LsaDBContext->LsaEnum.TDomain.EntriesRead;
                }

            } else if (LsaDBContext->SyncState == SecretState ) {

                LsaDBContext->LsaEnumBufferType = SecretEnumBuffer;

                Status = LsaIEnumerateSecrets(
                                DBInfo->DBHandle,
                                &LsaDBContext->LsaEnumHandle,
                                &LsaDBContext->LsaEnum.Secret,
                                SAM_SYNC_PREF_MAX,
                                &LsaDBContext->Count );

            }

            //
            // If LSA says there is more information,
            //  just ensure he returned something to us on this call.
            //

            if ( Status == STATUS_SUCCESS || Status == STATUS_MORE_ENTRIES ) {
                NlAssert( LsaDBContext->Count != 0 );

            //
            // If LSA says he's returned all of the information,
            //  remember not to ask it for more.
            //

            } else if ( Status == STATUS_NO_MORE_ENTRIES ) {
                LsaDBContext->LsaAllDone = TRUE;
                LsaDBContext->Count = 0;

            //
            // Any other error is fatal
            //

            } else {

                LsaDBContext->LsaEnumBufferType = EmptyEnumBuffer;
                LsaDBContext->Count = 0;
                goto Cleanup;

            }

            LsaDBContext->Index = 0;
        }


        //
        // Place this entry into the return buffer.
        //

        if ( LsaDBContext->Count > 0 ) {

            if (LsaDBContext->SyncState == AccountState ) {

                Status = NlPackLsaAccount(
                    LsaDBContext->LsaEnum.Account.
                        Information[LsaDBContext->Index].Sid,
                    &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize,
                    SessionInfo );

                if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
                    Status = STATUS_SUCCESS;
                    IgnoreDeltaObject = TRUE;
                    BufferSize = 0;
                }

            } else if (LsaDBContext->SyncState == TDomainState ) {

                Status = NlPackLsaTDomain(
                    LsaDBContext->LsaEnum.TDomain.
                        Information[LsaDBContext->Index].Sid,
                    &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                    DBInfo,
                    &BufferSize );

            } else if (LsaDBContext->SyncState == SecretState ) {

                PUNICODE_STRING SecretName;

                SecretName =
                    &((PUNICODE_STRING)LsaDBContext->LsaEnum.Secret)
                            [LsaDBContext->Index];

                //
                // ignore local secret objects.
                //

                if( (SecretName->Length / sizeof(WCHAR) >
                        LSA_GLOBAL_SECRET_PREFIX_LENGTH ) &&
                    (_wcsnicmp( SecretName->Buffer,
                              LSA_GLOBAL_SECRET_PREFIX,
                              LSA_GLOBAL_SECRET_PREFIX_LENGTH ) == 0)) {

                    Status = NlPackLsaSecret(
                        SecretName,
                        &((DeltaArray->Deltas)[DeltaArray->CountReturned]),
                        DBInfo,
                        &BufferSize,
                        SessionInfo );

                } else {
                    Status = STATUS_SUCCESS;
                    IgnoreDeltaObject = TRUE;
                    BufferSize = 0;
                }

            }

            //
            // If there was a real error or this group didn't fit,
            //  return to the caller.
            //

            if ( Status != STATUS_SUCCESS ) {
                goto Cleanup;
            }

            LsaDBContext->Index ++;

            //
            // if this object is ignored, don't modify return values.
            //

            if ( !IgnoreDeltaObject ) {

                (DeltaArray->CountReturned)++;
                BufferConsumed +=
                    (sizeof(NETLOGON_DELTA_ENUM) + BufferSize);

                if( BufferConsumed >= PreferredMaximumLength) {
                    Status = STATUS_MORE_ENTRIES;
                    goto Cleanup;
                }

                //
                // If we're debugging replication, return only one change to the caller.
                //
#if NETLOGONDBG
                if ( NlGlobalParameters.DbFlag & NL_ONECHANGE_REPL ) {
                    Status = STATUS_MORE_ENTRIES;
                    goto Cleanup;
                }

#endif // NETLOGONDBG
            } else {
                IgnoreDeltaObject = FALSE;
            }
        }
    }

Cleanup:

    //
    // Set the return parameters to the proper values.
    //

    if ( NT_SUCCESS( Status ) ) {
        *SyncContext = LsaDBContext->SyncSerial;

    } else {
        if ( DeltaArray->Deltas != NULL ) {
            NlFreeDBDeltaArray( DeltaArray->Deltas, DeltaArray->CountReturned );
            DeltaArray->Deltas = NULL;
        }
        DeltaArray->CountReturned = 0;
        *SyncContext = 0;
    }

    if (!NT_SUCCESS(Status)) {

        NlPrint((NL_CRITICAL,
                "NlSyncLsaDatabase: returning unsuccessful (%lx).\n",
                Status));
    }


    return Status;

}


NTSTATUS
NetrDatabaseSync (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN OUT PULONG SyncContext,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArrayRet,
    IN DWORD PreferredMaximumLength
    )
/*++

Routine Description:

    NT 3.1 version of NetrDatabaseSync2.  Don't pass the RestartState parameter.
    Sync Context is all that is needed to identify the state.

Arguments:

    Same as NetrDatabaseSync2 (with the exception mentioned above).

Return Value:

    Save as NetrDatabaseSync2.

--*/
{
    return NetrDatabaseSync2(
                PrimaryName,
                ComputerName,
                Authenticator,
                ReturnAuthenticator,
                DatabaseID,
                NormalState,
                SyncContext,
                DeltaArrayRet,
                PreferredMaximumLength );

}


NTSTATUS
NetrDatabaseSync2 (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN SYNC_STATE RestartState,
    IN OUT PULONG SyncContext,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArrayRet,
    IN DWORD PreferredMaximumLength
    )
/*++

Routine Description:

    This function is used by an NT BDC to request
    the entire SAM/LSA database from a PDC in NTLANMAN-style format.
    This function can only be called by a server which has previously
    authenticated with the PDC by calling I_NetServerAuthenticate.  This
    function uses RPC to contact the Netlogon service on the PDC.

Arguments:

    PrimaryName -- Name of the PDC to retrieve the deltas from.

    ComputerName -- Name of the BDC or member server making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    DatabaseID -- Identifies the databse for which the deltas are requested.
        For SAM database the ID is 0, for Builtin Domain the ID is 1. Other
        databases may be defined later.

    RestartState -- Specifies whether this is a restart of the full sync and how
        to interpret SyncContext.  This value should be NormalState unless this
        is the restart of a full sync.

        However, if the caller is continuing a full sync after a reboot,
        the following values are used:

            GroupState - SyncContext is the global group rid to continue with.
            UserState - SyncContext is the user rid to continue with
            GroupMemberState - SyncContext is the global group rid to continue with
            AliasState - SyncContext should be zero to restart at first alias
            AliasMemberState - SyncContext should be zero to restart at first alias

        One cannot continue the LSA database in this way.

    SyncContext -- Specifies context needed to continue the
        operation.  The caller should treat this as an opaque
        value.  The value should be zero before the first call.

    DeltaArray -- Receives a pointer to a buffer where the information
        is placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

    PreferredMaximumLength - Preferred maximum length of returned
        data (in 8-bit bytes).  This is not a hard upper limit, but
        serves as a guide to the server.  Due to data conversion
        between systems with different natural data sizes, the actual
        amount of data returned may be greater than this value.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_MORE_ENTRIES -- The replicant should call again to get more
        data.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.


--*/
{
    NTSTATUS Status;

    PDOMAIN_INFO DomainInfo = NULL;
    PSERVER_SESSION ServerSession = NULL;
    PNETLOGON_DELTA_ENUM_ARRAY DeltaArray;

    SESSION_INFO SessionInfo;
    PDB_INFO DBInfo;

    DEFSSIAPITIMER;

    INITSSIAPITIMER;
    STARTSSIAPITIMER;

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation || !NlGlobalPdcDoReplication ) {
        NlPrint((NL_CRITICAL,
                "NetrDatabaseSync2: called from %ws.  This machine doesn't support replication.\n",
                ComputerName ));
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Gross hack because of RPC implementation.
    //
    // Rpc executes API calls in an I/O completion port thread.  If this thread
    //  goes CPU bound, then no other RPC will be allowed to start.  Even worse,
    //  there is only one outstanding listen, so the 'second' coming RPC call
    //  gets RPC_S_SERVER_TOO_BUSY.
    //
    // By sleeping here (even for a short period) the I/O completion port releases
    // another thread since it thinks this thread went I/O bound.
    //
    // We've seen this thread go CPU bound doing a full sync of a database with
    // 1000's of LSA account objects.
    //

    RpcServerYield();


    //
    // If the DS is recovering from a backup,
    //  avoid changing the DS.
    //

    if ( NlGlobalDsPaused ) {
        NlPrint((NL_CRITICAL,
                 "NetrDatabaseSync2: DsIsPaused.\n"));
        // Don't return a new status code since NT 4 DC would do a full sync
        return STATUS_ACCESS_DENIED;
    }

    if ( DatabaseID >= NUM_DBS ) {
        return STATUS_INVALID_LEVEL;
    }

    DBInfo = &NlGlobalDBInfoArray[DatabaseID];

    //
    // Initialization
    //

    *DeltaArrayRet = DeltaArray = (PNETLOGON_DELTA_ENUM_ARRAY)
            MIDL_user_allocate( sizeof(NETLOGON_DELTA_ENUM_ARRAY) );

    if( DeltaArray == NULL ) {
        return(STATUS_NO_MEMORY);
    }

    DeltaArray->Deltas = NULL;
    DeltaArray->CountReturned = 0;


    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( PrimaryName );

    NlPrintDom((NL_SYNC, DomainInfo,
            "NetrDatabaseSync: " FORMAT_LPWSTR " full sync called by " FORMAT_LPWSTR " State: %ld Context: 0x%lx.\n",
            DBInfo->DBName,
            ComputerName,
            RestartState,
            *SyncContext ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    if ( !IsPrimaryDomain( DomainInfo )) {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }


    //
    // Retrieve the requestor's entry to get sessionkey
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        // Don't log this event since it happens in nature after a reboot
        // or after we scavenge the server session.
        NlPrint((NL_CRITICAL,
                 "NetrDatabaseSync: No server session.\n"));
        goto CleanupNoEventlog;
    }

    //
    // Allow this call only on ServerSecureChannel.
    //

    if( ServerSession->SsSecureChannelType != ServerSecureChannel ) {

        //
        // If the only preblem is that this BDC hasn't authenticated,
        //  silently ask it to authenticate.
        //
        if ( ServerSession->SsSecureChannelType == NullSecureChannel ) {
            NlPrint((NL_CRITICAL,
                     "NetrDatabaseSync: No authenticated server session.\n"));
            ServerSession = NULL;
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            // Don't log this event since it happens in nature after a reboot
            // or after we scavenge the server session.
            Status = STATUS_ACCESS_DENIED;
            goto CleanupNoEventlog;
        } else {
            NlPrint((NL_CRITICAL,
                     "NetrDatabaseSync: SecureChannel type isn't BDC. %ld\n",
                     ServerSession->SsSecureChannelType ));
            ServerSession = NULL;
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }
    }

    //
    // Verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator( ServerSession,
                                   Authenticator,
                                   ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

        NlPrint((NL_CRITICAL,
                "NetrDatabaseSync: authentication failed.\n" ));

        ServerSession = NULL;
        goto Cleanup;
    }


    //
    // Prevent entry from being deleted, but drop the global lock.
    //
    // Beware of server with two concurrent calls outstanding
    //  (must have rebooted.)
    //

    if (ServerSession->SsFlags & SS_LOCKED ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

        NlPrint((NL_CRITICAL, "NetrDatabaseSync: Concurrent call detected.\n" ));

        Status = STATUS_ACCESS_DENIED;
        ServerSession = NULL;
        goto Cleanup;
    }
    ServerSession->SsFlags |= SS_LOCKED;


    SessionInfo.SessionKey = ServerSession->SsSessionKey;
    SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;

    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

    if( DatabaseID == LSA_DB ) {

        NlAssert( RestartState == NormalState );

        Status = NlSyncLsaDatabase( ServerSession,
                                    SyncContext,
                                    DeltaArray,
                                    PreferredMaximumLength,
                                    &SessionInfo );
    } else {

        Status = NlSyncSamDatabase( ServerSession,
                                    DatabaseID,
                                    RestartState,
                                    SyncContext,
                                    DeltaArray,
                                    PreferredMaximumLength,
                                    &SessionInfo );

    }

Cleanup:

    //
    // write event log
    //

    if ( !NT_SUCCESS( Status ) ) {

        LPWSTR MsgStrings[2];

        MsgStrings[0] = ComputerName;
        MsgStrings[1] = (LPWSTR) LongToPtr( Status );

        NlpWriteEventlog(
            NELOG_NetlogonFullSyncCallFailed,
            EVENTLOG_WARNING_TYPE,
            (LPBYTE)&Status,
            sizeof(Status),
            MsgStrings,
            2 | NETP_LAST_MESSAGE_IS_NTSTATUS | NETP_ALLOW_DUPLICATE_EVENTS );

    } else {

        LPWSTR MsgStrings[2];
        WCHAR CountBuffer[20]; // random size

        MsgStrings[0] = ComputerName;

        ultow( DeltaArray->CountReturned, CountBuffer, 10);
        MsgStrings[1] = CountBuffer;

        NlpWriteEventlog(
            NELOG_NetlogonFullSyncCallSuccess,
            EVENTLOG_INFORMATION_TYPE,
            NULL,
            0,
            MsgStrings,
            2 | NETP_ALLOW_DUPLICATE_EVENTS );

    }

    //
    // Unlock the server session entry if we've locked it.
    //
CleanupNoEventlog:

    if ( ServerSession != NULL ) {

        //
        // If we're done, free up the context structure,
        //

        if ( Status != STATUS_MORE_ENTRIES && ServerSession->SsSync != NULL ) {
            CLEAN_SYNC_CONTEXT( ServerSession->SsSync );

            NetpMemoryFree( ServerSession->SsSync );
            ServerSession->SsSync = NULL;
        }

        //
        // If we are successfully returning these deltas to the BDC,
        //  update our tables to reflect the changes.
        //

        if ( Status == STATUS_SUCCESS ) {
            NlPrimaryAnnouncementFinish( ServerSession,
                                         DatabaseID,
                                         NULL );

        }

        NlUnlockServerSession( ServerSession );
    }

    //
    // If the BDC called us just as SAM was shutting down,
    //  map the status to prevent the BDC from full syncing.
    //

    if ( Status == STATUS_INVALID_SERVER_STATE ) {
        Status = STATUS_ACCESS_DENIED;
    }


    NlPrint((NL_SYNC,
            "NetrDatabaseSync: " FORMAT_LPWSTR " returning (0x%lx) to " FORMAT_LPWSTR " Context: 0x%lx.\n",
            DBInfo->DBName,
            Status,
            ComputerName,
            *SyncContext ));

    STOPSSIAPITIMER;

    NlPrint((NL_REPL_TIME,"NetrDatabaseSync Time:\n"));
    PRINTSSIAPITIMER;

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return Status;

}


NTSTATUS
NetrDatabaseRedo(
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN LPBYTE OrigChangeLogEntry,
    IN DWORD ChangeLogEntrySize,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArrayRet
    )
/*++

Routine Description:

    This function is used by a SAM BDC to request infomation about a single
    account. This function can only be called by a server which has previously
    authenticated with the PDC by calling I_NetServerAuthenticate.  This
    function uses RPC to contact the Netlogon service on the PDC.

Arguments:

    PrimaryName -- Name of the PDC to retrieve the delta from.

    ComputerName -- Name of the BDC making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    ChangeLogEntry -- A description of the account to be queried.

    ChangeLogEntrySize -- Size (in bytes) of the ChangeLogEntry.

    DeltaArrayRet -- Receives a pointer to a buffer where the information is
        placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.

--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry;

    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;
    PSERVER_SESSION ServerSession = NULL;

    LPWSTR MsgStrings[2];

    DWORD BufferSize;

    PNETLOGON_DELTA_ENUM_ARRAY DeltaArray = NULL;
    SESSION_INFO SessionInfo;

    DEFSSIAPITIMER;

    INITSSIAPITIMER;
    STARTSSIAPITIMER;

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation || !NlGlobalPdcDoReplication ) {
        NlPrint((NL_CRITICAL,
                "NetrDatabaseRedo: called from %ws.  This machine doesn't support replication.\n",
                ComputerName ));
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If the DS is recovering from a backup,
    //  avoid changing the DS.
    //

    if ( NlGlobalDsPaused ) {
        NlPrint((NL_CRITICAL,
                 "NetrDatabaseRedo: DsIsPaused.\n"));
        // Don't return a new status code since NT 4 DC would do a full sync
        return STATUS_ACCESS_DENIED;
    }

    //
    // Initialization
    //

    ChangeLogEntry = (PCHANGELOG_ENTRY) OrigChangeLogEntry;
    if ( !NlValidateChangeLogEntry( ChangeLogEntry, ChangeLogEntrySize ) ||
         ChangeLogEntry->DBIndex >= NUM_DBS ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }



    //
    // Find the domain this API was made to.
    //

    DomainInfo = NlFindDomainByServerName( PrimaryName );

    NlPrintDom((NL_SYNC, DomainInfo,
            "NetrDatabaseRedo: " FORMAT_LPWSTR " redo sync called by " FORMAT_LPWSTR
            " with this change log entry:\n",
            NlGlobalDBInfoArray[ChangeLogEntry->DBIndex].DBName,
            ComputerName ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    if ( !IsPrimaryDomain( DomainInfo )) {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }


#if NETLOGONDBG
    PrintChangeLogEntry( ChangeLogEntry );
#endif // NETLOGONDBG

    //
    // The change log entry really represents an object and not an operation.
    // Therefore, convert the delta type from whatever was passed to an
    // "AddOrChange" operation.  Then NlPackSingleDelta will return everything
    // we know about the object.
    //

    ChangeLogEntry->DeltaType = (UCHAR)NlGlobalAddDeltaType[ChangeLogEntry->DeltaType];

    *DeltaArrayRet = DeltaArray = (PNETLOGON_DELTA_ENUM_ARRAY)
            MIDL_user_allocate( sizeof(NETLOGON_DELTA_ENUM_ARRAY) );

    if( DeltaArray == NULL ) {
        return STATUS_NO_MEMORY;
    }

    DeltaArray->CountReturned = 0;
    DeltaArray->Deltas = NULL;
    SessionInfo.NegotiatedFlags = 0;




    //
    // Retrieve the requestor's entry to get sessionkey
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        NlPrint((NL_CRITICAL,
                 "NetrDatabaseRedo: No server session.\n"));
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        // Don't log this event since it happens in nature after a reboot
        // or after we scavenge the server session.
        goto CleanupNoEventlog;
    }

    //
    // Allow this call only on ServerSecureChannel.
    //

    if( ServerSession->SsSecureChannelType != ServerSecureChannel ) {

        //
        // If the only preblem is that this BDC hasn't authenticated,
        //  silently ask it to authenticate.
        //
        if ( ServerSession->SsSecureChannelType == NullSecureChannel ) {
            NlPrint((NL_CRITICAL,
                     "NetrDatabaseRedo: No authenticated server session.\n"));
            ServerSession = NULL;
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            // Don't log this event since it happens in nature after a reboot
            // or after we scavenge the server session.
            Status = STATUS_ACCESS_DENIED;
            goto CleanupNoEventlog;
        } else {
            NlPrint((NL_CRITICAL,
                     "NetrDatabaseRedo: SecureChannel type isn't BDC. %ld\n",
                     ServerSession->SsSecureChannelType ));
            ServerSession = NULL;
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }
    }

    //
    // Verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator( ServerSession,
                                   Authenticator,
                                   ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

        NlPrint((NL_CRITICAL, "NetrDatabaseRedo: authentication failed.\n" ));

        ServerSession = NULL;
        goto Cleanup;
    }


    //
    // Prevent entry from being deleted, but drop the global lock.
    //
    // Beware of server with two concurrent calls outstanding
    //  (must have rebooted.)
    //

    if (ServerSession->SsFlags & SS_LOCKED ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

        NlPrint((NL_CRITICAL, "NetrDatabaseRedo: Concurrent call detected.\n" ));

        Status = STATUS_ACCESS_DENIED;
        ServerSession = NULL;
        goto Cleanup;
    }
    ServerSession->SsFlags |= SS_LOCKED;

    SessionInfo.SessionKey = ServerSession->SsSessionKey;
    SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;

    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );


    //
    // Allocate memory for delta buffer.
    //

    DeltaArray->Deltas = (PNETLOGON_DELTA_ENUM) MIDL_user_allocate(
                    MAX_DELTAS_PER_CHANGELOG * sizeof(NETLOGON_DELTA_ENUM) );

    if( DeltaArray->Deltas == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaArray->Deltas,
                    MAX_DELTAS_PER_CHANGELOG * sizeof(NETLOGON_DELTA_ENUM) );


    //
    // Put the data for the changelog entry into the user's buffer.
    //

    Status = NlPackSingleDelta( ChangeLogEntry,
                                DeltaArray,
                                &BufferSize,
                                &SessionInfo,
                                FALSE );


    //
    // If the only problem is that the object no longer exists,
    //  return a delta asking the BDC to delete the object.
    //

    if ( !NT_SUCCESS(Status) &&
         IsObjectNotFoundStatus( ChangeLogEntry->DeltaType, Status ) ) {


        NlPrint((NL_SYNC,
            "NetrDatabaseRedo: " FORMAT_LPWSTR " object no longer exists (0x%lx) "
            FORMAT_LPWSTR "\n",
            NlGlobalDBInfoArray[ChangeLogEntry->DBIndex].DBName,
            Status,
            ComputerName ));

        //
        // Convert the change log entry into an appropriate delete delta type and
        //  try again.
        //

        ChangeLogEntry->DeltaType = (UCHAR)NlGlobalDeleteDeltaType[ChangeLogEntry->DeltaType];

        Status = NlPackSingleDelta( ChangeLogEntry,
                                    DeltaArray,
                                    &BufferSize,
                                    &SessionInfo,
                                    FALSE );

    }

Cleanup:

    //
    // write event log
    //

    if ( !NT_SUCCESS( Status ) ) {

        MsgStrings[0] = ComputerName;
        MsgStrings[1] = (LPWSTR) LongToPtr( Status );

        NlpWriteEventlog(
            NELOG_NetlogonPartialSyncCallFailed,
            EVENTLOG_WARNING_TYPE,
            (LPBYTE)&Status,
            sizeof(Status),
            MsgStrings,
            2 | NETP_LAST_MESSAGE_IS_NTSTATUS | NETP_ALLOW_DUPLICATE_EVENTS );

    } else {

        //
        // Log the successful replication only if deltas have been returned
        // to the caller.
        //
        if ( DeltaArray->CountReturned != 0 ) {
            LPWSTR MsgStrings[2];
            WCHAR CountBuffer[20]; // random size

            MsgStrings[0] = ComputerName;

            ultow( DeltaArray->CountReturned, CountBuffer, 10);
            MsgStrings[1] = CountBuffer;

            NlpWriteEventlog(
                NELOG_NetlogonPartialSyncCallSuccess,
                EVENTLOG_INFORMATION_TYPE,
                NULL,
                0,
                MsgStrings,
                2 | NETP_ALLOW_DUPLICATE_EVENTS );
        }

    }


    //
    // Free up locally allocated resources.
    //

CleanupNoEventlog:

    //
    // If we weren't successful,
    //  Don't return any deltas.
    //

    if ( !NT_SUCCESS(Status)) {
        if ( DeltaArray != NULL ) {
            if ( DeltaArray->Deltas != NULL ) {
                NlFreeDBDeltaArray( DeltaArray->Deltas, DeltaArray->CountReturned );
                DeltaArray->Deltas = NULL;
            }
            DeltaArray->CountReturned = 0;
        }
    }

    //
    // Unlock the server session entry if we've locked it.
    //

    if ( ServerSession != NULL ) {
        NlUnlockServerSession( ServerSession );
    }

    //
    // If the BDC called us just as SAM was shutting down,
    //  map the status to prevent the BDC from full syncing.
    //

    if ( Status == STATUS_INVALID_SERVER_STATE ) {
        Status = STATUS_ACCESS_DENIED;
    }


    NlPrint((NL_SYNC,
            "NetrDatabaseRedo: " FORMAT_LPWSTR " returning (0x%lx) to "
            FORMAT_LPWSTR "\n",
            NlGlobalDBInfoArray[ChangeLogEntry->DBIndex].DBName,
            Status,
            ComputerName ));

    STOPSSIAPITIMER;

    NlPrint((NL_REPL_TIME,"NetrDatabaseRedo Time:\n"));
    PRINTSSIAPITIMER;

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return Status;

}



NTSTATUS
NetrAccountDeltas (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PUAS_INFO_0 RecordId,
    IN DWORD Count,
    IN DWORD Level,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT PULONG CountReturned,
    OUT PULONG TotalEntries,
    OUT PUAS_INFO_0 NextRecordId
    )
/*++

Routine Description:

    This function is used by a UAS BDC or UAS member server to request
    UAS-style account change information.  This function can only be
    called by a server which has previously authenticated with the PDC by
    calling I_NetServerAuthenticate.

    This function is only called by the XACT server upon receipt of a
    I_NetAccountDeltas XACT SMB from a UAS BDC or a UAS member server.
    As such, many of the parameters are opaque since the XACT server
    doesn't need to interpret any of that data.  This function uses RPC
    to contact the Netlogon service.

    The LanMan 3.0 SSI Functional Specification describes the operation
    of this function.

Arguments:

    PrimaryName -- Must be NULL to indicate this call is a local call
        being made on behalf of a UAS server by the XACT server.

    ComputerName -- Name of the BDC or member making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    RecordId -- Supplies an opaque buffer indicating the last record
        received from a previous call to this function.

    Count -- Supplies the number of Delta records requested.

    Level -- Reserved.  Must be zero.

    Buffer -- Returns opaque data representing the information to be
        returned.

    BufferSize -- Size of buffer in bytes.

    CountReturned -- Returns the number of records returned in buffer.

    TotalEntries -- Returns the total number of records available.

    NextRecordId -- Returns an opaque buffer identifying the last
        record received by this function.


Return Value:

    NT status code.

--*/
{
    NlAssert(!"NetrAccountDeltas called");
    UNREFERENCED_PARAMETER( PrimaryName );
    UNREFERENCED_PARAMETER( ComputerName );
    UNREFERENCED_PARAMETER( Authenticator );
    UNREFERENCED_PARAMETER( ReturnAuthenticator );
    UNREFERENCED_PARAMETER( RecordId );
    UNREFERENCED_PARAMETER( Count );
    UNREFERENCED_PARAMETER( Level );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( BufferSize );
    UNREFERENCED_PARAMETER( CountReturned );
    UNREFERENCED_PARAMETER( TotalEntries );
    UNREFERENCED_PARAMETER( NextRecordId );

    return(STATUS_NOT_IMPLEMENTED);
}




NTSTATUS
NetrAccountSync (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD Reference,
    IN DWORD Level,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT PULONG CountReturned,
    OUT PULONG TotalEntries,
    OUT PULONG NextReference,
    OUT PUAS_INFO_0 LastRecordId
    )
/*++

Routine Description:

    This function is used by a UAS BDC or UAS member server to request
    the entire user accounts database.  This function can only be called
    by a server which has previously authenticated with the PDC by
    calling I_NetServerAuthenticate.

    This function is only called by the XACT server upon receipt of a
    I_NetAccountSync XACT SMB from a UAS BDC or a UAS member server.  As
    such, many of the parameters are opaque since the XACT server doesn't
    need to interpret any of that data.  This function uses RPC to
    contact the Netlogon service.

    The LanMan 3.0 SSI Functional Specification describes the operation
    of this function.

    "reference" and "next_reference" are treated as below.

    1. "reference" should hold either 0 or value of "next_reference"
       from previous call to this API.
    2. Send the modals and ALL group records in the first call. The API
       expects the buffer to be large enough to hold this info (worst
       case size would be
            MAXGROUP * (sizeof(struct group_info_1) + MAXCOMMENTSZ)
                     + sizeof(struct user_modals_info_0)
       which, for now, will be 256 * (26 + 49) + 16 = 19216 bytes

Arguments:

    PrimaryName -- Must be NULL to indicate this call is a local call
        being made on behalf of a UAS server by the XACT server.

    ComputerName -- Name of the BDC or member making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    Reference -- Supplies find-first find-next handle returned by the
        previous call to this function or 0 if it is the first call.

    Level -- Reserved.  Must be zero.

    Buffer -- Returns opaque data representing the information to be
        returned.

    BufferLen -- Length of buffer in bytes.

    CountReturned -- Returns the number of records returned in buffer.

    TotalEntries -- Returns the total number of records available.

    NextReference -- Returns a find-first find-next handle to be
        provided on the next call.

    LastRecordId -- Returns an opaque buffer identifying the last
        record received by this function.


Return Value:

    NT status code.

--*/

{
    NlAssert(!"NetrAccountDeltas called");
    UNREFERENCED_PARAMETER( PrimaryName );
    UNREFERENCED_PARAMETER( ComputerName );
    UNREFERENCED_PARAMETER( Authenticator );
    UNREFERENCED_PARAMETER( ReturnAuthenticator );
    UNREFERENCED_PARAMETER( Reference );
    UNREFERENCED_PARAMETER( Level );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( BufferSize );
    UNREFERENCED_PARAMETER( CountReturned );
    UNREFERENCED_PARAMETER( TotalEntries );
    UNREFERENCED_PARAMETER( NextReference );
    UNREFERENCED_PARAMETER( LastRecordId );

    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
NlGetTrustedSideInfo(
    IN PCLIENT_SESSION ClientSession,
    IN LPWSTR AccountName OPTIONAL,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    OUT PNT_OWF_PASSWORD NewOwfPassword,
    OUT PNT_OWF_PASSWORD OldOwfPassword,
    OUT PNL_GENERIC_RPC_DATA *TrustInfo
    )
/*++

Routine Description:

    This function is used by a trusting side DC to get the new and old
    passwords from the trusted side.

    The caller must be the writer of the client session.

Arguments:

    ClientSession - Identifies a session to the trusted side.
        The caller must be the writer of this client session.

    AccountName -- Name of the account to get the password for. If NULL,
        the account name from the ClientSession is used.

    AccountType -- The type of account being accessed. Ignored if
        AccountName is NULL in which case the account type specified
        in teh ClientSession is used.

    NewOwfPassword -- Returns the new OWF password of the account.

    OldOwfPassword -- Returns the old OWF password of the account.

    TrustInfo -- Returns the trusted domain info

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;
    SESSION_INFO SessionInfo;
    BOOLEAN FirstTry = TRUE;
    BOOLEAN OldServer = FALSE;
    ENCRYPTED_LM_OWF_PASSWORD SessKeyEncrNewPassword;
    ENCRYPTED_LM_OWF_PASSWORD SessKeyEncrOldPassword;
    NETLOGON_CREDENTIAL CurrentAuthenticationSeed;

    PNL_GENERIC_RPC_DATA LocalTrustInfo = NULL;

    //
    // If the server supports neither the new get_password_and_attributes API
    //  nor the old get_passwords API, there is nothing for us to do here
    //

    if ( (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_NO_PWD_ATTR_MONITOR) &&
         (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_NO_PWD_MONITOR) ) {

        return STATUS_NOT_SUPPORTED;
    }

    //
    // If the session isn't authenticated,
    //  do so now.
    //

FirstTryFailed:

    Status = NlEnsureSessionAuthenticated( ClientSession, 0 );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    SessionInfo.SessionKey = ClientSession->CsSessionKey;
    SessionInfo.NegotiatedFlags = ClientSession->CsNegotiatedFlags;

    //
    // Remember current authentication seed. We may need to reset it
    // if the trusted side server is the old one that doesn't have
    // the passwords monitoring API.
    //

    CurrentAuthenticationSeed = ClientSession->CsAuthenticationSeed;

    //
    // Build the Authenticator for this request to the server
    //

    NlBuildAuthenticator(
                    &ClientSession->CsAuthenticationSeed,
                    &ClientSession->CsSessionKey,
                    &OurAuthenticator);

    //
    // Get the passwords (and perhaps attributes) from the server
    //

    NL_API_START( Status, ClientSession, TRUE ) {

        NlAssert( ClientSession->CsUncServerName != NULL );

        //
        // If this server may support getting both passwords and attributes,
        //  ask for both
        //
        if ( (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_NO_PWD_ATTR_MONITOR) == 0 ) {
            Status = I_NetServerGetTrustInfo(
                          ClientSession->CsUncServerName,
                          (AccountName != NULL) ?
                            AccountName :
                            ClientSession->CsAccountName,
                          (AccountName != NULL) ?
                            AccountType :
                            ClientSession->CsSecureChannelType,
                          ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                          &OurAuthenticator,
                          &ReturnAuthenticator,
                          &SessKeyEncrNewPassword,
                          &SessKeyEncrOldPassword,
                          &LocalTrustInfo );

            //
            // If the server is old that doesn't support this functionality,
            //  remember to never ask it about attributes again and try to
            //  get just the passwords
            //
            if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
                ClientSession->CsDiscoveryFlags |= CS_DISCOVERY_NO_PWD_ATTR_MONITOR;
            }
        }

        //
        // If this server doesn't support getting both passwords and attributes but
        //  may support getting just the passwords, ask for it.
        //
        // REVIEW: Ditch this code once there are no more Whistler Beta2 servers out
        //  there which don't support I_NetServerGetTrustInfo.
        //
        if ( (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_NO_PWD_ATTR_MONITOR) != 0 &&
             (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_NO_PWD_MONITOR) == 0 ) {

            Status = I_NetServerTrustPasswordsGet(
                          ClientSession->CsUncServerName,
                          (AccountName != NULL) ?
                            AccountName :
                            ClientSession->CsAccountName,
                          (AccountName != NULL) ?
                            AccountType :
                            ClientSession->CsSecureChannelType,
                          ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                          &OurAuthenticator,
                          &ReturnAuthenticator,
                          &SessKeyEncrNewPassword,
                          &SessKeyEncrOldPassword );

            //
            // If the server is old that doesn't support this functionality,
            //  remember to never ask it about passwords again
            //
            if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
                ClientSession->CsDiscoveryFlags |= CS_DISCOVERY_NO_PWD_MONITOR;
            }
        }

        //
        // Detect if the trusted side is an old server. If so, avoid dropping the
        // secure channel in the NL_API_ELSE logic by making it think all was fine.
        //
        if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
            OldServer = TRUE;
            Status = STATUS_SUCCESS;
        }

    // NOTE: This call may drop the secure channel behind our back
    } NL_API_ELSE( Status, ClientSession, TRUE ) {
    } NL_API_END;

    if ( OldServer ) {
        goto Cleanup;
    }

    //
    // Now verify primary's authenticator and update our seed
    //

    if ( Status == STATUS_ACCESS_DENIED ||
         !NlUpdateSeed( &ClientSession->CsAuthenticationSeed,
                        &ReturnAuthenticator.Credential,
                        &ClientSession->CsSessionKey) ) {

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlGetTrustedSideInfo: denying access after status: 0x%lx\n",
                    Status ));

        //
        // Preserve any status indicating a communication error.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_ACCESS_DENIED;
        }
        NlSetStatusClientSession( ClientSession, Status );

        //
        // Perhaps the netlogon service on the server has just restarted.
        //  Try just once to set up a session to the server again.
        //
        if ( FirstTry ) {
            FirstTry = FALSE;
            goto FirstTryFailed;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Decrypt the password returned from the server.
    //

    Status = RtlDecryptNtOwfPwdWithNtOwfPwd(
                &SessKeyEncrNewPassword,
                (PNT_OWF_PASSWORD) &SessionInfo.SessionKey,
                NewOwfPassword );
    NlAssert( NT_SUCCESS(Status) );

    Status = RtlDecryptNtOwfPwdWithNtOwfPwd(
                &SessKeyEncrOldPassword,
                (PNT_OWF_PASSWORD) &SessionInfo.SessionKey,
                OldOwfPassword );
    NlAssert( NT_SUCCESS(Status) );

    //
    // Common exit
    //

Cleanup:

    //
    // Remember to not try this call to this server in future.
    // Reset authentication seed to have the secure channel
    // working next time we use it.
    //

    if ( OldServer ) {
        ClientSession->CsAuthenticationSeed = CurrentAuthenticationSeed;
        Status = STATUS_NOT_SUPPORTED;
    }

    //
    // On success, return the trust info
    //

    if ( !NT_SUCCESS(Status) ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlGetTrustedSideInfo: %ws: failed %lX\n",
                    AccountName,
                    Status ));

        if ( LocalTrustInfo != NULL ) {
            NetApiBufferFree( LocalTrustInfo );
        }
    } else {
        *TrustInfo = LocalTrustInfo;
    }

    return Status;
}

NTSTATUS
NlVerifyTrust(
    IN PCLIENT_SESSION ClientSession,
    OUT PNETLOGON_CONTROL_QUERY_INFORMATION QueryInformation
    )
/*++

Routine Description:

    This function is used by the trusting side to verify the status
    of the secure channel to the trusted side DC.

    It first tries to use an API that goes over the secure channel and
    returns the passwords used for the given trust relationship from the
    trusted side. The trusting side checks if there is match between the
    passwords returned from the trusted side and those it has locally. If
    they match, the API returns success to the caller. If the trusted side
    lacks this functionality, the trusting side verifies the trust by
    performing an authentication call over the secure channel for a bogus
    domain\user. If the secure channel works, this is bound to fail with
    STATUS_NO_SUCH_USER in which case success is returned to the caller.

Arguments:

    ClientSession - Identifies a session to the trusted side.

    QueryInformation - Returns a pointer to a NETLOGON_INFO_2 buffer
        which contains the requested information. The buffer must be
        freed using NetApiBufferFree.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;              // Status of operation
    NTSTATUS SecureChannelStatus = STATUS_SUCCESS; // Status of secure channel
    NTSTATUS VerificationStatus = STATUS_SUCCESS;  // Status of trust verification

    NT_OWF_PASSWORD NewOwfPassword;
    NT_OWF_PASSWORD OldOwfPassword;
    NT_OWF_PASSWORD OurNewOwfPassword;
    NT_OWF_PASSWORD OurOldOwfPassword;

    PUNICODE_STRING OurNewPassword = NULL;
    PUNICODE_STRING OurOldPassword = NULL;

    ULONG DummyPasswordVersionNumber;
    LPBYTE ValidationInformation = NULL;

    LPWSTR ServerName = NULL;
    ULONG ServerDiscoveryFlags = 0;
    PNL_GENERIC_RPC_DATA TrustInfo = NULL;
    BOOL AmWriter = FALSE;
    BOOL TrustAttribVerified = FALSE;

    //
    // Become a Writer of the ClientSession.
    //

    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                 "NlVerifyTrust: Can't become writer of client session.\n"));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }
    AmWriter = TRUE;

    //
    // Get the trust passwords from the trusted side
    //

    Status = NlGetTrustedSideInfo( ClientSession,
                                   NULL, // Use the account specified in the client session
                                   NullSecureChannel, // Let the routine get the account type
                                   &NewOwfPassword,
                                   &OldOwfPassword,
                                   &TrustInfo );

    //
    // If this call is not supported on the trusted side DC,
    //  we can only check if the secure chanel is currently healthy.
    //

    if ( Status == STATUS_NOT_SUPPORTED ) {
        NETLOGON_INTERACTIVE_INFO LogonInformation;
        PNETLOGON_LOGON_IDENTITY_INFO Identity = (PNETLOGON_LOGON_IDENTITY_INFO) &LogonInformation;
        BOOLEAN Authoritative;
        WCHAR BogusName[2];
        ULONG ExtraFlags = 0;

        BogusName[0] = (WCHAR) 0xFFFF;
        BogusName[1] = UNICODE_NULL;

        //
        // Reset the status
        //

        Status = STATUS_SUCCESS;

        //
        // Initialize the structure with bogus names
        //

        RtlZeroMemory( &LogonInformation, sizeof(LogonInformation) );
        RtlInitUnicodeString( &Identity->LogonDomainName, BogusName );
        RtlInitUnicodeString( &Identity->UserName, BogusName );
        RtlInitUnicodeString( &Identity->Workstation, BogusName );

        //
        // Release the writer lock as it is used
        //  in the following secure channel call
        //

        NlResetWriterClientSession( ClientSession );
        AmWriter = FALSE;

        //
        // Force a call over the secure channel
        //

        Status = NlpUserValidateHigher( ClientSession,
                                        FALSE,  // not doing indirect trust
                                        NetlogonInteractiveInformation,
                                        (LPBYTE) &LogonInformation,
                                        NetlogonValidationSamInfo,
                                        &ValidationInformation,
                                        &Authoritative,
                                        &ExtraFlags );

        //
        // This is bound to fail. Ignore the failure.
        //

        NlAssert( !NT_SUCCESS(Status) );
        Status = STATUS_SUCCESS;

        //
        // Get the secure channel status after
        //  we made a call over it
        //

        SecureChannelStatus = NlCaptureServerClientSession(
                                        ClientSession,
                                        &ServerName,
                                        &ServerDiscoveryFlags );

        //
        // The above is our best we can do to
        //  verify the trust for an old server
        //

        VerificationStatus = SecureChannelStatus;

    //
    // Otherwise, this is the new server.
    //  Check the secure channel state. If it's successful,
    //  verify the trust status by checking whether local
    //  trust attributes and passwords match with those
    //  received from the trusted side.
    //

    } else {

        //
        // Get the secure channel status and the server
        //  name. Do this while holding the writer lock
        //  to ensure we return the name of the server
        //  used to verify the trust.
        //

        SecureChannelStatus = NlCaptureServerClientSession(
                                        ClientSession,
                                        &ServerName,
                                        &ServerDiscoveryFlags );

        //
        // Release the writer lock. We don't need it anymore.
        //

        NlResetWriterClientSession( ClientSession );
        AmWriter = FALSE;

        //
        // If secure channel is down, there is nothing
        //  to verify
        //

        if ( !NT_SUCCESS(SecureChannelStatus) ) {
            VerificationStatus = SecureChannelStatus;
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        //
        // OK, secure channel is up. However, if we couldn't
        //  get the trust info for some reason, set the
        //  verification status to the error we got while
        //  getting the trust info and bail out.
        //

        if ( !NT_SUCCESS(Status) ) {
            VerificationStatus = Status;
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        //
        // If the trusted side returned trust attributes,
        //  check if trust attributes match.
        //
        // The first ULONG in the trust info is the trust attributes
        //

        if ( TrustInfo != NULL && TrustInfo->UlongEntryCount > NL_GENERIC_RPC_TRUST_ATTRIB_INDEX ) {

            //
            // We are only interested in the forest transitive bit
            //
            if ( (ClientSession->CsTrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0 ) {
                if ( (TrustInfo->UlongData[NL_GENERIC_RPC_TRUST_ATTRIB_INDEX] &
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE) == 0 ) {
                    NlPrintCs(( NL_CRITICAL, ClientSession,
                              "NlVerifyTrust: F bit is set locally but not on trusted side\n" ));
                    VerificationStatus = STATUS_DOMAIN_TRUST_INCONSISTENT;
                    goto Cleanup;
                }
            } else {
                if ( (TrustInfo->UlongData[NL_GENERIC_RPC_TRUST_ATTRIB_INDEX] &
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0 ) {
                    NlPrintCs(( NL_CRITICAL, ClientSession,
                              "NlVerifyTrust: F bit is set on trusted side but not locally\n" ));
                    VerificationStatus = STATUS_DOMAIN_TRUST_INCONSISTENT;
                    goto Cleanup;
                }
            }
            TrustAttribVerified = TRUE;
        }

        //
        // OK, the trust attributes check succeeded.
        //  Proceed to check the password match
        //
        // Get our local passwords
        //

        Status = NlGetOutgoingPassword( ClientSession,
                                        &OurNewPassword,
                                        &OurOldPassword,
                                        &DummyPasswordVersionNumber,
                                        NULL );  // No need to return password set time

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Check if our new password matches
        // either one returned from the trusted side
        //

        if ( OurNewPassword != NULL ) {
            Status = RtlCalculateNtOwfPassword( OurNewPassword,
                                                &OurNewOwfPassword );

            if ( !NT_SUCCESS( Status ) ) {

                //
                // return more appropriate error.
                //
                if ( !NlpIsNtStatusResourceError( Status )) {
                    Status = STATUS_NO_TRUST_LSA_SECRET;
                }
                goto Cleanup;
            }

            //
            // Check if this password is the same as the new one from trusted side
            //

            if ( RtlEqualNtOwfPassword(&OurNewOwfPassword, &NewOwfPassword) ) {
                NlPrintCs(( NL_MISC, ClientSession,
                          "NlVerifyTrust: new-new password match (%s trust attributes)\n",
                          (TrustAttribVerified ? "with" : "without") ));
                VerificationStatus = STATUS_SUCCESS;
                goto Cleanup;
            }

            //
            // Check if this password is the same as the old one from trusted side
            //

            if ( RtlEqualNtOwfPassword(&OurNewOwfPassword, &OldOwfPassword) ) {
                NlPrintCs(( NL_MISC, ClientSession,
                          "NlVerifyTrust: new-old password match (%s trust attributes)\n",
                          (TrustAttribVerified ? "with" : "without") ));
                VerificationStatus = STATUS_SUCCESS;
                goto Cleanup;
            }
        }

        //
        // Check if our old password matches
        // either one returned from the trusted side
        //

        if ( OurOldPassword != NULL ) {
            Status = RtlCalculateNtOwfPassword( OurOldPassword,
                                                &OurOldOwfPassword );

            if ( !NT_SUCCESS( Status ) ) {

                //
                // return more appropriate error.
                //
                if ( !NlpIsNtStatusResourceError( Status )) {
                    Status = STATUS_NO_TRUST_LSA_SECRET;
                }
                goto Cleanup;
            }

            //
            // Check if this password is the same as the new one from trusted side
            //

            if ( RtlEqualNtOwfPassword(&OurOldOwfPassword, &NewOwfPassword) ) {
                NlPrintCs(( NL_MISC, ClientSession,
                          "NlVerifyTrust: old-new password match (%s trust attributes)\n",
                          (TrustAttribVerified ? "with" : "without") ));
                VerificationStatus = STATUS_SUCCESS;
                goto Cleanup;
            }

            //
            // Check if this password is the same as the old one from trusted side
            //

            if ( RtlEqualNtOwfPassword(&OurOldOwfPassword, &OldOwfPassword) ) {
                NlPrintCs(( NL_MISC, ClientSession,
                          "NlVerifyTrust: old-old password match (%s trust attributes)\n",
                          (TrustAttribVerified ? "with" : "without") ));
                VerificationStatus = STATUS_SUCCESS;
                goto Cleanup;
            }
        }

        //
        // If we are here, passwords didn't match
        //

        VerificationStatus = STATUS_WRONG_PASSWORD;
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlVerifyTrust: passwords don't match\n" ));
    }

Cleanup:

    if ( AmWriter ) {
        NlResetWriterClientSession( ClientSession );
    }

    //
    // On success, return the results of verification
    //

    if ( Status == STATUS_SUCCESS ) {

        //
        // If we don't know the server name,
        //  set it to blank name
        //

        if ( ServerName == NULL ) {
            ServerName = NetpAllocWStrFromWStr( L"" );
            if ( ServerName == NULL ) {
                Status = STATUS_NO_MEMORY;
            }
        }

        //
        // Allocate the memory for returned structure
        //

        if ( Status == STATUS_SUCCESS ) {
            QueryInformation->NetlogonInfo2 = MIDL_user_allocate( sizeof(NETLOGON_INFO_2) );
            if ( QueryInformation->NetlogonInfo2 == NULL ) {
                Status = STATUS_NO_MEMORY;
            }
        }

        //
        // If allocations succeeded,
        //  return the data
        //

        if ( Status == STATUS_SUCCESS ) {
            QueryInformation->NetlogonInfo2->netlog2_flags = 0;

            //
            // Indicate that we are returing the verification status
            //  in netlog2_pdc_connection_status
            //
            QueryInformation->NetlogonInfo2->netlog2_flags |= NETLOGON_VERIFY_STATUS_RETURNED;
            QueryInformation->NetlogonInfo2->netlog2_pdc_connection_status =
                NetpNtStatusToApiStatus( VerificationStatus );

            //
            // Return the server discovery flags
            //
            if ( ServerDiscoveryFlags & CS_DISCOVERY_HAS_TIMESERV ) {
                QueryInformation->NetlogonInfo2->netlog2_flags |= NETLOGON_HAS_TIMESERV;
            }

            if ( ServerDiscoveryFlags & CS_DISCOVERY_HAS_IP ) {
                QueryInformation->NetlogonInfo2->netlog2_flags |= NETLOGON_HAS_IP;
            }

            //
            // Return the current secure channel status
            //  and the server name
            //
            QueryInformation->NetlogonInfo2->netlog2_tc_connection_status =
                NetpNtStatusToApiStatus( SecureChannelStatus );
            QueryInformation->NetlogonInfo2->netlog2_trusted_dc_name = ServerName;
            ServerName = NULL;  // don't free this name below
        }
    }

    //
    // Free locally used resources
    //

    if ( OurNewPassword != NULL ) {
        LocalFree( OurNewPassword );
    }

    if ( OurOldPassword != NULL ) {
        LocalFree( OurOldPassword );
    }

    if ( ServerName != NULL ) {
        NetApiBufferFree( ServerName );
    }

    if ( TrustInfo != NULL ) {
        NetApiBufferFree( TrustInfo );
    }

    if ( ValidationInformation != NULL ) {
        MIDL_user_free( ValidationInformation );
    }

    return Status;
}


NET_API_STATUS
NetrLogonControl(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    OUT PNETLOGON_CONTROL_QUERY_INFORMATION QueryInformation
    )

/*++

Routine Description:

    This function controls various aspects of the Netlogon service.  It
    can be used to request that a BDC ensure that its copy of the SAM
    database is brought up to date.  It can, also, be used to determine
    if a BDC currently has a secure channel open to the PDC.

    Only an Admin, Account Operator or Server Operator may call this
    function.

Arguments:

    ServerName - The name of the remote server.

    FunctionCode - Defines the operation to be performed.  The valid
        values are:

        FunctionCode Values

        NETLOGON_CONTROL_QUERY - No operation.  Merely returns the
            information requested.

        NETLOGON_CONTROL_REPLICATE: Forces the SAM database on a BDC
            to be brought in sync with the copy on the PDC.  This
            operation does NOT imply a full synchronize.  The
            Netlogon service will merely replicate any outstanding
            differences if possible.

        NETLOGON_CONTROL_SYNCHRONIZE: Forces a BDC to get a
            completely new copy of the SAM database from the PDC.
            This operation will perform a full synchronize.

        NETLOGON_CONTROL_PDC_REPLICATE: Forces a PDC to ask each BDC
            to replicate now.

    QueryLevel - Indicates what information should be returned from
        the Netlogon Service.  Must be 1.

    QueryInformation - Returns a pointer to a buffer which contains the
        requested information.  The buffer must be freed using
        NetApiBufferFree.


Return Value:

    NERR_Success: the operation was successful

    ERROR_NOT_SUPPORTED: Function code is not valid on the specified
        server.  (e.g. NETLOGON_CONTROL_REPLICATE was passed to a PDC).

--*/
{
    NET_API_STATUS NetStatus;

    QueryInformation->NetlogonInfo1 = NULL;

    switch( QueryLevel ) {
    case (1):
        break;
    case (2):
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;

    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // ensure the input data is valid.
    //

    switch( FunctionCode ) {
    case NETLOGON_CONTROL_QUERY:
    case NETLOGON_CONTROL_REPLICATE:
    case NETLOGON_CONTROL_SYNCHRONIZE:
    case NETLOGON_CONTROL_PDC_REPLICATE:

#if NETLOGONDBG
    case NETLOGON_CONTROL_BACKUP_CHANGE_LOG:
    case NETLOGON_CONTROL_TRUNCATE_LOG:
    case NETLOGON_CONTROL_BREAKPOINT:
#endif // NETLOGONDBG

        break;

    default:
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;

    }

    NetStatus = NetrLogonControl2Ex(
                    ServerName,
                    FunctionCode,
                    QueryLevel,
                    NULL,
                    QueryInformation );

Cleanup:

    return( NetStatus );
}

NET_API_STATUS
NetrLogonControl2(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    IN PNETLOGON_CONTROL_DATA_INFORMATION InputData,
    OUT PNETLOGON_CONTROL_QUERY_INFORMATION QueryInformation
    )

/*++

Routine Description:

    Same as NetrLogonControl2Ex.

    A client should never pass a QueryLevel of 4 to this procedure.  We don't check since, if
    they did, it's too late now.  The client will access violate upon return.

Arguments:

    Same as NetrLogonControl2Ex.

Return Value:


--*/
{
    NET_API_STATUS NetStatus;

    NetStatus = NetrLogonControl2Ex(
                    ServerName,
                    FunctionCode,
                    QueryLevel,
                    InputData,
                    QueryInformation );


    return NetStatus;
}



NET_API_STATUS
NetrLogonControl2Ex(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    IN PNETLOGON_CONTROL_DATA_INFORMATION InputData,
    OUT PNETLOGON_CONTROL_QUERY_INFORMATION QueryInformation
    )

/*++

Routine Description:

    This function controls various aspects of the Netlogon service.  It
    can be used to request that a BDC ensure that its copy of the SAM
    database is brought up to date.  It can, also, be used to determine
    if a BDC currently has a secure channel open to the PDC.

    Only an Admin, Account Operator or Server Operator may call this
    function.

Arguments:

    ServerName - The name of the remote server.

    FunctionCode - Defines the operation to be performed.  The valid
        values are:

        FunctionCode Values

        NETLOGON_CONTROL_QUERY - No operation.  Merely returns the
            information requested.

        NETLOGON_CONTROL_REPLICATE: Forces the SAM database on a BDC
            to be brought in sync with the copy on the PDC.  This
            operation does NOT imply a full synchronize.  The
            Netlogon service will merely replicate any outstanding
            differences if possible.

        NETLOGON_CONTROL_SYNCHRONIZE: Forces a BDC to get a
            completely new copy of the SAM database from the PDC.
            This operation will perform a full synchronize.

        NETLOGON_CONTROL_PDC_REPLICATE: Forces a PDC to ask each BDC
            to replicate now.

        NETLOGON_CONTROL_REDISCOVER: Forces a DC to rediscover the
            specified trusted domain DC.

        NETLOGON_CONTROL_TC_QUERY: Query the status of the specified
            trusted domain secure channel.

        NETLOGON_CONTROL_TC_VERIFY: Verify the status of the specified
            trusted domain secure channel. If the current status is
            success (which means that the last operation performed
            over the secure channel was successful), ping the DC. If the
            current status is not success or the ping fails, rediscover
            a new DC.

        NETLOGON_CONTROL_TRANSPORT_NOTIFY: Notifies netlogon that a new transport
            has been added.  Currently, it merely resets discovery timeouts allowing
            all secure channel discoveries to be retried immediately.  However, the
            intention is to later add support for anything similar.  The intention is that
            a client can call this function after a new transport has been added (e.g., it
            dialed a RAS link) and immediately before calling Netlogon (e.g., indirectly
            by doing an LsaLogonUser).

        NETLOGON_CONTROL_FORCE_DNS_REG: Forces the DC to re-register all of its
            DNS records.  QueryLevel parameter must be 1.

        NETLOGON_CONTROL_QUERY_DNS_REG: Query the status of DNS updates
            performed by netlogon. If there was any DNS registration or
            deregistration error for any of the records as they were
            updated last time, the query result will be negative;
            otherwise the query result will be positive.
            QueryLevel parameter must be 1.

    QueryLevel - Indicates what information should be returned from
        the Netlogon Service.

    InputData - According to the function code specified this parameter
        will carry input data. NETLOGON_CONTROL_REDISCOVER,
        NETLOGON_CONTROL_TC_QUERY, and NETLOGON_CONTROL_TC_VERIFY
        function code specify the trusted domain name (LPWSTR type) here.
        NETLOGON_CONTROL_FIND_USER function code specifies the user name
        (LPWSTR type) here.

    QueryInformation - Returns a pointer to a buffer which contains the
        requested information.  The buffer must be freed using
        NetApiBufferFree.


Return Value:

    NERR_Success: the operation was successful

    ERROR_NOT_SUPPORTED: Function code is not valid on the specified
        server.  (e.g. NETLOGON_CONTROL_REPLICATE was passed to a PDC).

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    DWORD i;
    DWORD InfoSize;
    BOOL DnsLastStatusCheck = TRUE;
    ACCESS_MASK DesiredAccess;

    UNICODE_STRING DomainName;
    PDOMAIN_INFO DomainInfo = NULL;
    PCLIENT_SESSION ClientSession = NULL;
    LPWSTR TDCName = NULL;
    LPWSTR TrustedDomainName = NULL;
    LPWSTR SamAccountName = NULL;
    LPWSTR SamDomainName = NULL;
    DWORD SamExtraFlags;
    DWORD TcServerDiscoveryFlags = 0;
    PNL_DC_CACHE_ENTRY DcCacheEntry = NULL;

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ServerName );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }

    //
    // Ensure the QueryLevel is valid
    //

    QueryInformation->NetlogonInfo1 = NULL;

    switch( QueryLevel ) {
    case (1):
    case (2):
    case (3):
    case (4):
        break;
    default:
        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // ensure the input data is valid.
    //

    switch( FunctionCode ) {
    case NETLOGON_CONTROL_REDISCOVER:
    case NETLOGON_CONTROL_TC_QUERY:
    case NETLOGON_CONTROL_TC_VERIFY:
    case NETLOGON_CONTROL_FIND_USER:
    case NETLOGON_CONTROL_CHANGE_PASSWORD:
#if NETLOGONDBG
    case NETLOGON_CONTROL_SET_DBFLAG:
#endif // NETLOGONDBG

        NlAssert( InputData != NULL );
        if( InputData == NULL ) {
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        break;

    default:
        break;
    }

    //
    // compute access mask.
    //

    switch ( FunctionCode ) {

    case NETLOGON_CONTROL_QUERY:
    case NETLOGON_CONTROL_TC_QUERY:
    case NETLOGON_CONTROL_TRANSPORT_NOTIFY:
    case NETLOGON_CONTROL_QUERY_DNS_REG:
        DesiredAccess = NETLOGON_QUERY_ACCESS;
        break;

    case NETLOGON_CONTROL_REPLICATE:
    case NETLOGON_CONTROL_SYNCHRONIZE:
    case NETLOGON_CONTROL_PDC_REPLICATE:
    case NETLOGON_CONTROL_REDISCOVER:
    case NETLOGON_CONTROL_TC_VERIFY:
    case NETLOGON_CONTROL_FIND_USER:
    case NETLOGON_CONTROL_CHANGE_PASSWORD:
    case NETLOGON_CONTROL_FORCE_DNS_REG:
#if NETLOGONDBG
    case NETLOGON_CONTROL_BREAKPOINT:
    case NETLOGON_CONTROL_SET_DBFLAG:
    case NETLOGON_CONTROL_TRUNCATE_LOG:
    case NETLOGON_CONTROL_BACKUP_CHANGE_LOG:
#endif // NETLOGONDBG
    default:
        DesiredAccess = NETLOGON_CONTROL_ACCESS;
        break;
    }


    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,     // Security descriptor
            DesiredAccess,                          // Desired access
            &NlGlobalNetlogonInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }


    //
    // Handle the various FunctionCodes
    //

    switch ( FunctionCode ) {

    //
    // On a query, do nothing but return status.
    //

    case NETLOGON_CONTROL_QUERY:
        NlPrintDom((NL_MISC,  DomainInfo,
                 "QUERY function received.\n"));
        break;

#ifdef _DC_NETLOGON
    //
    // Force a PDC to broadcast a database change record.
    //

    case NETLOGON_CONTROL_PDC_REPLICATE:

        NlPrint((NL_SYNC, "PDC REPLICATE function received.\n" ));
#if 0
        {
            NlSitesUpdateSiteCoverage( DomainInfo, NULL );
            NlPrintDom((NL_CRITICAL, DomainInfo,
                        "Cliffs test code *****************************.\n" ));
        }
#endif
        //
        // This FunctionCode is only valid on a PDC
        //

        if ( !NlGlobalPdcDoReplication ) {
            NlPrint((NL_CRITICAL, "PDC REPLICATE only supported in mixed mode.\n" ));

            NetStatus = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        }

        //
        // Simply send the announcement.  Any BDC that is out of date
        // will replicate any changes.
        //

        NlPrimaryAnnouncement( ANNOUNCE_FORCE );

        break;
#endif // _DC_NETLOGON


    //
    // Force to rediscover trusted domain DCs.
    //

    case NETLOGON_CONTROL_REDISCOVER: {
        LPWSTR DiscoveredDc;

        NlPrintDom((NL_SESSION_SETUP,  DomainInfo,
                 "NETLOGON_CONTROL_REDISCOVER function received.\n"));

        NlAssert( InputData->TrustedDomainName != NULL );
        if( InputData->TrustedDomainName == NULL ) {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                     "NetrLogonControl called with function code NETLOGON_CONTROL_REDISCOVER "
                        "specified NULL trusted domain name. \n"));

            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Determine if there is a \ in the passed name.
        //  If so, truncate the string there and save a pointer to the
        //  DC name after the \.
        //

        DiscoveredDc = wcschr( InputData->TrustedDomainName, L'\\' );

        if ( DiscoveredDc != NULL ) {
            *DiscoveredDc = L'\0';
            DiscoveredDc++;
        }


        RtlInitUnicodeString(&DomainName, InputData->TrustedDomainName );

        //
        // get client structure for the specified domain.
        //

        ClientSession = NlFindNamedClientSession( DomainInfo,
                                                  &DomainName,
                                                  NL_DIRECT_TRUST_REQUIRED,
                                                  NULL );

        if( ClientSession == NULL ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NetrLogonControl can't find the client structure of the domain %wZ specified.\n",
                    &DomainName ));

            NetStatus =  ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        //
        // Ping the DC to figure out if it is available
        //

        if ( DiscoveredDc != NULL ) {

            //
            // We ensure that the DC has our account.
            //  Otherwise, if this DC doesn't have our
            //  account, the session setup may rediscover
            //  a different DC and we may end up setting
            //  up the secure channel to a DC other than
            //  the one passed to us.
            //
            NetStatus = NlPingDcName(
                         ClientSession,
                         0,              // Try both ping mechanisms
                         TRUE,           // Cache this DC
                         FALSE,          // Do not require IP
                         TRUE,           // Ensure the DC has our account
                         FALSE,          // Do not refresh the session
                         DiscoveredDc,   // Ping this DC
                         &DcCacheEntry );

            if ( NetStatus != NO_ERROR ) {
                NlPrintCs((NL_SESSION_SETUP, ClientSession,
                    "NetrLogonControl: Unsuccessful response from DC %ws 0x%lx\n",
                    DiscoveredDc, NetStatus ));
                //
                // If the service is paused on the server, return the
                //  appropriate status.  Otherwise, map the status
                //  to a generic error code.
                //
                if ( NetStatus != ERROR_SERVICE_NOT_ACTIVE ) {
                    NetStatus = ERROR_NO_LOGON_SERVERS;
                }
                goto Cleanup;
            } else {
                NlPrintCs((NL_SESSION_SETUP, ClientSession,
                    "NetrLogonControl: Successful response from DC %ws\n",
                    DiscoveredDc ));
            }
        }



        //
        // Force Discovery of a DC
        //

        if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                     "NetrLogonControl2: Can't become writer of client session.\n"));
            NetStatus = ERROR_NO_LOGON_SERVERS;
            goto Cleanup;
        } else {

            //
            // Reset the current DC.
            //
            NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );

            //
            // If the caller specified a DC,
            //  set it in the client sesion structure.
            //
            if ( DcCacheEntry != NULL ) {
                NlSetServerClientSession( ClientSession,
                                          DcCacheEntry,
                                          TRUE,     // was discovery with account
                                          FALSE );  // not the session refresh
            }

            //
            // Setup a session to the DC (Discover one if needed)
            //
            Status = NlSessionSetup( ClientSession );
            NlResetWriterClientSession( ClientSession );

            if ( !NT_SUCCESS(Status) ) {

                NlPrintCs((NL_CRITICAL, ClientSession,
                    "NetrLogonControl: Discovery failed %lx\n",
                    Status ));

                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }
        }

        break;
        }

    case NETLOGON_CONTROL_TC_QUERY:
        NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                 "NETLOGON_CONTROL_TC_QUERY function received.\n"));

        NlAssert( InputData->TrustedDomainName != NULL );
        if( InputData->TrustedDomainName == NULL ) {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonControl called with NETLOGON_CONTROL_TC_QUERY "
                "and specified NULL trusted domain name. \n"));
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        RtlInitUnicodeString(&DomainName, InputData->TrustedDomainName );

        //
        // get client structure for the specified domain.
        //

        ClientSession = NlFindNamedClientSession( DomainInfo,
                                                  &DomainName,
                                                  NL_DIRECT_TRUST_REQUIRED,
                                                  NULL );

        if( ClientSession == NULL ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonControl can't find the client structure of the domain %wZ specified.\n",
                &DomainName ));

            NetStatus =  ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }
        break;

    case NETLOGON_CONTROL_TC_VERIFY:
        NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                 "NETLOGON_CONTROL_TC_VERIFY function received.\n"));

        NlAssert( InputData->TrustedDomainName != NULL );
        if( InputData->TrustedDomainName == NULL ) {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonControl called with NETLOGON_CONTROL_TC_VERIFY "
                "and specified NULL trusted domain name. \n"));
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // This requires query level 2
        //

        if ( QueryLevel != 2 ) {
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;
        }


        RtlInitUnicodeString(&DomainName, InputData->TrustedDomainName );

        //
        // get client structure for the specified domain.
        //

        ClientSession = NlFindNamedClientSession( DomainInfo,
                                                  &DomainName,
                                                  NL_DIRECT_TRUST_REQUIRED,
                                                  NULL );

        if( ClientSession == NULL ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonControl can't find the client structure of the domain %wZ specified.\n",
                &DomainName ));

            NetStatus =  ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        //
        // Verify the trust
        //

        Status = NlVerifyTrust( ClientSession, QueryInformation );

        //
        // NlVerifyTrust built all the required info,
        //  so we are done
        //

        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;

    case NETLOGON_CONTROL_CHANGE_PASSWORD:
        NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                 "NETLOGON_CONTROL_CHANGE_PASSWORD function received.\n"));

        // NlAssert( InputData->TrustedDomainName != NULL );
        if( InputData->TrustedDomainName == NULL ) {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonControl called with NETLOGON_CONTROL_CHANGE_PASSWORD "
                "and specified NULL trusted domain name. \n"));
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        RtlInitUnicodeString(&DomainName, InputData->TrustedDomainName );

        //
        // get client structure for the specified domain.
        //

        ClientSession = NlFindNamedClientSession( DomainInfo,
                                                  &DomainName,
                                                  NL_DIRECT_TRUST_REQUIRED | NL_ROLE_PRIMARY_OK,
                                                  NULL );

        if( ClientSession == NULL ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonControl can't find the client structure of the domain %wZ specified.\n",
                &DomainName ));

            NetStatus =  ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        //
        // Do not allow password change for an interdomain trust account on a BDC
        //

        if ( (DomainInfo->DomRole == RoleBackup) &&
             ( IsDomainSecureChannelType(ClientSession->CsSecureChannelType )) ) {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonControl called with NETLOGON_CONTROL_CHANGE_PASSWORD "
                "for an interdomain trust account on a BDC. \n"));
            NetStatus = ERROR_INVALID_DOMAIN_ROLE;
            goto Cleanup;
        }

        //
        // Force the password on the client session found
        //

        Status = NlChangePassword( ClientSession, TRUE, NULL );

        if ( !NT_SUCCESS(Status) ) {

            NlPrintCs((NL_CRITICAL, ClientSession,
                "NetrLogonControl: Password Change failed %lx\n",
                Status ));

            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        break;

    //
    // A client has added a new transport and needs us to use it.
    //  Mark all the client sessions that its OK to authentication NOW.
    //

    case NETLOGON_CONTROL_TRANSPORT_NOTIFY: {
        NlPrint((NL_SESSION_SETUP , "NETLOGON_CONTROL_TRANSPORT_NOTIFY function received.\n" ));

        //
        // Flush any caches that aren't valid any more since there
        // is now a new transport
        //
        NlFlushCacheOnPnp();

        break;
    }

    //
    // Find a user in one of the trusted domains.
    //

    case NETLOGON_CONTROL_FIND_USER: {

        UNICODE_STRING UserNameString;
        NlPrint((NL_MISC, "NETLOGON_CONTROL_FIND_USER function received for %ws.\n", InputData->UserName ));

        if ( QueryLevel != 4 ) {
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Don't allow on workstation since CrackSingleName isn't implemented on
        //  a workstation.
        //

        if ( NlGlobalMemberWorkstation ) {
            NetStatus = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        }

        //
        // Find a user in one of the trusted domains.
        //
        //  Allow machine accounts just as a handy extension.
        //  Don't find "Local User" accounts since we can't pass through to them
        //


        RtlInitUnicodeString( &UserNameString, InputData->UserName );

        Status = NlPickDomainWithAccount (
                            DomainInfo,
                            &UserNameString,
                            NULL,               // No domain name
                            USER_NORMAL_ACCOUNT | USER_MACHINE_ACCOUNT_MASK,
                            NullSecureChannel,  // No incoming secure channel
                            FALSE,              // Call wasn't expedited to root
                            FALSE,              // Call wasn't first hop across forest.
                            &SamAccountName,
                            &SamDomainName,
                            &SamExtraFlags );

        if ( !NT_SUCCESS( Status )) {
            if ( Status == STATUS_NO_SUCH_DOMAIN ) {
                NetStatus = NERR_UserNotFound;
            } else {
                NetStatus = NetpNtStatusToApiStatus( Status );
            }
            goto Cleanup;
        }

        //
        // If the account isn't in this forest,
        //  tell the caller.
        //

        if ( SamExtraFlags & (NL_EXFLAGS_EXPEDITE_TO_ROOT|NL_EXFLAGS_CROSS_FOREST_HOP) ) {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                     "NetrLogonControl: User %ws is in a trusted forest (%lx).\n",
                     InputData->UserName,
                     SamExtraFlags ));

            NetStatus = NERR_UserNotFound;
            goto Cleanup;

        }

        }
        break;

    //
    // Force re-registration of all DNS records for this DC
    //

    case NETLOGON_CONTROL_FORCE_DNS_REG:

        //
        // This is not supported on workstations
        //

        if ( NlGlobalMemberWorkstation ) {
            NetStatus = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        }

        //
        // Re-register all records
        //

        NlDnsPnp( TRUE );
        break;

    //
    // Query the status of last DNS updates
    //

    case NETLOGON_CONTROL_QUERY_DNS_REG:

        //
        // This is not supported on workstations
        //

        if ( NlGlobalMemberWorkstation ) {
            NetStatus = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        }

        //
        // This requires query level 1
        //

        if ( QueryLevel != 1 ) {
            NetStatus = ERROR_INVALID_LEVEL;
            goto Cleanup;
        }

        //
        // Call the worker
        //

        DnsLastStatusCheck = NlDnsCheckLastStatus();
        break;

#if NETLOGONDBG
    //
    // Force a breakpoint
    //

    case NETLOGON_CONTROL_BREAKPOINT:
        KdPrint(( "I_NetLogonControl Break Point\n"));
#if DBG
        DbgBreakPoint();
#else // DBG
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
#endif // DBG
        break;

    //
    // Change the debug flags
    //

    case NETLOGON_CONTROL_SET_DBFLAG:
        NlGlobalParameters.DbFlag = InputData->DebugFlag;
        NlPrint((NL_MISC,"DbFlag is set to %lx\n", NlGlobalParameters.DbFlag ));

        break;

    //
    // Truncate the log file
    //

    case NETLOGON_CONTROL_TRUNCATE_LOG:

        NlOpenDebugFile( TRUE );
        NlPrint((NL_MISC, "TRUNCATE_LOG function received.\n" ));
        break;

    //
    // Backup changelog file
    //

    case NETLOGON_CONTROL_BACKUP_CHANGE_LOG:

        NlPrint((NL_MISC, "BACKUP_CHANGE_LOG function received, (%ld).\n", NetStatus ));
        NetStatus = NlBackupChangeLogFile();
        break;

#if DBG
    //
    // Unload Netlogon.dll
    //

    case NETLOGON_CONTROL_UNLOAD_NETLOGON_DLL:

        //
        // Don't unload the DLL now.
        // RPC still needs the the DLL as a security provider throughout shutdown.
        //

        NlPrint((NL_MISC, "UNLOAD_NETLOGON_DLL function received.\n" ));
        NlGlobalUnloadNetlogon = TRUE;

        NetStatus = NO_ERROR;
        break;
#endif // DBG

#endif // NETLOGONDBG

    //
    // All other function codes are invalid.
    //

    default:
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }


    //
    // allocate return info structure.
    //

    switch( QueryLevel ) {
    case (1):
        InfoSize = sizeof(NETLOGON_INFO_1);
        break;
    case (2):
        InfoSize = sizeof(NETLOGON_INFO_2);
        break;
    case (3):
        InfoSize = sizeof(NETLOGON_INFO_3);
        break;
    case (4):
        InfoSize = sizeof(NETLOGON_INFO_4);
        break;
    }

    QueryInformation->NetlogonInfo1 = MIDL_user_allocate( InfoSize );

    if ( QueryInformation->NetlogonInfo1 == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }



    //
    // Return DomainName and DC Name.
    //
    switch( QueryLevel ) {
    case (4):
        switch ( FunctionCode ) {
        case NETLOGON_CONTROL_FIND_USER: {
            UNICODE_STRING SamDomainNameString;

            //
            // If the account is in this Domain,
            //  return the name of this DC.
            //

            RtlInitUnicodeString( &SamDomainNameString, SamDomainName );

            if ( RtlEqualDomainName( &SamDomainNameString,
                                     &DomainInfo->DomUnicodeDomainNameString ) ||
                 NlEqualDnsNameU( &SamDomainNameString,
                                  &DomainInfo->DomUnicodeDnsDomainNameString ) ) {


                //
                // Grab the name of this DC.
                //

                TDCName = NetpAllocWStrFromWStr( DomainInfo->DomUncUnicodeComputerName );

                if ( TDCName == NULL ) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                //
                // Grab the name of this domain.
                //

                LOCK_TRUST_LIST( DomainInfo );
                TrustedDomainName = NetpAllocWStrFromWStr( DomainInfo->DomUnicodeDomainName );
                UNLOCK_TRUST_LIST( DomainInfo );

                if ( TrustedDomainName == NULL ) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

            //
            // If the account is not in this domain,
            //  find the client session and get the DC name from there.
            //

            } else {

                //
                // Find the client session of the Domain anywhere in the forest.
                //

                ClientSession = NlFindNamedClientSession(
                                            DomainInfo,
                                            &SamDomainNameString,
                                            0,  // Indirect trust OK
                                            NULL );

                if ( ClientSession == NULL ) {
                    //
                    // Replication latency.  The GC knows of a domain in the forest
                    //  that we don't trust.
                    //

                    NlPrintDom((NL_CRITICAL, DomainInfo,
                             "NetrLogonControl: User %ws\\%ws apparently isn't in this forest.\n",
                             SamAccountName,
                             SamDomainName ));

                    NetStatus = NERR_UserNotFound;
                    goto Cleanup;
                }

                //
                // If the account isn't on a directly trusted domain,
                //  indicate that we don't know the DC.
                //

                if ( (ClientSession->CsFlags & CS_DIRECT_TRUST) == 0 ) {
                    TDCName = NULL;


                //
                // If the account is on a directly trusted domain,
                //  return the name of a DC in the domain.
                //
                // Capture the name of the server
                //  (even if it is an empty string.)
                //

                } else {

                    // REVIEW: do discovery here.
                    Status = NlCaptureServerClientSession( ClientSession, &TDCName, NULL );

                    if ( !NT_SUCCESS( Status )) {
                        TDCName = NetpAllocWStrFromWStr( L"" );
                    }

                    if ( TDCName == NULL ) {
                        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }
                }

                //
                // Capture the name of the domain.
                //

                if ( ClientSession->CsDebugDomainName != NULL ) {
                    TrustedDomainName = NetpAllocWStrFromWStr( ClientSession->CsDebugDomainName );

                    if ( TrustedDomainName == NULL ) {
                        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }
                } else {
                    TrustedDomainName = NULL;
                }
            }

            QueryInformation->NetlogonInfo4->netlog4_trusted_dc_name = TDCName;
            QueryInformation->NetlogonInfo4->netlog4_trusted_domain_name = TrustedDomainName;
            break;
            }

        default:
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        break;

    //
    // Return queried profile information.
    //
    case (3):
        QueryInformation->NetlogonInfo3->netlog3_flags = 0;
        QueryInformation->NetlogonInfo3->netlog3_logon_attempts =
        // ??: What about kerberos logons
            MsvGetLogonAttemptCount();
        QueryInformation->NetlogonInfo3->netlog3_reserved1 = 0;
        QueryInformation->NetlogonInfo3->netlog3_reserved2 = 0;
        QueryInformation->NetlogonInfo3->netlog3_reserved3 = 0;
        QueryInformation->NetlogonInfo3->netlog3_reserved4 = 0;
        QueryInformation->NetlogonInfo3->netlog3_reserved5 = 0;
        break;

    //
    // Return secure channel specific information.
    //
    case (2):
        switch ( FunctionCode ) {
        case NETLOGON_CONTROL_REDISCOVER:
        case NETLOGON_CONTROL_TC_QUERY:
        case NETLOGON_CONTROL_TC_VERIFY:

            if( ClientSession == NULL ) {
                NetStatus =  ERROR_NO_SUCH_DOMAIN;
                goto Cleanup;
            }

            //
            // Capture the name of the server
            //  (even if it is an empty string.)
            //

            Status = NlCaptureServerClientSession( ClientSession,
                                                   &TDCName,
                                                   &TcServerDiscoveryFlags );

            QueryInformation->NetlogonInfo2->netlog2_tc_connection_status =
                NetpNtStatusToApiStatus(Status);

            if ( !NT_SUCCESS( Status )) {
                TDCName = NetpAllocWStrFromWStr( L"" );
            }

            if ( TDCName == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            QueryInformation->NetlogonInfo2->netlog2_trusted_dc_name = TDCName;
            break;

        default:
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // fall through to fill other fields of the info structure.
        //


    //
    // Return status of secure channel to PDC.
    //
    case (1):


        //
        // Fill in the return buffer
        //

        QueryInformation->NetlogonInfo1->netlog1_flags = 0;

        if ( TcServerDiscoveryFlags & CS_DISCOVERY_HAS_TIMESERV ) {
            QueryInformation->NetlogonInfo1->netlog1_flags |= NETLOGON_HAS_TIMESERV;
        }

        if ( TcServerDiscoveryFlags & CS_DISCOVERY_HAS_IP ) {
            QueryInformation->NetlogonInfo1->netlog1_flags |= NETLOGON_HAS_IP;
        }

        if ( !DnsLastStatusCheck ) {
            QueryInformation->NetlogonInfo1->netlog1_flags |= NETLOGON_DNS_UPDATE_FAILURE;
        }

        if ( DomainInfo->DomRole == RolePrimary ) {
            QueryInformation->NetlogonInfo1->netlog1_pdc_connection_status =
                 NERR_Success;
        } else {
            PCLIENT_SESSION LocalClientSession;

            LocalClientSession = NlRefDomClientSession( DomainInfo );
            if ( LocalClientSession != NULL ) {
                QueryInformation->NetlogonInfo1->netlog1_pdc_connection_status =
                        NetpNtStatusToApiStatus( LocalClientSession->CsConnectionStatus);
                NlUnrefClientSession( LocalClientSession );
            } else {
                QueryInformation->NetlogonInfo1->netlog1_pdc_connection_status =
                    ERROR_NOT_SUPPORTED;
            }
        }
        break;

    default:
        break;
    }

    NetStatus = NERR_Success;

    //
    // Free up locally used resources.
    //
Cleanup:

    if( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
    }

    if ( SamAccountName != NULL ) {
        NetApiBufferFree( SamAccountName );
    }
    if ( SamDomainName != NULL ) {
        NetApiBufferFree( SamDomainName );
    }

    if ( NetStatus != NERR_Success ) {

        if ( QueryInformation->NetlogonInfo1 != NULL ) {
            MIDL_user_free( QueryInformation->NetlogonInfo1 );
            QueryInformation->NetlogonInfo1 = NULL;
        }

        if ( TDCName != NULL ) {
            MIDL_user_free( TDCName );
        }
        if ( TrustedDomainName != NULL ) {
            MIDL_user_free( TrustedDomainName );
        }

    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    if ( DcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( DcCacheEntry );
    }

    return NetStatus;
}

VOID
NlFreePingContext(
    IN PNL_GETDC_CONTEXT PingContext
    )

/*++

Routine Description:

    Free the context used to perform DC pings.

Arguments:

    PingContext - Context used to perform the pings.

--*/
{
    if ( PingContext != NULL ) {
        NetpDcUninitializeContext( PingContext );
        NetApiBufferFree( PingContext );
    }
}

NET_API_STATUS
NlPingDcName (
    IN  PCLIENT_SESSION ClientSession,
    IN  ULONG  DcNamePingFlags,
    IN  BOOL CachePingedDc,
    IN  BOOL RequireIp,
    IN  BOOL DoPingWithAccount,
    IN  BOOL RefreshClientSession,
    IN  LPWSTR DcName OPTIONAL,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry OPTIONAL
    )

/*++

Routine Description:

    Ping the specified DC using the appropriate ping mechanism.

    If RefreshClientSession is TRUE, the caller must be the writer
    of the passed client session.

Arguments:

    ClientSession - The client session to ping a DC for.  If DcName is
        NULL, the server from ClientSession is pinged.  If DcName isn't
        NULL, ClientSession is used to get the session info (other than
        the server name) needed to perform the pings.

    DcNamePingFlags - Specifies properties of DcName.  Can be
        DS_PING_NETBIOS_HOST or DS_PING_NETBIOS_HOST or zero. If other than
        zero, only the specified ping mechanism will be used.

    CachePingedDc - If TRUE, the successfully pinged DC will be cached
        for future use by DsGetDcName.

    RequireIp - TRUE if pinging the DC must be done using only IP enabled
        transports.

    DoPingWithAccount - If TRUE, the account name for this machine will be
        specified in the pings.

    RefreshClientSession - If TRUE, the client session will be refreshed
        using the ping response info.  If TRUE, the caller must be the
        writer of the client session.

    DcName - If set, that DC name will be pinged using info from ClientSession.

    NlDcCacheEntry - Returns the data structure describing response received
        from the DC. Should be freed by calling NetpDcDerefCacheEntry.

Return Value:

    NO_ERROR - Success.

    ERROR_NO_LOGON_SERVERS - No DC could be found

    ERROR_NO_SUCH_USER - Returned if we do ping with account and the DC doesn't
        have the account specified.

    ERROR_DOMAIN_TRUST_INCONSISTENT - The server that responded is not a proper
        domain controller of the specified domain.

    ERROR_SERVICE_NOT_ACTIVE - The netlogon service is paused on the server.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    LPWSTR LocalDcName = NULL;
    LPWSTR CapturedDnsForestName = NULL;
    ULONG AllowableAccountControlBits;

    NL_GETDC_CONTEXT Context;
    BOOL TriedContextInitialization = FALSE;
    ULONG Flags = 0;
    ULONG InternalFlags = 0;
    PDNS_RECORD DnsRecords = NULL;
    LPSOCKET_ADDRESS SockAddresses = NULL;
    LPSOCKET_ADDRESS AllocatedSockAddresses = NULL;
    SOCKET_ADDRESS OneSockAddress;
    SOCKADDR_IN OneSockAddressIn;
    ULONG SockAddressCount = 0;
    ULONG LoopIndex;

    PNL_DC_CACHE_ENTRY LocalNlDcCacheEntry = NULL;

    //
    // If a DC name specified, try to figure out its properties
    //

    if ( DcName != NULL ) {

        //
        // Prove below that the name is valid
        //

        NetStatus = ERROR_INVALID_COMPUTERNAME;

        //
        // If the DC name is a syntactically valid DNS name,
        //  assume the server name is a DNS name.
        //
        // Skip this step if we are told that the name is Netbios.
        //

        if ( (DcNamePingFlags & DS_PING_NETBIOS_HOST) == 0 &&
             NetpDcValidDnsDomain(DcName) ) {

            NetStatus = NO_ERROR;

            //
            // Get the IP address of the server from DNS
            //

            NetStatus = DnsQuery_W( DcName,
                                    DNS_TYPE_A,
                                    0,
                                    NULL,   // No list of DNS servers
                                    &DnsRecords,
                                    NULL );

            //
            // On success, set to use ldap pings. Otherwise, do not
            //  error out, rather try the mailslot mechanism
            //

            if ( NetStatus == NO_ERROR ) {
                NetStatus = NetpSrvProcessARecords( DnsRecords,
                                                    NULL,
                                                    0,
                                                    &SockAddressCount,
                                                    &AllocatedSockAddresses );

                if ( NetStatus == NO_ERROR && SockAddressCount > 0 ) {
                    SockAddresses = AllocatedSockAddresses;
                    InternalFlags |= DS_PING_USING_LDAP;
                    InternalFlags |= DS_PING_DNS_HOST;
                }
            }
        }

        //
        // If the DC name is syntactically valid Netbios name,
        // assume you can use mailslot pings
        //
        // Skip this step if we are told that the name is DNS.
        //

        if ( (DcNamePingFlags & DS_PING_DNS_HOST) == 0 &&
             NetpIsComputerNameValid(DcName) &&
             wcslen(DcName) <= CNLEN ) {  // NetpIsComputerNameValid doesn't require 15 chacter limit

            NetStatus = NO_ERROR;
            InternalFlags |= DS_PING_USING_MAILSLOT;
            InternalFlags |= DS_PING_NETBIOS_HOST;
        }

        //
        // If there is no ping mechanism to use, error out
        //

        if ( (InternalFlags & (DS_PING_USING_LDAP|DS_PING_USING_MAILSLOT)) == 0 ) {
            NlPrintCs(( NL_CRITICAL, ClientSession,
                        "NlPingDcName: No ping mechanism for %ws 0x%lx\n",
                        DcName, NetStatus ));
            NetStatus = ERROR_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        LocalDcName = DcName;
    }

    //
    // If this is a client session to a domain in our
    //  forest (always the case on workstation),
    //  get our forest name.
    //

    if ( NlGlobalMemberWorkstation ||
         (ClientSession->CsFlags & CS_DOMAIN_IN_FOREST) != 0 ) {

        CapturedDnsForestName = LocalAlloc( LMEM_ZEROINIT,
                                            (NL_MAX_DNS_LENGTH+1)*sizeof(WCHAR) );
        if ( CapturedDnsForestName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        NlCaptureDnsForestName( CapturedDnsForestName );
    }

    //
    // Capture the needed info from the Client session
    //

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

    //
    // Capture the server name if the one wasn't passed.
    //  If the client session is idle, this will fail.
    //

    if ( DcName == NULL ) {
        ULONG DiscoveryFlags = 0;

        Status = NlCaptureServerClientSession( ClientSession,
                                               &LocalDcName,
                                               &DiscoveryFlags );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintCs(( NL_CRITICAL, ClientSession,
                        "NlPingDcName: Cannot NlCaptureServerClientSession %ld\n",
                        Status ));

            if ( Status == STATUS_NO_MEMORY ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                NetStatus = ERROR_NO_LOGON_SERVERS;
            }
            LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
            goto Cleanup;
        }

        if ( DiscoveryFlags & CS_DISCOVERY_DNS_SERVER ) {
            InternalFlags |= DS_PING_DNS_HOST;
        } else {
            InternalFlags |= DS_PING_NETBIOS_HOST;
        }

        if ( DiscoveryFlags & CS_DISCOVERY_USE_LDAP ) {
            InternalFlags |= DS_PING_USING_LDAP;

            //
            // Capture the cached server socket address
            //
            NlAssert( ClientSession->CsServerSockAddr.iSockaddrLength != 0 );
            OneSockAddress.iSockaddrLength = ClientSession->CsServerSockAddr.iSockaddrLength;
            OneSockAddress.lpSockaddr = (LPSOCKADDR) &OneSockAddressIn;
            RtlCopyMemory( OneSockAddress.lpSockaddr,
                           ClientSession->CsServerSockAddr.lpSockaddr,
                           ClientSession->CsServerSockAddr.iSockaddrLength );

            SockAddresses = &OneSockAddress;
            SockAddressCount = 1;
        }

        if ( DiscoveryFlags & CS_DISCOVERY_USE_MAILSLOT ) {
            InternalFlags |= DS_PING_USING_MAILSLOT;
        }
    }

    //
    // Determine the Account type we're looking for.
    //

    InternalFlags |= DS_IS_TRUSTED_DOMAIN;
    switch ( ClientSession->CsSecureChannelType ) {
    case WorkstationSecureChannel:
        AllowableAccountControlBits = USER_WORKSTATION_TRUST_ACCOUNT;
        InternalFlags |= DS_IS_PRIMARY_DOMAIN;
        break;

    case TrustedDomainSecureChannel:
        AllowableAccountControlBits = USER_INTERDOMAIN_TRUST_ACCOUNT;
        break;

    case TrustedDnsDomainSecureChannel:
        AllowableAccountControlBits = USER_DNS_DOMAIN_TRUST_ACCOUNT;
        break;

    case ServerSecureChannel:
        AllowableAccountControlBits = USER_SERVER_TRUST_ACCOUNT;
        Flags |= DS_PDC_REQUIRED;
        InternalFlags |= DS_IS_PRIMARY_DOMAIN;
        break;

    default:
        NlPrintCs(( NL_CRITICAL, ClientSession,
                  "NlPingDcName: invalid SecureChannelType %ld\n",
                  ClientSession->CsSecureChannelType ));
        NetStatus = ERROR_NO_LOGON_SERVERS;
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
        goto Cleanup;
    }

    //
    // Indicate whether IP transport is required
    //

    if ( RequireIp ) {
        Flags |= DS_IP_REQUIRED;
    }

    //
    // Initialize the ping context.
    //

    TriedContextInitialization = TRUE;
    NetStatus = NetpDcInitializeContext(
                    ClientSession->CsDomainInfo,    // SendDatagramContext
                    ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
#ifdef DONT_REQUIRE_MACHINE_ACCOUNT // useful for number of trust testing
                    NULL,
#else // DONT_REQUIRE_MACHINE_ACCOUNT
                    DoPingWithAccount ?  // Specify the account name as directed
                        ClientSession->CsAccountName :
                        NULL,
#endif // DONT_REQUIRE_MACHINE_ACCOUNT
                    DoPingWithAccount ?  // Specify the account control bits as directed
                        AllowableAccountControlBits :
                        0,
                    ClientSession->CsNetbiosDomainName.Buffer,
                    ClientSession->CsDnsDomainName.Buffer,
                    CapturedDnsForestName,
                    ClientSession->CsDomainId,
                    ClientSession->CsDomainGuid,
                    NULL,
                    DcName == NULL ?
                        LocalDcName+2 :  // Skip '\\' in the DC name
                        LocalDcName,     //   captured from the client session
                    SockAddresses,
                    SockAddressCount,
                    Flags,
                    InternalFlags,
                    NL_GETDC_CONTEXT_INITIALIZE_FLAGS | NL_GETDC_CONTEXT_INITIALIZE_PING,
                    &Context );

    if ( NetStatus != NO_ERROR ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlPingDcName: Cannot NetpDcInitializeContext 0x%lx\n",
                    NetStatus ));
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
        goto Cleanup;
    }
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );


    //
    // Ping the DC and get a response from it
    //
    // If we ping using a cached IP address, it's possible that server's
    //  IP address changed. For this case, if we fail to ping the server
    //  on the first try, we will refresh the address by querying DNS
    //  and then we will retry to ping the server.
    //

    for ( LoopIndex = 0; LoopIndex < 2; LoopIndex++ ) {
        NET_API_STATUS TmpNetStatus;
        ULONG TmpSockAddressCount = 0;
        ULONG Index;

        if ( LocalNlDcCacheEntry != NULL ) {
            NetpDcDerefCacheEntry( LocalNlDcCacheEntry );
            LocalNlDcCacheEntry = NULL;
        }

        NetStatus = NlPingDcNameWithContext(
                       &Context,
                       MAX_DC_RETRIES,    // send 2 pings
                       TRUE,              // wait for response
                       (NL_DC_MAX_TIMEOUT + NlGlobalParameters.ExpectedDialupDelay*1000),  // timeout
                       NULL,              // Don't care which domain name matched
                       &LocalNlDcCacheEntry );

        //
        // If we pinged successfully or
        //  we got hard error or
        //  we didn't do LDAP pings or
        //  we already did DNS queries because DC name was passed or
        //  this is the second attempt to ping the DC,
        //
        //  we are done
        //
        if ( NetStatus == NO_ERROR ||
             NetStatus == ERROR_NOT_ENOUGH_MEMORY ||
             SockAddresses == NULL ||
             DcName != NULL ||
             LoopIndex == 1 ) {

            break;
        }

        //
        // Attempt to get fresh DNS records
        //
        TmpNetStatus = DnsQuery_W( LocalDcName+2, // Skip '\\' in the DC name
                                   DNS_TYPE_A,
                                   0,
                                   NULL,          // No list of DNS servers
                                   &DnsRecords,
                                   NULL );

        //
        // Bail on error
        //
        if ( TmpNetStatus != NO_ERROR ) {
            break;
        }

        //
        // Process fresh DNS records
        //
        TmpNetStatus = NetpSrvProcessARecords( DnsRecords,
                                               NULL,
                                               0,  // force port to be zero
                                               &TmpSockAddressCount,
                                               &AllocatedSockAddresses );
        //
        // Bail on error
        //
        if ( TmpNetStatus != NO_ERROR || TmpSockAddressCount == 0 ) {
            break;
        }

        //
        // Check if there are new addresses we didn't try
        //
        SockAddressCount = 0;
        for ( Index = 0; Index < TmpSockAddressCount; Index++ ) {

            //
            // Keep this entry if it's not the one we had
            //
            if ( AllocatedSockAddresses[Index].iSockaddrLength != OneSockAddress.iSockaddrLength ||
                 !RtlEqualMemory(AllocatedSockAddresses[Index].lpSockaddr,
                                 OneSockAddress.lpSockaddr,
                                 OneSockAddress.iSockaddrLength) ) {

                AllocatedSockAddresses[SockAddressCount] = AllocatedSockAddresses[Index];
                SockAddressCount ++;
            }
        }

        //
        // Bail if we didn't get any new addresses
        //
        if ( SockAddressCount == 0 ) {
            break;
        }

        //
        // We have new addresses. Free the current
        //  address list and add the new addresses
        //
        NetpDcFreeAddressList( &Context );
        TmpNetStatus = NetpDcProcessAddressList( &Context,
                                              LocalDcName+2,
                                              AllocatedSockAddresses,
                                              SockAddressCount,
                                              FALSE,  // Don't know if site specific
                                              NULL );

        //
        // Bail on error. Otherwise, retry pinging
        //  given the new addresses.
        //
        if ( TmpNetStatus != NO_ERROR ) {
            break;
        }

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlPingDcName: Retry DC ping for %lu new addresses\n",
                    SockAddressCount ));
    }

    //
    // Cache this DC if asked
    //

    if ( NetStatus == NO_ERROR && CachePingedDc ) {

        //
        // Set the FORCE flag so that the old entry (if any) gets replaced
        //
        Context.QueriedFlags |= DS_FORCE_REDISCOVERY;
        NetpDcInsertCacheEntry( &Context, LocalNlDcCacheEntry );

        NlPrintCs(( NL_MISC, ClientSession,
                    "NlPingDcName: %ws: %ws: Caching pinged DC info for %ws\n",
                    Context.NlDcDomainEntry->UnicodeNetbiosDomainName,
                    Context.NlDcDomainEntry->UnicodeDnsDomainName,
                    LocalDcName ));
    }

    //
    // Refresh the client session, if asked
    //

    if ( NetStatus == NO_ERROR && RefreshClientSession ) {
        NetStatus = NlSetServerClientSession(
                            ClientSession,
                            LocalNlDcCacheEntry,
                            DoPingWithAccount, // was discovery with account?
                            TRUE );            // session refresh
    }

    //
    // Return the cache entry
    //

    if ( NetStatus == NO_ERROR && NlDcCacheEntry != NULL ) {
        *NlDcCacheEntry = LocalNlDcCacheEntry;
        LocalNlDcCacheEntry = NULL;
    }

Cleanup:

    if ( DnsRecords != NULL ) {
        DnsRecordListFree( DnsRecords, DnsFreeRecordListDeep );
    }

    if ( AllocatedSockAddresses != NULL ) {
        LocalFree( AllocatedSockAddresses );
    }

    if ( DcName == NULL && LocalDcName != NULL ) {
        NetApiBufferFree( LocalDcName );
    }

    if ( TriedContextInitialization ) {
        NetpDcUninitializeContext( &Context );
    }

    if ( LocalNlDcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( LocalNlDcCacheEntry );
    }

    if ( CapturedDnsForestName != NULL ) {
        LocalFree( CapturedDnsForestName );
    }

    return NetStatus;
}


NTSTATUS
NlGetAnyDCName (
    IN  PCLIENT_SESSION ClientSession,
    IN  BOOL RequireIp,
    IN  BOOL EnsureDcHasOurAccount,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry,
    OUT PBOOLEAN DcRediscovered
    )

/*++

Routine Description:

    Get the name of the any domain controller for a trusted domain.

    The domain controller found in guaranteed to have be up at one point during
    this API call.  The machine is also guaranteed to be a DC in the domain
    specified.

    The caller of this routine should not have any locks held (it calls the
    LSA back in several instances).  This routine may take some time to execute.

    The caller must be a writer of the ClientSession.

Arguments:

    ClientSession - Structure describing the session to the domain whose
        DC is to be returned.

    RequireIp - TRUE if communication with the DC must be done using only
        IP enabled transports.

    EnsureDcHasOurAccount - If TRUE this routine will verify that the returned
        DC has an account for this machine.

    NlDcCacheEntry - Returns the data structure describing response received
        from the server. Should be freed by calling NetpDcDerefCacheEntry

    DcRediscovered - Returns whether a new DC has been discovered

Return Value:

    STATUS_SUCCESS - Success.  Buffer contains DC name prefixed by \\.

    STATUS_NO_LOGON_SERVERS - No DC could be found

    STATUS_NO_SUCH_DOMAIN - The specified domain is not a trusted domain.

    STATUS_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken.

    STATUS_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken.

    STATUS_DOMAIN_TRUST_INCONSISTENT - The server that responded is not a proper
        domain controller of the specified domain.


--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    BOOLEAN DiscoveryDone = FALSE;
    PNL_DC_CACHE_ENTRY NlLocalDcCacheEntry = NULL;

    //
    // Don't give up unless we've done discovery.
    //

    do {

        //
        // If we don't currently know the name of the server,
        //  discover one.
        //

        if ( ClientSession->CsState == CS_IDLE ) {

            //
            // If we've tried to authenticate recently,
            //  don't bother trying again.
            //

            if ( !NlTimeToReauthenticate( ClientSession ) ) {
                Status = ClientSession->CsConnectionStatus;
                goto Cleanup;

            }

            Status = NlDiscoverDc( ClientSession,
                                   DT_Synchronous,
                                   FALSE,
                                   EnsureDcHasOurAccount ?
                                      TRUE :
                                      FALSE );

            if ( !NT_SUCCESS(Status) ) {

                NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlGetAnyDCName: Discovery failed %lx\n",
                    Status ));
                goto Cleanup;
            }

            DiscoveryDone = TRUE;

        }

        //
        // Try multiple times to get a response from the DC using the appropriate protocol.
        //

        if ( NlLocalDcCacheEntry != NULL ) {
            NetpDcDerefCacheEntry( NlLocalDcCacheEntry );
            NlLocalDcCacheEntry = NULL;
        }

        NetStatus = NlPingDcName( ClientSession,
                                  0,              // Use ping mechanism specified in ClientSession
                                  FALSE,          // Don't cache this DC (it is already cached)
                                  RequireIp,      // Require IP as the caller said
                                  EnsureDcHasOurAccount,
                                  TRUE,           // Refresh the session since we are the writer
                                  NULL,           // Ping the server specified in ClientSession
                                  &NlLocalDcCacheEntry );

        //
        // If we couldn't ping the DC when IP was required, see if we can ping it at all.
        //  If we can't ping it at all, this DC is dead, so drop it. Otherwise, the DC is
        //  alive (so we won't drop it), but the caller is out of luck.
        //

        if ( NetStatus == ERROR_NO_LOGON_SERVERS && RequireIp ) {
            NET_API_STATUS TmpNetStatus;

            TmpNetStatus = NlPingDcName( ClientSession,
                                      0,              // Use ping mechanism specified in ClientSession
                                      FALSE,          // Don't cache this DC (it is already cached)
                                      FALSE,          // Do not require IP
                                      FALSE,          // Don't specify account name
                                      TRUE,           // Refresh the session since we are the writer
                                      NULL,           // Ping the server specified in ClientSession
                                      NULL );         // No cache entry needed

            //
            // Don't drop this DC if it's alive
            //
            if ( TmpNetStatus == NO_ERROR ) {
                NlPrintCs(( NL_CRITICAL,  ClientSession,
                            "NlGetAnyDCName: IP is required but only non-IP is available for %ws\n",
                            ClientSession->CsUncServerName ));
                Status = STATUS_NO_LOGON_SERVERS;
                goto Cleanup;
            }

            //
            // Drop through and re-discover a new DC
            //
        }

        if ( NetStatus == NO_ERROR ) {
            Status = STATUS_SUCCESS;
            goto Cleanup;
        } else {
            NlPrintCs(( NL_CRITICAL,  ClientSession,
                        "NlGetAnyDCName: Can't ping the DC %ws 0x%lx.\n",
                        ClientSession->CsUncServerName, NetStatus ));
        }

        //
        // Drop the secure channel to force the next iteration to discover
        //  a new dc
        //

        if ( !DiscoveryDone ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlGetAnyDCName: Current DC '%ws' no longer available. (rediscover)\n",
                    ClientSession->CsUncServerName ));
            NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );
        }

    } while ( !DiscoveryDone );

    Status = STATUS_NO_LOGON_SERVERS;
    NlPrintCs(( NL_CRITICAL,  ClientSession, "NlGetAnyDCName: Failed\n" ));

    //
    // Free any locally used resources.
    //
Cleanup:

    //
    // Don't divulge too much to the caller.
    //

    if ( Status == STATUS_ACCESS_DENIED ) {
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
    }

    //
    // Return the DC info to the caller.
    //

    if ( Status == STATUS_SUCCESS ) {
        *NlDcCacheEntry = NlLocalDcCacheEntry;
        if ( DcRediscovered != NULL ) {
            *DcRediscovered = DiscoveryDone;
        }
    } else if ( NlLocalDcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( NlLocalDcCacheEntry );
    }

    return Status;
}


NET_API_STATUS
NetrGetAnyDCName (
    IN  LPWSTR   ServerName OPTIONAL,
    IN  LPWSTR   DomainName OPTIONAL,
    OUT LPWSTR  *Buffer
    )

/*++

Routine Description:

    Get the name of the any domain controller for a trusted domain.

    The domain controller found in guaranteed to have be up at one point during
    this API call.

Arguments:

    ServerName - name of remote server (null for local)

    DomainName - name of domain (null for primary domain)

    Buffer - Returns a pointer to an allcated buffer containing the
        servername of a DC of the domain.  The server name is prefixed
        by \\.  The buffer should be deallocated using NetApiBufferFree.

Return Value:

    ERROR_SUCCESS - Success.  Buffer contains DC name prefixed by \\.

    ERROR_NO_LOGON_SERVERS - No DC could be found

    ERROR_NO_SUCH_DOMAIN - The specified domain is not a trusted domain.

    ERROR_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken.

    ERROR_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken.

    ERROR_DOMAIN_TRUST_INCONSISTENT - The server that responded is not a proper
        domain controller of the specified domain.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    LPWSTR TmpUncServerName = NULL;

    UNICODE_STRING DomainNameString;

    PDOMAIN_INFO DomainInfo = NULL;
    PCLIENT_SESSION ClientSession = NULL;
    PNL_DC_CACHE_ENTRY NlDcCacheEntry = NULL;
    BOOL AmWriter = FALSE;

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ServerName );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }

    //
    // Fill in the primary domain name if the caller didn't specify one.
    //

    if ( DomainName == NULL || *DomainName == L'\0' ) {
        RtlInitUnicodeString( &DomainNameString, DomainInfo->DomUnicodeDomainName );
    } else {
        RtlInitUnicodeString( &DomainNameString, DomainName );
    }

    //
    // On the PDC or BDC,
    //  find the Client session for the domain.
    // On workstations,
    //  find the primary domain client session.
    //

    ClientSession = NlFindNamedClientSession( DomainInfo,
                                              &DomainNameString,
                                              NL_DIRECT_TRUST_REQUIRED,
                                              NULL );

    if ( ClientSession == NULL ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "NetrGetAnyDCName: %ws: No such trusted domain\n",
                     DomainName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Become a writer of the client session.
    //

    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintCs((NL_CRITICAL,  ClientSession,
                 "NetrGetAnyDCName: Can't become writer of client session.\n"));
        NetStatus = ERROR_NO_LOGON_SERVERS;
        goto Cleanup;
    }
    AmWriter = TRUE;

    //
    // Call the internal routine to do the actual work.
    //
    // Ensure that the responding DC has our account as required by this API
    //

    Status = NlGetAnyDCName( ClientSession,
                             FALSE,  // IP is not required
                             TRUE,   // Do with-account discovery
                             &NlDcCacheEntry,
                             NULL ); // don't care if the DC was rediscovered

    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Prefer Netbios DC name for this old API
    //

    if ( NlDcCacheEntry->UnicodeNetbiosDcName != NULL ) {
        NetStatus = NetApiBufferAllocate(
                        (wcslen(NlDcCacheEntry->UnicodeNetbiosDcName) + 3) * sizeof(WCHAR),
                        &TmpUncServerName );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }
        wcscpy( TmpUncServerName, L"\\\\" );
        wcscpy( TmpUncServerName+2, NlDcCacheEntry->UnicodeNetbiosDcName );
    } else {
        NetStatus = NetApiBufferAllocate(
                        (wcslen(NlDcCacheEntry->UnicodeDnsHostName) + 3) * sizeof(WCHAR),
                        &TmpUncServerName );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }
        wcscpy( TmpUncServerName, L"\\\\" );
        wcscpy( TmpUncServerName+2, NlDcCacheEntry->UnicodeDnsHostName );
    }

    *Buffer = TmpUncServerName;
    NetStatus = NERR_Success;

Cleanup:

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    if ( ClientSession != NULL ) {
        if ( AmWriter ) {
            NlResetWriterClientSession( ClientSession );
        }
        NlUnrefClientSession( ClientSession );
    }

    if ( NlDcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( NlDcCacheEntry );
    }

    return NetStatus;
}



BOOLEAN
NlAllocOneDomainInfo(
    IN LPWSTR DomainName OPTIONAL,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN LPWSTR DnsForestName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    OUT PNETLOGON_ONE_DOMAIN_INFO OneDomainInfo
    )
/*++

Routine Description:

    This function fill in a NETLOGON_ONE_DOMAIN_INFO structure suitable for
    returning from an RPC server routine.

Arguments:

    Sundry parameters to fill in.

    OneDomainInfo - Pointer to an already allocated structure to fill in.

Return Value:

    TRUE - success
    FALSE - couldn't allocate memory

--*/
{
    IN ULONG DomainSidSize;

    // Copy Netbios Domainname
    if ( !NlAllocStringFromWStr(
                DomainName,
                &OneDomainInfo->DomainName ) ) {
        return FALSE;
    }

    // Copy DNS domain name
    if ( !NlAllocStringFromWStr(
                DnsDomainName,
                &OneDomainInfo->DnsDomainName ) ) {
        return FALSE;
    }

    // Copy DNS tree name
    if ( !NlAllocStringFromWStr(
                DnsForestName,
                &OneDomainInfo->DnsForestName ) ) {
        return FALSE;
    }

    // Copy Domain GUID
    if ( DomainGuid != NULL ) {
        OneDomainInfo->DomainGuid = *DomainGuid;
    }

    // Copy DomainSid
    if ( DomainSid != NULL ) {
        DomainSidSize = RtlLengthSid( DomainSid );
        OneDomainInfo->DomainSid = MIDL_user_allocate( DomainSidSize );
        if ( OneDomainInfo->DomainSid == NULL ) {
            return FALSE;
        }
        RtlCopyMemory( OneDomainInfo->DomainSid, DomainSid, DomainSidSize );
    }

    return TRUE;
}



VOID
NlFreeOneDomainInfo(
    IN PNETLOGON_ONE_DOMAIN_INFO OneDomainInfo
    )
/*++

Routine Description:

    This function free all buffers allocated from a NETLOGON_ONE_DOMAIN_INFO structure

Arguments:

    OneDomainInfo - Pointer to an already allocated structure to fill in.

Return Value:

    None.

--*/
{
    if ( OneDomainInfo->DomainName.Buffer != NULL ) {
        MIDL_user_free( OneDomainInfo->DomainName.Buffer );
    }
    if ( OneDomainInfo->DnsDomainName.Buffer != NULL ) {
        MIDL_user_free( OneDomainInfo->DnsDomainName.Buffer );
    }
    if ( OneDomainInfo->DnsForestName.Buffer != NULL ) {
        MIDL_user_free( OneDomainInfo->DnsForestName.Buffer );
    }
    if ( OneDomainInfo->TrustExtension.Buffer != NULL ) {
        MIDL_user_free( OneDomainInfo->TrustExtension.Buffer );
    }
    if ( OneDomainInfo->DomainSid != NULL ) {
        MIDL_user_free( OneDomainInfo->DomainSid );
    }
    return;
}

NTSTATUS
NetrLogonDummyRoutine1(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD QueryLevel,
    OUT PNETLOGON_DUMMY1 Buffer
    )
/*++

Routine Description:

    This function is never called.

Arguments:


Return Value:


--*/
{
    return STATUS_NOT_IMPLEMENTED;
    UNREFERENCED_PARAMETER( ServerName );
    UNREFERENCED_PARAMETER( ComputerName );
    UNREFERENCED_PARAMETER( Authenticator );
    UNREFERENCED_PARAMETER( ReturnAuthenticator );
    UNREFERENCED_PARAMETER( QueryLevel );
    UNREFERENCED_PARAMETER( Buffer );
}



NTSTATUS
NetrLogonGetDomainInfo(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD QueryLevel,
    PNETLOGON_WORKSTATION_INFORMATION InBuffer,
    OUT PNETLOGON_DOMAIN_INFORMATION OutBuffer
    )
/*++

Routine Description:

    This function is used by an NT workstation to query information about the
    domain it is a member of.

Arguments:

    ServerName -- Name of the DC to retrieve the data from.

    ComputerName -- Name of the workstation making the call.

    Authenticator -- supplied by the workstation.

    ReturnAuthenticator -- Receives an authenticator returned by the DC.

    QueryLevel - Level of information to return from the DC. Valid values are:

        1: Return NETLOGON_DOMAIN_INFO structure.

    InBuffer - Buffer to pass to DC

    OutBuffer - Returns a pointer to an allocated buffer containing the queried
        information.


Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_ACCESS_DENIED -- The workstations should re-authenticate with
        the DC.

--*/
{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;

    PSERVER_SESSION ServerSession;
    SESSION_INFO SessionInfo;
    LM_OWF_PASSWORD OwfPassword;
    PNETLOGON_DOMAIN_INFO NetlogonDomainInfo = NULL;
    PNETLOGON_LSA_POLICY_INFO NetlogonLsaPolicyInfo = NULL;
    PNETLOGON_LSA_POLICY_INFO OutLsaPolicy = NULL;
    PNETLOGON_WORKSTATION_INFO InWorkstationInfo = NULL;

    ULONG i;
    ULONG ForestTrustListCount = 0;
    PULONG IndexInReturnedList = NULL;

    LPWSTR PreviousDnsHostName = NULL;

    BOOLEAN DomainLocked = FALSE;
    BOOLEAN ClientHandlesSpn = FALSE;
    BOOLEAN NeedBidirectionalTrust = FALSE;



    PLIST_ENTRY ListEntry;
    LPBYTE Where;


    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ServerName );

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrLogonGetDomainInfo: %ws %ld Entered\n",
            ComputerName,
            QueryLevel ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the Session key for this session.
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    SessionInfo.SessionKey = ServerSession->SsSessionKey;
    SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;

    //
    // now verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator( ServerSession,
                                   Authenticator,
                                   ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        goto Cleanup;
    }

    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

    //
    // Ensure we support the query level specified.
    //

    switch ( QueryLevel ) {
    case NETLOGON_QUERY_DOMAIN_INFO:

        //
        // Determine the size of the buffer to allocate.
        //

        EnterCriticalSection( &NlGlobalDomainCritSect );
        LOCK_TRUST_LIST( DomainInfo );
        DomainLocked = TRUE;

        //
        // Allocate the buffer to return.
        //

        NetlogonDomainInfo = MIDL_user_allocate( sizeof(*NetlogonDomainInfo) );

        if ( NetlogonDomainInfo == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlZeroMemory( NetlogonDomainInfo, sizeof(*NetlogonDomainInfo) );

        //
        // Tell the caller the common set of bits we support
        //

        NetlogonDomainInfo->WorkstationFlags =
            InBuffer->WorkstationInfo->WorkstationFlags &
            NL_GET_DOMAIN_INFO_SUPPORTED;
        ClientHandlesSpn =
            (NetlogonDomainInfo->WorkstationFlags & NL_CLIENT_HANDLES_SPN) != 0;
        NeedBidirectionalTrust =
            (NetlogonDomainInfo->WorkstationFlags & NL_NEED_BIDIRECTIONAL_TRUSTS) != 0;


        //
        // Copy the information into the buffer.
        //
        // Copy the description of the primary domain.
        //
        EnterCriticalSection( &NlGlobalDnsForestNameCritSect );
        if ( !NlAllocOneDomainInfo(
                DomainInfo->DomUnicodeDomainNameString.Buffer,
                DomainInfo->DomUnicodeDnsDomainNameString.Buffer,
                NlGlobalUnicodeDnsForestName,
                &DomainInfo->DomDomainGuidBuffer,
                DomainInfo->DomAccountDomainId,
                &NetlogonDomainInfo->PrimaryDomain ) ) {

            LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );

        //
        // Determine the length of the forest trust list to return
        //

        ForestTrustListCount = DomainInfo->DomForestTrustListCount;

        //
        // Check if need to exclude directly trusting domains
        //

        if ( !NeedBidirectionalTrust ) {
            ULONG Index;
            for ( Index=0; Index<DomainInfo->DomForestTrustListCount; Index++ ) {
                if ( (DomainInfo->DomForestTrustList[Index].Flags &
                     (DS_DOMAIN_PRIMARY|DS_DOMAIN_IN_FOREST|DS_DOMAIN_DIRECT_OUTBOUND)) == 0 ) {
                    ForestTrustListCount--;
                }
            }
        }

        //
        // Copy trusted domain info
        //
        if ( ForestTrustListCount != 0 ) {
            PNETLOGON_ONE_DOMAIN_INFO TrustedDomainInfo;
            ULONG Index;
            ULONG ReturnedEntryIndex = 0;

            //
            // If need to exclude directly trusting domains,
            // allocate an array of ULONGs that will be used to keep track of the
            // index of a trust entry in the returned list.  This is needed to
            // corectly set ParentIndex for entries returned.
            //
            if ( !NeedBidirectionalTrust ) {
                IndexInReturnedList = LocalAlloc( LMEM_ZEROINIT,
                                            DomainInfo->DomForestTrustListCount * sizeof(ULONG) );

                if ( IndexInReturnedList == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }
            }

            //
            // Allocate a buffer for the trusted domain info.
            //
            NetlogonDomainInfo->TrustedDomains =
               MIDL_user_allocate( sizeof(NETLOGON_ONE_DOMAIN_INFO) * ForestTrustListCount );

            if ( NetlogonDomainInfo->TrustedDomains == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlZeroMemory( NetlogonDomainInfo->TrustedDomains,
                           sizeof(NETLOGON_ONE_DOMAIN_INFO) * ForestTrustListCount );

            TrustedDomainInfo = NetlogonDomainInfo->TrustedDomains;
            NetlogonDomainInfo->TrustedDomainCount = ForestTrustListCount;


            for ( Index=0; Index<DomainInfo->DomForestTrustListCount; Index++ ) {

                PNL_TRUST_EXTENSION TrustExtension;

                //
                // Skip this entry if need to exclude directly trusting domains.
                // Otherwise, remember the index of this entry in the returned list.
                //

                if ( !NeedBidirectionalTrust ) {

                    if ( (DomainInfo->DomForestTrustList[Index].Flags &
                         (DS_DOMAIN_PRIMARY|DS_DOMAIN_IN_FOREST|DS_DOMAIN_DIRECT_OUTBOUND)) == 0 ) {
                        continue;
                    } else {
                        IndexInReturnedList[Index] = ReturnedEntryIndex;
                    }

                }

                //
                // Fill in the fixed length data
                //

                TrustExtension = MIDL_user_allocate( sizeof(NL_TRUST_EXTENSION) );

                if ( TrustExtension == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                TrustExtension->Flags = DomainInfo->DomForestTrustList[Index].Flags;

                //
                // If this is a primary domain entry, determine whether it runs
                // in native or mixed mode
                //
                if ( (DomainInfo->DomForestTrustList[Index].Flags & DS_DOMAIN_PRIMARY) &&
                     !SamIMixedDomain( DomainInfo->DomSamServerHandle ) ) {
                    TrustExtension->Flags |= DS_DOMAIN_NATIVE_MODE;
                }

                //
                // Do not leak the new DS_DOMAIN_DIRECT_INBOUND bit to an old client;
                // it can get confused otherwise.  The new DS_DOMAIN_DIRECT_OUTBOUND
                // bit is just the renamed old DS_DOMAIN_DIRECT_TRUST, so leave it alone.
                //
                if ( !NeedBidirectionalTrust ) {
                    TrustExtension->Flags &= ~DS_DOMAIN_DIRECT_INBOUND;
                }

                TrustExtension->ParentIndex = DomainInfo->DomForestTrustList[Index].ParentIndex;
                TrustExtension->TrustType = DomainInfo->DomForestTrustList[Index].TrustType;
                TrustExtension->TrustAttributes = DomainInfo->DomForestTrustList[Index].TrustAttributes;

                TrustedDomainInfo->TrustExtension.Buffer = (LPWSTR)TrustExtension;
                TrustedDomainInfo->TrustExtension.MaximumLength =
                    TrustedDomainInfo->TrustExtension.Length = sizeof(NL_TRUST_EXTENSION);


                // Copy the description of the primary domain.
                if ( !NlAllocOneDomainInfo(
                        DomainInfo->DomForestTrustList[Index].NetbiosDomainName,
                        DomainInfo->DomForestTrustList[Index].DnsDomainName,
                        NULL, // DNS Tree name not meaningfull
                        &DomainInfo->DomForestTrustList[Index].DomainGuid,
                        DomainInfo->DomForestTrustList[Index].DomainSid,
                        TrustedDomainInfo ) ) {

                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                // Move on to the next trusted domain.
                TrustedDomainInfo ++;
                ReturnedEntryIndex ++;

            }

            //
            // Fix ParentIndex.  If need to exclude directly trusting domains,
            // adjust the index to point to the appropriate entry in the
            // returned list.  Otherwise, leave it alone.
            //

            if ( !NeedBidirectionalTrust ) {
                PNL_TRUST_EXTENSION TrustExtension;
                TrustedDomainInfo = NetlogonDomainInfo->TrustedDomains;
                for ( Index=0; Index<ForestTrustListCount; Index++ ) {
                    TrustExtension = (PNL_TRUST_EXTENSION)TrustedDomainInfo->TrustExtension.Buffer;
                    if ( (TrustExtension->Flags & DS_DOMAIN_IN_FOREST) != 0 &&
                         (TrustExtension->Flags & DS_DOMAIN_TREE_ROOT) == 0 ) {
                        TrustExtension->ParentIndex =
                            IndexInReturnedList[TrustExtension->ParentIndex];
                    }
                    TrustedDomainInfo ++;
                }
            }

        }

        //
        // Indicate that the LSA policy should be handled.
        //

        InWorkstationInfo = InBuffer->WorkstationInfo;

        OutLsaPolicy = &NetlogonDomainInfo->LsaPolicy;
        break;

    case NETLOGON_QUERY_LSA_POLICY_INFO:

        //
        // Allocate the buffer to return.
        //

        NetlogonLsaPolicyInfo = MIDL_user_allocate( sizeof(*NetlogonLsaPolicyInfo) );

        if ( NetlogonLsaPolicyInfo == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Indicate that the LSA policy should be handled.
        //

        InWorkstationInfo = InBuffer->WorkstationInfo;
        OutLsaPolicy = NetlogonLsaPolicyInfo;
        break;

    default:
        Status = STATUS_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // If we're passing LSA policy back and forth between workstation/DC,
    //  handle the next leg.
    //

    if ( InWorkstationInfo != NULL ) {
        OSVERSIONINFOEXW OsVersionInfoEx;
        POSVERSIONINFOEXW OsVersionInfoExPtr = NULL;
        LPWSTR OsName;
        LPWSTR AllocatedOsName = NULL;

        //
        // See if the caller passed the OS version to us.
        //

        if ( InWorkstationInfo->OsVersion.Length >= sizeof(OsVersionInfoEx) ) {
            //
            // Copy the version to get the alignment right
            //  (since RPC thinks this is a WCHAR buffer).
            //

            RtlCopyMemory( &OsVersionInfoEx,
                           InWorkstationInfo->OsVersion.Buffer,
                           sizeof(OsVersionInfoEx) );

            OsVersionInfoExPtr = &OsVersionInfoEx;

            NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                    "NetrLogonGetDomainInfo: %ws is running NT %ld.%ld build %ld (%ld)\n",
                    ComputerName,
                    OsVersionInfoEx.dwMajorVersion,
                    OsVersionInfoEx.dwMinorVersion,
                    OsVersionInfoEx.dwBuildNumber,
                    OsVersionInfoEx.wProductType ));
        }

        //
        // See if the caller passed us an OsName.
        //

        if ( InWorkstationInfo->OsName.Length ) {
            AllocatedOsName = LocalAlloc( 0, InWorkstationInfo->OsName.Length + sizeof(WCHAR));

            if ( AllocatedOsName == NULL) {
                OsName = L"Windows 2000";
            } else {
                RtlCopyMemory( AllocatedOsName,
                               InWorkstationInfo->OsName.Buffer,
                               InWorkstationInfo->OsName.Length );
                AllocatedOsName[InWorkstationInfo->OsName.Length/sizeof(WCHAR)] = L'\0';
                OsName = AllocatedOsName;
            }


        //
        // If the caller didn't pass us its OsName,
        //  make one up.
        //  (Only pre RTM versions of WIN 2000 did this.)
        //
        } else {
            if ( OsVersionInfoExPtr == NULL ) {
                OsName = L"Windows 2000";
            } else {
                if ( OsVersionInfoExPtr->wProductType == VER_NT_WORKSTATION ) {
                    OsName = L"Windows 2000 Professional";
                } else {
                    OsName = L"Windows 2000 Server";
                }
            }
        }


        //
        // Set the DnsHostName on the computer object.
        //  If the client handles SPN setting, get the DnsHostName from the DS
        //  rather than setting it.
        //
        Status = LsaISetClientDnsHostName(
                    ComputerName,
                    ClientHandlesSpn ? NULL : InWorkstationInfo->DnsHostName,
                    OsVersionInfoExPtr,
                    OsName,
                    ClientHandlesSpn ? &PreviousDnsHostName : NULL );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NetrLogonGetDomainInfo: Cannot set client DNS host name %lx (ignoring)\n",
                    Status ));
            PreviousDnsHostName = NULL;
            // This isn't fatal
        }

        NlPrintDom((NL_MISC, DomainInfo,
                "NetrLogonGetDomainInfo: DnsHostName of %ws is %ws\n",
                ComputerName,
                PreviousDnsHostName ));

        if ( AllocatedOsName != NULL) {
            LocalFree( AllocatedOsName );
        }

        //
        // Set the HOST/name SPN on the object as well.  This
        // is handled mostly by the DS side of things.
        //

        if ( !ClientHandlesSpn ) {
            NlSetDsSPN( FALSE,  // Don't wait for this to complete
                        TRUE,   // Set the SPN
                        FALSE,  // We've already set the Dns host name
                        DomainInfo,
                        DomainInfo->DomUncUnicodeComputerName,
                        ComputerName,
                        InWorkstationInfo->DnsHostName );
        }

        //
        // Return the Previous DNS Host Name to the client
        //

        if ( NetlogonDomainInfo != NULL ) {
            RtlInitUnicodeString( &NetlogonDomainInfo->DnsHostNameInDs, PreviousDnsHostName );
            PreviousDnsHostName = NULL;
        }

        //
        // Tell the caller there is no policy to return
        //
        OutLsaPolicy->LsaPolicySize = 0;
        OutLsaPolicy->LsaPolicy = NULL;

    }



    Status = STATUS_SUCCESS;

    //
    // Common exit point
    //

Cleanup:

    //
    // If the request failed, be careful to not leak authentication
    // information.
    //

    if ( Status == STATUS_ACCESS_DENIED )  {
        RtlZeroMemory( ReturnAuthenticator, sizeof(*ReturnAuthenticator) );
    }


    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrLogonGetDomainInfo: %ws %ld Returns 0x%lX\n",
            ComputerName,
            QueryLevel,
            Status ));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    if ( IndexInReturnedList != NULL ) {
        LocalFree( IndexInReturnedList );
    }

    if ( PreviousDnsHostName != NULL ) {
        MIDL_user_free( PreviousDnsHostName );
    }

    if ( NT_SUCCESS(Status)) {
        if ( NetlogonDomainInfo != NULL ) {
            OutBuffer->DomainInfo = NetlogonDomainInfo;
        } else if ( NetlogonLsaPolicyInfo != NULL ) {
            OutBuffer->LsaPolicyInfo = NetlogonLsaPolicyInfo;
        }
    } else {

        if ( NetlogonDomainInfo != NULL ) {

            NlFreeOneDomainInfo( &NetlogonDomainInfo->PrimaryDomain );

            for ( i=0; i<NetlogonDomainInfo->TrustedDomainCount; i++ ) {
                NlFreeOneDomainInfo( &NetlogonDomainInfo->TrustedDomains[i] );
            }

            if ( NetlogonDomainInfo->LsaPolicy.LsaPolicy != NULL ) {
                MIDL_user_free( NetlogonDomainInfo->LsaPolicy.LsaPolicy );
            }

            MIDL_user_free( NetlogonDomainInfo );
        }

        if ( NetlogonLsaPolicyInfo != NULL ) {

            if ( NetlogonLsaPolicyInfo->LsaPolicy != NULL ) {
                MIDL_user_free( NetlogonLsaPolicyInfo->LsaPolicy );
            }

            MIDL_user_free( NetlogonLsaPolicyInfo );
        }
    }

    if ( DomainLocked ) {
        UNLOCK_TRUST_LIST( DomainInfo );
        LeaveCriticalSection( &NlGlobalDomainCritSect );
    }

    return Status;
}


NTSTATUS
NetrLogonSetServiceBits(
    IN LPWSTR ServerName,
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    )

/*++

Routine Description:

    Inidcates whether this DC is currently running the specified service.

    For instance,

        NetLogonSetServiceBits( DS_KDC_FLAG, DS_KDC_FLAG );

    tells Netlogon the KDC is running.  And

        NetLogonSetServiceBits( DS_KDC_FLAG, 0 );

    tells Netlogon the KDC is not running.

    This out of proc API can set only a certain set of bits:
        DS_TIMESERV_FLAG
        DS_GOOD_TIMESERV_FLAG

    If other bits are attempted to be set, access denied is returned.

Arguments:

    ServerName -- Name of the DC to retrieve the data from.

    ServiceBitsOfInterest - A mask of the service bits being changed, set,
        or reset by this call.  Only the following flags are valid:

            DS_KDC_FLAG
            DS_DS_FLAG
            DS_TIMESERV_FLAG
            DS_GOOD_TIMESERV_FLAG

    ServiceBits - A mask indicating what the bits specified by ServiceBitsOfInterest
        should be set to.


Return Value:

    STATUS_SUCCESS - Success.

    STATUS_ACCESS_DENIED - Caller does not have permission to call this API.

    STATUS_INVALID_PARAMETER - The parameters have extaneous bits set.

--*/
{
    NET_API_STATUS NetStatus;

    //
    // Out of proc callers can set only certain bits
    //

    if ( (ServiceBitsOfInterest & ~DS_OUTOFPROC_VALID_SERVICE_BITS) != 0 ) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,     // Security descriptor
            NETLOGON_SERVICE_ACCESS,                // Desired access
            &NlGlobalNetlogonInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {
        return STATUS_ACCESS_DENIED;
    }

    return I_NetLogonSetServiceBits( ServiceBitsOfInterest, ServiceBits );
    UNREFERENCED_PARAMETER( ServerName );
}


NET_API_STATUS
NlComputeMd5Digest(
    IN LPBYTE Message,
    IN ULONG MessageSize,
    IN PNT_OWF_PASSWORD OwfPassword,
    OUT CHAR MessageDigest[NL_DIGEST_SIZE]
    )

/*++

Routine Description:

    Compute the message digest for Message.

Arguments:

    Message - The message to compute the digest for.

    MessageSize - The size of Message in bytes.

    OwfPassword - Password of the account to used salt the digest

    MessageDigest - Returns the 128-bit digest of the message.

Return Value:

    NERR_Success: the operation was successful

    ERROR_NOT_SUPPORTED: MD5 is not supported on this machine.


--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    PCHECKSUM_FUNCTION Check;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    BOOL Initialized = FALSE;

    //
    // Locate the checksum routine for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCheckSum(KERB_CHECKSUM_MD5, &Check);
    if (!NT_SUCCESS(Status)) {
        NlPrint((NL_CRITICAL,
                "NlComputeMd5Digest: MD5 is not supported\n",
                DomainName ));
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Initialize
    //

    Status = Check->Initialize(0, &CheckBuffer);
    if (!NT_SUCCESS(Status)) {
        NlPrint((NL_CRITICAL,
                "NlComputeMd5Digest: cannot initialize MD5 0x%lx\n",
                Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }
    Initialized = TRUE;


    //
    // First compute the digest of the OWF
    //
    Status = Check->Sum( CheckBuffer, sizeof(*OwfPassword), (PUCHAR) OwfPassword );

    if (!NT_SUCCESS(Status)) {
        NlPrint((NL_CRITICAL,
                "NlComputeMd5Digest: cannot checksum OWF password 0x%lx\n",
                Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Then compute the digest of the message itself
    //
    Status = Check->Sum( CheckBuffer, MessageSize, Message );

    if (!NT_SUCCESS(Status)) {
        NlPrint((NL_CRITICAL,
                "NlComputeMd5Digest: cannot checksum message 0x%lx\n",
                Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Grab the digest.
    //

    if ( Check->CheckSumSize != NL_DIGEST_SIZE ) {
        NlPrint((NL_CRITICAL,
                "NlComputeMd5Digest: digest is the wrong size.\n" ));
        NetStatus = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    Status = Check->Finalize(CheckBuffer, MessageDigest);
    if (!NT_SUCCESS(Status)) {
        NlPrint((NL_CRITICAL,
                "NlComputeMd5Digest: cannot checksum message 0x%lx\n",
                Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Done.
    //

    NetStatus = NO_ERROR;
Cleanup:
    if ( Initialized ) {
        Status = Check->Finish(&CheckBuffer);
        if (!NT_SUCCESS(Status)) {
            NlPrint((NL_CRITICAL,
                    "NlComputeMd5Digest: cannot finish 0x%lx\n",
                    Status ));
        }
    }

    return NetStatus;
}




NET_API_STATUS
NetrLogonGetTrustRid(
        IN LPWSTR ServerName OPTIONAL,
        IN LPWSTR DomainName OPTIONAL,
        OUT PULONG Rid
    )

/*++

Routine Description:

    Returns the Rid of the account that ServerName uses in its secure channel to DomainName.

    Only an Admin or LocalSystem or LocalService may call this function.

Arguments:

    ServerName - The name of the remote server.

    DomainName - The name (DNS or Netbios) of the domain the trust is to.
        NULL implies the domain the machine is a member of.

    Rid - Rid is the RID of the account in the specified domain that represents the
        trust relationship between the ServerName and DomainName.


Return Value:

    NERR_Success: the operation was successful

    ERROR_NO_SUCH_DOMAIN: The specified domain does not exist.

    ERROR_NO_LOGON_SERVERS:  There are currently no logon server available for the domain or
        there is some problem with the secure channel.

    ERROR_NOT_SUPPORTED: The specified trusted domain does not support digesting.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    NTSTATUS Status = STATUS_SUCCESS;

    PCLIENT_SESSION ClientSession = NULL;
    PDOMAIN_INFO DomainInfo = NULL;
    UNICODE_STRING DomainNameString;
    BOOL AmWriter = FALSE;
    ULONG LocalRid = 0;

    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,     // Security descriptor
            NETLOGON_SERVICE_ACCESS,                // Desired access
            &NlGlobalNetlogonInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ServerName );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }


    //
    // On the PDC or BDC,
    //  find the Client session for the domain.
    // On workstations,
    //  find the primary domain client session.
    //

    if ( DomainName == NULL ) {
        DomainName = DomainInfo->DomUnicodeDomainName;
    }

    RtlInitUnicodeString( &DomainNameString, DomainName );
    ClientSession = NlFindNamedClientSession( DomainInfo,
                                              &DomainNameString,
                                              NL_DIRECT_TRUST_REQUIRED | NL_ROLE_PRIMARY_OK,
                                              NULL );

    if ( ClientSession == NULL ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonGetTrustRid: %ws: No such trusted domain\n",
                DomainName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Become a writer of the ClientSession.
    //

    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                 "NetrLogonGetTrustRid: Can't become writer of client session.\n" ));
        NetStatus = ERROR_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    AmWriter = TRUE;


    //
    // If this is a server secure channel (i.e. we are a DC and
    //  this is our domain) we can get the RID from local SAM
    //

    if ( ClientSession->CsSecureChannelType == ServerSecureChannel ) {
        ULONG AccountRid = 0;

        Status = NlSamOpenNamedUser( DomainInfo,
                                     ClientSession->CsAccountName,
                                     NULL,
                                     &AccountRid,
                                     NULL );

        //
        // Just stash it into the client session.
        //
        // Note that if we are a BDC, we also set RID during
        //  secure channel setup to our PDC, so whoever writes
        //  last is the winner. But hopefully the same value
        //  will be written in both cases.
        //
        if ( NT_SUCCESS(Status) ) {
            ClientSession->CsAccountRid = AccountRid;
        } else {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                         "NlUpdateRole: NlSamOpenNamedUser failed 0x%lx\n",
                         Status ));
        }

    //
    // For all other secure channel types, we have to
    //  get the RID as a side effect of setting up the
    //  secure channel. Note that we merely refresh RID
    //  here as we may already have it from a previous
    //  successful secure channel setup.
    //
    } else if ( ClientSession->CsState != CS_AUTHENTICATED &&
                NlTimeToReauthenticate(ClientSession) ) {

        //
        // Try to set up the channel.  If we can't
        //  don't error out, rather use RID that
        //  we got when on one of the previous attemps.
        //
        Status = NlSessionSetup( ClientSession );
    }

    //
    // Ensure that we return non-zero RID on success
    //

    LocalRid = ClientSession->CsAccountRid;

    if ( LocalRid != 0 ) {
        *Rid = LocalRid;
        NetStatus = NO_ERROR;
    } else {

        //
        // If the trust is not NT5, this call is not supported
        //
        if ( (ClientSession->CsFlags & CS_NT5_DOMAIN_TRUST) == 0 ) {
            NetStatus = ERROR_NOT_SUPPORTED;
        } else {
            NetStatus = ERROR_TRUSTED_RELATIONSHIP_FAILURE;
        }
    }

    //
    // Free any locally used resources.
    //
Cleanup:
    if ( AmWriter ) {
        NlResetWriterClientSession( ClientSession );
    }

    if ( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return NetStatus;
}


NET_API_STATUS
NetrLogonComputeServerDigest(
    IN LPWSTR ServerName OPTIONAL,
    IN ULONG Rid,
    IN LPBYTE Message,
    IN ULONG MessageSize,
    OUT CHAR NewMessageDigest[NL_DIGEST_SIZE],
    OUT CHAR OldMessageDigest[NL_DIGEST_SIZE]
    )
/*++

Routine Description:

    Compute the message digest for Message on the server.

    A digest is computed given the message and the password used on
    the account identified by teh account RID. Since there may be up
    to 2 passwords on the account (for interdomain trust), this routine
    returns 2 digets corresponding to the 2 passwords.  If the account
    has just one password on the server side (true for any account other
    than the intedomain trust account) or the two passwords are the same
    the 2 digests returned will be identical.

    Only an Admin or LocalSystem or LocalService may call this function.

Arguments:

    ServerName - The name of the remote server.

    Rid - The RID of the account to create the digest for.
        The RID must be the RID of a machine account or the API returns an error.

    Message - The message to compute the digest for.

    MessageSize - The size of Message in bytes.

    NewMessageDigest - Returns the 128-bit digest of the message corresponding to
        the new account password.

    OldMessageDigest - Returns the 128-bit digest of the message corresponding to
        the old account password.

Return Value:

    NERR_Success: the operation was successful

    ERROR_NOT_SUPPORTED: The specified trusted domain does not support digesting.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    PDOMAIN_INFO DomainInfo = NULL;
    PSID UserSid = NULL;
    UNICODE_STRING UserSidString;

    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL;
    SID_AND_ATTRIBUTES_LIST ReverseMembership;

    LPWSTR LocalUserName = NULL;
    NT_OWF_PASSWORD NewOwfPassword;
    NT_OWF_PASSWORD OldOwfPassword;
    ULONG AccountRid;
    ULONG LocalUserAccountControl;

    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,     // Security descriptor
            NETLOGON_SERVICE_ACCESS,                // Desired access
            &NlGlobalNetlogonInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {
        NlPrint((NL_CRITICAL,
                        "NetrLogonComputeServerDigest: Account %ld failed access check.\n",
                        Rid ));
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ServerName );

    if ( DomainInfo == NULL ) {
        NlPrint((NL_CRITICAL,
                        "NetrLogonComputeServerDigest: Account %ld: cannot find domain for %ws\n",
                        Rid,
                        ServerName ));
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }

    //
    // Convert the account RID to an account SID
    //

    NetStatus = NetpDomainIdToSid( DomainInfo->DomAccountDomainId,
                                   Rid,
                                   &UserSid );

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NetrLogonComputeServerDigest: Account %ld: cannot convert domain ID to sid.: %ld\n",
                        Rid,
                        NetStatus ));
        goto Cleanup;
    }



    //
    // Get the info about the user.
    //
    // Use SamIGetUserLogonInformation instead of SamrOpenUser.
    // The former is more efficient (since it only does one
    //  DirSearch and doesn't lock the global SAM lock) and more powerful
    //  (since it returns UserAllInformation).
    //

    UserSidString.Buffer = UserSid;
    UserSidString.MaximumLength =
        UserSidString.Length = (USHORT) RtlLengthSid( UserSid );

    Status = SamIGetUserLogonInformation(
                DomainInfo->DomSamAccountDomainHandle,
                SAM_NO_MEMBERSHIPS | // Don't need group memberships
                    SAM_OPEN_BY_SID, // Next parameter is the SID of the account
                &UserSidString,
                &UserAllInfo,
                &ReverseMembership,
                NULL );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "NetrLogonComputeServerDigest: Account %ld: Cannot SamIGetUserLogonInfo 0x%lx\n",
                     Rid,
                     Status ));
        if ( Status == STATUS_NOT_FOUND ||
             Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            NetStatus = ERROR_NO_SUCH_USER;
        } else {
            NetStatus = NetpNtStatusToApiStatus(Status);
        }
        goto Cleanup;
    }

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeServerDigest: %ld: %wZ: Message: ",
            Rid,
            &UserAllInfo->All.UserName ));
    NlpDumpBuffer(NL_ENCRYPT, Message, MessageSize );


    //
    // Ensure the account is a machine account.
    //

    if ( (UserAllInfo->All.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) == 0 ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NetrLogonComputeServerDigest: Account %ld isn't a machine account\n",
                        Rid ));
        NetStatus = ERROR_NO_SUCH_USER;
        goto Cleanup;
    }

    if ( UserAllInfo->All.UserAccountControl & USER_ACCOUNT_DISABLED ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonComputeServerDigest: Account %ld is disabled\n",
                Rid ));
        NetStatus = ERROR_NO_SUCH_USER;
        goto Cleanup;
    }

    //
    // Get the password(s) for the account. For interdomain trust
    //  trust account, get both current and previous passwords
    //

    LocalUserName = LocalAlloc( 0, UserAllInfo->All.UserName.Length + sizeof(WCHAR) );
    if ( LocalUserName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( LocalUserName,
                   UserAllInfo->All.UserName.Buffer,
                   UserAllInfo->All.UserName.Length );

    LocalUserName[ (UserAllInfo->All.UserName.Length)/sizeof(WCHAR) ] = UNICODE_NULL;

    //
    // NlGetIncomingPassword checks for the exact equality of the user account control
    //  to the trust account flags. Therefore pass only these flags if they are set in
    //  the data retuned from SAM.
    //
    LocalUserAccountControl = UserAllInfo->All.UserAccountControl;
    if ( UserAllInfo->All.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) {
        LocalUserAccountControl = USER_INTERDOMAIN_TRUST_ACCOUNT;
    }
    if ( UserAllInfo->All.UserAccountControl & USER_DNS_DOMAIN_TRUST_ACCOUNT ) {
        LocalUserAccountControl = USER_DNS_DOMAIN_TRUST_ACCOUNT;
    }

    Status = NlGetIncomingPassword(
                    DomainInfo,
                    LocalUserName,
                    NullSecureChannel, // The account control bits are passed next
                    LocalUserAccountControl,
                    TRUE,    // Fail for disabled accounts
                    &NewOwfPassword,
                    (UserAllInfo->All.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) ?
                        &OldOwfPassword :  // Get previous password for interdomain account
                        NULL,
                    &AccountRid,
                    NULL,    // Don't need trust attributes
                    NULL );  // Don't need the account type

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                "NetrLogonComputeServerDigest: Can't NlGetIncomingPassword for %wZ 0x%lx.\n",
                &UserAllInfo->All.UserName,
                Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    NlAssert( Rid == AccountRid );

    //
    // If there is no old password on the account,
    //  use the new one
    //

    if ( (UserAllInfo->All.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0 ) {
        RtlCopyMemory( &OldOwfPassword,
                       &NewOwfPassword,
                       sizeof(OldOwfPassword) );
    }

    //
    // Compute the new message digest.
    //

    NetStatus = NlComputeMd5Digest( Message, MessageSize, &NewOwfPassword, NewMessageDigest );
    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "NetrLogonComputeServerDigest: %ld: NlComputeMd5Digest failed (1): 0x%lx\n",
                  Rid, NetStatus ));
        goto Cleanup;
    }

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeServerDigest: %ld: New Password: ",
            Rid ));
    NlpDumpBuffer(NL_ENCRYPT, &NewOwfPassword, sizeof(NewOwfPassword) );

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeServerDigest: %ld: New Digest: ",
            Rid ));
    NlpDumpBuffer(NL_ENCRYPT, NewMessageDigest, sizeof(NewMessageDigest) );

    //
    // Compute the old message digest.
    //

    NetStatus = NlComputeMd5Digest( Message, MessageSize, &OldOwfPassword, OldMessageDigest );
    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "NetrLogonComputeServerDigest: %ld: NlComputeMd5Digest failed (2): 0x%lx\n",
                  Rid, NetStatus ));
        goto Cleanup;
    }

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeServerDigest: %ld: Old Password: ",
            Rid ));
    NlpDumpBuffer(NL_ENCRYPT, &OldOwfPassword, sizeof(OldOwfPassword) );

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeServerDigest: %ld: Old Digest: ",
            Rid ));
    NlpDumpBuffer(NL_ENCRYPT, OldMessageDigest, sizeof(OldMessageDigest) );

    //
    // Free any locally used resources.
    //
Cleanup:

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }
    if ( UserSid != NULL ) {
        NetpMemoryFree( UserSid );
    }
    if ( LocalUserName != NULL ) {
        LocalFree( LocalUserName );
    }

    if ( UserAllInfo != NULL ) {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    return NetStatus;
}


NET_API_STATUS
NetrLogonComputeClientDigest(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    IN LPBYTE Message,
    IN ULONG MessageSize,
    OUT CHAR NewMessageDigest[NL_DIGEST_SIZE],
    OUT CHAR OldMessageDigest[NL_DIGEST_SIZE]
    )
/*++

Routine Description:

    Compute the message digest for Message on the client.

    A digest is computed given the message and the password used on
    the account identified by the domain name. Since there are two
    passwords on the account on the client side, this routine
    returns 2 digests corresponding to the 2 passwords.  If the two
    passwords are the same the 2 digests returned will be identical.

    Only an Admin or LocalSystem or LocalService may call this function.

Arguments:

    ServerName - The name of the remote server.

    DomainName - The name (DNS or Netbios) of the domain the trust is to.
        NULL implies the domain the machine is a member of.

    Message - The message to compute the digest for.

    MessageSize - The size of Message in bytes.

    NewMessageDigest - Returns the 128-bit digest of the message corresponding
        to the new password

    NewMessageDigest - Returns the 128-bit digest of the message corresponding
        to the new password

Return Value:

    NERR_Success: the operation was successful

    ERROR_NOT_SUPPORTED: The specified trusted domain does not support digesting.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    NTSTATUS Status = STATUS_SUCCESS;
    PCLIENT_SESSION ClientSession = NULL;
    PDOMAIN_INFO DomainInfo = NULL;
    UNICODE_STRING DomainNameString;

    PUNICODE_STRING NewPassword = NULL;
    PUNICODE_STRING OldPassword = NULL;
    ULONG DummyPasswordVersionNumber;
    NT_OWF_PASSWORD NewOwfPassword;
    NT_OWF_PASSWORD OldOwfPassword;

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeClientDigest: %ws: Message: ",
            DomainName ));
    NlpDumpBuffer(NL_ENCRYPT, Message, MessageSize );


    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,     // Security descriptor
            NETLOGON_SERVICE_ACCESS,                // Desired access
            &NlGlobalNetlogonInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ServerName );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }


    //
    // On the PDC or BDC,
    //  find the Client session for the domain.
    // On workstations,
    //  find the primary domain client session.
    //

    if ( DomainName == NULL ) {
        DomainName = DomainInfo->DomUnicodeDomainName;
    }

    RtlInitUnicodeString( &DomainNameString, DomainName );
    ClientSession = NlFindNamedClientSession( DomainInfo,
                                              &DomainNameString,
                                              NL_DIRECT_TRUST_REQUIRED | NL_ROLE_PRIMARY_OK,
                                              NULL );

    if ( ClientSession == NULL ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonComputeClientDigest: %ws: No such trusted domain\n",
                DomainName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Get the two passwords on the account in clear
    //

    Status = NlGetOutgoingPassword( ClientSession,
                                    &NewPassword,
                                    &OldPassword,
                                    &DummyPasswordVersionNumber,
                                    NULL );  // No need to return password set time

    if ( !NT_SUCCESS(Status) ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NetrLogonComputeClientDigest: cannot NlGetOutgoingPassword 0x%lx\n",
                    Status ));

        //
        // Return more appropriate error.
        //
        if ( !NlpIsNtStatusResourceError( Status )) {
            Status = STATUS_NO_TRUST_LSA_SECRET;
        }
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Compute the new OWF password
    //

    if ( NewPassword != NULL  ) {
        Status = RtlCalculateNtOwfPassword( NewPassword,
                                            &NewOwfPassword );

        if ( !NT_SUCCESS( Status ) ) {

            //
            // return more appropriate error.
            //
            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_TRUST_LSA_SECRET;
            }
            NetStatus = NetpNtStatusToApiStatus(Status);
            goto Cleanup;
        }

    //
    // If no new password exists on the account,
    //  use a blank password
    //

    } else {
        UNICODE_STRING TempUnicodeString;

        RtlInitUnicodeString(&TempUnicodeString, NULL);
        Status = RtlCalculateNtOwfPassword( &TempUnicodeString,
                                            &NewOwfPassword );
        if ( !NT_SUCCESS(Status) ) {
            NlPrint(( NL_CRITICAL,
                      "NetrLogonComputeClientDigest: %ws Cannot RtlCalculateNtOwfPassword (NULL) 0x%lx\n",
                      DomainName,
                      Status ));
            NetStatus = NetpNtStatusToApiStatus(Status);
            goto Cleanup;
        }
    }

    //
    // Compute the old OWF password
    //

    if ( OldPassword != NULL  ) {
        Status = RtlCalculateNtOwfPassword( OldPassword,
                                            &OldOwfPassword );

        if ( !NT_SUCCESS( Status ) ) {

            //
            // return more appropriate error.
            //
            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_TRUST_LSA_SECRET;
            }
            NetStatus = NetpNtStatusToApiStatus(Status);
            goto Cleanup;
        }

    //
    // If no old password exists on the account,
    //  use the new password in place of the old one
    //

    } else {
        RtlCopyMemory( &OldOwfPassword,
                       &NewOwfPassword,
                       sizeof(OldOwfPassword) );
    }


    //
    // Compute the new message digest.
    //

    NetStatus = NlComputeMd5Digest( Message, MessageSize, &NewOwfPassword, NewMessageDigest );
    if ( NetStatus != NO_ERROR ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NetrLogonComputeClientDigest: cannot NlComputeMd5Digest (1) 0x%lx\n",
                    NetStatus ));
        goto Cleanup;
    }

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeClientDigest: %ws: New Password: ",
            DomainName ));
    NlpDumpBuffer(NL_ENCRYPT, &NewOwfPassword, sizeof(NewOwfPassword) );

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeClientDigest: %ws: New Digest: ",
            DomainName ));
    NlpDumpBuffer(NL_ENCRYPT, NewMessageDigest, sizeof(NewMessageDigest) );

    //
    // Compute the old message digest.
    //

    NetStatus = NlComputeMd5Digest( Message, MessageSize, &OldOwfPassword, OldMessageDigest );
    if ( NetStatus != NO_ERROR ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NetrLogonComputeClientDigest: cannot NlComputeMd5Digest (2) 0x%lx\n",
                    NetStatus ));
        goto Cleanup;
    }

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeClientDigest: %ws: Old Password: ",
            DomainName ));
    NlpDumpBuffer(NL_ENCRYPT, &OldOwfPassword, sizeof(OldOwfPassword) );

    NlPrint((NL_ENCRYPT,
            "NetrLogonComputeClientDigest: %ws: Old Digest: ",
            DomainName ));
    NlpDumpBuffer(NL_ENCRYPT, OldMessageDigest, sizeof(OldMessageDigest) );

    //
    // Free any locally used resources.
    //
Cleanup:

    if ( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    if ( NewPassword != NULL ) {
        LocalFree( NewPassword );
    }

    if ( OldPassword != NULL ) {
        LocalFree( OldPassword );
    }

    return NetStatus;
}


NET_API_STATUS
NetrLogonGetTimeServiceParentDomain(
        IN LPWSTR ServerName OPTIONAL,
        OUT LPWSTR *DomainName,
        OUT PBOOL PdcSameSite
    )

/*++

Routine Description:

    Returns the domain name of the domain that is logically the "parent" of this
    domain.  The returned domain name is suitable for passing into the
    NetLogonGetTrustRid and NetLogonComputeClientDigest API.

    On a workstation or member server, the returned domain name is that of the
    domain that ServerName is a member of.

    On a DC that is at the root of the forest, ERROR_NO_SUCH_DOMAIN is returned.

    On a DC that is at the root of a tree in the forest, the name of a trusted
        domain that is also at the root of a tree in the forest is returned.

    On any other DC, the name of the domain that is directly the parent domain
        is returned.

    (See the notes on multiple hosted domains in the code below.)

    Only an Admin or LocalSystem may call this function.

Arguments:

    ServerName - The name of the remote server.

    DomainName - Returns the name of the parent domain.
        The returned buffer should be freed using NetApiBufferFree

    PdcSameSite - Return TRUE if the PDC of ServerName's domain is in the same
        site as ServerName.
        (This value should be ignored if ServerName is not a DC.)

Return Value:

    NERR_Success: the operation was successful

    ERROR_NO_SUCH_DOMAIN: This server is a DC in the domain that is at the
        root of the forest.


--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PCLIENT_SESSION ClientSession = NULL;
    PDOMAIN_INFO DomainInfo = NULL;
    BOOLEAN IsSameSite;

    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,     // Security descriptor
            NETLOGON_SERVICE_ACCESS,                // Desired access
            &NlGlobalNetlogonInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Lookup which domain this call pertains to.
    //
    // MULTIHOST: This API doesn't take the hosted domain name on purpose.
    //  When I do multiple hosted domains, this API should find the
    //  DomainInfo structure for the hosted domain that's closest to the root.
    //  We'll return the parent of that domain.
    //
    // Since there is only one physical clock on this machine, we'll only run
    //  one copy of the time service.  It should sync from as high up the tree
    //  as we have trust to.
    //

    UNREFERENCED_PARAMETER( ServerName );
    DomainInfo = NlFindDomainByServerName( NULL );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }


    //
    // On a workstation,
    //  Use the session for the domain we're a member of.
    //

    if ( NlGlobalMemberWorkstation ) {
        ClientSession = NlRefDomClientSession( DomainInfo );
        IsSameSite = TRUE;

    //
    // On a DC,
    //  Use the session for the domain representing our parent domain
    //
    } else {

        //
        // Determine whether the PDC is in the same site
        //

        Status = SamISameSite( &IsSameSite );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom(( NL_CRITICAL,  DomainInfo,
                         "NetrLogonGetTimeServiceParentDomain: Cannot SamISameSite.\n" ));
            NetStatus = NetpNtStatusToApiStatus(Status);
            goto Cleanup;
        }

        ClientSession = NlRefDomParentClientSession( DomainInfo );
    }

    if ( ClientSession == NULL ) {
        NlPrintDom(( NL_CRITICAL,  DomainInfo,
                     "NetrLogonGetTimeServiceParentDomain: Cannot find trust to my parent domain.\n" ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Return the name of the trusted parent domain to the caller.
    //

    LOCK_TRUST_LIST( DomainInfo );
    if ( ClientSession->CsDnsDomainName.Length == 0 ) {
        *DomainName = NetpAllocWStrFromWStr( ClientSession->CsNetbiosDomainName.Buffer );
    } else {
        *DomainName = NetpAllocWStrFromWStr( ClientSession->CsDnsDomainName.Buffer );
    }
    UNLOCK_TRUST_LIST( DomainInfo );

    if ( *DomainName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    *PdcSameSite = IsSameSite;

    NlPrintDom(( NL_SESSION_SETUP, DomainInfo,
                 "NetrLogonGetTimeServiceParentDomain: %ws is the parent domain. (PdcSameSite: %ld)\n",
                 *DomainName,
                 IsSameSite ));

    //
    // Free any locally used resources.
    //
Cleanup:

    if ( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return NetStatus;
}

DWORD
NlSetDsSPNWorker(
    PNL_SPN_UPDATE Update
    )
/*++

Routine Description:

    Updates the SPN of the computer object described in the
    NL_SPN_UPDATE structure.  The SPN is updated, but the rules
    about SPN update are left to the DS.

Arguments:

    Update - Update record describing the name of the computer
             object and the SPN to use.

Return Value:

    ignored - this is a thread pool worker function.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    ULONG CrackStatus = DS_NAME_NO_ERROR;

    LPWSTR DnsHostNameValues[2];
    LPWSTR SpnArray[3];
    LPWSTR DnsSpn = NULL;
    LPWSTR NetbiosSpn = NULL;

    LDAPModW DnsHostNameAttr;
    LDAPModW SpnAttr;
    LDAPModW *Mods[3] = {NULL};

    HANDLE hDs = NULL;
    LDAP *LdapHandle = NULL;
    LDAPMessage *LdapMessage = NULL;
    PDS_NAME_RESULTW CrackedName = NULL;
    LPWSTR DnOfAccount = NULL;

    LPWSTR NameToCrack;
    DWORD SamNameSize;
    WCHAR SamName[ DNLEN + 1 + CNLEN + 1 + 1];

    ULONG LdapStatus;
    LONG LdapOption;

    LDAP_TIMEVAL LdapTimeout;
    ULONG MessageNumber;

    //
    // Ldap modify control needed to indicate that the
    // existing values of the modified attributes should
    // be left intact and the missing ones should be added.
    // Without this control, a modification of an attribute
    // that results in an addition of a value that already
    // exists will fail.
    //

    LDAPControl     ModifyControl =
                    {
                        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                        {
                            0, NULL
                        },
                        FALSE
                    };

    PLDAPControl    ModifyControlArray[2] =
                    {
                        &ModifyControl,
                        NULL
                    };
    //
    // Sanity check computer name
    //

    if ( wcslen( Update->NetbiosComputerName ) > CNLEN ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }

    //
    // Prepare DnsHostName modification entry
    //

    if ( Update->SetDnsHostName ) {
        DnsHostNameValues[0] = Update->DnsHostName;
        DnsHostNameValues[1] = NULL;

        NlPrint(( NL_MISC, "SPN: Setting DnsHostName %ws\n",
                  DnsHostNameValues[0] ));

        //
        // If we set both DnsHostName and SPN, then DnsHostName is
        // missing, so add it. If we set DnsHostName only, then
        // DnsHostName already exists (but incorrect), so replace it.
        //
        if ( Update->SetSpn ) {
            DnsHostNameAttr.mod_op = LDAP_MOD_ADD;
        } else {
            DnsHostNameAttr.mod_op = LDAP_MOD_REPLACE;
        }
        DnsHostNameAttr.mod_type = L"DnsHostName";
        DnsHostNameAttr.mod_values = DnsHostNameValues;

        Mods[0] = &DnsHostNameAttr;
        Mods[1] = NULL;
    }

    //
    //  Prepare SPN modification entries
    //

    if ( Update->SetSpn ) {
        LPBYTE Where;
        DWORD SpnSize;

        //
        // Build the DNS SPN
        //

        SpnSize = (wcslen( Update->DnsHostName ) + 1) * sizeof( WCHAR );
        SpnSize += sizeof( NL_HOST_PREFIX ) ;

        DnsSpn = (LPWSTR) LocalAlloc( 0, SpnSize );

        if ( DnsSpn == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( DnsSpn, NL_HOST_PREFIX );

        wcscpy( DnsSpn + (sizeof( NL_HOST_PREFIX ) / sizeof(WCHAR) ) - 1,
                Update->DnsHostName );

        //
        // Build the Netbios SPN
        //

        SpnSize = (wcslen( Update->NetbiosComputerName ) + 1) * sizeof( WCHAR );
        SpnSize += sizeof( NL_HOST_PREFIX ) ;

        NetbiosSpn = (LPWSTR) LocalAlloc( 0, SpnSize );

        if ( NetbiosSpn == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( NetbiosSpn, NL_HOST_PREFIX );

        wcscpy( NetbiosSpn + (sizeof( NL_HOST_PREFIX ) / sizeof(WCHAR) ) - 1,
                Update->NetbiosComputerName );

        NlPrint(( NL_MISC,
                  "SPN: Setting SPN %ws and %ws\n",
                  DnsSpn,
                  NetbiosSpn ));

        SpnArray[0] = DnsSpn;
        SpnArray[1] = NetbiosSpn;
        SpnArray[2] = NULL;

        SpnAttr.mod_op = LDAP_MOD_ADD;
        SpnAttr.mod_type = L"ServicePrincipalName";
        SpnAttr.mod_values = SpnArray;

        //
        // Use the first modification entry slot available (actually,
        //  when we set SPNs, we always set DnsHostName first, but
        //  let's be general and check it here).
        //

        if ( Mods[0] == NULL ) {
            Mods[0] = &SpnAttr;
            Mods[1] = NULL;
        } else {
            Mods[1] = &SpnAttr;
            Mods[2] = NULL;
        }
    }

    //
    // The name of the computer object is
    //  <NetbiosDomainName>\<NetbiosComputerName>$
    //

    wcscpy( SamName, Update->NetbiosDomainName );
    wcscat( SamName, L"\\" );
    wcscat( SamName, Update->NetbiosComputerName );
    wcscat( SamName, L"$" );


    //
    // Bind to the DS on the DC.
    //

    NetStatus = DsBindW( Update->UncDcName,
                         NULL,
                         &hDs );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: Cannot bind to DS on %ws: %ld\n",
                  Update->UncDcName,
                  NetStatus ));
        goto Cleanup ;
    }

    //
    // Crack the sam account name into a DN:
    //

    NameToCrack = SamName;
    NetStatus = DsCrackNamesW(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &NameToCrack,
                    &CrackedName );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: CrackNames failed on %ws for %ws: %ld\n",
                  Update->UncDcName,
                  SamName,
                  NetStatus ));
        goto Cleanup ;
    }

    if ( CrackedName->cItems != 1 ) {
        CrackStatus = DS_NAME_ERROR_NOT_UNIQUE;
        NlPrint(( NL_CRITICAL,
                  "SPN: Cracked Name is not unique on %ws for %ws: %ld\n",
                  Update->UncDcName,
                  SamName,
                  NetStatus ));
        goto Cleanup ;
    }

    if ( CrackedName->rItems[ 0 ].status != DS_NAME_NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: CrackNames failed on %ws for %ws: substatus %ld\n",
                  Update->UncDcName,
                  SamName,
                  CrackedName->rItems[ 0 ].status ));
        CrackStatus = CrackedName->rItems[ 0 ].status;
        goto Cleanup ;
    }
    DnOfAccount = CrackedName->rItems[0].pName;

    //
    // Open an LDAP connection to the DC and set useful options
    //

    LdapHandle = ldap_init( Update->UncDcName+2, LDAP_PORT );

    if ( LdapHandle == NULL ) {
        NetStatus = GetLastError();
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_init failed on %ws for %ws: %ld\n",
                  Update->UncDcName,
                  SamName,
                  NetStatus ));
        goto Cleanup;
    }

    // 30 second timeout
    LdapOption = 30;
    LdapStatus = ldap_set_optionW( LdapHandle, LDAP_OPT_TIMELIMIT, &LdapOption );
    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_set_option LDAP_OPT_TIMELIMIT failed on %ws for %ws: %ld: %s\n",
                  Update->UncDcName,
                  SamName,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }

    // Don't chase referals
    LdapOption = PtrToLong(LDAP_OPT_OFF);
    LdapStatus = ldap_set_optionW( LdapHandle, LDAP_OPT_REFERRALS, &LdapOption );
    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_set_option LDAP_OPT_REFERRALS failed on %ws for %ws: %ld: %s\n",
                  Update->UncDcName,
                  SamName,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }

    // Set the option telling LDAP that I passed it an explicit DC name and
    //  that it can avoid the DsGetDcName.
    LdapOption = PtrToLong(LDAP_OPT_ON);
    LdapStatus = ldap_set_optionW( LdapHandle, LDAP_OPT_AREC_EXCLUSIVE, &LdapOption );
    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_set_option LDAP_OPT_AREC_EXCLUSIVE failed on %ws for %ws: %ld: %s\n",
                  Update->UncDcName,
                  SamName,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }


    //
    // Bind to the DC
    //

    LdapStatus = ldap_bind_s( LdapHandle,
                              NULL, // No DN of account to authenticate as
                              NULL, // Default credentials
                              LDAP_AUTH_NEGOTIATE );

    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: Cannot ldap_bind to %ws for %ws: %ld: %s\n",
                  Update->UncDcName,
                  SamName,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }


    //
    // Write the modifications
    //

    LdapStatus = ldap_modify_extW( LdapHandle,
                                   DnOfAccount,
                                   Mods,
                                   (PLDAPControl *) &ModifyControlArray,
                                   NULL,     // No client controls
                                   &MessageNumber );

    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: Cannot ldap_modify on %ws for %ws: %ld: %s\n",
                  Update->UncDcName,
                  DnOfAccount,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }

    // Wait for the modify to complete
    LdapTimeout.tv_sec = NlGlobalParameters.ShortApiCallPeriod / 1000,  // Don't wait forever
    LdapTimeout.tv_usec = 0;
    LdapStatus = ldap_result( LdapHandle,
                              MessageNumber,
                              LDAP_MSG_ALL,
                              &LdapTimeout,
                              &LdapMessage );

    switch ( LdapStatus ) {
    case -1:
        NlPrint(( NL_CRITICAL,
                  "SPN: Cannot ldap_result on %ws for %ws: %ld: %s\n",
                  Update->UncDcName,
                  SamName,
                  LdapHandle->ld_errno,
                  ldap_err2stringA( LdapHandle->ld_errno )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;

    case 0:
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_result timeout on %ws for %ws.\n",
                  Update->UncDcName,
                  SamName ));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;

    case LDAP_RES_MODIFY:
        if ( LdapMessage->lm_returncode != 0 ) {
            NlPrint(( NL_CRITICAL,
                      "SPN: Cannot ldap_result on %ws for %ws: %ld: %s\n",
                      Update->UncDcName,
                      SamName,
                      LdapMessage->lm_returncode,
                      ldap_err2stringA( LdapMessage->lm_returncode )));
            NetStatus = LdapMapErrorToWin32(LdapMessage->lm_returncode);
            goto Cleanup;
        }

        NlPrint(( NL_MISC,
                  "SPN: Set successfully on DC %ws\n",
                   Update->UncDcName ));
        break;  // This is what we expect

    default:
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_result unexpected result on %ws for %ws: %ld\n",
                  Update->UncDcName,
                  SamName,
                  LdapStatus ));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }


Cleanup:

    //
    // Log the failure in the event log, if requested.
    // Try to output the most specific error.
    //

    if ( CrackStatus != DS_NAME_NO_ERROR && Update->WriteEventLogOnFailure ) {

        //
        // Try to log a more descriptive error message
        //
        if ( CrackStatus == DS_NAME_ERROR_NOT_UNIQUE ) {
            LPWSTR MsgStrings[2];

            MsgStrings[0] = Update->UncDcName;
            MsgStrings[1] = SamName;

            NlpWriteEventlog( NELOG_NetlogonSpnMultipleSamAccountNames,
                              EVENTLOG_ERROR_TYPE,
                              NULL,
                              0,
                              MsgStrings,
                              2 );
        //
        // Log a generic crack name error message
        //
        } else {
            LPWSTR MsgStrings[4];
            // Each byte of the status code will transform into one character 0-F
            WCHAR  NetStatusString[sizeof(WCHAR) * (sizeof(NetStatus) + 1)];
            WCHAR  CrackStatusString[sizeof(WCHAR) * (sizeof(CrackStatus) + 1)];

            swprintf( NetStatusString, L"%lx", NetStatus );
            swprintf( CrackStatusString, L"%lx", CrackStatus );

            MsgStrings[0] = Update->UncDcName;
            MsgStrings[1] = SamName;
            MsgStrings[2] = NetStatusString;
            MsgStrings[3] = CrackStatusString;

            NlpWriteEventlog( NELOG_NetlogonSpnCrackNamesFailure,
                              EVENTLOG_ERROR_TYPE,
                              NULL,
                              0,
                              MsgStrings,
                              4 );
        }

    //
    // Log the more generic error
    //
    } else if ( NetStatus != NO_ERROR && Update->WriteEventLogOnFailure ) {

        if ( Update->SetDnsHostName ) {
            LPWSTR MsgStrings[2];

            if ( Update->DnsHostName != NULL ) {
                MsgStrings[0] = Update->DnsHostName;
            } else {
                MsgStrings[0] = L"<UNAVAILABLE>";
            }

            MsgStrings[1] = (LPWSTR) ULongToPtr( NetStatus );

            NlpWriteEventlog( NELOG_NetlogonFailedDnsHostNameUpdate,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE)&NetStatus,
                              sizeof(NetStatus),
                              MsgStrings,
                              2 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        }
        if ( Update->SetSpn ) {
            LPWSTR MsgStrings[3];

            if ( DnsSpn != NULL ) {
                MsgStrings[0] = DnsSpn;
            } else {
                MsgStrings[0] = L"<UNAVAILABLE>";
            }
            if ( NetbiosSpn != NULL ) {
                MsgStrings[1] = NetbiosSpn;
            } else {
                MsgStrings[1] = L"<UNAVAILABLE>";
            }
            MsgStrings[2] = (LPWSTR) ULongToPtr( NetStatus );

            NlpWriteEventlog( NELOG_NetlogonFailedSpnUpdate,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE)&NetStatus,
                              sizeof(NetStatus),
                              MsgStrings,
                              3 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        }
    }

    if ( hDs ) {
        DsUnBind( &hDs );
    }

    if ( CrackedName ) {
        DsFreeNameResultW( CrackedName );
    }

    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
    }

    if ( LdapHandle != NULL ) {
        ldap_unbind_s( LdapHandle );
    }

    if ( DnsSpn ) {
        LocalFree( DnsSpn );
    }

    if ( NetbiosSpn ) {
        LocalFree( NetbiosSpn );
    }

    if ( Update ) {
        LocalFree( Update );
    }

    return 0;
}


NET_API_STATUS
NlSetDsSPN(
    IN BOOLEAN Synchronous,
    IN BOOLEAN SetSpn,
    IN BOOLEAN SetDnsHostName,
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR UncDcName,
    IN LPWSTR ComputerName,
    IN LPWSTR DnsHostName
    )
/*++

Routine Description:

    Queues an update request to the thread pool for later
    execution in a worker thread.

Arguments:

    Synchronous - TRUE if the operation is to complete before this procedure returns

    SetSpn -  TRUE if the SPN is to be updated

    SetDnsHostName - TRUE if the Dns host name is to be updated

    DomainInfo - Hosted Domain this object is in

    UncDcName - UNC name of the DC to make this call on

    ComputerName - Name of the computer.  This is (usually)
                   equivalent to the netbios name, without
                   the '$' on the end.

    DnsHostName - DNS Hostname of the computer.  This is in
                  FQDN format:  longcomputername.dns.domain.com

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - No memory to queue the worker request

    NO_ERROR - Queued.

--*/
{
    NET_API_STATUS NetStatus;

    PNL_SPN_UPDATE Update;
    DWORD Size;
    DWORD NetbiosComputerNameSize;
    DWORD DnsHostNameSize;
    DWORD DcNameSize;
    WCHAR NetbiosDomainName[DNLEN+1];
    DWORD NetbiosDomainNameSize;
    LPBYTE Where;

    //
    // Silently ignore clients with no DNS host name
    //

    if ( DnsHostName == NULL ) {
        return NO_ERROR;
    }

    if ( !SetSpn && !SetDnsHostName ) {
        return NO_ERROR;
    }

    //
    // Sanity check computer name
    //

    if ( wcslen( ComputerName ) > CNLEN ) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Grab the Netbios Domain Name
    //

    EnterCriticalSection( &NlGlobalDomainCritSect );
    wcscpy( NetbiosDomainName, DomainInfo->DomUnicodeDomainName );
    LeaveCriticalSection( &NlGlobalDomainCritSect );


    //
    // Allocate a workitem
    //

    DnsHostNameSize = wcslen( DnsHostName ) * sizeof(WCHAR) + sizeof(WCHAR);
    NetbiosComputerNameSize = wcslen( ComputerName ) * sizeof(WCHAR) + sizeof(WCHAR);
    DcNameSize = wcslen( UncDcName ) * sizeof(WCHAR) + sizeof(WCHAR);
    NetbiosDomainNameSize = wcslen( NetbiosDomainName ) * sizeof(WCHAR) + sizeof(WCHAR);

    Size = sizeof( NL_SPN_UPDATE ) +
           DnsHostNameSize +
           NetbiosComputerNameSize +
           DcNameSize +
           NetbiosDomainNameSize +
           NL_MAX_DNS_LENGTH * sizeof(WCHAR) + sizeof(WCHAR);

    Update = LocalAlloc( 0, Size );

    if ( Update == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY ;
    }

    //
    // Build the update request:
    //

    Update->SetSpn = SetSpn;
    Update->SetDnsHostName = SetDnsHostName;
    Update->WriteEventLogOnFailure = FALSE;

    Where = (LPBYTE) (Update + 1);

    Update->DnsHostName = (LPWSTR)Where;
    RtlCopyMemory( Where, DnsHostName, DnsHostNameSize );
    Where += DnsHostNameSize;

    Update->NetbiosComputerName = (LPWSTR)Where;
    RtlCopyMemory( Where, ComputerName, NetbiosComputerNameSize );
    Where += NetbiosComputerNameSize;

    Update->UncDcName = (LPWSTR)Where;
    RtlCopyMemory( Where, UncDcName, DcNameSize );
    Where += DcNameSize;

    Update->NetbiosDomainName = (LPWSTR)Where;
    RtlCopyMemory( Where, NetbiosDomainName, NetbiosDomainNameSize );
    Where += NetbiosDomainNameSize;

    Update->DnsDomainName = (LPWSTR)Where;
    NlCaptureDomainInfo( DomainInfo,
                         Update->DnsDomainName,
                         NULL );
    Where += NL_MAX_DNS_LENGTH * sizeof(WCHAR) + sizeof(WCHAR);


    //
    // Either do the work now or queue it to a worker thread.
    //

    if ( Synchronous ) {

        //
        // On workstation where this call is synchronous,
        //  log any error in the event log.
        //
        Update->WriteEventLogOnFailure = TRUE;
        (VOID) NlSetDsSPNWorker( Update );

    } else {
        //
        // Queue it off to a worker thread.  The update will take
        // place from a different thread, so we won't have interesting
        // deadlocks due to lookups.
        //

        NlPrint(( NL_MISC,
                  "NlSetDsSPN: Queuing SPN update for %ws on %ws.\n",
                  Update->DnsHostName,
                  Update->UncDcName ));

        //
        // REVIEW: how do I wait for this worker to finish executing when the
        //  service shuts down.
        //
        if ( !QueueUserWorkItem( NlSetDsSPNWorker, Update, 0 ) ) {
            LocalFree( Update );
            return ERROR_NOT_ENOUGH_MEMORY ;
        }

        NetStatus = NO_ERROR;
    }

    return NetStatus;

}

NET_API_STATUS NET_API_FUNCTION
DsrDeregisterDnsHostRecords (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN GUID *DsaGuid OPTIONAL,
    IN LPWSTR DnsHostName
    )

/*++

Routine Description:

    This function deletes all DNS entries associated with a particular
    NtDsDsa object.

    This routine does NOT delete A records registered by the DC.  We have
    no way of finding out the IP addresses of the long gone DC.

    Only an Admin, Account Operator or Server Operator may call this
    function.

Arguments:

    DnsDomainName - DNS domain name of the domain the DC was in.
        This need not be a domain hosted by this DC.
        If NULL, it is implied to be the DnsHostName with the leftmost label
            removed.

    DomainGuid - Domain Guid of the domain.
        If NULL, GUID specific names will not be removed.

    DsaGuid - GUID of the NtdsDsa object that will be deleted.
        If NULL, NtdsDsa specific names will not be removed.

    DnsHostName - DNS host name of the DC whose DNS records are being deleted.

Return Value:

    NO_ERROR - Success.

    ERROR_NOT_SUPPORTED - The server specified is not a DC.

    ERROR_ACCESS_DENIED - The caller is not allowed to perform this operation.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    //
    // This APIis supported on DCs only
    //

    if ( NlGlobalMemberWorkstation ) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Perform access validation on the caller
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,   // Security descriptor
            NETLOGON_CONTROL_ACCESS,              // Desired access
            &NlGlobalNetlogonInfoMapping );       // Generic mapping

    if ( NetStatus != NERR_Success) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Notify the service that DNS records need to be deleted
    //

    Status = I_NetNotifyNtdsDsaDeletion ( DnsDomainName,
                                          DomainGuid,
                                          DsaGuid,
                                          DnsHostName );

    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        NlPrint(( NL_CRITICAL,
                  "DsrDeregisterDnsHostRecords: Cannot I_NetNotifyNtdsDsaDeletion. %ld\n",
                  NetStatus ));
        return NetStatus;
    }

    //
    // Everything was successful
    //

    return NO_ERROR;

UNREFERENCED_PARAMETER( ServerName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\worker.h ===
/*++

Copyright (c) 1991-1996 Microsoft Corporation

Module Name:

    worker.h

Abstract:

    This file describes the netlogon thread queue interfaces.

Author:

    Larry Osterman (larryo) 15-Feb-1991

Revision History:

--*/

#ifndef _WORKER_H_
#define _WORKER_H_


typedef
VOID
(*PNETLOGON_WORKER_ROUTINE) (
    IN PVOID Parameter
    );


typedef struct _WORKER_ITEM {
    LIST_ENTRY List;
    PNETLOGON_WORKER_ROUTINE WorkerRoutine;
    PVOID Parameter;
    BOOLEAN Inserted;
} WORKER_ITEM, *PWORKER_ITEM;

#ifdef notdef
typedef struct _BROWSER_TIMER {
    HANDLE TimerHandle;
    WORKER_ITEM WorkItem;
} BROWSER_TIMER, *PBROWSER_TIMER;
#endif // notdef


BOOL
NlQueueWorkItem(
    IN PWORKER_ITEM WorkItem,
    IN BOOL InsertNewItem,
    IN BOOL HighPriority
    );

NET_API_STATUS
NlWorkerInitialization(
    VOID
    );

VOID
NlWorkerTermination (
    VOID
    );

#ifdef notdef
NET_API_STATUS
BrSetTimer(
    IN PBROWSER_TIMER Timer,
    IN ULONG MilliSecondsToExpire,
    IN PBROWSER_WORKER_ROUTINE WorkerFunction,
    IN PVOID Context
    );

NET_API_STATUS
BrCancelTimer(
    IN PBROWSER_TIMER Timer
    );

NET_API_STATUS
BrDestroyTimer(
    IN PBROWSER_TIMER Timer
    );

NET_API_STATUS
BrCreateTimer(
    IN PBROWSER_TIMER Timer
    );
#endif // notdef

#define NlInitializeWorkItem(Item, Routine, Context) \
    (Item)->WorkerRoutine = (Routine);               \
    (Item)->Parameter = (Context);                   \
    (Item)->Inserted = FALSE;


#endif // ifdef _WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\ssiauth.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    ssiauth.c

Abstract:

    Authentication related functions

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    12-Jul-1991 (cliffv)
        Ported to NT.  Converted to NT style.

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

#include <cryptdll.h>
#include <wincrypt.h>   // Crypto apis


LONG NlGlobalSessionCounter = 0;


NTSTATUS
NlMakeSessionKey(
    IN ULONG NegotiatedFlags,
    IN PNT_OWF_PASSWORD CryptKey,
    IN PNETLOGON_CREDENTIAL ClientChallenge,
    IN PNETLOGON_CREDENTIAL ServerChallenge,
    OUT PNETLOGON_SESSION_KEY SessionKey
    )
/*++

Routine Description:

      Build an encryption key for use in authentication for
      this RequestorName.

Arguments:

      NegotiatedFlags - Determines the strength of the key.

      CryptKey -- The OWF password of the user account being used.

      ClientChallenge --  8 byte (64 bit) number generated by caller

      ServerChallenge -- 8 byte (64 bit) number generated by primary

      SessionKey --  16 byte (128 bit) number generated at both ends
        If the key strength is weak, the last 64 bits will be zero.

Return Value:

    TRUE: Success
    FALSE: Failure

    NT status code.

--*/
{
    NTSTATUS Status;
    BLOCK_KEY BlockKey;
    NETLOGON_SESSION_KEY TempSessionKey;

#ifndef NETSETUP_JOIN
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCHECKSUM_FUNCTION Check;
#endif // NETSETUP_JOIN

    //
    // Start with a zero key
    //
    RtlZeroMemory(SessionKey, sizeof(NETLOGON_SESSION_KEY));

#ifdef NETSETUP_JOIN
    UNREFERENCED_PARAMETER( NegotiatedFlags );
#else // NETSETUP_JOIN
    //
    // If the caller wants a strong key,
    //  Compute it.
    //
    if ( NegotiatedFlags & NETLOGON_SUPPORTS_STRONG_KEY ) {

        // PCRYPTO_SYSTEM CryptSystem;

        UCHAR LocalChecksum[sizeof(*SessionKey)];
        // ULONG OutputSize;

        //
        // Initialize the checksum routines.
        //

        Status = CDLocateCheckSum( KERB_CHECKSUM_MD5_HMAC, &Check);
        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,"NlMakeSessionKey: Failed to load checksum routines: 0x%x\n", Status));
            goto Cleanup;
        }

        NlAssert(Check->CheckSumSize <= sizeof(LocalChecksum));

        Status = Check->InitializeEx(
                    (LPBYTE)CryptKey,
                    sizeof( *CryptKey ),
                    0,              // no message type
                    &CheckBuffer );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,"NlMakeSessionKey: Failed to initialize checksum routines: 0x%x\n", Status));
            goto Cleanup;
        }


        //
        // Sum in the client challenge, a constant, and the server challenge
        //

        Check->Sum( CheckBuffer,
                    sizeof(*ClientChallenge),
                    (PUCHAR)ClientChallenge );

        Check->Sum( CheckBuffer,
                    sizeof(*ServerChallenge),
                    (PUCHAR)ServerChallenge );

        //
        // Finish the checksum
        //

        (void) Check->Finalize(CheckBuffer, LocalChecksum);


        //
        // Copy the checksum into the message.
        //

        NlAssert( sizeof(LocalChecksum) >= sizeof(*SessionKey) );
        RtlCopyMemory( SessionKey, LocalChecksum, sizeof(*SessionKey) );


    //
    // Compute weaker (but backward compatible key)
    //
    } else {
#endif // NETSETUP_JOIN

        //
        // we will have a 128 bit key (64 bit encrypted rest padded with 0s)
        //
        // SessionKey = C + P  (arithmetic sum ignore carry)
        //

        *((unsigned long * ) SessionKey) =
            *((unsigned long * ) ClientChallenge) +
            *((unsigned long * ) ServerChallenge);

        *((unsigned long * )((LPBYTE)SessionKey + 4)) =
            *((unsigned long * )((LPBYTE)ClientChallenge + 4)) +
            *((unsigned long * )((LPBYTE)ServerChallenge + 4));


        //
        // CryptKey is our 16 byte key to be used as described in codespec
        // use first 7 bytes of CryptKey for first encryption
        //

        RtlCopyMemory( &BlockKey, CryptKey, BLOCK_KEY_LENGTH );

        Status = RtlEncryptBlock(
                    (PCLEAR_BLOCK) SessionKey,   // Clear text
                    &BlockKey,                  // Key
                    (PCYPHER_BLOCK) &TempSessionKey);    // Cypher Block

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }


        //
        // Further encrypt the encrypted "SessionKey" using upper 7 bytes
        //

        NlAssert( LM_OWF_PASSWORD_LENGTH == 2*BLOCK_KEY_LENGTH+2 );

        RtlCopyMemory( &BlockKey,
                       ((PUCHAR)CryptKey) + 2 + BLOCK_KEY_LENGTH,
                       BLOCK_KEY_LENGTH );

        Status = RtlEncryptBlock(
                    (PCLEAR_BLOCK) &TempSessionKey,   // Clear text
                    &BlockKey,                  // Key
                    (PCYPHER_BLOCK) SessionKey);    // Cypher Block

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }
#ifndef NETSETUP_JOIN
    }
#endif // NETSETUP_JOIN

Cleanup:
#ifndef NETSETUP_JOIN
    if (CheckBuffer != NULL) {
        Status = Check->Finish(&CheckBuffer);

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,"NlMakeSessionKey: Failed to finish checksum: 0x%x\n", Status));
        }
    }
#endif // NETSETUP_JOIN

    return Status;
}

#ifdef _DC_NETLOGON

NTSTATUS
NlCheckAuthenticator(
    IN OUT PSERVER_SESSION ServerSession,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator
    )
/*++

Routine Description:

    Verify that supplied Authenticator is valid.
    It is intended for use by the server side after initial authentication
    has succeeded. This routine will modify the seed by
    first adding the time-of-day received from the Authenticator
    and then by incrementing it.

    A ReturnAuthenticator is built based on the final seed.

Arguments:

    ServerSession - Pointer to the ServerSession structure.  The following
        fields are used:

        SsAuthenticationSeed - Supplies the seed used for authentication and
            returns the updated seed.

        SsSessionKey - The session key used for encryption.

        SsCheck - Is zeroed to indicate successful communication with the client.

    Authenticator - The authenticator passed by the caller.

    ReturnAuthenticator - The authenticator we'll return to the caller.

Return Value:

    STATUS_SUCCESS;
    STATUS_ACCESS_DENIED;
    STATUS_TIME_DIFFERENCE_AT_DC;

--*/
{

    NETLOGON_CREDENTIAL TargetCredential;



    NlPrint((NL_CHALLENGE_RES,"NlCheckAuthenticator: Seed = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &ServerSession->SsAuthenticationSeed, sizeof(ServerSession->SsAuthenticationSeed) );

    NlPrint((NL_CHALLENGE_RES, "NlCheckAuthenticator: SessionKey = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &ServerSession->SsSessionKey, sizeof(ServerSession->SsSessionKey) );

    NlPrint((NL_CHALLENGE_RES, "NlCheckAuthenticator: Client Authenticator GOT = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &Authenticator->Credential, sizeof(Authenticator->Credential) );

    NlPrint((NL_CHALLENGE_RES, "NlCheckAuthenticator: Time = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &Authenticator->timestamp, sizeof(Authenticator->timestamp) );



    //
    // modify the seed before computing auth_credential for verification
    // Two long words are added and overflow carry (if any) ignored
    // This will leave upper 4 bytes unchanged
    //

    *((unsigned long * ) &ServerSession->SsAuthenticationSeed) += Authenticator->timestamp;


    NlPrint((NL_CHALLENGE_RES, "NlCheckAuthenticator: Seed + TIME = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &ServerSession->SsAuthenticationSeed, sizeof(ServerSession->SsAuthenticationSeed) );


    //
    // Compute TargetCredential to verify the one supplied in the Authenticator
    //

    NlComputeCredentials( &ServerSession->SsAuthenticationSeed,
                          &TargetCredential,
                          &ServerSession->SsSessionKey );


    NlPrint((NL_CHALLENGE_RES, "NlCheckAuthenticator: Client Authenticator MADE = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &TargetCredential, sizeof(TargetCredential) );

    //
    // verify the computed credentials with those supplied
    // Authenticator must have used seed + time_of_day as seed
    //

    if (!RtlEqualMemory( &Authenticator->Credential,
                         &TargetCredential,
                         sizeof(TargetCredential)) ) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // modify our seed before computing the ReturnAuthenticator.
    // The requestor will increment his seed if he matches this credentials.
    //

    (*((unsigned long * ) &ServerSession->SsAuthenticationSeed))++;

    //
    // compute ClientCredential to send back to requestor
    //

    NlComputeCredentials( &ServerSession->SsAuthenticationSeed,
                          &ReturnAuthenticator->Credential,
                          &ServerSession->SsSessionKey);


    NlPrint((NL_CHALLENGE_RES,
            "NlCheckAuthenticator: Server Authenticator SEND = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &ReturnAuthenticator->Credential, sizeof(ReturnAuthenticator->Credential) );


    NlPrint((NL_CHALLENGE_RES, "NlCheckAuthenticator: Seed + time + 1= " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &ServerSession->SsAuthenticationSeed, sizeof(ServerSession->SsAuthenticationSeed) );


    //
    // Indicate successful communication with the client
    //

    ServerSession->SsCheck = 0;
    ServerSession->SsPulseTimeoutCount = 0;
    ServerSession->SsFlags &= ~SS_PULSE_SENT;

    return STATUS_SUCCESS;

}
#endif // _DC_NETLOGON


VOID
NlComputeCredentials(
    IN PNETLOGON_CREDENTIAL Challenge,
    OUT PNETLOGON_CREDENTIAL Credential,
    IN PNETLOGON_SESSION_KEY SessionKey
    )
/*++

Routine Description:

    Calculate the credentials by encrypting the 8 byte
    challenge with first 7 bytes of sessionkey and then
    further encrypting it by next 7 bytes of sessionkey.

Arguments:

    Challenge  - Supplies the 8 byte (64 bit) challenge

    Credential - Returns the 8  byte (64 bit) number generated

    SessionKey - Supplies 14 byte (112 bit) encryption key
        The buffer is 16 bytes (128 bits) long.  For a weak key, the trailing 8 bytes
        are zero.  For a strong key, this routine ingored that trailing 2 bytes of
        useful key.

Return Value:

    NONE

--*/
{
    NTSTATUS Status;
    BLOCK_KEY BlockKey;
    CYPHER_BLOCK IntermediateBlock;

    RtlZeroMemory(Credential, sizeof(*Credential));

    //
    // use first 7 bytes of SessionKey for first encryption
    //

    RtlCopyMemory( &BlockKey, SessionKey, BLOCK_KEY_LENGTH );

    Status = RtlEncryptBlock( (PCLEAR_BLOCK) Challenge, // Cleartext
                              &BlockKey,                // Key
                              &IntermediateBlock );     // Cypher Block

    NlAssert( NT_SUCCESS(Status) );

    //
    // further encrypt the encrypted Credential using next 7 bytes
    //

    RtlCopyMemory( &BlockKey,
                   ((PUCHAR)SessionKey) + BLOCK_KEY_LENGTH,
                   BLOCK_KEY_LENGTH );

    Status = RtlEncryptBlock( (PCLEAR_BLOCK) &IntermediateBlock, // Cleartext
                              &BlockKey,                // Key
                              Credential );             // Cypher Block

    NlAssert( NT_SUCCESS(Status) );

    return;

}



VOID
NlComputeChallenge(
    OUT PNETLOGON_CREDENTIAL Challenge
    )

/*++

Routine Description:

    Generates a 64 bit challenge

Arguments:

    Challenge - Returns the computed challenge

Return Value:

    None.

--*/
{

    //
    // Use an ideal random bit generator.
    //

    if (!NlGenerateRandomBits( (LPBYTE)Challenge, sizeof(*Challenge) )) {
        NlPrint((NL_CRITICAL, "Can't NlGenerateRandomBits\n" ));
    }

    return;
}



VOID
NlBuildAuthenticator(
    IN OUT PNETLOGON_CREDENTIAL AuthenticationSeed,
    IN PNETLOGON_SESSION_KEY SessionKey,
    OUT PNETLOGON_AUTHENTICATOR Authenticator
    )
/*++

Routine Description:

    Build the authenticator to be sent to primary.
    This routine will modify the seed by adding the
    time-of-day before computing the credentials.

Arguments:

    AuthenticationSeed -- The current authentication seed.  This seed will
        have the current time of day added to it prior to building the
        Authenticator.

    SessionKey - The Session Key used for encrypting the Authenticator.

    Authenticator - The Authenticator to pass to the PDC for the current
        call.

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeNow;

    //
    // Use the current time of day to modify the authentication seed
    //

    RtlZeroMemory(Authenticator, sizeof(*Authenticator));

    NlQuerySystemTime( &TimeNow );

    Status = RtlTimeToSecondsSince1970( &TimeNow, &Authenticator->timestamp );
    NlAssert( NT_SUCCESS(Status) );

    //
    // Modify the AuthenticationSeed before computing auth_credential for
    // verification .
    //
    // Two long words are added and overflow carry (if any) ignored
    // This will leave upper 4 bytes unchanged
    //


    NlPrint((NL_CHALLENGE_RES,"NlBuildAuthenticator: Old Seed = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, AuthenticationSeed, sizeof(*AuthenticationSeed) );

    NlPrint((NL_CHALLENGE_RES,"NlBuildAuthenticator: Time = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &Authenticator->timestamp, sizeof(Authenticator->timestamp) );



    *((unsigned long * ) AuthenticationSeed) += Authenticator->timestamp;


    NlPrint((NL_CHALLENGE_RES,"NlBuildAuthenticator: New Seed = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, AuthenticationSeed, sizeof(*AuthenticationSeed) );


    NlPrint((NL_CHALLENGE_RES, "NlBuildAuthenticator: SessionKey = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, SessionKey, sizeof(*SessionKey) );


    //
    // compute AuthenticationSeed to verify the one supplied by Requestor
    //

    NlComputeCredentials( AuthenticationSeed,
                               &Authenticator->Credential,
                               SessionKey);


    NlPrint((NL_CHALLENGE_RES,"NlBuildAuthenticator: Client Authenticator = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &Authenticator->Credential, sizeof(Authenticator->Credential) );


    return;

}


BOOL
NlUpdateSeed(
    IN OUT PNETLOGON_CREDENTIAL AuthenticationSeed,
    IN PNETLOGON_CREDENTIAL TargetCredential,
    IN PNETLOGON_SESSION_KEY SessionKey
    )
/*++

Routine Description:

    Called by the initiator of a communication over the secure channel
    following a successful transaction.

    The PDC would have incremented the seed so we must do so also.

    We also verify that the incremented seed builds a credential identical
    to the one passed back by the PDC.

Arguments:

    AuthenticationSeed - Pointer to the AuthenticationSeed to be incremented.

    TargetCredential - Supplies the Credential that the incremented
        AuthenticationSeed should encrypt to.

    SessionKey - Supplies the encryption key to use for the encryption.

Return Value:

    TRUE: Success
    FALSE: Failure

--*/
{
    NETLOGON_CREDENTIAL NewCredential;

    //
    //  modify our AuthenticationSeed before computing NewCredential to check
    //  those returned from primary (NewSeed = AuthenticationSeed+1)
    //

    (*((unsigned long * ) AuthenticationSeed))++;


    NlPrint((NL_CHALLENGE_RES,"NlUpdateSeed: Seed + time + 1= " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, AuthenticationSeed, sizeof(*AuthenticationSeed) );


    //
    // Compute ClientCredential to check which came from primary
    //

    NlComputeCredentials(AuthenticationSeed, &NewCredential, SessionKey);


    NlPrint((NL_CHALLENGE_RES,"NlUpdateSeed: Server Authenticator GOT  = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, TargetCredential, sizeof(*TargetCredential) );


    NlPrint((NL_CHALLENGE_RES,"NlUpdateSeed: Server Authenticator MADE = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &NewCredential, sizeof(NewCredential) );


    if ( !RtlEqualMemory( TargetCredential, &NewCredential, sizeof(NewCredential)) ) {
        return FALSE;
    }

    //
    // Done
    //

    return TRUE;

}


VOID
NlEncryptRC4(
    IN OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    Encrypt data using RC4 with the session key as the key.

Arguments:

    Buffer -- Buffer containing the data to encrypt in place.

    BufferSize -- Size (in bytes) of Buffer.

    SessionInfo -- Info describing secure channel

Return Value:

    NT status code

--*/
{
    NTSTATUS NtStatus;
    DATA_KEY KeyData;
    CRYPT_BUFFER Data;

    //
    // Build a data buffer to describe the encryption key.
    //

    KeyData.Length = sizeof(NETLOGON_SESSION_KEY);
    KeyData.MaximumLength = sizeof(NETLOGON_SESSION_KEY);
    KeyData.Buffer = (PVOID)&SessionInfo->SessionKey;

    NlAssert( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION );

    //
    // Build a data buffer to decribe the encrypted data.
    //

    Data.Length = Data.MaximumLength = BufferSize;
    Data.Buffer = Buffer;

    //
    // Encrypt the data.
    //

    IF_NL_DEBUG( ENCRYPT ) {
        NlPrint((NL_ENCRYPT, "NlEncryptRC4: Clear data: " ));
        NlpDumpBuffer( NL_ENCRYPT, Data.Buffer, Data.Length );
    }

    NtStatus = RtlEncryptData2( &Data, &KeyData );
    NlAssert( NT_SUCCESS(NtStatus) );

    IF_NL_DEBUG( ENCRYPT ) {
        NlPrint((NL_ENCRYPT, "NlEncryptRC4: Encrypted data: " ));
        NlpDumpBuffer( NL_ENCRYPT, Data.Buffer, Data.Length );
    }

}


VOID
NlDecryptRC4(
    IN OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    Decrypt data using RC4 with the session key as the key.

Arguments:

    Buffer -- Buffer containing the data to decrypt in place.

    BufferSize -- Size (in bytes) of Buffer.

    SessionInfo -- Info describing secure channel

Return Value:

    NT status code

--*/
{
    NTSTATUS NtStatus;
    DATA_KEY KeyData;
    CRYPT_BUFFER Data;

    //
    // Build a data buffer to describe the encryption key.
    //

    KeyData.Length = sizeof(NETLOGON_SESSION_KEY);
    KeyData.MaximumLength = sizeof(NETLOGON_SESSION_KEY);
    KeyData.Buffer = (PVOID)&SessionInfo->SessionKey;

    NlAssert( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION );

    //
    // Build a data buffer to decribe the encrypted data.
    //

    Data.Length = Data.MaximumLength = BufferSize;
    Data.Buffer = Buffer;

    //
    // Encrypt the data.
    //


    IF_NL_DEBUG( ENCRYPT ) {
        NlPrint((NL_ENCRYPT, "NlDecryptRC4: Encrypted data: " ));
        NlpDumpBuffer( NL_ENCRYPT, Data.Buffer, Data.Length );
    }

    NtStatus = RtlDecryptData2( &Data, &KeyData );
    NlAssert( NT_SUCCESS(NtStatus) );

    IF_NL_DEBUG( ENCRYPT ) {
        NlPrint((NL_ENCRYPT, "NlDecryptRC4: Clear data: " ));
        NlpDumpBuffer( NL_ENCRYPT, Data.Buffer, Data.Length );
    }

}


BOOLEAN
NlGenerateRandomBits(
    PUCHAR Buffer,
    ULONG  BufferLen
    )
/*++

Routine Description:

    Generates random bits

Arguments:

    pBuffer - Buffer to fill

    cbBuffer - Number of bytes in buffer

Return Value:

    Status of the operation.

--*/

{
    if( !CryptGenRandom( NlGlobalCryptProvider, BufferLen, ( LPBYTE )Buffer ) )
    {
        NlPrint((NL_CRITICAL, "CryptGenRandom failed with %lu\n", GetLastError() ));
        return FALSE;
    }

    return TRUE;
}



#ifndef NETSETUP_JOIN

VOID
NlPrintTrustedDomain(
    PDS_DOMAIN_TRUSTSW TrustedDomain,
    IN BOOLEAN VerbosePrint,
    IN BOOLEAN AnsiOutput
    )
/*++

Routine Description:

    Print a trusted domain structure

Arguments:

    TrustedDomain -- Structure to print

    VerbosePrint - If TRUE, output domain's GUID and SID

    AnsiOutput - If TRUE, names are in ansi format

Return Value:

    None.

--*/

{
    if ( AnsiOutput ) {
        if ( TrustedDomain->NetbiosDomainName != NULL ) {
            NlPrint(( NL_LOGON, " %s", TrustedDomain->NetbiosDomainName ));
        }
        if ( TrustedDomain->DnsDomainName != NULL ) {
            NlPrint(( NL_LOGON, " %s", TrustedDomain->DnsDomainName ));
        }
    } else {
        if ( TrustedDomain->NetbiosDomainName != NULL ) {
            NlPrint(( NL_LOGON, " %ws", TrustedDomain->NetbiosDomainName ));
        }
        if ( TrustedDomain->DnsDomainName != NULL ) {
            NlPrint(( NL_LOGON, " %ws", TrustedDomain->DnsDomainName ));
        }
    }

    switch ( TrustedDomain->TrustType ) {
    case TRUST_TYPE_DOWNLEVEL:
        NlPrint(( NL_LOGON, " (NT 4)" ); break);
    case TRUST_TYPE_UPLEVEL:
        NlPrint(( NL_LOGON, " (NT 5)" ); break);
    case TRUST_TYPE_MIT:
        NlPrint(( NL_LOGON, " (MIT)" ); break);
    case TRUST_TYPE_DCE:
        NlPrint(( NL_LOGON, " (DCE)" ); break);
    default:
        NlPrint(( NL_LOGON, " (Unknown Trust Type: %ld)", TrustedDomain->TrustType ); break);
    }

    if ( TrustedDomain->Flags ) {
        ULONG Flags;
        Flags = TrustedDomain->Flags;
        if ( Flags & DS_DOMAIN_IN_FOREST ) {
            if ( Flags & DS_DOMAIN_TREE_ROOT ) {
                NlPrint(( NL_LOGON, " (Forest Tree Root)" ));
                Flags &= ~DS_DOMAIN_TREE_ROOT;
            } else {
                NlPrint(( NL_LOGON, " (Forest: %ld)", TrustedDomain->ParentIndex ));
            }
            Flags &= ~DS_DOMAIN_IN_FOREST;
        }
        if ( Flags & DS_DOMAIN_DIRECT_OUTBOUND ) {
            NlPrint(( NL_LOGON, " (Direct Outbound)"));
            Flags &= ~DS_DOMAIN_DIRECT_OUTBOUND;
        }
        if ( Flags & DS_DOMAIN_DIRECT_INBOUND ) {
            NlPrint(( NL_LOGON, " (Direct Inbound)"));
            Flags &= ~DS_DOMAIN_DIRECT_INBOUND;
        }
        if ( Flags & DS_DOMAIN_TREE_ROOT ) {
            NlPrint(( NL_LOGON, " (Tree Root but not in forest!!!!)"));
            Flags &= ~DS_DOMAIN_TREE_ROOT;
        }
        if ( Flags & DS_DOMAIN_PRIMARY ) {
            NlPrint(( NL_LOGON, " (Primary Domain)"));
            Flags &= ~DS_DOMAIN_PRIMARY;
        }
        if ( Flags & DS_DOMAIN_NATIVE_MODE ) {
            NlPrint(( NL_LOGON, " (Native)"));
            Flags &= ~DS_DOMAIN_NATIVE_MODE;
        }
        if ( Flags != 0 ) {
            NlPrint(( NL_LOGON, " 0x%lX", Flags));
        }
    }

    if ( TrustedDomain->TrustAttributes ) {
        ULONG TrustAttributes = TrustedDomain->TrustAttributes;
        NlPrint(( NL_LOGON, " ( Attr:" ));
        if ( TrustAttributes & TRUST_ATTRIBUTE_NON_TRANSITIVE ) {
            NlPrint(( NL_LOGON, " non-trans"));
            TrustAttributes &= ~TRUST_ATTRIBUTE_NON_TRANSITIVE;
        }
        if ( TrustAttributes & TRUST_ATTRIBUTE_UPLEVEL_ONLY ) {
            NlPrint(( NL_LOGON, " uplevel-only"));
            TrustAttributes &= ~TRUST_ATTRIBUTE_UPLEVEL_ONLY;
        }
        if ( TrustAttributes & TRUST_ATTRIBUTE_FILTER_SIDS ) {
            NlPrint(( NL_LOGON, " filtered"));
            TrustAttributes &= ~TRUST_ATTRIBUTE_FILTER_SIDS;
        }
        if ( TrustAttributes != 0 ) {
            NlPrint(( NL_LOGON, " 0x%lX", TrustAttributes));
        }
        NlPrint(( NL_LOGON, " )"));
    }

    //
    // Output domain's GUID and SID
    //

    if ( VerbosePrint ) {
        if ( !IsEqualGUID( &TrustedDomain->DomainGuid, &NlGlobalZeroGuid) ) {
            RPC_STATUS RpcStatus;
            char *StringGuid;

            NlPrint(( NL_LOGON, "\n" ));
            NlPrint(( NL_LOGON, "       Dom Guid: " ));
            RpcStatus = UuidToStringA( &TrustedDomain->DomainGuid, &StringGuid );
            if ( RpcStatus == RPC_S_OK ) {
                NlPrint(( NL_LOGON, "%s", StringGuid ));
                RpcStringFreeA( &StringGuid );
            } else {
                NlPrint(( NL_LOGON, "Not available because UuidToStringA failed" ));
            }
        }

        NlPrint(( NL_LOGON, "\n" ));
        if ( TrustedDomain->DomainSid != NULL ) {
            NlPrint(( NL_LOGON, "       Dom Sid: " ));
            NlpDumpSid( NL_LOGON, TrustedDomain->DomainSid );
        }
    } else {
        NlPrint(( NL_LOGON, "\n" ));
    }
}
#endif // NETSETUP_JOIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\trustutl.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    trustutl.c

Abstract:

    Utilities routine to manage the trusted domain list.

Author:

    30-Jan-92 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//

#include <ntdsapip.h>


#define INDEX_LIST_ALLOCATED_CHUNK_SIZE  50

//
// Assume the domain is mixed mode until proven otherwise
//

BOOL NlGlobalWorkstationMixedModeDomain = TRUE;    

//
// Local procedure forwards.
//
VOID
NlDcDiscoveryWorker(
    IN PVOID Context
    );

//
// Local structures.
//

//
// Context keeping track of the current attempt to build the trust list.
//
typedef struct _NL_INIT_TRUSTLIST_CONTEXT {

    //
    // Buffer for building Forest trust list into.
    //
    BUFFER_DESCRIPTOR BufferDescriptor;

    //
    // Total size (in bytes) of the Forest trust list.
    //
    ULONG DomForestTrustListSize;

    //
    // Number of entries in the Forest trust list.
    //
    ULONG DomForestTrustListCount;

} NL_INIT_TRUSTLIST_CONTEXT, *PNL_INIT_TRUSTLIST_CONTEXT;


NET_API_STATUS
NlpSecureChannelBind(
    IN LPWSTR ServerName OPTIONAL,
    OUT handle_t *ContextHandle
    )

/*++

Routine Description:

    Returns a handle to be used for a secure channel to the named DC.


Arguments:

    ServerName - The name of the remote server.

    ContextHandle - Returns a handle to be used on subsequent calls

Return Value:

    NERR_Success: the operation was successful

--*/
{
    NET_API_STATUS NetStatus;


    //
    // Create the RPC binding handle
    //

    NetStatus = NlRpcpBindRpc (
                    ServerName,
                    SERVICE_NETLOGON,
                    L"Security=Impersonation Dynamic False",
                    UseTcpIp,  // Always use TCP/IP
                    ContextHandle );

    if ( NetStatus != NO_ERROR ) {
        *ContextHandle = NULL;
        return NetStatus;
    }

    return NetStatus;
}

VOID
NlpSecureChannelUnbind(
    IN PCLIENT_SESSION ClientSession,
    IN LPCWSTR ServerName,
    IN LPCSTR DebugInfo,
    IN ULONG CaIndex,
    IN handle_t ContextHandle,
    IN NL_RPC_BINDING RpcBindingType
    )

/*++

Routine Description:

    Unbinds a handle returned from NetLogonSecureChannelBind or
        NlBindingAddServerToCache.

Arguments:

    ClientSession - Session this binding handle is for

    ServerName - Name of server handle is to

    DebugInfo - Text string identifying the caller

    CaIndex - Index identifying which binding handle

    ContextHandle - Specifies handle to be unbound

    RpcBindingType - Type of binding

Return Value:

    None.

--*/
{

    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    NlPrintCs((NL_SESSION_SETUP, ClientSession,
        "%s: Unbind from server %ws (%s) %ld.\n",
        DebugInfo,
        ServerName,
        RpcBindingType == UseTcpIp ? "TCP" : "PIPE",
        CaIndex ));

    //
    // Some RPC handles are unbound via routines in netapi32
    //

    if ( CaIndex == 0 ) {

        Status = NlBindingRemoveServerFromCache(
                        ContextHandle,
                        RpcBindingType );


    //
    // Other RPC handles are handled directly in netlogon
    //

    } else {

        NetStatus = RpcpUnbindRpc( ContextHandle );

        Status = NetpApiStatusToNtStatus( NetStatus );
    }


    if ( Status != STATUS_SUCCESS ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
            "%s: Unbind from server %ws (%s) %ld failed. 0x%lX\n",
            DebugInfo,
            ServerName,
            RpcBindingType == UseTcpIp ? "TCP" : "PIPE",
            CaIndex,
            Status ));
    }

    UNREFERENCED_PARAMETER( DebugInfo );
    UNREFERENCED_PARAMETER( ServerName );
}




PCLIENT_SESSION
NlFindNamedClientSession(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN ULONG Flags,
    OUT PBOOLEAN TransitiveUsed OPTIONAL
    )
/*++

Routine Description:

    Find the specified entry in the Trust List.

Arguments:

    DomainInfo - Hosted domain of the client session to find

    DomainName - The NetbiosName or Dns Name of the domain to find

    Flags - Flags defining which client session to return:

        NL_DIRECT_TRUST_REQUIRED: Indicates that NULL should be returned
            if DomainName is not directly trusted.

        NL_RETURN_CLOSEST_HOP: Indicates that for indirect trust, the "closest hop"
            session should be returned rather than the actual session

        NL_ROLE_PRIMARY_OK: Indicates that if this is a PDC, it's OK to return
            the client session to the primary domain.

        NL_REQUIRE_DOMAIN_IN_FOREST - Indicates that DomainName must be a domain in
            the forest.

    TransitiveUsed - If specified and NL_RETURN_CLOSEST_HOP is specified,
        the returned boolean will be TRUE if transitive trust was used.

Return Value:

    Returns a pointer to the found entry.
    The found entry is returned referenced and must be dereferenced using
    NlUnrefClientSession.

    If there is no such entry, return NULL.

--*/
{
    PCLIENT_SESSION ClientSession = NULL;
    PLIST_ENTRY ListEntry;

    //
    // Lock trust list.
    //
    LOCK_TRUST_LIST( DomainInfo );
    if ( ARGUMENT_PRESENT( TransitiveUsed )) {
        *TransitiveUsed = FALSE;
    }

#ifdef _DC_NETLOGON
    //
    // On DC, look up the domain in the trusted domain list.
    //
    // Lookup the ClientSession with the TrustList locked and reference
    //  the found entry before dropping the lock.
    //

    if ( DomainInfo->DomRole == RoleBackup || DomainInfo->DomRole == RolePrimary ) {

        for ( ListEntry = DomainInfo->DomTrustList.Flink ;
              ListEntry != &DomainInfo->DomTrustList ;
              ListEntry = ListEntry->Flink) {

            ClientSession =
                CONTAINING_RECORD( ListEntry, CLIENT_SESSION, CsNext );

            if ( (ClientSession->CsNetbiosDomainName.Buffer != NULL &&
                  RtlEqualDomainName( &ClientSession->CsNetbiosDomainName,
                                      DomainName ) ) ||
                 (ClientSession->CsDnsDomainName.Buffer != NULL &&
                  NlEqualDnsNameU( &ClientSession->CsDnsDomainName,
                                   DomainName ) ) ) {

                //
                // If the caller requires a domain in the forest,
                //  Ensure this is one.
                //

                if ( (Flags & NL_REQUIRE_DOMAIN_IN_FOREST) != 0 &&
                     (ClientSession->CsFlags & CS_DOMAIN_IN_FOREST) == 0 ) {

                    ClientSession = NULL;
                    break;
                }

                //
                // If the found domain is not directly trusted,
                //  check if that's OK with the caller.
                //

                if ((ClientSession->CsFlags & CS_DIRECT_TRUST) == 0 ) {

                    //
                    // If the caller needs a direct trust,
                    //  simply indicate that the domain isn't trusted.
                    //

                    if ( Flags & NL_DIRECT_TRUST_REQUIRED ) {
                        ClientSession = NULL;
                        break;
                    }

                    //
                    // If the caller wants the closest Hop,
                    //  return that instead.
                    //

                    if ( Flags & NL_RETURN_CLOSEST_HOP ) {
                        //
                        // If there isn't a domain that's one hop closer than this one,
                        //  return failure to the caller.
                        //

                        if ( ClientSession->CsDirectClientSession == NULL ) {
                            ClientSession = NULL;
                            break;
                        }

                        //
                        // Otherwise return the client session that's one hop closer.
                        //

                        ClientSession = ClientSession->CsDirectClientSession;
                        if ( ARGUMENT_PRESENT( TransitiveUsed )) {
                            *TransitiveUsed = TRUE;
                        }
                    }


                }

                NlRefClientSession( ClientSession );
                break;
            }

            ClientSession = NULL;

        }

    }
#endif // _DC_NETLOGON

    //
    // On a workstation or BDC, refer to the Primary domain.
    // Also, if this is a PDC and it's OK to return its only
    // client session (to itself), refer to the Primary domain.
    //

    if ( (DomainInfo->DomRole == RoleBackup && ClientSession == NULL) ||
         (DomainInfo->DomRole == RolePrimary && ClientSession == NULL &&
            (Flags & NL_ROLE_PRIMARY_OK) ) ||
         DomainInfo->DomRole == RoleMemberWorkstation ) {

        ClientSession = NlRefDomClientSession( DomainInfo );

        if ( ClientSession != NULL ) {
            if ( RtlEqualDomainName( &DomainInfo->DomUnicodeDomainNameString,
                                     DomainName ) ||
                 DomainInfo->DomUnicodeDnsDomainNameString.Buffer != NULL &&
                 NlEqualDnsNameU( &DomainInfo->DomUnicodeDnsDomainNameString,
                                  DomainName ) ) {

                /* Drop Through */
            } else {
                NlUnrefClientSession( ClientSession );
                ClientSession = NULL;
            }

        }
    }

    UNLOCK_TRUST_LIST( DomainInfo );
    return ClientSession;

}


BOOL
NlSetNamesClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN PUNICODE_STRING DomainName OPTIONAL,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PSID DomainId OPTIONAL,
    IN GUID *DomainGuid OPTIONAL
    )
/*++

Routine Description:

    Set the name of the client session on the ClientSession structure.

        Enter with the domain trust list locked.
        The caller must be a writer of the trust list entry.



Arguments:

    ClientSession - Client session to update

    The next four parameters specify the names of the client session.
    All of the non-null names are updated on the client session structure.

        DomainId -- Domain Id of the domain to do the discovery for.

        DomainName -- Specifies the Netbios DomainName of the trusted domain.

        DnsDomainName - Specifies the Dns domain name of the trusted domain.

        DomainGuid - Specifies the GUID of the trusted domain


Return Value:

    TRUE: Names were successfully updated.

    FALSE: there was not enough memory available to update the names.

--*/
{
    WCHAR AccountNameBuffer[SSI_ACCOUNT_NAME_LENGTH+1];
    LPWSTR AccountName = NULL;
    NTSTATUS Status;

    NlAssert( ClientSession->CsReferenceCount > 0 );
    // We're not writer for a newly allocated structure, but it
    //  doesn't make any difference since it isn't linked anywhere.
    // NlAssert( ClientSession->CsFlags & CS_WRITER );

    //
    // If we now know the domain GUID,
    //  save it.
    //

    if ( ARGUMENT_PRESENT( DomainGuid ) ) {
        ClientSession->CsDomainGuidBuffer = *DomainGuid;
        ClientSession->CsDomainGuid = &ClientSession->CsDomainGuidBuffer;
    }


    //
    // If we now know the domain Sid,
    //  save it.
    //

    if ( ARGUMENT_PRESENT( DomainId ) ) {

        //
        // If the Domain Sid is already known,
        //  ditch the old sid if it is different that the new one.

        if ( ClientSession->CsDomainId != NULL &&
             !RtlEqualSid( ClientSession->CsDomainId, DomainId ) ) {
            LocalFree( ClientSession->CsDomainId );
            ClientSession->CsDomainId = NULL;
        }

        //
        // If the Domain Sid is not alreay known,
        //  Save the new one.
        //

        if ( ClientSession->CsDomainId == NULL ) {
            ULONG SidSize;

            SidSize = RtlLengthSid( DomainId );

            ClientSession->CsDomainId = LocalAlloc( 0, SidSize );

            if (ClientSession->CsDomainId == NULL ) {
                return FALSE;
            }

            RtlCopyMemory( ClientSession->CsDomainId, DomainId, SidSize );
        }
    }

    //
    // If we now know the Netbios domain name,
    //  save it.
    //

    if ( ARGUMENT_PRESENT(DomainName) ) {

        //
        // If the Netbios domain name is already known,
        //  ditch the old name if it is different than the new name.
        //

        if ( ClientSession->CsNetbiosDomainName.Length != 0 &&
             !RtlEqualDomainName( &ClientSession->CsNetbiosDomainName,
                                  DomainName ) ) {
            if ( ClientSession->CsDebugDomainName == ClientSession->CsNetbiosDomainName.Buffer ) {
                ClientSession->CsDebugDomainName = NULL;
            }
            NlFreeUnicodeString( &ClientSession->CsNetbiosDomainName );
            ClientSession->CsOemNetbiosDomainNameLength = 0;
            ClientSession->CsOemNetbiosDomainName[0] = '\0';
        }

        //
        // If there is no Netbios domain name,
        //  save the new one.
        //

        if ( ClientSession->CsNetbiosDomainName.Length == 0 ) {
            if ( !NlDuplicateUnicodeString( DomainName,
                                            &ClientSession->CsNetbiosDomainName ) ) {
                return FALSE;
            }
            if ( ClientSession->CsDebugDomainName == NULL ) {
                ClientSession->CsDebugDomainName = ClientSession->CsNetbiosDomainName.Buffer;
            }

            //
            // Convert the domain name to OEM for passing it over the wire.
            //
            Status = RtlUpcaseUnicodeToOemN( ClientSession->CsOemNetbiosDomainName,
                                             sizeof(ClientSession->CsOemNetbiosDomainName),
                                             &ClientSession->CsOemNetbiosDomainNameLength,
                                             DomainName->Buffer,
                                             DomainName->Length );

            if (!NT_SUCCESS(Status)) {
                NlPrint(( NL_CRITICAL, "%ws: Unable to convert Domain name to OEM 0x%lx\n", DomainName, Status ));
                return FALSE;
            }

            ClientSession->CsOemNetbiosDomainName[ClientSession->CsOemNetbiosDomainNameLength] = '\0';
        }
    }

    //
    // If we now know the DNS domain name,
    //  save it.
    //

    if ( ARGUMENT_PRESENT(DnsDomainName) ) {

        //
        // If the DNS domain name is already known,
        //  ditch the old name if it is different than the new name.
        //

        if ( ClientSession->CsDnsDomainName.Length != 0 &&
             !NlEqualDnsNameU( &ClientSession->CsDnsDomainName,
                               DnsDomainName ) ) {
            if ( ClientSession->CsDebugDomainName == ClientSession->CsDnsDomainName.Buffer ) {
                ClientSession->CsDebugDomainName = NULL;
            }
            NlFreeUnicodeString( &ClientSession->CsDnsDomainName );
            if ( ClientSession->CsUtf8DnsDomainName != NULL ) {
                NetpMemoryFree( ClientSession->CsUtf8DnsDomainName );
                ClientSession->CsUtf8DnsDomainName = NULL;
            }
        }

        //
        // If there is no DNS domain name,
        //  save the new one.
        //

        if ( ClientSession->CsDnsDomainName.Length == 0 ) {
            if ( !NlDuplicateUnicodeString( DnsDomainName,
                                            &ClientSession->CsDnsDomainName ) ) {
                return FALSE;
            }
            if ( ClientSession->CsDebugDomainName == NULL ) {
                ClientSession->CsDebugDomainName = ClientSession->CsDnsDomainName.Buffer;
            }

            if ( ClientSession->CsDnsDomainName.Buffer == NULL ) {
                ClientSession->CsUtf8DnsDomainName = NULL;
            } else {
                ClientSession->CsUtf8DnsDomainName = NetpAllocUtf8StrFromWStr( ClientSession->CsDnsDomainName.Buffer );
                if ( ClientSession->CsUtf8DnsDomainName == NULL ) {
                    return FALSE;
                }
            }
        }
    }


    //
    // If this is a direct trust relationship,
    //  build the name of the account in the trusted domain.
    //

    if ( ClientSession->CsFlags & CS_DIRECT_TRUST ) {
        //
        // Build the account name as a function of the SecureChannelType.
        //

        switch (ClientSession->CsSecureChannelType) {
        case WorkstationSecureChannel:
        case ServerSecureChannel:
            wcscpy( AccountNameBuffer, ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer );
            wcscat( AccountNameBuffer, SSI_ACCOUNT_NAME_POSTFIX);
            AccountName = AccountNameBuffer;
            break;

        case TrustedDomainSecureChannel:
            wcscpy( AccountNameBuffer, ClientSession->CsDomainInfo->DomUnicodeDomainName );
            wcscat( AccountNameBuffer, SSI_ACCOUNT_NAME_POSTFIX);
            AccountName = AccountNameBuffer;
            break;

        case TrustedDnsDomainSecureChannel:
            if ( ClientSession->CsDomainInfo->DomUnicodeDnsDomainName == NULL ) {
                NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSetNameClientSession: NT 5 DNS trust with no DnsDomainName.\n" ));
                return FALSE;

            }

            AccountName = ClientSession->CsDomainInfo->DomUnicodeDnsDomainName;
            break;

        default:
            return FALSE;
        }


        //
        // If the account name is already known,
        //  ditch the old name if it is different than the new name.
        //

        if ( ClientSession->CsAccountName != NULL &&
             _wcsicmp( ClientSession->CsAccountName, AccountName ) != 0 ) {

            NetApiBufferFree( ClientSession->CsAccountName );
            ClientSession->CsAccountName = NULL;
        }

        //
        // If there is no account name,
        //  save the new one.
        //

        if ( ClientSession->CsAccountName == NULL ) {
            ClientSession->CsAccountName = NetpAllocWStrFromWStr( AccountName );

            if ( ClientSession->CsAccountName == NULL ) {
                return FALSE;
            }
        }
    }

    return TRUE;

}



PCLIENT_SESSION
NlAllocateClientSession(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PSID DomainId,
    IN GUID *DomainGuid OPTIONAL,
    IN ULONG Flags,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN ULONG TrustAttributes
    )
/*++

Routine Description:

    Allocate a ClientSession structure and initialize it.

    The allocated entry is returned referenced and must be dereferenced using
    NlUnrefClientSession.

Arguments:

    DomainInfo - Hosted domain this session is for.

    DomainName - Specifies the DomainName of the entry.

    DnsDomainName - Specifies the DNS domain name of the trusted domain

    DomainId - Specifies the DomainId of the Domain.

    DomainGuid - Specifies the GUID of the trusted domain

    Flags - Specifies initial flags to set on the session

    SecureChannelType -- Type of secure channel this ClientSession structure
        will represent.

    TrustAttributes - The attributes of the trust corresponding to the
        trusted domain

Return Value:

    NULL: There's not enough memory to allocate the client session.

--*/
{
    PCLIENT_SESSION ClientSession;
    ULONG CaIndex;

    //
    // Validate the arguments
    //

    if ( DomainName != NULL &&
         DomainName->Length > DNLEN * sizeof(WCHAR) ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlAllocateClientSession given too long domain name %wZ\n",
                 DomainName ));
        return NULL;
    }


    //
    // Allocate the Client Session Entry
    //

    ClientSession = LocalAlloc( LMEM_ZEROINIT,
                                sizeof(CLIENT_SESSION) +
                                (NlGlobalMaxConcurrentApi-1) * sizeof(CLIENT_API) );

    if (ClientSession == NULL) {
        return NULL;
    }



    //
    // Initialize misc. fields.
    //

    ClientSession->CsSecureChannelType = SecureChannelType;
    ClientSession->CsFlags = Flags;
    ClientSession->CsState = CS_IDLE;
    ClientSession->CsReferenceCount = 1;
    ClientSession->CsConnectionStatus = STATUS_NO_LOGON_SERVERS;
    ClientSession->CsDomainInfo = DomainInfo;
    ClientSession->CsTrustAttributes = TrustAttributes;
    InitializeListHead( &ClientSession->CsNext );
    NlInitializeWorkItem(&ClientSession->CsAsyncDiscoveryWorkItem, NlDcDiscoveryWorker, ClientSession);

    for ( CaIndex=0; CaIndex<NlGlobalMaxConcurrentApi; CaIndex++ ) {
        ClientSession->CsClientApi[CaIndex].CaApiTimer.Period = MAILSLOT_WAIT_FOREVER;
    }

    //
    // Set the names of the trusted domain onto the Client session.
    //

    if ( !NlSetNamesClientSession( ClientSession,
                                   DomainName,
                                   DnsDomainName,
                                   DomainId,
                                   DomainGuid ) ) {
        NlUnrefClientSession( ClientSession );
        return NULL;
    }


    //
    // Create the writer semaphore.
    //

    ClientSession->CsWriterSemaphore = CreateSemaphore(
        NULL,       // No special security
        1,          // Initially not locked
        1,          // At most 1 unlocker
        NULL );     // No name

    if ( ClientSession->CsWriterSemaphore == NULL ) {
        NlUnrefClientSession( ClientSession );
        return NULL;
    }

    //
    // Create the API semaphore
    //

    if ( NlGlobalMaxConcurrentApi > 1 ) {

        ClientSession->CsApiSemaphore = CreateSemaphore(
            NULL,                       // No special security
            NlGlobalMaxConcurrentApi-1, // Initially all slots are free
            NlGlobalMaxConcurrentApi-1, // And there will never be more slots than that
            NULL );                     // No name

        if ( ClientSession->CsApiSemaphore == NULL ) {
            NlUnrefClientSession( ClientSession );
            return NULL;
        }

    }




    //
    // Create the Discovery event.
    //

    if ( SecureChannelType != WorkstationSecureChannel ) {
        ClientSession->CsDiscoveryEvent = CreateEvent(
            NULL,       // No special security
            TRUE,       // Manual Reset
            FALSE,      // No discovery initially happening
            NULL );     // No name

        if ( ClientSession->CsDiscoveryEvent == NULL ) {
            NlUnrefClientSession( ClientSession );
            return NULL;
        }
    }



    return ClientSession;


}


VOID
NlFreeClientSession(
    IN PCLIENT_SESSION ClientSession
    )
/*++

Routine Description:

    This routine prevents any new references to the ClientSession.
    It does this by removing it from any global lists.

    This routine is called with the Trust List locked.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry to delete.

Return Value:

--*/
{

    //
    // Remove any reference to the directly trusted domain.
    //  (Do this before checking the reference count since this may
    //  be a reference to itself.)
    //

    if ( ClientSession->CsDirectClientSession != NULL ) {
        NlUnrefClientSession( ClientSession->CsDirectClientSession );
        ClientSession->CsDirectClientSession = NULL;
    }

#ifdef _DC_NETLOGON
    //
    // If this is a trusted domain secure channel,
    //  Delink the entry from the sequential list.
    //

    if ( IsDomainSecureChannelType(ClientSession->CsSecureChannelType) &&
         !IsListEmpty( &ClientSession->CsNext) ) {

        RemoveEntryList( &ClientSession->CsNext );
        ClientSession->CsDomainInfo->DomTrustListLength --;
        //
        // Remove the reference for us being in the list.
        //
        NlUnrefClientSession( ClientSession );
    }
#endif // _DC_NETLOGON

}


VOID
NlRefClientSession(
    IN PCLIENT_SESSION ClientSession
    )
/*++

Routine Description:

    Mark the specified client session as referenced.

    On Entry,
        The trust list must be locked.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry.

Return Value:

    None.

--*/
{

    //
    // Simply increment the reference count.
    //

    ClientSession->CsReferenceCount ++;
}




VOID
NlUnrefClientSession(
    IN PCLIENT_SESSION ClientSession
    )
/*++

Routine Description:

    Mark the specified client session as unreferenced.

    On Entry,
        The trust list entry must be referenced by the caller.
        The caller must not be a writer of the trust list entry.

    The trust list may be locked.  But this routine will lock it again to
    handle those cases where it isn't already locked.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry.

Return Value:

--*/
{

    PDOMAIN_INFO DomainInfo = ClientSession->CsDomainInfo;
    ULONG CaIndex;

    LOCK_TRUST_LIST( DomainInfo );

    //
    // Dereference the entry.
    //

    NlAssert( ClientSession->CsReferenceCount > 0 );
    ClientSession->CsReferenceCount --;
    // NlPrintCs((NL_CRITICAL, ClientSession, "Deref: %ld\n", ClientSession->CsReferenceCount ));

    //
    // If we're the last reference,
    //  delete the entry.
    //

    if ( ClientSession->CsReferenceCount == 0 ) {

        //
        // Close the discovery event if it exists.
        //

        if ( ClientSession->CsDiscoveryEvent != NULL ) {
            CloseHandle( ClientSession->CsDiscoveryEvent );
        }

        //
        // Close the write synchronization handles.
        //

        if ( ClientSession->CsWriterSemaphore != NULL ) {
            (VOID) CloseHandle( ClientSession->CsWriterSemaphore );
        }

        //
        // Close the API synchronization handles.
        //

        if ( ClientSession->CsApiSemaphore != NULL ) {
            (VOID) CloseHandle( ClientSession->CsApiSemaphore );
        }


        //
        // Clean any outstanding API calls
        //

        for ( CaIndex=0; CaIndex<NlGlobalMaxConcurrentApi; CaIndex++ ) {
            PCLIENT_API ClientApi;

            ClientApi = &ClientSession->CsClientApi[CaIndex];

            //
            // Close the thread handle if it exists.
            //

            if ( ClientApi->CaThreadHandle != NULL ) {
                CloseHandle( ClientApi->CaThreadHandle );
            }

            //
            // If there is an rpc binding handle to this server,
            //  unbind it.

            if ( ClientApi->CaFlags & CA_BINDING_CACHED ) {

                //
                // Indicate the handle is no longer bound
                //

                NlGlobalBindingHandleCount --;


                //
                // Unbind the handle
                //
                NlAssert( ClientSession->CsUncServerName != NULL );
                NlpSecureChannelUnbind(
                            ClientSession,
                            ClientSession->CsUncServerName,
                            "NlFreeClientSession",
                            CaIndex,
                            ClientApi->CaRpcHandle,
                            (ClientApi->CaFlags & CA_TCP_BINDING) ? UseTcpIp : UseNamedPipe);

            }
        }

        //
        // Free the credentials handle
        //

        if ( ClientSession->CsCredHandle.dwUpper != 0 || ClientSession->CsCredHandle.dwLower != 0 ) {
            FreeCredentialsHandle( &ClientSession->CsCredHandle );
            ClientSession->CsCredHandle.dwUpper = 0;
            ClientSession->CsCredHandle.dwLower = 0;
        }

        //
        // If there is authentication data,
        //  delete it.

        if ( ClientSession->ClientAuthData != NULL ) {
            NetpMemoryFree( ClientSession->ClientAuthData );
            ClientSession->ClientAuthData = NULL;
        }

        //
        // Free the domain Sid
        //

        if ( ClientSession->CsDomainId != NULL ) {
            LocalFree( ClientSession->CsDomainId );
            ClientSession->CsDomainId = NULL;
        }

        //
        // Free the Netbios domain name.
        //

        if ( ClientSession->CsNetbiosDomainName.Buffer != NULL ) {
            NlFreeUnicodeString( &ClientSession->CsNetbiosDomainName );
        }
        ClientSession->CsOemNetbiosDomainNameLength = 0;
        ClientSession->CsOemNetbiosDomainName[0] = '\0';

        //
        // Free the DNS domain name.
        //

        if ( ClientSession->CsDnsDomainName.Buffer != NULL ) {
            NlFreeUnicodeString( &ClientSession->CsDnsDomainName );
        }
        if ( ClientSession->CsUtf8DnsDomainName != NULL ) {
            NetpMemoryFree( ClientSession->CsUtf8DnsDomainName );
            ClientSession->CsUtf8DnsDomainName = NULL;
        }

        //
        // Free the DC name.
        //

        if ( ClientSession->CsUncServerName != NULL ) {
            NetApiBufferFree( ClientSession->CsUncServerName );
            ClientSession->CsUncServerName = NULL;
        }

        //
        // Delete the entry itself
        //

        LocalFree( ClientSession );
    }

    UNLOCK_TRUST_LIST( DomainInfo );

}




PCLIENT_API
NlAllocateClientApi(
    IN PCLIENT_SESSION ClientSession,
    IN DWORD Timeout
    )
/*++

Routine Description:

    This routine allocates a ClientApi structure for use by the caller.

    Fail the operation if we have to wait more than Timeout milliseconds.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.
        The caller must NOT be a writer of the trust list entry.

    Actually, the trust list can be locked if the caller passes in a short
    timeout (for instance, zero milliseconds.)  Specifying a longer timeout
    violates the locking order.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry.

    Timeout - Maximum time (in milliseconds) to wait for an API slot to become
        available.

Return Value:

    NULL - The call timed out.

    Non-NULL - Return a pointer to a ClientApi structure that should be
        freed using NlFreeClientApi.

--*/
{
    DWORD WaitStatus;
    ULONG CaIndex;

    NlAssert( ClientSession->CsReferenceCount > 0 );

    //
    // If we aren't doing concurrent API calls,
    //  we're done.
    //

    if ( NlGlobalMaxConcurrentApi == 1 ||
         NlGlobalWinsockPnpAddresses == NULL ) {
        return &ClientSession->CsClientApi[0];
    }

    //
    // Wait for an API slot to free up.
    //

    WaitStatus = WaitForSingleObject( ClientSession->CsApiSemaphore, Timeout );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                  "NlAllocateClientApi timed out: %ld %ld\n",
                  GetLastError(),
                  WaitStatus ));
        return NULL;
    }

    //
    // Take the next available slot.
    //
    //  Don't use the first slot.  It is reserved for non concurrent API calls.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    for ( CaIndex=1; CaIndex < NlGlobalMaxConcurrentApi; CaIndex++ ) {

        if ( (ClientSession->CsClientApi[CaIndex].CaFlags & CA_ENTRY_IN_USE) == 0 ) {
            ClientSession->CsClientApi[CaIndex].CaFlags |= CA_ENTRY_IN_USE;
            UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
            return &ClientSession->CsClientApi[CaIndex];
        }

    }
    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

    NlAssert( FALSE );
    NlPrintCs(( NL_CRITICAL, ClientSession,
              "NlAllocateClientApi all entries are in use. (This can't happen)\n" ));


    return NULL;

}


VOID
NlFreeClientApi(
    IN PCLIENT_SESSION ClientSession,
    IN PCLIENT_API ClientApi
    )
/*++

Routine Description:

    This routine frees a ClientApi structure allocated by NlAllocateClientApi

    On Entry,
        The trust list entry must be referenced by the caller.
        The caller must NOT be a writer of the trust list entry.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry.

    ClientApi - The Client API stucture to free

Return Value:

    None.

--*/
{
    DWORD WaitStatus;

    NlAssert( ClientSession->CsReferenceCount > 0 );

    //
    // If we aren't doing concurrent API calls,
    //  we're done.
    //

    if ( !UseConcurrentRpc( ClientSession, ClientApi)  ) {
        return;
    }
    NlAssert( !IsApiActive( ClientApi ) );

    //
    // Free the entry
    //
    // The RPC binding is maintained past this free.  It is available for
    // the next thread to use.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );

    //
    // The entry must be in use
    //

    NlAssert( ClientApi->CaFlags & CA_ENTRY_IN_USE );

    ClientApi->CaFlags &= ~CA_ENTRY_IN_USE;

    //
    // Close the handle of this thread.
    //

    if ( ClientApi->CaThreadHandle != NULL ) {
        CloseHandle( ClientApi->CaThreadHandle );
        ClientApi->CaThreadHandle = NULL;
    }

    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );


    //
    // Allow someone else to have this slot.
    //

    if ( !ReleaseSemaphore( ClientSession->CsApiSemaphore, 1, NULL ) ) {
        NlAssert( !"ReleaseSemaphore failed" );
        NlPrintCs((NL_CRITICAL, ClientSession,
                "ReleaseSemaphore CsApiSemaphore returned %ld\n",
                GetLastError() ));
    }


    return;
}




BOOL
NlTimeoutSetWriterClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN DWORD Timeout
    )
/*++

Routine Description:

    Become a writer of the specified client session but fail the operation if
    we have to wait more than Timeout milliseconds.

    A writer can "write" many of the fields in the client session structure.
    See the comments in ssiinit.h for details.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.
        The caller must NOT be a writer of the trust list entry.

    Actually, the trust list can be locked if the caller passes in a short
    timeout (for instance, zero milliseconds.)  Specifying a longer timeout
    violates the locking order.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry.

    Timeout - Maximum time (in milliseconds) to wait for a previous writer.

Return Value:

    TRUE - The caller is now the writer of the client session.

    FALSE - The operation has timed out.

--*/
{
    DWORD WaitStatus;
    NlAssert( ClientSession->CsReferenceCount > 0 );

    //
    // Wait for other writers to finish.
    //

    WaitStatus = WaitForSingleObject( ClientSession->CsWriterSemaphore, Timeout );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                  "NlTimeoutSetWriterClientSession timed out: %ld %ld\n",
                  GetLastError(),
                  WaitStatus ));
        return FALSE;
    }


    //
    // Become a writer.
    //
    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    ClientSession->CsFlags |= CS_WRITER;
    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

    return TRUE;

}



VOID
NlResetWriterClientSession(
    IN PCLIENT_SESSION ClientSession
    )
/*++

Routine Description:

    Stop being a writer of the specified client session.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.
        The caller must be a writer of the trust list entry.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry.

Return Value:

--*/
{

    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsFlags & CS_WRITER );


    //
    // Stop being a writer.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    ClientSession->CsFlags &= ~CS_WRITER;

    //
    // Close the handle of this thread.
    //
    // The zeroeth API slot is reserved for non-concurrent API calls.
    // As such, if the ThreadHandle is set, it had to have been set by this thread.
    //

    if ( ClientSession->CsClientApi[0].CaThreadHandle != NULL ) {
        CloseHandle( ClientSession->CsClientApi[0].CaThreadHandle );
        ClientSession->CsClientApi[0].CaThreadHandle = NULL;
    }
    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );


    //
    // Allow writers to try again.
    //

    if ( !ReleaseSemaphore( ClientSession->CsWriterSemaphore, 1, NULL ) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "ReleaseSemaphore CsWriterSemaphore returned %ld\n",
                GetLastError() ));
    }

}



VOID
NlSetStatusClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN NTSTATUS CsConnectionStatus
    )
/*++

Routine Description:

    Set the connection state for this client session.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.
        The caller must be a writer of the trust list entry.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry.

    CsConnectionStatus - the status of the connection.

Return Value:

--*/
{
    handle_t OldRpcHandle[MAX_MAXCONCURRENTAPI+1];
    NL_RPC_BINDING OldRpcBindingType[MAX_MAXCONCURRENTAPI+1];
    BOOLEAN FreeHandles = FALSE;
    LPWSTR SavedServerName = NULL;


    ULONG CaIndex;

    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsFlags & CS_WRITER );

    NlPrintCs((NL_SESSION_SETUP, ClientSession,
            "NlSetStatusClientSession: Set connection status to %lx\n",
            CsConnectionStatus ));

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
    ClientSession->CsConnectionStatus = CsConnectionStatus;
    if ( NT_SUCCESS(CsConnectionStatus) ) {
        ClientSession->CsState = CS_AUTHENTICATED;

    //
    // Handle setting the connection status to an error condition.
    //

    } else {

        //
        // If there is an rpc binding handle to this server,
        //  unbind it.

        LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
        for ( CaIndex=0; CaIndex<NlGlobalMaxConcurrentApi; CaIndex++ ) {
            PCLIENT_API ClientApi;

            ClientApi = &ClientSession->CsClientApi[CaIndex];

            if ( ClientApi->CaFlags & CA_BINDING_CACHED ) {

                //
                // If the API call is still active,
                //  we can't simply unbind.
                //
                // Rather cancel the call an let the thread doing the call
                // find out that the session was dropped.
                //

                if ( IsApiActive( ClientApi ) ) {


                    //
                    // Cancel the RPC call.
                    //
                    // Keep the trust list locked even though this will be a long call
                    //  since I have to protect the thread handle.
                    //
                    // RpcCancelThread merely queues a workitem anyway.
                    //

                    if ( ClientApi->CaThreadHandle != NULL ) {

                        NET_API_STATUS NetStatus;

                        NlPrintCs(( NL_CRITICAL, ClientSession,
                               "NlSetStatusClientSession: Start RpcCancelThread on %ws\n",
                               ClientSession->CsUncServerName ));

                        NetStatus = RpcCancelThread( ClientApi->CaThreadHandle );

                        NlPrintCs(( NL_CRITICAL, ClientSession,
                               "NlSetStatusClientSession: Finish RpcCancelThread on %ws %ld\n",
                               ClientSession->CsUncServerName,
                               NetStatus ));
                    } else {
                        NlPrintCs(( NL_CRITICAL, ClientSession,
                                    "NlSetStatusClientSession: No thread handle so can't cancel RPC on %ws\n",
                                    ClientSession->CsUncServerName ));
                    }

                //
                // If there is no active API,
                //  just unbind the handle
                //
                } else {

                    if ( !FreeHandles ) {
                        FreeHandles = TRUE;
                        RtlZeroMemory( &OldRpcHandle, sizeof(OldRpcHandle) );
                        RtlZeroMemory( &OldRpcBindingType, sizeof(OldRpcBindingType) );
                    }


                    //
                    // Figure out the binding type to unbind.
                    //

                    OldRpcBindingType[CaIndex] =
                        (ClientApi->CaFlags & CA_TCP_BINDING) ? UseTcpIp : UseNamedPipe;

                    //
                    // Indicate the handle is no longer bound
                    //

                    ClientApi->CaFlags &= ~(CA_BINDING_CACHED|CA_BINDING_AUTHENTICATED|CA_TCP_BINDING);
                    NlGlobalBindingHandleCount --;

                    //
                    // Save the server name.
                    //

                    if ( SavedServerName == NULL &&
                         ClientSession->CsUncServerName != NULL ) {
                        SavedServerName = NetpAllocWStrFromWStr( ClientSession->CsUncServerName );
                        NlAssert( SavedServerName != NULL );
                    }


                    //
                    // Some RPC handles are unbound via routines in netapi32
                    //

                    if ( !UseConcurrentRpc( ClientSession, ClientApi)  ) {

                        //
                        // Capture the ServerName
                        //

                        NlAssert( ClientSession->CsUncServerName != NULL && SavedServerName != NULL );
                        OldRpcHandle[CaIndex] = SavedServerName;


                    //
                    // Other RPC handles are handled directly in netlogon
                    //

                    } else {
                        OldRpcHandle[CaIndex] = ClientApi->CaRpcHandle;
                    }
                    ClientApi->CaRpcHandle = NULL;
                }

            }
        }
        UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

        //
        // Free the credentials handle
        //

        if ( ClientSession->CsCredHandle.dwUpper != 0 || ClientSession->CsCredHandle.dwLower != 0 ) {
            FreeCredentialsHandle( &ClientSession->CsCredHandle );
            ClientSession->CsCredHandle.dwUpper = 0;
            ClientSession->CsCredHandle.dwLower = 0;
        }

        //
        // If there is authentication data,
        //  delete it.

        if ( ClientSession->ClientAuthData != NULL ) {
            NetpMemoryFree( ClientSession->ClientAuthData );
            ClientSession->ClientAuthData = NULL;
        }


        //
        // Indicate discovery is needed (And can be done at any time.)
        //

        ClientSession->CsState = CS_IDLE;
        if ( ClientSession->CsUncServerName != NULL ) {
            NetApiBufferFree( ClientSession->CsUncServerName );
            ClientSession->CsUncServerName = NULL;
        }

        //
        // Zero out the server socket address
        //

        RtlZeroMemory( &ClientSession->CsServerSockAddr,
                       sizeof(ClientSession->CsServerSockAddr) );
        RtlZeroMemory( &ClientSession->CsServerSockAddrIn,
                       sizeof(ClientSession->CsServerSockAddrIn) );

#ifdef _DC_NETLOGON
        ClientSession->CsTransport = NULL;
#endif // _DC_NETLOGON
        ClientSession->CsTimeoutCount = 0;
        ClientSession->CsFastCallCount = 0;
        ClientSession->CsLastAuthenticationTry.QuadPart = 0;
        ClientSession->CsDiscoveryFlags &= ~(CS_DISCOVERY_HAS_DS|
                                             CS_DISCOVERY_IS_CLOSE|
                                             CS_DISCOVERY_HAS_IP|
                                             CS_DISCOVERY_USE_MAILSLOT|
                                             CS_DISCOVERY_USE_LDAP|
                                             CS_DISCOVERY_HAS_TIMESERV|
                                             CS_DISCOVERY_DNS_SERVER|
                                             CS_DISCOVERY_NO_PWD_MONITOR|
                                             CS_DISCOVERY_NO_PWD_ATTR_MONITOR);
        ClientSession->CsSessionCount++;

        //
        // Don't be tempted to clear CsAuthenticationSeed and CsSessionKey here.
        // Even though the secure channel is gone, NlFinishApiClientSession may
        // have dropped it.  The caller of NlFinishApiClientSession will use
        // the above two fields after the session is dropped in an attempt to
        // complete the final call on the secure channel.
        //

        //
        // Also note that we don't clear CsAccountRid because it doesn't change
        //  often, so we can reuse it on failover if we cannot reset the secure
        //  channel for some reason.
        //

    }

    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );


    //
    // Now that I have as many resources unlocked as possible,
    //    Unbind from this server.
    //

    if ( FreeHandles ) {

        for ( CaIndex=0; CaIndex<NlGlobalMaxConcurrentApi; CaIndex++ ) {

            //
            // Skip indices that don't have an active API
            //

            if ( OldRpcHandle[CaIndex] == NULL ) {
                continue;
            }

            //
            // Unbind the handle
            //

            NlpSecureChannelUnbind(
                        ClientSession,
                        SavedServerName,
                        "NlSetStatusClientSession",
                        CaIndex,
                        OldRpcHandle[CaIndex],
                        OldRpcBindingType[CaIndex] );

        }

        if ( SavedServerName != NULL ) {
            NetApiBufferFree( SavedServerName );
        }
    }

}

#ifdef _DC_NETLOGON
#ifdef notdef

PLSAPR_TREE_TRUST_INFO
NlFindParentInDomainTree(
    IN PDOMAIN_INFO DomainInfo,
    IN PLSAPR_TREE_TRUST_INFO TreeTrustInfo,
    OUT PBOOLEAN ThisNodeIsSelf
    )
/*++

Routine Description:

    This routine walks the trust tree and returns a pointer to the entry
    for our parent.

Arguments:

    DomainInfo - Hosted domain to initialize

    TreeTrustInfo - Structure describing the tree of domains.

    ThisNodeIsSelf - Returns TRUE if the node at TreeTrustInfo is this
        domain.  (Return value will be NULL)

Return Value:

    Returns a pointer to the parent of this domain.

    NULL: Parent is not in the subtree.

--*/
{
    NTSTATUS Status;

    // LSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInformation;
    // PCLIENT_SESSION ThisDomainClientSession = NULL;
    ULONG Index;
    BOOLEAN ChildIsSelf;
    PLSAPR_TREE_TRUST_INFO LocalTreeTrustInfo;


    //
    // Check if this tree has us as the root
    //

    if ( (TreeTrustInfo->DnsDomainName.Length != 0 &&
          NlEqualDnsNameU( (PUNICODE_STRING)&TreeTrustInfo->DnsDomainName,
                          &DomainInfo->DomUnicodeDnsDomainNameString ) ) ||
          RtlEqualDomainName( &DomainInfo->DomUnicodeDomainNameString,
                             (PUNICODE_STRING)&TreeTrustInfo->FlatName ) ) {

        *ThisNodeIsSelf = TRUE;
        return NULL;
    }


    //
    // Loop handling each of the children domains.
    //

    for ( Index=0; Index<TreeTrustInfo->Children; Index++ ) {

        //
        // Check the subtree rooted at this domain's children.
        //

        LocalTreeTrustInfo = NlFindParentInDomainTree(
                    DomainInfo,
                    &TreeTrustInfo->ChildDomains[Index],
                    &ChildIsSelf );

        //
        // If our parent has been found,
        //  return it to our caller.
        //
        if ( LocalTreeTrustInfo != NULL) {
            *ThisNodeIsSelf = FALSE;
            return LocalTreeTrustInfo;
        }

        //
        // If this child is our domain,
        //  then this domain is our domain's parent.
        //

        if ( ChildIsSelf ) {
            *ThisNodeIsSelf = FALSE;
            return TreeTrustInfo;
        }
    }

    //
    // Our domain isn't in this subtree
    //
    *ThisNodeIsSelf = FALSE;
    return NULL;

}
#endif // notdef




VOID
NlPickTrustedDcForEntireTrustList(
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN OnlyDoNewTrusts
    )
/*++

Routine Description:

    For each domain in the trust list where the DC has not been
    available for at least 45 seconds, try to select a new DC.

Arguments:

    DomainInfo - Hosted domain to handle.

    OnlyDoNewTrusts - True if only new trust relationships are to be done.

Return Value:

    Status of the operation.

--*/
{
    PLIST_ENTRY ListEntry;
    PCLIENT_SESSION ClientSession;
    DISCOVERY_TYPE DiscoveryType;

    //
    // If we're just handling new trusts,
    //  Make the discovery a full async discovery.
    //

    if ( OnlyDoNewTrusts ) {
        DiscoveryType = DT_Asynchronous;

    //
    // If we're just scavenging trusts,
    //  make the discovery a dead domain discovery.
    //
    } else {
        DiscoveryType = DT_DeadDomain;
    }


    LOCK_TRUST_LIST( DomainInfo );

    //
    // Mark each entry to indicate we need to pick a DC.
    //

    for ( ListEntry = DomainInfo->DomTrustList.Flink ;
          ListEntry != &DomainInfo->DomTrustList ;
          ListEntry = ListEntry->Flink) {

        ClientSession = CONTAINING_RECORD( ListEntry,
                                           CLIENT_SESSION,
                                           CsNext );
        ClientSession->CsFlags &= ~CS_PICK_DC;

        //
        // Only pick a DC if the domain is directly trusted.
        //  Only pick a DC if the domain isn't in the current forest.
        if ( (ClientSession->CsFlags & (CS_DIRECT_TRUST|CS_DOMAIN_IN_FOREST)) == CS_DIRECT_TRUST ) {

            //
            // Only pick a DC if we're doing ALL trusts, OR
            //  if this is a new trust
            //

            if ( !OnlyDoNewTrusts ||
                 (ClientSession->CsFlags & CS_NEW_TRUST) != 0 ) {

                ClientSession->CsFlags |= CS_PICK_DC;
            }

            ClientSession->CsFlags &= ~CS_NEW_TRUST;

        }
    }


    //
    // Loop thru the trust list finding secure channels needing the DC
    // to be picked.
    //
    for ( ListEntry = DomainInfo->DomTrustList.Flink ;
          ListEntry != &DomainInfo->DomTrustList ;
          ) {

        ClientSession = CONTAINING_RECORD( ListEntry,
                                           CLIENT_SESSION,
                                           CsNext );

        //
        // If we've already done this entry,
        //  skip this entry.
        //
        if ( (ClientSession->CsFlags & CS_PICK_DC) == 0 ) {
          ListEntry = ListEntry->Flink;
          continue;
        }
        ClientSession->CsFlags &= ~CS_PICK_DC;

        //
        // If the DC is already picked,
        //  skip this entry.
        //
        if ( ClientSession->CsState != CS_IDLE ) {
            ListEntry = ListEntry->Flink;
            continue;
        }

        //
        // Reference this entry while picking the DC.
        //

        NlRefClientSession( ClientSession );

        UNLOCK_TRUST_LIST( DomainInfo );

        //
        // Check if we've tried to authenticate recently.
        //  (Don't call NlTimeToReauthenticate with the trust list locked.
        //  It locks NlGlobalDcDiscoveryCritSect.  That's the wrong locking
        //  order.)
        //

        if ( NlTimeToReauthenticate( ClientSession ) ) {

            //
            // Try to pick the DC for the session.
            //

            if ( NlTimeoutSetWriterClientSession( ClientSession, 10*1000 ) ) {
                if ( ClientSession->CsState == CS_IDLE ) {

                    //
                    // Don't ask for with-account discovery as it's too costly on the
                    //  server side. If the discovered server doesn't have our account,
                    //  the session setup logic will attempt with-account discovery.
                    //
                    (VOID) NlDiscoverDc( ClientSession,
                                         DiscoveryType,
                                         FALSE,
                                         FALSE );  // don't specify account

                }
                NlResetWriterClientSession( ClientSession );
            }

        }

        //
        // Since we dropped the trust list lock,
        //  we'll start the search from the front of the list.
        //

        NlUnrefClientSession( ClientSession );
        LOCK_TRUST_LIST( DomainInfo );

        ListEntry = DomainInfo->DomTrustList.Flink ;

    }

    UNLOCK_TRUST_LIST( DomainInfo );

    //
    // On a BDC,
    //  ensure we know who the PDC is.
    //
    // In NT 3.1, we relied on the fact that the PDC sent us pulses every 5
    // minutes.  For NT 3.5, the PDC backs off after 3 such failed attempts and
    // will only send a pulse every 2 hours.  So, we'll take on the
    // responsibility
    //

    if ( DomainInfo->DomRole == RoleBackup ) {
        ClientSession = NlRefDomClientSession( DomainInfo );

        if ( ClientSession != NULL ) {
            if ( ClientSession->CsState == CS_IDLE ) {



                //
                // Check if we've tried to authenticate recently.
                //  (Don't call NlTimeToReauthenticate with the trust list locked.
                //  It locks NlGlobalDcDiscoveryCritSect.  That's the wrong locking
                //  order.)
                //

                if ( NlTimeToReauthenticate( ClientSession ) ) {

                    //
                    // Try to pick the DC for the session.
                    //

                    if ( NlTimeoutSetWriterClientSession( ClientSession, 10*1000 ) ) {
                        if ( ClientSession->CsState == CS_IDLE ) {

                            //
                            // Don't ask for with-account discovery
                            //  as there is only one PDC
                            //
                            (VOID) NlDiscoverDc( ClientSession,
                                                 DT_DeadDomain,
                                                 FALSE,
                                                 FALSE );  // don't specify account
                        }
                        NlResetWriterClientSession( ClientSession );
                    }

                }

            }
            NlUnrefClientSession( ClientSession );
        }
    }

}
#endif // _DC_NETLOGON


BOOL
NlReadSamLogonResponse (
    IN HANDLE ResponseMailslotHandle,
    IN LPWSTR AccountName,
    OUT LPDWORD Opcode,
    OUT LPWSTR *LogonServer,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry OPTIONAL
    )

/*++

Routine Description:

    Read a response from to a SamLogonRequest.

Arguments:

    ResponseMailslotHandle - Handle of mailslot to read.

    AccountName - Name of the account the response is for.

    Opcode - Returns the opcode from the message.  This will be one of
        LOGON_SAM_LOGON_RESPONSE or LOGON_SAM_USER_UNKNOWN.

    LogonServer - Returns the name of the logon server that responded.
        This buffer is only returned if a valid message was received.
        The buffer returned should be freed via NetpMemoryFree.

    NlDcCacheEntry - Returns the data structure describing the response
        received from the server.  Should be freed by calling NetpDcDerefCacheEntry.


Return Value:

    TRUE: a valid message was received.
    FALSE: a valid message was not received.

--*/
{
    NET_API_STATUS NetStatus;
    CHAR ResponseBuffer[MAX_RANDOM_MAILSLOT_RESPONSE];
    DWORD SamLogonResponseSize;
    PNL_DC_CACHE_ENTRY NlLocalDcCacheEntry = NULL;
    PCHAR Where;
    DWORD Version;
    DWORD VersionFlags;

    //
    // Loop ignoring responses which are garbled.
    //

    for ( ;; ) {

        //
        // Read the response from the response mailslot
        //  (This mailslot is set up with a 5 second timeout).
        //

        if ( !ReadFile( ResponseMailslotHandle,
                           ResponseBuffer,
                           sizeof(ResponseBuffer),
                           &SamLogonResponseSize,
                           NULL ) ) {

            IF_NL_DEBUG( MAILSLOT ) {
                NET_API_STATUS NetStatus;
                NetStatus = GetLastError();

                if ( NetStatus != ERROR_SEM_TIMEOUT ) {
                    NlPrint((NL_CRITICAL,
                        "NlReadSamLogonResponse: cannot read response mailslot: %ld\n",
                        NetStatus ));
                }
            }
            return FALSE;
        }

        NlPrint((NL_MAILSLOT_TEXT, "NlReadSamLogonResponse opcode 0x%x\n",
                        ((PNETLOGON_SAM_LOGON_RESPONSE)ResponseBuffer)->Opcode ));

        NlpDumpBuffer(NL_MAILSLOT_TEXT, ResponseBuffer, SamLogonResponseSize);

        //
        // Parse the response
        //

        NetStatus = NetpDcParsePingResponse(
                        AccountName,
                        ResponseBuffer,
                        SamLogonResponseSize,
                        &NlLocalDcCacheEntry );

        if ( NetStatus != NO_ERROR ) {
            NlPrint((NL_CRITICAL,
                    "NlReadSamLogonResponse: can't parse response. %ld\n",
                    NetStatus ));
            continue;
        }

        //
        // Ensure the opcode is expected.
        //  (Ignore responses from paused DCs, too.)
        //

        if ( NlLocalDcCacheEntry->Opcode != LOGON_SAM_LOGON_RESPONSE &&
             NlLocalDcCacheEntry->Opcode != LOGON_SAM_USER_UNKNOWN ) {
            NlPrint((NL_CRITICAL,
                    "NlReadSamLogonResponse: response opcode not valid. 0x%lx\n",
                    NlLocalDcCacheEntry->Opcode ));

        //
        // If the user name is missing,
        //  ignore the message.
        //

        } else if ( NlLocalDcCacheEntry->UnicodeUserName == NULL ) {
            NlPrint((NL_CRITICAL,
                    "NlReadSamLogonResponse: username missing\n" ));

        //
        // If the server name is missing,
        //  ignore the message.
        //

        } else if ( NlLocalDcCacheEntry->UnicodeNetbiosDcName == NULL ) {
            NlPrint((NL_CRITICAL,
                    "NlReadSamLogonResponse: severname missing\n" ));

        //
        // If the response is for the wrong account,
        //  ignore the response.
        //

        } else if ( NlNameCompare( AccountName, NlLocalDcCacheEntry->UnicodeUserName, NAMETYPE_USER) != 0 ) {
            NlPrint((NL_CRITICAL,
                    "NlReadSamLogonResponse: User name %ws  s.b. %ws.\n",
                    NlLocalDcCacheEntry->UnicodeUserName,
                    AccountName ));

        //
        // Otherwise use this response.
        //

        } else {
            break;
        }


        NetpDcDerefCacheEntry( NlLocalDcCacheEntry );
        NlLocalDcCacheEntry = NULL;

    }

    //
    // Return the info to the caller.
    //

    *Opcode = NlLocalDcCacheEntry->Opcode;
    *LogonServer = NetpAllocWStrFromWStr( NlLocalDcCacheEntry->UnicodeNetbiosDcName );

    if ( *LogonServer == NULL ) {

        if ( NlLocalDcCacheEntry != NULL ) {
            NetpDcDerefCacheEntry( NlLocalDcCacheEntry );
        }
        return FALSE;

    }

    if ( NlDcCacheEntry != NULL ) {
        *NlDcCacheEntry = NlLocalDcCacheEntry;
    }

    return TRUE;

}


NET_API_STATUS
NlReadRegTrustedDomainList (
    IN PDOMAIN_INFO DomainInfo,
    IN BOOL DeleteName,
    OUT PDS_DOMAIN_TRUSTSW *RetForestTrustList,
    OUT PULONG RetForestTrustListSize,
    OUT PULONG RetForestTrustListCount
    )

/*++

Routine Description:

    Read the list of trusted domains from the registry.

Arguments:

    DomainInfo - Hosted domain of the primary domain

    DeleteName - TRUE if the name is to be deleted upon successful completion.

    RetForestTrustList - Specifies a list of trusted domains.
        This buffer should be free using NetApiBufferFree().

    RetForestTrustListSize - Size (in bytes) of RetForestTrustList

    RetForestTrustListCount - Number of entries in RetForestTrustList

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    LPNET_CONFIG_HANDLE SectionHandle = NULL;
    LPTSTR_ARRAY TStrArray;
    LPTSTR_ARRAY TrustedDomainList = NULL;
    BUFFER_DESCRIPTOR BufferDescriptor;

    PDS_DOMAIN_TRUSTSW TrustedDomain;
    ULONG Size;

    //
    // Initialization
    //

    *RetForestTrustList = NULL;
    *RetForestTrustListCount = 0;
    *RetForestTrustListSize = 0;
    BufferDescriptor.Buffer = NULL;

    //
    // The registry doesn't have the PrimaryDomain.  (Add it here).
    //
    Status = NlAllocateForestTrustListEntry (
                        &BufferDescriptor,
                        &DomainInfo->DomUnicodeDomainNameString,
                        &DomainInfo->DomUnicodeDnsDomainNameString,
                        DS_DOMAIN_PRIMARY,
                        0,      // No ParentIndex
                        TRUST_TYPE_DOWNLEVEL,
                        0,      // No TrustAttributes
                        DomainInfo->DomAccountDomainId,
                        DomainInfo->DomDomainGuid,
                        &Size,
                        &TrustedDomain );

    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    *RetForestTrustListSize += Size;
    (*RetForestTrustListCount) ++;

    //
    // Open the NetLogon configuration section.
    //

    NetStatus = NetpOpenConfigData(
                    &SectionHandle,
                    NULL,                       // no server name.
                    SERVICE_NETLOGON,
                    !DeleteName );               // Get Write access if deleting.

    if ( NetStatus != NO_ERROR ) {
        NlPrint((NL_CRITICAL,
                "NlReadRegTrustedDomainList: NetpOpenConfigData failed: %ld\n",
                NetStatus ));
        goto Cleanup;
    }

    //
    // Get the "TrustedDomainList" configured parameter
    //

    NetStatus = NetpGetConfigTStrArray (
            SectionHandle,
            NETLOGON_KEYWORD_TRUSTEDDOMAINLIST,
            &TrustedDomainList );                  // Must be freed by NetApiBufferFree().

    //
    // Handle the default
    //

    if (NetStatus == NERR_CfgParamNotFound) {
        NetStatus = NO_ERROR;
        TrustedDomainList = NULL;
        goto Cleanup;
    } else if (NetStatus != NO_ERROR) {
        NlPrint((NL_CRITICAL,
                "NlReadRegTrustedDomainList: NetpGetConfigTStrArray failed: %ld\n",
                NetStatus ));
        goto Cleanup;
    }


    //
    // Delete the key if asked to do so
    //

    if ( DeleteName ) {
        NET_API_STATUS TempNetStatus;
        TempNetStatus = NetpDeleteConfigKeyword ( SectionHandle, NETLOGON_KEYWORD_TRUSTEDDOMAINLIST );

        if ( TempNetStatus != NO_ERROR ) {
            NlPrint((NL_CRITICAL,
                    "NlReadRegTrustedDomainList: NetpDeleteConfigKeyword failed: %ld\n",
                    TempNetStatus ));
        }
    }


    //
    // Handle each trusted domain.
    //

    TStrArray = TrustedDomainList;
    while (!NetpIsTStrArrayEmpty(TStrArray)) {
        UNICODE_STRING CurrentDomain;

        //
        // Add the domain to the list
        //
        RtlInitUnicodeString( &CurrentDomain, TStrArray );

        Status = NlAllocateForestTrustListEntry (
                            &BufferDescriptor,
                            &CurrentDomain,  // Netbios domain name
                            NULL,   // No DNS domain name
                            DS_DOMAIN_DIRECT_OUTBOUND,
                            0,      // No ParentIndex
                            TRUST_TYPE_DOWNLEVEL,
                            0,      // No TrustAttributes
                            NULL,   // No Domain Sid
                            NULL,   // No DomainGuid
                            &Size,
                            &TrustedDomain );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        //
        // Account for the newly allocated entry
        //

        *RetForestTrustListSize += Size;
        (*RetForestTrustListCount) ++;

        //
        // Move to the next entry
        //

        TStrArray = NetpNextTStrArrayEntry(TStrArray);

    }

    NetStatus = NO_ERROR;

Cleanup:
    //
    // Return the buffer to the caller.
    //
    if ( NetStatus == NO_ERROR ) {
        *RetForestTrustList = (PDS_DOMAIN_TRUSTSW)BufferDescriptor.Buffer;
        BufferDescriptor.Buffer = NULL;
    }
    if ( TrustedDomainList != NULL ) {
        NetApiBufferFree( TrustedDomainList );
    }
    if ( SectionHandle != NULL ) {
        (VOID) NetpCloseConfigData( SectionHandle );
    }
    if ( BufferDescriptor.Buffer != NULL ) {
        NetApiBufferFree( BufferDescriptor.Buffer );

    }

    return NetStatus;
}


NET_API_STATUS
NlReadFileTrustedDomainList (
    IN PDOMAIN_INFO DomainInfo OPTIONAL,
    IN LPWSTR FileSuffix,
    IN BOOL DeleteName,
    IN ULONG Flags,
    OUT PDS_DOMAIN_TRUSTSW *ForestTrustList,
    OUT PULONG ForestTrustListSize,
    OUT PULONG ForestTrustListCount
    )

/*++

Routine Description:

    Read the list of trusted domains from a binary file.

Arguments:

    DomainInfo - Hosted domain that this machine is a member of
        If not specified, the check to ensure file is for primary domain isn't done.

    FileSuffix - Specifies the name of the file to write (relative to the
        Windows directory)

    DeleteName - TRUE if the name is to be deleted upon successful completion.

    Flags - Specifies attributes of trusts which should be returned. These are the flags
        of the DS_DOMAIN_TRUSTSW strusture.  If an entry has any of the bits specified
        in Flags set, it will be returned.

    ForestTrustList - Specifies a list of trusted domains.
        This buffer should be free using NetApiBufferFree().

    ForestTrustListSize - Size (in bytes) of ForestTrustList

    ForestTrustListCount - Number of entries in ForestTrustList

Return Value:

    None.

    ERROR_NO_SUCH_DOMAIN: Log file isn't for the primary domain.
    ERROR_INTERNAL_DB_CORRUPTION: Log file is corrupted.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    ULONG RecordBufferSize;
    PDS_DISK_TRUSTED_DOMAIN_HEADER RecordBuffer = NULL;
    LPBYTE RecordBufferEnd;
    PDS_DISK_TRUSTED_DOMAINS LogEntry;
    ULONG CurrentSize;
    BUFFER_DESCRIPTOR BufferDescriptor;
    BOOLEAN PrimaryDomainHandled = FALSE;
    PULONG IndexInReturnedList = NULL;
    ULONG IndexInReturnedListSize = 0;
    ULONG Index = 0;
    ULONG NumberOfFileEntries;

    LPBYTE Where;

    //
    // Initialization
    //
    *ForestTrustListCount = 0;
    *ForestTrustListSize = 0;
    *ForestTrustList = NULL;
    BufferDescriptor.Buffer = NULL;


    //
    // Read the file into a buffer.
    //

    NetStatus = NlReadBinaryLog(
                    FileSuffix,
                    DeleteName,
                    (LPBYTE *) &RecordBuffer,
                    &RecordBufferSize );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "NlReadFileForestTrustList: error reading binary log: %ld.\n",
                  FileSuffix,
                  RecordBufferSize ));
        goto Cleanup;
    }

    if ( RecordBufferSize == 0 ) {
        NetStatus = NO_ERROR;
        goto Cleanup;
    }




    //
    // Validate the returned data.
    //

    if ( RecordBufferSize < sizeof(DS_DISK_TRUSTED_DOMAIN_HEADER) ) {
        NlPrint(( NL_CRITICAL,
                  "NlReadFileForestTrustList: %ws: size too small: %ld.\n",
                  FileSuffix,
                  RecordBufferSize ));
        NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
        goto Cleanup;
    }

    if ( RecordBuffer->Version != DS_DISK_TRUSTED_DOMAIN_VERSION ) {
        NlPrint(( NL_CRITICAL,
                  "NlReadFileForestTrustList: %ws: Version wrong: %ld.\n",
                  FileSuffix,
                  RecordBuffer->Version ));
        NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
        goto Cleanup;
    }

    //
    // If domains in forest were requested,
    // allocate an array of ULONGs that will be used to keep track of the
    // index of a trust entry in the returned list. This is needed to
    // corectly set ParentIndex for entries returned.
    //

    if ( Flags & DS_DOMAIN_IN_FOREST ) {
        IndexInReturnedListSize = INDEX_LIST_ALLOCATED_CHUNK_SIZE;
        IndexInReturnedList = LocalAlloc( LMEM_ZEROINIT,
                                    IndexInReturnedListSize * sizeof(ULONG) );

        if ( IndexInReturnedList == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Loop through each log entry.
    //

    RecordBufferEnd = ((LPBYTE)RecordBuffer) + RecordBufferSize;
    LogEntry = (PDS_DISK_TRUSTED_DOMAINS)ROUND_UP_POINTER( (RecordBuffer + 1), ALIGN_WORST );

    while ( (LPBYTE)(LogEntry+1) <= RecordBufferEnd ) {
        PSID DomainSid;
        UNICODE_STRING NetbiosDomainName;
        UNICODE_STRING DnsDomainName;
        LPBYTE LogEntryEnd;
        ULONG Size;
        PDS_DOMAIN_TRUSTSW TrustedDomain;

        LogEntryEnd = ((LPBYTE)LogEntry) + LogEntry->EntrySize;

        //
        // Ensure this entry is entirely within the allocated buffer.
        //

        if  ( LogEntryEnd > RecordBufferEnd || LogEntryEnd <= (LPBYTE)LogEntry ) {
            NlPrint(( NL_CRITICAL,
                      "NlReadFileForestTrustList: Entry too big or small: %lx %lx.\n",
                      ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer),
                      LogEntry->EntrySize ));
            NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
            goto Cleanup;
        }

        //
        // Validate the entry
        //

        if ( !COUNT_IS_ALIGNED(LogEntry->EntrySize, ALIGN_WORST) ) {
            NlPrint(( NL_CRITICAL,
                      "NlReadFileForestTrustList: size not aligned %lx.\n",
                      LogEntry->EntrySize ));
            NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
            goto Cleanup;
        }

        //
        // Skip this entry if the caller doesn't need it
        //

        if ( (LogEntry->Flags & Flags) == 0 ) {
            LogEntry = (PDS_DISK_TRUSTED_DOMAINS)LogEntryEnd;
            Index++;
            continue;
        }

        //
        // Grab the Sid from the entry.
        //

        Where = (LPBYTE) (LogEntry+1);

        if ( LogEntry->DomainSidSize ) {
            ULONG DomainSidSize;

            if ( Where + sizeof(SID) > LogEntryEnd ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: DomainSid missing (A): %lx\n",
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }
            if ( Where + LogEntry->DomainSidSize > LogEntryEnd ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: DomainSid missing (B): %lx\n",
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            DomainSid = Where;
            DomainSidSize = RtlLengthSid( DomainSid );

            if ( LogEntry->DomainSidSize != DomainSidSize ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: DomainSidSize mismatch: %ld %ld\n",
                          LogEntry->DomainSidSize,
                          DomainSidSize ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            Where += DomainSidSize;
        }

        //
        // Grab the NetbiosDomainName from the entry
        //

        if ( LogEntry->NetbiosDomainNameSize ) {
            if ( Where + LogEntry->NetbiosDomainNameSize > LogEntryEnd ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: NetbiosDomainName missing: %lx\n",
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            if ( !COUNT_IS_ALIGNED( LogEntry->NetbiosDomainNameSize, ALIGN_WCHAR) ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: NetbiosDomainNameSize not aligned: %ld %lx\n",
                          LogEntry->NetbiosDomainNameSize,
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            NetbiosDomainName.Buffer = (LPWSTR) Where;

            if ( NetbiosDomainName.Buffer[(LogEntry->NetbiosDomainNameSize/sizeof(WCHAR))-1] != L'\0' ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: NetbiosDomainName not zero terminated: %lx\n",
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            Where += LogEntry->NetbiosDomainNameSize;
        }

        //
        // Grab the DnsDomainName from the entry
        //

        if ( LogEntry->DnsDomainNameSize ) {
            if ( Where + LogEntry->DnsDomainNameSize > LogEntryEnd ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: DnsDomainName missing: %lx\n",
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            if ( !COUNT_IS_ALIGNED( LogEntry->DnsDomainNameSize, ALIGN_WCHAR) ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: DnsDomainNameSize not aligned: %ld %lx\n",
                          LogEntry->DnsDomainNameSize,
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            DnsDomainName.Buffer = (LPWSTR) Where;

            if ( DnsDomainName.Buffer[(LogEntry->DnsDomainNameSize/sizeof(WCHAR))-1] != L'\0' ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: DnsDomainName not zero terminated: %lx\n",
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
                NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            Where += LogEntry->DnsDomainNameSize;
        }

        //
        // Put this entry into the buffer.
        //

        NetbiosDomainName.Length =
            NetbiosDomainName.MaximumLength = (USHORT) LogEntry->NetbiosDomainNameSize;
        DnsDomainName.Length =
            DnsDomainName.MaximumLength = (USHORT) LogEntry->DnsDomainNameSize;

        Status = NlAllocateForestTrustListEntry (
                            &BufferDescriptor,
                            &NetbiosDomainName,
                            &DnsDomainName,
                            LogEntry->Flags,
                            LogEntry->ParentIndex,
                            LogEntry->TrustType,
                            LogEntry->TrustAttributes,
                            LogEntry->DomainSidSize ?
                                DomainSid :
                                NULL,
                            &LogEntry->DomainGuid,
                            &Size,
                            &TrustedDomain );

        if ( !NT_SUCCESS(Status) ) {
            NlPrint(( NL_CRITICAL,
                      "NlReadFileForestTrustList: Cannot allocate entry %lx\n",
                      Status ));
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        //
        // If domains in forest were requested,
        // remember the index of this entry in the returned list.
        // Allocate more memory for IndexInReturnedList as needed.
        //

        if ( Flags & DS_DOMAIN_IN_FOREST ) {
            if ( Index >= IndexInReturnedListSize ) {
                PULONG TmpIndexInReturnedList = NULL;

                IndexInReturnedListSize = Index;
                IndexInReturnedListSize += INDEX_LIST_ALLOCATED_CHUNK_SIZE;
                TmpIndexInReturnedList = LocalReAlloc( IndexInReturnedList,
                                             IndexInReturnedListSize * sizeof(ULONG),
                                             LMEM_ZEROINIT | LMEM_MOVEABLE );

                if ( TmpIndexInReturnedList == NULL ) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
                IndexInReturnedList = TmpIndexInReturnedList;
            }
            IndexInReturnedList[Index] = *ForestTrustListCount;
        }


        //
        // Account for the newly allocated entry
        //
        *ForestTrustListSize += Size;
        (*ForestTrustListCount) ++;


        //
        // If this entry describes the primary domain,
        //  make sure that this log is for the right primary domain.
        //

        if ( TrustedDomain->Flags & DS_DOMAIN_PRIMARY ) {

            //
            // Ensure there is only one primary domain entry.
            //

            if ( PrimaryDomainHandled ) {
                NlPrint(( NL_CRITICAL,
                          "NlReadFileForestTrustList: %ws: Duplicate primary domain entry: %ws %ws %lx\n",
                          FileSuffix,
                          TrustedDomain->NetbiosDomainName,
                          TrustedDomain->DnsDomainName,
                          ((LPBYTE)LogEntry)-((LPBYTE)RecordBuffer) ));
            }

            PrimaryDomainHandled = TRUE;

            //
            // If the domain names are different,
            //  disregard this log file.
            //

            if ( DomainInfo != NULL ) {
                if ( ( TrustedDomain->NetbiosDomainName != NULL &&
                       NlNameCompare( TrustedDomain->NetbiosDomainName,
                                      DomainInfo->DomUnicodeDomainName,
                                      NAMETYPE_DOMAIN ) != 0 ) ||
                      ( TrustedDomain->DnsDomainName != NULL &&
                        DomainInfo->DomUnicodeDnsDomainName != NULL &&
                        !NlEqualDnsName( TrustedDomain->DnsDomainName,
                                         DomainInfo->DomUnicodeDnsDomainName ) ) ) {

                    NlPrint(( NL_CRITICAL,
                              "NlReadFileForestTrustList: %ws: Log file isn't for primary domain: %ws %ws\n",
                              FileSuffix,
                              TrustedDomain->NetbiosDomainName,
                              TrustedDomain->DnsDomainName ));

                    NetStatus = ERROR_NO_SUCH_DOMAIN;
                    goto Cleanup;
                }
            }


        }

        //
        // Move to the next entry.
        //

        LogEntry = (PDS_DISK_TRUSTED_DOMAINS)LogEntryEnd;
        Index++;
    }

    NumberOfFileEntries = Index;

    if ( !PrimaryDomainHandled ) {

        NlPrint(( NL_CRITICAL,
                  "NlReadFileForestTrustList: %ws: No primary domain record in Log file\n",
                  FileSuffix ));
    }

    *ForestTrustList = (PDS_DOMAIN_TRUSTSW) BufferDescriptor.Buffer;

    //
    // Fix ParentIndex.  If domains in the forest are requested,
    // adjust the index to point to the appropriate entry in the
    // returned list.  Otherwise, set the index to 0.
    //

    if ( Flags & DS_DOMAIN_IN_FOREST ) {
        ULONG ParentIndex;
        ULONG ParentIndexInReturnedList;

        for ( Index=0; Index<*ForestTrustListCount; Index++ ) {
            if ( ((*ForestTrustList)[Index].Flags & DS_DOMAIN_IN_FOREST) != 0 &&
                 ((*ForestTrustList)[Index].Flags & DS_DOMAIN_TREE_ROOT) == 0 ) {
                ParentIndex = (*ForestTrustList)[Index].ParentIndex;

                //
                // Check if the parent index is out of range. If so, the file is corrupted.
                //
                if ( ParentIndex >= NumberOfFileEntries ||
                     ParentIndex >= IndexInReturnedListSize ) {
                    NlPrint(( NL_CRITICAL,
                              "NlReadFileForestTrustList: ParentIndex %lu is out of range %lu\n",
                              ParentIndex, NumberOfFileEntries ));
                    NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                    goto Cleanup;
                }
                ParentIndexInReturnedList = IndexInReturnedList[ParentIndex];

                //
                // Check if the returned list entry pointed to by the parent index is
                // in forest.  If not, the file is corrupted.
                //
                if ( (*ForestTrustList)[ParentIndexInReturnedList].Flags & DS_DOMAIN_IN_FOREST ) {
                    (*ForestTrustList)[Index].ParentIndex = ParentIndexInReturnedList;
                } else {
                    NlPrint(( NL_CRITICAL,
                       "NlReadFileForestTrustList: ReturnedList entry %lu is not in the forest\n",
                       ParentIndexInReturnedList ));
                    NetStatus = ERROR_INTERNAL_DB_CORRUPTION;
                    goto Cleanup;
                }
            }
        }

    } else {

        for ( Index=0; Index<*ForestTrustListCount; Index++ ) {
            (*ForestTrustList)[Index].ParentIndex = 0;
        }
    }

    BufferDescriptor.Buffer = NULL;
    NetStatus = NO_ERROR;

    //
    // Free any locally used resources.
    //
Cleanup:

    if ( BufferDescriptor.Buffer != NULL ) {
        NetApiBufferFree( BufferDescriptor.Buffer );
        *ForestTrustListCount = 0;
        *ForestTrustListSize = 0;
        *ForestTrustList = NULL;
    }

    if ( IndexInReturnedList != NULL ) {
        LocalFree( IndexInReturnedList );
    }

    if ( RecordBuffer != NULL ) {
        LocalFree( RecordBuffer );
    }

    if ( *ForestTrustList == NULL ) {
        *ForestTrustListCount = 0;
        *ForestTrustListSize = 0;
    }

    return NetStatus;
}

NTSTATUS
NlUpdatePrimaryDomainInfo(
    IN LSAPR_HANDLE PolicyHandle,
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING DnsDomainName,
    IN PUNICODE_STRING DnsForestName,
    IN GUID *DomainGuid
    )
/*++

Routine Description:

    This routine sets the DnsDomainName, DnsForestName and DomainGuid in the LSA.

Arguments:

    PolicyHandle - A trusted policy handle open to the LSA.

    NetbiosDomainName - Specifies the Netbios domain name of the primary domain.

    DnsDomainName -  Specifies the DNS domain name of the primary domain.

    DnsForestName - Specifies the DNS tree name the primary domain belongs to.

    DomainGuid - Specifies the GUID of the primary domain.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    PLSAPR_POLICY_INFORMATION OldPrimaryDomainInfo = NULL;
    LSAPR_POLICY_INFORMATION NewPrimaryDomainInfo;
    BOOL SomethingChanged = FALSE;


    //
    // Get the Primary Domain info from the LSA.
    //

    NlPrint((NL_DOMAIN,
            "Setting LSA NetbiosDomain: %wZ DnsDomain: %wZ DnsTree: %wZ DomainGuid:",
            NetbiosDomainName,
            DnsDomainName,
            DnsForestName ));
    NlpDumpGuid( NL_DOMAIN, DomainGuid );
    NlPrint(( NL_DOMAIN, "\n" ));

    Status = LsarQueryInformationPolicy(
                PolicyHandle,
                PolicyDnsDomainInformation,
                &OldPrimaryDomainInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Initialize the new policy to equal the old policy.
    //

    NewPrimaryDomainInfo.PolicyDnsDomainInfo = OldPrimaryDomainInfo->PolicyDnsDomainInfo;

    //
    // If Netbios domain name changed,
    //  update it.
    //

    if ( NetbiosDomainName->Length != 0 ) {
         if ( NewPrimaryDomainInfo.PolicyDnsDomainInfo.Name.Length == 0 ||
              !RtlEqualDomainName(NetbiosDomainName,
                                  (PUNICODE_STRING)&NewPrimaryDomainInfo.PolicyDnsDomainInfo.Name) ) {

             NlPrint(( NL_DOMAIN,
                       "   NetbiosDomain changed from %wZ to %wZ\n",
                       &NewPrimaryDomainInfo.PolicyDnsDomainInfo.Name,
                       NetbiosDomainName ));

             NewPrimaryDomainInfo.PolicyDnsDomainInfo.Name = *((LSAPR_UNICODE_STRING*)NetbiosDomainName);

             SomethingChanged = TRUE;
         }
    }

    //
    // If the DnsDomainName has changed,
    //  udpate it.
    //

    if ( !NlEqualDnsNameU(DnsDomainName,
                          (PUNICODE_STRING)&NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsDomainName )) {

        NlPrint((NL_DOMAIN,
                "   DnsDomain changed from %wZ to %wZ\n",
                &NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsDomainName,
                DnsDomainName ));

        NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsDomainName =
            *((LSAPR_UNICODE_STRING*)DnsDomainName);

        // Truncate the trailing .
        if ( NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsDomainName.Length > 0 &&
             NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsDomainName.Buffer[
                NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsDomainName.Length-1] == L'.' ) {

            NlPrint((NL_DOMAIN,
                    "   Ditch the dot. DnsDomain changed from %wZ to %wZ\n",
                    &NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsDomainName,
                    DnsDomainName ));

            NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsDomainName.Length --;
        }
        SomethingChanged = TRUE;

    }

    //
    // If the DnsForestName has changed,
    //  udpate it.
    //

    if ( !NlEqualDnsNameU( DnsForestName,
                           (PUNICODE_STRING)&NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsForestName ) ) {

        NlPrint((NL_DOMAIN,
                "   DnsTree changed from %wZ to %wZ\n",
                &NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsForestName,
                DnsForestName ));

        NewPrimaryDomainInfo.PolicyDnsDomainInfo.DnsForestName =
            *((LSAPR_UNICODE_STRING*)DnsForestName);
        SomethingChanged = TRUE;

    }

    //
    // If the DomainGuid has changed,
    //  udpate it.
    //

    if ( !IsEqualGUID(DomainGuid,
                      &NewPrimaryDomainInfo.PolicyDnsDomainInfo.DomainGuid )) {

        NlPrint((NL_DOMAIN,
                "   DomainGuid changed from " ));
        NlpDumpGuid( NL_DOMAIN, &NewPrimaryDomainInfo.PolicyDnsDomainInfo.DomainGuid );
        NlPrint((NL_DOMAIN,
                " to " ));
        NlpDumpGuid( NL_DOMAIN, DomainGuid );
        NlPrint((NL_DOMAIN,
                "\n" ));

        NewPrimaryDomainInfo.PolicyDnsDomainInfo.DomainGuid = *DomainGuid;
        SomethingChanged = TRUE;

    }

    //
    // Only update the LSA if something has really changed.
    //
    if ( SomethingChanged ) {
        Status = LsarSetInformationPolicy(
                    PolicyHandle,
                    PolicyDnsDomainInformation,
                    &NewPrimaryDomainInfo );

        if ( !NT_SUCCESS(Status) ) {
            NlPrint((NL_CRITICAL,
                "NlUpdatePrimaryDomainInfo: Cannot LsarSetInformationPolicy 0x%lx\n",
                Status ));
            goto Cleanup;
        }

    }

    Status = STATUS_SUCCESS;

    //
    // Return
    //
Cleanup:
    if ( OldPrimaryDomainInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            OldPrimaryDomainInfo );
    }

    return Status;
}


NTSTATUS
NlUpdateDomainInfo(
    IN PCLIENT_SESSION ClientSession
    )

/*++

Routine Description:

    Gets the domain information from a DC in the domain and updates that
    information on this workstation.

    Note: this routine is called from NlSessionSetup.  When called from outside
    NlSessionSetup, the caller should call this routine directly if the
    session is already setup.  Otherwise, the caller should simply setup
    the session and rely on the fact the NlSessionSetup called this routine
    as a side effect.

Arguments:

    ClientSession - Structure used to define the session.
        The caller must be a writer of the ClientSession.

Return Value:

    Status of the operation.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;
    PNETLOGON_DOMAIN_INFO NetlogonDomainInfo = NULL;
    NETLOGON_WORKSTATION_INFO NetlogonWorkstationInfo;
    OSVERSIONINFOEXW OsVersionInfoEx;
    WCHAR LocalDnsDomainName[NL_MAX_DNS_LENGTH+1];
    WCHAR LocalNetbiosDomainName[DNLEN+1];
    WCHAR CapturedSiteName[NL_MAX_DNS_LABEL_LENGTH+1];
    SESSION_INFO SessionInfo;
    GUID *NewGuid;

    ULONG i;

    PDS_DOMAIN_TRUSTSW ForestTrustList = NULL;
    ULONG ForestTrustListSize;
    ULONG ForestTrustListCount;

    LPBYTE Where;


    //
    // Initialization.
    //

    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsFlags & CS_WRITER );
    RtlZeroMemory( &NetlogonWorkstationInfo, sizeof(NetlogonWorkstationInfo) );

    SessionInfo.SessionKey = ClientSession->CsSessionKey;
    SessionInfo.NegotiatedFlags = ClientSession->CsNegotiatedFlags;


    //
    // If we are talking to a DC that doesn't support I_NetLogonGetDomainInfo,
    //  do things in an NT 4.0 compatible way.
    //

    if (!(SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_GET_DOMAIN_INFO )) {

        //
        // Get the trusted domain list from the discovered DC using the NT 4
        //  protocol.
        //

        Status = NlGetNt4TrustedDomainList (
                        ClientSession->CsUncServerName,
                        &ClientSession->CsDomainInfo->DomUnicodeDomainNameString,
                        &ClientSession->CsDomainInfo->DomUnicodeDnsDomainNameString,
                        ClientSession->CsDomainInfo->DomAccountDomainId,
                        ClientSession->CsDomainInfo->DomDomainGuid,
                        &ForestTrustList,
                        &ForestTrustListSize,
                        &ForestTrustListCount );

        //
        // If we failed, error out.
        //
        // Special case the access denied which is probably
        //  because LSA ACLs are tightened on the NT4.0 DC.
        //  We don't want to fail the secure channel setup
        //  in NlSessionSetup because of this. The other
        //  place where this routine is called is
        //  DsrEnumerateDomainTrusts which will return the
        //  trust list cached at the join time and will
        //  ignore the failure to update the trust list here.
        //

        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_ACCESS_DENIED ) {
                Status = STATUS_SUCCESS;
            }
            return Status;
        }

        //
        // Otherwise, fall through and update the
        //  forest trust list
        //

        goto Cleanup;
    }

    //
    // Sanity check that the secure channel is really up.
    //

    if ( ClientSession->CsState == CS_IDLE ) {
        Status = ClientSession->CsConnectionStatus;
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlUpdateDomainInfo: Secure channel is down %lx\n",
                Status ));
        goto Cleanup;
    }

    //
    // Tell the DC that we're not interested in LSA policy.
    //  (We only did LSA policy for NT 5.0 beta 1.)
    //

    NetlogonWorkstationInfo.LsaPolicy.LsaPolicySize = 0;
    NetlogonWorkstationInfo.LsaPolicy.LsaPolicy = NULL;

    //
    // Fill in data the DC needs to know about this workstation.
    //

    if  ( NlCaptureSiteName( CapturedSiteName ) ) {
        NetlogonWorkstationInfo.SiteName = CapturedSiteName;
    }

    NetlogonWorkstationInfo.DnsHostName =
        ClientSession->CsDomainInfo->DomUnicodeDnsHostNameString.Buffer,

    //
    // Fill in the OS Version of this machine.
    //

    OsVersionInfoEx.dwOSVersionInfoSize = sizeof(OsVersionInfoEx);

    if ( GetVersionEx( (POSVERSIONINFO)&OsVersionInfoEx) ) {
        NetlogonWorkstationInfo.OsVersion.MaximumLength =
            NetlogonWorkstationInfo.OsVersion.Length = sizeof(OsVersionInfoEx);
        NetlogonWorkstationInfo.OsVersion.Buffer = (WCHAR *) &OsVersionInfoEx;

        if ( OsVersionInfoEx.wProductType == VER_NT_WORKSTATION ) {
            RtlInitUnicodeString( &NetlogonWorkstationInfo.OsName,
                                  L"Windows XP Professional" );
        } else {
            RtlInitUnicodeString( &NetlogonWorkstationInfo.OsName,
                                  L"Windows .NET Server" );
        }
    } else {
        RtlInitUnicodeString( &NetlogonWorkstationInfo.OsName,
                              L"Windows XP" );
    }


    //
    // Ask for both trusted and trusting domains to be returned
    //

    NetlogonWorkstationInfo.WorkstationFlags |= NL_NEED_BIDIRECTIONAL_TRUSTS;
    NetlogonWorkstationInfo.WorkstationFlags |= NL_CLIENT_HANDLES_SPN;

    //
    // Build the Authenticator for this request on the secure channel
    //

    NlBuildAuthenticator(
         &ClientSession->CsAuthenticationSeed,
         &ClientSession->CsSessionKey,
         &OurAuthenticator );

    //
    // Make the request across the secure channel.
    //

    NL_API_START( Status, ClientSession, TRUE ) {

        Status = I_NetLogonGetDomainInfo(
                    ClientSession->CsUncServerName,
                    ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                    &OurAuthenticator,
                    &ReturnAuthenticator,
                    NETLOGON_QUERY_DOMAIN_INFO,
                    (LPBYTE) &NetlogonWorkstationInfo,
                    (LPBYTE *) &NetlogonDomainInfo );

    // NOTE: This call may drop the secure channel behind our back
    } NL_API_ELSE( Status, ClientSession, TRUE ) {
        //
        // We might have been called from NlSessionSetup,
        //  So we have to indicate the failure to our caller.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = ClientSession->CsConnectionStatus;
            goto Cleanup;
        }
    } NL_API_END;

    //
    // Verify authenticator of the server on the other side and update our seed.
    //
    // If the server denied access or the server's authenticator is wrong,
    //      Force a re-authentication.
    //
    //

    if ( NlpDidDcFail( Status ) ||
         !NlUpdateSeed(
            &ClientSession->CsAuthenticationSeed,
            &ReturnAuthenticator.Credential,
            &ClientSession->CsSessionKey) ) {

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlUpdateDomainInfo: denying access after status: 0x%lx\n",
                    Status ));

        //
        // Preserve any status indicating a communication error.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_ACCESS_DENIED;
        }
        goto Cleanup;
    }

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Normalize the GUID
    //

    if ( !IsEqualGUID( &NetlogonDomainInfo->PrimaryDomain.DomainGuid,
                       &NlGlobalZeroGuid ) ) {
        NewGuid = &NetlogonDomainInfo->PrimaryDomain.DomainGuid;
    } else {
        NewGuid = NULL;
    }

    //
    // If the DNS domain name is different than the one we already have,
    //  update the one we already have.
    //
    // This allows for DNS domain renaming and for picking up the DNS name from
    // and NT 5 DC once it is upgraded (to NT 5 or to supporting DNS).
    //

    if ( NetlogonDomainInfo->PrimaryDomain.DnsDomainName.Length < sizeof(LocalDnsDomainName) &&
         NetlogonDomainInfo->PrimaryDomain.DomainName.Length < sizeof(LocalNetbiosDomainName) ) {
        BOOLEAN DnsDomainNameWasChanged = FALSE;

        RtlCopyMemory( LocalDnsDomainName,
                       NetlogonDomainInfo->PrimaryDomain.DnsDomainName.Buffer,
                       NetlogonDomainInfo->PrimaryDomain.DnsDomainName.Length );
        LocalDnsDomainName[
            NetlogonDomainInfo->PrimaryDomain.DnsDomainName.Length/sizeof(WCHAR)] = L'\0';

        RtlCopyMemory( LocalNetbiosDomainName,
                       NetlogonDomainInfo->PrimaryDomain.DomainName.Buffer,
                       NetlogonDomainInfo->PrimaryDomain.DomainName.Length );
        LocalNetbiosDomainName[
            NetlogonDomainInfo->PrimaryDomain.DomainName.Length/sizeof(WCHAR)] = L'\0';


        NetStatus = NlSetDomainNameInDomainInfo(
                          ClientSession->CsDomainInfo,
                          LocalDnsDomainName,
                          LocalNetbiosDomainName,
                          NewGuid,
                          &DnsDomainNameWasChanged,
                          NULL,
                          NULL );

        if ( NetStatus != NO_ERROR ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlUpdateDomainInfo: Can't NlSetDnsDomainDomainInfo %ld\n",
                    NetStatus ));
            Status = NetpApiStatusToNtStatus( NetStatus );
            goto Cleanup;
        }

        //
        // Change the computer name as required. The new name will take effect next time
        // the computer reboots. An error here is not fatal.
        //

        if ( DnsDomainNameWasChanged && LocalDnsDomainName != NULL ) {
            if ( NERR_Success != NetpSetDnsComputerNameAsRequired( LocalDnsDomainName ) ) {
                NlPrintCs((NL_CRITICAL, ClientSession,
                        "NlUpdateDomainInfo: Can't NetpSetDnsComputerNameAsRequired %ld\n",
                        NetStatus ));
            } else {
                NlPrintCs((NL_MISC, ClientSession,
                           "NlUpdateDomainInfo: Successfully set computer name with suffix %ws\n",
                           LocalDnsDomainName ));
            }
        }
    }

    //
    // Save the new tree name.
    //

    NetStatus = NlSetDnsForestName( &NetlogonDomainInfo->PrimaryDomain.DnsForestName, NULL );

    if ( NetStatus != NO_ERROR ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlUpdateDomainInfo: Can't NlSetDnsForestName %ld\n",
                NetStatus ));
        Status = NetpApiStatusToNtStatus( NetStatus );
        goto Cleanup;
    }



    //
    // Update the Dns Domain Name, Dns Tree Name and Domain GUID in the LSA
    //

    Status = NlUpdatePrimaryDomainInfo(
                    ClientSession->CsDomainInfo->DomLsaPolicyHandle,
                    &NetlogonDomainInfo->PrimaryDomain.DomainName,
                    &NetlogonDomainInfo->PrimaryDomain.DnsDomainName,
                    &NetlogonDomainInfo->PrimaryDomain.DnsForestName,
                    &NetlogonDomainInfo->PrimaryDomain.DomainGuid );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlUpdateDomainInfo: Can't NlUpdatePrimaryDomainInfo 0x%lx\n",
                Status ));
        goto Cleanup;
    }



    //
    // Determine the size of forest trust info returned on this call.
    //

    ForestTrustListSize = 0;
    for ( i=0; i<NetlogonDomainInfo->TrustedDomainCount; i++ ) {
        ForestTrustListSize += sizeof(DS_DOMAIN_TRUSTSW) +
                 NetlogonDomainInfo->TrustedDomains[i].DomainName.Length + sizeof(WCHAR) +
                 NetlogonDomainInfo->TrustedDomains[i].DnsDomainName.Length + sizeof(WCHAR);
        if ( NetlogonDomainInfo->TrustedDomains[i].DomainSid != NULL ) {
            ForestTrustListSize += RtlLengthSid( NetlogonDomainInfo->TrustedDomains[i].DomainSid );
        }
        ForestTrustListSize = ROUND_UP_COUNT( ForestTrustListSize, ALIGN_DWORD );
    }

    //
    // Allocate the buffer.
    //

    ForestTrustList = NetpMemoryAllocate( ForestTrustListSize );

    if ( ForestTrustList == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    ForestTrustListCount = NetlogonDomainInfo->TrustedDomainCount;
    Where = (LPBYTE)(&ForestTrustList[ForestTrustListCount]);

    //
    // Handle each trusted domain.
    //

    for ( i=0; i<NetlogonDomainInfo->TrustedDomainCount; i++ ) {
        NL_TRUST_EXTENSION TrustExtension;

        //
        // See if the caller passed the trust extension to us.
        //

        if ( NetlogonDomainInfo->TrustedDomains[i].TrustExtension.Length >= sizeof(TrustExtension) ) {
            //
            // Copy the extension to get the alignment right
            //  (since RPC thinks this is a WCHAR buffer).
            //

            RtlCopyMemory( &TrustExtension,
                           NetlogonDomainInfo->TrustedDomains[i].TrustExtension.Buffer,
                           sizeof(TrustExtension) );

            ForestTrustList[i].Flags = TrustExtension.Flags;
            ForestTrustList[i].ParentIndex = TrustExtension.ParentIndex;
            ForestTrustList[i].TrustType = TrustExtension.TrustType;
            ForestTrustList[i].TrustAttributes = TrustExtension.TrustAttributes;

        //
        // If not,
        //  make something up.
        //
        } else {


            ForestTrustList[i].Flags = DS_DOMAIN_DIRECT_OUTBOUND; // = DS_DOMAIN_DIRECT_TRUST;
            ForestTrustList[i].ParentIndex = 0;
            ForestTrustList[i].TrustType = TRUST_TYPE_DOWNLEVEL;
            ForestTrustList[i].TrustAttributes = 0;
        }

        ForestTrustList[i].DomainGuid = NetlogonDomainInfo->TrustedDomains[i].DomainGuid;

        //
        // Copy the DWORD aligned data
        //

        if ( NetlogonDomainInfo->TrustedDomains[i].DomainSid != NULL ) {
            ULONG SidSize;
            ForestTrustList[i].DomainSid = (PSID) Where;
            SidSize = RtlLengthSid( NetlogonDomainInfo->TrustedDomains[i].DomainSid );
            RtlCopyMemory( Where,
                           NetlogonDomainInfo->TrustedDomains[i].DomainSid,
                           SidSize );
            Where += SidSize;
        } else {
            ForestTrustList[i].DomainSid = NULL;
        }

        //
        // Copy the WCHAR aligned data
        //

        if ( NetlogonDomainInfo->TrustedDomains[i].DnsDomainName.Length != 0 ) {
            ForestTrustList[i].DnsDomainName = (LPWSTR)Where;
            RtlCopyMemory( Where,
                           NetlogonDomainInfo->TrustedDomains[i].DnsDomainName.Buffer,
                           NetlogonDomainInfo->TrustedDomains[i].DnsDomainName.Length );
            Where += NetlogonDomainInfo->TrustedDomains[i].DnsDomainName.Length;
            *(PWCHAR)Where = L'\0';
            Where += sizeof(WCHAR);
        } else {
            ForestTrustList[i].DnsDomainName = NULL;
        }

        if ( NetlogonDomainInfo->TrustedDomains[i].DomainName.Length != 0 ) {
            ForestTrustList[i].NetbiosDomainName = (LPWSTR)Where;
            RtlCopyMemory( Where,
                           NetlogonDomainInfo->TrustedDomains[i].DomainName.Buffer,
                           NetlogonDomainInfo->TrustedDomains[i].DomainName.Length );
            Where += NetlogonDomainInfo->TrustedDomains[i].DomainName.Length;
            *(PWCHAR)Where = L'\0';
            Where += sizeof(WCHAR);
        } else {
            ForestTrustList[i].NetbiosDomainName = NULL;
        }

        Where = ROUND_UP_POINTER( Where, ALIGN_DWORD);
    }

    //
    // Ensure the DC has our latest SPN
    //

    if ( NetlogonDomainInfo->WorkstationFlags & NL_CLIENT_HANDLES_SPN ) {
        LONG WinError;
        HKEY Key;

        //
        // See if we are supposed to set SPN
        //
        WinError = RegOpenKey( HKEY_LOCAL_MACHINE,
                               NETSETUPP_NETLOGON_AVOID_SPN_PATH,
                               &Key );

        //
        // If the key exists it must have just been set by Netjoin
        //  so we should avoid setting it ourselves because we may
        //  not know the new machine name until the reboot. The key
        //  we just read is volatile, so it won't exist after the
        //  reboot when teh new computer name becomes available to us.
        //
        if ( WinError == ERROR_SUCCESS ) {

            RegCloseKey( Key );

        } else {
            BOOLEAN SetSpn = FALSE;
            BOOLEAN SetDnsHostName = FALSE;

            //
            // If the DC doesn't know any DnsHostName at all,
            //  set both the SPN and the DNS host name.
            //  (This is expected to handle the case where the DC was just upgraded to
            //  NT 5.  In all other cases, join (etc) is expected to already have set
            //  the SPN and DC names.
            //

            if ( NetlogonDomainInfo->DnsHostNameInDs.Buffer == NULL ) {
                SetSpn = TRUE;
                SetDnsHostName = TRUE;
            } else {
                //
                // If the DC simply doesn't know the correct host name,
                //  just set that.
                //  (The DS will set all of the appropriate SPNs as a side effect of
                //  the host name changing.)
                //
                if ( !NlEqualDnsNameU(
                        &NetlogonDomainInfo->DnsHostNameInDs,
                        &ClientSession->CsDomainInfo->DomUnicodeDnsHostNameString ) ) {

                    SetDnsHostName = TRUE;

                }
            }

            (VOID) NlSetDsSPN( TRUE,   // Synchronous
                               SetSpn,
                               SetDnsHostName,
                               ClientSession->CsDomainInfo,
                               ClientSession->CsUncServerName,
                               ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                               ClientSession->CsDomainInfo->DomUnicodeDnsHostNameString.Buffer );
        }
    }

    Status = STATUS_SUCCESS;

    //
    // Free any locally used resources.
    //
Cleanup:

    //
    // On success,
    //  save the trusted domain list.
    //
    if ( NT_SUCCESS(Status) ) {

        //
        // Ensure the SID of the trusted domain isn't the domain sid of the primary
        //  domain.
        //

        for ( i=0; i<ForestTrustListCount; i++ ) {

           if ( (ForestTrustList[i].Flags & DS_DOMAIN_PRIMARY) == 0 &&
                ForestTrustList[i].DomainSid != NULL &&
                RtlEqualSid( ForestTrustList[i].DomainSid, ClientSession->CsDomainInfo->DomAccountDomainId )) {

               LPWSTR AlertStrings[3];

               //
               // alert admin.
               //

               AlertStrings[0] = NlGlobalUnicodeComputerName;
               AlertStrings[1] = ForestTrustList[i].DnsDomainName != NULL ?
                                 ForestTrustList[i].DnsDomainName :
                                 ForestTrustList[i].NetbiosDomainName;
               AlertStrings[2] = NULL; // Needed for RAISE_ALERT_TOO

               //
               // Save the info in the eventlog
               //

               NlpWriteEventlog(
                           ALERT_NetLogonSidConflict,
                           EVENTLOG_ERROR_TYPE,
                           (LPBYTE)ForestTrustList[i].DomainSid,
                           RtlLengthSid(ForestTrustList[i].DomainSid),
                           AlertStrings,
                           2 | NETP_RAISE_ALERT_TOO );

           }

        }

        //
        // Save the collected information to the binary file.
        //

        NetStatus = NlWriteFileForestTrustList (
                                NL_FOREST_BINARY_LOG_FILE,
                                ForestTrustList,
                                ForestTrustListCount );

        if ( NetStatus != NO_ERROR ) {
            LPWSTR MsgStrings[2];

            MsgStrings[0] = NL_FOREST_BINARY_LOG_FILE;
            MsgStrings[1] = (LPWSTR) ULongToPtr( NetStatus );

            NlpWriteEventlog (NELOG_NetlogonFailedFileCreate,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE) &NetStatus,
                              sizeof(NetStatus),
                              MsgStrings,
                              2 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        }

        //
        // Save the list on the DomainInfo
        //  (May null out ForestTrustList).
        //

        NlSetForestTrustList ( ClientSession->CsDomainInfo,
                               &ForestTrustList,
                               ForestTrustListSize,
                               ForestTrustListCount );

    }

    if ( NetlogonDomainInfo != NULL ) {
        NetApiBufferFree( NetlogonDomainInfo );
    }

    if ( ForestTrustList != NULL ) {
        NetApiBufferFree( ForestTrustList );
    }

    return Status;
}



VOID
NlSetForestTrustList (
    IN PDOMAIN_INFO DomainInfo,
    IN OUT PDS_DOMAIN_TRUSTSW *ForestTrustList,
    IN ULONG ForestTrustListSize,
    IN ULONG ForestTrustListCount
    )

/*++

Routine Description:

    Set the domain list on DomainInfo (on a DC) or globals (on a workstation)

Arguments:

    DomainInfo - Domain trust list is associated with

    ForestTrustList - Specifies a list of trusted domains.
        This pointer is NULLed if this routine consumes the buffer.

    ForestTrustListSize - Size (in bytes) of ForestTrustList

    ForestTrustListCount - Number of entries in ForestTrustList

Return Value:

    Status of the operation.

    Upon failure, the previous list remains intact.

--*/
{
    PTRUSTED_DOMAIN TempTrustedDomainList = NULL;
    ULONG TempTrustedDomainCount = 0;
    PTRUSTED_DOMAIN LocalTrustedDomainList = NULL;
    DWORD i;

    //
    // On workstations,
    //  build a global list that contains the minimum amount of memory possible.
    //

    if ( NlGlobalMemberWorkstation ) {
        DWORD LocalTrustedDomainCount;
        DWORD LocalTrustedDomainSize;

        PTRUSTED_DOMAIN OldList;
        LPBYTE Where;


        //
        // If the new list is zero length,
        //  don't bother allocating anything.
        //

        if ( ForestTrustListCount == 0 ) {
            LocalTrustedDomainList = NULL;
            LocalTrustedDomainCount = 0;
            LocalTrustedDomainSize = 0;

        //
        // Otherwise, build a buffer of the trusted domain list
        //

        } else {

            //
            // Allocate a temporary buffer for the new list
            //

            TempTrustedDomainList = NetpMemoryAllocate(
                                        ForestTrustListCount * sizeof(TRUSTED_DOMAIN) );

            if ( TempTrustedDomainList == NULL ) {
                goto Cleanup;
            }

            RtlZeroMemory( TempTrustedDomainList,
                           ForestTrustListCount * sizeof(TRUSTED_DOMAIN ));

            //
            // Copy the Netbios names to the new structure upper casing them and
            //  converting to OEM.
            //

            TempTrustedDomainCount = 0;
            LocalTrustedDomainSize = 0;

            EnterCriticalSection( &NlGlobalLogFileCritSect );
            NlPrint((NL_LOGON, "NlSetForestTrustList: New trusted domain list:\n" ));

            for ( i=0; i<ForestTrustListCount; i++ ) {
                NTSTATUS Status;


                NlPrint(( NL_LOGON, "    %ld:", i ));
                NlPrintTrustedDomain( &(*ForestTrustList)[i],
                                      TRUE,      // verbose output
                                      FALSE );   // wide character output

                //
                // Skip entries that represent trusts Netlogon doesn't use
                //

                if ( (*ForestTrustList)[i].TrustType != TRUST_TYPE_DOWNLEVEL &&
                     (*ForestTrustList)[i].TrustType != TRUST_TYPE_UPLEVEL ) {
                    continue;
                }

                if ( (*ForestTrustList)[i].TrustAttributes & TRUST_ATTRIBUTE_UPLEVEL_ONLY ) {
                    continue;
                }

                //
                // On workstation, we keep in memory trusted domains only
                //

                if ( ((*ForestTrustList)[i].Flags & DS_DOMAIN_PRIMARY) == 0 &&
                     ((*ForestTrustList)[i].Flags & DS_DOMAIN_IN_FOREST) == 0 &&
                     ((*ForestTrustList)[i].Flags & DS_DOMAIN_DIRECT_OUTBOUND) == 0 ) {
                    continue;
                }


                //
                // Copy the Netbios names to the new structure.
                //

                if ( (*ForestTrustList)[i].NetbiosDomainName != NULL ) {

                    if ( wcslen( (*ForestTrustList)[i].NetbiosDomainName ) > DNLEN ) {
                        NlPrint(( NL_CRITICAL,
                                  "Netbios domain name is too long: %ws\n",
                                  (*ForestTrustList)[i].NetbiosDomainName ));

                        LeaveCriticalSection( &NlGlobalLogFileCritSect );
                        goto Cleanup;
                    }

                    wcscpy( TempTrustedDomainList[TempTrustedDomainCount].UnicodeNetbiosDomainName,
                            (*ForestTrustList)[i].NetbiosDomainName );
                }


                //
                // Copy the DNS domain name
                //

                if ( (*ForestTrustList)[i].DnsDomainName != NULL ) {

                    TempTrustedDomainList[TempTrustedDomainCount].Utf8DnsDomainName =
                        NetpAllocUtf8StrFromWStr( (*ForestTrustList)[i].DnsDomainName );

                    if ( TempTrustedDomainList[TempTrustedDomainCount].Utf8DnsDomainName == NULL ) {
                        NlPrint(( NL_CRITICAL,
                                  "Can't convert to UTF-8: %ws\n",
                                  (*ForestTrustList)[i].DnsDomainName ));
                        LeaveCriticalSection( &NlGlobalLogFileCritSect );
                        goto Cleanup;
                    }

                    LocalTrustedDomainSize += strlen(TempTrustedDomainList[TempTrustedDomainCount].Utf8DnsDomainName ) + 1;
                }

                //
                // If this is a primary domain entry,
                //  remember whether it's mixed mode
                //

                if ( (*ForestTrustList)[i].Flags & DS_DOMAIN_PRIMARY ) {
                    if ( (*ForestTrustList)[i].Flags & DS_DOMAIN_NATIVE_MODE ) {
                        NlGlobalWorkstationMixedModeDomain = FALSE;
                    } else {
                        NlGlobalWorkstationMixedModeDomain = TRUE;
                    }
                }

                //
                // Move on to the next entry
                //

                TempTrustedDomainCount ++;
                LocalTrustedDomainSize += sizeof(TRUSTED_DOMAIN);

            }

            LeaveCriticalSection( &NlGlobalLogFileCritSect );

            //
            // Allocate a single buffer to contain the list
            //  (to improve locality of reference)
            //

            LocalTrustedDomainList = NetpMemoryAllocate( LocalTrustedDomainSize );

            if ( LocalTrustedDomainList == NULL ) {
                goto Cleanup;
            }

            Where = (LPBYTE)(&LocalTrustedDomainList[TempTrustedDomainCount]);
            LocalTrustedDomainCount = TempTrustedDomainCount;

            //
            // Copy it to the local buffer
            //

            for ( i=0; i<TempTrustedDomainCount; i++ ) {

                //
                // Copy the Netbios domain name
                //

                RtlCopyMemory( LocalTrustedDomainList[i].UnicodeNetbiosDomainName,
                               TempTrustedDomainList[i].UnicodeNetbiosDomainName,
                               sizeof(LocalTrustedDomainList[i].UnicodeNetbiosDomainName ));

                //
                // Copy the DNS domain name
                //

                if ( TempTrustedDomainList[i].Utf8DnsDomainName != NULL ) {
                    ULONG Utf8DnsDomainNameSize;
                    Utf8DnsDomainNameSize = strlen(TempTrustedDomainList[i].Utf8DnsDomainName ) + 1;

                    LocalTrustedDomainList[i].Utf8DnsDomainName = (LPSTR) Where;
                    RtlCopyMemory( Where,
                                   TempTrustedDomainList[i].Utf8DnsDomainName,
                                   Utf8DnsDomainNameSize );
                    Where += Utf8DnsDomainNameSize;
                } else {
                    LocalTrustedDomainList[i].Utf8DnsDomainName = NULL;
                }

            }
        }


        //
        // Swap in the new list
        //

        EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
        OldList = NlGlobalTrustedDomainList;
        NlGlobalTrustedDomainList = LocalTrustedDomainList;
        LocalTrustedDomainList = NULL;
        NlGlobalTrustedDomainCount = LocalTrustedDomainCount;
        NlQuerySystemTime( &NlGlobalTrustedDomainListTime );
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );


        //
        // Free the old list.
        //

        if ( OldList != NULL ) {
            NetpMemoryFree( OldList );
        }


    //
    // On a DC,
    //  save the exact list we want to return later.
    //

    } else {
        LOCK_TRUST_LIST( DomainInfo );
        if ( DomainInfo->DomForestTrustList != NULL ) {
            MIDL_user_free( DomainInfo->DomForestTrustList );
            DomainInfo->DomForestTrustList = NULL;
        }
        DomainInfo->DomForestTrustList = *ForestTrustList;
        *ForestTrustList = NULL;
        DomainInfo->DomForestTrustListSize = ForestTrustListSize;
        DomainInfo->DomForestTrustListCount = ForestTrustListCount;
        UNLOCK_TRUST_LIST( DomainInfo );
    }

    //
    // Free locally used resources.
    //
Cleanup:
    if ( TempTrustedDomainList != NULL ) {
        for ( i=0; i<TempTrustedDomainCount; i++ ) {
            if ( TempTrustedDomainList[i].Utf8DnsDomainName != NULL ) {
                NetpMemoryFree( TempTrustedDomainList[i].Utf8DnsDomainName );
            }
        }

        NetpMemoryFree( TempTrustedDomainList );
    }

    if ( LocalTrustedDomainList != NULL ) {
        NetpMemoryFree( LocalTrustedDomainList );
    }

}


BOOLEAN
NlIsDomainTrusted (
    IN PUNICODE_STRING DomainName
    )

/*++

Routine Description:

    Determine if the specified domain is trusted.

Arguments:

    DomainName - Name of the DNS or Netbios domain to query.

Return Value:

    TRUE - if the domain name specified is a trusted domain.

--*/
{
    NTSTATUS Status;
    DWORD i;
    BOOLEAN RetVal;

    LPSTR Utf8String = NULL;


    PDOMAIN_INFO DomainInfo = NULL;

    //
    // If the no domain name was specified,
    //  indicate the domain is not trusted.
    //

    if ( DomainName == NULL || DomainName->Length == 0 ) {
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Get a pointer to the primary domain info.
    //

    DomainInfo = NlFindNetbiosDomain( NULL, TRUE );    // Primary domain

    if ( DomainInfo == NULL ) {
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Convert the input string to UTF-8
    //

    Utf8String = NetpAllocUtf8StrFromUnicodeString( DomainName );

    if ( Utf8String == NULL ) {
        RetVal = FALSE;
        goto Cleanup;
    }




    //
    // Compare the input trusted domain name to each element in the list
    //

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
    for ( i=0; i<NlGlobalTrustedDomainCount; i++ ) {
        UNICODE_STRING UnicodeNetbiosDomainName;

        RtlInitUnicodeString( &UnicodeNetbiosDomainName,
                              NlGlobalTrustedDomainList[i].UnicodeNetbiosDomainName );


        //
        // Simply compare the bytes (both are already uppercased)
        //
        if ( RtlEqualDomainName( DomainName, &UnicodeNetbiosDomainName ) ||
             ( Utf8String != NULL &&
               NlGlobalTrustedDomainList[i].Utf8DnsDomainName != NULL &&
               NlEqualDnsNameUtf8( Utf8String,
                                NlGlobalTrustedDomainList[i].Utf8DnsDomainName ) ) ) {

           LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
           RetVal = TRUE;
           goto Cleanup;
        }

    }
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    //
    // All other domains aren't trusted.
    //

    RetVal = FALSE;

Cleanup:
    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }
    if ( Utf8String != NULL ) {
        NetApiBufferFree( Utf8String );
    }

    return RetVal;
}


NET_API_STATUS
NlGetTrustedDomainNames (
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR DomainName,
    OUT LPWSTR *TrustedDnsDomainName,
    OUT LPWSTR *TrustedNetbiosDomainName
    )

/*++

Routine Description:

    Get a DNS name of a trusted domain given its Netbios name.

Arguments:

    DomainInfo - Hosted domain info.

    DomainName - Name of the Netbios or DNS domain to query.

    TrustedDnsDomainName - Returns the DnsDomainName of the domain if DomainName is trusted.
        The buffer must be freed using NetApiBufferFree.

    TrustedNetbiosDomainName - Returns the Netbios domain name of the domain if DomainName is trusted.
        The buffer must be freed using NetApiBufferFree.

Return Value:

    NO_ERROR: The routine functioned properly. The returned domain name may or may not
        be set depending on whether DomainName is trusted.

--*/
{
    NET_API_STATUS NetStatus;

    ULONG Index;
    LPSTR Utf8DomainName = NULL;

    //
    // Initialization
    //

    *TrustedDnsDomainName = NULL;
    *TrustedNetbiosDomainName = NULL;


    //
    // On a workstation, look up the global trust list
    //

    if ( NlGlobalMemberWorkstation ) {

        //
        // Convert the input string to UTF-8
        //

        Utf8DomainName = NetpAllocUtf8StrFromWStr( DomainName );

        if ( Utf8DomainName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
        for ( Index=0; Index<NlGlobalTrustedDomainCount; Index++ ) {

            //
            // If the passed in name is either the Netbios or DNS name of the trusted domain,
            //  return both names to the caller.
            //
            if ( (NlGlobalTrustedDomainList[Index].UnicodeNetbiosDomainName != NULL &&
                  NlNameCompare( NlGlobalTrustedDomainList[Index].UnicodeNetbiosDomainName,
                                 DomainName,
                                 NAMETYPE_DOMAIN ) == 0 ) ||
                 (NlGlobalTrustedDomainList[Index].Utf8DnsDomainName != NULL &&
                  NlEqualDnsNameUtf8( NlGlobalTrustedDomainList[Index].Utf8DnsDomainName,
                                   Utf8DomainName ) ) ) {

                if ( NlGlobalTrustedDomainList[Index].UnicodeNetbiosDomainName != NULL ) {
                    *TrustedNetbiosDomainName = NetpAllocWStrFromWStr( NlGlobalTrustedDomainList[Index].UnicodeNetbiosDomainName );
                    if ( *TrustedNetbiosDomainName == NULL ) {
                        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
                        goto Cleanup;
                    }
                }

                if ( NlGlobalTrustedDomainList[Index].Utf8DnsDomainName != NULL ) {
                    *TrustedDnsDomainName = NetpAllocWStrFromUtf8Str( NlGlobalTrustedDomainList[Index].Utf8DnsDomainName );
                    if ( *TrustedDnsDomainName == NULL ) {
                        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
                        goto Cleanup;
                    }
                }

                break;
            }
        }
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    //
    // On a DC, search the forest trust list associated with the DomainInfo
    //

    } else {

        LOCK_TRUST_LIST( DomainInfo );

        for ( Index=0; Index<DomainInfo->DomForestTrustListCount; Index++ ) {

            //
            // If the passed in name is either the Netbios or DNS name of the trusted domain,
            //  return both names to the caller.
            //

            if ( (DomainInfo->DomForestTrustList[Index].NetbiosDomainName != NULL &&
                  NlNameCompare( DomainInfo->DomForestTrustList[Index].NetbiosDomainName,
                                 DomainName,
                                 NAMETYPE_DOMAIN ) == 0 ) ||
                 (DomainInfo->DomForestTrustList[Index].DnsDomainName != NULL &&
                  NlEqualDnsName( DomainInfo->DomForestTrustList[Index].DnsDomainName,
                                   DomainName ) ) ) {

                if ( DomainInfo->DomForestTrustList[Index].NetbiosDomainName != NULL ) {
                    *TrustedNetbiosDomainName = NetpAllocWStrFromWStr( DomainInfo->DomForestTrustList[Index].NetbiosDomainName );
                    if ( *TrustedNetbiosDomainName == NULL ) {
                        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                        UNLOCK_TRUST_LIST( DomainInfo );
                        goto Cleanup;
                    }
                }

                if ( DomainInfo->DomForestTrustList[Index].DnsDomainName != NULL ) {
                    *TrustedDnsDomainName = NetpAllocWStrFromWStr( DomainInfo->DomForestTrustList[Index].DnsDomainName );
                    if ( *TrustedDnsDomainName == NULL ) {
                        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                        UNLOCK_TRUST_LIST( DomainInfo );
                        goto Cleanup;
                    }

                }

                break;
            }
        }

        UNLOCK_TRUST_LIST( DomainInfo );
    }

    NetStatus = NO_ERROR;

Cleanup:
    if ( NetStatus != NO_ERROR ) {
        if ( *TrustedDnsDomainName != NULL ) {
            NetApiBufferFree( *TrustedDnsDomainName );
            *TrustedDnsDomainName = NULL;
        }
        if ( *TrustedNetbiosDomainName != NULL ) {
            NetApiBufferFree( *TrustedNetbiosDomainName );
            *TrustedNetbiosDomainName = NULL;
        }
    }

    if ( Utf8DomainName != NULL ) {
        NetpMemoryFree( Utf8DomainName );
    }
    return NetStatus;
}

VOID
NlDcDiscoveryWorker(
    IN PVOID Context
    )
/*++

Routine Description:

    Worker routine to asynchronously do DC discovery for a client session.

Arguments:

    Context - ClientSession to do DC discovery for

Return Value:

    None

--*/
{
    NTSTATUS Status;
    PCLIENT_SESSION ClientSession = (PCLIENT_SESSION) Context;

    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsState == CS_IDLE );
    NlAssert( ClientSession->CsDiscoveryFlags & CS_DISCOVERY_ASYNCHRONOUS );


    //
    // Call to discovery routine again telling it we're now in the worker routine.
    //  Avoid discovery if being asked to terminate.
    //

    if ( !NlGlobalTerminate ) {
        (VOID) NlDiscoverDc ( ClientSession,
                              (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_DEAD_DOMAIN) ?
                                    DT_DeadDomain : DT_Asynchronous,
                              TRUE,
                              FALSE ); // with-account discovery is not performed from the discovery thread
    }



    //
    // This was an async discovery,
    //  let everyone know we're done.
    //

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsDiscoveryFlags & CS_DISCOVERY_ASYNCHRONOUS );

    ClientSession->CsDiscoveryFlags &= ~CS_DISCOVERY_ASYNCHRONOUS;
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );


    //
    // Let any other caller know we're done.
    //

    NlAssert( ClientSession->CsDiscoveryEvent != NULL );

    if ( !SetEvent( ClientSession->CsDiscoveryEvent ) ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                  "NlDiscoverDc: SetEvent failed %ld\n",
                  GetLastError() ));
    }

    //
    // We no longer care about the Client session
    //

    NlUnrefClientSession( ClientSession );
}



VOID
NlDcQueueDiscovery (
    IN OUT PCLIENT_SESSION ClientSession,
    IN DISCOVERY_TYPE DiscoveryType
    )

/*++

Routine Description:

    This routine queues an async discovery to an async discovery thread.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.
        The caller must be a writer of the trust list entry.
        NlGlobalDcDiscoveryCritSect must be locked.

Arguments:

    ClientSession -- Client session structure whose DC is to be picked.
        The Client Session structure must be marked for write.
        The Client Session structure must be idle.

    DiscoveryType -- Indicates Asynchronous, or rediscovery of a "Dead domain".

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;
    BOOL ReturnValue;
    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsState == CS_IDLE );

    //
    // Don't let the session go away during discovery.
    //

    ClientSession->CsDiscoveryFlags |= CS_DISCOVERY_ASYNCHRONOUS;

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    NlRefClientSession( ClientSession );
    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

    //
    // Indicate the discovery is in progress.
    //

    NlAssert( ClientSession->CsDiscoveryEvent != NULL );

    if ( !ResetEvent( ClientSession->CsDiscoveryEvent ) ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                "NlDcQueueDiscovery: ResetEvent failed %ld\n",
                GetLastError() ));
    }

    //
    // Queue this client session for async discovery.
    //

    if ( DiscoveryType == DT_DeadDomain ) {
        ClientSession->CsDiscoveryFlags |= CS_DISCOVERY_DEAD_DOMAIN;
    } else {
        ClientSession->CsDiscoveryFlags &= ~CS_DISCOVERY_DEAD_DOMAIN;
    }

    ReturnValue = NlQueueWorkItem( &ClientSession->CsAsyncDiscoveryWorkItem, TRUE, FALSE );

    //
    // If we can't queue the entry,
    //  undo what we've done above.


    if ( !ReturnValue ) {
        NlAssert( ClientSession->CsReferenceCount > 0 );
        NlAssert( ClientSession->CsDiscoveryFlags & CS_DISCOVERY_ASYNCHRONOUS );

        NlPrintCs(( NL_CRITICAL, ClientSession,
                "NlDcQueueDiscovery: Can't queue it.\n" ));

        ClientSession->CsDiscoveryFlags &= ~CS_DISCOVERY_ASYNCHRONOUS;


        //
        // Let any other caller know we're done.
        //

        NlAssert( ClientSession->CsDiscoveryEvent != NULL );

        if ( !SetEvent( ClientSession->CsDiscoveryEvent ) ) {
            NlPrintCs(( NL_CRITICAL, ClientSession,
                      "NlDiscoverDc: SetEvent failed %ld\n",
                      GetLastError() ));
        }

        //
        // We no longer care about the Client session
        //

        NlUnrefClientSession( ClientSession );
    }

    return;

}



NET_API_STATUS
NlSetServerClientSession(
    IN OUT PCLIENT_SESSION ClientSession,
    IN PNL_DC_CACHE_ENTRY NlDcCacheEntry,
    IN BOOL DcDiscoveredWithAccount,
    IN BOOL SessionRefresh
    )

/*++

Routine Description:

    Sets the name of a discovered DC and optionally its IP address
    and the discovery flags onto a ClientSession.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.

Arguments:

    ClientSession -- Client session structure whose DC is to be picked.

    NlDcCacheEntry -- DC cache entry.

    DcDiscoveredWithAccount - If TRUE, the DC was discovered with account.

    SessionRefresh -- TRUE if this is a session refresh. If so, the caller
        must be a writer of the client session. If FALSE, the client session
        must be idle in which case the caller doesn't have to be a writer since
        it is safe to change (atomically) the server name from NULL to non-NULL
        with only NlGlobalDcDiscoveryCritSect locked.

Return Value:

    NO_ERROR - Success
    ERROR_NOT_ENOUGH_MEMORY - Not enough memory to allocate name
    ERROR_INVALID_COMPUTERNAME - ComputerName is too long

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR TmpUncServerName = NULL;
    ULONG  TmpDiscoveryFlags = 0;
    LPWSTR CacheEntryServerName = NULL;
    ULONG OldDiscoveryFlags = 0;

    NlAssert( ClientSession->CsReferenceCount > 0 );

    //
    // If this is a session refresh,
    //  the caller must be a writer of the client session
    //
    if ( SessionRefresh ) {
        NlAssert( ClientSession->CsFlags & CS_WRITER );

    //
    //  Othewise the client session must be idle
    //
    } else {
        NlAssert( ClientSession->CsState == CS_IDLE);
        NlAssert( ClientSession->CsUncServerName == NULL );
        NlAssert( ClientSession->CsServerSockAddr.iSockaddrLength == 0 );
        NlAssert( ClientSession->ClientAuthData == NULL );
        NlAssert( ClientSession->CsCredHandle.dwUpper == 0 && ClientSession->CsCredHandle.dwLower == 0 );
    }


    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

    //
    // Choose the server name. If we got the cache entry over ldap,
    //  prefer the DNS name. Otherwise, prefer the Netbios name.
    //

    if ( NlDcCacheEntry->CacheEntryFlags & NL_DC_CACHE_LDAP ) {

        if ( NlDcCacheEntry->UnicodeDnsHostName != NULL ) {
            CacheEntryServerName = NlDcCacheEntry->UnicodeDnsHostName;
            TmpDiscoveryFlags |= CS_DISCOVERY_DNS_SERVER;
        } else if ( NlDcCacheEntry->UnicodeNetbiosDcName != NULL ) {
            CacheEntryServerName = NlDcCacheEntry->UnicodeNetbiosDcName;
        }

        //
        // Indicate that we should use ldap to ping this DC
        //
        TmpDiscoveryFlags |= CS_DISCOVERY_USE_LDAP;

    } else if ( NlDcCacheEntry->CacheEntryFlags & NL_DC_CACHE_MAILSLOT ) {

        if ( NlDcCacheEntry->UnicodeNetbiosDcName != NULL ) {
            CacheEntryServerName = NlDcCacheEntry->UnicodeNetbiosDcName;
        } else if ( NlDcCacheEntry->UnicodeDnsHostName != NULL ) {
            CacheEntryServerName = NlDcCacheEntry->UnicodeDnsHostName;
            TmpDiscoveryFlags |= CS_DISCOVERY_DNS_SERVER;
        }

        //
        // Indicate that we should use mailslots to ping this DC
        //
        TmpDiscoveryFlags |= CS_DISCOVERY_USE_MAILSLOT;
    }

    if ( CacheEntryServerName == NULL ) {
        NlPrint(( NL_CRITICAL, "NlSetServerClientSession: Invalid data\n" ));
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
        return ERROR_INVALID_DATA;
    }

    NetStatus = NetApiBufferAllocate(
                    (wcslen(CacheEntryServerName) + 3) * sizeof(WCHAR),
                    &TmpUncServerName );

    if ( NetStatus != NO_ERROR ) {
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
        return NetStatus;
    }
    wcscpy( TmpUncServerName, L"\\\\" );
    wcscpy( TmpUncServerName+2, CacheEntryServerName );

    //
    // Indicate whether the server has IP address
    //

    if ( NlDcCacheEntry->SockAddr.iSockaddrLength != 0 ) {
        TmpDiscoveryFlags |= CS_DISCOVERY_HAS_IP;
    }

    //
    // Indicate whether the server is NT5 machine and whether it is in a close site.
    //

    if ( (NlDcCacheEntry->ReturnFlags & DS_DS_FLAG) != 0 ) {
        TmpDiscoveryFlags |= CS_DISCOVERY_HAS_DS;
        NlPrintCs(( NL_SESSION_MORE, ClientSession,
                "NlSetServerClientSession: New DC is an NT 5 DC: %ws\n",
                TmpUncServerName ));
    }

    //
    // If the server or client site is not known, assume closest site
    //

    if ( NlDcCacheEntry->UnicodeDcSiteName == NULL ||
         NlDcCacheEntry->UnicodeClientSiteName == NULL ) {
        TmpDiscoveryFlags |= CS_DISCOVERY_IS_CLOSE;
        NlPrintCs(( NL_SESSION_MORE, ClientSession,
                "NlSetServerClientSession: New DC site isn't known (assume closest site): %ws\n",
                TmpUncServerName ));
    } else if ( (NlDcCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) != 0 ) {
        TmpDiscoveryFlags |= CS_DISCOVERY_IS_CLOSE;
        NlPrintCs(( NL_SESSION_MORE, ClientSession,
                "NlSetServerClientSession: New DC is in closest site: %ws\n",
                TmpUncServerName ));
    }

    //
    // Indicate if the server runs the Windows Time Service
    //

    if ( NlDcCacheEntry->ReturnFlags & DS_TIMESERV_FLAG ) {
        TmpDiscoveryFlags |= CS_DISCOVERY_HAS_TIMESERV;
        NlPrintCs(( NL_SESSION_MORE, ClientSession,
                "NlSetServerClientSession: New DC runs the time service: %ws\n",
                TmpUncServerName ));
    }


    //
    // Free the old server name, if any
    //

    if ( ClientSession->CsUncServerName != NULL ) {
        BOOL FreeCurrentName = FALSE;

        //
        // If the current name is Netbios ...
        //
        if ( (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_DNS_SERVER) == 0 ) {

            //
            // If the new name is DNS, free the current name
            //
            if ( (TmpDiscoveryFlags & CS_DISCOVERY_DNS_SERVER) != 0 ) {
                FreeCurrentName = TRUE;
            //
            // Otherwise, check whether the two Netbios names are different
            //  (Skip the UNC prefix in the names)
            //
            } else if ( NlNameCompare(ClientSession->CsUncServerName+2,
                                      TmpUncServerName+2,
                                      NAMETYPE_COMPUTER) != 0 ) {
                FreeCurrentName = TRUE;
            }

        //
        // If the current name is DNS ...
        //
        } else {

            //
            // If the new name is Netbios, free the current name
            //
            if ( (TmpDiscoveryFlags & CS_DISCOVERY_DNS_SERVER) == 0 ) {
                FreeCurrentName = TRUE;
            //
            // Otherwise, check whether the two DNS names are the same
            //  (Skip the UNC prefix in the names)
            //
            } else if ( !NlEqualDnsName(ClientSession->CsUncServerName+2,
                                        TmpUncServerName+2) ) {
                FreeCurrentName = TRUE;
            }
        }

        //
        // Free the current name as needed
        //
        if ( FreeCurrentName ) {
            NlPrintCs(( NL_SESSION_SETUP, ClientSession,
                        "NlSetServerClientSession: New DC name: %ws; Old DC name: %ws\n",
                        TmpUncServerName,
                        ClientSession->CsUncServerName ));
            NetApiBufferFree( ClientSession->CsUncServerName );
            ClientSession->CsUncServerName = NULL;
        }
    }

    //
    // Reset the discovery flags
    //

    OldDiscoveryFlags = ClientSession->CsDiscoveryFlags &
                               (CS_DISCOVERY_USE_MAILSLOT |
                                CS_DISCOVERY_USE_LDAP |
                                CS_DISCOVERY_HAS_DS |
                                CS_DISCOVERY_IS_CLOSE |
                                CS_DISCOVERY_DNS_SERVER |
                                CS_DISCOVERY_HAS_TIMESERV |
                                CS_DISCOVERY_HAS_IP);

    if ( OldDiscoveryFlags != TmpDiscoveryFlags ) {
        NlPrintCs(( NL_SESSION_MORE, ClientSession,
                    "NlSetServerClientSession: New discovery flags: 0x%lx; Old flags: 0x%lx\n",
                    TmpDiscoveryFlags,
                    OldDiscoveryFlags ));
        ClientSession->CsDiscoveryFlags &= ~OldDiscoveryFlags;
        ClientSession->CsDiscoveryFlags |= TmpDiscoveryFlags;
    }

    //
    // Make the (atomic) pointer assignments here
    //

    if ( ClientSession->CsUncServerName == NULL ) {
        ClientSession->CsUncServerName = TmpUncServerName;
        TmpUncServerName = NULL;
    }

    //
    // If there is a socket address, save it
    //

    if ( NlDcCacheEntry->SockAddr.iSockaddrLength != 0 ) {
        ClientSession->CsServerSockAddr.iSockaddrLength =
                       NlDcCacheEntry->SockAddr.iSockaddrLength;
        ClientSession->CsServerSockAddr.lpSockaddr =
                       (LPSOCKADDR) &ClientSession->CsServerSockAddrIn;
        RtlCopyMemory( ClientSession->CsServerSockAddr.lpSockaddr,
                       NlDcCacheEntry->SockAddr.lpSockaddr,
                       NlDcCacheEntry->SockAddr.iSockaddrLength );
    //
    // Otherwise, wipe out the previous socket address in the client session
    //

    } else {
        RtlZeroMemory( &ClientSession->CsServerSockAddr,
                       sizeof(ClientSession->CsServerSockAddr) );
        RtlZeroMemory( &ClientSession->CsServerSockAddrIn,
                       sizeof(ClientSession->CsServerSockAddrIn) );
    }

    //
    // If this is not just a refresh,
    // Leave CsConnectionStatus with a "failure" status code until the
    // secure channel is set up.  Other routines simply return
    // CsConnectionStatus as the state of the secure channel.
    //

    if ( !SessionRefresh) {
        ClientSession->CsLastAuthenticationTry.QuadPart = 0;
        NlQuerySystemTime( &ClientSession->CsLastDiscoveryTime );

        //
        // If the server was discovered with account,
        //  update that timestampt, too
        //
        if ( DcDiscoveredWithAccount ) {
            NlQuerySystemTime( &ClientSession->CsLastDiscoveryWithAccountTime );
        }
        ClientSession->CsState = CS_DC_PICKED;
    }

    //
    // Update the refresh time
    //

    NlQuerySystemTime( &ClientSession->CsLastRefreshTime );

    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    //
    // Free locally allocated memory
    //

    if ( TmpUncServerName != NULL ) {
        NetApiBufferFree( TmpUncServerName );
    }

    return NO_ERROR;
}



NTSTATUS
NlDiscoverDc (
    IN OUT PCLIENT_SESSION ClientSession,
    IN DISCOVERY_TYPE DiscoveryType,
    IN BOOLEAN InDiscoveryThread,
    IN BOOLEAN DiscoverWithAccount
    )

/*++

Routine Description:

    Get the name of a DC in a domain.

    If the ClientSession is not currently IDLE, then this is an attempt to
    discover a "better" DC.  In that case, the newly discovered DC will only be
    used if it is indeed "better" than the current DC.

    The current implementation only support synchronous attempts to find a "better"
    DC.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.
        The caller must be a writer of the trust list entry. (Unless in DiscoveryThread).

Arguments:

    ClientSession -- Client session structure whose DC is to be picked.

    DiscoveryType -- Indicate synchronous, Asynchronous, or rediscovery of a
        "Dead domain".

    InDiscoveryThread -- TRUE if this is the DiscoveryThread completing an async
        call.

    DiscoverWithAccount - If TRUE and this is not in discovery thread,
        the discovery with account will be performed. Otherwise, no account
        will be specified in the discovery attempt.

Return Value:

    STATUS_SUCCESS - if DC was found.
    STATUS_PENDING - Operation is still in progress
    STATUS_NO_LOGON_SERVERS - if DC was not found.
    STATUS_NO_TRUST_SAM_ACCOUNT - if DC was found but it does not have
        an account for this machine.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    ULONG AllowableAccountControlBits;
    LPWSTR TransportName = NULL;
    PNL_DC_CACHE_ENTRY DomainControllerCacheEntry = NULL;
    ULONG Flags = 0;
    ULONG InternalFlags = 0;
    LPWSTR CapturedInfo = NULL;
    LPWSTR CapturedDnsForestName;
    LPWSTR CapturedSiteName;
    LPWSTR LocalSiteName;


    //
    // Allocate a temp buffer
    //  (Don't put it on the stack since we don't want to commit a huge stack.)
    //

    CapturedInfo = LocalAlloc( 0,
                               (NL_MAX_DNS_LENGTH+1)*sizeof(WCHAR) +
                               (NL_MAX_DNS_LABEL_LENGTH+1)*sizeof(WCHAR) );

    if ( CapturedInfo == NULL ) {
        return STATUS_NO_MEMORY;
    }

    CapturedDnsForestName = CapturedInfo;
    CapturedSiteName = &CapturedDnsForestName[NL_MAX_DNS_LENGTH+1];

    //
    // Initialization
    //
    NlAssert( ClientSession->CsReferenceCount > 0 );
    // NlAssert( ClientSession->CsState == CS_IDLE );
    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

    //
    // Ignore discoveries on indirect trusts.
    //

    if ((ClientSession->CsFlags & CS_DIRECT_TRUST) == 0 ) {

        //
        // If this is a synchronous discovery,
        //  the caller is confused,
        //  tell him we can't find any DCs.
        //
        if ( DiscoveryType == DT_Synchronous ) {

            NlPrintCs(( NL_CRITICAL, ClientSession,
                      "NlDiscoverDc: Synchronous discovery attempt of indirect trust.\n" ));
            // NlAssert( DiscoveryType != DT_Synchronous );
            Status = STATUS_NO_LOGON_SERVERS;

        //
        // For non-synchronous,
        //  let the caller think he succeeded.
        //
        } else {
            Status = STATUS_PENDING;
        }
        goto Cleanup;
    }



    //
    // If we're in the discovery thread,
    //
    //

    if ( InDiscoveryThread ) {
        NlAssert( DiscoveryType != DT_Synchronous );

    //
    // If we're not in the discovery thread,
    //

    } else {
        NlAssert( ClientSession->CsFlags & CS_WRITER );


        //
        // Handle synchronous requests.
        //

        if ( DiscoveryType == DT_Synchronous ) {

            //
            // If discovery is already going on asynchronously,
            //  just wait for it.
            //

            if ( ClientSession->CsDiscoveryFlags & CS_DISCOVERY_ASYNCHRONOUS ) {
                DWORD WaitStatus;

                //
                // Boost the priority of the asynchronous discovery
                //  since we now really need it to complete quickly.
                //

                if ( !NlQueueWorkItem(&ClientSession->CsAsyncDiscoveryWorkItem, FALSE, TRUE) ) {
                    NlPrintCs(( NL_CRITICAL, ClientSession,
                            "NlDiscoverDc: Failed to boost ASYNC discovery priority\n" ));
                }

                //
                // Wait for the maximum time that a discovery might take.
                //  (Unlock the crit sect to allow the async discovery to complete)
                //

                LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
                WaitStatus = WaitForSingleObject(
                                ClientSession->CsDiscoveryEvent,
                                NL_DC_MAX_TIMEOUT + NlGlobalParameters.ExpectedDialupDelay*1000 + 1000 );  // Add extra second to avoid race
                EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );


                if ( WaitStatus == WAIT_OBJECT_0 ) {
                    if ( ClientSession->CsState == CS_DC_PICKED ) {
                        Status = STATUS_SUCCESS;
                    } else {
                        Status = ClientSession->CsConnectionStatus;
                        NlPrintCs((NL_CRITICAL, ClientSession,
                                "NlDiscoverDc: ASYNC discovery failed so we will too 0x%lx.\n",
                                Status ));
                    }

                } else if ( WaitStatus == WAIT_TIMEOUT ) {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                            "NlDiscoverDc: ASYNC discovery took too long.\n" ));
                    Status = STATUS_NO_LOGON_SERVERS;

                } else {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                            "NlDiscoverDc: wait error: %ld %ld\n",
                            GetLastError(),
                            WaitStatus ));
                    Status = NetpApiStatusToNtStatus( WaitStatus );
                }

                goto Cleanup;
            }



        //
        // If we're starting an async discovery,
        //  mark it so and queue up the discovery.
        //

        } else {

            //
            // If discovery is already going on asynchronously,
            //  we're done for now.
            //

            if ( ClientSession->CsDiscoveryFlags & CS_DISCOVERY_ASYNCHRONOUS ) {
                Status = STATUS_PENDING;
                goto Cleanup;
            }



            //
            // Queue the discovery
            //

            NlDcQueueDiscovery ( ClientSession, DiscoveryType );

            Status = STATUS_PENDING;
            goto Cleanup;
        }
    }


    //
    // Determine the Account type we're looking for.
    //

    InternalFlags |= DS_IS_TRUSTED_DOMAIN;
    switch ( ClientSession->CsSecureChannelType ) {
    case WorkstationSecureChannel:
        AllowableAccountControlBits = USER_WORKSTATION_TRUST_ACCOUNT;
        InternalFlags |= DS_IS_PRIMARY_DOMAIN;
        break;

    case TrustedDomainSecureChannel:
        AllowableAccountControlBits = USER_INTERDOMAIN_TRUST_ACCOUNT;
        break;

    case TrustedDnsDomainSecureChannel:
        AllowableAccountControlBits = USER_DNS_DOMAIN_TRUST_ACCOUNT;
        break;

    case ServerSecureChannel:
        AllowableAccountControlBits = USER_SERVER_TRUST_ACCOUNT;
        Flags |= DS_PDC_REQUIRED;
        InternalFlags |= DS_IS_PRIMARY_DOMAIN;
        break;

    default:
        NlPrintCs(( NL_CRITICAL, ClientSession,
                  "NlDiscoverDc: invalid SecureChannelType retry %ld\n",
                  ClientSession->CsSecureChannelType ));
        Status = STATUS_NO_LOGON_SERVERS;
        NlQuerySystemTime( &ClientSession->CsLastDiscoveryTime );
        if ( ClientSession->CsState == CS_IDLE ) {
            ClientSession->CsLastAuthenticationTry = ClientSession->CsLastDiscoveryTime;
            ClientSession->CsConnectionStatus = Status;
        }
        goto Cleanup;
    }



    NlPrintCs(( NL_SESSION_SETUP, ClientSession,
                "NlDiscoverDc: Start %s Discovery\n",
                DiscoveryType == DT_Synchronous ? "Synchronous" : "Async" ));


    //
    // Capture the name of the site this machine is in.
    //

    if  ( NlCaptureSiteName( CapturedSiteName ) ) {
        LocalSiteName = CapturedSiteName;
        InternalFlags |= DS_SITENAME_DEFAULTED;
    } else {
        LocalSiteName = NULL;
    }

    //
    // If the trusted domain is an NT 5 domain,
    //  prefer an NT 5 DC.
    //

    if ( ClientSession->CsFlags & CS_NT5_DOMAIN_TRUST ) {
        Flags |= DS_DIRECTORY_SERVICE_PREFERRED;
    }

    //
    // If we picked up a DC at least once, force the rediscovery
    //  as there is a reason we are called to get a different DC,
    //  so we want to avoid cached data. Otherwise, avoid forcing
    //  rediscovery so that we get the same DC as other components
    //  potentially discovered (in particular, this is important
    //  if other component's discovery resulted in join DC being
    //  cached -- we don't want to avoid that cache entry on our
    //  first secure channel setup).
    //

    if ( ClientSession->CsFlags & CS_DC_PICKED_ONCE ) {
        Flags |= DS_FORCE_REDISCOVERY;
    }

    //
    // Do the actual discovery of the DC.
    //
    // When NetpDcGetName is called from netlogon,
    //  it has both the Netbios and DNS domain name available for the primary
    //  domain.  That can trick DsGetDcName into returning DNS host name of a
    //  DC in the primary domain.  However, on IPX only systems, that won't work.
    //  Avoid that problem by not passing the DNS domain name of the primary domain
    //  if there are no DNS servers.
    //
    // Avoid having anything locked while calling NetpDcGetName.
    // It calls back into Netlogon and locks heaven only knows what.

    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
    NlCaptureDnsForestName( CapturedDnsForestName );

    NetStatus = NetpDcGetName(
                    ClientSession->CsDomainInfo,    // SendDatagramContext
                    ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
// #define DONT_REQUIRE_MACHINE_ACCOUNT 1
#ifdef DONT_REQUIRE_MACHINE_ACCOUNT // useful for number of trust testing
                    NULL,
#else // DONT_REQUIRE_MACHINE_ACCOUNT
                    DiscoverWithAccount ?  // pass the account name as appropriate
                        ClientSession->CsAccountName :
                        NULL,
#endif // DONT_REQUIRE_MACHINE_ACCOUNT
                    DiscoverWithAccount ?  // pass the account control bits as appropriate
                        AllowableAccountControlBits :
                        0,
                    ClientSession->CsNetbiosDomainName.Buffer,
                    NlDnsHasDnsServers() ? ClientSession->CsDnsDomainName.Buffer : NULL,
                    CapturedDnsForestName,
                    ClientSession->CsDomainId,
                    ClientSession->CsDomainGuid,
                    LocalSiteName,
                    Flags,
                    InternalFlags,
                    NL_DC_MAX_TIMEOUT + NlGlobalParameters.ExpectedDialupDelay*1000,
                    DiscoveryType == DT_DeadDomain ? 1 : MAX_DC_RETRIES,
                    NULL,
                    &DomainControllerCacheEntry );
    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

    if( NetStatus != NO_ERROR ) {

        //
        // Map the status to something more appropriate.
        //

        switch ( NetStatus ) {
        case ERROR_NO_SUCH_DOMAIN:
            NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlDiscoverDc: Cannot find DC.\n" ));
            Status = STATUS_NO_LOGON_SERVERS;
            break;

        case ERROR_NO_SUCH_USER:
            NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlDiscoverDc: DC reports no such account found.\n" ));
            Status = STATUS_NO_TRUST_SAM_ACCOUNT;
            break;

        default:
            NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlDiscoverDc: NetpDcGetName Unknown error %ld.\n",
                    NetStatus ));

            // This isn't the real status, but callers handle this status
            Status = STATUS_NO_LOGON_SERVERS;
            break;
        }

        NlQuerySystemTime( &ClientSession->CsLastDiscoveryTime );
        if ( ClientSession->CsState == CS_IDLE ) {
            ClientSession->CsLastAuthenticationTry = ClientSession->CsLastDiscoveryTime;
            ClientSession->CsConnectionStatus = Status;
        }

        //
        // If this discovery was with account, update that timestamp, too
        //
        if ( DiscoverWithAccount ) {
            NlQuerySystemTime( &ClientSession->CsLastDiscoveryWithAccountTime );
        }
        goto Cleanup;
    }

    //
    // Indicate that we at least once successfully
    //  discovered a DC for this client session
    //

    ClientSession->CsFlags |= CS_DC_PICKED_ONCE;

    //
    // Handle a non-idle secure channel
    //

    if ( ClientSession->CsState != CS_IDLE ) {

        //
        // If we're in the discovery thread,
        //  another thread must have finished the discovery.
        //  We're done since we're not the writer of the client session.
        //
        // When we implement doing async discovery while a session is already up,
        // we need to handle the case where someone has the ClientSession
        // write locked.  In that case, we should probably just hang the new
        // DCname somewhere off the ClientSession structure and swap in the
        // new DCname when the writer drops the write lock. ??
        //

        if ( InDiscoveryThread ) {
            NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlDiscoverDc: Async discovery completed by another thread (current value ignored).\n" ));
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }


        //
        // If the newly discovered DC is "better" than the old one,
        //  use the new one.
        //

        NlAssert( ClientSession->CsFlags & CS_WRITER );
        if ( ((ClientSession->CsDiscoveryFlags & CS_DISCOVERY_HAS_DS) == 0 &&
              (DomainControllerCacheEntry->ReturnFlags & DS_DS_FLAG) != 0) ||
             ((ClientSession->CsDiscoveryFlags & CS_DISCOVERY_IS_CLOSE) == 0 &&
                  (DomainControllerCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) != 0) ) {

            //
            // Set the client session to idle.
            //
            // Avoid having the crit sect locked while we unbind.
            //
            //
            LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
            NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );
            EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
        } else {
            NlPrintCs(( NL_SESSION_SETUP, ClientSession,
                        "NlDiscoverDc: Better DC not found (keeping NT old DC). 0x%lx 0x%lx\n",
                        ClientSession->CsDiscoveryFlags,
                        DomainControllerCacheEntry->ReturnFlags ));
            NlQuerySystemTime( &ClientSession->CsLastDiscoveryTime );

            //
            // If this discovery was with account, update that timestamp, too
            //
            if ( DiscoverWithAccount ) {
                NlQuerySystemTime( &ClientSession->CsLastDiscoveryWithAccountTime );
            }
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }
    }


    //
    // Set the new DC info in the Client session
    //

    NlSetServerClientSession( ClientSession,
                              DomainControllerCacheEntry,
                              DiscoverWithAccount ?   // was it discovery with account?
                                 TRUE :
                                 FALSE,
                              FALSE );  // not the session refresh

    //
    // Save the transport this discovery came in on.
    //
    // ?? NetpDcGetName should really return the TransportName as a parameter.
    // ?? I can't do this since it just does a mailslot "ReadFile" which doesn't
    //  return transport information.  So, I guess I'll just have to send UAS change
    //  datagrams on all transports.
    //
    if ( TransportName == NULL ) {
        NlPrintCs(( NL_SESSION_SETUP, ClientSession,
                "NlDiscoverDc: Found DC %ws\n",
                ClientSession->CsUncServerName ));
    } else {
        NlPrintCs(( NL_SESSION_SETUP, ClientSession,
                "NlDiscoverDc: Found DC %ws on transport %ws\n",
                ClientSession->CsUncServerName,
                TransportName ));

        ClientSession->CsTransport =
            NlTransportLookupTransportName( TransportName );

        if ( ClientSession->CsTransport == NULL ) {
            NlPrintCs(( NL_CRITICAL, ClientSession,
                      "NlDiscoverDc: %ws: Transport not found\n",
                      TransportName ));
        }
    }

    Status = STATUS_SUCCESS;


    //
    // Cleanup locally used resources.
    //
Cleanup:

    //
    // Unlock the crit sect and return.
    //
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    if ( DomainControllerCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( DomainControllerCacheEntry );
    }
    if ( CapturedInfo != NULL ) {
        LocalFree( CapturedInfo );
    }

    return Status;
}




NET_API_STATUS
NlFlushCacheOnPnpWorker(
    IN PDOMAIN_INFO DomainInfo,
    IN PVOID Context
    )
/*++

Routine Description:

    Flush any caches that need to be flush when a new transport comes online

    This worker routine handles on hosted domain.

Arguments:

    DomainInfo - Domain the cache is to be flushed for

    Context - Not used.

Return Value:

    NO_ERROR: The cache was flushed.

--*/
{
    PCLIENT_SESSION ClientSession;
    PLIST_ENTRY ListEntry;


    //
    // Mark the global entry to indicate we've not tried to authenticate recently
    //

    ClientSession = NlRefDomClientSession( DomainInfo );

    if ( ClientSession != NULL ) {
        //
        // Become a writer to ensure that another thread won't set the
        // last auth time because it just finished a failed discovery.
        //
        if ( NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {

            if ( ClientSession->CsState != CS_AUTHENTICATED ) {
                NlPrintCs(( NL_SESSION_SETUP, ClientSession,
                          "     Zero LastAuth\n" ));
                EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
                ClientSession->CsLastAuthenticationTry.QuadPart = 0;
                LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
            }

            NlResetWriterClientSession( ClientSession );

        } else {
            NlPrintCs(( NL_CRITICAL, ClientSession,
                      "     Cannot Zero LastAuth since cannot become writer.\n" ));
        }
        NlUnrefClientSession( ClientSession );
    }



    //
    // Mark each entry to indicate we've not tried to authenticate recently
    //

    LOCK_TRUST_LIST( DomainInfo );
    for ( ListEntry = DomainInfo->DomTrustList.Flink ;
          ListEntry != &DomainInfo->DomTrustList ;
          ListEntry = ListEntry->Flink) {

        ClientSession = CONTAINING_RECORD( ListEntry,
                                           CLIENT_SESSION,
                                           CsNext );

        //
        // Flag each entry to indicate it needs to be processed
        //
        // There may be multiple threads in this routine simultaneously.
        // Each thread will set CS_ZERO_LAST_AUTH.  Only one thread needs
        // to do the work.
        //
        ClientSession->CsFlags |= CS_ZERO_LAST_AUTH;
    }


    for ( ListEntry = DomainInfo->DomTrustList.Flink ;
          ListEntry != &DomainInfo->DomTrustList ;
          ) {

        ClientSession = CONTAINING_RECORD( ListEntry,
                                           CLIENT_SESSION,
                                           CsNext );

        //
        // If we've already done this entry,
        //  skip this entry.
        //
        if ( (ClientSession->CsFlags & CS_ZERO_LAST_AUTH) == 0 ) {
          ListEntry = ListEntry->Flink;
          continue;
        }
        ClientSession->CsFlags &= ~CS_ZERO_LAST_AUTH;

        //
        // Reference this entry while doing the work.
        //  Unlock the trust list to keep the locking order right.
        //

        NlRefClientSession( ClientSession );

        UNLOCK_TRUST_LIST( DomainInfo );

        //
        // Become a writer to ensure that another thread won't set the
        // last auth time because it just finished a failed discovery.
        //
        if ( NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {

            if ( ClientSession->CsState != CS_AUTHENTICATED ) {
                NlPrintCs(( NL_SESSION_SETUP, ClientSession,
                          "     Zero LastAuth\n" ));
                EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
                ClientSession->CsLastAuthenticationTry.QuadPart = 0;
                LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
            }

            NlResetWriterClientSession( ClientSession );

        } else {
            NlPrintCs(( NL_CRITICAL, ClientSession,
                      "     Cannot Zero LastAuth since cannot become writer.\n" ));
        }

        //
        // Since we dropped the trust list lock,
        //  we'll start the search from the front of the list.
        //

        NlUnrefClientSession( ClientSession );
        LOCK_TRUST_LIST( DomainInfo );

        ListEntry = DomainInfo->DomTrustList.Flink ;

    }

    UNLOCK_TRUST_LIST( DomainInfo );

    return NO_ERROR;
    UNREFERENCED_PARAMETER( Context );
}



VOID
NlFlushCacheOnPnp (
    VOID
    )

/*++

Routine Description:

    Flush any caches that need to be flush when a new transport comes online

Arguments:

    None.

Return Value:

    None

--*/
{

    //
    // Flush caches specific to a trusted domain.
    //
    NlEnumerateDomains( FALSE, NlFlushCacheOnPnpWorker, NULL );

    //
    // Flush the failure to find a DC.
    //
    NetpDcFlushNegativeCache();

}


#ifdef _DC_NETLOGON

NTSTATUS
NlUpdateForestTrustList (
    IN PNL_INIT_TRUSTLIST_CONTEXT InitTrustListContext,
    IN PCLIENT_SESSION ClientSession OPTIONAL,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX CurrentTrust,
    IN ULONG CsFlags,
    IN ULONG TdFlags,
    IN ULONG ParentIndex,
    IN GUID *DomainGuid OPTIONAL,
    OUT PULONG MyIndex OPTIONAL
    )

/*++

Routine Description:

    Update a single in-memory trust list entry to match the LSA.
    Do async discovery on a domain.

        Enter with the domain trust list locked.

Arguments:

    InitTrustListContext - Context describing the current trust list enumeration

    DomainInfo - Hosted domain to update the trust list for.

    ClientSession - Netlogon trust entry
        NULL implies netlogon isn't interested in this trust object

    CurrentTrust - Description of the trusted domain.

    CsFlags - Flags from the client session structure describing the trust.
        These are CS_ flags.

    TdFlags - Flags from the Trusted domains structure describing the trust.
        These are DS_DOMAIN_ flags.

    ParentIndex - Passes in the Index of the domain that is the parent of this domain

    DomainGuid - GUID of the trusted domain

    MyIndex - Returns the index of this domain

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    PDS_DOMAIN_TRUSTSW TrustedDomain = NULL;

    ULONG Size;
    ULONG VariableSize;

    UNICODE_STRING NetbiosDomainName;
    UNICODE_STRING DnsDomainName;
    PSID DomainSid;
    ULONG Index;

    //
    // Grab the names that we're actually going to store
    //

    if ( ClientSession == NULL ) {
        if ( CurrentTrust->TrustType == TRUST_TYPE_UPLEVEL ) {
            DnsDomainName = *((PUNICODE_STRING)&CurrentTrust->Name);
        } else {
            RtlInitUnicodeString( &DnsDomainName, NULL );
        }
        NetbiosDomainName = *((PUNICODE_STRING)&CurrentTrust->FlatName);
        DomainSid = CurrentTrust->Sid;
    } else {
        DnsDomainName = ClientSession->CsDnsDomainName;
        NetbiosDomainName = ClientSession->CsNetbiosDomainName;
        DomainSid = ClientSession->CsDomainId;
    }

    //
    // Determine if there is already an entry for this domain.
    //

    for ( Index=0; Index<InitTrustListContext->DomForestTrustListCount; Index++ ) {

        ULONG ThisIsIt;
        TrustedDomain = &((PDS_DOMAIN_TRUSTSW)(InitTrustListContext->BufferDescriptor.Buffer))[Index];

        //
        // Compare against each of the specified parameters.
        //  This avoids cases where two domains have similar names.  That
        //  will most likely happen if two netbios names collide after netbios
        //  is turned off.
        //
        ThisIsIt = FALSE;
        if ( DomainSid != NULL &&
             TrustedDomain->DomainSid != NULL ) {

            if ( RtlEqualSid( TrustedDomain->DomainSid, DomainSid ) ) {
                ThisIsIt = TRUE;
            }
        }

        if ( NetbiosDomainName.Length != 0 &&
             TrustedDomain->NetbiosDomainName != NULL ) {
            UNICODE_STRING LocalUnicodeString;

            RtlInitUnicodeString( &LocalUnicodeString, TrustedDomain->NetbiosDomainName );

            if ( RtlEqualDomainName( &NetbiosDomainName,
                                     &LocalUnicodeString )) {
                ThisIsIt = TRUE;
            } else {
                if ( ThisIsIt ) {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                                "NlUpdateForestTrustList: Similar trusts have different netbios names: %wZ %wZ\n",
                                &NetbiosDomainName,
                                &LocalUnicodeString ));
                    TrustedDomain = NULL;
                    continue;
                }
            }
        }

        if ( DnsDomainName.Length != 0 &&
             TrustedDomain->DnsDomainName != NULL ) {
            UNICODE_STRING LocalUnicodeString;

            RtlInitUnicodeString( &LocalUnicodeString, TrustedDomain->DnsDomainName );

            if ( NlEqualDnsNameU( &DnsDomainName,
                                  &LocalUnicodeString ) ) {
                ThisIsIt = TRUE;
            } else {
                if ( ThisIsIt ) {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                                "NlUpdateForestTrustList: Similar trusts have different DNS names: %wZ %wZ\n",
                                &DnsDomainName,
                                &LocalUnicodeString ));
                    TrustedDomain = NULL;
                    continue;
                }
            }
        }

        //
        // If we found a match,
        //  we're done.
        //
        if ( ThisIsIt ) {
            if ( ARGUMENT_PRESENT( MyIndex )) {
                *MyIndex = Index;
            }
            break;
        }

        TrustedDomain = NULL;
    }

    //
    // If no entry was found,
    //  allocate one.
    //

    if ( TrustedDomain == NULL ) {

        Status = NlAllocateForestTrustListEntry (
                    &InitTrustListContext->BufferDescriptor,
                    &NetbiosDomainName,
                    &DnsDomainName,
                    0,
                    0,          // Start with no parent index
                    CurrentTrust->TrustType,
                    0,          // Start with no trust attributes
                    DomainSid,
                    NULL,       // Start with no GUID
                    &Size,
                    &TrustedDomain );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }


        //
        // Update our context to account for the new entry
        //

        InitTrustListContext->DomForestTrustListSize += Size;

        if ( ARGUMENT_PRESENT( MyIndex )) {
            *MyIndex = InitTrustListContext->DomForestTrustListCount;
        }
        InitTrustListContext->DomForestTrustListCount ++;

    }

    //
    // Update any existing information.
    //

    TrustedDomain->Flags |= TdFlags;

    if ( CsFlags & CS_DOMAIN_IN_FOREST ) {
        TrustedDomain->Flags |= DS_DOMAIN_IN_FOREST;
    }
    if ( (CsFlags & CS_DIRECT_TRUST) &&
         (CurrentTrust->TrustDirection & TRUST_DIRECTION_OUTBOUND) ) {
        TrustedDomain->Flags |= DS_DOMAIN_DIRECT_OUTBOUND;
    }
    if ( (CsFlags & CS_DIRECT_TRUST) &&
         (CurrentTrust->TrustDirection & TRUST_DIRECTION_INBOUND) ) {
        TrustedDomain->Flags |= DS_DOMAIN_DIRECT_INBOUND;
    }

    if ( ParentIndex != 0 ) {
        NlAssert( TrustedDomain->ParentIndex == 0 || TrustedDomain->ParentIndex == ParentIndex );
        TrustedDomain->ParentIndex = ParentIndex;
    }
    TrustedDomain->TrustType = CurrentTrust->TrustType;
    TrustedDomain->TrustAttributes |= CurrentTrust->TrustAttributes;

    if ( DomainGuid != NULL ) {
        TrustedDomain->DomainGuid = *DomainGuid;
    }


    //
    // If this node is at the root of a tree, set its ParentIndex to 0
    //
    //

    if ( (TrustedDomain->Flags & DS_DOMAIN_TREE_ROOT) != 0 &&
         (TrustedDomain->Flags & DS_DOMAIN_IN_FOREST) != 0 ) {
        TrustedDomain->ParentIndex = 0;
    }


    Status = STATUS_SUCCESS;


Cleanup:

    return Status;
}



NTSTATUS
NlUpdateTrustList (
    IN PNL_INIT_TRUSTLIST_CONTEXT InitTrustListContext,
    IN PDOMAIN_INFO DomainInfo,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX CurrentTrust,
    IN BOOLEAN IsTdo,
    IN ULONG Flags,
    IN ULONG ParentIndex,
    IN ULONG TdFlags OPTIONAL,
    IN GUID *DomGuid OPTIONAL,
    OUT PULONG MyIndex OPTIONAL,
    OUT PCLIENT_SESSION *RetClientSession OPTIONAL
    )

/*++

Routine Description:

    Update a single in-memory trust list entry to match the LSA.

        Enter with the domain trust list locked.

Arguments:

    InitTrustListContext - Context describing the current trust list enumeration

    DomainInfo - Hosted domain to update the trust list for.

    CurrentTrust - Description of the trusted domain.

    IsTdo - TRUE if CurrentTrust specifies the information from the TDO itself.
        FALSE if CurrentTrust specifies information crafted from a cross ref object.

    Flags - Flags describing the trust.

    ParentIndex - Passes in the Index of the domain that is the parent of this domain

    MyIndex - Returns the index of this domain

    TdFlags - Flags from the Trusted domains structure describing the trust.
        These are DS_DOMAIN_ flags.

    DomGuid - GUID of the trusted domain

    RetClientSession - If specified and the client session could be found or
        created, a pointer to the client session is returned here.
        ClientSession should be dereferenced using NlUnrefClientSession().

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;

    PLIST_ENTRY ListEntry;
    PCLIENT_SESSION ClientSession = NULL;

    BOOLEAN DeleteTrust = FALSE;
    PUNICODE_STRING DomainName = NULL;
    PUNICODE_STRING DnsDomainName = NULL;
    PSID DomainId = NULL;
    NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType;

    //
    // Initialization
    //

    if ( ARGUMENT_PRESENT( RetClientSession )) {
        *RetClientSession = NULL;
    }


    //
    // Get the individual fields from the trust description.
    //

    DomainName = (PUNICODE_STRING)&CurrentTrust->FlatName;
    if ( DomainName->Length == 0 ) {
        DomainName = NULL;
    }

    if ( CurrentTrust->TrustType == TRUST_TYPE_UPLEVEL ) {
        DnsDomainName = (PUNICODE_STRING)&CurrentTrust->Name;
        if ( DnsDomainName->Length == 0 ) {
            DnsDomainName = NULL;
        }
        Flags |= CS_NT5_DOMAIN_TRUST;
    }

    DomainId = CurrentTrust->Sid;



    //
    // No Client session needs to be establish for direct trust unless it is outbound.
    //

    if ( (Flags & CS_DIRECT_TRUST) &&
         (CurrentTrust->TrustDirection & TRUST_DIRECTION_OUTBOUND) == 0 ) {
        NlPrintDom((NL_MISC, DomainInfo,
                "NlUpdateTrustList: %wZ: trust is not outbound (ignored)\n",
                DomainName ));
        DeleteTrust = TRUE;
    }

    //
    // Ensure we have a domain SID for directly trusted domains
    //

    if ( (Flags & CS_DIRECT_TRUST) != 0 &&
         DomainId == NULL ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NlUpdateTrustList: %wZ: trust has no SID (ignored)\n",
                DomainName ));
        DeleteTrust = TRUE;
    }

    if ( CurrentTrust->TrustType == TRUST_TYPE_DOWNLEVEL ) {
        SecureChannelType = TrustedDomainSecureChannel;
    } else if ( CurrentTrust->TrustType == TRUST_TYPE_UPLEVEL ) {
        SecureChannelType = TrustedDnsDomainSecureChannel;
    } else {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NlUpdateTrustList: %wZ: trust type is neither NT4 nor NT 5 (%ld) (ignored)\n",
                DomainName,
                CurrentTrust->TrustType ));
        DeleteTrust = TRUE;
    }

    if ( CurrentTrust->TrustAttributes & TRUST_ATTRIBUTE_UPLEVEL_ONLY ) {
        NlPrintDom((NL_MISC, DomainInfo,
                "NlUpdateTrustList: %wZ: trust is KERB only (ignored)\n",
                DomainName ));
        DeleteTrust = TRUE;
    }



    //
    // Ensure all of the lengths are within spec. Do this after checking
    // the type so we don't validate trusts we don't use.
    //

    if (!DeleteTrust) {

        BOOLEAN NameBad = FALSE;
        UNICODE_STRING BadName;

        if ( DomainName != NULL &&
             DomainName->Length > DNLEN * sizeof(WCHAR) ) {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlUpdateTrustList: %wZ: Netbios domain name is too long.\n",
                    DomainName ));

            BadName = *DomainName;
            NameBad = TRUE;
        }

        if ( DnsDomainName != NULL &&
             DnsDomainName->Length > NL_MAX_DNS_LENGTH * sizeof(WCHAR) ) {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlUpdateTrustList: %wZ: DNS domain name is too long (ignored)\n",
                    DnsDomainName ));

            BadName = *DnsDomainName;
            NameBad = TRUE;
        }

        if ( NameBad ) {
            LPWSTR AlertStrings[3];

            //
            // alert admin.
            //

            AlertStrings[0] = DomainInfo->DomUnicodeDomainName;
            AlertStrings[1] = LocalAlloc( 0, BadName.Length + sizeof(WCHAR) );
            if ( AlertStrings[1] != NULL ) {
                RtlCopyMemory( AlertStrings[1],
                               BadName.Buffer,
                               BadName.Length );
                AlertStrings[1][BadName.Length/sizeof(WCHAR)] = L'\0';
            }
            AlertStrings[2] = NULL; // Needed for RAISE_ALERT_TOO

            //
            // Save the info in the eventlog
            //

            NlpWriteEventlog(
                        ALERT_NetLogonTrustNameBad,
                        EVENTLOG_ERROR_TYPE,
                        DomainId,
                        DomainId != NULL ? RtlLengthSid( DomainId ) : 0,
                        AlertStrings,
                        2 | NETP_RAISE_ALERT_TOO );

            //
            // For consistency, ensure this trust is deleted.
            //
            DeleteTrust = TRUE;
        }
    }


    //
    // Ensure the SID of the trusted domain isn't the domain sid of this
    //  machine.
    //

    if ( DomainId != NULL &&
         RtlEqualSid( DomainId, DomainInfo->DomAccountDomainId )) {

        LPWSTR AlertStrings[3];
        WCHAR AlertDomainName[DNLEN+1];

        //
        // alert admin.
        //


        if ( DomainName == NULL ||
             DomainName->Length > sizeof(AlertDomainName) ) {
            AlertDomainName[0] = L'\0';
        } else {
            RtlCopyMemory( AlertDomainName, DomainName->Buffer, DomainName->Length );
            AlertDomainName[ DomainName->Length / sizeof(WCHAR) ] = L'\0';
        }

        AlertStrings[0] = DomainInfo->DomUnicodeDomainName;
        AlertStrings[1] = AlertDomainName;
        AlertStrings[2] = NULL; // Needed for RAISE_ALERT_TOO

        //
        // Save the info in the eventlog
        //

        NlpWriteEventlog(
                    ALERT_NetLogonSidConflict,
                    EVENTLOG_ERROR_TYPE,
                    DomainId,
                    RtlLengthSid( DomainId ),
                    AlertStrings,
                    2 | NETP_RAISE_ALERT_TOO );

    }

    //
    // Ensure we have at least some search parameters.
    //

    if ( DomainId == NULL &&
         DomainName == NULL &&
         DnsDomainName == NULL ) {

        //
        // This isn't a fatal error.
        //
        // If DeleteTrust was set above, we have no interest in this TDO.
        // Otherwise, we'll get notified when the TDO gets named.
        //
        // In either case, press on.
        //

        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlUpdateTrustList: All parameters are NULL (ignored)\n" ));
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }


    //
    // Loop through the trust list finding the right entry.
    //

    // LOCK_TRUST_LIST( DomainInfo );
    for ( ListEntry = DomainInfo->DomTrustList.Flink ;
          ListEntry != &DomainInfo->DomTrustList ;
          ListEntry = ListEntry->Flink) {

        ULONG ThisIsIt;

        ClientSession = CONTAINING_RECORD( ListEntry, CLIENT_SESSION, CsNext );

        //
        // Compare against each of the specified parameters.
        //  This avoids cases where two domains have similar names.  That
        //  will most likely happen if two netbios names collide after netbios
        //  is turned off.
        //
        ThisIsIt = FALSE;
        if ( DomainId != NULL &&
             ClientSession->CsDomainId != NULL ) {

            if ( RtlEqualSid( ClientSession->CsDomainId, DomainId ) ) {
                ThisIsIt = TRUE;
            }
        }

        if ( DomainName != NULL &&
             ClientSession->CsNetbiosDomainName.Length != 0 ) {

            if ( RtlEqualDomainName( DomainName,
                                     &ClientSession->CsNetbiosDomainName )) {
                ThisIsIt = TRUE;
            } else {
                if ( ThisIsIt ) {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                                "NlUpdateTrustList: Similar trusts have different netbios names: %wZ %wZ\n",
                                DomainName,
                                &ClientSession->CsNetbiosDomainName ));
                    ClientSession = NULL;
                    continue;
                }
            }
        }

        if ( DnsDomainName != NULL &&
             ClientSession->CsDnsDomainName.Length != 0 ) {

            if ( NlEqualDnsNameU( DnsDomainName,
                                  &ClientSession->CsDnsDomainName ) ) {
                ThisIsIt = TRUE;
            } else {
                if ( ThisIsIt ) {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                                "NlUpdateTrustList: Similar trusts have different DNS names: %wZ %wZ\n",
                                DnsDomainName,
                                &ClientSession->CsDnsDomainName ));
                    ClientSession = NULL;
                    continue;
                }
            }
        }

        //
        // If we found a match,
        //  we're done.
        //
        if ( ThisIsIt ) {
            break;
        }

        ClientSession = NULL;

    }



    //
    // At this point,
    //  DeleteTrust is TRUE if the trust relationship doesn't exist in LSA
    //  ClientSession is NULL if the trust relationship doesn't exist in memory
    //

    //
    // If the Trust exists in neither place,
    //  ignore this request.
    //

    if ( DeleteTrust && ClientSession == NULL ) {
        // UNLOCK_TRUST_LIST( DomainInfo );
        Status = STATUS_SUCCESS;
        goto Cleanup;



    //
    // If the trust exists in the LSA but not in memory,
    //  add the trust entry.
    //

    } else if ( !DeleteTrust && ClientSession == NULL ) {


        ClientSession = NlAllocateClientSession(
                                DomainInfo,
                                DomainName,
                                DnsDomainName,
                                DomainId,
                                NULL,   // No domain GUID
                                Flags | CS_NEW_TRUST,
                                SecureChannelType,
                                CurrentTrust->TrustAttributes );

        if (ClientSession == NULL) {
            // UNLOCK_TRUST_LIST( DomainInfo );
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Link this entry onto the tail of the TrustList.
        //  Add reference for us being on the list.
        //

        InsertTailList( &DomainInfo->DomTrustList, &ClientSession->CsNext );
        DomainInfo->DomTrustListLength ++;
        NlRefClientSession( ClientSession );

        NlPrintCs((NL_SESSION_SETUP, ClientSession,
                    "NlUpdateTrustList: Added to local trust list\n" ));



    //
    // If the trust exists in memory but not in the LSA,
    //  delete the entry.
    //

    } else if ( DeleteTrust && ClientSession != NULL ) {

        NlPrintCs((NL_SESSION_SETUP, ClientSession,
                    "NlUpdateTrustList: Deleted from local trust list\n" ));
        NlFreeClientSession( ClientSession );
        ClientSession = NULL;


    //
    // If the trust exists in both places,
    //   Mark that the account really is in the LSA.
    //

    } else if ( !DeleteTrust && ClientSession != NULL ) {

        //
        // Update any names that are on the ClientSession structure.
        //

        if ( !NlSetNamesClientSession( ClientSession,
                                       DomainName,
                                       DnsDomainName,
                                       DomainId,
                                       NULL )) {   // No domain GUID
            // UNLOCK_TRUST_LIST( DomainInfo );
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        ClientSession->CsFlags &= ~CS_NOT_IN_LSA;
        ClientSession->CsFlags |= Flags;
        if ( IsTdo ) {
            ClientSession->CsTrustAttributes = CurrentTrust->TrustAttributes;
        }
        NlRefClientSession( ClientSession );

        NlPrintCs((NL_SESSION_SETUP, ClientSession,
                    "NlUpdateTrustList: Already in trust list\n" ));

    }


    //
    // If there is a client session,
    //  update it.
    //
    if ( ClientSession != NULL ) {
        //
        // If this is a direct trust,
        //  and the directly trusted domain hasn't yet been saved.
        //  Save it now.
        //

        if ( (ClientSession->CsFlags & CS_DIRECT_TRUST) != 0 &&
             ClientSession->CsDirectClientSession == NULL ) {

            ClientSession->CsDirectClientSession = ClientSession;
            NlRefClientSession( ClientSession );
        }

        //
        // Save the name of the trusted domain object.
        //

        if ( CurrentTrust->TrustType == TRUST_TYPE_UPLEVEL ) {
            ClientSession->CsTrustName = &ClientSession->CsDnsDomainName;
        } else {
            ClientSession->CsTrustName = &ClientSession->CsNetbiosDomainName;
        }
    }

    // UNLOCK_TRUST_LIST( DomainInfo );

    Status = STATUS_SUCCESS;

    //
    // Cleanup locally used resources.
    //
Cleanup:

    //
    // Update the ForestTrustList
    //

    Status = NlUpdateForestTrustList(
                    InitTrustListContext,
                    ClientSession,
                    CurrentTrust,
                    Flags,      // CsFlags
                    TdFlags,    // TdFlags
                    ParentIndex,
                    DomGuid,
                    MyIndex );


    //
    // Return the client session to the caller (if he wants it)
    //
    if ( ClientSession != NULL ) {

        if ( ARGUMENT_PRESENT( RetClientSession )) {
            *RetClientSession = ClientSession;
        } else {
            NlUnrefClientSession( ClientSession );
        }
    }

    return Status;
}
#endif //_DC_NETLOGON


NTSTATUS
NlAddDomainTreeToTrustList(
    IN PNL_INIT_TRUSTLIST_CONTEXT InitTrustListContext,
    IN PDOMAIN_INFO DomainInfo,
    IN PLSAPR_TREE_TRUST_INFO TreeTrustInfo,
    IN PCLIENT_SESSION ClientSession OPTIONAL,
    IN ULONG ParentIndex
    )
/*++

Routine Description:

    Adds each domain in a tree of domains to the in-memory trust list.

    This routine is implemented recursively.  It adds the domain at the
    root of the tree then calls itself to each child domain.

        Enter with the domain trust list locked.

Arguments:

    InitTrustListContext - Context describing the current trust list enumeration

    DomainInfo - Hosted domain to initialize

    TreeTrustInfo - Structure describing the tree of domains to add

    ClientSession - Pointer an existing session.  Attempts to pass through
        to domain at the root of TreeTrustInfo should be routed to the
        ClientSession domain (unless we later find that the domain itself has
        a direct trust).

        This parameter may be NULL if the information isn't yet known.

    ParentIndex - Passes in the Index of the domain that is the parent of this domain

Return Value:

    Status of the operation.

    This routine will add as much of the tree as possible regardless of the
    returned status.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInformation;
    UNICODE_STRING PrintableName;
    PCLIENT_SESSION ThisDomainClientSession = NULL;
    ULONG Index;
    ULONG MyIndex;

    //
    // Initialization
    //

    if ( TreeTrustInfo->DnsDomainName.Length != 0 ) {
        PrintableName = *((PUNICODE_STRING)&TreeTrustInfo->DnsDomainName);
    } else {
        PrintableName = *((PUNICODE_STRING)&TreeTrustInfo->FlatName);
    }

    RtlZeroMemory( &TrustInformation, sizeof(TrustInformation) );
    TrustInformation.Name = *((PLSAPR_UNICODE_STRING)&TreeTrustInfo->DnsDomainName);
    TrustInformation.FlatName = *((PLSAPR_UNICODE_STRING)&TreeTrustInfo->FlatName);

    // ?? Big assumption here that bidirectional trust really exists
    // TrustInformation.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
    TrustInformation.TrustType = TRUST_TYPE_UPLEVEL;
    TrustInformation.TrustAttributes = 0;
    TrustInformation.Sid = TreeTrustInfo->DomainSid;

    //
    // Avoid adding a name for ourself
    //

    if ( (TreeTrustInfo->DnsDomainName.Length != 0 &&
          NlEqualDnsNameU( (PUNICODE_STRING)&TreeTrustInfo->DnsDomainName,
                          &DomainInfo->DomUnicodeDnsDomainNameString ) ) ||
          RtlEqualDomainName( &DomainInfo->DomUnicodeDomainNameString,
                             (PUNICODE_STRING)&TreeTrustInfo->FlatName ) ) {

        NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                 "NlAddDomainTreeToTrustList: %wZ ignoring enterprise tree entry for ourself\n",
                 &PrintableName ));

        TrustInformation.Sid = DomainInfo->DomAccountDomainId;


        //
        // At least add this domain to the forest trust list
        //

        Status = NlUpdateForestTrustList (
                    InitTrustListContext,
                    NULL,   // There is no client session for ourself.
                    &TrustInformation,
                    CS_DOMAIN_IN_FOREST,    // Indicate this domain is in the forest
                    DS_DOMAIN_PRIMARY |
                        ( (TreeTrustInfo->Flags & LSAI_FOREST_ROOT_TRUST) ?
                            DS_DOMAIN_TREE_ROOT :
                            0),
                    ParentIndex,
                    ( (TreeTrustInfo->Flags & LSAI_FOREST_DOMAIN_GUID_PRESENT) ?
                            &TreeTrustInfo->DomainGuid :
                            NULL),
                    &MyIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

    //
    // Build a trust entry describing the domain at the root of the tree.
    //

    } else {

        NlPrintDom((NL_SESSION_SETUP,  DomainInfo,
                 "%wZ: Added from enterprise tree in LSA\n",
                 &PrintableName ));

        //
        // Ensure there is a ClientSession for this domain.
        //

        Status =  NlUpdateTrustList(
                    InitTrustListContext,
                    DomainInfo,
                    &TrustInformation,
                    FALSE,                  // TrustInformation built from XREF object
                    CS_DOMAIN_IN_FOREST,    // Indicate this domain is in the forest
                    ParentIndex,
                    ( (TreeTrustInfo->Flags & LSAI_FOREST_ROOT_TRUST) ?
                            DS_DOMAIN_TREE_ROOT :
                            0),
                    ( (TreeTrustInfo->Flags & LSAI_FOREST_DOMAIN_GUID_PRESENT) ?
                            &TreeTrustInfo->DomainGuid :
                            NULL),
                    &MyIndex,
                    &ThisDomainClientSession );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;

        //
        // Handle sucessfully creating the ClientSession.
        //
        } else if ( ThisDomainClientSession != NULL ) {

            //
            // If we've been told a direct route to this domain,
            //  and a more direct route hasn't yet been determined,
            //  save the direct route.
            //

            if ( ClientSession != NULL &&
                 ThisDomainClientSession->CsDirectClientSession == NULL ) {

                ThisDomainClientSession->CsDirectClientSession = ClientSession;
                NlRefClientSession( ClientSession );

                NlPrintDom((NL_SESSION_SETUP,  DomainInfo,
                         "NlAddDomainTreeToTrustList: Closest path to %wZ is via %ws.\n",
                         &PrintableName,
                         ClientSession->CsDebugDomainName ));
            }

            //
            // If we have a direct trust to this domain,
            //  all children of this domain can be reached through this domain.
            //

            if ( ThisDomainClientSession->CsFlags & CS_DIRECT_TRUST ) {
                ClientSession = ThisDomainClientSession;
            }
        }
    }


    //
    // Loop handling each of the children domains.
    //

    for ( Index=0; Index<TreeTrustInfo->Children; Index++ ) {
        //
        // Add a trust entry for each domain in the tree.
        //

        Status = NlAddDomainTreeToTrustList(
                    InitTrustListContext,
                    DomainInfo,
                    &TreeTrustInfo->ChildDomains[Index],
                    ClientSession,
                    MyIndex );    // This domain is the parent of its children

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    }

Cleanup:

    if ( ThisDomainClientSession != NULL ) {
        NlUnrefClientSession( ThisDomainClientSession );
    }

    return Status;
}

// #define DBG_BUILD_FOREST 1
#ifdef DBG_BUILD_FOREST
NTSTATUS
KerbDuplicateString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{


    if ((SourceString == NULL) || (SourceString->Buffer == NULL))
    {
        DestinationString->Buffer = NULL;
        DestinationString->Length = DestinationString->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }

    DestinationString->Buffer = (LPWSTR) MIDL_user_allocate(SourceString->Length + sizeof(WCHAR));
    if (DestinationString->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    DestinationString->Length = SourceString->Length;
    DestinationString->MaximumLength = SourceString->Length + sizeof(WCHAR);
    RtlCopyMemory(
        DestinationString->Buffer,
        SourceString->Buffer,
        SourceString->Length
        );

    DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';

    return(STATUS_SUCCESS);

}


PLSAPR_TREE_TRUST_INFO
DebugBuildNode(
    IN LPWSTR DnsName
    )
{
    PLSAPR_TREE_TRUST_INFO TreeTrust;
    UNICODE_STRING TempString;

    //
    // Allocate this node and enough space for several children
    //

    TreeTrust = (PLSAPR_TREE_TRUST_INFO) LocalAlloc( LMEM_ZEROINIT, 10 * sizeof(LSAPR_TREE_TRUST_INFO));

    TreeTrust->ChildDomains = (TreeTrust + 1 );

    RtlInitUnicodeString( &TempString, DnsName );
    KerbDuplicateString( (PUNICODE_STRING)
        &TreeTrust->DnsDomainName,
        &TempString );

    //  if ( TempString.Length > DNLEN*sizeof(WCHAR)) {
        TempString.Length = (wcschr( TempString.Buffer, L'.' ) - TempString.Buffer) * sizeof(WCHAR);
    // }

    KerbDuplicateString( (PUNICODE_STRING)
        &TreeTrust->FlatName,
        &TempString );

    return TreeTrust;

}

PLSAPR_TREE_TRUST_INFO
DebugAddChild(
    IN PLSAPR_TREE_TRUST_INFO ParentNode,
    IN LPWSTR DnsName
    )
{
    PLSAPR_TREE_TRUST_INFO TreeTrust;

    TreeTrust = DebugBuildNode( DnsName );

    ParentNode->ChildDomains[ParentNode->Children] = *TreeTrust;
    ParentNode->Children ++;

    return &ParentNode->ChildDomains[ParentNode->Children-1];

}

VOID
DebugBuildDomainForest(
    OUT PLSAPR_FOREST_TRUST_INFO * ForestInfo
    )
{
    PLSAPR_TREE_TRUST_INFO RootTrust;
    PLSAPR_TREE_TRUST_INFO NovTrust;
    PLSAPR_TREE_TRUST_INFO IbmTrust;
    PLSAPR_TREE_TRUST_INFO Trust1;
    PLSAPR_TREE_TRUST_INFO Trust2;
    PLSAPR_TREE_TRUST_INFO Trust3;
    PLSAPR_TREE_TRUST_INFO Trust4;
    PLSAPR_TREE_TRUST_INFO Trust5;
    PLSAPR_FOREST_TRUST_INFO ForestTrustInfo = NULL;
    PLSAPR_TREE_TRUST_INFO ChildDomains = NULL;
    PLSAPR_TREE_TRUST_INFO ChildRoot = NULL;
        UNICODE_STRING TempString;
    ULONG Index;

    ForestTrustInfo = (PLSAPR_FOREST_TRUST_INFO) MIDL_user_allocate(sizeof(LSAPR_FOREST_TRUST_INFO));


    //
    // Node at root of tree
    //
    RootTrust = DebugBuildNode( L"microsoft.com" );

    ForestTrustInfo->RootTrust = *RootTrust;
    RootTrust = &ForestTrustInfo->RootTrust;

    //
    // Build Novell
    //

    NovTrust = DebugAddChild( RootTrust, L"novell.com" );
    Trust1 = DebugAddChild( NovTrust, L"a.novell.com" );
    DebugAddChild( Trust1, L"c.a.novell.com" );
    Trust2 = DebugAddChild( NovTrust, L"b.novell.com" );
    DebugAddChild( Trust2, L"d.b.novell.com" );

    //
    // Build IBM
    //

    IbmTrust = DebugAddChild( RootTrust, L"ibm.com" );
    DebugAddChild( IbmTrust, L"sub.ibm.com" );

    //
    // Build Microsoft
    //
    Trust1 = DebugAddChild( RootTrust, L"ntdev.microsoft.com" );
    ForestTrustInfo->ParentDomainReference = Trust1;
    Trust2 = DebugAddChild( Trust1, L"cliffvdom.ntdev.microsoft.com" );
    Trust3 = DebugAddChild( Trust2, L"cliffvchild.cliffvdom.ntdev.microsoft.com" );
    Trust4 = DebugAddChild( Trust3, L"cliffvgrand.cliffvchild.cliffvdom.ntdev.microsoft.com" );
    Trust2 = DebugAddChild( Trust1, L"cliffvsib.ntdev.microsoft.com" );
    Trust3 = DebugAddChild( Trust2, L"cliffvsibchild.cliffvsib.ntdev.microsoft.com" );

    //
    // Build Compaq

    Trust1 = DebugAddChild( RootTrust, L"compaq.com" );

    *ForestInfo = ForestTrustInfo;
}

VOID
DebugFillInTrust(
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustEntry,
    LPWSTR DnsName
    )
{
    UNICODE_STRING TempString;

    RtlInitUnicodeString( &TempString, DnsName );
    KerbDuplicateString( (PUNICODE_STRING)
        &TrustEntry->Name,
        &TempString );

    if ( TempString.Length > DNLEN*sizeof(WCHAR)) {
        TempString.Length = (wcschr( TempString.Buffer, L'.' ) - TempString.Buffer) * sizeof(WCHAR);
    }

    KerbDuplicateString( (PUNICODE_STRING)
        &TrustEntry->FlatName,
        &TempString );

    // ?? Big assumption here that bidirectional trust really exists
    TrustEntry->TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
    TrustEntry->TrustType = TRUST_TYPE_UPLEVEL;
    TrustEntry->TrustAttributes = 0;

}


VOID
DebugBuildDomainTrust(
    PLSAPR_TRUSTED_ENUM_BUFFER_EX TrustInfo
    )
{
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustEntry;

    TrustInfo->EntriesRead = 0;
    TrustEntry = TrustInfo->EnumerationBuffer =
        LocalAlloc( LMEM_ZEROINIT, 10*sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX));


    DebugFillInTrust( TrustEntry, L"ntdev.microsoft.com" );
    TrustInfo->EntriesRead++;
    TrustEntry++;

    DebugFillInTrust( TrustEntry, L"cliffvchild.cliffvdom.ntdev.microsoft.com" );
    TrustInfo->EntriesRead++;
    TrustEntry++;

    // Build a downlevel trust
    DebugFillInTrust( TrustEntry, L"redmond.cliffvdom.ntdev.microsoft.com" );
    TrustInfo->EntriesRead++;
    TrustEntry->TrustType = TRUST_TYPE_DOWNLEVEL;
    TrustEntry++;


    return;
}

#endif // DBG_BUILD_FOREST


NTSTATUS
NlInitTrustList(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Initialize the in-memory trust list to match LSA's version.

Arguments:

    DomainInfo - Hosted domain to initialize

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    LSA_ENUMERATION_HANDLE EnumerationContext = 0;
    LSAPR_TRUSTED_ENUM_BUFFER_EX LsaTrustList;
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX CurrentTrust;

    PLSAPR_FOREST_TRUST_INFO ForestInfo = NULL;
    ULONG Index;
    PCLIENT_SESSION ClientSession;
    PCLIENT_SESSION ParentClientSession = NULL;
    NL_INIT_TRUSTLIST_CONTEXT InitTrustListContext;

    PLIST_ENTRY ListEntry;

    //
    // Avoid initializing the trust list in the setup mode.
    // We may not fully function as a DC as in the case of
    // a NT4 to NT5 DC upgrade.
    //

    if ( NlDoingSetup() ) {
        NlPrint(( NL_MISC, "NlInitTrustList: avoid trust init in setup mode\n" ));
        return STATUS_SUCCESS;
    }

    //
    // Initialization
    //

    RtlZeroMemory( &LsaTrustList, sizeof(LsaTrustList) );
    InitTrustListContext.BufferDescriptor.Buffer = NULL;
    InitTrustListContext.DomForestTrustListSize = 0;
    InitTrustListContext.DomForestTrustListCount = 0;


    //
    // Mark each entry in the trust list for deletion
    //  Keep the trust list locked for the duration since I temporarily
    //  clear several fields.
    //

    LOCK_TRUST_LIST( DomainInfo );

    //
    // Set the NlGlobalTrustInfoUpToDateEvent event so that any waiting
    // thread that was waiting to access the trust info will be waked up.
    //

    if ( !SetEvent( NlGlobalTrustInfoUpToDateEvent ) ) {
        NlPrint((NL_CRITICAL,
                "Cannot set NlGlobalTrustInfoUpToDateEvent event: %lu\n",
                GetLastError() ));
    }

    //
    // In the following loop we are clearing the fields in all client sessions
    //  which (fields) pertain to the structure of the forest:
    //
    //  * The CS_DIRECT_TRUST and CS_DOMAIN_IN_FOREST bits which specify
    //    the relation of the trust (represented by the client session
    //    in question) to the forest we are in.
    //  * The CsDirectClientSession field that specifies the client session
    //    to use to pass a logon destined to the domain represented by the
    //    client session in question.
    //
    //  We will reset these fields as we rebuild the trust info below. However,
    //  it's possible that we may fail to reset the fields for some of the client
    //  sessions due a critical error (no memory) encountered in the process of
    //  rebuilding. In such case we will end up with some client session without
    //  these fields set. While this may result in failures to pass logons to
    //  the affected domains, it will not result in inconsistent forest structure
    //  (that could be quite harmful in case pass-through loops are created (due
    //  to wrong values for CsDirectClientSession links) leading to potentially
    //  infinite looping of logons within the loops). The CsDirectClientSession
    //  link will either represent the right pass-through direction or no direction
    //  at all. In case of critical error we will reset the event to rebuild the
    //  trust info later so that we hopefully completely recover at that time.
    //

    for ( ListEntry = DomainInfo->DomTrustList.Flink ;
          ListEntry != &DomainInfo->DomTrustList ;
          ListEntry = ListEntry->Flink) {

        ClientSession = CONTAINING_RECORD( ListEntry, CLIENT_SESSION, CsNext );

        ClientSession->CsFlags |= CS_NOT_IN_LSA;

        //
        // Remove the direct trust bit.
        //  We'll or it back in below as we enumerate trusts.
        ClientSession->CsFlags &= ~CS_DIRECT_TRUST|CS_DOMAIN_IN_FOREST;

        //
        // Forget all of the directly trusted domains.
        //  We'll fill it in again later.
        //
        if ( ClientSession->CsDirectClientSession != NULL ) {
            NlUnrefClientSession( ClientSession->CsDirectClientSession );
            ClientSession->CsDirectClientSession = NULL;
        }

    }



    //
    // Loop through the LSA's list of trusted domains
    //
    // For each entry found,
    //  If the entry already exits in the trust list,
    //      remove the mark for deletion.
    //  else
    //      allocate a new entry.
    //

    for (;;) {


        //
        // Free any previous buffer returned from LSA.
        //

#ifndef DBG_BUILD_FOREST
        if ( LsaTrustList.EnumerationBuffer != NULL ) {

            LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX( &LsaTrustList );
            LsaTrustList.EnumerationBuffer = NULL;
        }
#endif

        //
        // Do the actual enumeration
        //

        GiveInstallHints( FALSE );

        NlPrintDom((NL_SESSION_MORE,  DomainInfo,
                 "NlInitTrustList: Calling LsarEnumerateTrustedDomainsEx Context=%ld\n",
                 EnumerationContext ));

#ifndef DBG_BUILD_FOREST
        Status = LsarEnumerateTrustedDomainsEx(
                    DomainInfo->DomLsaPolicyHandle,
                    &EnumerationContext,
                    &LsaTrustList,
                    4096);
#else
        if ( EnumerationContext == 0 ) {
            DebugBuildDomainTrust( &LsaTrustList);
            Status = STATUS_SUCCESS;
            EnumerationContext = 1;
        } else {
            Status = STATUS_NO_MORE_ENTRIES;
        }
#endif

        NlPrintDom((NL_SESSION_MORE,  DomainInfo,
                 "NlInitTrustList: returning from LsarEnumerateTrustedDomainsEx Context=%ld %lX\n",
                 EnumerationContext,
                 Status ));

        //
        // If Lsa says he's returned all of the information,
        //  we're done.
        //

        if ( Status == STATUS_NO_MORE_ENTRIES ) {
            break;

        } else if ( !NT_SUCCESS(Status) ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                         "NlInitTrustList: Cannot LsarEnumerateTrustedDomainsEx 0x%lX\n",
                         Status ));
            goto Cleanup;
        }

        //
        // Ensure the LSA made some progress.
        //

        if ( LsaTrustList.EntriesRead == 0 ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                         "NlInitTrustList: LsarEnumerateTrustedDomainsEx returned zero entries\n" ));
            break;  // proceed with X-ref enumeration
        }

        //
        // Handle each of the returned trusted domains.
        //

        for ( Index=0; Index< LsaTrustList.EntriesRead; Index++ ) {
            PUNICODE_STRING DnsDomainName;
            PUNICODE_STRING DomainName;

            //
            // Validate the current entry.
            //

            CurrentTrust = &LsaTrustList.EnumerationBuffer[Index];

            DnsDomainName = (PUNICODE_STRING) &(CurrentTrust->Name);
            DomainName = (PUNICODE_STRING) &(CurrentTrust->FlatName);


            NlPrintDom((NL_SESSION_SETUP,  DomainInfo,
                     "%wZ is directly trusted according to LSA.\n",
                     DnsDomainName->Length != 0 ? DnsDomainName : DomainName ));

            if ( RtlEqualDomainName( &DomainInfo->DomUnicodeDomainNameString,
                                     DomainName ) ) {
                NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                         "NlInitTrustList: %wZ ignoring trust relationship to our own domain\n",
                         DomainName ));
                continue;
            }

            //
            // Update the in-memory trust list to match the LSA.
            //

            Status =  NlUpdateTrustList(
                        &InitTrustListContext,
                        DomainInfo,
                        CurrentTrust,
                        TRUE,               // TrustInformation built from TDO object
                        CS_DIRECT_TRUST,    // We directly trust this domain
                        0,                  // Don't know the index of my parent
                        0,                  // No TdFlags
                        NULL,               // No DomainGuid
                        NULL,               // Don't care what my index is
                        NULL );             // No need to return client session pointer

            if ( !NT_SUCCESS(Status) ) {
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                             "NlInitTrustList: %wZ NlUpdateTrustList failed 0x%lx\n",
                             DomainName,
                             Status ));
                goto Cleanup;
            }

            //
            // If this is an uplevel inbound trust,
            //  update the attributes on any existing inbound server session.
            //

            if ( CurrentTrust->TrustType == TRUST_TYPE_UPLEVEL &&
                 (CurrentTrust->TrustDirection & TRUST_DIRECTION_INBOUND) != 0 ) {

                //
                // Set the trust attributes on all of the inbound server sessions
                //  from this domain.
                //

                NlSetServerSessionAttributesByTdoName( DomainInfo,
                                                       DnsDomainName,
                                                       CurrentTrust->TrustAttributes );

            }
        }


    }

    //
    // Enumerate all the domains in the enterprise.
    //  We indirectly trust all of these domains.
    //


#ifndef DBG_BUILD_FOREST
    Status = LsaIQueryForestTrustInfo(
                DomainInfo->DomLsaPolicyHandle,
                &ForestInfo );
#else
    DebugBuildDomainForest(&ForestInfo);
    Status = STATUS_SUCCESS;
#endif

    if (!NT_SUCCESS(Status)) {
        ForestInfo = NULL;
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "NlInitTrustList: Cannot LsaIQueryForestTrustInfo 0x%lX\n",
                     Status ));

        // We aren't part of a tree, all ok
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            NlPrint(( NL_INIT,
                      "This domain is not part of a tree so domain tree ignored\n" ));
            Status = STATUS_SUCCESS;

        // We're running the non-DS version of LSA
        } else if (Status == STATUS_INVALID_DOMAIN_STATE) {
            NlPrint(( NL_INIT,
                      "DS isn't running so domain tree ignored\n" ));
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // Process the tree of trusts that makes up the forest.
    //
    // The LSA identifies the domain that is the parent of this domain.
    //
    // All domains starting at all roots can be reached via our parent domain.
    //

    if ( ForestInfo->ParentDomainReference == NULL ) {
        NlPrintDom((NL_SESSION_SETUP,  DomainInfo,
                     "NlInitTrustList: This domain has no parent in forest.\n" ));
        ParentClientSession = NULL;

    } else {
        PUNICODE_STRING ParentName;

        if ( ForestInfo->ParentDomainReference->DnsDomainName.Length != 0 ) {
            ParentName = ((PUNICODE_STRING)&ForestInfo->ParentDomainReference->DnsDomainName);
        } else {
            ParentName = ((PUNICODE_STRING)&ForestInfo->ParentDomainReference->FlatName);
        }

        //
        // Find the directly trusted session for the parent.
        //

        ParentClientSession = NlFindNamedClientSession(
                                    DomainInfo,
                                    ParentName,
                                    NL_DIRECT_TRUST_REQUIRED,
                                    NULL );

        if ( ParentClientSession == NULL ) {
            NlPrintDom(( NL_CRITICAL,  DomainInfo,
                         "NlInitTrustList: Cannot find trust to my parent domain %wZ.\n",
                         ParentName ));
        }

    }

    //
    // Remember the parent client session.
    //

    if ( DomainInfo->DomParentClientSession != NULL ) {
        NlUnrefClientSession( DomainInfo->DomParentClientSession );
        DomainInfo->DomParentClientSession = NULL;
    }

    if ( ParentClientSession != NULL ) {
        NlRefClientSession( ParentClientSession );
        DomainInfo->DomParentClientSession = ParentClientSession;
    }

    //
    // Add the domain tree to the trust list.
    //

    Status = NlAddDomainTreeToTrustList(
                &InitTrustListContext,
                DomainInfo,
                &ForestInfo->RootTrust,
                ParentClientSession,
                0 );    // The Forest root has no parent

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL,  DomainInfo,
                     "NlInitTrustList: NlAddDomainTreeToTrustList failed 0x%lx\n",
                     Status ));
        goto Cleanup;
    }

    //
    // Delete any trust list entry that no longer exists in LSA.
    //

    for ( ListEntry = DomainInfo->DomTrustList.Flink ;
          ListEntry != &DomainInfo->DomTrustList ;
          ) {
        PCLIENT_SESSION ClientSession;

        ClientSession = CONTAINING_RECORD( ListEntry, CLIENT_SESSION, CsNext );
        ListEntry = ListEntry->Flink;

        if ( ClientSession->CsFlags & CS_NOT_IN_LSA ) {

            NlPrintCs((NL_SESSION_SETUP, ClientSession,
                        "NlInitTrustList: Deleted from local trust list\n" ));
            NlFreeClientSession( ClientSession );
        }

    }

    //
    // Swap in the new forest trust list
    //  (May null out ForestTrustList).
    //

    NlSetForestTrustList ( DomainInfo,
                           (PDS_DOMAIN_TRUSTSW *) &InitTrustListContext.BufferDescriptor.Buffer,
                           InitTrustListContext.DomForestTrustListSize,
                           InitTrustListContext.DomForestTrustListCount );

    //
    // We have successfully initilized the trust list
    //

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // If there was an error, reset the TrustInfoUpToDate event so that the
    // scavenger (that checks if the event is set) will call this function
    // again to redo the work.  It is possible that the scavenger can call
    // this function unapproprietly when the event was just set by LSA and
    // we didn't dispatch this work item yet in which case this function
    // will be called twice performing the same task. We'll live with that
    // since chances of this happening are very small and doing the task
    // twice does not cause any real error (just a perfomance hit).
    //

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_MISC,
                "NlInitTrustList: Reseting NlGlobalTrustInfoUpToDateEvent on error.\n"));
        if ( !ResetEvent( NlGlobalTrustInfoUpToDateEvent ) ) {
            NlPrint((NL_CRITICAL,
                    "Cannot reset NlGlobalTrustInfoUpToDateEvent event: %lu\n",
                    GetLastError() ));
        }
    }

    UNLOCK_TRUST_LIST( DomainInfo );

    //
    // Find a DC for all of the newly added trusts.
    //

    NlPickTrustedDcForEntireTrustList( DomainInfo, TRUE );

    //
    // Free locally used resources.
    //
    if ( ParentClientSession != NULL ) {
        NlUnrefClientSession( ParentClientSession );
    }
#ifndef DBG_BUILD_FOREST
    if ( ForestInfo != NULL ) {
        LsaIFreeForestTrustInfo( ForestInfo );
    }
    LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX( &LsaTrustList );
#endif // DBG_BUILD_FOREST
    if ( InitTrustListContext.BufferDescriptor.Buffer != NULL ) {
        NetApiBufferFree( InitTrustListContext.BufferDescriptor.Buffer );
    }

    return Status;
}




NTSTATUS
NlCaptureNetbiosServerClientSession (
    IN PCLIENT_SESSION ClientSession,
    OUT WCHAR NetbiosUncServerName[UNCLEN+1]
    )
/*++

Routine Description:

    Captures a copy of the Netbios UNC server name for the client session.

    NOTE: This routine isn't currently used.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.
        The caller must NOT be a writer of the trust list entry.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry to use.

    UncServerName - Returns the UNC name of the server for this client session.
        If there is none, NULL is returned.
        Returned string should be free using NetApiBufferFree.

Return Value:

    STATUS_SUCCESS - Server name was successfully copied.

    Otherwise - Status of the secure channel
--*/
{
    NTSTATUS Status;
    LPWSTR UncServerName = NULL;
    DWORD NetbiosUncServerNameLength;

    //
    // Grab the DNS or netbios name
    //

    Status = NlCaptureServerClientSession( ClientSession, &UncServerName, NULL );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Convert the DNS hostname to Netbios Computername
    //

    NetbiosUncServerName[0] = '\\';
    NetbiosUncServerName[1] = '\\';
    NetbiosUncServerNameLength = CNLEN+1;
    if ( !DnsHostnameToComputerNameW( UncServerName+2,
                                      NetbiosUncServerName+2,
                                      &NetbiosUncServerNameLength ) ) {
        Status = NetpApiStatusToNtStatus( GetLastError() );
        NlPrintCs(( NL_CRITICAL, ClientSession,
                "Cannot convert DNS to Netbios %ws 0x%lx\n",
                UncServerName+2,
                Status ));
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;
Cleanup:
    if ( UncServerName != NULL ) {
        NetApiBufferFree( UncServerName );
    }

    return Status;
}



NTSTATUS
NlCaptureServerClientSession (
    IN PCLIENT_SESSION ClientSession,
    OUT LPWSTR *UncServerName,
    OUT DWORD *DiscoveryFlags OPTIONAL
    )
/*++

Routine Description:

    Captures a copy of the UNC server name for the client session.

    On Entry,
        The trust list must NOT be locked.
        The trust list entry must be referenced by the caller.
        The caller must NOT be a writer of the trust list entry.

Arguments:

    ClientSession - Specifies a pointer to the trust list entry to use.

    UncServerName - Returns the UNC name of the server for this client session.
        If there is none, NULL is returned.
        Returned string should be free using NetApiBufferFree.

    DiscoveryFlags - Returns discovery flags

Return Value:

    STATUS_SUCCESS - Server name was successfully copied.

    Otherwise - Status of the secure channel
--*/
{
    NTSTATUS Status;

    NlAssert( ClientSession->CsReferenceCount > 0 );
    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

    if ( ClientSession->CsState == CS_IDLE ) {
        Status = ClientSession->CsConnectionStatus;
        *UncServerName = NULL;
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

    NlAssert( ClientSession->CsUncServerName != NULL );
    *UncServerName = NetpAllocWStrFromWStr( ClientSession->CsUncServerName );

    if ( *UncServerName == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    if ( DiscoveryFlags != NULL ) {
        *DiscoveryFlags = ClientSession->CsDiscoveryFlags;
    }


Cleanup:
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    if ( Status != STATUS_SUCCESS && *UncServerName != NULL ) {
        NetApiBufferFree( *UncServerName );
        *UncServerName = NULL;
    }

    return Status;
}

#ifdef _DC_NETLOGON

NET_API_STATUS
NlPreparePingContext (
    IN PCLIENT_SESSION ClientSession,
    IN LPWSTR AccountName,
    IN ULONG AllowableAccountControlBits,
    OUT LPWSTR *ReturnedQueriedDcName,
    OUT PNL_GETDC_CONTEXT *PingContext
    )

/*++

Routine Description:

    Initialize the ping context structure using client session info

Arguments:

    ClientSession - The client session info.

    AccountName - Name of our user account to find.

    AllowableAccountControlBits - A mask of allowable SAM account types that
        are allowed to satisfy this request.

    ReturnedQueriedDcName - Returns the server name that will be pinged
        using this ping context. Should be deallocated by calling
        NetApiBufferFree.

    PingContext - Returns the Context structure that can be used to perform
        the pings.  The returned structure should be freed by calling
        NlFreePingContext.

Return Value:

    Pointer to referenced ClientSession structure describing the secure channel
    to the domain containing the account.

    The returned ClientSession is referenced and should be unreferenced
    using NlUnrefClientSession.

    NULL - DC was not found.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    ULONG DiscoveryFlags = 0;
    ULONG InternalFlags = 0;
    ULONG Flags = 0;
    PNL_GETDC_CONTEXT Context = NULL;

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

    Status = NlCaptureServerClientSession(
                           ClientSession,
                           ReturnedQueriedDcName,
                           &DiscoveryFlags );

    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Set the ping flags based on the type of the account
    //
    if ( DiscoveryFlags & CS_DISCOVERY_DNS_SERVER ) {
        InternalFlags |= DS_PING_DNS_HOST;
    } else {
        InternalFlags |= DS_PING_NETBIOS_HOST;
    }

    if ( DiscoveryFlags & CS_DISCOVERY_USE_LDAP ) {
        InternalFlags |= DS_PING_USING_LDAP;
    }
    if ( DiscoveryFlags & CS_DISCOVERY_USE_MAILSLOT ) {
        InternalFlags |= DS_PING_USING_MAILSLOT;
    }

    if ( AllowableAccountControlBits == USER_WORKSTATION_TRUST_ACCOUNT ) {
        InternalFlags |= DS_IS_PRIMARY_DOMAIN;
    }
    if ( AllowableAccountControlBits == USER_SERVER_TRUST_ACCOUNT ) {
        Flags |= DS_PDC_REQUIRED;
        InternalFlags |= DS_IS_PRIMARY_DOMAIN;
    }
    InternalFlags |= DS_IS_TRUSTED_DOMAIN;

    //
    // Initialize the ping context.
    //

    NetStatus = NetApiBufferAllocate( sizeof(*Context), &Context );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    NetStatus = NetpDcInitializeContext(
                    ClientSession->CsDomainInfo,    // SendDatagramContext
                    ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
#ifdef DONT_REQUIRE_MACHINE_ACCOUNT // useful for number of trust testing
                    NULL,
#else // DONT_REQUIRE_MACHINE_ACCOUNT
                    AccountName,
#endif // DONT_REQUIRE_MACHINE_ACCOUNT
                    AllowableAccountControlBits,
                    ClientSession->CsNetbiosDomainName.Buffer,
                    ClientSession->CsDnsDomainName.Buffer,
                    NULL,
                    ClientSession->CsDomainId,
                    ClientSession->CsDomainGuid,
                    NULL,
                    (*ReturnedQueriedDcName) + 2,     // Skip '\\' in the DC name
                    (ClientSession->CsServerSockAddr.iSockaddrLength != 0) ? // Socket addresses
                        &ClientSession->CsServerSockAddr :
                        NULL,
                    (ClientSession->CsServerSockAddr.iSockaddrLength != 0) ? // Number of socket addresses
                        1 :
                        0,
                    Flags,
                    InternalFlags,
                    NL_GETDC_CONTEXT_INITIALIZE_FLAGS | NL_GETDC_CONTEXT_INITIALIZE_PING,
                    Context );

    if ( NetStatus != NO_ERROR ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlPickDomainWithAccountViaPing: Cannot NetpDcInitializeContext 0x%lx\n",
                    NetStatus ));
        NlFreePingContext( Context );
        goto Cleanup;
    }

Cleanup:

    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    if ( NetStatus == NO_ERROR ) {
        *PingContext = Context;
    }

    return NetStatus;
}


PCLIENT_SESSION
NlPickDomainWithAccountViaPing (
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR AccountName,
    IN ULONG AllowableAccountControlBits
    )

/*++

Routine Description:

    Get the name of a trusted domain that defines a particular account.

Arguments:

    DomainInfo - Domain account is in

    AccountName - Name of our user account to find.

    AllowableAccountControlBits - A mask of allowable SAM account types that
        are allowed to satisfy this request.

Return Value:

    Pointer to referenced ClientSession structure describing the secure channel
    to the domain containing the account.

    The returned ClientSession is referenced and should be unreferenced
    using NlUnrefClientSession.

    NULL - DC was not found.

--*/
{
    NET_API_STATUS NetStatus;

    PCLIENT_SESSION ClientSession;
    PLIST_ENTRY ListEntry;
    DWORD DomainsPending;
    ULONG WaitStartTime;
    BOOL UsedNetbios;
    ULONG PingContextIndex;
    PNL_DC_CACHE_ENTRY NlDcCacheEntry = NULL;
    PNL_GETDC_CONTEXT TrustEntryPingContext;

    //
    // Define a local list of trusted domains.
    //

    ULONG LocalTrustListLength;
    ULONG Index;
    struct _LOCAL_TRUST_LIST {

        //
        // TRUE if ALL processing is finished on this trusted domain.
        //

        BOOLEAN Done;

        //
        // TRUE if at least one discovery has been done on this trusted domain.
        //

        BOOLEAN DiscoveryDone;

        //
        // TRUE if discovery is in progress on this trusted domain.
        //

        BOOLEAN DoingDiscovery;

        //
        // Number of times we need to repeat the current domain discovery
        //  or finduser datagram for this current domain.
        //

        DWORD RetriesLeft;

        //
        // Pointer to referenced ClientSession structure for the domain.
        //

        PCLIENT_SESSION ClientSession;

        //
        // Server name for the domain.
        //

        LPWSTR UncServerName;

        //
        // Second server name for the domain.
        //

        LPWSTR UncServerName2;

        //
        // Ping Context for the domain.
        //

        PNL_GETDC_CONTEXT PingContext;

        //
        // Second ping Context for the domain.
        //

        PNL_GETDC_CONTEXT PingContext2;

    } *LocalTrustList = NULL;


    //
    // Allocate a local list of trusted domains.
    //

    LOCK_TRUST_LIST( DomainInfo );
    LocalTrustListLength = DomainInfo->DomTrustListLength;

    LocalTrustList = (struct _LOCAL_TRUST_LIST *) NetpMemoryAllocate(
        LocalTrustListLength * sizeof(struct _LOCAL_TRUST_LIST));

    if ( LocalTrustList == NULL ) {
        UNLOCK_TRUST_LIST( DomainInfo );
        ClientSession = NULL;
        NetStatus = NO_ERROR;
        goto Cleanup;
    }


    //
    // Build a local list of trusted domains we know DCs for.
    //


    Index = 0;
    for ( ListEntry = DomainInfo->DomTrustList.Flink ;
          ListEntry != &DomainInfo->DomTrustList ;
          ListEntry = ListEntry->Flink) {

        ClientSession = CONTAINING_RECORD( ListEntry, CLIENT_SESSION, CsNext );

        //
        // Add this Client Session to the list.
        //
        // Don't do domains in the same forest.  We've already handled such
        // domains by going to the GC.
        //

        if ( (ClientSession->CsFlags & (CS_DIRECT_TRUST|CS_DOMAIN_IN_FOREST)) == CS_DIRECT_TRUST ) {
            NlRefClientSession( ClientSession );

            LocalTrustList[Index].ClientSession = ClientSession;
            Index++;
        }
    }

    UNLOCK_TRUST_LIST( DomainInfo );
    LocalTrustListLength = Index;

    //
    // If there are no trusted domains to try,
    //  we're done.

    if ( Index == 0 ) {
        ClientSession = NULL;
        NetStatus = NO_ERROR;
        goto Cleanup;
    }


    //
    // Initialize the local trust list.
    //

    for ( Index = 0; Index < LocalTrustListLength; Index ++ ) {

        LocalTrustList[Index].UncServerName = NULL;
        LocalTrustList[Index].UncServerName2 = NULL;
        LocalTrustList[Index].PingContext = NULL;
        LocalTrustList[Index].PingContext2 = NULL;

        //
        // Prepare the ping context. This will fail if the
        //  client session is idle.
        //

        NetStatus = NlPreparePingContext ( LocalTrustList[Index].ClientSession,
                                           AccountName,
                                           AllowableAccountControlBits,
                                           &LocalTrustList[Index].UncServerName,
                                           &LocalTrustList[Index].PingContext );

        //
        // If the client session isn't idle,
        //  try sending to the current DC before discovering a new one.
        //

        if ( NetStatus == NO_ERROR ) {

            NlPrintCs(( NL_MISC, LocalTrustList[Index].ClientSession,
                "NlPickDomainWithAccountViaPing: Captured DC %ws\n",
                LocalTrustList[Index].UncServerName ));
            LocalTrustList[Index].RetriesLeft = 3;
            LocalTrustList[Index].DoingDiscovery = FALSE;
            LocalTrustList[Index].DiscoveryDone = FALSE;

        //
        // Otherwise don't try very hard to discover one.
        //  (Indeed, just one discovery datagram is all we need.)
        //

        } else {

            //
            // If this is a hard error, error out
            //
            if ( NetStatus == ERROR_NOT_ENOUGH_MEMORY ) {
                ClientSession = NULL;
                goto Cleanup;
            }

            NlPrintCs(( NL_CRITICAL, LocalTrustList[Index].ClientSession,
                "NlPickDomainWithAccountViaPing: Cannot NlPreparePingContext 0x%lx\n",
                NetStatus ));
            LocalTrustList[Index].RetriesLeft = 1;
            LocalTrustList[Index].DoingDiscovery = TRUE;
            LocalTrustList[Index].DiscoveryDone = TRUE;
        }

        //
        // We're not done yet.
        //

        LocalTrustList[Index].Done = FALSE;
    }

    //
    // Try multiple times to get a response from each DC.
    //

    for (;; ) {

        //
        // Send a ping to each domain that has not yet responded.
        //

        DomainsPending = 0;

        for ( Index = 0; Index < LocalTrustListLength; Index ++ ) {

            //
            // If this domain has already responded, ignore it.
            //

            if ( LocalTrustList[Index].Done ) {
                continue;
            }

            //
            // If we don't currently know the DC name for this domain,
            //  check if any has been discovered since we started the algorithm.
            //

            if ( LocalTrustList[Index].PingContext == NULL ) {

                //
                // Prepare the ping context. This will fail if
                //  the client session is idle.
                //

                NetStatus = NlPreparePingContext ( LocalTrustList[Index].ClientSession,
                                                   AccountName,
                                                   AllowableAccountControlBits,
                                                   &LocalTrustList[Index].UncServerName,
                                                   &LocalTrustList[Index].PingContext );

                //
                // If the client session isn't idle,
                //  try sending to the current DC before discovering a new one.
                //

                if ( NetStatus == NO_ERROR ) {

                    NlPrintDom((NL_LOGON, DomainInfo,
                             "NlPickDomainWithAccount: %ws: Noticed domain %ws has discovered a new DC %ws\n",
                             AccountName,
                             LocalTrustList[Index].ClientSession->CsDebugDomainName,
                             LocalTrustList[Index].UncServerName ));

                    //
                    // If we did the discovery,
                    //

                    if ( LocalTrustList[Index].DoingDiscovery ) {
                        LocalTrustList[Index].DoingDiscovery = FALSE;
                        LocalTrustList[Index].RetriesLeft = 3;
                    }

                //
                // Error out on the hard error
                //

                } else if ( NetStatus == ERROR_NOT_ENOUGH_MEMORY ) {
                    ClientSession = NULL;
                    goto Cleanup;
                }

            }

            //
            // If we have a ping context and retries left, ping the DC
            //

            if ( LocalTrustList[Index].PingContext != NULL &&
                 LocalTrustList[Index].RetriesLeft > 0 ) {

                NetStatus = NlPingDcNameWithContext(
                               LocalTrustList[Index].PingContext,
                               1,               // Send 1 ping
                               FALSE,           // Do not wait for response
                               0,               // Timeout
                               NULL,            // Don't care which domain name matched
                               NULL );          // Don't need the DC info

                //
                // If we cannot send the ping, we are done with this DC.
                //
                if ( NetStatus == ERROR_NO_LOGON_SERVERS ) {
                    NlPrint(( NL_CRITICAL,
                       "NlPickDomainWithAccount: Cannot ping DC %ws 0x%lx\n",
                       LocalTrustList[Index].UncServerName,
                       NetStatus ));
                    LocalTrustList[Index].RetriesLeft = 0;
                    NlFreePingContext( LocalTrustList[Index].PingContext );
                    LocalTrustList[Index].PingContext = NULL;
                    NetApiBufferFree( LocalTrustList[Index].UncServerName );
                    LocalTrustList[Index].UncServerName = NULL;

                //
                // Error out on a hard error
                //
                } else if ( NetStatus != NO_ERROR ) {
                    NlPrint(( NL_CRITICAL,
                       "NlPickDomainWithAccount: Cannot NlPingDcNameWithContext %ws 0x%lx\n",
                       LocalTrustList[Index].UncServerName,
                       NetStatus ));
                    ClientSession = NULL;
                    goto Cleanup;
                }
            }

            //
            // If we're done retrying what we were doing,
            //  try something else.
            //

            if ( LocalTrustList[Index].RetriesLeft == 0 ) {
                if ( LocalTrustList[Index].DiscoveryDone ) {
                    LocalTrustList[Index].Done = TRUE;
                    NlPrintDom((NL_LOGON, DomainInfo,
                             "NlPickDomainWithAccount: %ws: Can't find DC for domain %ws (ignore this domain).\n",
                             AccountName,
                             LocalTrustList[Index].ClientSession->CsDebugDomainName ));

                    continue;
                } else {

                    //
                    // Save the previous DC ping context since it might just
                    // be very slow in responding.  We'll want to be able
                    // to recognize responses from the previous DC.
                    //

                    LocalTrustList[Index].UncServerName2 = LocalTrustList[Index].UncServerName;
                    LocalTrustList[Index].UncServerName = NULL;
                    LocalTrustList[Index].PingContext2 = LocalTrustList[Index].PingContext;
                    LocalTrustList[Index].PingContext = NULL;

                    LocalTrustList[Index].DoingDiscovery = TRUE;
                    LocalTrustList[Index].DiscoveryDone = TRUE;
                    LocalTrustList[Index].RetriesLeft = 3;
                }
            }

            //
            // If its time to discover a DC in the domain,
            //  do it.
            //

            if ( LocalTrustList[Index].DoingDiscovery ) {

                //
                // Discover a new server
                //

                if ( NlTimeoutSetWriterClientSession( LocalTrustList[Index].ClientSession,
                                                      10*1000 ) ) {

                    //
                    // Only tear down an existing secure channel once.
                    //

                    if ( LocalTrustList[Index].RetriesLeft == 3 ) {
                        NlSetStatusClientSession( LocalTrustList[Index].ClientSession,
                            STATUS_NO_LOGON_SERVERS );
                    }

                    //
                    // We can't afford to wait so only send a single
                    //  discovery datagram.
                    //

                    if ( LocalTrustList[Index].ClientSession->CsState == CS_IDLE ) {
                        (VOID) NlDiscoverDc( LocalTrustList[Index].ClientSession,
                                             DT_DeadDomain,
                                             FALSE,
                                             FALSE );  // don't specify account
                    }

                    NlResetWriterClientSession( LocalTrustList[Index].ClientSession );

                }
            }

            //
            // Indicate we're trying something.
            //

            LocalTrustList[Index].RetriesLeft --;
            DomainsPending ++;
        }

        //
        // If all of the domains are done,
        //  leave the loop.
        //

        if ( DomainsPending == 0 ) {
            break;
        }

        //
        // See if any DC responds within 5 seconds
        //

        NlPrint(( NL_MISC,
                  "NlPickDomainWithAccountViaPing: Waiting for responses\n" ));

        WaitStartTime = GetTickCount();
        while ( DomainsPending > 0 &&
                NetpDcElapsedTime(WaitStartTime) < 5000 ) {

            //
            // Find out which DC responded
            //

            for ( Index = 0; Index < LocalTrustListLength; Index ++ ) {

                if ( LocalTrustList[Index].Done ) {
                    continue;
                }

                //
                // Check if a DC has become available if we are
                // doing discovery for this domain. If so, ping it.
                //

                if ( LocalTrustList[Index].DoingDiscovery ) {

                    //
                    // Prepare the ping context. This will fail if
                    //  the client session is still idle.
                    //

                    NetStatus = NlPreparePingContext ( LocalTrustList[Index].ClientSession,
                                                       AccountName,
                                                       AllowableAccountControlBits,
                                                       &LocalTrustList[Index].UncServerName,
                                                       &LocalTrustList[Index].PingContext );
                    //
                    // If the client session isn't idle,
                    //  try sending to the current DC.
                    //

                    if ( NetStatus == NO_ERROR ) {
                        LocalTrustList[Index].DoingDiscovery = FALSE;
                        NlPrintDom((NL_LOGON, DomainInfo,
                                 "NlPickDomainWithAccount: %ws: Noticed domain %ws has discovered a new DC %ws\n",
                                 AccountName,
                                 LocalTrustList[Index].ClientSession->CsDebugDomainName,
                                 LocalTrustList[Index].UncServerName ));

                        NetStatus = NlPingDcNameWithContext(
                                       LocalTrustList[Index].PingContext,
                                       1,               // Send 1 ping
                                       FALSE,           // Do not wait for response
                                       0,               // Timeout
                                       NULL,            // Don't care which domain name matched
                                       NULL );          // Don't need the DC info

                        LocalTrustList[Index].RetriesLeft = 2;  // Already sent 1 ping

                        //
                        // If we cannot send the ping, we are done with this DC.
                        //
                        if ( NetStatus == ERROR_NO_LOGON_SERVERS ) {
                            NlPrint(( NL_CRITICAL,
                                 "NlPickDomainWithAccount: Cannot ping DC %ws 0x%lx\n",
                                 LocalTrustList[Index].UncServerName,
                                 NetStatus ));
                            LocalTrustList[Index].RetriesLeft = 0;
                            NlFreePingContext( LocalTrustList[Index].PingContext );
                            LocalTrustList[Index].PingContext = NULL;
                            NetApiBufferFree( LocalTrustList[Index].UncServerName );
                            LocalTrustList[Index].UncServerName = NULL;

                        //
                        // Error out on a hard error
                        //
                        } else if ( NetStatus != NO_ERROR ) {
                            NlPrint(( NL_CRITICAL,
                               "NlPickDomainWithAccount: Cannot NlPingDcNameWithContext %ws 0x%lx\n",
                               LocalTrustList[Index].UncServerName,
                               NetStatus ));
                            ClientSession = NULL;
                            goto Cleanup;
                        }

                    //
                    // Error out on the hard error
                    //

                    } else if ( NetStatus == ERROR_NOT_ENOUGH_MEMORY ) {
                        ClientSession = NULL;
                        goto Cleanup;
                    }

                }


                //
                // Check if the response corresponds to either ping context
                //  for this trust entry
                //

                for ( PingContextIndex=0; PingContextIndex<2; PingContextIndex++ ) {

                    if ( PingContextIndex == 0 ) {
                        TrustEntryPingContext = LocalTrustList[Index].PingContext;
                    } else {
                        TrustEntryPingContext = LocalTrustList[Index].PingContext2;
                    }
                    if ( TrustEntryPingContext == NULL ) {
                        continue;
                    }
                    if ( NlDcCacheEntry != NULL ) {
                        NetpDcDerefCacheEntry( NlDcCacheEntry );
                        NlDcCacheEntry = NULL;
                    }

                    //
                    // Get the response. Set timeout to 0 to avoid
                    //  waiting for a response if it's not available.
                    //
                    NetStatus = NetpDcGetPingResponse(
                                   TrustEntryPingContext,
                                   0,
                                   &NlDcCacheEntry,
                                   &UsedNetbios );

                    //
                    // If no error, we've found the domain
                    //
                    if ( NetStatus == NO_ERROR ) {
                        NlPrintDom((NL_MISC, DomainInfo,
                                "NlPickDomainWithAccount: %ws has account %ws\n",
                                LocalTrustList[Index].ClientSession->CsDebugDomainName,
                                AccountName ));
                        ClientSession = LocalTrustList[Index].ClientSession;
                        goto Cleanup;

                    //
                    // If there is no such user in the domain, we are
                    //  done with this trust entry
                    //
                    } else if ( NetStatus == ERROR_NO_SUCH_USER ) {
                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                "NlPickDomainWithAccount: %ws responded negatively for account %ws\n",
                                LocalTrustList[Index].ClientSession->CsDebugDomainName,
                                AccountName ));

                        LocalTrustList[Index].RetriesLeft = 0;
                        LocalTrustList[Index].Done = TRUE;
                        break;

                    //
                    // Any other response other than wait timeout means
                    //  that the DC responded with invalid data.  We are
                    //  done with this DC then.
                    //
                    } else if ( NetStatus != ERROR_SEM_TIMEOUT ) {
                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                "NlPickDomainWithAccount: %ws invalid response for account %ws\n",
                                LocalTrustList[Index].ClientSession->CsDebugDomainName,
                                AccountName ));

                        //
                        // If this is the current DC for this domain,
                        //  indicate that we should stop pinging it.
                        //
                        if ( PingContextIndex == 0 ) {
                            LocalTrustList[Index].RetriesLeft = 0;
                            NlFreePingContext( LocalTrustList[Index].PingContext );
                            LocalTrustList[Index].PingContext = NULL;
                            NetApiBufferFree( LocalTrustList[Index].UncServerName );
                            LocalTrustList[Index].UncServerName = NULL;
                        } else {
                            NlFreePingContext( LocalTrustList[Index].PingContext2 );
                            LocalTrustList[Index].PingContext2 = NULL;
                            NetApiBufferFree( LocalTrustList[Index].UncServerName2 );
                            LocalTrustList[Index].UncServerName2 = NULL;
                        }
                    }
                }

                //
                // If we have no ping context for this trust entry
                //  and we are not doing a DC discovery for it, we
                //  are done with it.
                //
                if ( LocalTrustList[Index].PingContext  == NULL &&
                     LocalTrustList[Index].PingContext2 == NULL &&
                     !LocalTrustList[Index].DoingDiscovery ) {
                    NlPrintDom((NL_CRITICAL, DomainInfo,
                            "NlPickDomainWithAccount: %ws no ping context for account %ws\n",
                            LocalTrustList[Index].ClientSession->CsDebugDomainName,
                            AccountName ));
                    LocalTrustList[Index].Done = TRUE;
                }

                if ( LocalTrustList[Index].Done ) {
                    DomainsPending --;
                }
            }

            //
            // Sleep for a little while waiting for replies
            //  (In other words, don't go CPU bound)
            //
            Sleep( NL_DC_MIN_PING_TIMEOUT );
        }
    }

    //
    // No DC has the specified account.
    //

    ClientSession = NULL;
    NetStatus = NO_ERROR;

    //
    // Cleanup locally used resources.
    //

Cleanup:

    if ( NlDcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( NlDcCacheEntry );
    }

    //
    // Unreference each client session structure and free the local trust list.
    //  (Keep the returned ClientSession referenced).
    //

    if ( LocalTrustList != NULL ) {

        for ( Index=0; Index<LocalTrustListLength; Index++ ) {
            if ( LocalTrustList[Index].UncServerName != NULL ) {
                NetApiBufferFree( LocalTrustList[Index].UncServerName );
            }
            if ( LocalTrustList[Index].UncServerName2 != NULL ) {
                NetApiBufferFree( LocalTrustList[Index].UncServerName2 );
            }
            if ( LocalTrustList[Index].PingContext != NULL ) {
                NlFreePingContext( LocalTrustList[Index].PingContext );
            }
            if ( LocalTrustList[Index].PingContext2 != NULL ) {
                NlFreePingContext( LocalTrustList[Index].PingContext2 );
            }
            if ( ClientSession != LocalTrustList[Index].ClientSession ) {
                NlUnrefClientSession( LocalTrustList[Index].ClientSession );
            }
        }

        NetpMemoryFree(LocalTrustList);
    }

    if ( NetStatus != NO_ERROR && ClientSession == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlPickDomainWithAccountViaPing failed 0x%lx\n",
                  NetStatus ));
    }

    return ClientSession;
}


NTSTATUS
NlLoadNtdsaDll(
    VOID
    )
/*++

Routine Description:

    This function loads the ntdsa.dll module if it is not loaded
    already.

Arguments:

    None

Return Value:

    NT Status code.

--*/
{
    static NTSTATUS DllLoadStatus = STATUS_SUCCESS;
    HANDLE DllHandle = NULL;

    //
    // If the DLL is already loaded,
    //  we're done.
    //

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
    if ( NlGlobalNtDsaHandle != NULL ) {
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
        return STATUS_SUCCESS;
    }


    //
    // If we've tried to load the DLL before and it failed,
    //  return the same error code again.
    //

    if( DllLoadStatus != STATUS_SUCCESS ) {
        goto Cleanup;
    }


    //
    // Load the dll
    //

    DllHandle = LoadLibraryA( "NtDsa" );

    if ( DllHandle == NULL ) {
        DllLoadStatus = STATUS_DLL_NOT_FOUND;
        goto Cleanup;
    }

//
// Macro to grab the address of the named procedure from ntdsa.dll
//

#define GRAB_ADDRESS( _X ) \
    NlGlobalp##_X = (P##_X) GetProcAddress( DllHandle, #_X ); \
    \
    if ( NlGlobalp##_X == NULL ) { \
        DllLoadStatus = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

    //
    // Get the addresses of the required procedures.
    //

    GRAB_ADDRESS( CrackSingleName );
    GRAB_ADDRESS( GetConfigurationName );
    GRAB_ADDRESS( GetConfigurationNamesList );
    GRAB_ADDRESS( GetDnsRootAlias );
    GRAB_ADDRESS( DsGetServersAndSitesForNetLogon );
    GRAB_ADDRESS( DsFreeServersAndSitesForNetLogon );

    DllLoadStatus = STATUS_SUCCESS;

Cleanup:
    if (DllLoadStatus == STATUS_SUCCESS) {
        NlGlobalNtDsaHandle = DllHandle;

    } else {
        if ( DllHandle != NULL ) {
            FreeLibrary( DllHandle );
        }
    }
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
    return( DllLoadStatus );
}


NTSTATUS
NlCrackSingleName(
    DWORD       formatOffered,          // one of DS_NAME_FORMAT in ntdsapi.h
    BOOL        fPerformAtGC,           // whether to go to GC or not
    WCHAR       *pNameIn,               // name to crack
    DWORD       formatDesired,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       *pccDnsDomain,          // char count of following argument
    WCHAR       *pDnsDomain,            // buffer for DNS domain name
    DWORD       *pccNameOut,            // char count of following argument
    WCHAR       *pNameOut,              // buffer for formatted name
    DWORD       *pErr)                  // one of DS_NAME_ERROR in ntdsapi.h
/*++

Routine Description:

    This routine is a thin wrapper that loads NtDsa.dll then calls
    CrackSingleName.

Arguments:

    Same as CrackSingleName

Return Value:

    Same as CrackSingleName

--*/
{
    NTSTATUS Status;

    //
    // Ensure ntdsa.dll is loaded.
    //

    Status = NlLoadNtdsaDll();

    if ( NT_SUCCESS(Status) ) {

        //
        // Call the actual function.
        //
        Status = (*NlGlobalpCrackSingleName)(
                        formatOffered,
                        DS_NAME_FLAG_TRUST_REFERRAL |   // Tell CrackSingle name that we understand the DS_NAME_ERROR_TRUST_REFERRAL status code
                            (fPerformAtGC ?
                                DS_NAME_FLAG_GCVERIFY : 0),
                        pNameIn,
                        formatDesired,
                        pccDnsDomain,
                        pDnsDomain,
                        pccNameOut,
                        pNameOut,
                        pErr );

        //
        // CrackSingle name sometimes returns DS_NAME_ERROR_DOMAIN_ONLY after syntactically
        //  parsing the name.
        //
        if ( Status == STATUS_SUCCESS &&
             *pErr == DS_NAME_ERROR_DOMAIN_ONLY ) {
            *pErr = DS_NAME_ERROR_NOT_FOUND;
        }

    }

    return Status;
}

NTSTATUS
NlCrackSingleNameEx(
    DWORD formatOffered,
    WCHAR *InGcAccountName OPTIONAL,
    WCHAR *InLsaAccountName OPTIONAL,
    DWORD formatDesired,
    DWORD *CrackedDnsDomainNameLength,
    WCHAR *CrackedDnsDomainName,
    DWORD *CrackedUserNameLength,
    WCHAR *CrackedUserName,
    DWORD *CrackError,
    LPSTR *CrackDebugString
    )
/*++

Routine Description:

    This routine tries the crack name in the following places in succession:

    * The cross forest trust cache (at the root of the forest)
    * A local DsCrackName
    * A DsCrackName on the GC.

Arguments:

    Same as CrackSingleName plus the following

    InGcAccountName - Name to crack on GC.
        If NULL, no name is cracked on GC.

    InLsaAccountName - Name to crack using LsaIForestTrustFindMatch
        If NULL, no name is cracked using LsaIForestTrustFindMatch

Return Value:

    Same as CrackSingleName

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Save the domain name and user name before we overwrite them
    //

    *CrackDebugString = NULL;


    //
    // If we're a DC the root of the forest,
    //  ask LSA if the account is in a trusted forest.
    //

    if ( InLsaAccountName ) {
        UNICODE_STRING InAccountNameString;
        LSA_UNICODE_STRING OutForestName;

        //
        // Match the name to the FTinfo list
        //

        RtlInitUnicodeString( &InAccountNameString, InLsaAccountName );

        *CrackDebugString = "via LsaMatch";
        Status = LsaIForestTrustFindMatch(
                            formatOffered == DS_USER_PRINCIPAL_NAME ?
                                RoutingMatchUpn :
                                RoutingMatchDomainName,
                            &InAccountNameString,
                            &OutForestName );

        if ( NT_SUCCESS(Status) ) {
            if ( OutForestName.Length + sizeof(WCHAR) <= *CrackedDnsDomainNameLength ) {
                RtlCopyMemory( CrackedDnsDomainName,
                               OutForestName.Buffer,
                               OutForestName.Length );
                CrackedDnsDomainName[OutForestName.Length/sizeof(WCHAR)] = '\0';
                *CrackedDnsDomainNameLength = OutForestName.Length/sizeof(WCHAR);
                *CrackedUserNameLength = 0;
                *CrackError = DS_NAME_ERROR_TRUST_REFERRAL;
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }

            LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (PLSAPR_UNICODE_STRING)&OutForestName );
            return Status;
        } else if ( Status == STATUS_NO_MATCH ) {
            Status = STATUS_SUCCESS;
            *CrackError = DS_NAME_ERROR_NOT_FOUND;
        }
    }



    //
    // We've already tried the local DC, try the GC.
    //

    if ( InGcAccountName ) {

        *CrackDebugString = "on GC";
        Status = NlCrackSingleName(
                              formatOffered,
                              TRUE,                         // do it on GC
                              InGcAccountName,              // Name to crack
                              formatDesired,
                              CrackedDnsDomainNameLength,   // length of domain buffer
                              CrackedDnsDomainName,         // domain buffer
                              CrackedUserNameLength,        // length of user name
                              CrackedUserName,              // name
                              CrackError );                 // Translation error code

    }

    return Status;

}

NTSTATUS
NlGetConfigurationName(
                       DWORD       which,
                       DWORD       *pcbName,
                       DSNAME      *pName
    )
/*++

Routine Description:

    This routine is a thin wrapper that loads NtDsa.dll then calls
    GetConfigurationName.

Arguments:

    Same as GetConfigurationName

Return Value:

    Same as GetConfigurationName

--*/
{
    NTSTATUS Status;

    //
    // Ensure ntdsa.dll is loaded.
    //

    Status = NlLoadNtdsaDll();

    if ( NT_SUCCESS(Status) ) {

        //
        // Call the actual function.
        //
        Status = (*NlGlobalpGetConfigurationName)(
                                which,
                                pcbName,
                                pName );

    }

    return Status;
}

NTSTATUS
NlGetConfigurationNamesList(
    DWORD       which,
    DWORD       dwFlags,
    ULONG *     pcbNames,
    DSNAME **   padsNames
    )
/*++

Routine Description:

    This routine is a thin wrapper that loads NtDsa.dll then calls
    GetConfigurationNamesList.

Arguments:

    Same as GetConfigurationNamesList

Return Value:

    Same as GetConfigurationNamesList

--*/
{
    NTSTATUS Status;

    //
    // Ensure ntdsa.dll is loaded.
    //

    Status = NlLoadNtdsaDll();

    if ( NT_SUCCESS(Status) ) {

        //
        // Call the actual function.
        //
        Status = (*NlGlobalpGetConfigurationNamesList)(
                                which,
                                dwFlags,
                                pcbNames,
                                padsNames );

    }

    return Status;
}

NTSTATUS
NlGetDnsRootAlias(
    WCHAR * pDnsRootAlias,
    WCHAR * pRootDnsRootAlias
    )
/*++

Routine Description:

    This routine is a thin wrapper that loads NtDsa.dll then calls
    GetDnsRootAlias.

Arguments:

    Same as GetDnsRootAlias

Return Value:

    Same as GetDnsRootAlias

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Ensure ntdsa.dll is loaded.
    //

    Status = NlLoadNtdsaDll();

    if ( NT_SUCCESS(Status) ) {

        //
        // Call the actual function.
        //
        Status = (*NlGlobalpGetDnsRootAlias)(
                                pDnsRootAlias,
                                pRootDnsRootAlias );

    }

    return Status;
}

DWORD
NlDsGetServersAndSitesForNetLogon(
    WCHAR *    pNDNC,
    SERVERSITEPAIR ** ppaRes)
/*++

Routine Description:

    This routine is a thin wrapper that loads NtDsa.dll then calls
    DsGetServersAndSitesForNetLogon.

Arguments:

    Same as DsGetServersAndSitesForNetLogon

Return Value:

    Same as DsGetServersAndSitesForNetLogon

--*/
{
    NTSTATUS Status;

    //
    // Ensure ntdsa.dll is loaded.
    //

    Status = NlLoadNtdsaDll();

    if ( NT_SUCCESS(Status) ) {

        //
        // Call the actual function.
        //
        Status = (*NlGlobalpDsGetServersAndSitesForNetLogon)(
                                pNDNC,
                                ppaRes );
    }

    return Status;
}

VOID
NlDsFreeServersAndSitesForNetLogon(
    SERVERSITEPAIR *         paServerSites
    )
/*++

Routine Description:

    This routine is a thin wrapper that loads NtDsa.dll then calls
    DsFreeServersAndSitesForNetLogon.

Arguments:

    Same as DsFreeServersAndSitesForNetLogon

Return Value:

    Same as DsFreeServersAndSitesForNetLogon

--*/
{
    NTSTATUS Status;

    //
    // Ensure ntdsa.dll is loaded.
    //

    Status = NlLoadNtdsaDll();

    if ( NT_SUCCESS(Status) ) {

        //
        // Call the actual function.
        //
        (*NlGlobalpDsFreeServersAndSitesForNetLogon)( paServerSites );
    }
}


NTSTATUS
NlPickDomainWithAccount (
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING InAccountNameString,
    IN PUNICODE_STRING InDomainNameString OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN BOOLEAN ExpediteToRoot,
    IN BOOLEAN CrossForestHop,
    OUT LPWSTR *RealSamAccountName,
    OUT LPWSTR *RealDomainName,
    OUT PULONG RealExtraFlags
    )

/*++

Routine Description:

    Get the name of a trusted domain that defines a particular account.

Arguments:

    DomainInfo - Domain account is in

    AccountNameString - Name of our user account to find.

    DomainNameString - Name of the domain to find the account name in.
        If not specified, the domain name is unknown.

    AllowableAccountControlBits - A mask of allowable SAM account types that
        are allowed to satisfy this request.

    SecureChannelType -- Type of secure channel this request was made over.

    ExpediteToRoot = Request was passed expedite to root DC of this forest.

    CrossForestHop = Request is first hop over cross forest trust TDO.

    RealSamAccountName - On success, returns a pointer to the name of the SAM account to use.
        The caller should free this buffer via NetApiBufferFree().
        Returns NULL if NL_EXFLAGS_EXPEDITE_TO_ROOT or NL_EXFLAGS_CROSS_FOREST_HOP is returned.

    RealDomainName - On success, returns a pointer to the name of the Domain the account is in.
        The caller should free this buffer via NetApiBufferFree().
        Returns NULL if NL_EXFLAGS_EXPEDITE_TO_ROOT is returned.
        Returns the name of the trusted forest if NL_EXFLAGS_CROSS_FOREST_HOP is returned.

    RealExtraFlags - On success, returns flags describing the found account.
        NL_EXFLAGS_EXPEDITE_TO_ROOT - Indicates account is in a trusted forest.
        NL_EXFLAGS_CROSS_FOREST_HOP - Indicates account is in a trusted forest and this domain is root of this forest.


Return Value:

    STATUS_SUCCESS - Domain found.  Information about the DC was returned.

    STATUS_NO_SUCH_DOMAIN - Named account doesn't exist in any domain.

--*/
{
    NTSTATUS Status;
    // NET_API_STATUS NetStatus;
    DWORD CrackError;
    LPSTR CrackDebugString = NULL;
    ULONG DebugFlag;

    UNICODE_STRING TemplateDomainNameString;
    PCLIENT_SESSION ClientSession = NULL;
    WCHAR *UpnDomainName = NULL;
    ULONG UpnPrefixLength;
    LPWSTR SamAccountNameToReturn;
    BOOLEAN MightBeUpn = FALSE;
    BOOL MightBeSamAccount;
    LPWSTR AllocatedBuffer = NULL;

    LPWSTR InDomainName;
    LPWSTR InPrintableAccountName;
    LPWSTR InAccountName;


    LPWSTR CrackedDnsDomainName;
    UNICODE_STRING DnsDomainNameString;
    DWORD CrackedDnsDomainNameLength;
    DWORD MaxCrackedDnsDomainNameLength;

    LPWSTR CrackedUserName;
    DWORD CrackedUserNameLength;
    DWORD MaxCrackedUserNameLength;

    BOOLEAN CallerIsDc = IsDomainSecureChannelType(SecureChannelType);

    BOOLEAN AtRoot = (DomainInfo->DomFlags & DOM_FOREST_ROOT) != 0;

    BOOLEAN UseLsaMatch = FALSE;
    BOOLEAN UseGc = FALSE;
    BOOLEAN UseReferral = FALSE;
    BOOLEAN UsePing = FALSE;

    //
    // Initialization
    //

    *RealSamAccountName = NULL;
    *RealDomainName = NULL;
    *RealExtraFlags = 0;

    //
    // Canonicalize the passed in domain name
    //

    if ( InDomainNameString == NULL ) {
        InDomainNameString = &TemplateDomainNameString;
        RtlInitUnicodeString( &TemplateDomainNameString, NULL );
    }


    //
    // Allocate a buffer for storage local to this procedure.
    //  (Don't put it on the stack since we don't want to commit a huge stack.)
    //

    MaxCrackedDnsDomainNameLength = NL_MAX_DNS_LENGTH+1;
    MaxCrackedUserNameLength = DNLEN + 1 + UNLEN + 1;

    AllocatedBuffer = LocalAlloc( 0,
            sizeof(WCHAR) * (MaxCrackedDnsDomainNameLength + MaxCrackedUserNameLength) +
            InDomainNameString->Length + sizeof(WCHAR) +
            InDomainNameString->Length + sizeof(WCHAR) +
            InAccountNameString->Length + sizeof(WCHAR) );

    if ( AllocatedBuffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    CrackedDnsDomainName = AllocatedBuffer;
    CrackedUserName = &AllocatedBuffer[MaxCrackedDnsDomainNameLength];
    InDomainName = &CrackedUserName[MaxCrackedUserNameLength];
    InPrintableAccountName = &InDomainName[(InDomainNameString->Length/sizeof(WCHAR))+1];
    InAccountName = &InPrintableAccountName[(InDomainNameString->Length/sizeof(WCHAR))+1];

    //
    // Build a zero terminated version of the input strings
    //

    if ( InDomainNameString->Length != 0 ) {
        RtlCopyMemory( InDomainName, InDomainNameString->Buffer, InDomainNameString->Length );
        InDomainName[InDomainNameString->Length/sizeof(WCHAR)] = '\0';

        RtlCopyMemory( InPrintableAccountName, InDomainNameString->Buffer, InDomainNameString->Length );
        InPrintableAccountName[InDomainNameString->Length/sizeof(WCHAR)] = '\\';
    } else {
        InDomainName = NULL;
        InPrintableAccountName = InAccountName;
    }

    RtlCopyMemory( InAccountName, InAccountNameString->Buffer, InAccountNameString->Length );
    InAccountName[InAccountNameString->Length/sizeof(WCHAR)] = '\0';




    //
    // Classify the input account name.
    //
    // A UPN has the syntax <AccountName>@<DnsDomainName>.
    // If there are multiple @ signs,
    //  use the last one since an AccountName can have an @ in it.
    //

    if ( InDomainName == NULL ) {
        UpnDomainName = wcsrchr( InAccountName, L'@' );
        if ( UpnDomainName != NULL ) {

            //
            // Avoid zero length <AccountName>
            //
            UpnPrefixLength = (ULONG)(UpnDomainName - InAccountName);
            if ( UpnPrefixLength ) {
                UpnDomainName++;

                //
                // Avoid zero length <DnsDomainName>
                //
                if ( *UpnDomainName != L'\0') {
                    MightBeUpn = TRUE;
                }
            }

        }
    }

    MightBeSamAccount = NetpIsUserNameValid( InAccountName );

    NlPrintDom((NL_LOGON, DomainInfo,
             "NlPickDomainWithAccount: %ws: Algorithm entered. UPN:%ld Sam:%ld Exp:%ld Cross: %ld Root:%ld DC:%ld\n",
             InPrintableAccountName,
             MightBeUpn,
             MightBeSamAccount,
             ExpediteToRoot,
             CrossForestHop,
             AtRoot,
             CallerIsDc ));

    if ( !MightBeSamAccount && !MightBeUpn ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlPickDomainWithAccount: %ws: Must be either UPN or SAM account. UPN:%ld Sam:%ld\n",
                 InPrintableAccountName,
                 MightBeUpn,
                 MightBeSamAccount ));

        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Some combinations are invalid
    //

    if ( !CallerIsDc && (CrossForestHop || ExpediteToRoot)) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlPickDomainWithAccount: %ws: Non-DC passed CrossForestHop (%ld) or ExpediteToRoot (%ld)\n",
                 InPrintableAccountName,
                 CrossForestHop,
                 ExpediteToRoot ));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }
    if ( CrossForestHop && ExpediteToRoot ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlPickDomainWithAccount: %ws: Both CrossForestHop (%ld) and ExpediteToRoot (%ld)\n",
                 InPrintableAccountName,
                 CrossForestHop,
                 ExpediteToRoot ));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }
    if ( CrossForestHop && !AtRoot ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlPickDomainWithAccount: %ws: CrossForestHop (%ld) and not AtRoot (%ld)\n",
                 InPrintableAccountName,
                 CrossForestHop,
                 AtRoot ));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // If this request came from a DC,
    //  that DC should have done this call except in two cases:
    //  1) This is a ExpediteToRoot and we're now at the root.
    //  2) This is a CrossForestHop and we're now in the other forest.
    //

    if ( CallerIsDc &&
         !(ExpediteToRoot && AtRoot) &&
         !CrossForestHop )  {
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Finally, mark which lookups are to be performed
    //

    if ( ExpediteToRoot && AtRoot ) {
        UseLsaMatch = TRUE;
        UseReferral = TRUE;
    } else if ( CrossForestHop ) {
        UseGc = TRUE;
    } else {
        UseLsaMatch = TRUE;
        UseGc = TRUE;
        UseReferral = TRUE;
        UsePing = TRUE;
    }





    //
    // If the name might be a UPN,
    //  look it up.
    //

    if ( MightBeUpn ) {

        //
        // Crack the UPN.
        //

        CrackedDnsDomainNameLength = MaxCrackedDnsDomainNameLength;
        CrackedUserNameLength = MaxCrackedUserNameLength;

        Status = NlCrackSingleNameEx(
                              DS_USER_PRINCIPAL_NAME,       // Translate from UPN,
                              UseGc ? InAccountName : NULL, // GC Name to crack
                              UseLsaMatch ? InAccountName : NULL, // LSA Name to crack
                              DS_NT4_ACCOUNT_NAME,          // Translate to NT 4 style
                              &CrackedDnsDomainNameLength,  // length of domain buffer
                              CrackedDnsDomainName,         // domain buffer
                              &CrackedUserNameLength,       // length of user name
                              CrackedUserName,              // name
                              &CrackError,                  // Translation error code
                              &CrackDebugString );


        DebugFlag = NL_CRITICAL;
        if ( Status == STATUS_SUCCESS ) {

            if ( CrackError == DS_NAME_ERROR_TRUST_REFERRAL && !UseReferral ) {
                CrackError = DS_NAME_ERROR_NOT_FOUND;
            }

            if ( CrackError == DS_NAME_NO_ERROR ||
                 CrackError == DS_NAME_ERROR_TRUST_REFERRAL ) {

                goto CrackNameWorked;

            } else if ( CrackError == DS_NAME_ERROR_NOT_FOUND ) {
                DebugFlag = NL_SESSION_MORE;
            }
        }

        NlPrintDom(( DebugFlag, DomainInfo,
                     "NlPickDomainWithAccount: Username %ws can't be cracked %s. 0x%lx %ld\n",
                     InPrintableAccountName,
                     CrackDebugString,
                     Status,
                     CrackError ));



        //
        // If the string to the right of the @ is in the forest or a directly trusted domain,
        //  convert the UPN to <DnsDomainName>\<UserName> and try the operation again.
        //

        if ( UpnPrefixLength <= UNLEN ) {
            UNICODE_STRING UpnDomainNameString;

            RtlInitUnicodeString( &UpnDomainNameString, UpnDomainName );

            ClientSession = NlFindNamedClientSession(
                                        DomainInfo,
                                        &UpnDomainNameString,
                                        0,  // Indirect trust OK
                                        NULL );

            if ( ClientSession != NULL ) {

                //
                // We don't need the client session.
                //

                NlUnrefClientSession( ClientSession );
                ClientSession = NULL;


                //
                // The real sam account name is everything before the @
                //

                RtlCopyMemory( CrackedUserName, InAccountName, UpnPrefixLength*sizeof(WCHAR) );
                CrackedUserName[UpnPrefixLength] = L'\0';

                SamAccountNameToReturn = CrackedUserName;


                //
                // The real domain name is everything after the @
                //
                CrackedDnsDomainName = UpnDomainName;


                NlPrintDom((NL_LOGON, DomainInfo,
                         "NlPickDomainWithAccount: Username %ws is assumed to be in %ws with account name %ws\n",
                         InPrintableAccountName,
                         UpnDomainName,
                         SamAccountNameToReturn ));

                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
        }


    }

    //
    // See if this is a SAM account name of an account in the enterprise.
    //
    if ( MightBeSamAccount ) {
        CrackedDnsDomainNameLength = MaxCrackedDnsDomainNameLength;
        CrackedUserNameLength = MaxCrackedUserNameLength;


        //
        // If the domain name isn't specified,
        //  try the GC to find the domain name.
        //

        if ( InDomainName == NULL ) {

            if ( UseGc ) {
                CrackDebugString = "On GC";
                Status = NlCrackSingleName(
                              DS_NT4_ACCOUNT_NAME_SANS_DOMAIN_EX,   // Translate from Sam Account Name without domain name
                                                                    // The _EX version also avoids disabled accounts
                              TRUE,                                 // do it on GC
                              InAccountName,                        // Name to crack
                              DS_NT4_ACCOUNT_NAME,                  // Translate to NT 4 style
                              &CrackedDnsDomainNameLength,          // length of domain buffer
                              CrackedDnsDomainName,                 // domain buffer
                              &CrackedUserNameLength,               // length of user name
                              CrackedUserName,                      // name
                              &CrackError );                        // Translation error code
            } else {
                CrackDebugString = NULL;
            }

        //
        // If the domain name is specified,
        //  the caller already determine that the name isn't that of a (transitively) trusted domain,
        //  try the GC (or local DS) to determine if the account is in another forest.
        //

        } else {

            Status = NlCrackSingleNameEx(
                          DS_NT4_ACCOUNT_NAME,                  // Translate from NT 4 style
                          UseGc ? InPrintableAccountName : NULL,// GC Name to crack
                          UseLsaMatch ? InDomainName : NULL,    // LSA Name to crack
                          DS_NT4_ACCOUNT_NAME,                  // Translate to NT 4 style
                          &CrackedDnsDomainNameLength,          // length of domain buffer
                          CrackedDnsDomainName,                 // domain buffer
                          &CrackedUserNameLength,               // length of user name
                          CrackedUserName,                      // name
                          &CrackError,                          // Translation error code
                          &CrackDebugString );
        }

        if ( CrackDebugString != NULL ) {
            DebugFlag = NL_CRITICAL;
            if ( Status == STATUS_SUCCESS ) {

                if ( CrackError == DS_NAME_ERROR_TRUST_REFERRAL && !UseReferral ) {
                    CrackError = DS_NAME_ERROR_NOT_FOUND;
                }

                if ( CrackError == DS_NAME_NO_ERROR ||
                     CrackError == DS_NAME_ERROR_TRUST_REFERRAL ) {

                    goto CrackNameWorked;
                } else if ( CrackError == DS_NAME_ERROR_NOT_FOUND ) {
                    DebugFlag = NL_SESSION_MORE;
                }
            }

            NlPrintDom(( DebugFlag, DomainInfo,
                         "NlPickDomainWithAccount: Username %ws can't be cracked (%s). 0x%lx %ld\n",
                         InPrintableAccountName,
                         CrackDebugString,
                         Status,
                         CrackError ));
        }



        //
        // Finally, use the barbaric "ping" method of finding a DC.
        //

        if ( InDomainName == NULL && UsePing ) {
            ClientSession = NlPickDomainWithAccountViaPing (
                                DomainInfo,
                                InAccountName,
                                AllowableAccountControlBits );

            if ( ClientSession != NULL ) {

                NlPrintDom((NL_CRITICAL, DomainInfo,
                         "NlPickDomainWithAccount: Username %ws found via 'pinging'\n",
                         InPrintableAccountName ));

                LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
                if ( ClientSession->CsDnsDomainName.Length == 0 ) {
                    CrackedDnsDomainName = ClientSession->CsDnsDomainName.Buffer;
                } else {
                    CrackedDnsDomainName = ClientSession->CsNetbiosDomainName.Buffer;
                }
                UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

                SamAccountNameToReturn = InAccountName;

                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
        }

    }


    //
    // No mechanism worked
    //
    Status = STATUS_NO_SUCH_DOMAIN;
    goto Cleanup;


    //
    // If DsCrackName found the account,
    //  Lookup the nearest domain to go to.
    //

CrackNameWorked:
    if ( CrackError == DS_NAME_NO_ERROR ) {


        //
        // Crackname returned the account name in the form:
        //  <NetbiosDomain>\<SamAccountName>
        //
        // Parse that and return the SamAccountName
        //

        SamAccountNameToReturn = wcschr( CrackedUserName, L'\\' );

        if ( SamAccountNameToReturn == NULL ) {
            SamAccountNameToReturn = CrackedUserName;
        } else {
            SamAccountNameToReturn++;
        }

        NlPrintDom(( NL_LOGON, DomainInfo,
                     "NlPickDomainWithAccount: Username %ws is %ws\\%ws (found %s)\n",
                     InPrintableAccountName,
                     CrackedDnsDomainName,
                     SamAccountNameToReturn,
                     CrackDebugString ));

    //
    // If DsCrackName determined this was a cross forest trust,
    //  return that info to the caller.
    //

    } else if ( CrackError == DS_NAME_ERROR_TRUST_REFERRAL ) {


        NlPrintDom(( NL_LOGON, DomainInfo,
                     "NlPickDomainWithAccount: Username %ws is in forest %ws (found %s)\n",
                     InPrintableAccountName,
                     CrackedDnsDomainName,
                     CrackDebugString ));

        SamAccountNameToReturn = NULL;

        if ( AtRoot ) {

            //
            // If just hopped from another forest,
            //  stay within this forest.
            //  Cross forest trust isn't transitive.
            //

            if ( CrossForestHop ) {
                Status = STATUS_NO_SUCH_DOMAIN;
                goto Cleanup;
            }

            *RealExtraFlags |= NL_EXFLAGS_CROSS_FOREST_HOP;

        } else {
            *RealExtraFlags |= NL_EXFLAGS_EXPEDITE_TO_ROOT;
            CrackedDnsDomainName = NULL;   // No use returning this to the caller since the caller can't use it
        }


    //
    // Internal error.
    //
    } else {
        NlAssert(( "Invalid CrackError" && FALSE ));
    }




    Status = STATUS_SUCCESS;

    //
    // Cleanup locally used resources.
    //
    //
Cleanup:

    //
    // On Success, SamAccountNameToReturn and CrackedDnsDomainName are pointers to the names to return
    //  SamAccountNameToReturn can be null if the account is in another forest.
    //

    if ( NT_SUCCESS(Status) && SamAccountNameToReturn != NULL ) {

        *RealSamAccountName = NetpAllocWStrFromWStr( SamAccountNameToReturn );

        if ( *RealSamAccountName == NULL ) {
            Status = STATUS_NO_MEMORY;
        }
    }

    if ( NT_SUCCESS(Status) && CrackedDnsDomainName != NULL ) {

        *RealDomainName = NetpAllocWStrFromWStr( CrackedDnsDomainName );

        if ( *RealDomainName == NULL ) {
            if ( *RealSamAccountName != NULL ) {
                NetApiBufferFree( *RealSamAccountName );
                *RealSamAccountName = NULL;
            }

            Status = STATUS_NO_MEMORY;
        }
    }

    if ( AllocatedBuffer != NULL ) {
        LocalFree( AllocatedBuffer );
    }

    if ( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
    }

    return Status;
}
#endif // _DC_NETLOGON


NTSTATUS
NlStartApiClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN BOOLEAN QuickApiCall,
    IN ULONG RetryIndex,
    IN NTSTATUS DefaultStatus,
    IN PCLIENT_API ClientApi
    )
/*++

Routine Description:

    Enable the timer for timing out an API call on the secure channel.

    On Entry,
        The trust list must NOT be locked.
        The caller must be a writer of the trust list entry.

Arguments:

    ClientSession - Structure used to define the session.

    QuickApiCall - True if this API call MUST finish in less than 45 seconds
        and will in reality finish in less than 15 seconds unless something
        is terribly wrong.

    RetryIndex - Index of number of times this call was retried.

    DefaultStatus - Status to return if the binding type isn't supported.
        (This is either a default status or the status from the previous
        iteration.  The status from the previous iteration is better than
        anything we could return here.)

    ClientApi - Specifies a pointer to the structure representing
        this API call.

Return Value:

    Status of the RPC binding to the server

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    BOOLEAN BindingHandleCached;
    BOOLEAN UnbindFromServer = FALSE;
    BOOLEAN DoAuthenticatedRpc;
    LARGE_INTEGER TimeNow;
    NL_RPC_BINDING RpcBindingType;
    NL_RPC_BINDING OldRpcBindingType;


    //
    // Remember the session count of when we started this API call
    //

    ClientApi->CaSessionCount = ClientSession->CsSessionCount;

    //
    // Determine the RPC Binding Type.
    //
    // Try TCP if the connection is to an NT 5 or newer DC and
    //  if this machine has TCP addresses
    //
    // Fall back to named pipes
    //

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
    if ( (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_HAS_DS) != 0 &&
         NlGlobalWinsockPnpAddresses != NULL ) {

        if ( RetryIndex == 0 ) {
            RpcBindingType = UseTcpIp;
        } else {
            if ( UseConcurrentRpc( ClientSession, ClientApi)  ) {
                LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
                return DefaultStatus;
            }
            RpcBindingType = UseNamedPipe;
        }

    //
    // Otherwise, only use named pipes.
    //

    } else {
        // NlAssert( !UseConcurrentRpc(, ClientSession, ClientApi) );
        if ( UseConcurrentRpc( ClientSession, ClientApi)  ) {
            LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
            return DefaultStatus;
        }
        if ( RetryIndex == 0 ) {
            RpcBindingType = UseNamedPipe;
        } else {
            LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
            return DefaultStatus;
        }
    }
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
    NlAssert( ClientSession->CsUncServerName != NULL );


    //
    // Save the current time.
    // Start the timer on the API call.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    NlQuerySystemTime( &TimeNow );
    ClientApi->CaApiTimer.StartTime = TimeNow;
    ClientApi->CaApiTimer.Period =
        QuickApiCall ? NlGlobalParameters.ShortApiCallPeriod : LONG_API_CALL_PERIOD;

    //
    // If the global timer isn't running,
    //  start it and tell the main thread that I've changed a timer.
    //

    if ( NlGlobalBindingHandleCount == 0 ) {

        if ( NlGlobalApiTimer.Period != NlGlobalParameters.ShortApiCallPeriod ) {

            NlGlobalApiTimer.Period = NlGlobalParameters.ShortApiCallPeriod;
            NlGlobalApiTimer.StartTime = TimeNow;

            if ( !SetEvent( NlGlobalTimerEvent ) ) {
                NlPrintCs(( NL_CRITICAL, ClientSession,
                        "NlStartApiClientSession: SetEvent failed %ld\n",
                        GetLastError() ));
            }
        }
    }

    //
    // If we haven't grabbed a thread handle yet,
    //  do so now.
    //

    if ( ClientApi->CaThreadHandle == NULL ) {
        if ( !DuplicateHandle( GetCurrentProcess(),
                               GetCurrentThread(),
                               GetCurrentProcess(),
                               &ClientApi->CaThreadHandle,
                               0,
                               FALSE,
                               DUPLICATE_SAME_ACCESS ) ) {
            NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlStartApiClientSession: DuplicateHandle failed %ld\n",
                    GetLastError() ));
        }

        //
        // Set the amount of time this client thread is willing to wait for
        //  the server to respond to a cancel.
        //

        NetStatus = RpcMgmtSetCancelTimeout( 1 );   // 1 second

        if ( NetStatus != NO_ERROR ) {
            NlPrintCs((NL_SESSION_MORE, ClientSession,
                    "NlStartApiClientSession: Cannot RpcMgmtSetCancelTimeout: %ld (continuing)\n",
                    NetStatus ));
        }
    }


    //
    // Remember if the binding handle is cached, then mark it as cached.
    //

    BindingHandleCached = (ClientApi->CaFlags & CA_BINDING_CACHED) != 0;
    ClientApi->CaFlags |= CA_BINDING_CACHED;


    //
    // Count the number of concurrent binding handles cached
    //

    if ( !BindingHandleCached ) {
        NlGlobalBindingHandleCount ++;

    //
    // If we're currently bound using TCP/IP,
    //  and the caller wants named pipe.
    //  fall back to named pipe.
    //

    } else if ( ClientApi->CaFlags & CA_TCP_BINDING ) {
        if ( RpcBindingType == UseNamedPipe ) {
            OldRpcBindingType = UseTcpIp;
            UnbindFromServer = TRUE;
            ClientApi->CaFlags &= ~CA_TCP_BINDING;
        }

    //
    // If we're currently bound using named pipe,
    //  TCP/IP must have failed in the past,
    //  continue using named pipe.
    //
    } else {
        RpcBindingType = UseNamedPipe;
    }

    //
    // Remember the RPC binding type.
    //

    if ( RpcBindingType == UseTcpIp ) {
        ClientApi->CaFlags |= CA_TCP_BINDING;
    }


    //
    // If we haven't yet told RPC to do authenticated RPC,
    //  the secure channel is already authenticated (from our perspective), and
    //  authenticated RPC has been negotiated,
    //  do it now.
    //

    DoAuthenticatedRpc =
        (ClientApi->CaFlags & CA_BINDING_AUTHENTICATED) == 0 &&
        ClientSession->CsState == CS_AUTHENTICATED &&
        (ClientSession->CsNegotiatedFlags & NETLOGON_SUPPORTS_AUTH_RPC) != 0;

    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );


    //
    // If we're bound to the wrong transport,
    //  unbind.
    //

    if ( UnbindFromServer ) {
        NTSTATUS TempStatus;

        //
        // Ensure we rebind below.
        //
        BindingHandleCached = FALSE;

        //
        // Unbind the handle
        //

        NlpSecureChannelUnbind(
                    ClientSession,
                    ClientSession->CsUncServerName,
                    "NlStartApiClientSession",
                    0,
                    ClientSession->CsUncServerName,
                    OldRpcBindingType );

    }

    //
    // Impersonate the thread token as anonymous if we use named pipes.
    //
    // By default the token is impersonated as a system token since
    // netlogon is a system service.  In this case, if we use named
    // pipes, RPC may authenticate this API call through Kerberos
    // that potentially calls us back to discover a DC therby creating
    // a potential deadlock loop.  We avoid this by impersonating the
    // token as anonymous if we use named pipes for this API call.
    // We will revert this by setting the token back to the default
    // value when we are done with this API call.
    //

    if ( (ClientApi->CaFlags & CA_TCP_BINDING) == 0 ) {
        Status = NtImpersonateAnonymousToken( NtCurrentThread() );

        if ( !NT_SUCCESS(Status) ) {
            NlPrint(( NL_CRITICAL,
                      "NlStartApiClientSession: cannot NtImpersonateAnonymousToken: 0x%lx\n",
                      Status ));
        }
    } else {
        Status = STATUS_SUCCESS;
    }


    //
    // If the binding handle isn't already cached,
    //  cache it now.
    //

    if ( NT_SUCCESS(Status) && !BindingHandleCached ) {


        NlPrintCs((NL_SESSION_MORE, ClientSession,
                "NlStartApiClientSession: Bind to server %ws (%s) %ld (Retry: %ld).\n",
                ClientSession->CsUncServerName,
                RpcBindingType == UseTcpIp ? "TCP" : "PIPE",
                ClientApiIndex( ClientSession, ClientApi ),
                RetryIndex ));

        NlAssert( ClientSession->CsState != CS_IDLE );


        //
        // If this API use the netapi32 binding handle,
        //  bind it.
        //

        if ( !UseConcurrentRpc( ClientSession, ClientApi ) ) {

            //
            // Bind to the server
            //

            Status = NlBindingAddServerToCache ( ClientSession->CsUncServerName,
                                                     RpcBindingType );

            if ( !NT_SUCCESS(Status) ) {

                //
                // If we're binding to TCP,
                //  and TCP isn't supported on this machine,
                //  simply return as though the server doesn't support TCP
                //  so caller will fall back to Named pipe.
                //

                if ( Status == RPC_NT_PROTSEQ_NOT_SUPPORTED &&
                     RpcBindingType == UseTcpIp ) {
                    NlPrintCs((NL_SESSION_MORE, ClientSession,
                            "NlStartApiClientSession: Bind to server %ws (%s) %ld failed 0x%lx (Client doesn't support TCP/IP).\n",
                            ClientSession->CsUncServerName,
                            RpcBindingType == UseTcpIp ? "TCP" : "PIPE",
                            ClientApiIndex( ClientSession, ClientApi ),
                            Status ));
                    Status = DefaultStatus;
                } else {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                            "NlStartApiClientSession: Bind to server %ws (%s) %ld failed 0x%lx.\n",
                            ClientSession->CsUncServerName,
                            RpcBindingType == UseTcpIp ? "TCP" : "PIPE",
                            ClientApiIndex( ClientSession, ClientApi ),
                            Status ));
                }

                LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
                ClientApi->CaFlags &= ~(CA_BINDING_CACHED|CA_BINDING_AUTHENTICATED|CA_TCP_BINDING);
                NlGlobalBindingHandleCount --;
                UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
            } else {
                ClientApi->CaRpcHandle = ClientSession->CsUncServerName;
            }

        //
        // If this API call uses a local binding handle,
        //  create it.
        //
        } else {
            NetStatus = NlpSecureChannelBind(
                            ClientSession->CsUncServerName,
                            &ClientApi->CaRpcHandle );

            if ( NetStatus != NO_ERROR ) {
                Status = NetpApiStatusToNtStatus( NetStatus );

                NlPrintCs((NL_CRITICAL, ClientSession,
                        "NlStartApiClientSession: Bind to server %ws (%s) %ld failed 0x%lx.\n",
                        ClientSession->CsUncServerName,
                        RpcBindingType == UseTcpIp ? "TCP" : "PIPE",
                        ClientApiIndex( ClientSession, ClientApi ),
                        Status ));

                LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
                ClientApi->CaFlags &= ~(CA_BINDING_CACHED|CA_BINDING_AUTHENTICATED|CA_TCP_BINDING);
                NlGlobalBindingHandleCount --;
                UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
            } else {
                Status = STATUS_SUCCESS;
            }
        }

    }


    //
    // If we need to tell RPC to do authenticated RPC,
    //  do so now.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    if ( NT_SUCCESS(Status) && DoAuthenticatedRpc ) {

        NlPrintCs((NL_SESSION_MORE, ClientSession,
                "NlStartApiClientSession: Try to NlBindingSetAuthInfo\n" ));


        //
        // Build a generic client context for the security package
        //  if we don't have one already.
        //

        if ( ClientSession->ClientAuthData == NULL ) {
            ClientSession->ClientAuthData = NlBuildAuthData( ClientSession );
            if ( ClientSession->ClientAuthData == NULL ) {
                Status = STATUS_NO_MEMORY;
            } else {
                SECURITY_STATUS SecStatus;
                TimeStamp DummyTimeStamp;

                //
                // Keep a reference count on the credentials handle associated with this
                //  auth data (by calling AcquireCredentialsHandle) to ensure that we use
                //  the same handle as long as the secure channel is up. This is a performance
                //  improvement since the RPC users of netlogon's SSPI will get the same handle
                //  for the same auth data thereby avoiding a new secure RPC connection setup.
                //
                SecStatus = AcquireCredentialsHandleW( NULL,
                                                       NULL,
                                                       SECPKG_CRED_OUTBOUND,
                                                       NULL,
                                                       ClientSession->ClientAuthData,
                                                       NULL,
                                                       NULL,
                                                       &ClientSession->CsCredHandle,
                                                       &DummyTimeStamp );
                if ( SecStatus != SEC_E_OK ) {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                               "NlStartApiClientSession: AcquireCredentialsHandleW failed 0x%lx\n",
                               SecStatus ));
                }
            }
        }

        if ( NT_SUCCESS(Status) ) {

            //
            // If this API uses the netapi32 binding handle,
            //  set the auth info there.
            //

            if ( !UseConcurrentRpc( ClientSession, ClientApi ) ) {

                Status = NlBindingSetAuthInfo (
                            ClientSession->CsUncServerName,
                            RpcBindingType,
                            NlGlobalParameters.SealSecureChannel,
                            ClientSession->ClientAuthData,
                            ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer ); // Server context

                if ( NT_SUCCESS(Status) ) {
                    ClientApi->CaFlags |= CA_BINDING_AUTHENTICATED;
                } else {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                            "NlStartApiClientSession: Cannot NlBindingSetAuthInfo: %lx\n",
                            Status ));
                }

            //
            // If this API call uses a local binding handle,
            //  Simply call RPC directly
            //
            } else {

                //
                // Tell RPC to start doing secure RPC
                //

                NetStatus = RpcBindingSetAuthInfoW(
                                    ClientApi->CaRpcHandle,
                                    ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer, // Server context
                                    NlGlobalParameters.SealSecureChannel ?
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY : RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                                    RPC_C_AUTHN_NETLOGON,   // Netlogon's own security package
                                    ClientSession->ClientAuthData,
                                    RPC_C_AUTHZ_NAME );

                if ( NetStatus == NO_ERROR ) {
                    ClientApi->CaFlags |= CA_BINDING_AUTHENTICATED;
                } else {

                    Status = NetpApiStatusToNtStatus( NetStatus );
                    NlPrintCs((NL_CRITICAL, ClientSession,
                            "NlStartApiClientSession: Cannot RpcBindingSetAuthInfoW: %ld\n",
                            NetStatus ));
                }

            }

        }

    }


    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

    return Status;

}


BOOLEAN
NlFinishApiClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN BOOLEAN OkToKillSession,
    IN BOOLEAN AmWriter,
    IN PCLIENT_API ClientApi
    )
/*++

Routine Description:

    Disable the timer for timing out the API call.

    Also, determine if it is time to pick a new DC since the current DC is
    reponding so poorly. The decision is made from the number of
    timeouts that happened during the last reauthentication time. If
    timeoutcount is more than the limit, it sets the connection status
    to CS_IDLE so that new DC will be picked up and new session will be
    established.

    On Entry,
        The trust list must NOT be locked.
        The caller must be a writer of the trust list entry.

Arguments:

    ClientSession - Structure used to define the session.

    OkToKillSession - TRUE if it's OK to actually drop the secure channel.
        Otherwise, this routine will simply return FALSE upon timeout and
        depend on the caller to drop the secure channel.

    AmWriter - TRUE if the caller is the writer of the client session.
        This should only be false for concurrent API calls where the caller
        could not re-establish writership after the API call completed.

    ClientApi - Specifies a pointer to the structure representing
        this API call.

Return Value:

    TRUE - API finished normally
    FALSE - API timed out AND the ClientSession structure was torn down.
        The caller shouldn't use the ClientSession structure without first
        setting up another session.  FALSE will only be return for a "quick"
        API call.

        FALSE does not imply that the API call failed.  It should only be used
        as an indication that the secure channel was torn down.

--*/
{
    BOOLEAN SessionOk = TRUE;
    TIMER ApiTimer;
    NTSTATUS Status;
    HANDLE NullToken = NULL;
    // NlAssert( ClientSession->CsUncServerName != NULL ); // Not true for concurrent RPC calls

    //
    // Grab a copy of the ApiTimer.
    //
    // Only a copy is needed and we don't want to keep the trust list locked
    // while locking NlGlobalDcDiscoveryCritSect (wrong locking order) nor while
    // freeing the session.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    ApiTimer = ClientApi->CaApiTimer;

    //
    // Turn off the timer for this API call.
    //

    ClientApi->CaApiTimer.Period = MAILSLOT_WAIT_FOREVER;

    //
    // If some other thread dropped the secure channel,
    //  it couldn't unbind this binding handle since we were using it.
    //
    // Unbind now.
    //

    NlAssert( ClientApi->CaFlags & CA_BINDING_CACHED );
    if ( !AmWriter ||
         ClientApi->CaSessionCount != ClientSession->CsSessionCount ) {

        if ( ClientApi->CaFlags & CA_BINDING_CACHED ) {
            NL_RPC_BINDING OldRpcBindingType;
            //
            // Indicate the handle is no longer cached.
            //

            OldRpcBindingType =
                (ClientApi->CaFlags & CA_TCP_BINDING) ? UseTcpIp : UseNamedPipe;

            ClientApi->CaFlags &= ~(CA_BINDING_CACHED|CA_BINDING_AUTHENTICATED|CA_TCP_BINDING);
            NlGlobalBindingHandleCount --;

            //
            // Save the server name but drop all our locks.
            //

            UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

            //
            // Unbind the handle
            //

            NlpSecureChannelUnbind(
                        ClientSession,
                        NULL,   // Server name not known
                        "NlFinishApiClientSession",
                        ClientApiIndex( ClientSession, ClientApi),
                        ClientApi->CaRpcHandle,
                        OldRpcBindingType );

            LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
        }
    }
    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );


    //
    // If this was a "quick" API call,
    //  and the API took too long,
    //  increment the count of times it timed out.
    //
    // Do this analysis only if this is not a BDC
    //  to PDC secure channel; there is only ONE
    //  PDC so don't attemp to find a "better" PDC
    //  in this case.
    //

    if ( ClientSession->CsSecureChannelType != ServerSecureChannel &&
         AmWriter &&
         ApiTimer.Period == NlGlobalParameters.ShortApiCallPeriod ) {

        //
        // If the API took really long,
        //  increment the count.
        //

        if( NetpLogonTimeHasElapsed(
                ApiTimer.StartTime,
                MAX_DC_API_TIMEOUT + NlGlobalParameters.ExpectedDialupDelay*1000 ) ) {

            //
            // API timeout.
            //

            ClientSession->CsTimeoutCount++;
            ClientSession->CsFastCallCount = 0;

            NlPrintCs((NL_CRITICAL, ClientSession,
                     "NlFinishApiClientSession: timeout call to %ws.  Count: %lu \n",
                     ClientSession->CsUncServerName,
                     ClientSession->CsTimeoutCount));

        //
        // If we've had at least one API that took really long in the past,
        //      try to determine if the performance it better now.
        //

        } else if ( ClientSession->CsTimeoutCount ) {

            //
            // If this call was really fast,
            //  count this call as an indication of better performance.
            //
            if( NetpLogonTimeHasElapsed(
                    ApiTimer.StartTime,
                    FAST_DC_API_TIMEOUT ) ) {

                //
                // If we've reached the threshold,
                //  decrement our timeout count.
                //

                ClientSession->CsFastCallCount++;

                if ( ClientSession->CsFastCallCount == FAST_DC_API_THRESHOLD ) {
                    ClientSession->CsTimeoutCount --;
                    ClientSession->CsFastCallCount = 0;

                    NlPrintCs((NL_CRITICAL, ClientSession,
                             "NlFinishApiClientSession: fast call threshold to %ws.  Count: %lu \n",
                             ClientSession->CsUncServerName,
                             ClientSession->CsTimeoutCount));
                } else {

                    NlPrintCs((NL_CRITICAL, ClientSession,
                             "NlFinishApiClientSession: fast call to %ws.  FastCount: %lu \n",
                             ClientSession->CsUncServerName,
                             ClientSession->CsFastCallCount ));
                }
            }

        }

        //
        // did we hit the limit ?
        //

        if( ClientSession->CsTimeoutCount >= MAX_DC_TIMEOUT_COUNT ) {

            BOOL IsTimeHasElapsed;

            //
            // block CsLastAuthenticationTry access
            //

            EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

            IsTimeHasElapsed = NetpLogonTimeHasElapsed(
                                    ClientSession->CsLastAuthenticationTry,
                                    MAX_DC_REAUTHENTICATION_WAIT );

            LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

            if( IsTimeHasElapsed ) {

                NlPrintCs((NL_CRITICAL, ClientSession,
                         "NlFinishApiClientSession: dropping the session to %ws\n",
                         ClientSession->CsUncServerName ));

                //
                // timeoutcount limit exceeded and it is time to reauth.
                //

                SessionOk = FALSE;

                //
                // Only drop the secure channel if the caller requested it.
                //

                if ( OkToKillSession ) {
                    NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );

#ifdef _DC_NETLOGON
                    //
                    // Start asynchronous DC discovery if this is not a workstation.
                    //

                    if ( !NlGlobalMemberWorkstation ) {
                        (VOID) NlDiscoverDc( ClientSession,
                                             DT_Asynchronous,
                                             FALSE,
                                             FALSE );  // don't specify account
                    }
#endif // _DC_NETLOGON
                }

            }
        }
    }

    //
    // If we didn't use concurrent RPC for this API call and the call
    // was made over named pipes, we impersonated this thread's token
    // as anonymous.  Revert this impersonation here to the default.
    // We set the impersonation to the default in any case just to be
    // safe.
    //

    //if ( !UseConcurrentRpc( ClientSession, ClientApi ) &&
    //     (ClientApi->CaFlags & CA_TCP_BINDING) == 0 ) {
    //    NTSTATUS Status;
    //    HANDLE NullToken = NULL;

        Status = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &NullToken,
                         sizeof(HANDLE) );

        if ( !NT_SUCCESS( Status)) {
             NlPrint(( NL_CRITICAL,
                       "NlFinishApiClientSession: cannot NtSetInformationThread: 0x%lx\n",
                       Status ));
        }
    //}


    return SessionOk;
}



BOOLEAN
NlTimeoutOneApiClientSession (
    PCLIENT_SESSION ClientSession
    )

/*++

Routine Description:

    Timeout any API calls active specified client session structure

Arguments:

    ClientSession: Pointer to client session to time out

    Enter with global trust list locked.

Return Value:

    TRUE - iff this routine temporarily dropped the global trust list lock.

--*/
{

    NET_API_STATUS NetStatus;
    BOOLEAN TrustListNowLocked = TRUE;
    BOOLEAN TrustListUnlockedOnce = FALSE;
    ULONG CaIndex;

    //
    // Ignore non-existent sessions.
    //

    if ( ClientSession == NULL ) {
        return FALSE;
    }

    //
    // Loop handling each API call active on this session
    //
    for ( CaIndex=0; CaIndex<NlGlobalMaxConcurrentApi; CaIndex++ ) {
        PCLIENT_API ClientApi;

        ClientApi = &ClientSession->CsClientApi[CaIndex];

        //
        // If an API call is in progress and has taken too long,
        //  Timeout the API call.
        //

        if ( NetpLogonTimeHasElapsed( ClientApi->CaApiTimer.StartTime,
                                      ClientApi->CaApiTimer.Period ) ) {


            //
            // Cancel the RPC call.
            //
            // Keep the trust list locked even though this will be a long call
            //  since I have to protect the thread handle.
            //
            // RpcCancelThread merely queues a workitem anyway.
            //

            if ( ClientApi->CaThreadHandle != NULL ) {
                LPWSTR MsgStrings[3];

                NlPrintCs(( NL_CRITICAL, ClientSession,
                       "NlTimeoutApiClientSession: Start RpcCancelThread on %ws\n",
                       ClientSession->CsUncServerName ));

                MsgStrings[0] = ClientSession->CsUncServerName;
                MsgStrings[1] = ClientSession->CsDebugDomainName;
                MsgStrings[2] = ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,

                NlpWriteEventlog( NELOG_NetlogonRpcCallCancelled,
                                  EVENTLOG_ERROR_TYPE,
                                  NULL,
                                  0,
                                  MsgStrings,
                                  3 );

                NetStatus = RpcCancelThread( ClientApi->CaThreadHandle );

                NlPrintCs(( NL_CRITICAL, ClientSession,
                       "NlTimeoutApiClientSession: Finish RpcCancelThread on %ws %ld\n",
                       ClientSession->CsUncServerName,
                       NetStatus ));
            } else {
                NlPrintCs(( NL_CRITICAL, ClientSession,
                            "NlTimeoutApiClientSession: No thread handle so can't cancel RPC on %ws\n",
                            ClientSession->CsUncServerName ));
            }



        //
        // If the API is not active,
        //  and we have an RPC binding handle cached,
        //  and it has outlived its usefulness,
        //  purge it from the cache.
        //

        } else if ( !IsApiActive(ClientApi) &&
                    (ClientApi->CaFlags & CA_BINDING_CACHED) != 0 &&
                    NetpLogonTimeHasElapsed( ClientApi->CaApiTimer.StartTime,
                                      BINDING_CACHE_PERIOD ) ) {


            //
            // We must be a writer of the Client Session to unbind the RPC binding
            //  handle.
            //
            // Don't wait to become the writer because:
            //  A) We've violated the locking order by trying to become the writer
            //     with the trust list locked.
            //  B) The writer might be doing a long API call like replication and
            //     we're not willing to wait.
            //

            NlRefClientSession( ClientSession );
            if ( NlTimeoutSetWriterClientSession( ClientSession, 0 ) ) {

                //
                // Check again now that we have the lock locked.
                //

                if ( (ClientApi->CaFlags & CA_BINDING_CACHED) != 0 ) {
                    NL_RPC_BINDING OldRpcBindingType;

                    //
                    // Indicate the handle is no longer cached.
                    //

                    OldRpcBindingType =
                        (ClientApi->CaFlags & CA_TCP_BINDING) ? UseTcpIp : UseNamedPipe;

                    ClientApi->CaFlags &= ~(CA_BINDING_CACHED|CA_BINDING_AUTHENTICATED|CA_TCP_BINDING);
                    NlGlobalBindingHandleCount --;

                    //
                    // Save the server name but drop all our locks.
                    //

                    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
                    TrustListNowLocked = FALSE;
                    TrustListUnlockedOnce = TRUE;

                    //
                    // Unbind the handle
                    //

                    NlpSecureChannelUnbind(
                                ClientSession,
                                ClientSession->CsUncServerName,
                                "NlTimeoutApiClientSession",
                                CaIndex,
                                ClientApi->CaRpcHandle,
                                OldRpcBindingType );

                }

                //
                // Done being a writer of the client session
                //

                NlResetWriterClientSession( ClientSession );
            }
            NlUnrefClientSession( ClientSession );
        }

        if ( !TrustListNowLocked ) {
            LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
            TrustListNowLocked = TRUE;
        }

    }

    NlAssert( TrustListNowLocked );
    return TrustListUnlockedOnce;
}


VOID
NlTimeoutApiClientSession(
    IN PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Timeout any API calls active on any of the client session structures

Arguments:

    DomainInfo - Hosted domain to timeout APIs for

Return Value:

    None

--*/
{
    PCLIENT_SESSION ClientSession;
    PLIST_ENTRY ListEntry;

    //
    // If there are no API calls outstanding,
    //  just reset the global timer.
    //

    NlPrintDom(( NL_SESSION_MORE, DomainInfo,
              "NlTimeoutApiClientSession Called\n"));

    LOCK_TRUST_LIST( DomainInfo );

    if ( NlGlobalBindingHandleCount == 0 ) {
        NlGlobalApiTimer.Period = (DWORD) MAILSLOT_WAIT_FOREVER;


    //
    // If there are API calls outstanding,
    //   Loop through the trust list making a list of Servers to kill
    //

    } else {


        //
        // Mark each trust list entry indicating it needs to be handled
        //

        for ( ListEntry = DomainInfo->DomTrustList.Flink ;
              ListEntry != &DomainInfo->DomTrustList ;
              ListEntry = ListEntry->Flink) {

            ClientSession = CONTAINING_RECORD( ListEntry,
                                               CLIENT_SESSION,
                                               CsNext );

            //
            // APIs are only outstanding to directly trusted domains.
            //
            if ( ClientSession->CsFlags & CS_DIRECT_TRUST ) {
                ClientSession->CsFlags |= CS_HANDLE_API_TIMER;
            }
        }


        //
        // Loop thru the trust list handling API timeout
        //

        for ( ListEntry = DomainInfo->DomTrustList.Flink ;
              ListEntry != &DomainInfo->DomTrustList ;
              ) {

            ClientSession = CONTAINING_RECORD( ListEntry,
                                               CLIENT_SESSION,
                                               CsNext );

            //
            // If we've already done this entry,
            //  skip this entry.
            //

            if ( (ClientSession->CsFlags & CS_HANDLE_API_TIMER) == 0 ) {
                ListEntry = ListEntry->Flink;
                continue;
            }
            ClientSession->CsFlags &= ~CS_HANDLE_API_TIMER;


            //
            // Handle timing out the API call and the RPC binding handle.
            //
            // If the routine had to drop the TrustList crit sect,
            //  start at the very beginning of the list.

            if ( NlTimeoutOneApiClientSession ( ClientSession ) ) {
                ListEntry = DomainInfo->DomTrustList.Flink;
            } else {
                ListEntry = ListEntry->Flink;
            }

        }

        //
        // Do the global client session, too.
        //

        if ( DomainInfo->DomRole != RolePrimary ) {
            ClientSession = NlRefDomClientSession( DomainInfo );
            if ( ClientSession != NULL ) {

                (VOID) NlTimeoutOneApiClientSession ( ClientSession );

                NlUnrefClientSession( ClientSession );
            }
        }


    }

    UNLOCK_TRUST_LIST( DomainInfo );
}


NTSTATUS
NetrEnumerateTrustedDomains (
    IN  LPWSTR   ServerName OPTIONAL,
    OUT PDOMAIN_NAME_BUFFER DomainNameBuffer
    )

/*++

Routine Description:

    This API returns the names of the domains trusted by the domain ServerName is a member of.

    The returned list does not include the domain ServerName is directly a member of.

    Netlogon implements this API by calling LsaEnumerateTrustedDomains on a DC in the
    domain ServerName is a member of.  However, Netlogon returns cached information if
    it has been less than 5 minutes since the last call was made or if no DC is available.
    Netlogon's cache of Trusted domain names is maintained in the registry across reboots.
    As such, the list is available upon boot even if no DC is available.


Arguments:

    ServerName - name of remote server (null for local).  ServerName must be an NT workstation
        or NT non-DC server.

    DomainNameBuffer->DomainNames - Returns an allocated buffer containing the list of trusted domains in
        MULTI-SZ format (i.e., each string is terminated by a zero character, the next string
        immediately follows, the sequence is terminated by zero length domain name).  The
        buffer should be freed using NetApiBufferFree.

    DomainNameBuffer->DomainNameByteCount - Number of bytes returned in DomainNames

Return Value:


    ERROR_SUCCESS - Success.

    STATUS_NOT_SUPPORTED - This machine is not an NT workstation or NT non-DC server.

    STATUS_NO_LOGON_SERVERS - No DC could be found and no cached information is available.

    STATUS_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken and no cached information is available.

    STATUS_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken and no cached information is available.

--*/
{
    NET_API_STATUS NetStatus;

    NETLOGON_TRUSTED_DOMAIN_ARRAY Domains = {0};
    LPWSTR CurrentLoc;
    ULONG i;

    ULONG BufferLength;
    LPWSTR TrustedDomainList = NULL;

    //
    // Call the new-fangled routine to do the actual work.
    //

    NetStatus = NetrEnumerateTrustedDomainsEx (
                    ServerName,
                    &Domains );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Walk through the returned list an convert it to the proper form
    //

    BufferLength = sizeof(WCHAR);

    for ( i=0; i<Domains.DomainCount; i++ ) {
        if ( Domains.Domains[i].NetbiosDomainName != NULL ) {
            BufferLength += (wcslen(Domains.Domains[i].NetbiosDomainName)+1) * sizeof(WCHAR);
        }
    }

    TrustedDomainList = (LPWSTR) NetpMemoryAllocate( BufferLength );

    if (TrustedDomainList == NULL) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Now add all the trusted domains onto the string we allocated
    //

    *TrustedDomainList = L'\0';
    CurrentLoc = TrustedDomainList;

    for ( i=0; i<Domains.DomainCount; i++ ) {

        //
        // Skip domains not understood by the old API.
        //
        if ( Domains.Domains[i].NetbiosDomainName != NULL &&
             (Domains.Domains[i].Flags & DS_DOMAIN_PRIMARY) == 0 &&
             (Domains.Domains[i].TrustType == TRUST_TYPE_UPLEVEL ||
              Domains.Domains[i].TrustType == TRUST_TYPE_DOWNLEVEL ) ) {
            ULONG StringLength =
                wcslen(Domains.Domains[i].NetbiosDomainName);

            RtlCopyMemory(
                CurrentLoc,
                Domains.Domains[i].NetbiosDomainName,
                StringLength * sizeof(WCHAR) );

            CurrentLoc += StringLength;

            *(CurrentLoc++) = L'\0';
            *CurrentLoc = L'\0';    // Place double terminator each time
        }

    }

    NetStatus = NO_ERROR;


    //
    // Free any locally used resources.
    //
Cleanup:

    //
    // Return the DCName to the caller.
    //

    if ( NetStatus == NO_ERROR ) {
        DomainNameBuffer->DomainNameByteCount = NetpTStrArraySize( TrustedDomainList );
        DomainNameBuffer->DomainNames = (LPBYTE) TrustedDomainList;
    } else {
        if ( TrustedDomainList != NULL ) {
            NetApiBufferFree( TrustedDomainList );
        }
        DomainNameBuffer->DomainNameByteCount = 0;
        DomainNameBuffer->DomainNames = NULL;
    }

    if ( Domains.Domains != NULL ) {
        MIDL_user_free( Domains.Domains );
    }

    return NetpApiStatusToNtStatus( NetStatus );

UNREFERENCED_PARAMETER( ServerName );
}



NET_API_STATUS
NlpEnumerateDomainTrusts (
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG Flags,
    OUT PULONG RetForestTrustListCount,
    OUT PDS_DOMAIN_TRUSTSW *RetForestTrustList
    )

/*++

Routine Description:

    This API returns the names of the domains trusting/trusted by the domain ServerName
    is a member of.

    This is the worker routine for getting the cached domain trusts list from a DC.


Arguments:

    DomainInfo - Hosted domain that this call pertains to

    Flags - Specifies attributes of trusts which should be returned. These are the flags
        of the DS_DOMAIN_TRUSTSW structure.  If a trust entry has any of the bits specified
        in Flags set, it will be returned.

    RetForestTrustListCount - Returns the number of entries in RetForestTrustList.

    RetForestTrustList - Returns an array of domains.
        The caller should free this array using MIDL_user_free.

Return Value:


    NO_ERROR - Success.

    ERROR_NO_LOGON_SERVERS - No DC could be found and no cached information is available.

    ERROR_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken and no cached information is available.

    ERROR_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken and no cached information is available.

    ERROR_INVALID_FLAGS - The Flags parameter has invalid bits set.

--*/
{
    NET_API_STATUS NetStatus;

    PDS_DOMAIN_TRUSTSW ForestTrustList = NULL;
    ULONG ForestTrustListCount = 0;
    ULONG ForestTrustListSize;
    LPBYTE Where;
    ULONG Index;
    DWORD WaitResult;
    PULONG IndexInReturnedList = NULL;


    //
    // Wait until the updated trust info is available or we are signaled to
    // terminate.
    //

    HANDLE Waits[2];
    Waits[0] = NlGlobalTrustInfoUpToDateEvent;
    Waits[1] = NlGlobalTerminateEvent;

    for ( ;; ) {

        WaitResult = WaitForMultipleObjects( 2,  // # of events to wait for
                                Waits,           // array of event handles
                                FALSE,           // wait for all objects ?
                                20000 );         // wait for 20 seconds max

        //
        // The TrustInfoUpToDate event is set before the trust info gets actually
        // updated, so try to lock DomainInfo here -- you will succeed only after
        // the trust info gets updated at which time the lock has been released.
        //
        LOCK_TRUST_LIST( DomainInfo );

        //
        // If we got a timeout or some kind of error occured, we've done our best to
        // get the updated data but the data is still old.  We are going to return
        // the old data. Also, break out of the loop if we are said to terminate.
        //
        if ( WaitResult != WAIT_OBJECT_0 ) {
            NlPrint((NL_MISC,
               "NlpEnumerateDomainTrusts: Can't get updated Domain List from cache.\n"));
            break;
        }

        //
        // Check if the event is still set; it may be reset by another LSA call between
        // the time the event was set last time and the trust info got updated or by
        // the NlInitTrustList function itself if there was an error.
        //

        WaitResult = WaitForSingleObject( NlGlobalTrustInfoUpToDateEvent, 0 );

        if ( WaitResult == WAIT_OBJECT_0 || WaitResult == WAIT_FAILED ) {
            break;
        } else {
            NlPrint((NL_MISC,
               "NlpEnumerateDomainTrusts: NlGlobalTrustInfoUpToDateEvent has been reset.\n" ));
        }
        UNLOCK_TRUST_LIST( DomainInfo );

    }

    //
    // Return the information from the cache
    //

    if ( DomainInfo->DomForestTrustListSize ) {
        ULONG VariableSize;

        //
        // Compute the size of the trusted/trusting domain list.
        //

        ForestTrustListSize = 0;
        ForestTrustListCount = 0;
        for ( Index=0; Index<DomainInfo->DomForestTrustListCount; Index++ ) {
            if ( DomainInfo->DomForestTrustList[Index].Flags & Flags ) {
                VariableSize = 0;
                if ( DomainInfo->DomForestTrustList[Index].DnsDomainName != NULL ) {
                    VariableSize +=
                        (wcslen( DomainInfo->DomForestTrustList[Index].DnsDomainName ) + 1) * sizeof(WCHAR);
                }
                if ( DomainInfo->DomForestTrustList[Index].NetbiosDomainName != NULL ) {
                    VariableSize +=
                        (wcslen( DomainInfo->DomForestTrustList[Index].NetbiosDomainName ) + 1) * sizeof(WCHAR);
                }
                if ( DomainInfo->DomForestTrustList[Index].DomainSid != NULL  ) {
                    VariableSize +=
                        RtlLengthSid( DomainInfo->DomForestTrustList[Index].DomainSid );
                }
                VariableSize = ROUND_UP_COUNT( VariableSize, ALIGN_DWORD );
                ForestTrustListSize += ( VariableSize + sizeof(DS_DOMAIN_TRUSTSW) );
                ForestTrustListCount++;
            }
        }

        if ( ForestTrustListSize == 0 ) {
            NetStatus = NO_ERROR;
            UNLOCK_TRUST_LIST( DomainInfo );
            goto Cleanup;
        }

        ForestTrustList = (PDS_DOMAIN_TRUSTSW) NetpMemoryAllocate( ForestTrustListSize );

        if (ForestTrustList == NULL) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            UNLOCK_TRUST_LIST( DomainInfo );
            goto Cleanup;
        }

        //
        // If domains in the forest are requested,
        // allocate an array of ULONGs that will be used to keep track of the
        // index of a trust entry in the returned list.  This is needed to
        // corectly set ParentIndex for entries returned.
        //

        if ( Flags & DS_DOMAIN_IN_FOREST ) {
            IndexInReturnedList = LocalAlloc( LMEM_ZEROINIT,
                                        DomainInfo->DomForestTrustListCount * sizeof(ULONG) );

            if ( IndexInReturnedList == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                UNLOCK_TRUST_LIST( DomainInfo );
                goto Cleanup;
            }
        }

        //
        // Now add all the trusted/trusting domains into the buffer we allocated
        //

        Where = (LPBYTE)&ForestTrustList[ForestTrustListCount];
        ForestTrustListCount = 0;

        for ( Index=0; Index<DomainInfo->DomForestTrustListCount; Index++ ) {

            //
            // Skip this entry if the caller doesn't need it
            //
            if ( (DomainInfo->DomForestTrustList[Index].Flags & Flags) == 0 ) {
                continue;
            }

            //
            // If domains in the forest are requested,
            // remember the index of this entry in the returned list
            //
            if ( Flags & DS_DOMAIN_IN_FOREST ) {
                IndexInReturnedList[Index] = ForestTrustListCount;
            }

            //
            // Fill in the fixed length data
            //

            ForestTrustList[ForestTrustListCount].Flags = DomainInfo->DomForestTrustList[Index].Flags;
            ForestTrustList[ForestTrustListCount].ParentIndex = DomainInfo->DomForestTrustList[Index].ParentIndex;
            ForestTrustList[ForestTrustListCount].TrustType = DomainInfo->DomForestTrustList[Index].TrustType;
            ForestTrustList[ForestTrustListCount].TrustAttributes = DomainInfo->DomForestTrustList[Index].TrustAttributes;
            ForestTrustList[ForestTrustListCount].DomainGuid = DomainInfo->DomForestTrustList[Index].DomainGuid;

            //
            // If this is a primary domain entry, determine whether it runs
            // in native or mixed mode
            //
            if ( (DomainInfo->DomForestTrustList[Index].Flags & DS_DOMAIN_PRIMARY) &&
                 !SamIMixedDomain( DomainInfo->DomSamServerHandle ) ) {
                ForestTrustList[ForestTrustListCount].Flags |= DS_DOMAIN_NATIVE_MODE;
            }

            //
            // Fill in the variable length data.
            //

            if ( DomainInfo->DomForestTrustList[Index].DomainSid != NULL ) {
                ULONG SidSize;
                ForestTrustList[ForestTrustListCount].DomainSid = (PSID) Where;
                SidSize = RtlLengthSid( DomainInfo->DomForestTrustList[Index].DomainSid );
                RtlCopyMemory( Where,
                               DomainInfo->DomForestTrustList[Index].DomainSid,
                               SidSize );
                Where += SidSize;
            } else {
                ForestTrustList[ForestTrustListCount].DomainSid = NULL;
            }

            if ( DomainInfo->DomForestTrustList[Index].NetbiosDomainName != NULL ) {
                ULONG StringSize;
                ForestTrustList[ForestTrustListCount].NetbiosDomainName = (LPWSTR)Where;
                StringSize = (wcslen( DomainInfo->DomForestTrustList[Index].NetbiosDomainName ) + 1) * sizeof(WCHAR);
                RtlCopyMemory( Where,
                               DomainInfo->DomForestTrustList[Index].NetbiosDomainName,
                               StringSize );

                Where += StringSize;
            } else {
                ForestTrustList[ForestTrustListCount].NetbiosDomainName = NULL;
            }

            if ( DomainInfo->DomForestTrustList[Index].DnsDomainName != NULL ) {
                ULONG StringSize;
                ForestTrustList[ForestTrustListCount].DnsDomainName = (LPWSTR)Where;
                StringSize = (wcslen( DomainInfo->DomForestTrustList[Index].DnsDomainName ) + 1) * sizeof(WCHAR);
                RtlCopyMemory( Where,
                               DomainInfo->DomForestTrustList[Index].DnsDomainName,
                               StringSize );

                Where += StringSize;
            } else {
                ForestTrustList[ForestTrustListCount].DnsDomainName = NULL;
            }

            Where = ROUND_UP_POINTER( Where, ALIGN_DWORD);
            ForestTrustListCount++;

        }

        //
        // Fix ParentIndex.  If domains in the forest are requested,
        // adjust the index to point to the appropriate entry in the
        // returned list.  Otherwise, set the index to 0.
        //

        if ( Flags & DS_DOMAIN_IN_FOREST ) {

            for ( Index=0; Index<ForestTrustListCount; Index++ ) {
                if ( (ForestTrustList[Index].Flags & DS_DOMAIN_IN_FOREST) != 0 &&
                     (ForestTrustList[Index].Flags & DS_DOMAIN_TREE_ROOT) == 0 ) {
                    ForestTrustList[Index].ParentIndex =
                        IndexInReturnedList[ForestTrustList[Index].ParentIndex];
                }
            }

        } else {

            for ( Index=0; Index<ForestTrustListCount; Index++ ) {
                ForestTrustList[Index].ParentIndex = 0;
            }
        }


    }
    UNLOCK_TRUST_LIST( DomainInfo );
    NetStatus = NO_ERROR;


    //
    // Free any locally used resources.
    //
Cleanup:

    if ( IndexInReturnedList != NULL ) {
        LocalFree( IndexInReturnedList );
    }

    //
    // Return the info to the caller.
    //

    if ( NetStatus == NO_ERROR ) {
        *RetForestTrustListCount = ForestTrustListCount;
        *RetForestTrustList = ForestTrustList;
    } else {
        if ( ForestTrustList != NULL ) {
            NetApiBufferFree( ForestTrustList );
        }
        *RetForestTrustListCount = 0;
        *RetForestTrustList = NULL;
    }

    return NetStatus;

}


NET_API_STATUS
DsrEnumerateDomainTrusts (
    IN  LPWSTR   ServerName OPTIONAL,
    IN  ULONG    Flags,
    OUT PNETLOGON_TRUSTED_DOMAIN_ARRAY Domains
    )

/*++

Routine Description:

    This API returns the names of the domains trusting/trusted by the domain ServerName
    is a member of.

    Netlogon's cache of Trusted domain names is maintained in a file across reboots.
    As such, the list is available upon boot even if no DC is available.


Arguments:

    ServerName - name of remote server (null for local).  ServerName must be an NT workstation
        or NT non-DC server.

    Flags - Specifies attributes of trusts which should be returned. These are the flags
        of the DS_DOMAIN_TRUSTSW strusture.  If a trust entry has any of the bits specified
        in Flags set, it will be returned.

    Domains - Returns an array of trusted domains.

Return Value:


    NO_ERROR - Success.

    ERROR_NO_LOGON_SERVERS - No DC could be found and no cached information is available.

    ERROR_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken and no cached information is available.

    ERROR_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken and no cached information is available.

    ERROR_INVALID_FLAGS - The Flags parameter has invalid bits set.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PCLIENT_SESSION ClientSession = NULL;
    BOOLEAN FirstTry = TRUE;

    PDOMAIN_INFO DomainInfo = NULL;

    PDS_DOMAIN_TRUSTSW ForestTrustList = NULL;
    ULONG ForestTrustListCount = 0;
    ULONG ForestTrustListSize;

    NlPrint((NL_MISC,
        "DsrEnumerateDomainTrusts: Called, Flags = 0x%lx\n", Flags ));

    //
    // Validate the parameter
    //

    if ( Domains == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate the Flags parameter
    //

    if ( (Flags & DS_DOMAIN_VALID_FLAGS) == 0 ||
         (Flags & ~DS_DOMAIN_VALID_FLAGS) != 0 ) {
        NlPrint((NL_CRITICAL,
           "DsrEnumerateDomainTrusts: Invalid Flags parameter: 0x%lx\n", Flags ));
        NetStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // Find the referenced domain

    DomainInfo = NlFindDomainByServerName( ServerName );    // Primary domain

    if ( DomainInfo == NULL ) {
        // Default to primary domain to handle the case where the ComputerName
        // is an IP address.

        DomainInfo = NlFindNetbiosDomain( NULL, TRUE );

        if ( DomainInfo == NULL ) {
            NetStatus = ERROR_INVALID_COMPUTERNAME;
            goto Cleanup;
        }
    }


    //
    // On workstations,
    //  Refresh the cache periodically
    //

    NetStatus = NO_ERROR;
    if ( NlGlobalMemberWorkstation ) {

        ClientSession = NlRefDomClientSession(DomainInfo);

        if ( ClientSession == NULL ) {
            NetStatus = ERROR_INVALID_COMPUTERNAME;
        } else {
            //
            // Become a writer of the client session.
            //

            if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
                NlPrint((NL_CRITICAL, "DsrEnumerateDomainTrusts: Can't become writer of client session.\n" ));
                NetStatus = ERROR_NO_LOGON_SERVERS;

            } else {

                //
                // If the session isn't authenticated,
                //  do so now.
                //

FirstTryFailed:
                Status = NlEnsureSessionAuthenticated( ClientSession, 0 );

                if ( !NT_SUCCESS(Status) ) {
                    NetStatus = NetpNtStatusToApiStatus( Status );
                } else {


                    //
                    // If it has been more than 5 minutes since we've refreshed our cache,
                    //  get a new list from our primary domain.
                    //

                    if ( NetpLogonTimeHasElapsed( NlGlobalTrustedDomainListTime, 5 * 60 * 1000 ) ) {
                        NlPrintCs((NL_MISC, ClientSession,
                            "DsrEnumerateDomainTrusts: Domain List collected from %ws\n",
                            ClientSession->CsUncServerName ));

                        NlAssert( ClientSession->CsUncServerName != NULL );
                        Status = NlUpdateDomainInfo ( ClientSession );

                        if ( !NT_SUCCESS(Status) ) {

                            NlSetStatusClientSession( ClientSession, Status );

                            if ( Status == STATUS_ACCESS_DENIED ) {

                                //
                                // Perhaps the netlogon service on the server has just restarted.
                                //  Try just once to set up a session to the server again.
                                //
                                if ( FirstTry ) {
                                    FirstTry = FALSE;
                                    goto FirstTryFailed;
                                }
                            }
                            NetStatus = NetpNtStatusToApiStatus( Status );
                        }
                    }
                }

                //
                // Read the list from cache even if you failed to get a fresh copy from a DC.
                // Read it while holding the write lock to avoid concurrent reading/writing
                // problems.
                //

                NetStatus = NlReadFileTrustedDomainList (
                                DomainInfo,
                                NL_FOREST_BINARY_LOG_FILE,
                                FALSE,  // Don't delete (Save it for the next boot)
                                Flags,
                                &ForestTrustList,
                                &ForestTrustListSize,
                                &ForestTrustListCount );

                if ( NetStatus != NO_ERROR ) {
                    NlPrint((NL_CRITICAL,
                        "DsrEnumerateDomainTrusts: Can't get Domain List from cache: 0x%lX\n",
                        NetStatus ));
                    NetStatus = ERROR_NO_LOGON_SERVERS;
                }

                NlResetWriterClientSession( ClientSession );
            }

            NlUnrefClientSession( ClientSession );
        }

    //
    // On non-workstations,
    //  grab the trusted domain list from the in-memory list.
    //
    } else {


        //
        // Call the worker routine to get the list.
        //

        NetStatus = NlpEnumerateDomainTrusts (
                                    DomainInfo,
                                    Flags,
                                    &ForestTrustListCount,
                                    &ForestTrustList );
    }


    //
    // Free any locally used resources.
    //
Cleanup:

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    //
    // Return the DCName to the caller.
    //

    if ( NetStatus == NO_ERROR ) {
        Domains->DomainCount = ForestTrustListCount;
        Domains->Domains = ForestTrustList;
    } else {
        if ( ForestTrustList != NULL ) {
            NetApiBufferFree( ForestTrustList );
        }
        Domains->DomainCount = 0;
        Domains->Domains = NULL;
    }

    NlPrint((NL_MISC,
        "DsrEnumerateDomainTrusts: returns: %ld\n",
        NetStatus ));
    return NetStatus;

}


NET_API_STATUS
NetrEnumerateTrustedDomainsEx (
    IN  LPWSTR   ServerName OPTIONAL,
    OUT PNETLOGON_TRUSTED_DOMAIN_ARRAY Domains
    )

/*++

Routine Description:

    This API returns the names of the domains trusted by the domain ServerName
    is a member of.

    Netlogon's cache of Trusted domain names is maintained in a file across reboots.
    As such, the list is available upon boot even if no DC is available.


Arguments:

    ServerName - name of remote server (null for local).  ServerName must be an NT workstation
        or NT non-DC server.

    Domains - Returns an array of trusted domains.

Return Value:


    NO_ERROR - Success.

    ERROR_NO_LOGON_SERVERS - No DC could be found and no cached information is available.

    ERROR_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken and no cached information is available.

    ERROR_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken and no cached information is available.

--*/
{
    NET_API_STATUS NetStatus;
    ULONG Index;

    NlPrint((NL_MISC,
        "NetrEnumerateTrustedDomains: Called.\n" ));

    NetStatus = DsrEnumerateDomainTrusts( ServerName,
                                          DS_DOMAIN_IN_FOREST |
                                            DS_DOMAIN_DIRECT_OUTBOUND |
                                            DS_DOMAIN_PRIMARY,
                                          Domains );
    //
    // Do not leak the new DS_DOMAIN_DIRECT_INBOUND bit to the caller of this old
    // API; the caller can get confused otherwise.  The new DS_DOMAIN_DIRECT_OUTBOUND
    // bit is just the renamed old DS_DOMAIN_DIRECT_TRUST, so leave it alone.
    //

    if ( NetStatus == NO_ERROR ) {
        for ( Index = 0; Index < Domains->DomainCount; Index++ ) {
            Domains->Domains[Index].Flags &= ~DS_DOMAIN_DIRECT_INBOUND;
        }
    }

    return NetStatus;
}

NTSTATUS
I_NetLogonMixedDomain(
    OUT PBOOL MixedMode
    )

/*++

Routine Description:

    This routine is provided for in-proc callers on workstations
    to determine whether the workstaion's domain is running in mixed
    mode. This is a quick routine that returns the state of a global
    boolean. The boolean is set on boot from the cached domain trust
    info and it's updated on domain trust refreshes.

    If the machine is a DC, this routine returns the authoritative
    answer by calling SamIMixedDomain.

Arguments:

    MixedMode - Returns TRUE/FALSE if the domain is mixed/native mode

Return Value:

    STATUS_SUCCESS - The operation was successful

    STATUS_NETLOGON_NOT_STARTED - Netlogon hasn't started yet

--*/
{
    //
    // If caller is calling when the netlogon service hasn't started yet,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }

    if ( NlGlobalMemberWorkstation ) {
        *MixedMode = NlGlobalWorkstationMixedModeDomain;
    } else {
        *MixedMode = SamIMixedDomain( NlGlobalDomainInfo->DomSamServerHandle );
    }

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\tests\fttest.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fttest.c

Abstract:

    Component test for Ds*ForestTrustInformation API

Author:

    Cliff Van Dyke       (CliffV)    August 11, 2000

Environment:

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
// #include <wincred.h>
// #include <credp.h>
#include <stdio.h>
#include <stdlib.h>
// #include <winnetwk.h>

#include <lmcons.h>
#include <lmerr.h>
#include <ntlsa.h>
#include <dsgetdc.h>
#include <ntstatus.dbg>
#include <winerror.dbg>


VOID
NlpDumpSid(
    IN DWORD DebugFlag,
    IN PSID Sid OPTIONAL
    )
/*++

Routine Description:

    Dumps a SID to the debugger output

Arguments:

    DebugFlag - Debug flag to pass on to NlPrintRoutine

    Sid - SID to output

Return Value:

    none

--*/
{

    //
    // Output the SID
    //

    if ( Sid == NULL ) {
        printf( "(null)\n");
    } else {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Invalid 0x%lX\n", Status );
        } else {
            printf( "%wZ\n", &SidString );
            RtlFreeUnicodeString( &SidString );
        }
    }

    UNREFERENCED_PARAMETER( DebugFlag );
}



VOID
PrintTime(
    LPSTR Comment,
    LARGE_INTEGER ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - GMT time to print (Nothing is printed if this is zero)

Return Value:

    None

--*/
{
    //
    // If we've been asked to convert an NT GMT time to ascii,
    //  Do so
    //

    if ( ConvertTime.QuadPart != 0 ) {
        LARGE_INTEGER LocalTime;
        TIME_FIELDS TimeFields;
        NTSTATUS Status;

        printf( "%s", Comment );

        Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
        if ( !NT_SUCCESS( Status )) {
            printf( "Can't convert time from GMT to Local time\n" );
            LocalTime = ConvertTime;
        }

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%8.8lx %8.8lx = %ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                ConvertTime.LowPart,
                ConvertTime.HighPart,
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }
}

LPSTR
FindSymbolicNameForStatus(
    DWORD Id
    )
{
    ULONG i;

    i = 0;
    if (Id == 0) {
        return "STATUS_SUCCESS";
    }

    if (Id & 0xC0000000) {
        while (ntstatusSymbolicNames[ i ].SymbolicName) {
            if (ntstatusSymbolicNames[ i ].MessageId == (NTSTATUS)Id) {
                return ntstatusSymbolicNames[ i ].SymbolicName;
            } else {
                i += 1;
            }
        }
    }

    while (winerrorSymbolicNames[ i ].SymbolicName) {
        if (winerrorSymbolicNames[ i ].MessageId == Id) {
            return winerrorSymbolicNames[ i ].SymbolicName;
        } else {
            i += 1;
        }
    }

#ifdef notdef
    while (neteventSymbolicNames[ i ].SymbolicName) {
        if (neteventSymbolicNames[ i ].MessageId == Id) {
            return neteventSymbolicNames[ i ].SymbolicName
        } else {
            i += 1;
        }
    }
#endif // notdef

    return NULL;
}


VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case NERR_UserNotFound:
        printf( " NERR_UserNotFound" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    default:
        printf( " %s", FindSymbolicNameForStatus( NetStatus ) );
        break;

    }

    printf( "\n" );
}

VOID
DumpFtinfo(
    PLSA_FOREST_TRUST_INFORMATION Ftinfo
    )
/*++
Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
    ULONG Index;

    if ( Ftinfo == NULL ) {
        printf( "    (null)\n");
    } else {

        for ( Index=0; Index<Ftinfo->RecordCount; Index++ ) {

            switch ( Ftinfo->Entries[Index]->ForestTrustType ) {
            case ForestTrustTopLevelName:
                printf( "    TLN: %wZ",
                        &Ftinfo->Entries[Index]->ForestTrustData.TopLevelName );
                break;
            case ForestTrustTopLevelNameEx:
                printf( "    TEX: %wZ",
                        &Ftinfo->Entries[Index]->ForestTrustData.TopLevelName );
                break;
            case ForestTrustDomainInfo:
                printf( "    Dom: %wZ (%wZ)",
                        &Ftinfo->Entries[Index]->ForestTrustData.DomainInfo.DnsName,
                        &Ftinfo->Entries[Index]->ForestTrustData.DomainInfo.NetbiosName );
                break;
            default:
                printf( "    Invalid Type: %ld", Ftinfo->Entries[Index]->ForestTrustType );
            }

            if ( Ftinfo->Entries[Index]->Flags ) {
                ULONG Flags = Ftinfo->Entries[Index]->Flags;

                printf(" (" );
#define DoFlag( _flag, _text ) \
                if ( Flags & _flag ) { \
                    printf( _text ); \
                    Flags &= ~_flag; \
                }

                switch ( Ftinfo->Entries[Index]->ForestTrustType ) {
                case ForestTrustTopLevelName:
                case ForestTrustTopLevelNameEx:

                    DoFlag( LSA_TLN_DISABLED_NEW, " TlnNew" );
                    DoFlag( LSA_TLN_DISABLED_ADMIN, " TlnAdmin" );
                    DoFlag( LSA_TLN_DISABLED_CONFLICT, " TlnConflict" );
                }

                switch ( Ftinfo->Entries[Index]->ForestTrustType ) {
                case ForestTrustDomainInfo:
                    DoFlag( LSA_SID_DISABLED_ADMIN, " SidAdmin" );
                    DoFlag( LSA_SID_DISABLED_CONFLICT, " SidConflict" );

                    DoFlag( LSA_NB_DISABLED_ADMIN, " NbAdmin" );
                    DoFlag( LSA_NB_DISABLED_CONFLICT, " NbConflict" );
                }

                if ( Flags != 0 ) {
                    printf(" 0x%lX", Flags);
                }

                printf(")" );

            }

            switch ( Ftinfo->Entries[Index]->ForestTrustType ) {
            case ForestTrustDomainInfo:
                printf(" ");
                NlpDumpSid( 0, Ftinfo->Entries[Index]->ForestTrustData.DomainInfo.Sid );
                break;
            default:
                printf("\n");
                break;
            }
        }
    }

}

//
// Structure describing an Ftinfo entry
//

typedef struct _AN_ENTRY {
    ULONG Flags;
    LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType; // type of record
#define TLN ForestTrustTopLevelName
#define TLNEX ForestTrustTopLevelNameEx
#define  DOM ForestTrustDomainInfo
#define EOD (DOM+1)
    LPWSTR Name;
    PSID Sid;
    LPWSTR NetbiosName;
} AN_ENTRY, *PAN_ENTRY;

//
// Define template FTinfo structures.
//

AN_ENTRY Ftinfo0[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo1[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        TLN, L"ms.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo2[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        TLN, L"z.au" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo3[] = {
    { 0,        TLN, L"z.au" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo4[] = {
    { 0,        TLN, L"corp.acme.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo5[] = {
    { 0,        TLN, L"x.corp.acme.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo6[] = {
    { 0,        TLN, L"acme.com" },
    { LSA_TLN_DISABLED_ADMIN,        TLN, L"ms.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo7[] = {
    { 0,        TLN, L"acme.com" },
    { 0xFFFFFFFF, TLN, L"ms.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo8[] = {
    { 0,        TLN, L"acme.com" },
    { LSA_TLN_DISABLED_ADMIN, TLN, L"ms.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo9[] = {
    { 0,        TLN, L"acme.com" },
    { LSA_TLN_DISABLED_ADMIN, TLN, L"b.a.ms.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo10[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        TLN, L"a.ms.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo11[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        TLNEX, L"a.acme.com" },
    { 0,        EOD },
};

SID Sid1 = { 1, 1, SECURITY_NT_AUTHORITY, 1 };
SID Sid2 = { 1, 1, SECURITY_NT_AUTHORITY, 2 };
SID Sid3 = { 1, 1, SECURITY_NT_AUTHORITY, 3 };
SID Sid4 = { 1, 1, SECURITY_NT_AUTHORITY, 4 };
SID Sid5 = { 1, 1, SECURITY_NT_AUTHORITY, 5 };

AN_ENTRY Ftinfo12[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com", &Sid1, L"CORP_NB" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo13[] = {
    { 0,        TLN, L"acme.com" },
    { LSA_SID_DISABLED_ADMIN, DOM, L"corp.acme.com", &Sid1, L"CORP_NB" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo13a[] = {
    { 0,        TLN, L"acme.com" },
    { 0xFFFFFFFF, DOM, L"corp.acme.com", &Sid1, L"CORP_NB" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo14[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        TLN, L"acme.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo15[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        TLN, L"a.acme.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo16[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        TLN, L"acme.com" },
    { 0,        TLN, L"a.acme.com" },
    { 0,        TLN, L"b.acme.com" },
    { 0,        TLN, L"ms.com" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo17[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB2" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo18[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid1, L"CORP_NB2" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo19[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid1, L"CORP_NB2" },
    { 0,        DOM, L"c3.corp.acme.com", &Sid1, L"CORP_NB3" },
    { 0,        DOM, L"c4.corp.acme.com", &Sid1, L"CORP_NB4" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo20[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB2" },
    { 0,        DOM, L"c3.corp.acme.com", &Sid4, L"CORP_NB3" },
    { 0,        DOM, L"c4.corp.acme.com", &Sid5, L"CORP_NB4" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo21[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { LSA_SID_DISABLED_ADMIN, DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB2" },
    { LSA_SID_DISABLED_ADMIN, DOM, L"c3.corp.acme.com", &Sid4, L"CORP_NB3" },
    { 0,        DOM, L"c4.corp.acme.com", &Sid5, L"CORP_NB4" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo22[] = {
    { 0,        TLN, L"acme.com" },
    { LSA_SID_DISABLED_ADMIN, DOM, L"ms.com", &Sid1, L"CORP_NB" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo23[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.ms.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.ms.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.ms.com", &Sid3, L"CORP_NB2" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo24[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB2" },
    { 0,        DOM, L"c3.corp.acme.com", &Sid4, L"CORP_NB3" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo24a[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB2" },
    { 0,        DOM, L"c3.corp.acme.com", &Sid4, L"CORP_NB3" },
    { LSA_NB_DISABLED_ADMIN, DOM, L"c4.corp.acme.com", &Sid5, L"CORP_NB4" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo24b[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB2" },
    { 0,        DOM, L"c3.corp.acme.com", &Sid4, L"CORP_NB3" },
    { LSA_NB_DISABLED_CONFLICT, DOM, L"c4.corp.acme.com", &Sid5, L"CORP_NB4" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo24c[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB3" },
    { LSA_NB_DISABLED_ADMIN|LSA_NB_DISABLED_CONFLICT, DOM, L"c3.corp.acme.com", &Sid4, L"CORP_NB2" },
    { 0,        EOD },
};

AN_ENTRY Ftinfo24d[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB3" },
    { 0xFFFFFFFF, DOM, L"c3.corp.acme.com", &Sid4, L"CORP_NB2" },
    { 0,        EOD },
};
AN_ENTRY Ftinfo24e[] = {
    { 0,        TLN, L"acme.com" },
    { 0,        DOM, L"corp.acme.com",    &Sid1, L"CORP_NB0" },
    { 0,        DOM, L"c1.corp.acme.com", &Sid2, L"CORP_NB1" },
    { 0,        DOM, L"c2.corp.acme.com", &Sid3, L"CORP_NB3" },
    { 0,        DOM, L"c3.corp.acme.com", &Sid4, L"CORP_NB2" },
    { 0,        EOD },
};


//
// Structure describine test cases
//

typedef struct _TEST_CASE {
    PAN_ENTRY OldFtinfo;
#define PREVIOUS ((PAN_ENTRY) 1)
    PAN_ENTRY NewFtinfo;
    LPSTR Description;
} TEST_CASE, PTEST_CASE;

//
// Define the test cases
//

TEST_CASE TestCases[] = {
    { NULL,     Ftinfo0, "Just acme.com TLN" },
    { NULL,     Ftinfo1, "acme.com and ms.com TLN" },
    { NULL,     Ftinfo2, "Same but switch the alphabetical order" },
    { NULL,     Ftinfo3, "Have no TLN for the forest (Should fail w/ ERROR_INVALID_PARAMETER)" },
    { NULL,     Ftinfo0, "Build acme.com again" },
    { PREVIOUS, Ftinfo1, "Add a new ms.com TLN" },
    { PREVIOUS, Ftinfo1, "Ensure the new bit doesn't go away" },
    { NULL,     Ftinfo4, "Exact match on corp.acme.com TLN" },
    { NULL,     Ftinfo5, "Only child of corp.acme.com TLN (Should fail w/ ERROR_INVALID_PARAMETER)" },
    { Ftinfo6,  Ftinfo1, "Ensure a disabled TLN stays disabled" },
    { Ftinfo7,  Ftinfo1, "Ensure all bits are preserved in a TLN" },
    { Ftinfo8,  Ftinfo10, "Ensure a disabled TLN stays disabled in a child" },
    { Ftinfo9,  Ftinfo10, "Ensure a disabled TLN does *not* disable a parent" },
    { NULL,     Ftinfo11, "Ensure a TLNEX is ignored in new" },
    { Ftinfo11, Ftinfo0,  "Ensure a TLNEX is copied from old" },
    { NULL,     Ftinfo12, "Trivial single domain forest" },
    { Ftinfo13, Ftinfo12, "Ensure a disabled domain remains disabled" },
    { NULL,     Ftinfo14, "Drop duplicate new TLN entries" },
    { NULL,     Ftinfo15, "... even if the duplicate is subordinate" },
    { NULL,     Ftinfo16, "... even if there are many of them" },
    { NULL,     Ftinfo17, "Try multiple domain entries" },
    { NULL,     Ftinfo18, "Duplicate Sids are bad" },
    { NULL,     Ftinfo19, "... even if there are many of them" },
    { Ftinfo21, Ftinfo20, "Ensure multiple disabled domains remain disabled" },
    { Ftinfo13, Ftinfo0,  "Don't let an old disabled domain entry go away" },
    { Ftinfo22, Ftinfo0,  "... even if there's no TLN for the domain entry" },
    { Ftinfo17, Ftinfo20, "Add a new domain" },
    { Ftinfo20, Ftinfo17, "Delete old domains" },
    { NULL,     Ftinfo23, "Ensure there's a TLN for every domain" },
    { Ftinfo13a,Ftinfo12, "Ensure all of the possible flag bits are preserved" },
    { Ftinfo24a,Ftinfo24, "Ensure that a netbios admin disabled bit doesn't disappear" },
    { Ftinfo24b,Ftinfo24, "... but that a netbios conflict does" },
    { Ftinfo24c,Ftinfo24, "... Get it right even if the NB entry moves to different sid" },
    { Ftinfo24d,Ftinfo24, "... and that all of the other flag bits stay put" },
    { PREVIOUS, Ftinfo24e,"... and that we self repait when the trusted domain stops lying" },
};


PLSA_FOREST_TRUST_INFORMATION
BuildFtinfo(
    PAN_ENTRY AnEntry
    )
/*++
Routine Description:

    Builds a FtInfo array from the "easy to initialize" templates.

Arguments:

    AnEntry - Pointer to the first entry.

Return Value:

    Returns a real ftinfo array.
    If this weren't a cheesy test program, the caller should free this memory.

--*/
{
    PAN_ENTRY CurrentEntry;
    ULONG CurrentIndex;
    PLSA_FOREST_TRUST_INFORMATION Ftinfo;

    //
    // NULL is OK
    //

    if ( AnEntry == NULL ) {
        return NULL;
    }

    //
    // Allocate the return array
    //

    Ftinfo = LocalAlloc( 0, sizeof(*Ftinfo) );

    if ( Ftinfo == NULL ) {
        printf( "No memory\n");
        return NULL;
    }

    //
    // Count the number of entries
    //

    Ftinfo->RecordCount = 0;
    for ( CurrentEntry=AnEntry;
          CurrentEntry->ForestTrustType != EOD;
          CurrentEntry++ ) {

        Ftinfo->RecordCount ++;
    }

    //
    // Allocate the array of entry pointers.
    //

    Ftinfo->Entries = LocalAlloc( 0, sizeof(PLSA_FOREST_TRUST_RECORD) * Ftinfo->RecordCount );

    if ( Ftinfo->Entries == NULL ) {
        printf( "No memory\n");
        return NULL;
    }

    //
    // Loop through the entries.
    //

    CurrentIndex = 0;
    for ( CurrentEntry=AnEntry;
          CurrentEntry->ForestTrustType != EOD;
          CurrentEntry++ ) {

        //
        // Allocate the entry
        //

        Ftinfo->Entries[CurrentIndex] = LocalAlloc( LMEM_ZEROINIT, sizeof(LSA_FOREST_TRUST_RECORD) );

        if ( Ftinfo->Entries[CurrentIndex] == NULL ) {
            printf( "No memory\n");
            return NULL;
        }

        //
        // Fill it in
        //

        Ftinfo->Entries[CurrentIndex]->ForestTrustType = CurrentEntry->ForestTrustType;
        Ftinfo->Entries[CurrentIndex]->Flags = CurrentEntry->Flags;

        switch ( CurrentEntry->ForestTrustType ) {
        case TLN:
        case TLNEX:
            RtlInitUnicodeString(
                    &Ftinfo->Entries[CurrentIndex]->ForestTrustData.TopLevelName,
                    CurrentEntry->Name );
            break;
        case DOM:
            RtlInitUnicodeString(
                    &Ftinfo->Entries[CurrentIndex]->ForestTrustData.DomainInfo.DnsName,
                    CurrentEntry->Name );

            Ftinfo->Entries[CurrentIndex]->ForestTrustData.DomainInfo.Sid =
                    CurrentEntry->Sid;

            RtlInitUnicodeString(
                    &Ftinfo->Entries[CurrentIndex]->ForestTrustData.DomainInfo.NetbiosName,
                    CurrentEntry->NetbiosName );
            break;
        default:
            printf( "Bad forest trust type\n");
            return NULL;
        }

        CurrentIndex ++;
    }

    return Ftinfo;
}




int __cdecl
main (
    IN int argc,
    IN char ** argv
    )
{
    NET_API_STATUS NetStatus;
    PLSA_FOREST_TRUST_INFORMATION OldFtinfo;
    PLSA_FOREST_TRUST_INFORMATION NewFtinfo;
    PLSA_FOREST_TRUST_INFORMATION OutputFtinfo = NULL;
    ULONG CaseIndex;
    ULONG FirstIndex = 0;

    //
    // If an argument is specified,
    //  it is the test number to start with.
    //

    if ( argc > 1 ) {
        char *end;
        FirstIndex = strtoul( argv[1], &end, 10 );
    }

    //
    // Loop through the list of tests
    //

    for ( CaseIndex=FirstIndex; CaseIndex<(sizeof(TestCases)/sizeof(TestCases[0])); CaseIndex++ ) {


        printf( "\nCase %ld: %s\n", CaseIndex, TestCases[CaseIndex].Description );

        //
        // Build the test case FTINFO structures
        //

        if ( TestCases[CaseIndex].OldFtinfo == PREVIOUS ) {
            OldFtinfo = OutputFtinfo;
        } else {
            OldFtinfo = BuildFtinfo( TestCases[CaseIndex].OldFtinfo );
        }

        NewFtinfo = BuildFtinfo( TestCases[CaseIndex].NewFtinfo );

        //
        // Display them
        //

        printf("  Old Ftinfo:\n");
        DumpFtinfo( OldFtinfo );

        printf("  New Ftinfo:\n");
        DumpFtinfo( NewFtinfo );

        //
        // Merge them
        //

        NetStatus = DsMergeForestTrustInformationW( L"corp.acme.com",
                                                    NewFtinfo,
                                                    OldFtinfo,
                                                    &OutputFtinfo );

        if ( NetStatus != NERR_Success ) {
            printf( "DsMergeForestTrustInformationW failed: ");
            PrintStatus( NetStatus );
        } else {
            printf("  Result Ftinfo:\n");
            DumpFtinfo( OutputFtinfo );
        }

    }

    printf("\n\nYee haw.   We're done.\n");
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\ssiinit.h ===
/*++

Copyright (c) 1991-1996 Microsoft Corporation

Module Name:

    ssiinit.h

Abstract:

    Private global variables, defines, and routine declarations used for
    to implement SSI.

Author:

    Cliff Van Dyke (cliffv) 25-Jul-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

    04-10-1992 (madana)
        added support for LSA replication.

--*/

// general purpose mainfests
//
// Define UserAccountControl bit to indicate an NT 5.0 interdomain trust.
//
// This is not really a SAM account.  But UserAccountControl is used for all
// other trust types.
//
// Pick a bit that will never be used in the future to indicate a different
// account type.
//
#define USER_DNS_DOMAIN_TRUST_ACCOUNT USER_ACCOUNT_AUTO_LOCKED

//
// Maximum time we'll wait during full sync in an attempt to decrease
// wan link utilization.
//
#define MAX_SYNC_SLEEP_TIME      (60*60*1000)   // 1 hour


//
// How big a buffer we request on a SAM delta or a SAM sync.
//
#define SAM_DELTA_BUFFER_SIZE (128*1024)

//
// The size of the largest mailslot message.
//
// All mailslot messages we receive are broadcast.  The Win32 spec says
// the limit on broadcast mailslot is 400 bytes.  Really it is
// 444 bytes (512 minus SMB header etc) - size of the mailslot name.
// I'll use 444 to ensure this size is the largest I'll ever need.
//
// The NETLOGON_SAM_LOGON_RESPONSE_EX structure isn't packed into a mailslot
// packet so it may be larger.
//

#define NETLOGON_MAX_MS_SIZE max(444, sizeof(NETLOGON_SAM_LOGON_RESPONSE_EX))

//
// Structure describing a transport supported by redir/server and browser.
//
typedef struct _NL_TRANSPORT {
    //
    // List of all transports headed by NlTransportListHead.
    //  (Serialized by NlTransportCritSect)
    //

    LIST_ENTRY Next;

    //
    // True if the transport is currently enabled.
    //  We never delete a transport in order to avoid maintaining a reference count.
    //

    BOOLEAN TransportEnabled;

    //
    // True if transport is an IP transport.
    //

    BOOLEAN IsIpTransport;

    //
    // True if transport is direct host IPX transport
    //

    BOOLEAN DirectHostIpx;

    //
    // IP Address for this transport.
    //  Zero if not IP or none yet assigned.
    //

    ULONG IpAddress;

    //
    // Handle to the transport device
    //

    HANDLE DeviceHandle;

    //
    // Name of the transport.
    //

    WCHAR TransportName[1];


} NL_TRANSPORT, *PNL_TRANSPORT;


/////////////////////////////////////////////////////////////////////////////
//
// Client Session definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// An internal timer used to schedule a periodic event.
//

typedef struct _TIMER {
    LARGE_INTEGER StartTime; // Start of period (NT absolute time)
    DWORD Period;   // length of period (miliseconds)
#define TIMER_MAX_PERIOD (MAILSLOT_WAIT_FOREVER - 1)

} TIMER, *PTIMER;

#define NL_MILLISECONDS_PER_SECOND (1000)
#define NL_MILLISECONDS_PER_MINUTE (60 * NL_MILLISECONDS_PER_SECOND)
#define NL_MILLISECONDS_PER_HOUR (60 * NL_MILLISECONDS_PER_MINUTE)
#define NL_MILLISECONDS_PER_DAY (24 * NL_MILLISECONDS_PER_HOUR)

//
// Structure the describes an API call over the secure channel
//


typedef struct _CLIENT_API {


    //
    // Each API call made across this secure channel is timed by this timer.
    // If the timer expires, the session to the server is forcefully
    // terminated to ensure the client doesn't hang for a dead server.
    //
    // Access serialized by DomainInfo->DomTrustListCritSect.
    //

    TIMER CaApiTimer;

#define SHORT_API_CALL_PERIOD   (45*1000)    // Logon API lasts 45 seconds
#define LONG_API_CALL_PERIOD    (15*60*1000) // Replication API 15 minute
#define BINDING_CACHE_PERIOD    (3*60*1000)  // Cache RPC handle for 3 minutes
#define WRITER_WAIT_PERIOD      NlGlobalParameters.ShortApiCallPeriod // Max time to wait to become writer

#define IsApiActive( _ClientApi ) ((_ClientApi)->CaApiTimer.Period != MAILSLOT_WAIT_FOREVER )

    //
    // Handle to the thread doing the API.
    //
    // Access serialized by DomainInfo->DomTrustListCritSect.
    //

    HANDLE CaThreadHandle;


    //
    // Access serialized by DomainInfo->DomTrustListCritSect.
    //

    DWORD CaFlags;


#define CA_BINDING_CACHED           0x1 // Set if the binding handle is cached

#define CA_TCP_BINDING              0x2 // Set if the cached binding handle is TCP/IP

#define CA_BINDING_AUTHENTICATED    0x4 // Set if the binding handle is marked authenticated

#define CA_ENTRY_IN_USE             0x8 // Entry is in use by a thread

    //
    // Rpc context handle for this call.
    //
    // Access serialized by DomainInfo->DomTrustListCritSect.
    //
    handle_t CaRpcHandle;

    //
    // When an api is in progress,
    //  this is the CsSessionCount at the start of the API call.
    //
    // Access serialized by CsWriterSemaphore.
    //

    DWORD CaSessionCount;


} CLIENT_API, * PCLIENT_API;


//
// Client session.
//
//  Structure to define the client side of a session to a DC.
//

typedef struct _CLIENT_SESSION {

    //
    // Each client session entry is in a doubly linked list defined by
    // DomTrustList.
    //
    // Access serialized by DomTrustListCritSect.
    //

    LIST_ENTRY CsNext;


    //
    // Time when the last authentication attempt was made.
    //
    // When the CsState is CS_AUTHENTICATED, this field is the time the
    // secure channel was setup.
    //
    // When the CsState is CS_IDLE, this field is the time of the last
    // failed discovery or session setup.  Or it may be zero, to indicate
    // that it is OK to do another discovery at any time.
    //
    // When the CsState is CS_DC_PICKED, this field is zero indicating it is
    // OK to do the session setup at any time.  Or it may be the time of the
    // last failed session setup if different threads did the setup/discovery.
    //
    // Access serialized by NlGlobalDcDiscoveryCritSect
    //

    LARGE_INTEGER CsLastAuthenticationTry;

    //
    // Time when the last discovery attempt was made.
    //
    // The time is the time of completion of the last discovery attempt regardless
    // of the success or failure of that attempt or the discovery type (with or without account)
    //
    // Access serialized by NlGlobalDcDiscoveryCritSect
    //

    LARGE_INTEGER CsLastDiscoveryTime;

    //
    // Time when the last discovery attempt with account was made
    // regardless of the success or failure of that attempt
    //

    LARGE_INTEGER CsLastDiscoveryWithAccountTime;

    //
    // Time when the session was refreshed last time
    //

    LARGE_INTEGER CsLastRefreshTime;

    //
    // WorkItem for Async discovery
    //

    WORKER_ITEM CsAsyncDiscoveryWorkItem;

    //
    // Name/Guid of the domain this connection is to
    //
    // Access serialized by DomTrustListCritSect.
    //

    GUID CsDomainGuidBuffer;
    UNICODE_STRING CsNetbiosDomainName;
    CHAR CsOemNetbiosDomainName[DNLEN+1];
    ULONG CsOemNetbiosDomainNameLength;
    UNICODE_STRING CsDnsDomainName;
    LPSTR CsUtf8DnsDomainName;
    GUID *CsDomainGuid; // NULL if domain has no GUID.

    // Either the Netbios or Dns Domain name.
    // Suitable for debug.  Suitable for Eventlog messages.
    LPWSTR CsDebugDomainName;

    //
    // Name of the local trusted domain object.
    //
    PUNICODE_STRING CsTrustName;


    //
    // Name of the account on the server.
    //  For NT 5.0 interdomain trust, this is the dns name of this domain.
    //

    LPWSTR CsAccountName;



    //
    // Domain ID of the domain this connection is to
    //
    // Access serialized by either DomTrustListCritSect or CsWriter.
    // Modifications must lock both.

    PSID CsDomainId;


    //
    // Hosted domain this session is for
    //

    PDOMAIN_INFO CsDomainInfo;

    //
    // Type of CsAccountName
    //

    NETLOGON_SECURE_CHANNEL_TYPE CsSecureChannelType;

    //
    // State of the connection to the server.
    //
    // Access serialized by NlGlobalDcDiscoveryCritSect
    //  This field can be read without the crit sect locked if
    //  the answer will only be used as a hint.
    //

    DWORD CsState;

#define CS_IDLE             0       // No session is currently active
#define CS_DC_PICKED        1       // The session has picked a DC for session
#define CS_AUTHENTICATED    2       // The session is currently active


    //
    // Status of latest attempt to contact the server.
    //
    // When the CsState is CS_AUTHENTICATED, this field is STATUS_SUCCESS.
    //
    // When the CsState is CS_IDLE, this field is a non-successful status.
    //
    // When the CsState is CS_DC_PICKED, this field is the same non-successful
    //  status from when the CsState was last CS_IDLE.
    //
    // Access serialized by NlGlobalDcDiscoveryCritSect
    //  This field can be read without the crit sect locked if
    //  the answer will only be used as a hint.
    //

    NTSTATUS CsConnectionStatus;

    //
    // Access serialized by DomTrustListCritSect or
    //  by the writer lock if so indicated
    //

    DWORD CsFlags;

#define CS_UPDATE_PASSWORD    0x01  // Set if the password has already
                                    // been changed on the client and
                                    // needs changing on the server.

#define CS_PASSWORD_REFUSED   0x02  // Set if DC refused a password change.

#define CS_NT5_DOMAIN_TRUST   0x04  // Trust is to an NT 5 domain.

#define CS_WRITER             0x08  // Entry is being modified

#define CS_DIRECT_TRUST       0x10  // We have a direct trust to the specified
                                    // domain.

#define CS_CHECK_PASSWORD     0x20  // Set if we need to check the password

#define CS_PICK_DC            0x40  // Set if we need to Pick a DC

#define CS_REDISCOVER_DC      0x80  // Set when we need to Rediscover a DC

#define CS_HANDLE_API_TIMER  0x400  // Set if we need to handle API timer expiration

#define CS_NOT_IN_LSA        0x800  // Flag to delete this entry if it's
                                    // not later proved to be in the LSA.

#define CS_ZERO_LAST_AUTH        0x2000  // Set if we need to zero CsLastAuthenticationTry

#define CS_DOMAIN_IN_FOREST      0x4000  // Set if trusted domain is in same forest as this domain.

#define CS_NEW_TRUST             0x8000  // Set on a newly allocated trusted domain
                                         // until async discovery has been tried

#define CS_DC_PICKED_ONCE        0x10000 // Set if DC was picked at least once.
                                         //  Access serialized by writer lock

    //
    // Trust attributes for the trusted domain object
    //

    ULONG CsTrustAttributes;

    //
    // Pointer to client session that represents the direct trust that's
    //  the closest route to the domain of this client session.
    //
    // The pointed to client session will always be marked CS_DIRECT_TRUST.
    //
    // If this is a CS_DIRECT_TRUST session,
    //  this field will point to this client session.
    //

    struct _CLIENT_SESSION *CsDirectClientSession;

    //
    // Flags describing capabilities of both client and server.
    //

    ULONG CsNegotiatedFlags;

    //
    // Time Number of authentication attempts since last success.
    //
    // Access serialized by CsWriterSemaphore.
    //

    DWORD CsAuthAlertCount;

    //
    // Number of times the secure channel has been dropped.
    //
    // Access serialized by CsWriterSemaphore.
    //

    DWORD CsSessionCount;

    //
    // Number of threads referencing this entry.
    //
    // Access serialized by DomTrustListCritSect.
    //

    DWORD CsReferenceCount;

    //
    // Writer semaphore.
    //
    //  This semaphore is locked whenever there is a writer modifying
    //  fields in this client session.
    //

    HANDLE CsWriterSemaphore;


#ifdef _DC_NETLOGON
    //
    // The following fields are used by the NlDiscoverDc to keep track
    //  of discovery state.
    //
    // Access serialized by NlGlobalDcDiscoveryCritSect
    //

    DWORD CsDiscoveryFlags;
#define CS_DISCOVERY_DEAD_DOMAIN    0x001    // This is a dead domain disocvery
#define CS_DISCOVERY_ASYNCHRONOUS   0x002    // Discovery being processed in worker thread
#define CS_DISCOVERY_HAS_DS         0x004    // Discovered DS has a DS
#define CS_DISCOVERY_IS_CLOSE       0x008    // Discovered DS is in a close site
#define CS_DISCOVERY_HAS_IP         0x010    // Discovered DC has IP address
#define CS_DISCOVERY_USE_MAILSLOT   0x020    // Discovered DC should be pinged using mailslot mechanism
#define CS_DISCOVERY_USE_LDAP       0x040    // Discovered DC should be pinged using LDAP mechanism
#define CS_DISCOVERY_HAS_TIMESERV   0x080    // Discovered DC runs the Windows Time Service
#define CS_DISCOVERY_DNS_SERVER     0x100    // Discovered DC name is DNS (if off, the name is Netbios)

//
// The next 2 password/trust monitor bits are protected by the writer lock
//
#define CS_DISCOVERY_NO_PWD_MONITOR 0x200    // Discovered DC cannot process NetrServerTrustPasswordsGet
#define CS_DISCOVERY_NO_PWD_ATTR_MONITOR 0x400 // Discovered DC cannot process NetrServerTrustPasswordsAndAttribGet

    //
    // This event is set to indicate that discovery is not in progress on this
    //  client session.
    //

    HANDLE CsDiscoveryEvent;
#endif // _DC_NETLOGON

    //
    // API timout count. After each logon/logoff API call made to the
    // server this count is incremented if the time taken to execute the
    // this API is more than MAX_DC_API_TIMEOUT.
    //
    // The count is decremented each time there are FAST_DC_API_THRESHOLD calls
    // that execute in FAST_DC_API_TIMEOUT seconds.
    //
    //
    // Access serialized by CsWriterSemaphore.
    //

    DWORD CsTimeoutCount;

#define MAX_DC_TIMEOUT_COUNT        2   // drop the session after this
                                        // many timeouts and when it is
                                        // time to reauthenticate.

#define MAX_DC_API_TIMEOUT          (long) (15L*1000L)   // 15 seconds

#define MAX_DC_REAUTHENTICATION_WAIT    (long) (5L*60L*1000L) // 5 mins

#define MAX_DC_REFRESH_TIMEOUT      (45 * 60 * 1000) // 45 minutes

#define FAST_DC_API_THRESHOLD       5   // Number of fast calls needed before
                                        // we decrement timeout count

#define FAST_DC_API_TIMEOUT         (1000)  // 1 second

    //
    // Count of Fast Calls
    //
    // Access serialized by CsWriterSemaphore.
    //

    DWORD CsFastCallCount;

    //
    // Authentication information.
    //
    // Access serialized by CsWriterSemaphore.
    //

    NETLOGON_CREDENTIAL CsAuthenticationSeed;
    NETLOGON_SESSION_KEY CsSessionKey;

    PVOID ClientAuthData;
    CredHandle CsCredHandle;

#ifdef _DC_NETLOGON
    //
    // Transport the server was discovered on.
    //

    PNL_TRANSPORT CsTransport;
#endif // _DC_NETLOGON


    //
    // Rid of the account used to contact server
    //

    ULONG CsAccountRid;

    //
    // Know good password for this secure channel.
    //
    // After secure channel setup, it is the password used to setup the channel.
    // After a password change, it is the password successfully set on the DC.
    //
    NT_OWF_PASSWORD CsNtOwfPassword;

    //
    // Name of the server this connection is to (may be DNS or Netbios) and its
    //  IP address (if any).
    //
    // Access serialized by CsWriterSemaphore or NlGlobalDcDiscoveryCritSect.
    // Modification from Null to non-null serialized by
    //  NlGlobalDcDiscoveryCritSect
    // (Modification from non-null to null requires both to be locked.)
    //

    LPWSTR CsUncServerName;

    SOCKET_ADDRESS CsServerSockAddr;
    SOCKADDR_IN CsServerSockAddrIn;

    //
    // API semaphore.
    //
    //  This semaphore has one reference for each slot in CsClientApi.
    //  (Except the zeroth slot which is special.)
    //

    HANDLE CsApiSemaphore;

    //
    // List of API calls outstanding on this session
    //
    // Access serialized by DomainInfo->DomTrustListCritSect.
    //

    CLIENT_API CsClientApi[1];

#define ClientApiIndex( _ClientSession, _ClientApi ) \
    ((LONG) ((_ClientApi)-&((_ClientSession)->CsClientApi[0])) )

#define UseConcurrentRpc( _ClientSession, _ClientApi ) \
    (ClientApiIndex( _ClientSession, _ClientApi ) != 0 )


} CLIENT_SESSION, * PCLIENT_SESSION;


#define LOCK_TRUST_LIST(_DI)   EnterCriticalSection( &(_DI)->DomTrustListCritSect )
#define UNLOCK_TRUST_LIST(_DI) LeaveCriticalSection( &(_DI)->DomTrustListCritSect )

//
// For member workstations,
//  maintain a list of domains trusted by our primary domain.
//
// Access serialized by NlGlobalDcDiscoveryCritSect
//

typedef struct {
    WCHAR UnicodeNetbiosDomainName[DNLEN+1];
    LPSTR Utf8DnsDomainName;
} TRUSTED_DOMAIN, *PTRUSTED_DOMAIN;



#ifdef _DC_NETLOGON
/////////////////////////////////////////////////////////////////////////////
//
// Server Session definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Sam Sync Context.
//
// A Sam sync context is maintained on the PDC for each BDC/member currently
// doing a full sync.
//
typedef struct _SAM_SYNC_CONTEXT {

    //
    // The Sync state indicates tracks the progression of the sync.
    //

    SYNC_STATE SyncState;

    //
    // A serial number indicating the number of times the BDC/member
    // has called us.  We use this as a resume handle.
    //

    ULONG SyncSerial;

    //
    // The current Sam Enumeration information
    //

    SAM_ENUMERATE_HANDLE SamEnumHandle;     // Current Sam Enum Handle
    PSAMPR_ENUMERATION_BUFFER SamEnum;      // Sam returned buffer
    PULONG RidArray;                        // Array of enumerated Rids
    ULONG Index;                            // Index to current entry
    ULONG Count;                            // Total Number of entries

    BOOL SamAllDone;                        // True, if Sam has completed

} SAM_SYNC_CONTEXT, *PSAM_SYNC_CONTEXT;

#define SAM_SYNC_PREF_MAX 1024              // Preferred max for Sam Sync


//
// Lsa Sync Context.
//
// A Lsa sync context is maintained on the PDC for each BDC/member
//  currently doing a full sync.
//
typedef struct _LSA_SYNC_CONTEXT {

    //
    // The Sync state indicates tracks the progression of the sync.
    //

    enum {
        AccountState,
        TDomainState,
        SecretState,
        LsaDoneState
    } SyncState;

    //
    // A serial number indicating the number of times the BDC/member
    // has called us.  We use this as a resume handle.
    //

    ULONG SyncSerial;

    //
    // The current Lsa Enumeration information
    //

    LSA_ENUMERATION_HANDLE LsaEnumHandle;     // Current Lsa Enum Handle

    enum {
        AccountEnumBuffer,
        TDomainEnumBuffer,
        SecretEnumBuffer,
        EmptyEnumBuffer
    } LsaEnumBufferType;

    union {
        LSAPR_ACCOUNT_ENUM_BUFFER Account;
        LSAPR_TRUSTED_ENUM_BUFFER TDomain;
        PVOID Secret;
    } LsaEnum;                              // Lsa returned buffer

    ULONG Index;                            // Index to current entry
    ULONG Count;                            // Total Number of entries

    BOOL LsaAllDone;                        // True, if Lsa has completed

} LSA_SYNC_CONTEXT, *PLSA_SYNC_CONTEXT;

//
// union of lsa and sam context
//

typedef struct _SYNC_CONTEXT {
    enum {
        LsaDBContextType,
        SamDBContextType
    } DBContextType;

    union {
        LSA_SYNC_CONTEXT Lsa;
        SAM_SYNC_CONTEXT Sam;
    } DBContext;
} SYNC_CONTEXT, *PSYNC_CONTEXT;

//
// Macro used to free any resources allocated by SAM.
//
// ?? check LsaIFree_LSAPR_* call parameters.
//

#define CLEAN_SYNC_CONTEXT( _Sync ) { \
    if ( (_Sync)->DBContextType == LsaDBContextType ) { \
        if ( (_Sync)->DBContext.Lsa.LsaEnumBufferType != \
                                            EmptyEnumBuffer) { \
            if ( (_Sync)->DBContext.Lsa.LsaEnumBufferType == \
                                            AccountEnumBuffer) { \
                LsaIFree_LSAPR_ACCOUNT_ENUM_BUFFER( \
                    &((_Sync)->DBContext.Lsa.LsaEnum.Account) ); \
            } \
            else if ( (_Sync)->DBContext.Lsa.LsaEnumBufferType == \
                                                TDomainEnumBuffer) { \
                LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER( \
                    &((_Sync)->DBContext.Lsa.LsaEnum.TDomain) ); \
            } \
            else { \
                LsaIFree_LSAI_SECRET_ENUM_BUFFER ( \
                    (_Sync)->DBContext.Lsa.LsaEnum.Secret, \
                    (_Sync)->DBContext.Lsa.Count ); \
                (_Sync)->DBContext.Lsa.LsaEnum.Secret = NULL; \
            } \
            (_Sync)->DBContext.Lsa.LsaEnumBufferType = \
                                            EmptyEnumBuffer; \
        } \
    } else { \
        if ( (_Sync)->DBContext.Sam.SamEnum != NULL ) { \
            SamIFree_SAMPR_ENUMERATION_BUFFER( \
                (_Sync)->DBContext.Sam.SamEnum ); \
            (_Sync)->DBContext.Sam.SamEnum = NULL; \
        } \
        if ( (_Sync)->DBContext.Sam.RidArray != NULL ) { \
            MIDL_user_free( (_Sync)->DBContext.Sam.RidArray );\
            (_Sync)->DBContext.Sam.RidArray = NULL; \
        } \
    } \
}

//
// Macro to initialize Sync Context
//
#define INIT_SYNC_CONTEXT( _Sync, _ContextType ) { \
    RtlZeroMemory( (_Sync), sizeof( *(_Sync) ) ) ; \
    (_Sync)->DBContextType = (_ContextType) ; \
}

//
// Server Session structure
//
// This structure represents the server side of a connection to a DC.
//
// ISSUE-2000/09/15-CliffV: This structure could be made smaller by using SsSecureChannelType
//  as a discriminator.  Many fields are specific to a BDC server session entry.  Others
//  are specific to a domain server session entry.  However, most entries are member workstation
//  server session entries that don't use either of the fields.
//

typedef struct _SERVER_SESSION {
    //
    // Each server session entry is in a doubly linked list for each hash bucket.
    //  Indexed by SsComputerName
    //

    LIST_ENTRY SsHashList;

    //
    // Each server session entry is in a doubly linked list defined by
    // DomainInfo->DomServerSessionTable.
    //

    LIST_ENTRY SsSeqList;

    //
    // List of all BDCs headed by NlGlobalBdcServerSessionList.
    //
    // (The field is set only on BDC server session entries)
    //
    // Access serialized by NlGlobalServerSessionTableCritSect.
    //

    LIST_ENTRY SsBdcList;

    //
    // List of BDC's which have a pulse pending.
    //

    LIST_ENTRY SsPendingBdcList;

    //
    // Time when the last pulse was sent to this machine
    //
    // (The field is set only on BDC server session entries)
    //

    LARGE_INTEGER SsLastPulseTime;

    //
    // Current serial numbers of each database on the BDC.
    //
    // (The field is set only on BDC server session entries)
    //

    LARGE_INTEGER SsBdcDbSerialNumber[NUM_DBS];

    //
    // The computername uniquely identifies this server session entry.
    //

    NETLOGON_SECURE_CHANNEL_TYPE SsSecureChannelType;
    CHAR SsComputerName[CNLEN+1];

    //
    // Rid of the account to authenticate with
    //

    ULONG SsAccountRid;

    //
    // The number of times there has been no response to a pulse.
    //

    USHORT SsPulseTimeoutCount;

    //
    // Hosted domain for this server session.
    //

    PDOMAIN_INFO SsDomainInfo;

    //
    // The number of times this entry has been scavanged.
    //

    USHORT SsCheck;

    //
    // Flags describing the state of the current entry.
    //  See the SS_ defines below.
    //

    USHORT SsFlags;

#define SS_BDC_FORCE_DELETE    0x0001 // Unless set, BDC server session won't be deleted
#define SS_AUTHENTICATED       0x0002 // Remote side has been authenticated

#define SS_LOCKED              0x0004 // Delay deletion requests for this entry
                                      // While set, SsSessionKey may be referenced
#define SS_DELETE_ON_UNLOCK    0x0008 // Delete entry when it is unlocked

#define SS_BDC                 0x0010 // BDC account exists for this Client
#define SS_FOREST_TRANSITIVE   0x0020 // TDO has TRUST_ATTRIBUTE_FOREST_TRANSITIVE set
#define SS_PENDING_BDC         0x0040 // BDC is on pending BDC list.

#define SS_FORCE_PULSE         0x0200 // Force a pulse message to this BDC.
#define SS_PULSE_SENT          0x0400 // Pulse has been sent but has not
                                      // been responded to yet
#define SS_LSA_REPL_NEEDED     0x2000 // BDC needs LSA DB replicated
#define SS_ACCOUNT_REPL_NEEDED 0x4000 // BDC needs SAM Account DB replicated
#define SS_BUILTIN_REPL_NEEDED 0x8000 // BDC needs SAM Builtin DB replicated
#define SS_REPL_MASK           0xE000 // BDC needs replication mask
#define SS_REPL_LSA_MASK       0x2000 // BDC needs LSA replication mask
#define SS_REPL_SAM_MASK       0xC000 // BDC needs SAM replication mask

// Don't clear these on session setup
#define SS_PERMANENT_FLAGS \
    ( SS_BDC | SS_PENDING_BDC | SS_FORCE_PULSE | SS_REPL_MASK )

    //
    // Flags describing capabilities of both client and server.
    //

    ULONG SsNegotiatedFlags;

    //
    // Transport the client connected over.
    //

    PNL_TRANSPORT SsTransport;


    //
    // This is the ClientCredential (after authentication is complete).
    //

    NETLOGON_CREDENTIAL SsAuthenticationSeed;

    //
    // This is the ServerChallenge (during the challenge phase) and later
    //  the SessionKey (after authentication is complete).
    //

    NETLOGON_SESSION_KEY SsSessionKey;


    //
    // A pointer to the Sync context.
    //
    // (The field is set only on BDC server session entries)
    //

    PSYNC_CONTEXT SsSync;

    //
    // Each server session entry is in a doubly linked list for each hash bucket.
    //  Indexed by SsTdoName
    //
    // (This field is set only on *uplevel* interdomain trust entries.)
    //

    LIST_ENTRY SsTdoNameHashList;

    UNICODE_STRING SsTdoName;

} SERVER_SESSION, *PSERVER_SESSION;
#endif // _DC_NETLOGON


//
// Structure shared by all PDC and BDC sync routines.
//  (And other users of secure channels.)
//

typedef struct _SESSION_INFO {

    //
    // Session Key shared by both client and server.
    //

    NETLOGON_SESSION_KEY SessionKey;

    //
    // Flags describing capabilities of both client and server.
    //

    ULONG NegotiatedFlags;

} SESSION_INFO, *PSESSION_INFO;

//
// Macro for tranlating the negotiated database replication flags to the mask of
//  which databases to replicate/
//

#define NlMaxReplMask( _NegotiatedFlags ) \
  ((((_NegotiatedFlags) & NETLOGON_SUPPORTS_AVOID_SAM_REPL) ? 0 : SS_REPL_SAM_MASK ) | \
   (((_NegotiatedFlags) & NETLOGON_SUPPORTS_AVOID_LSA_REPL) ? 0 : SS_REPL_LSA_MASK ) )


/////////////////////////////////////////////////////////////////////////////
//
// Structures and variables describing the database info.
//
/////////////////////////////////////////////////////////////////////////////

typedef struct _DB_Info {
    LARGE_INTEGER   CreationTime;   // database creation time
    DWORD           DBIndex;        // index of Database table
    SAM_HANDLE      DBHandle;       // database handle to access
    LPWSTR          DBName;         // Name of the database
    DWORD           DBSessionFlag;  // SS_ Flag representing this database
} DB_INFO, *PDB_INFO;





/////////////////////////////////////////////////////////////////////////////
//
// Replication timing macros
//
/////////////////////////////////////////////////////////////////////////////

#if NETLOGONDBG

///////////////////////////////////////////////////////////////////////////////

#define DEFPACKTIMER DWORD PackTimer, PackTimerTicks

#define INITPACKTIMER       PackTimer = 0;

#define STARTPACKTIMER      \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        PackTimerTicks = GetTickCount(); \
    }

#define STOPPACKTIMER       \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        PackTimer += GetTickCount() - PackTimerTicks; \
    }


#define PRINTPACKTIMER       \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        NlPrint((NL_REPL_OBJ_TIME,"\tTime Taken to PACK this object = %d msecs\n", \
            PackTimer )); \
    }

///////////////////////////////////////////////////////////////////////////////

#define DEFSAMTIMER DWORD SamTimer, SamTimerTicks

#define INITSAMTIMER      SamTimer = 0;

#define STARTSAMTIMER      \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        SamTimerTicks = GetTickCount(); \
    }

#define STOPSAMTIMER       \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        SamTimer += GetTickCount() - SamTimerTicks; \
    }


#define PRINTSAMTIMER       \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        NlPrint((NL_REPL_OBJ_TIME, \
            "\tTime spent in SAM calls = %d msecs\n", \
            SamTimer )); \
    }

///////////////////////////////////////////////////////////////////////////////

#define DEFLSATIMER DWORD LsaTimer, LsaTimerTicks

#define INITLSATIMER        LsaTimer = 0;

#define STARTLSATIMER      \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        LsaTimerTicks = GetTickCount(); \
    }

#define STOPLSATIMER       \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        LsaTimer += GetTickCount() - LsaTimerTicks; \
    }


#define PRINTLSATIMER       \
    IF_NL_DEBUG( REPL_OBJ_TIME ) { \
        NlPrint((NL_REPL_OBJ_TIME, \
            "\tTime spent in LSA calls = %d msecs\n", \
            LsaTimer )); \
    }

///////////////////////////////////////////////////////////////////////////////

#define DEFSSIAPITIMER DWORD SsiApiTimer, SsiApiTimerTicks

#define INITSSIAPITIMER     SsiApiTimer = 0;

#define STARTSSIAPITIMER      \
    IF_NL_DEBUG( REPL_TIME ) { \
        SsiApiTimerTicks = GetTickCount(); \
    }

#define STOPSSIAPITIMER       \
    IF_NL_DEBUG( REPL_TIME ) { \
        SsiApiTimer += GetTickCount() - \
            SsiApiTimerTicks; \
    }


#define PRINTSSIAPITIMER       \
    IF_NL_DEBUG( REPL_TIME ) { \
        NlPrint((NL_REPL_TIME, \
            "\tTime Taken by this SSIAPI call = %d msecs\n", \
            SsiApiTimer )); \
    }

#else // NETLOGONDBG

#define DEFPACKTIMER
#define INITPACKTIMER
#define STARTPACKTIMER
#define STOPPACKTIMER
#define PRINTPACKTIMER

#define DEFSAMTIMER
#define INITSAMTIMER
#define STARTSAMTIMER
#define STOPSAMTIMER
#define PRINTSAMTIMER

#define DEFLSATIMER
#define INITLSATIMER
#define STARTLSATIMER
#define STOPLSATIMER
#define PRINTLSATIMER

#define DEFSSIAPITIMER
#define INITSSIAPITIMER
#define STARTSSIAPITIMER
#define STOPSSIAPITIMER
#define PRINTSSIAPITIMER

#endif // NETLOGONDBG

//
// macros used in pack and unpack routines
//

#define SECURITYINFORMATION OWNER_SECURITY_INFORMATION | \
                            GROUP_SECURITY_INFORMATION | \
                            SACL_SECURITY_INFORMATION | \
                            DACL_SECURITY_INFORMATION

#define INIT_PLACE_HOLDER(_x) \
    RtlInitString( (PSTRING) &(_x)->DummyString1, NULL ); \
    RtlInitString( (PSTRING) &(_x)->DummyString2, NULL ); \
    RtlInitString( (PSTRING) &(_x)->DummyString3, NULL ); \
    RtlInitString( (PSTRING) &(_x)->DummyString4, NULL ); \
    (_x)->DummyLong1 = 0; \
    (_x)->DummyLong2 = 0; \
    (_x)->DummyLong3 = 0; \
    (_x)->DummyLong4 = 0;

#define QUERY_LSA_SECOBJ_INFO(_x) \
    STARTLSATIMER; \
    Status = LsarQuerySecurityObject( \
                (_x), \
                SECURITYINFORMATION, \
                &SecurityDescriptor );\
    STOPLSATIMER; \
\
    if (!NT_SUCCESS(Status)) { \
        SecurityDescriptor = NULL; \
        goto Cleanup; \
    }

#define QUERY_SAM_SECOBJ_INFO(_x) \
    STARTSAMTIMER; \
    Status = SamrQuerySecurityObject( \
                (_x), \
                SECURITYINFORMATION, \
                &SecurityDescriptor );\
    STOPSAMTIMER; \
\
    if (!NT_SUCCESS(Status)) { \
        SecurityDescriptor = NULL; \
        goto Cleanup; \
    }


#define SET_LSA_SECOBJ_INFO(_x, _y) \
    SecurityDescriptor.Length = (_x)->SecuritySize; \
    SecurityDescriptor.SecurityDescriptor = (_x)->SecurityDescriptor; \
\
    STARTLSATIMER; \
    Status = LsarSetSecurityObject( \
                (_y), \
                (_x)->SecurityInformation, \
                &SecurityDescriptor ); \
    STOPLSATIMER; \
\
    if (!NT_SUCCESS(Status)) { \
        NlPrint((NL_CRITICAL, \
                 "LsarSetSecurityObject failed (%lx)\n", \
                 Status )); \
        goto Cleanup; \
    }

#define SET_SAM_SECOBJ_INFO(_x, _y) \
    SecurityDescriptor.Length = (_x)->SecuritySize; \
    SecurityDescriptor.SecurityDescriptor = (_x)->SecurityDescriptor; \
\
    STARTSAMTIMER; \
    Status = SamrSetSecurityObject( \
                (_y), \
                (_x)->SecurityInformation, \
                &SecurityDescriptor ); \
    STOPSAMTIMER; \
\
    if (!NT_SUCCESS(Status)) { \
        NlPrint((NL_CRITICAL, \
                 "SamrSetSecurityObject failed (%lx)\n", \
                 Status )); \
        goto Cleanup; \
    }


#define DELTA_SECOBJ_INFO(_x) \
    (_x)->SecurityInformation = SECURITYINFORMATION;\
    (_x)->SecuritySize = SecurityDescriptor->Length;\
\
    *BufferSize += NlCopyData( \
                    (LPBYTE *)&SecurityDescriptor->SecurityDescriptor, \
                    (LPBYTE *)&(_x)->SecurityDescriptor, \
                    SecurityDescriptor->Length );

//
// Values of WorkstationFlags field of NETLOGON_WORKSTATION_INFO
//

#define NL_NEED_BIDIRECTIONAL_TRUSTS    0x0001  // Client wants inbound trusts, too
#define NL_CLIENT_HANDLES_SPN           0x0002  // Client handles updating SPN

#define NL_GET_DOMAIN_INFO_SUPPORTED    0x0003  // Mask of all bits supported

//
// Structure describing failed user logon.
//  We keep a small cache of failed use logons
//  with bad password.
//

typedef struct _NL_FAILED_USER_LOGON {

    //
    // Link to next entry in the list of failed forwarded logons
    //  (Serialized by DomainInfo->DomTrustListCritSect)
    //
    LIST_ENTRY FuNext;

    //
    // Last time we forwarded the logon to the PDC
    //
    ULONG  FuLastTimeSentToPdc;

    //
    // Count of failed local logons
    //
    ULONG  FuBadLogonCount;

    //
    // The user name (must be lat field in struct)
    //
    WCHAR FuUserName[ANYSIZE_ARRAY];

} NL_FAILED_USER_LOGON, *PNL_FAILED_USER_LOGON;

//
// The number of failed user logons we keep per domain.
//  (The maximum number of negative cache entries we keep
//  before throwing the least recently used one.)
//
#define NL_MAX_FAILED_USER_LOGONS 50

//
// Number of failed logons for a given user after which we refrain from
//  forwarding subsequent user logons to the PDC for some period of time
//
#define NL_FAILED_USER_MAX_LOGON_COUNT 10

//
// Time period during which we refrain from forwarding a given
//  user logon to the PDC once number of failed user logons
//  reaches the above limit
//
#define NL_FAILED_USER_FORWARD_LOGON_TIMEOUT  300000  // 5 minutes


///////////////////////////////////////////////////////////////////////////////
//
// Procedure forwards.
//
///////////////////////////////////////////////////////////////////////////////

#ifdef _DC_NETLOGON
//
// srvsess.c
//


NET_API_STATUS
NlTransportOpen(
    VOID
    );

BOOL
NlTransportAddTransportName(
    IN LPWSTR TransportName,
    OUT PBOOLEAN IpTransportChanged
    );

BOOLEAN
NlTransportDisableTransportName(
    IN LPWSTR TransportName
    );

PNL_TRANSPORT
NlTransportLookupTransportName(
    IN LPWSTR TransportName
    );

PNL_TRANSPORT
NlTransportLookup(
    IN LPWSTR ClientName
    );

VOID
NlTransportClose(
    VOID
    );

ULONG
NlTransportGetIpAddresses(
    IN ULONG HeaderSize,
    IN BOOLEAN ReturnOffsets,
    OUT PSOCKET_ADDRESS *RetIpAddresses,
    OUT PULONG RetIpAddressSize
    );

BOOLEAN
NlHandleWsaPnp(
    VOID
    );


PSERVER_SESSION
NlFindNamedServerSession(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR ComputerName
    );

VOID
NlSetServerSessionAttributesByTdoName(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING TdoName,
    IN ULONG TrustAttributes
    );

NTSTATUS
NlInsertServerSession(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR ComputerName,
    IN LPWSTR TdoName OPTIONAL,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN DWORD Flags,
    IN ULONG AccountRid,
    IN ULONG NegotiatedFlags,
    IN PNL_TRANSPORT Transport OPTIONAL,
    IN PNETLOGON_SESSION_KEY SessionKey OPTIONAL,
    IN PNETLOGON_CREDENTIAL AuthenticationSeed OPTIONAL
    );

NTSTATUS
NlCheckServerSession(
    IN ULONG ServerRid,
    IN PUNICODE_STRING AccountName OPTIONAL,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType
    );

NTSTATUS
NlBuildNtBdcList(
    PDOMAIN_INFO DomainInfo
    );

NTSTATUS
NlBuildLmBdcList(
    PDOMAIN_INFO DomainInfo
    );

BOOLEAN
NlFreeServerSession(
    IN PSERVER_SESSION ServerSession
    );

VOID
NlUnlockServerSession(
    IN PSERVER_SESSION ServerSession
    );

VOID
NlFreeNamedServerSession(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR ComputerName,
    IN BOOLEAN AccountBeingDeleted
    );

VOID
NlFreeServerSessionForAccount(
    IN PUNICODE_STRING AccountName
    );

VOID
NlServerSessionScavenger(
    IN PDOMAIN_INFO DomainInfo
    );
#endif // _DC_NETLOGON


//
// ssiauth.c
//


NTSTATUS
NlMakeSessionKey(
    IN ULONG NegotiatedFlags,
    IN PNT_OWF_PASSWORD CryptKey,
    IN PNETLOGON_CREDENTIAL ClientChallenge,
    IN PNETLOGON_CREDENTIAL ServerChallenge,
    OUT PNETLOGON_SESSION_KEY SessionKey
    );

#ifdef _DC_NETLOGON
NTSTATUS
NlCheckAuthenticator(
    IN OUT PSERVER_SESSION ServerServerSession,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator
    );
#endif _DC_NETLOGON

VOID
NlComputeCredentials(
    IN PNETLOGON_CREDENTIAL Challenge,
    OUT PNETLOGON_CREDENTIAL Credential,
    IN PNETLOGON_SESSION_KEY SessionKey
    );

VOID
NlComputeChallenge(
    OUT PNETLOGON_CREDENTIAL Challenge
    );

VOID
NlBuildAuthenticator(
    IN OUT PNETLOGON_CREDENTIAL AuthenticationSeed,
    IN PNETLOGON_SESSION_KEY SessionKey,
    OUT PNETLOGON_AUTHENTICATOR Authenticator
    );

BOOL
NlUpdateSeed(
    IN OUT PNETLOGON_CREDENTIAL AuthenticationSeed,
    IN PNETLOGON_CREDENTIAL TargetCredential,
    IN PNETLOGON_SESSION_KEY SessionKey
    );

VOID
NlEncryptRC4(
    IN OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN PSESSION_INFO SessionInfo
    );

VOID
NlDecryptRC4(
    IN OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN PSESSION_INFO SessionInfo
    );

VOID
NlPrintTrustedDomain(
    PDS_DOMAIN_TRUSTSW TrustedDomain,
    IN BOOLEAN VerbosePrint,
    IN BOOLEAN AnsiOutput
    );

//
// trustutl.c
//

//
// Extended trust information passed via I_NetLogonGetDomainInfo
//
typedef struct _NL_TRUST_EXTENSION {
    ULONG Flags;
    ULONG ParentIndex;
    ULONG TrustType;
    ULONG TrustAttributes;
} NL_TRUST_EXTENSION, *PNL_TRUST_EXTENSION;

PCLIENT_SESSION
NlFindNamedClientSession(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN ULONG Flags,
    OUT PBOOLEAN TransitiveUsed OPTIONAL
    );


PCLIENT_SESSION
NlAllocateClientSession(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PSID DomainId,
    IN GUID *DomainGuid OPTIONAL,
    IN ULONG Flags,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN ULONG TrustAttributes
    );

VOID
NlFreeClientSession(
    IN PCLIENT_SESSION ClientSession
    );

VOID
NlRefClientSession(
    IN PCLIENT_SESSION ClientSession
    );

VOID
NlUnrefClientSession(
    IN PCLIENT_SESSION ClientSession
    );

PCLIENT_API
NlAllocateClientApi(
    IN PCLIENT_SESSION ClientSession,
    IN DWORD Timeout
    );

VOID
NlFreeClientApi(
    IN PCLIENT_SESSION ClientSession,
    IN PCLIENT_API ClientApi
    );

BOOL
NlTimeoutSetWriterClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN DWORD Timeout
    );

VOID
NlResetWriterClientSession(
    IN PCLIENT_SESSION ClientSession
    );

NTSTATUS
NlCaptureServerClientSession (
    IN PCLIENT_SESSION ClientSession,
    OUT LPWSTR *UncServerName,
    OUT DWORD *DiscoveryFlags OPTIONAL
    );

NTSTATUS
NlCaptureNetbiosServerClientSession (
    IN PCLIENT_SESSION ClientSession,
    OUT WCHAR NetbiosUncServerName[UNCLEN+1]
    );

BOOL
NlSetNamesClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN PUNICODE_STRING DomainName OPTIONAL,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PSID DomainId OPTIONAL,
    IN GUID *DomainGuid OPTIONAL
    );

VOID
NlSetStatusClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN NTSTATUS CsConnectionStatus
    );

#ifdef _DC_NETLOGON
NTSTATUS
NlInitTrustList(
    IN PDOMAIN_INFO DomainInfo
    );

VOID
NlPickTrustedDcForEntireTrustList(
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN OnlyDoNewTrusts
    );
#endif // _DC_NETLOGON

NTSTATUS
NlUpdatePrimaryDomainInfo(
    IN LSAPR_HANDLE PolicyHandle,
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING DnsDomainName,
    IN PUNICODE_STRING DnsForestName,
    IN GUID *DomainGuid
    );

VOID
NlSetForestTrustList (
    IN PDOMAIN_INFO DomainInfo,
    IN OUT PDS_DOMAIN_TRUSTSW *ForestTrustList,
    IN ULONG ForestTrustListSize,
    IN ULONG ForestTrustListCount
    );

NET_API_STATUS
NlReadRegTrustedDomainList (
    IN PDOMAIN_INFO DomainInfo,
    IN BOOL DeleteName,
    OUT PDS_DOMAIN_TRUSTSW *RetForestTrustList,
    OUT PULONG RetForestTrustListSize,
    OUT PULONG RetForestTrustListCount
    );

NET_API_STATUS
NlReadFileTrustedDomainList (
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR FileSuffix,
    IN BOOL DeleteName,
    IN ULONG Flags,
    OUT PDS_DOMAIN_TRUSTSW *RetForestTrustList,
    OUT PULONG RetForestTrustListSize,
    OUT PULONG RetForestTrustListCount
    );

NET_API_STATUS
NlpEnumerateDomainTrusts (
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG Flags,
    OUT PULONG RetForestTrustListCount,
    OUT PDS_DOMAIN_TRUSTSW *RetForestTrustList
    );

BOOLEAN
NlIsDomainTrusted (
    IN PUNICODE_STRING DomainName
    );

NET_API_STATUS
NlGetTrustedDomainNames (
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR DomainName,
    OUT LPWSTR *TrustedDnsDomainName,
    OUT LPWSTR *TrustedNetbiosDomainName
    );

typedef enum _DISCOVERY_TYPE {
#ifdef _DC_NETLOGON
    DT_DeadDomain,
    DT_Asynchronous,
#endif // _DC_NETLOGON
    DT_Synchronous
} DISCOVERY_TYPE;

NET_API_STATUS
NlSetServerClientSession(
    IN OUT PCLIENT_SESSION ClientSession,
    IN PNL_DC_CACHE_ENTRY NlDcCacheEntry,
    IN BOOL DcDiscoveredWithAccount,
    IN BOOL SessionRefresh
    );

NTSTATUS
NlDiscoverDc (
    IN OUT PCLIENT_SESSION ClientSession,
    IN DISCOVERY_TYPE DiscoveryType,
    IN BOOLEAN InDiscoveryThread,
    IN BOOLEAN DiscoverWithAccount
    );

VOID
NlFlushCacheOnPnp (
    VOID
    );

BOOL
NlReadSamLogonResponse (
    IN HANDLE ResponseMailslotHandle,
    IN LPWSTR AccountName,
    OUT LPDWORD Opcode,
    OUT LPWSTR *LogonServer,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry OPTIONAL
    );

#ifdef _DC_NETLOGON
NTSTATUS
NlPickDomainWithAccount (
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING InAccountNameString,
    IN PUNICODE_STRING InDomainNameString OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN BOOLEAN ExpediteToRoot,
    IN BOOLEAN CrossForestHop,
    OUT LPWSTR *RealSamAccountName,
    OUT LPWSTR *RealDomainName,
    OUT PULONG RealExtraFlags
    );
#endif // _DC_NETLOGON

#ifdef _NETLOGON_SERVER
NTSTATUS
NlGetConfigurationName(
                       DWORD       which,
                       DWORD       *pcbName,
                       DSNAME      *pName );

NTSTATUS
NlGetConfigurationNamesList(
    DWORD       which,
    DWORD       dwFlags,
    ULONG *     pcbNames,
    DSNAME **   padsNames );

NTSTATUS
NlGetDnsRootAlias(
    WCHAR * pDnsRootAlias,
    WCHAR * pRootDnsRootAlias);

DWORD
NlDsGetServersAndSitesForNetLogon(
    WCHAR *    pNDNC,
    SERVERSITEPAIR ** ppaRes);

VOID
NlDsFreeServersAndSitesForNetLogon(
    SERVERSITEPAIR *         paServerSites
    );

NTSTATUS
NlCrackSingleName(
    DWORD       formatOffered,          // one of DS_NAME_FORMAT in ntdsapi.h
    BOOL        fPerformAtGC,           // whether to go to GC or not
    WCHAR       *pNameIn,               // name to crack
    DWORD       formatDesired,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       *pccDnsDomain,          // char count of following argument
    WCHAR       *pDnsDomain,            // buffer for DNS domain name
    DWORD       *pccNameOut,            // char count of following argument
    WCHAR       *pNameOut,              // buffer for formatted name
    DWORD       *pErr);                 // one of DS_NAME_ERROR in ntdsapi.h
#endif // _NETLOGON_SERVER

//
// Macros to wrap all API calls over the secure channel.
//
// Here's a sample calling sequence"
//
//      NL_API_START( Status, ClientSession, TRUE ) {
//
//          Status = /* Call the secure channel API */
//
//      } NL_API_ELSE ( Status, ClientSession, FALSE ) {
//
//          /* Do whatever you'd do if the secure channel was timed out */
//
//      } NL_API_END;


// Loop through each of the appropriate RPC bindings for this ClientSession.
// Avoid the real API call altogether if we can't bind.
#define NL_API_START_EX( _NtStatus, _ClientSession, _QuickApiCall, _ClientApi ) \
    { \
        ULONG _BindingLoopCount; \
\
        _NtStatus = RPC_NT_PROTSEQ_NOT_SUPPORTED; \
        for ( _BindingLoopCount=0; _BindingLoopCount<2; _BindingLoopCount++ ) { \
            _NtStatus = NlStartApiClientSession( (_ClientSession), (_QuickApiCall), _BindingLoopCount, _NtStatus, _ClientApi ); \
\
            if ( NT_SUCCESS(_NtStatus) ) {

#define NL_API_START( _NtStatus, _ClientSession, _QuickApiCall ) \
    NL_API_START_EX( _NtStatus, _ClientSession, _QuickApiCall, &(_ClientSession)->CsClientApi[0]  )



// If the real API indicates the endpoint isn't registered,
//     fall back to another binding.
//
// EPT_NT_NOT_REGISTERED: from NlStartApiClientSession
// RPC_NT_SERVER_UNAVAILABLE: From server if TCP not configured at all
// RPC_NT_PROTSEQ_NOT_SUPPORTED: From client or server if TCP/IP not supported
//

#define NL_API_ELSE_EX( _NtStatus, _ClientSession, _OkToKillSession, _AmWriter, _ClientApi ) \
\
            } \
\
            if ( _NtStatus == EPT_NT_NOT_REGISTERED || \
                 _NtStatus == RPC_NT_SERVER_UNAVAILABLE || \
                 _NtStatus == RPC_NT_PROTSEQ_NOT_SUPPORTED ) { \
                continue; \
            } \
\
            break; \
\
        } \
\
        if ( !NlFinishApiClientSession( (_ClientSession), (_OkToKillSession), (_AmWriter), (_ClientApi) ) ) {

#define NL_API_ELSE( _NtStatus, _ClientSession, _OkToKillSession ) \
    NL_API_ELSE_EX( _NtStatus, _ClientSession, _OkToKillSession, TRUE, &(_ClientSession)->CsClientApi[0] ) \



#define NL_API_END \
        } \
    } \

NTSTATUS
NlStartApiClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN BOOLEAN QuickApiCall,
    IN ULONG RetryIndex,
    IN NTSTATUS DefaultStatus,
    IN PCLIENT_API ClientApi
    );

BOOLEAN
NlFinishApiClientSession(
    IN PCLIENT_SESSION ClientSession,
    IN BOOLEAN OkToKillSession,
    IN BOOLEAN AmWriter,
    IN PCLIENT_API ClientApi
    );

VOID
NlTimeoutApiClientSession(
    IN PDOMAIN_INFO DomainInfo
    );

typedef
DWORD
(*PDsBindW)(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    HANDLE          *phDS);

typedef
DWORD
(*PDsUnBindW)(
    HANDLE          *phDS);             // in

typedef NTSTATUS
(*PCrackSingleName)(
    DWORD       formatOffered,
    DWORD       dwFlags,
    WCHAR       *pNameIn,
    DWORD       formatDesired,
    DWORD       *pccDnsDomain,
    WCHAR       *pDnsDomain,
    DWORD       *pccNameOut,
    WCHAR       *pNameOut,
    DWORD       *pErr);

typedef NTSTATUS
(*PGetConfigurationName)(
    DWORD       which,
    DWORD       *pcbName,
    DSNAME      *pName);

typedef NTSTATUS
(*PGetConfigurationNamesList)(
    DWORD                    which,
    DWORD                    dwFlags,
    ULONG *                  pcbNames,
    DSNAME **                padsNames);

typedef NTSTATUS
(*PGetDnsRootAlias)(
    WCHAR * pDnsRootAlias,
    WCHAR * pRootDnsRootAlias);

typedef DWORD
(*PDsGetServersAndSitesForNetLogon)(
    WCHAR *    pNDNC,
    SERVERSITEPAIR ** ppaRes);

typedef VOID
(*PDsFreeServersAndSitesForNetLogon)(
    SERVERSITEPAIR *         paServerSites);


NTSTATUS
NlLoadNtdsaDll(
    VOID
    );

//
// secpkg.c
//

PVOID
NlBuildAuthData(
    PCLIENT_SESSION ClientSession
    );

BOOL
NlStartNetlogonCall(
    VOID
    );

VOID
NlEndNetlogonCall(
    VOID
    );

//
// ssiapi.c
//

NTSTATUS
NlGetAnyDCName (
    IN  PCLIENT_SESSION ClientSession,
    IN  BOOL RequireIp,
    IN  BOOL DoDiscoveryWithAccount,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry,
    OUT PBOOLEAN DcRediscovered
    );

NET_API_STATUS
NlSetDsSPN(
    IN BOOLEAN Synchronous,
    IN BOOLEAN SetSpn,
    IN BOOLEAN SetDnsHostName,
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR UncDcName,
    IN LPWSTR ComputerName,
    IN LPWSTR DnsHostName
    );

NET_API_STATUS
NlPingDcName (
    IN  PCLIENT_SESSION ClientSession,
    IN  ULONG  DcNamePingFlags,
    IN  BOOL CachePingedDc,
    IN  BOOL RequireIp,
    IN  BOOL DoPingWithAccount,
    IN  BOOL RefreshClientSession,
    IN  LPWSTR DcName OPTIONAL,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry OPTIONAL
    );

VOID
NlFreePingContext(
    IN PNL_GETDC_CONTEXT PingContext
    );

VOID
NlScavengeOldChallenges(
    VOID
    );

VOID
NlRemoveChallenge(
    IN LPWSTR ClientName OPTIONAL,
    IN LPWSTR AccountName OPTIONAL,
    IN BOOL InterdomainTrustAccount
    );

//
// logonapi.c
//

NTSTATUS
NlpUserValidateHigher (
    IN PCLIENT_SESSION ClientSession,
    IN BOOLEAN DoingIndirectTrust,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags
    );

VOID
NlScavengeOldFailedLogons(
    IN PDOMAIN_INFO DomainInfo
    );


//
// ftinfo.c
//

NTSTATUS
NlpGetForestTrustInfoHigher(
    IN PCLIENT_SESSION ClientSession,
    IN DWORD Flags,
    IN BOOLEAN ImpersonateCaller,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\worker.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    worker.c

Abstract:

    This module implements a worker thread and a set of functions for
    passing work to it.

Author:

    Larry Osterman (LarryO) 13-Jul-1992


Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Number of worker threads to create and the usage count array.
//


#define NL_MAX_WORKER_THREADS 5
ULONG NlNumberOfCreatedWorkerThreads = 0;

ULONG NlWorkerThreadStats[NL_MAX_WORKER_THREADS];
PHANDLE NlThreadArray[NL_MAX_WORKER_THREADS];
BOOLEAN NlThreadExitted[NL_MAX_WORKER_THREADS];

//
// CritSect guard the WorkQueue list.
//

BOOLEAN NlWorkerInitialized = FALSE;
CRITICAL_SECTION NlWorkerCritSect;

#define LOCK_WORK_QUEUE() EnterCriticalSection(&NlWorkerCritSect);
#define UNLOCK_WORK_QUEUE() LeaveCriticalSection(&NlWorkerCritSect);

//
// Head of singly linked list of work items queued to the worker thread.
//

LIST_ENTRY NlWorkerQueueHead = {0};
LIST_ENTRY NlWorkerHighQueueHead = {0};

VOID
NlWorkerThread(
    IN PVOID StartContext
    )

{
    NET_API_STATUS NetStatus;
    ULONG ThreadIndex = (ULONG)((ULONG_PTR)StartContext);

    ULONG Index;
    PWORKER_ITEM WorkItem;

    HANDLE EventHandle = NULL;


    //
    // Every thread should loop until the queue is empty.
    //
    // This loop completes even though Netlogon has been asked to terminate.
    // The individual worker routines are designed to terminate quickly when netlogon
    //  is terminating.  This philosophy allows the worker routines to do there own
    //  cleanup.
    //

    while( TRUE ) {

        //
        // Pull an entry off the queue
        //
        // Prefer a workitem from the high priority queue
        //

        LOCK_WORK_QUEUE();

        if (!IsListEmpty(&NlWorkerHighQueueHead)) {
            WorkItem = (PWORKER_ITEM)RemoveHeadList( &NlWorkerHighQueueHead );
        } else if (!IsListEmpty(&NlWorkerQueueHead)) {
            WorkItem = (PWORKER_ITEM)RemoveHeadList( &NlWorkerQueueHead );
        } else {
            UNLOCK_WORK_QUEUE();
            break;
        }

        NlAssert(WorkItem->Inserted);
        WorkItem->Inserted = FALSE;

        NlWorkerThreadStats[NlNumberOfCreatedWorkerThreads-1] += 1;

        UNLOCK_WORK_QUEUE();

        NlPrint(( NL_WORKER, "%lx: Pulling off work item %lx (%lx)\n", ThreadIndex, WorkItem, WorkItem->WorkerRoutine));


        //
        // Execute the specified routine.
        //

        (WorkItem->WorkerRoutine)( WorkItem->Parameter );



        //
        // A thread can ditch dangling thread handles for the other threads.
        //
        // This will ensure there is at most one dangling thread handle.
        //

        LOCK_WORK_QUEUE();
        for (Index = 0; Index < NL_MAX_WORKER_THREADS; Index++ ) {
            if ( ThreadIndex != Index && NlThreadArray[Index] != NULL && NlThreadExitted[Index] ) {
                DWORD WaitStatus;
                NlPrint(( NL_WORKER, "%lx: %lx: Ditching worker thread\n", Index, NlThreadArray[Index]));

                // Always wait for the thread to exit before closing the handle to
                // ensure the thread has left netlogon.dll before we unload the dll.
                WaitStatus = WaitForSingleObject( NlThreadArray[Index], 0xffffffff );
                if ( WaitStatus != 0 ) {
                    NlPrint(( NL_CRITICAL, "%lx: worker thread handle cannot be awaited. %ld 0x%lX\n", Index, WaitStatus, NlThreadArray[Index] ));
                }
                if (!CloseHandle( NlThreadArray[Index] ) ) {
                    NlPrint(( NL_CRITICAL, "%lx: worker thread handle cannot be closed. %ld 0x%lX\n", Index, GetLastError(), NlThreadArray[Index] ));
                }

                NlThreadArray[Index] = NULL;
                NlThreadExitted[Index] = FALSE;
            }
        }
        UNLOCK_WORK_QUEUE();

    }

    NlPrint(( NL_WORKER, "%lx: worker thread exitting\n", ThreadIndex ));

    LOCK_WORK_QUEUE();
    NlThreadExitted[ThreadIndex] = TRUE;
    NlNumberOfCreatedWorkerThreads--;
    UNLOCK_WORK_QUEUE();

}

NET_API_STATUS
NlWorkerInitialization(
    VOID
    )
{
    ULONG ThreadId;

    NET_API_STATUS NetStatus;

    //
    // Perform initialization that allows us to call NlWorkerTermination
    //

    try {
        InitializeCriticalSection( &NlWorkerCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    InitializeListHead( &NlWorkerQueueHead );
    InitializeListHead( &NlWorkerHighQueueHead );
    NlNumberOfCreatedWorkerThreads = 0;


    RtlZeroMemory( NlThreadArray, sizeof(NlThreadArray) );
    RtlZeroMemory( NlThreadExitted, sizeof(NlThreadExitted) );
    RtlZeroMemory( NlWorkerThreadStats, sizeof(NlWorkerThreadStats) );

    NlWorkerInitialized = TRUE;


    return NERR_Success;
}

VOID
NlWorkerKillThreads(
    VOID
    )

/*++

Routine Description:

    Terminate all worker threads.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Index;

    //
    // Wait for all the threads to exit.
    //

    for ( Index = 0; Index < NL_MAX_WORKER_THREADS; Index ++ ) {
        if ( NlThreadArray[Index] != NULL ) {
            DWORD WaitStatus;
            NlPrint(( NL_WORKER, "%lx: %lx: Ditching worker thread\n", Index, NlThreadArray[Index]));

            // Always wait for the thread to exit before closing the handle to
            // ensure the thread has left netlogon.dll before we unload the dll.
            WaitStatus = WaitForSingleObject( NlThreadArray[Index], 0xffffffff );
            if ( WaitStatus != 0 ) {
                NlPrint(( NL_CRITICAL, "%lx: worker thread handle cannot be awaited. %ld 0x%lX\n", Index, WaitStatus, NlThreadArray[Index] ));
            }

            if (!CloseHandle( NlThreadArray[Index] ) ) {
                NlPrint(( NL_CRITICAL, "%lx: worker thread handle cannot be closed. %ld 0x%lX\n", Index, GetLastError(), NlThreadArray[Index] ));
            }
            NlThreadArray[Index] = NULL;
            NlThreadExitted[Index] = FALSE;
        }

    }

    return;
}

VOID
NlWorkerTermination(
    VOID
    )

/*++

Routine Description:

    Undo initialization of the worker threads.

Arguments:

    None.

Return Value:

    Status value -

--*/
{

    //
    // Only cleanup if we've successfully initialized.
    //

    if ( NlWorkerInitialized ) {

        //
        //
        // Ensure the threads have been terminated.
        //

        NlWorkerKillThreads();

        DeleteCriticalSection( &NlWorkerCritSect );
        NlWorkerInitialized = FALSE;
    }

    return;
}

BOOL
NlQueueWorkItem(
    IN PWORKER_ITEM WorkItem,
    IN BOOL InsertNewItem,
    IN BOOL HighPriority
    )

/*++

Routine Description:

    This function modifies the work item queue by either inserting
    a new specified work item to a specified queue or increasing the
    priority of the already inserted item to the highest priority
    in the specified queue.

Arguments:

    WorkItem - Supplies a pointer to the work item to add the the queue.
        It is the caller's responsibility to reclaim the storage occupied by
        the WorkItem structure.

    InsertNewItem - If TRUE, we are to insert the new item into the queue
        specified by the value of the HighPriority parameter; the new item
        will be inserted at the end of the queue.  Otherwise, we are to
        modify (boost) the priority of already inserted work item by moving
        it to the front of the queue specified by the HighPriority value.
        If TRUE and the item is already inserted (as determined by this
        routine), this routine is no-op except for some possible cleanup.
        If FALSE and the item is not already inserted (as determined by
        this routine), this routine is no-op except for some possible cleanup.

    HighPriority - The queue entry should be processed at a higher priority than
        normal.

Return Value:

    TRUE if item got queued or modified

--*/

{
    ULONG Index;

    //
    // Ignore this attempt if the worker threads aren't initialized.
    //

    if ( !NlWorkerInitialized ) {
        NlPrint(( NL_CRITICAL, "NlQueueWorkItem when worker not initialized\n"));
        return FALSE;
    }


    //
    // Ditch any dangling thread handles
    //

    LOCK_WORK_QUEUE();
    for (Index = 0; Index < NL_MAX_WORKER_THREADS; Index++ ) {
        if ( NlThreadArray[Index] != NULL && NlThreadExitted[Index] ) {
            DWORD WaitStatus;
            NlPrint(( NL_WORKER, "%lx: %lx: Ditching worker thread\n", Index, NlThreadArray[Index]));

            // Always wait for the thread to exit before closing the handle to
            // ensure the thread has left netlogon.dll before we unload the dll.
            WaitStatus = WaitForSingleObject( NlThreadArray[Index], 0xffffffff );
            if ( WaitStatus != 0 ) {
                NlPrint(( NL_CRITICAL, "%lx: worker thread handle cannot be awaited. %ld 0x%lX\n", Index, WaitStatus, NlThreadArray[Index] ));
            }

            if (!CloseHandle( NlThreadArray[Index] ) ) {
                NlPrint(( NL_CRITICAL, "%lx: worker thread handle cannot be closed. %ld 0x%lX\n", Index, GetLastError(), NlThreadArray[Index] ));
            }

            NlThreadArray[Index] = NULL;
            NlThreadExitted[Index] = FALSE;
        }
    }


    //
    // If we are to insert a new work item,
    //  do so
    //

    if ( InsertNewItem ) {

        //
        // If the work item is already inserted,
        //  we are done expect for some possible
        //  cleanup
        //
        if ( WorkItem->Inserted ) {

            //
            // If there is no worker thread processing this
            //  work item (i.e. we failed to create a thread
            //  at the time this work item was inserted),
            //  fall through and retry to create a thread
            //  below. Otherwise, we are done.
            //
            if ( NlNumberOfCreatedWorkerThreads > 0 ) {
                UNLOCK_WORK_QUEUE();
                return TRUE;
            }

        //
        // Otherwise, insert this work item
        //
        } else  {

            NlPrint(( NL_WORKER, "Inserting work item %lx (%lx)\n",WorkItem, WorkItem->WorkerRoutine));

            if ( HighPriority ) {
                InsertTailList( &NlWorkerHighQueueHead, &WorkItem->List );
            } else {
                InsertTailList( &NlWorkerQueueHead, &WorkItem->List );
            }
            WorkItem->Inserted = TRUE;
        }

    //
    // Otherwise, we are to boost the priority
    //  of an already inserted work item
    //

    } else {

        //
        // If the work item isn't already inserted,
        //  we are done
        //
        if ( !WorkItem->Inserted ) {
            UNLOCK_WORK_QUEUE();
            return TRUE;

        //
        // Otherwise, boost the priority
        //
        } else  {
            NlPrint(( NL_WORKER,
                      "Boosting %s priority work item %lx (%lx)\n",
                      (HighPriority ? "high" : "low"),
                      WorkItem,
                      WorkItem->WorkerRoutine ));

            RemoveEntryList( &WorkItem->List );
            if ( HighPriority ) {
                InsertHeadList( &NlWorkerHighQueueHead, &WorkItem->List );
            } else {
                InsertHeadList( &NlWorkerQueueHead, &WorkItem->List );
            }

            //
            // If there is no worker thread processing this
            //  work item (i.e. we failed to create a thread
            //  at the time this work item was inserted),
            //  fall through and retry to create a thread
            //  below. Otherwise, we are done.
            //
            if ( NlNumberOfCreatedWorkerThreads > 0 ) {
                UNLOCK_WORK_QUEUE();
                return TRUE;
            }
        }
    }


    //
    //  If there isn't a worker thread to handle the request,
    //      create one now.
    //

    if ( NlNumberOfCreatedWorkerThreads < NL_MAX_WORKER_THREADS ) {

        //
        // Find a spot for the thread handle.
        //

        for (Index = 0; Index < NL_MAX_WORKER_THREADS; Index++ ) {
            if ( NlThreadArray[Index] == NULL ) {
                break;
            }
        }


        if ( Index >= NL_MAX_WORKER_THREADS ) {
            NlPrint(( NL_CRITICAL, "NlQueueWorkItem: Internal Error\n" ));
            UNLOCK_WORK_QUEUE();
            return FALSE;
        } else {
            DWORD ThreadId;
            NlThreadArray[Index] = CreateThread(
                                       NULL, // No security attributes
                                       0,
                                       (LPTHREAD_START_ROUTINE)NlWorkerThread,
                                       (PVOID) ULongToPtr( Index ),
                                       0,    // No special creation flags
                                       &ThreadId );

            NlPrint(( NL_WORKER, "%lx: %lx: %lx: Starting worker thread\n", Index, NlThreadArray[Index], ThreadId ));

            //
            // Note that if we fail to create a thread,
            //  the work item remains queued and possibly not processed.
            //  This is not critical because the item will be processed
            //  next time a work item gets queued which will happen at
            //  the next scavenging time at latest.
            //
            if (NlThreadArray[Index] == NULL) {
                NlPrint((NL_CRITICAL,
                        "NlQueueWorkItem: Cannot create thread %ld\n", GetLastError() ));
            } else {
                NlNumberOfCreatedWorkerThreads++;
            }


        }
    }

    UNLOCK_WORK_QUEUE();

    return TRUE;
}


#ifdef notdef   // Don't need timers yet
NET_API_STATUS
NlCreateTimer(
    IN PNlOWSER_TIMER Timer
    )
{
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;

    InitializeObjectAttributes(&ObjA, NULL, 0, NULL, NULL);

    Status = NtCreateTimer(&Timer->TimerHandle,
                           TIMER_ALL_ACCESS,
                           &ObjA,
                           NotificationTimer);

    if (!NT_SUCCESS(Status)) {
        NlPrint(( NL_CRITICAL, "Failed to create timer %lx: %X\n", Timer, Status));
        return(NlMapStatus(Status));
    }

    NlPrint(( Nl_TIMER, "Creating timer %lx: Handle: %lx\n", Timer, Timer->TimerHandle));

    return(NERR_Success);
}

NET_API_STATUS
NlDestroyTimer(
    IN PNlOWSER_TIMER Timer
    )
{
    HANDLE Handle;

    //
    // Avoid destroying a timer twice.
    //

    if ( Timer->TimerHandle == NULL ) {
        return NERR_Success;
    }

    // Closing doesn't automatically cancel the timer.
    (VOID) NlCancelTimer( Timer );

    //
    // Close the handle and prevent future uses.
    //

    Handle = Timer->TimerHandle;
    Timer->TimerHandle = NULL;

    NlPrint(( Nl_TIMER, "Destroying timer %lx\n", Timer));
    return NlMapStatus(NtClose(Handle));

}

NET_API_STATUS
NlCancelTimer(
    IN PNlOWSER_TIMER Timer
    )
{
    //
    // Avoid cancelling a destroyed timer.
    //

    if ( Timer->TimerHandle == NULL ) {
        NlPrint(( Nl_TIMER, "Canceling destroyed timer %lx\n", Timer));
        return NERR_Success;
    }

    NlPrint(( Nl_TIMER, "Canceling timer %lx\n", Timer));
    return NlMapStatus(NtCancelTimer(Timer->TimerHandle, NULL));
}

NET_API_STATUS
NlSetTimer(
    IN PNlOWSER_TIMER Timer,
    IN ULONG MillisecondsToExpire,
    IN PNlOWSER_WORKER_ROUTINE WorkerFunction,
    IN PVOID Context
    )
{
    LARGE_INTEGER TimerDueTime;
    NTSTATUS NtStatus;
    //
    // Avoid setting a destroyed timer.
    //

    if ( Timer->TimerHandle == NULL ) {
        NlPrint(( Nl_TIMER, "Setting a destroyed timer %lx\n", Timer));
        return NERR_Success;
    }

    NlPrint(( Nl_TIMER, "Setting timer %lx to %ld milliseconds, WorkerFounction %lx, Context: %lx\n", Timer, MillisecondsToExpire, WorkerFunction, Context));

    //
    //  Figure out the timeout.
    //

    TimerDueTime.QuadPart = Int32x32To64( MillisecondsToExpire, -10000 );

    NlInitializeWorkItem(&Timer->WorkItem, WorkerFunction, Context);

    //
    //  Set the timer to go off when it expires.
    //

    NtStatus = NtSetTimer(Timer->TimerHandle,
                            &TimerDueTime,
                            NlTimerRoutine,
                            Timer,
                            FALSE,
                            0,
                            NULL
                            );

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        NlPrint(( NL_CRITICAL, "Unable to set Netlogon timer expiration: %X (%lx)\n", NtStatus, Timer));
        DbgbreakPoint();
#endif

        return(NlMapStatus(NtStatus));
    }

    return NERR_Success;


}

VOID
NlTimerRoutine(
    IN PVOID TimerContext,
    IN ULONG TImerLowValue,
    IN LONG TimerHighValue
    )
{
    PNlOWSER_TIMER Timer = TimerContext;

    NlPrint(( Nl_TIMER, "Timer %lx fired\n", Timer));

    NlQueueWorkItem(&Timer->WorkItem);
}
#endif // notdef   // Don't need timers yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\client\msgsvc_c_stub.c ===
#include "msgsvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\tests\sitey.c ===
// Test DsAddressToSiteNames API
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddbrow.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <lmcons.h>
// #include <nlsite.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <lmapibuf.h>

#define AllocSplMem( _x) LocalAlloc( 0, _x)
#define DBGMSG( _x, _y) printf

VOID
AllocSplSockets(
    struct hostent  *pHostEnt,
    PSOCKET_ADDRESS *ppSocketAddress,
    DWORD           *nSocketAddresses
)
{
    DWORD           i;
    PSOCKET_ADDRESS pSocket;


    // Allocate Sockaddr element for each SOCKET_ADDRESS
    // If we fail partway through, just use partial list
    for ( i= 0 ; pHostEnt->h_addr_list[i] ; i++) {

        pSocket = &((*ppSocketAddress)[*nSocketAddresses]);
        if (!(pSocket->lpSockaddr = (struct sockaddr *) AllocSplMem(sizeof(struct sockaddr_in)))) {
            break;
        }
        ((struct sockaddr_in *) pSocket->lpSockaddr)->sin_family = AF_INET;
        ((struct sockaddr_in *) pSocket->lpSockaddr)->sin_addr = *(struct in_addr *) pHostEnt->h_addr_list[i];
        pSocket->iSockaddrLength = sizeof(struct sockaddr_in);
        *nSocketAddresses += 1;
    }
}


VOID
GetSocketAddressesFromMachineName(
    PSTR           pszAnsiMachineName,     // Machine
    PSOCKET_ADDRESS *ppSocketAddress,
    DWORD           *nSocketAddresses
)
/*++

Routine Description:
    This routine builds list of names other than the machine name that
    can be used to call spooler APIs.

--*/
{
    struct hostent     *HostEnt;
    DWORD               iWsaError;

            if (HostEnt = gethostbyname(pszAnsiMachineName)) {
                AllocSplSockets(HostEnt, ppSocketAddress, nSocketAddresses);
            } else {
                iWsaError = WSAGetLastError();
                printf("gethostbyname failed: %d\n", iWsaError);
            }
}


__cdecl main (int argc, char *argv[])
{
    NET_API_STATUS NetStatus;
    SOCKET_ADDRESS* SocketAddresses;
    ULONG EntryCount;
    LPWSTR *SiteNames;
    LPSTR *SiteNamesA;
    LPWSTR *SubnetNames;
    LPSTR *SubnetNamesA;
    ULONG i;
    int j;
    char *end;
    BOOLEAN Verbose = FALSE;

    if ( argc < 2 ) {
Usage:
        printf("Usage: %s [-s:<ServerName>] [-v] <HostNames>\n", argv[0] );
        return 1;
    }


   {
       WORD wVersionRequested;
       WSADATA wsaData;
       int err;
       //
       // Initialize winsock.
       //

       wVersionRequested = MAKEWORD( 1, 1 );

       NetStatus = WSAStartup( wVersionRequested, &wsaData );
       if ( NetStatus != 0 ) {
           printf("NETAPI32.DLL: Cannot initialize winsock %ld.\n", NetStatus );
           return NetStatus;
       }

       if ( LOBYTE( wsaData.wVersion ) != 1 ||
            HIBYTE( wsaData.wVersion ) != 1 ) {
           WSACleanup();
           printf("NETAPI32.DLL: Wrong winsock version %ld.\n", NetStatus );
           return WSANOTINITIALISED;
       }

   }



   //
   // Build an array of socket addresses
   //
   SocketAddresses = (PSOCKET_ADDRESS) AllocSplMem(5000*sizeof(SOCKET_ADDRESS));
   EntryCount = 0;
   for ( j=1; j<argc; j++ ) {

       if ( strcmp(argv[j], "-v") == 0 ) {
           Verbose = TRUE;
       } else if ( strncmp( argv[j], "-s:", 3 ) {
           AnsiServerName = &argv[j][3];
       } else {
           GetSocketAddressesFromMachineName(
                                             argv[j],
                                             &SocketAddresses,
                                             &EntryCount );
       }
   }

   //
   // Only do all of the API of verbose
   //
   if ( Verbose ) {

       //
       // Do it in unicode
       //

       printf( "\nUse DsAddressToSiteNamesW API:\n" );

       NetStatus = DsAddressToSiteNamesW(
                           NULL,
                           EntryCount,
                           SocketAddresses,
                           &SiteNames );

       if ( NetStatus != NO_ERROR ) {
           printf( "Translation Failed %ld\n", NetStatus );
           return 0;
       }

       for ( i=0; i<EntryCount; i++ ) {
           if ( SiteNames[i] == NULL ) {
               printf( "SiteName %ld doesn't map.\n", i );
           } else {
               printf( "SiteName %ld: %ws\n", i, SiteNames[i] );
           }
       }

       NetApiBufferFree( SiteNames );


       //
       // Do it in ANSI
       //

       printf( "\nUse DsAddressToSiteNamesA API:\n" );

       NetStatus = DsAddressToSiteNamesA(
                           NULL,
                           EntryCount,
                           SocketAddresses,
                           &SiteNamesA );

       if ( NetStatus != NO_ERROR ) {
           printf( "Translation Failed %ld\n", NetStatus );
           return 0;
       }

       for ( i=0; i<EntryCount; i++ ) {
           if ( SiteNamesA[i] == NULL ) {
               printf( "SiteName %ld doesn't map.\n", i );
           } else {
               printf( "SiteName %ld: %s\n", i, SiteNamesA[i] );
           }
       }

       NetApiBufferFree( SiteNamesA );

       //
       // Do it in unicode (with subnet)
       //

       printf( "\nUse DsAddressToSiteNamesExW API:\n" );

       NetStatus = DsAddressToSiteNamesExW(
                           NULL,
                           EntryCount,
                           SocketAddresses,
                           &SiteNames,
                           &SubnetNames );

       if ( NetStatus != NO_ERROR ) {
           printf( "Translation Failed %ld\n", NetStatus );
           return 0;
       }

       for ( i=0; i<EntryCount; i++ ) {
           printf( "SiteName %ld: %ws %ws\n", i, SiteNames[i], SubnetNames[i] );
       }

       NetApiBufferFree( SiteNames );
       NetApiBufferFree( SubnetNames );

       printf( "\nUse DsAddressToSiteNamesExA API:\n" );
   }


    //
    // Do it in ANSI
    //

    NetStatus = DsAddressToSiteNamesExA(
                        NULL,
                        EntryCount,
                        SocketAddresses,
                        &SiteNamesA,
                        &SubnetNamesA );

    if ( NetStatus != NO_ERROR ) {
        printf( "Translation Failed %ld\n", NetStatus );
        return 0;
    }

    for ( i=0; i<EntryCount; i++ ) {
        printf( "SiteName %ld: %s %s\n", i, SiteNamesA[i], SubnetNamesA[i] );
    }

    NetApiBufferFree( SiteNamesA );
    NetApiBufferFree( SubnetNamesA );



    printf( "Done\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\tests\site.c ===
#define NL_MAX_DNS_LABEL_LENGTH 63
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddbrow.h>
#include <windows.h>
#include <stdio.h>
#include <lmcons.h>
#include <winsock2.h>
#include <nlsite.h>
#include <dsgetdc.h>
#include <nlcommon.h>

#define MAX_PRINTF_LEN 1024        // Arbitrary.
VOID
NlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
{
    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    (VOID) vsprintf(OutputBuffer, Format, arglist);
    va_end(arglist);

    printf( "%s", OutputBuffer );
    return;
    UNREFERENCED_PARAMETER( DebugFlag );
}

VOID
NlAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
        printf( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

}


NTSTATUS
NlBrowserSendDatagram(
    IN PVOID ContextDomainInfo,
    IN ULONG IpAddress,
    IN LPWSTR UnicodeDestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )
/*++

Routine Description:

    Send the specified mailslot message to the specified mailslot on the
    specified server on the specified transport..

Arguments:

    DomainInfo - Hosted domain sending the datagram

    IpAddress - IpAddress of the machine to send the pind to.
        If zero, UnicodeDestinationName must be specified.

    UnicodeDestinationName -- Name of the server to send to.

    NameType -- Type of name represented by UnicodeDestinationName.

    TransportName -- Name of the transport to send on.
        Use NULL to send on all transports.

    OemMailslotName -- Name of the mailslot to send to.

    Buffer -- Specifies a pointer to the mailslot message to send.

    BufferSize -- Size in bytes of the mailslot message

Return Value:

    Status of the operation.

--*/
{
    return STATUS_INTERNAL_ERROR;
    // If this routine is ever needed, copy it from logonsrv\client\getdcnam.c

    UNREFERENCED_PARAMETER(ContextDomainInfo);
    UNREFERENCED_PARAMETER(IpAddress);
    UNREFERENCED_PARAMETER(UnicodeDestinationName);
    UNREFERENCED_PARAMETER(NameType);
    UNREFERENCED_PARAMETER(TransportName);
    UNREFERENCED_PARAMETER(OemMailslotName);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);
}

NET_API_STATUS
NlGetLocalPingResponse(
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN BOOL PdcOnly,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN ULONG NtVersion,
    IN ULONG NtVersionFlags,
    OUT PSOCKET_ADDRESS *ResponseDcAddress,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    )

/*++

Routine Description:

    Build the message to ping a DC to see if it exists.

Arguments:

    NetbiosDomainName - Netbios Domain Name of the domain to query.

    DnsDomainName - DNS Domain Name of the domain to query.

    PdcOnly - True if only the PDC should respond.

    UnicodeComputerName - Netbios computer name of the machine to respond to.

    UnicodeUserName - Account name of the user being pinged.
        If NULL, DC will always respond affirmatively.

    AllowableAccountControlBits - Mask of allowable account types for UnicodeUserName.

    NtVersion - Version of the message

    NtVersionFlags - Version of the message.
        0: For backward compatibility.
        NETLOGON_NT_VERSION_5: for NT 5.0 message.

    Message - Returns the message to be sent to the DC in question.
        Buffer must be free using NetpMemoryFree().

    MessageSize - Returns the size (in bytes) of the returned message


Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NO_SUCH_DOMAIN - If the machine isn't a DC for the requested domain.

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    // This stub routine simply does nothing harmful
    return ERROR_NO_SUCH_DOMAIN;
    UNREFERENCED_PARAMETER( NetbiosDomainName );
    UNREFERENCED_PARAMETER( DnsDomainName );
    UNREFERENCED_PARAMETER( DomainGuid );
    UNREFERENCED_PARAMETER( DomainSid );
    UNREFERENCED_PARAMETER( PdcOnly );
    UNREFERENCED_PARAMETER( UnicodeComputerName );
    UNREFERENCED_PARAMETER( UnicodeUserName );
    UNREFERENCED_PARAMETER( AllowableAccountControlBits );
    UNREFERENCED_PARAMETER( NtVersion );
    UNREFERENCED_PARAMETER( NtVersionFlags );
    UNREFERENCED_PARAMETER( ResponseDcAddress );
    UNREFERENCED_PARAMETER( Message );
    UNREFERENCED_PARAMETER( MessageSize );
}


VOID
NlpDumpBuffer(
    IN DWORD DebugFlag,
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to NlPrintRoutine

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf(0,"   ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    UNREFERENCED_PARAMETER( DebugFlag );
}

VOID
DoAdd(
      IN LPWSTR SubnetName,
      IN LPWSTR SiteName
      )
{
    ULONG SubnetAddress;
    ULONG SubnetMask;
    BYTE SubnetBitCount;
    NET_API_STATUS NetStatus;


    NetStatus = NlParseSubnetString( SubnetName,
                                     &SubnetAddress,
                                     &SubnetMask,
                                     &SubnetBitCount );

    if ( NetStatus != NO_ERROR ) {
        return;
    }

    printf( "Doing %ws %8.8lX %8.8lX %ld\n",
                SubnetName, SubnetAddress, SubnetMask, SubnetBitCount );

    NetStatus = NlSitesAddSubnet( SiteName, SubnetName );

    if ( NetStatus != NO_ERROR ) {
        printf("Cannot add site %ws %ws %ld\n", SiteName, SubnetName, NetStatus );
        return;
    }

}


VOID
DoLook(
      IN LPWSTR IpAddress
      )
{
    INT WsaStatus;
    SOCKADDR SockAddr;
    INT SockAddrSize;
    PNL_SITE_ENTRY SiteEntry;

    //
    // Convert the address to a sockaddr
    //

    SockAddrSize = sizeof(SockAddr);
    WsaStatus = WSAStringToAddressW( IpAddress,
                                     AF_INET,
                                     NULL,
                                     (PSOCKADDR)&SockAddr,
                                     &SockAddrSize );
    if ( WsaStatus != 0 ) {
        WsaStatus = WSAGetLastError();
        printf("DoLook: %ws: Wsa Error %ld\n", IpAddress, WsaStatus );
        return;
    }

    if ( SockAddr.sa_family != AF_INET ) {
        printf("DoLook: %ws: address not AF_INET\n", IpAddress );
        return;
    }


    SiteEntry = NlFindSiteEntryBySockAddr( &SockAddr );

    if ( SiteEntry == NULL ) {
        printf("DoLook: %ws: address cannot be found\n", IpAddress );
        return;
    }

    printf("%ws is in site %ws\n", IpAddress, SiteEntry->SiteName );

    NlDerefSiteEntry( SiteEntry );

}

__cdecl main (int argc, char *argv[])
{
    NET_API_STATUS NetStatus;
    PNL_SITE_ENTRY Site1;
    PNL_SITE_ENTRY Site2;
    PNL_SITE_ENTRY Site3;

    WORD wVersionRequested;
    WSADATA wsaData;
    int err;

    //
    // Initialize winsock.
    //

    wVersionRequested = MAKEWORD( 1, 1 );

    NetStatus = WSAStartup( wVersionRequested, &wsaData );
    if ( NetStatus != 0 ) {
        printf( "NETAPI32.DLL: Cannot initialize winsock %ld.\n", NetStatus );
        return NetStatus;
    }

    if ( LOBYTE( wsaData.wVersion ) != 1 ||
         HIBYTE( wsaData.wVersion ) != 1 ) {
        WSACleanup();
        printf( "NETAPI32.DLL: Wrong winsock version %ld.\n", wsaData.wVersion );
        return WSANOTINITIALISED;
    }


    //
    // Init
    NetStatus = NlSiteInitialize();

    if ( NetStatus != NO_ERROR ) {
        printf( "Cannot NlSiteInitialize %ld\n", NetStatus );
        return 1;
    }

#ifdef notdef
    //
    // Add some sites.
    //

    Site1 = NlFindSiteEntry( L"Site 1" );

    if ( Site1 == NULL ) {
        printf( "Cannot Create Site1\n");
        return 1;
    }
    printf( "%lx: %ws\n", Site1, Site1->SiteName );

    Site2 = NlFindSiteEntry( L"Site 1" );

    if ( Site2 == NULL ) {
        printf( "Cannot Create Site2\n");
        return 2;
    }
    printf( "%lx: %ws\n", Site2, Site2->SiteName );

    Site3 = NlFindSiteEntry( L"Site 3" );

    if ( Site3 == NULL ) {
        printf( "Cannot Create Site3\n");
        return 3;
    }
    printf( "%lx: %ws\n", Site3, Site3->SiteName );


    NlDerefSiteEntry( Site1 );
    NlDerefSiteEntry( Site2 );
    NlDerefSiteEntry( Site3 );
#endif // notdef

    //
    // Test invalid subnet strings
    //
#ifdef notdef
    DoAdd( L"999.0.0.0/1", L"Site 1" );
    DoAdd( L"1.0.0.0/0", L"Site 1" );
    DoAdd( L"1.0.0.0/1", L"Site 1" );
    DoAdd( L"1.0.0.0/33", L"Site 1" );
    DoAdd( L"1.0.0.0/1p", L"Site 1" );
    DoAdd( L"1.0.0.0", L"Site 1" );
    DoAdd( L"128.0.0.0/1", L"Site 1" );
    DoAdd( L"128.0.0.0/2", L"Site 1" );
    DoAdd( L"128.0.0.0/3", L"Site 1" );
    DoAdd( L"128.0.0.0/4", L"Site 1" );
    DoAdd( L"128.0.0.0/5", L"Site 1" );
    DoAdd( L"128.0.0.0/6", L"Site 1" );
    DoAdd( L"128.0.0.0/7", L"Site 1" );
    DoAdd( L"128.0.0.0/8", L"Site 1" );
    DoAdd( L"128.0.0.0/9", L"Site 1" );
    DoAdd( L"128.0.0.0/10", L"Site 1" );
    DoAdd( L"128.0.0.0/11", L"Site 1" );
    DoAdd( L"128.0.0.0/12", L"Site 1" );
    DoAdd( L"128.0.0.0/13", L"Site 1" );
    DoAdd( L"128.0.0.0/14", L"Site 1" );
    DoAdd( L"128.0.0.0/15", L"Site 1" );
    DoAdd( L"128.0.0.0/16", L"Site 1" );
    DoAdd( L"128.0.0.0/17", L"Site 1" );
    DoAdd( L"128.0.0.0/18", L"Site 1" );
    DoAdd( L"128.0.0.0/19", L"Site 1" );
    DoAdd( L"128.0.0.0/20", L"Site 1" );
    DoAdd( L"128.0.0.0/21", L"Site 1" );
    DoAdd( L"128.0.0.0/22", L"Site 1" );
    DoAdd( L"128.0.0.0/23", L"Site 1" );
    DoAdd( L"128.0.0.0/24", L"Site 1" );
    DoAdd( L"128.0.0.0/25", L"Site 1" );
    DoAdd( L"128.0.0.0/26", L"Site 1" );
    DoAdd( L"128.0.0.0/27", L"Site 1" );
    DoAdd( L"128.0.0.0/28", L"Site 1" );
    DoAdd( L"128.0.0.0/29", L"Site 1" );
    DoAdd( L"128.0.0.0/30", L"Site 1" );
    DoAdd( L"128.0.0.0/31", L"Site 1" );
    DoAdd( L"128.0.0.0/32", L"Site 1" );
#endif // notdef

    {
        ULONG i;
        for ( i=0; i<2; i++ ) {
            DoAdd( L"128.0.0.0/8", L"Site 1" );
            DoAdd( L"128.0.0.0/7", L"Site 2" );
            DoAdd( L"128.0.0.0/8", L"Site 3" );
            // DoAdd( L"128.0.0.0/1", L"Site 4" );
            DoAdd( L"157.55.0.0/16", L"Site 5" );
            DoAdd( L"157.55.80.0/20", L"Site 6" );


            NlSitesEndSubnetEnum();
        }
    }
    DoLook( L"157.55.95.68" );
    DoLook( L"157.55.24.68" );

#ifdef notdef
    DoAdd( L"157.55.0.0/16", L"Site 1" );
    DoAdd( L"157.55.240.0/20", L"Site 1" );
    DoAdd( L"128.0.0.0/1", L"Site 1" );
#endif // notdef

    //
    // Done.
    //
    NlSiteTerminate();
    printf( "Done\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\server\tests\sitecov.c ===
#define NL_MAX_DNS_LABEL_LENGTH 63
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <shellapi.h>

// #include <winsock2.h>
// #include <dnsapi.h>
#include <lmcons.h>
#include <lmerr.h>
#include <ismapi.h>
#include <rpc.h>
#include <ntdsapi.h>
#include <ntdsa.h>
// #include <dnssubr.h>
#include <nldebug.h>
// #include <tstring.h>

//
// Grab random stuff needed from Netlogon's environment.
//
LPWSTR NlGlobalUnicodeSiteName;
BOOLEAN NlGlobalMemberWorkstation = FALSE;
CRITICAL_SECTION NlGlobalLogFileCritSect;

#define MAX_PRINTF_LEN 1024        // Arbitrary.
VOID
NlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
{
    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    (VOID) vsprintf(OutputBuffer, Format, arglist);
    va_end(arglist);

    printf( "%s", OutputBuffer );
    return;
    UNREFERENCED_PARAMETER( DebugFlag );
}

VOID
NlAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
        printf( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

}

BOOL
NlCaptureSiteName(
    WCHAR CapturedSiteName[NL_MAX_DNS_LABEL_LENGTH+1]
    )
/*++

Routine Description:

    Capture the current sitename of the site this machine is in.

Arguments:

    CapturedSiteName - Returns the name of the site this machine is in.

Return Value:

    TRUE - if there is a site name.
    FALSE - if there is no site name.

--*/
{
    BOOL RetVal;

    if ( NlGlobalUnicodeSiteName == NULL ) {
        CapturedSiteName[0] = L'\0';
        RetVal = FALSE;
    } else {
        wcscpy( CapturedSiteName, NlGlobalUnicodeSiteName );
        RetVal = TRUE;
    }

    return RetVal;
}

NTSTATUS
GetConfigurationName(
    DWORD       which,
    DWORD       *pcbName,
    DSNAME      *pName)

/*++

Description:

    Routine for in-process clients like LSA to learn about various names
    we have cached in gAnchor.

    This routine intentionally does not require a THSTATE or DBPOS.

Arguments:

    which - Identifies a DSCONFIGNAME value.

    pcbName - On input holds the byte count of the pName buffer.  On
        STATUS_BUFFER_TOO_SMALL error returns the count of bytes required.

    pName - Pointer to user provided output buffer.

Return Values:

    STATUS_SUCCESS on success.
    STATUS_INVALID_PARAMETER on bad parameter.
    STATUS_BUFFER_TOO_SMALL if buffer is too small.
    STATUS_NOT_FOUND if we don't have the name.  Note that this can
        happen if caller is too early in the boot cycle.

--*/

{
    ULONG Length;

#define MAGIC L"CN=Configuration,DC=cliffvdom,DC=nttest,DC=microsoft,DC=com"

    Length = sizeof(DSNAME) + sizeof(MAGIC);

    if ( *pcbName < Length ) {
        *pcbName = Length;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    if ( pName != NULL ) {

        pName->NameLen = sizeof(MAGIC) - sizeof(WCHAR);
        wcscpy( pName->StringName, MAGIC );

    } else {

        return( STATUS_INVALID_PARAMETER );
    }

    return(STATUS_SUCCESS);
}


_cdecl
main(int argc, char **argv)
{
    NET_API_STATUS NetStatus;

    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argcw;

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW( CommandLine, &argcw );

    if ( argvw == NULL ) {
        fprintf( stderr, "Can't convert command line to Unicode: %ld\n", GetLastError() );
        return 1;
    }

    //
    // Set the site name.
    //

    if ( argcw != 2 ) {
// Usage:
        printf( "Usage: %ws <SiteDcIsIn>\n", argv[0]);
        return -1;
    }

    NlGlobalUnicodeSiteName = argvw[1];

    //
    // Misc environment initialization
    //

    RtlInitializeCriticalSection( &NlGlobalLogFileCritSect );


    //
    // Compute the site coverage.
    //

    NlSitesUpdateSiteCoverage( L"cliffvdom.nttest.microsoft.com", TRUE );


    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\idl\imports.h ===
#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#ifdef UNICODE
#define LPWSTR [string] wchar_t*
#endif
#endif

#include <lmmsg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\client\msgstub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgstub.c

Abstract:

    These are the Messenger Service API RPC client stubs.

Author:

    Dan Lafferty    (danl)  06-Feb-1991

Environment:

    User Mode - Win32

Revision History:
    
    27-Aug-1992     Danl
        Added downlevel support & removed error mapping for RPC errors.

    06-Feb-1991     Danl
        Created

--*/

//
// INCLUDES
//

#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <rpc.h>        // DataTypes and runtime APIs

#include <msgsvc.h>     // generated by the MIDL complier
#include <rpcutil.h>    // NetRpc utils

#include <lmsvc.h> 
#include <lmcons.h>     // NET_API_STATUS
#include <lmerr.h>      // NetError codes
#include <rxmsg.h>      // RxNetMessage API
#include <netlib.h>     // NetpServiceIsStarted() (needed by netrpc.h).
#include <netdebug.h>   // needed for netrpc.h
#include <netrpc.h>     // NET_REMOTE macros.



NET_API_STATUS NET_API_FUNCTION
NetMessageNameAdd (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  msgname
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetMessageNameAdd.  This API adds a name
    to the message name table.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.

    msgname - Pointer to a string containing the name to be added.


Return Value:

    NERR_Success - The operation was successful.

--*/
{
    NET_API_STATUS          apiStatus;
    DWORD                   OptionsSupported = 0;


    NET_REMOTE_TRY_RPC

        apiStatus = NetrMessageNameAdd ((LPWSTR)servername,(LPWSTR)msgname);

    NET_REMOTE_RPC_FAILED("NetMessageNameAdd",
        (LPWSTR)servername,
        apiStatus,
        NET_REMOTE_FLAG_NORMAL,
        SERVICE_MESSENGER)

        //
        // Call downlevel version of the API.
        //
        apiStatus = RxNetMessageNameAdd((LPWSTR)servername,(LPWSTR)msgname);

    NET_REMOTE_END

    return(apiStatus);
}


NET_API_STATUS NET_API_FUNCTION
NetMessageNameEnum (
    IN  LPCWSTR     servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetMessageNameEnum.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.

    level - This indicates the level of information that is desired.

    bufptr - A pointer to the location where the pointer to the returned
        array of info structures is to be placed.

    prefmaxlen - Indicates a maximum size limit that the caller will allow
        for the return buffer.

    entriesread - A pointer to the location where the number of entries
        (data structures)read is to be returned.

    totalentries - A pointer to the location which upon return indicates
        the total number of entries in the table.

    resumehandle - Pointer to a value that indicates where to resume
        enumerating data.

Return Value:

    Nerr_Success - The operation was successful.


Note:


--*/
{
    NET_API_STATUS          apiStatus;
    GENERIC_ENUM_STRUCT     infoStruct;
    GENERIC_INFO_CONTAINER  genericInfoContainer;
    DWORD                   OptionsSupported = 0;

    if (level != 0 && level != 1)
    {
        //
        // Return ERROR_INVALID_LEVEL rather than the RPC
        // "invalid level" error when it tries to assemble
        // the union with a bogus level in the stub.
        //
        return ERROR_INVALID_LEVEL;
    }

    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;


    NET_REMOTE_TRY_RPC

        apiStatus = NetrMessageNameEnum (
                (LPWSTR)servername,
                (LPMSG_ENUM_STRUCT) &infoStruct,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (apiStatus == NERR_Success || apiStatus == ERROR_MORE_DATA) {
            *bufptr = (LPBYTE) genericInfoContainer.Buffer;
            *entriesread = genericInfoContainer.EntriesRead;
        }

    NET_REMOTE_RPC_FAILED("NetMessageNameEnum",
            (LPWSTR)servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_MESSENGER )

        //
        // Call downlevel version of the API.
        //
        apiStatus = RxNetMessageNameEnum(
                (LPWSTR)servername,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle);
        
    NET_REMOTE_END


    return(apiStatus);
}



NET_API_STATUS NET_API_FUNCTION
NetMessageNameGetInfo (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  msgname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetMessageNameGetInfo.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.  Since this function is
        executing on that computer, this information is not useful
        by the time it gets here.  It is really only useful on the RPC
        client side.

    msgname - Pointer to a string containing the name in the table
        for which information is desired.

    level - This indicates the level of information that is desired.

    bufptr - Pointer to a Location where the pointer to the returned
        information structure is to be placed.

Return Value:

    NERR_Success - The operation was successful.


--*/

{
    NET_API_STATUS          apiStatus;
    DWORD                   OptionsSupported = 0;


    *bufptr = NULL;         // Must be NULL so RPC knows to till it in.

    NET_REMOTE_TRY_RPC

        apiStatus = NetrMessageNameGetInfo (
            (LPWSTR)servername,
            (LPWSTR)msgname,
            level,
            (LPMSG_INFO) bufptr);

    NET_REMOTE_RPC_FAILED("NetMessageNameGetInfo",
            (LPWSTR)servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_MESSENGER)

        //
        // Call downlevel version of the API.
        //
        apiStatus = RxNetMessageNameGetInfo(
                        (LPWSTR)servername,
                        (LPWSTR)msgname,
                        level,
                        bufptr);
    NET_REMOTE_END


    return(apiStatus);
}


NET_API_STATUS NET_API_FUNCTION
NetMessageNameDel (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  msgname
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetMessageNameDel.  This API deletes
    a name from the message name table.

Arguments:

    servername - Points to a string containing the name of the computer
        that is to execute the API function.

    msgname - Points to a string containing the name that is to be deleted
        from the message name table.


Return Value:

    NERR_Success - The operation was successful



--*/

{
    NET_API_STATUS          apiStatus;
    DWORD                   OptionsSupported = 0;



    NET_REMOTE_TRY_RPC

        apiStatus = NetrMessageNameDel ((LPWSTR)servername, (LPWSTR)msgname);

    NET_REMOTE_RPC_FAILED("NetMessageNameDel",
        (LPWSTR)servername,
        apiStatus,
        NET_REMOTE_FLAG_NORMAL,
        SERVICE_MESSENGER)

        //
        // Call downlevel version of the API.
        //
        apiStatus = RxNetMessageNameDel((LPWSTR)servername,(LPWSTR)msgname);

    NET_REMOTE_END

    return(apiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\client\msgbind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    msgbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Service Controller.

Author:

    Dan Lafferty (danl)     29-May-1991

Environment:

    User Mode -Win32

Revision History:


--*/

//
// INCLUDES
//
#include <nt.h>         // DbgPrint prototype
#include <rpc.h>        // DataTypes and runtime APIs
#include <msgsvc.h>     // generated by the MIDL complier
#include <rpcutil.h>    // NetRpc utils
#include <netlib.h>     // UNUSED macro

#include <msgnames.h>   // MSGR_INTERFACE_NAME


/****************************************************************************/
handle_t
MSGSVC_HANDLE_bind (
    MSGSVC_HANDLE   ServerName
    )

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the messenger service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle;
    RPC_STATUS  status;

    status = NetpBindRpc (
                ServerName,
                MSGR_INTERFACE_NAME,
                L"Security=Impersonation Dynamic False",
                &bindingHandle);

#ifdef DEBUG
    DbgPrint("MSGSVC_HANDLE_bind:NetpBindRpc status=%d\n",status);
    DbgPrint("MSGSVC_HANDLE_bind: handle=%d\n",bindingHandle);
#endif

    return( bindingHandle);
}



/****************************************************************************/
void
MSGSVC_HANDLE_unbind (
    MSGSVC_HANDLE   ServerName,
    handle_t        BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the Messenger Service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNUSED(ServerName);     // This parameter is not used

#ifdef DEBUG
    DbgPrint("MSGSVC_HANDLE_unbind: handle=%d\n",BindingHandle);
#endif

    NetpUnbindRpc ( BindingHandle);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\client\msg.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    MSG.C

Abstract:

    Test Routines for the Service Controller.

Author:

    Dan Lafferty    (danl)  08-May-1991

Environment:

    User Mode - Win32

Revision History:

    08-May-1991     danl
        created

--*/
//
// INCLUDES
//
#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h

#include <stdlib.h>     // atoi
#include <stdio.h>      // printf
#include <string.h>     // strcmp
#include <windows.h>    // win32 typedefs
#include <lmerr.h>      // NERR_ error codes
#include <windef.h>     // win32 typedefs
#include <lmcons.h> 
#include <lmmsg.h>
#include <tstring.h>    // Unicode

//
// FUNCTION PROTOTYPES
//
VOID
DisplayStatus (
    IN  LPBYTE      InfoStruct2,
    IN  DWORD       level
    );

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    );

BOOL
MakeArgsUnicode (
    DWORD           argc,
    PUCHAR          argv[]
    );


/****************************************************************************/
VOID __cdecl
main (
    int             argc,
    PUCHAR          argvA[]
    )

/*++

Routine Description:

    Allows manual testing of the Messenger Service  by typing commands on
    the command line such as:
        
        
        msg add danl                - adds a name (danl).
        msg del danl                - deletes a name (danl).
        msg enum                    - enumerates the names (level 1)
        msg enum -l1                - enumerates the names (level 1)
        msg enum -l0                - enumerates the names (level 0)
        msg enum rh= 2              - enum with resume handle =2 (level1)
        msg enum maxlen= 50         - Does an enum with a 50 byte buffer.
        msg query danl              - gets info on danl. (level 1)
        msg query danl -l0          - gets info on danl. (level 0)


Arguments:



Return Value:



--*/

{
    NET_API_STATUS  status;
    LPBYTE          InfoStruct;
    DWORD           entriesRead;
    DWORD           totalEntries;
    DWORD           resumeHandle;
    DWORD           prefMaxLen;
    DWORD           level;
    DWORD           specialFlag = FALSE;
    DWORD           i;
    WCHAR           name[50];
    LPWSTR          *argv;
    LPWSTR          pServerName;
    LPTSTR          *FixArgv;
    INT             argIndex;


    if (argc <2) {
        printf("ERROR: no command was given!  (add, del, enum, query)\n");
        return;
    }

    //
    // Make the arguments unicode if necessary.
    //
    argv = (LPWSTR *)argvA;
    
#ifdef UNICODE

    if (!MakeArgsUnicode(argc, (PUCHAR *)argv)) {
        return;
    }

#endif
    FixArgv = (LPTSTR *)argv;

    pServerName = NULL;
    argIndex = 1;

    if (STRNCMP (FixArgv[1], TEXT("\\\\"), 2) == 0) {
        pServerName = FixArgv[1];
        argIndex = 2;
    }

    if (_wcsicmp (FixArgv[argIndex], L"enum" ) == 0 ) {

        
        resumeHandle = 0;
        level = 1;
        prefMaxLen = 0xffffffff;

        if (argc > argIndex+1) {
            if (_wcsicmp (FixArgv[argIndex+1], L"rh=") == 0) {
                specialFlag = TRUE;
                if (argc > argIndex+2) {
                    resumeHandle = wtol(FixArgv[argIndex+2]);
                }
            }            
    
            if (_wcsicmp (FixArgv[argIndex+1], L"-l0") == 0) {
                specialFlag = TRUE;
                level = 0;
            }            
            if (_wcsicmp (FixArgv[argIndex+1], L"-l2") == 0) {
                specialFlag = TRUE;
                level = 2;
            }            
            if (_wcsicmp (FixArgv[argIndex+1], L"-l3") == 0) {
                specialFlag = TRUE;
                level = 3;
            }            
            if (_wcsicmp (FixArgv[argIndex+1], L"maxlen=") == 0) {
                specialFlag = TRUE;
                if (argc > argIndex+2) {
                    prefMaxLen = wtol(FixArgv[argIndex+2]);
                }
            }            
        }
        if (    (argc < argIndex+2) || 
                (specialFlag == TRUE) && (argc < argIndex+4) ) {

            status = NetMessageNameEnum (
                        pServerName,            // ServerName - Local version
                        level,                  // Level
                        &InfoStruct,            // return status buffer pointer
                        prefMaxLen,             // preferred max length
                        &entriesRead,           // entries read
                        &totalEntries,          // total entries
                        &resumeHandle);         // resume handle
        
            if ( (status == NERR_Success)    ||
                 (status == ERROR_MORE_DATA) ){

                printf("Enum: entriesRead  = %d\n", entriesRead);
                printf("Enum: totalEntries = %d\n", totalEntries);
                printf("Enum: resumeHandle = %d\n", resumeHandle);

                for (i=0; i<entriesRead; i++) {
                    DisplayStatus(InfoStruct,level);
                    switch(level) {
                    case 0:
                        InfoStruct += sizeof(MSG_INFO_0);
                        break;                    
                    case 1:
                        InfoStruct += sizeof(MSG_INFO_1);
                        break;                    
                    default:
                        printf("Bad InfoLevel\n");
                    }
                    
                }
            }
            else {
                printf("[msg] NetServiceEnum FAILED, rc = %ld\n", status);
                if (InfoStruct != NULL) {
                    DisplayStatus(InfoStruct,level);
                }
            }
        }
    }

    else if (_wcsicmp (FixArgv[argIndex], L"query") == 0) {
        
        level = 1;

        if (argc > argIndex+1 ) {
            wcscpy(name, FixArgv[argIndex+1]);
        }
        if (argc > argIndex+2) {
            if (_wcsicmp (FixArgv[argIndex+2], TEXT("-l0")) ==0) {
                level = 0;    
            }
        }
        
        status = NetMessageNameGetInfo (
                    pServerName,        // ServerName     Local version
                    name,               // MessageName
                    level,              // level  
                    &InfoStruct);      // buffer pointer
    
        if (status == NERR_Success) {
            DisplayStatus((LPBYTE)InfoStruct, level);
        }
        else {
            printf("[msg] NetMessageNameGetInfo FAILED, rc = %ld\n", status);
        }
    }

    else if (_wcsicmp (FixArgv[argIndex], L"add") == 0) {

        if (argc < argIndex+2) {
            printf("ERROR: no name given for add  (msg add <name>)\n");
            return;
        }

        wcscpy(name, FixArgv[argIndex+1]);

        status = NetMessageNameAdd (
                    pServerName,                // ServerName     Local version
                    name);                      // Name to add
    
        if (status == NERR_Success) {
            printf("name added successfully\n");
        }
        else {
            printf("[msg] NetMessageNameAdd FAILED, rc = %ld\n", status);
        }
    }

    else if (_wcsicmp (FixArgv[argIndex], L"del") == 0) {

        if (argc < argIndex+2) {
            printf("ERROR: no name given for add  (msg add <name>)\n");
            return;
        }

        wcscpy(name, FixArgv[argIndex+1]);

        status = NetMessageNameDel (
                    pServerName,                // ServerName     Local version
                    name);                      // Name to add
    
        if (status == NERR_Success) {
            printf("name deleted successfully\n");
        }
        else {
            printf("[msg] NetMessageNameDel FAILED, rc = %ld\n", status);
        }
    }

    else {
        printf("[msg] Unrecognized Command\n");
    }

    return;
}


/****************************************************************************/
VOID
DisplayStatus (
    IN  LPBYTE      InfoStruct,
    IN  DWORD       level
    )

/*++

Routine Description:

    Displays the returned info buffer.

Arguments:

    InfoStruct2 - This is a pointer to a SERVICE_INFO_2 structure from which
        information is to be displayed.
        
Return Value:

    none.
    
--*/
{
    LPMSG_INFO_0    InfoStruct0;
    LPMSG_INFO_1    InfoStruct1;

    switch(level) {
    case 0:
        InfoStruct0 = (LPMSG_INFO_0)InfoStruct;
        printf("\nNAME: %ws\n", InfoStruct0->msgi0_name);
        break;
    case 1:
        InfoStruct1 = (LPMSG_INFO_1)InfoStruct;

        printf("\nNAME: %ws\n", InfoStruct1->msgi1_name);
        printf("        FWD_FLAG:   %ld\n", InfoStruct1->msgi1_forward_flag);
        printf("        FWD_STRING: %ws\n", InfoStruct1->msgi1_forward );
        break;
    default:
        printf("DisplayStatus: illegal level\n");
    }
    return;
}

BOOL
MakeArgsUnicode (
    DWORD           argc,
    PUCHAR          argv[]
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   i;

    //
    // ScConvertToUnicode allocates storage for each string. 
    // We will rely on process termination to free the memory.
    //
    for(i=0; i<argc; i++) {

        if(!ConvertToUnicode( (LPWSTR *)&(argv[i]), argv[i])) {
            printf("Couldn't convert argv[%d] to unicode\n",i);
            return(FALSE);
        }


    }
    return(TRUE);
}

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    ) 

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to 
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.

Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    OEM_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = (strlen(AnsiIn)+1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (*UnicodeOut == NULL) {
        printf("ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    NetpInitOemString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlOemStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                FALSE);             // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        printf("ScConvertToUnicode:RtlOemStringToUnicodeString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    //
    // Fill in the pointer location with the unicode string buffer pointer.
    //
    *UnicodeOut = unicodeString.Buffer;

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\idl\msgnames.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgnames.h

Abstract:

    Defines the Messenger names.

Author:

    Dan Lafferty (danl)     24-Jun-1991

Revision History:


--*/

#ifndef _MSGNAMES_INCLUDED
#define _MSGNAMES_INCLUDED

#define MSGR_INTERFACE_NAME     TEXT("msgsvc")


#endif  // _MSGNAMES_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\apiutil.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    apiutil.c

Abstract:

    Contains functions used by the Messenger API.  This file contains the
    following functions:

        MsgIsValidMsgName
        MsgMapNetError
        MsgLookupName
        message_sec_check
        MsgGatherInfo
        MsgUnformatName

        MsgLookupNameForThisSession 
        MsgIsSessionInList (HYDRA specific)
        MsgAddSessionInList (HYDRA specific)
        MsgRemoveSessionFromList (HYDRA specific)

Author:

    Dan Lafferty (danl)     22-Jul-1991

Environment:

    User Mode -Win32

Notes:

    These functions were ported from LM2.0.  This file contains functions
    from several LM2.0 files.  Not all functions were used in this file
    since some were made obsolete by the NT Service Model.
    The following LM2.0 files were incorportated into this single file:
        
        msgutils.c
        msgutil2.c
        dupname.c
        netname.c
    
Revision History:

    22-Jul-1991     danl
        ported from LM2.0

--*/

//
// Includes
// 


#include "msrv.h"
#include <tstring.h>    // Unicode string macros
#include <lmwksta.h>
#include <lmmsg.h>

#include <smbtypes.h>   // needed for smb.h
#include <smb.h>        // Server Message Block definitions

#include <icanon.h>     // I_NetNameValidate
#include <netlib.h>     // NetpCopyStringToBuffer

#include "msgdbg.h"     // MSG_LOG
#include "heap.h"
#include "msgdata.h"
#include "apiutil.h"


//
// Table of NetBios mappings to Net Errors.
//
    DWORD   const mpnetmes[] = 
    {
    0x23,                       // 00 Number of messages
    NERR_NetworkError,          // 01 NRC_BUFLEN -> invalid length
    0xffffffff,                 // 02 NRC_BFULL , not expected
    NERR_NetworkError,          // 03 NRC_ILLCMD -> invalid command
    0xffffffff,                 // 04 not defined
    NERR_NetworkError,          // 05 NRC_CMDTMO -> network busy
    NERR_NetworkError,          // 06 NRC_INCOMP -> messgae incomplete
    0xffffffff,                 // 07 NRC_BADDR , not expected
    NERR_NetworkError,          // 08 NRC_SNUMOUT -> bad session
    NERR_NoNetworkResource,     // 09 NRC_NORES -> network busy
    NERR_NetworkError,          // 0a NRC_SCLOSED -> session closed
    NERR_NetworkError,          // 0b NRC_CMDCAN -> command cancelled
    0xffffffff,                 // 0c NRC_DMAFAIL, unexpected
    NERR_AlreadyExists,         // 0d NRC_DUPNAME -> already exists 
    NERR_TooManyNames,          // 0e NRC_NAMTFUL -> too many names
    NERR_DeleteLater,           // 0f NRC_ACTSES -> delete later
    0xffffffff,                 // 10 NRC_INVALID , unexpected
    NERR_NetworkError,          // 11 NRC_LOCTFUL -> too many sessions
    ERROR_REM_NOT_LIST,         // 12 NRC_REMTFUL -> remote not listening*/
    NERR_NetworkError,          // 13 NRC_ILLNN -> bad name
    NERR_NameNotFound,          // 14 NRC_NOCALL -> name not found
    ERROR_INVALID_PARAMETER,    // 15 NRC_NOWILD -> bad parameter
    NERR_DuplicateName,         // 16 NRC_INUSE -> name in use, retry
    ERROR_INVALID_PARAMETER,    // 17 NRC_NAMERR -> bad parameter
    NERR_NetworkError,          // 18 NRC_SABORT -> session ended
    NERR_DuplicateName,         // 19 NRC_NAMCONF -> duplicate name
    0xffffffff,                 // 1a not defined
    0xffffffff,                 // 1b not defined
    0xffffffff,                 // 1c not defined
    0xffffffff,                 // 1d not defined
    0xffffffff,                 // 1e not defined
    0xffffffff,                 // 1f not defined
    0xffffffff,                 // 20 not defined
    NERR_NetworkError,          // 21 NRC_IFBUSY -> network busy
    NERR_NetworkError,          // 22 NRC_TOOMANY -> retry later
    NERR_NetworkError           // 23 NRC_BRIDGE -> bridge error
    };


DWORD        
MsgIsValidMsgName(
    IN LPTSTR  name
    )

/*++

Routine Description:

    Check for a valid messaging name.
    This function checks for the validity of a messaging name.


Arguments:

    name - pointer to name to validate.


Return Value:

    Error code from I_NetNameValidate


--*/

{
    TCHAR   namebuf[NCBNAMSZ];
    DWORD   err_code;

    //
    // Message names cannot be larger than (NCBNAMSZ - 1) characters
    //
    if (STRLEN(name) > (NCBNAMSZ - 1))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    STRCPY(namebuf, name);

    err_code = I_NetNameValidate(NULL, namebuf, NAMETYPE_COMPUTER, 0L);

    if (err_code != 0)
    {
        return err_code;
    }
    
    //
    // Any name beginning with a * must be rejected as the message 
    // server relies on being able to ASTAT the name, and an ASTAT
    // name commencing with a * means ASTAT the local card.
    // 
    if(namebuf[0] == TEXT('*'))
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NERR_Success;
}


DWORD
MsgMapNetError(
    IN  UCHAR   Code        // Error code
    )

/*++

Routine Description:

    Map NetBios Error code to a message number

Arguments:

    code - Error code from NetBios (can be 0)

Return Value:

    Message code as defined in msgs.h

--*/
{
    DWORD   dwCode;

    dwCode = 0 | (UCHAR)Code;
                                            
    if( dwCode == 0) {
        return(NERR_Success);               // Special case
    }

    if((dwCode > 0) && (dwCode < mpnetmes[0])) {
        return(mpnetmes[dwCode]);
    }

    return (NERR_NetworkError);             // Can't map it!
}


DWORD
MsgLookupName(
    IN DWORD    net,        // The network card to search
    IN LPSTR    name        // Formatted name  (Non-unicode)
    )

/*++

Routine Description:

    This function looks up a formatted name in the name table in the
    Message Server's shared data area.
 
    This function looks the given name up in the name table in the shared
    data area.  In order to match the given name, the first NCBNAMLEN - 1
    characters of the name in the name table must be identical to the same
    characters in the given name, and the name in the name table must not be
    marked as deleted.  This function assumes that the shared data area is
    accessible and that the global variable, dataPtr, is valid.

Arguments:

    name - pointer to formatted name


Return Value:

    DWORD - index into table if found, -1 otherwise

--*/

{
    DWORD   i;                              // Index

    for(i = 0; i < NCBMAX(net); ++i) {           // Loop to search for name

        if( !memcmp( name, SD_NAMES(net,i), NCBNAMSZ - 1) &&
            !(SD_NAMEFLAGS(net,i) & NFDEL) ) {

            //
            // Return index if match found
            //
            return(i);
        }
    }                                       
    return(0xffffffff);                     // No match
}

//	For HYDRA, we want to make sure that the name exists for THIS client session.
DWORD
MsgLookupNameForThisSession(
    IN DWORD    net,        // The network card to search
    IN LPSTR    name,        // Formatted name to loook for (Non-unicode)
	IN ULONG	SessionId	 // Session Id to look for
    )
/*++

Routine Description:

    Same as MsgLookupName except that we care about the session Id.
    This function looks up a formatted name in the name table in the
    Message Server's shared data area. The name found must have the 
    requested SessionId in its session list to be considered as OK.

Arguments:

    name - pointer to formatted name
    SessionId - the requested Session Id


Return Value:

    DWORD - index into table if found, -1 otherwise

--*/

{
    DWORD   i;                              // Index
    DWORD   dwMsgrState;                    // messanger state

    if (!g_IsTerminalServer)        //  regular NT case
    {
        //
        //  if we are not on HYDRA, forget the SessionId
        //
        return MsgLookupName(net, name);
    }
    else            //  HYDRA case
    {
        //
        // dont try to access table if messanger stop is pending,
        //  we may not have GlobalData available
        //
        dwMsgrState = GetMsgrState();
        if (RUNNING == dwMsgrState)
        {
            for(i = 0; i < NCBMAX(net); ++i) {           // Loop to search for name

                if( !memcmp( name, SD_NAMES(net,i), NCBNAMSZ - 1) &&
                    !(SD_NAMEFLAGS(net,i) & NFDEL) &&
                    (MsgIsSessionInList(&(SD_SIDLIST(net,i)), SessionId ))
                    ) {
    			    return (i);
                }
            }
        }
        return(0xffffffff);                     // No match
    }
}


// message_sec_check
//
//    A common routine to check caller priv/auth against that
//  required to call the message apis.
//
// 

NET_API_STATUS
message_sec_check(VOID)
{
#ifdef later
    //
    // API security check. This call can be called by anyone locally,
    // but only by admins in the remote case.
    
    I_SecSyncSet(SECSYNC_READER);

    if ( ( clevel == ACCESS_REMOTE ) &&
         ( callinf != NULL ) &&
         ( CALLER_PRIV(callinf) != USER_PRIV_ADMIN ) )
    {
        I_SecSyncClear(SECSYNC_READER);
        return(ERROR_ACCESS_DENIED);
    }
    I_SecSyncClear(SECSYNC_READER);
#endif
    return (NERR_Success);
}                            


NET_API_STATUS 
MsgGatherInfo (
    IN      DWORD   Level,
    IN      LPSTR   FormattedName,
    IN OUT  LPBYTE  *InfoBufPtr,
    IN OUT  LPBYTE  *StringBufPtr
    )

/*++

Routine Description:



Arguments:

    Level - Indicates the  level of information that is being returned.

    FormattedName - This is a name that messages are received by.  This
        name is formated for NCB transactions.  Therefore, it is made
        up of ANSI characters that are space padded to fill out a packet
        of NCBNAMSZ characters.  The last character is always a 03 
        (indicating a non-forwarded name).
     
    InfoBufPtr - On input, this is a pointer to a pointer to where the
        messenger information is to be placed.  On successful return, this
        location contains a pointer to the location where the next
        information will be placed (on the next call to this function).

    StringBufPtr -  On input, thisis a pointer to a pointer to where the
        NUL terminated name string for that info record is to be placed.
        On successful return, this location contains a pointer to the
        location where the next set of strings will be placed (on the
        next call to this function).

Return Value:

    NERR_Success - The information was successfully gathered and placed
        in the info buffer.

    NERR_Internal_Error - The Formatted Name could not be correctly
        translated into a meaningful Unicode Name.

    ERROR_INVALID_LEVEL - An illegal info level was passed in.

    ERROR_NOT_ENOUGH_MEMORY - Not enough room to store gathered information.

--*/
{
    NET_API_STATUS  status;
    BOOL            bStatus;
    PCHAR           fixedDataEnd;   // pointer to free space from top of buffer.
    LPMSG_INFO_0    infoBuf0;
    LPMSG_INFO_1    infoBuf1;
    TCHAR           unicodeName[NCBNAMSZ];

    //
    // Convert the name to Unicode
    //
    status = MsgUnformatName(unicodeName, FormattedName);
    if (status != NERR_Success) {
        return(status);
    }
    
    switch (Level) {
    case LEVEL_0:
        infoBuf0 = (LPMSG_INFO_0)*InfoBufPtr;
        fixedDataEnd = (PCHAR)infoBuf0 + sizeof(MSG_INFO_0);

        if( fixedDataEnd >= *StringBufPtr) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        bStatus = NetpCopyStringToBuffer (
                    unicodeName,                // The String
                    STRLEN(unicodeName),        // StringLength
                    fixedDataEnd,               // FixedDataEnd
                    (PVOID)StringBufPtr,        // EndOfVariableData
                    &infoBuf0->msgi0_name);     // VariableDataPointer

        if (bStatus == FALSE) {
            MSG_LOG(TRACE,"MsgGatherInfo(level0): Not enough room\n",0);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        *InfoBufPtr = (LPBYTE)fixedDataEnd;
        break;

    case LEVEL_1:
        infoBuf1 = (LPMSG_INFO_1)*InfoBufPtr;

        fixedDataEnd = (PCHAR)infoBuf1 + sizeof(MSG_INFO_1);
        if( fixedDataEnd >= *StringBufPtr) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        bStatus = NetpCopyStringToBuffer (
                    unicodeName,                // The String
                    STRLEN(unicodeName),        // StringLength
                    fixedDataEnd,               // FixedDataEnd
                    (PVOID)StringBufPtr,        // EndOfVariableData
                    &infoBuf1->msgi1_name);     // VariableDataPointer

        if (bStatus == FALSE) {
            MSG_LOG(TRACE,"MsgGatherInfo(level1): Not enough room\n",0);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Set all the forward information to NULL since forwarding
        // is not supported.
        //
        infoBuf1->msgi1_forward_flag = 0;
        infoBuf1->msgi1_forward = NULL;
        
        *InfoBufPtr = (LPBYTE)fixedDataEnd;
        break;

    default:
        MSG_LOG(TRACE,"MsgGatherInfo Invalid level\n",0);
        return(ERROR_INVALID_LEVEL);
        break;
    }

    return(NERR_Success);

}


NET_API_STATUS
MsgUnformatName(
    OUT LPTSTR  UnicodeName,
    IN  LPSTR   FormattedName
    )

/*++

Routine Description:

    This routine creates a Unicode NUL-Terminated version of a NetBios
    Formatted name.

Arguments:

    UnicodeName - This is a pointer to a location where the un-formatted
        NUL terminated Unicode Name is to be copied.

    FormattedName - This is a pointer to an NCB formatted name.  This
        name always contains NCBNAMSZ characters of which the last character
        is a code used for a forward/non-forward flag.  These strings
        are space padded.
        

Return Value:

    NERR_Success - The operation was successful.

    NERR_Internal - The operation was unsuccessful.

--*/
{
    UNICODE_STRING  unicodeString;
    OEM_STRING     ansiString;
    NTSTATUS        ntStatus;
    int             i;

    //
    // Translate the ansi string in the name table to a unicode name
    //
#ifdef UNICODE
    unicodeString.Length = (NCBNAMSZ -1) * sizeof(WCHAR);
    unicodeString.MaximumLength = NCBNAMSZ * sizeof(WCHAR);
    unicodeString.Buffer = (LPWSTR)UnicodeName;

    ansiString.Length = NCBNAMSZ-1;
    ansiString.MaximumLength = NCBNAMSZ;
    ansiString.Buffer = FormattedName;

    ntStatus = RtlOemStringToUnicodeString(
                &unicodeString,      // Destination
                &ansiString,         // Source
                FALSE);              // Don't allocate the destination.

    if (!NT_SUCCESS(ntStatus)) {
        MSG_LOG(ERROR,
            "UnformatName:RtlOemStringToUnicodeString Failed rc=%X\n",
            ntStatus);
        //
        // Indicate a failure
        //
        return(NERR_InternalError);  
    }
#else
    UNUSED (ntStatus);
    UNUSED (ansiString);
    UNUSED (unicodeString);
    strncpy(UnicodeName, FormattedName, NCBNAMSZ-1);
#endif

    //
    // Remove excess Space characters starting at the back (skipping
    // the 03 flag character.
    //
    i = NCBNAMSZ-2;

    while ( UnicodeName[i] == TEXT(' ')) {

        UnicodeName[i--] = TEXT('\0');

        if (i < 0) {
            MSG_LOG(ERROR,
                "UnformatName:Nothing but space characters\n",0);
            return(NERR_InternalError);
        }
    }
    return(NERR_Success);
}


BOOL
MsgIsSessionInList(
				   IN PLIST_ENTRY SessionIdList,
				   IN ULONG SessionId
				   )
{
	BOOL		bRet = FALSE;

	PLIST_ENTRY				pList = SessionIdList;
	PMSG_SESSION_ID_ITEM	pItem;

	while (pList->Flink != SessionIdList)		// loop until we find it (or the end of the list)
	{
        pList = pList->Flink;
		pItem = CONTAINING_RECORD(pList, MSG_SESSION_ID_ITEM, List);
		if ( (pItem->SessionId == SessionId) || (pItem->SessionId == EVERYBODY_SESSION_ID) )
		{
			bRet = TRUE;	// we found it !
			break;
		}
	}

    return bRet;
}


VOID
MsgRemoveSessionFromList(
					  IN PLIST_ENTRY SessionIdList,
					  ULONG	SessionId
					  )
{
	PLIST_ENTRY				pList = SessionIdList;
	PMSG_SESSION_ID_ITEM	pItem;

	while (pList->Flink != SessionIdList)		// loop until we find it (or the end of the list)
	{
        pList = pList->Flink;  
		pItem = CONTAINING_RECORD(pList, MSG_SESSION_ID_ITEM, List);
		if (pItem->SessionId == SessionId)
		{
			// we found it. Let's remove it
			RemoveEntryList(pList);

			//Free the memory
			LocalFree(pItem);

			break;
		}
	}
}


BOOL
MsgAddSessionInList(
					 IN PLIST_ENTRY SessionIdList,
					 ULONG	SessionId
					 )
{
	BOOL		bRet;
	PMSG_SESSION_ID_ITEM	pItem;

	// allocate a new item
	pItem = (PMSG_SESSION_ID_ITEM) LocalAlloc(LMEM_ZEROINIT,sizeof(MSG_SESSION_ID_ITEM));

	if (pItem == NULL)	// If this happens, we really have big problems...
	{
		MSG_LOG(ERROR,"MsgAddSessionInList:  Unable to allocate memory\n",0);
		bRet = FALSE;
    }
	else	//	OK
	{
		bRet = TRUE;

		// initialize the item
		pItem->SessionId = SessionId;

		// insert the item in the list
		InsertTailList(SessionIdList, &pItem->List);
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\apidata.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

#define const

//
// msgdata.c - Contains all the global data used by the support functions
//        of the message server API.
// 
                               
#include <netcons.h>        // needed by service.h
#include <neterr.h>         // Status code definitions.
#include <error.h>          // Status code definitions.
#include <service.h>        // defines for service API usage
#include <ncb.h>            // NCB defines
#include <smb.h>            // SMB defines
#include <msrv.h>           // General message server defines
#include <srvparam.h>       // General server type defines

unsigned short  smbret;         // SMB return code
unsigned char   smbretclass;    // SMB return class
short           mgid;           // Message group i.d.
NCB             g_ncb;          // NCB used for all send functions

ulfp            semPtr;         // Pointer to data semaphore 
ucfp            dataPtr;        // Pointer to shared data area



// Support Arrays
//
//  These arrays (single dimensioned) contain one entry for each managed
//  network.  This allows each thread (network) to have its own set of
//  "global" data. They are all in the same segment, the size of which is
//  computed by the following formula:
//
//     size = NumNets * (sizeof(unsigned short) + sizeof(unsigned char) +
//            sizeof(ulfp))
//



unsigned short far *    NetBios_Hdl;    // NetBios handles, one per net
unsigned char far *    net_lana_num;    // Lan adaptor numbers
ul far *        wakeupSem;    // Semaphores to clear on NCB completion

unsigned long        MsgSegSem = 0L;    // Protecting the per process data
                                        // declared in this file.
                    

// Too avoid having an abundance of net errors to confuse the user, most of the 
 * net errors now map to NERR_NetworkError.

 
DWORD   const mpnetmes[] =        
    {
    0x23,                       // 00 Number of messages
    NERR_NetworkError,          // 01 NRC_BUFLEN -> invalid length
    -1,                         // 02 NRC_BFULL , not expected
    NERR_NetworkError,          // 03 NRC_ILLCMD -> invalid command
    -1,                         // 04 not defined
    NERR_NetworkError,          // 05 NRC_CMDTMO -> network busy
    NERR_NetworkError,          // 06 NRC_INCOMP -> messgae incomplete
    -1,                         // 07 NRC_BADDR , not expected
    NERR_NetworkError,          // 08 NRC_SNUMOUT -> bad session
    NERR_NoNetworkResource,     // 09 NRC_NORES -> network busy
    NERR_NetworkError,          // 0a NRC_SCLOSED -> session closed
    NERR_NetworkError,          // 0b NRC_CMDCAN -> command cancelled
    -1,                         // 0c NRC_DMAFAIL, unexpected
    NERR_AlreadyExists,         // 0d NRC_DUPNAME -> already exists 
    NERR_TooManyNames,          // 0e NRC_NAMTFUL -> too many names
    NERR_DeleteLater,           // 0f NRC_ACTSES -> delete later
    -1,                         // 10 NRC_INVALID , unexpected
    NERR_NetworkError,          // 11 NRC_LOCTFUL -> too many sessions
    ERROR_REM_NOT_LIST,         // 12 NRC_REMTFUL -> remote not listening*/
    NERR_NetworkError,          // 13 NRC_ILLNN -> bad name
    NERR_NameNotFound,          // 14 NRC_NOCALL -> name not found
    ERROR_INVALID_PARAMETER,    // 15 NRC_NOWILD -> bad parameter
    NERR_DuplicateName,         // 16 NRC_INUSE -> name in use, retry
    ERROR_INVALID_PARAMETER,    // 17 NRC_NAMERR -> bad parameter
    NERR_NetworkError,          // 18 NRC_SABORT -> session ended
    NERR_DuplicateName,         // 19 NRC_NAMCONF -> duplicate name
    -1,                         // 1a not defined
    -1,                         // 1b not defined
    -1,                         // 1c not defined
    -1,                         // 1d not defined
    -1,                         // 1e not defined
    -1,                         // 1f not defined
    -1,                         // 20 not defined
    NERR_NetworkError,          // 21 NRC_IFBUSY -> network busy
    NERR_NetworkError,          // 22 NRC_TOOMANY -> retry later
    NERR_NetworkError           // 23 NRC_BRIDGE -> bridge error
    };

    LPTSTR        MessageFileName;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\display.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    display.c

Abstract:

    This file contains functions that handle the displaying of messages.

    Currently a message box is used to display messages.  A message queueing
    scheme has been setup so that the messenger worker threads can
    call a function with a pointer to a message buffer.  That message will
    get copied into the queue so that the worker thread can go on gathering
    more messages.  When the display thread will be doing one of the following:
    1)  Displaying a message - waiting for the user to press "ok".
    2)  Sleeping - waiting for an event that will _tell it to _read the
        message queue.

    When the display thread completes displaying a message, it will check
    the queue for the next message to display.  If there are no further
    messages, it will go to sleep until a message comes in.

Author:

    Dan Lafferty (danl)     24-Feb-1992

Environment:

    User Mode -Win32

Notes:


Revision History:

    04-Nov-1992     danl
        MsgDisplayThread: Handle Extended Characters.  This was done by
        translating the Oem-style characters in the message to the unicode
        equivalent, and then calling the Unicode version of the MessageBox Api.
        It will still call the Ansi version of the MessageBox if the
        string cannot be translated for some reason.

    26-Oct-1992     danl
        MsgDisplayQueueAdd: Added Beep when message is added to queue.
        Fixed bug where "if (status = TRUE)" caused the GlobalMsgDisplayEvent
        to always be set.

    24-Feb-1992     danl
        created

--*/

//
// INCLUDES
//
#include "msrv.h"
#include <msgdbg.h>     // STATIC and MSG_LOG
#include <string.h>     // memcpy
#include <winuser.h>    // MessageBox
#include "msgdata.h"    // GlobalMsgDisplayEvent

//
// DEFINES
//

#define     MAX_QUEUE_SIZE      25
#define     WAIT_FOREVER        0xffffffff

//
// Queue Entry Structure
//
typedef struct _QUEUE_ENTRY {
    struct _QUEUE_ENTRY *Next;
    ULONG               SessionId;
    SYSTEMTIME          BigTime;
    CHAR                Message[1];
}QUEUE_ENTRY, *LPQUEUE_ENTRY;

//
// GLOBALS
//

    //
    // This critical section serializes access to all the other globals.
    //
    CRITICAL_SECTION    MsgDisplayCriticalSection;

    //
    // Used to wakeup the display thread if it was put to sleep due to
    // not having a user desktop to display the message on.
    //
    HANDLE           hGlobalDisplayEvent;

    //
    // These are the Display Queue pointers & counts.
    //
    LPQUEUE_ENTRY    GlobalMsgQueueHead;
    LPQUEUE_ENTRY    GlobalMsgQueueTail;
    DWORD            GlobalMsgQueueCount;

    BOOL             fGlobalInitialized;

    //
    // This indicates whether there is a display thread already available that
    // can service requests.  If this is false, it means a new thread will
    // need to be created.
    //
    HANDLE           GlobalDisplayThread;

//
//  Function Prototypes
//


BOOL
MsgDisplayQueueRead(
    OUT LPQUEUE_ENTRY   *pQueueEntry
    );

DWORD
MsgDisplayThread(
    LPVOID  parm
    );

VOID
MsgMakeNewFormattedMsg(
    LPWSTR        *ppHead,
    LPWSTR        *ppTime,
    LPWSTR        *ppBody,
    SYSTEMTIME    BigTime
    );


BOOL
MsgDisplayQueueAdd(
    IN  LPSTR        pMsgBuffer,
    IN  DWORD        MsgSize,
    IN  ULONG        SessionId,
    IN  SYSTEMTIME   BigTime
    )

/*++

Routine Description:

    This function adds a Message to the display queue.  If the queue is
    full, the message is rejected.

Arguments:

    pMsgBuffer - This is a pointer to the buffer where the message is
        stored.  The message must be in the form of a pre-formatted
        (with message header) NUL-terminated string of ansi characters.

    MsgSize - Indicates the size (in bytes) of the message in the
        message buffer, including the NUL terminator.

    BigTime - This is a SYSTEMTIME that indicates the time the message was
        received.

Return Value:

    TRUE - The message was successfully stored in the queue.

    FALSE - The message was rejected.  Either the queue was full, or
        there was not enough memory to store the message in the queue.


--*/
{
    LPQUEUE_ENTRY   pQueueEntry;
    BOOL            status;
    DWORD           threadId;

    MSG_LOG(TRACE,"Adding a message to the display queue\n",0);

    //  ***************************
    //  **** LOCK QUEUE ACCESS ****
    //  ***************************
    EnterCriticalSection(&MsgDisplayCriticalSection);

    //
    // Is there room for the message in the queue?
    //

    if (GlobalMsgQueueCount >= MAX_QUEUE_SIZE) {
        MSG_LOG(TRACE,"DisplayQueueAdd: Max Queue Size Exceeded\n",0);
        status = FALSE;
        goto CleanExit;
    }

    //
    // Allocate memory for the message in the queue.
    //
    pQueueEntry = (LPQUEUE_ENTRY)LocalAlloc(LMEM_FIXED, MsgSize + sizeof(QUEUE_ENTRY));

    if (pQueueEntry == NULL) {
        MSG_LOG(ERROR,"DisplayQueueAdd:  Unable to allocate memory\n",0);
        status = FALSE;
        goto CleanExit;
    }

    //
    // Copy the message into the queue entry.
    //
    pQueueEntry->Next = NULL;
    memcpy(pQueueEntry->Message, pMsgBuffer, MsgSize);
    pQueueEntry->BigTime = BigTime;
    pQueueEntry->SessionId = SessionId;

    //
    // Update the queue management pointer.
    //

    if (GlobalMsgQueueCount == 0) {
        //
        // There are no entries in the queue.  So make the head
        // and the tail equal.
        //
        GlobalMsgQueueTail = pQueueEntry;
        GlobalMsgQueueHead = pQueueEntry;
    }
    else {
        //
        // Create the new Queue Tail and have the old tail's next pointer
        // point to the new tail.
        //
        GlobalMsgQueueTail->Next = pQueueEntry;
        GlobalMsgQueueTail = pQueueEntry;
    }
    GlobalMsgQueueCount++;
    status = TRUE;

    //
    // If a display thread doesn't exist, then create one.
    //
    if (GlobalDisplayThread == NULL) {

        //
        //  No use to create the event in Hydra case, since the thread will never go asleep.
        //
        if (!g_IsTerminalServer)     
        {


            hGlobalDisplayEvent = CreateEvent( NULL,
                                              FALSE,    // auto-reset
                                              FALSE,    // init to non-signaled
                                              NULL );

        }

        GlobalDisplayThread = CreateThread (
            NULL,               // Thread Attributes
            0,                  // StackSize -- process default
            MsgDisplayThread,   // lpStartAddress
            (PVOID)NULL,        // lpParameter
            0L,                 // Creation Flags
            &threadId);         // lpThreadId

        if (GlobalDisplayThread == (HANDLE) NULL) {
            //
            // If we couldn't create the display thread, then we can't do
            // much about it.  Might as well leave the entry in the queue.
            // Perhaps we can display it the next time around.
            //
            MSG_LOG(ERROR,"MsgDisplayQueueAdd:CreateThread FAILURE %ld\n",
                GetLastError());

            if (hGlobalDisplayEvent != NULL) {
                CloseHandle(hGlobalDisplayEvent);
                hGlobalDisplayEvent = NULL;
            }
        }
    }


CleanExit:

    //  *****************************
    //  **** UNLOCK QUEUE ACCESS ****
    //  *****************************
    LeaveCriticalSection(&MsgDisplayCriticalSection);

    //
    // If we actually put something in the queue, then beep.
    //
    if (status == TRUE) {
        if (g_IsTerminalServer)
        {
            MsgArrivalBeep( SessionId );
        }
        else
        {
            MessageBeep(MB_OK);
        }
    }
    return(status);
}


VOID
MsgDisplayThreadWakeup()

/*++

Routine Description:

    This function is called at shutdown, or for API requests.  It causes
    the display thread to wake up and read the queue again.

    If the display thread cannot display the message because the MessageBox
    call fails, then we assume it is because the user desktop is not avaiable
    because the screensaver is on, or because the workstation is locked.
    In this case, the display thread hangs around waiting for this
    Event to get signalled.  Winlogon calls one of the API entry points
    in order to stimulate the display thread into action again.

Arguments:


Return Value:


--*/
{
    //  ***************************
    //  **** LOCK QUEUE ACCESS ****
    //  ***************************
    EnterCriticalSection(&MsgDisplayCriticalSection);

    if ( hGlobalDisplayEvent != (HANDLE)NULL ) {
        SetEvent( hGlobalDisplayEvent );
    }
    //  *****************************
    //  **** UNLOCK QUEUE ACCESS ****
    //  *****************************
    LeaveCriticalSection(&MsgDisplayCriticalSection);
}


DWORD
MsgDisplayInit(
    VOID
    )

/*++

Routine Description:

    This function initializes everything having to do with the displaying
    of messages.  It does the following:

        Initializes the Locks on global data
        Creates event for display thread to wait on.
        Starts the display thread that will read the msg queue.

Arguments:

    NONE

Return Value:

    Always TRUE.

--*/
{
    DWORD     dwError = NO_ERROR;
    NTSTATUS  status;

    MSG_LOG(TRACE,"Initializing the Message Display Code\n",0);

    //
    // Initialize the Critical Section that protects access to global data.
    //
    status = MsgInitCriticalSection(&MsgDisplayCriticalSection);

    if (NT_SUCCESS(status))
    {
        fGlobalInitialized = TRUE;
    }
    else
    {
        MSG_LOG1(ERROR,
                 "MsgDisplayInit:  MsgInitCriticalSection failed %#x\n",
                 status);

        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    GlobalMsgQueueHead  = NULL;
    GlobalMsgQueueTail  = NULL;
    GlobalMsgQueueCount = 0;
    GlobalDisplayThread = NULL;

    return dwError;
}


VOID
MsgDisplayEnd(
    VOID
    )

/*++

Routine Description:

    This function makes sure the Display Thread has completed its work,
    and free's up all of its resources.

    *** IMPORTANT ***
    NOTE:  This function should only be called when it is no longer possible
    for the MsgDisplayQueueAdd function to get called.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    LPQUEUE_ENTRY   freeEntry;

    if (!fGlobalInitialized) {
        return;
    }

    //  ***************************
    //  **** LOCK QUEUE ACCESS ****
    //  ***************************
    EnterCriticalSection(&MsgDisplayCriticalSection);

    if (GlobalDisplayThread != NULL) {
        TerminateThread(GlobalDisplayThread,0);
        CloseHandle( GlobalDisplayThread );
    }

    //
    // To make sure a new thread won't be created...
    //
    GlobalDisplayThread = INVALID_HANDLE_VALUE;

    //
    // Free memory in the queue
    //
    while(GlobalMsgQueueCount > 0) {

        freeEntry = GlobalMsgQueueHead;
        GlobalMsgQueueHead = GlobalMsgQueueHead->Next;
        LocalFree(freeEntry);
        GlobalMsgQueueCount--;

    }
    if (hGlobalDisplayEvent != NULL) {
        CloseHandle(hGlobalDisplayEvent);
        hGlobalDisplayEvent = NULL;
    }

    fGlobalInitialized = FALSE;

    //  *****************************
    //  **** UNLOCK QUEUE ACCESS ****
    //  *****************************
    LeaveCriticalSection(&MsgDisplayCriticalSection);

    DeleteCriticalSection(&MsgDisplayCriticalSection);

    MSG_LOG(TRACE,"The Display has free'd resources and is terminating\n",0);
}


BOOL
MsgDisplayQueueRead(
    OUT LPQUEUE_ENTRY   *pQueueEntry
    )

/*++

Routine Description:

    Pulls a display entry out of the display queue.

Arguments:

    pQueueEntry - This is a pointer to a location where a pointer to the
        queue entry structure can be placed.

Return Value:

    TRUE - If an entry was found.
    FALSE- If an entry wasn't found.

Note on LOCKS:

    The caller MUST hold the MsgDisplayCriticalSection Lock prior to calling
    this function!!!


--*/
{
    BOOL    status;

    //
    // If there is data in the queue, then get the pointer to the queue
    // entry from the queue head.  Then decrement the queue count and
    // set the queue head to the next entry (which could be zero if there
    // are no more).
    //
    if (GlobalMsgQueueCount != 0) {
        *pQueueEntry = GlobalMsgQueueHead;
        GlobalMsgQueueCount--;
        GlobalMsgQueueHead = (*pQueueEntry)->Next;
        status = TRUE;
        MSG_LOG(TRACE,"A message was read from the display queue\n",0);
    }
    else{
        status = FALSE;
        *pQueueEntry = NULL;
    }

    return(status);

}


DWORD
MsgDisplayThread(
    LPVOID  parm
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

    This worker thread expects that the critical section guarding the
    global queue data is already initialized.


--*/
{
    LPQUEUE_ENTRY   pQueueEntry;
    INT             displayStatus;
    DWORD           msgrState;
    UNICODE_STRING  unicodeString;
    OEM_STRING      oemString;
    NTSTATUS        ntStatus;
    USHORT          unicodeLength;
    LPWSTR          pHead;       // pointer to header portion of message
    LPSTR           pHeadAnsi;   // pointer to header of message pulled from queue
    LPWSTR          pTime;       // pointer to time portion of message
    LPWSTR          pBody;       // pointer to body of message (just after time)
    SYSTEMTIME      BigTime;
    ULONG           SessionId;   // SessionId of the recipient (found in QUEUE_ENTRY)

    BOOL            MsgToRead = TRUE;  // tells us whether or not to sleep.


    UNREFERENCED_PARAMETER(parm);

    pHead = NULL;
    pQueueEntry = NULL;

    do {

        //
        // If we are not currently working on displaying a message,
        // then get a new message from the queue.
        //
        if (pHead == NULL)
        {
            //  ***************************
            //  **** LOCK QUEUE ACCESS ****
            //  ***************************
            EnterCriticalSection(&MsgDisplayCriticalSection);

            if (!MsgDisplayQueueRead(&pQueueEntry))
            {
                //
                // No display entries in the queue.  We can leave.
                //
                MsgToRead = FALSE;

                CloseHandle(GlobalDisplayThread);
                GlobalDisplayThread = NULL;

                if (hGlobalDisplayEvent != NULL)
                {
                    CloseHandle(hGlobalDisplayEvent);
                    hGlobalDisplayEvent = NULL;
                }

                //  *****************************
                //  **** UNLOCK QUEUE ACCESS ****
                //  *****************************
                LeaveCriticalSection(&MsgDisplayCriticalSection);
                //
                // From this point on, we can't access any global
                // variables.
                //
            }
            else
            {
                //  *****************************
                //  **** UNLOCK QUEUE ACCESS ****
                //  *****************************
                LeaveCriticalSection(&MsgDisplayCriticalSection);

                //
                // Process the entry.
                //
                BigTime = pQueueEntry->BigTime;
                SessionId = pQueueEntry->SessionId;

                //
                // Here we trash the pQueueEntry structure by pointing to the
                // beginning and copying the message data starting at the
                // first address.  This is because MsgMakeNewFormattedMsg
                // expects the message to begin at a address that can be
                // released with LocalFree();
                //
                pHeadAnsi = (LPSTR) pQueueEntry;
                strcpy(pHeadAnsi, pQueueEntry->Message);

                //
                // Convert the data from the OEM character set to the
                // Unicode character set.
                //

                RtlInitAnsiString(&oemString, pHeadAnsi);

                unicodeLength = oemString.Length * sizeof(WCHAR);

                unicodeString.Buffer = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
                                                           unicodeLength + sizeof(WCHAR));

                if (unicodeString.Buffer == NULL)
                {
                    //
                    // Couldn't allocate for unicode buffer.  Therefore we will
                    // display the message with the Ansi version of the
                    // message box API.
                    //

                    LocalFree(pHeadAnsi);
                    pHeadAnsi = NULL;
                }
                else
                {
                    unicodeString.Length = unicodeLength;
                    unicodeString.MaximumLength = unicodeLength + sizeof(WCHAR);

                    ntStatus = RtlOemStringToUnicodeString(
                                &unicodeString,      // Destination
                                &oemString,          // Source
                                FALSE);              // Don't allocate the destination.

                    LocalFree(pHeadAnsi);
                    pHeadAnsi = NULL;

                    if (!NT_SUCCESS(ntStatus))
                    {
                        MSG_LOG(ERROR,
                                "MsgDisplayThread:RtlOemStringToUnicodeString Failed rc=%X\n",
                                ntStatus);

                        LocalFree(unicodeString.Buffer);
                        unicodeString.Buffer = NULL;
                    }
                    else
                    {
                        pHead = unicodeString.Buffer;
                        pTime = wcsstr(pHead, GlobalTimePlaceHolderUnicode);

                        if (pTime != NULL)
                        {
                            pBody = pTime + wcslen(GlobalTimePlaceHolderUnicode);
                        }
                        else
                        {
                            pTime = pBody = pHead;
                        }
                    }
                }
            }
        }

        if (pHead != NULL)
        {
            MsgMakeNewFormattedMsg(&pHead, &pTime, &pBody, BigTime);

            //
            // Display the data in the QueueEntry
            //

            MSG_LOG(TRACE, "Calling MessageBox\n",0);

            if (g_IsTerminalServer)
            {
                displayStatus = DisplayMessage(pHead,
                                               GlobalMessageBoxTitle,
                                               SessionId);

                //
                // In Hydra case do not care about the error, since DisplayMessageW returns FALSE 
                // only if the user cannot be found on any Winstation. No use to try again in that case !
                //
                // So free up the data in the QueueEntry in any case
                //
                LocalFree(pHead);
                pHead = NULL;
            }
            else
            {
                displayStatus = MessageBox(NULL,
                                           pHead,
                                           GlobalMessageBoxTitle,
                                           MB_OK | MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION |
                                               MB_SETFOREGROUND | MB_DEFAULT_DESKTOP_ONLY);

                if (displayStatus == 0)
                {
                    //
                    // MessageBoxW can fail in case the current desktop is not the application desktop
                    // So wait and try again later (Winlogon will "tickle" messenger at desktop switching)
                    //
                    MSG_LOG1(TRACE,"MessageBox (unicode) Call failed %d\n",GetLastError());
                    WaitForSingleObject( hGlobalDisplayEvent, INFINITE );
                }
                else
                {
                    //
                    // Free up the data in the QueueEntry
                    //
                    LocalFree(pHead);
                    pHead = NULL;
                }
            }
        }

        msgrState = GetMsgrState();
    }
    while(MsgToRead && (msgrState != STOPPING) && (msgrState != STOPPED));

    return 0;
}


VOID
MsgMakeNewFormattedMsg(
    LPWSTR        *ppHead,
    LPWSTR        *ppTime,
    LPWSTR        *ppBody,
    SYSTEMTIME    BigTime
    )

/*++

Routine Description:

    This function returns a buffer containing an entire message that
    consists of a single string of ansi (actually oem) characters.
    Pointers to various areas (time and body) within this buffer are
    also returned.

    MEMORY MANAGEMENT NOTE:
        *ppHead is expected to point to the top of the buffer.  If the
        message is reformatted, then this buffer will have been freed,
        and a new buffer will have been allocated.  It is expected that
        the caller allocates the original buffer passed in, and that
        the caller will free it when it is no longer needed.

Arguments:

    ppHead - Pointer to location that contains the pointer to the message
        buffer.

    ppTime - Pointer to location that contains the pointer to the time portion
        of the message buffer.

    ppBody - Pointer to location that immediately follows the time string.

Return Value:

    none.  If this fails to allocate memory for the formatted message, then
           the unformatted message should be displayed.

--*/
{
    WCHAR   TimeBuf[TIME_BUF_SIZE + 1];
    DWORD   BufSize;
    LPWSTR  pTemp;
    DWORD   numChars;
    LPWSTR  pOldHead;


    //
    // Create a properly formatted time string.
    //

    BufSize = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                            0,                                 // flags
                            &BigTime,                          // date message was received
                            NULL,                              // use default format
                            TimeBuf,                           // buffer
                            sizeof(TimeBuf) / sizeof(WCHAR));  // size (in characters)

    if (BufSize != 0)
    {
        //
        // Return value includes the trailing NUL
        //
        TimeBuf[BufSize - 1] = ' ';

        BufSize += GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                 0,                      // flags
                                 &BigTime,               // time message was received
                                 NULL,                   // use default format
                                 TimeBuf + BufSize,      // buffer
                                 sizeof(TimeBuf) / sizeof(WCHAR) - BufSize);

        ASSERT(wcslen(TimeBuf) == (BufSize - 1));
    }

    if (BufSize == 0)
    {
        //
        // Something went wrong
        //
        MSG_LOG1(ERROR,
                 "MsgMakeNewFormattedMsg: Date/time formatting failed %d\n",
                 GetLastError());

        TimeBuf[0] = L'\0';
    }

    if (wcsncmp(TimeBuf, *ppTime, BufSize - 1) == 0)
    {
        //
        // If the newly formatted time string is the same as the existing
        // time string, there is nothing to do so we just return.
        //
        MSG_LOG0(TRACE,
                 "MsgMakeNewFormattedMsg: Time Format has not changed - no update.\n");

        return;
    }

    //
    // Allocate a new message buffer
    //

    BufSize--;
    BufSize += wcslen(*ppHead) + sizeof(WCHAR) - (DWORD) (*ppBody - *ppTime);

    pTemp = LocalAlloc(LMEM_ZEROINIT, BufSize * sizeof(WCHAR));

    if (pTemp == NULL)
    {
        MSG_LOG0(ERROR,"MsgMakeNewFormattedMsg: LocalAlloc failed\n");
        return;
    }

    pOldHead = *ppHead;

    //
    // Copy the header of the message.
    //
    numChars = (DWORD) (*ppTime - *ppHead);
    wcsncpy(pTemp, *ppHead, numChars);
    *ppHead = pTemp;

    //
    // Copy the time string
    //
    *ppTime = *ppHead + numChars;
    wcscpy(*ppTime, TimeBuf);

    //
    // Copy the Body of the message
    //
    pTemp = *ppBody;
    *ppBody = *ppTime + wcslen(*ppTime);
    wcscpy(*ppBody, pTemp);

    LocalFree(pOldHead);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\fmtncbna.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    fmtncbna.c

Abstract:

    Contains a function for formatting a name NCB_style.

Author:

    Dan Lafferty (danl)     29-May-1991

Environment:

    User Mode -Win32

Revision History:

    29-May-1991     danl
        ported from LM2.0
    01-Oct-1991     danl
        Working toward UNICODE.

--*/
#include <nt.h>         // needed by tstring.h
#include <windef.h>     // needed by tstring.h
#include <nt.h>         // (Needed by <tstring.h>.)
#include <windef.h>     // (Needed by <tstring.h>.)
#include <tstring.h>    // STRLEN
#include "msrv.h"       // For prototype definitions
#include "msgdbg.h"     // MSG_LOG
#include <netdebug.h>   // NetpAssert
#include <netlib.h>     // UNUSED macro
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include <icanon.h>     // Canonicalization Routines



NET_API_STATUS
MsgFmtNcbName(
    OUT PCHAR   DestBuf,
    IN  LPTSTR  Name,
    IN  DWORD   Type)

/*++

Routine Description:

    FmtNcbName - format a name NCB-style
 
    Given a name, a name type, and a destination address, this
    function copies the name and the type to the destination in
    the format used in the name fields of a Network Control
    Block.
 

    SIDE EFFECTS
 
    Modifies 16 bytes starting at the destination address.

Arguments:

    DestBuf - Pointer to the destination buffer.

    Name - Unicode NUL-terminated name string

    Type - Name type number (0, 3, 5, or 32) (3=NON_FWD, 5=FWD)



Return Value:

    NERR_Success - The operation was successful

    Translated Return Code from the Rtl Translate routine.

--*/

  {
    DWORD           i;                // Counter
    NTSTATUS        ntStatus;
    NET_API_STATUS  status;
    OEM_STRING     ansiString;
    UNICODE_STRING  unicodeString;
    PCHAR           pAnsiString;


    //
    // Force the name to be upper case.
    //
    status = NetpNameCanonicalize(
                NULL,
                Name,
                Name,
                STRSIZE(Name),
                NAMETYPE_MESSAGEDEST,
                0);
    if (status != NERR_Success) {
        return(status);
    }
                
    //
    // Convert the unicode name string into an ansi string - using the
    // current locale.
    //
#ifdef UNICODE
    unicodeString.Length = (USHORT)(STRLEN(Name)*sizeof(WCHAR));
    unicodeString.MaximumLength = (USHORT)((STRLEN(Name)+1) * sizeof(WCHAR));
    unicodeString.Buffer = Name;

    ntStatus = RtlUnicodeStringToOemString(
                &ansiString,
                &unicodeString,
                TRUE);          // Allocate the ansiString Buffer.

    if (!NT_SUCCESS(ntStatus))
    {
        MSG_LOG(ERROR,
            "FmtNcbName:RtlUnicodeStringToOemString Failed rc=%X\n",
            ntStatus);

        return NetpNtStatusToApiStatus(ntStatus);
    }

    pAnsiString = ansiString.Buffer;
    *(pAnsiString+ansiString.Length) = '\0';
#else
    UNUSED(ntStatus);
    UNUSED(unicodeString);
    UNUSED(ansiString);
    pAnsiString = Name;
#endif  // UNICODE

    //
    // copy each character until a NUL is reached, or until NCBNAMSZ-1
    // characters have been copied.
    //
    for (i=0; i < NCBNAMSZ - 1; ++i) { 
        if (*pAnsiString == '\0') {
            break;        
        }

        //
        // Copy the Name
        //

        *DestBuf++ = *pAnsiString++;
    }

                
    
    //
    // Free the buffer that RtlUnicodeStringToOemString created for us.
    // NOTE:  only the ansiString.Buffer portion is free'd.
    //

#ifdef UNICODE
    RtlFreeOemString( &ansiString);
#endif // UNICODE

    //
    // Pad the name field with spaces
    //
    for(; i < NCBNAMSZ - 1; ++i) {
        *DestBuf++ = ' ';
    }
                          
    //
    // Set the name type.
    //
    NetpAssert( Type!=5 );          // 5 is not valid for NT.

    *DestBuf = (CHAR) Type;     // Set name type

    return(NERR_Success);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\apiutil.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    apidata.h

Abstract:

    contains prototypes for api helper utility function.

Author:

    Dan Lafferty (danl)     25-Jul-1991

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

    25-Jul-1991     danl
        created

--*/

#ifndef _APIUTIL_INCLUDED
#define _APIUTIL_INCLUDED


//
// Function Prototypes
//

DWORD        
MsgIsValidMsgName(
    IN LPTSTR  name
    );

DWORD
MsgMapNetError(
    IN  UCHAR   Code        // Error code
    );

DWORD
MsgLookupName(
    IN DWORD    net,        // The network card to search
    IN LPSTR    name        // Formatted name  (Non-unicode)
    );

DWORD
MsgLookupNameForThisSession(
    IN DWORD    net,        // The network card to search
    IN LPSTR    name,        // Formatted name to loook for (Non-unicode)
	IN ULONG	SessionId	 // Session Id to look for
    );

NET_API_STATUS
message_sec_check(VOID);

NET_API_STATUS 
MsgGatherInfo (
    IN      DWORD   Level,
    IN      LPSTR   FormattedName,
    IN OUT  LPBYTE  *InfoBufPtr,
    IN OUT  LPBYTE  *StringBufPtr
    );

NET_API_STATUS
MsgUnformatName(
    LPTSTR  UnicodeName,
    LPSTR   FormattedName
    );

BOOL
MsgIsSessionInList(
					   IN PLIST_ENTRY SessionIdList,
					   IN ULONG SessionId
					   );
VOID
MsgRemoveSessionFromList(
					     IN PLIST_ENTRY SessionIdList,
					     ULONG	SessionId
					     );

BOOL
MsgAddSessionInList(
					IN PLIST_ENTRY SessionIdList,
					ULONG	SessionId
					);

#endif // _APIUTIL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\data.c ===
/*****************************************************************/
/**                     Microsoft LAN Manager                   **/
/**               Copyright(c) Microsoft Corp., 1990            **/
/*****************************************************************/
// data.c
//
// This file contains most of the data declarations and set up routines
// used by the messenger service.
//
//
// Revision History:
//    02-Sep-1993     wlees
//        Provide synchronization between rpc routines and Pnp reconfiguration


#include "msrv.h"       // Message server declarations
#include <rpc.h>        // RPC_HANDLE
#include <winsvc.h>     // Defines for using service API

#include <smbtypes.h>   // needed for smb.h
#include <smb.h>        // Server Message Block definition
#include <netlib.h>     // UNUSED macro
#include <align.h>      // ROUND_UP_POINTER

#include "msgdbg.h"     // MSG_LOG
#include <svcs.h>       // Intrinsic service data

    GLOBAL_DATA GlobalData;

    HANDLE     wakeupEvent = 0;    // Master copy of wakeup event
    HANDLE     GrpMailslotHandle = INVALID_HANDLE_VALUE; // Event to signal mailslot has data
    PHANDLE     wakeupSem;      // Semaphores to clear on NCB completion


//
// Other  Global Data
//
//  The other misc. global data that the messenger uses.
//

    DWORD           MsgsvcDebugLevel; // Debug level flag used by MSG_LOG

    LPTSTR          MessageFileName;

    //
    // The local machine name and length/
    //
    TCHAR           machineName[NCBNAMSZ+sizeof(TCHAR)];
    SHORT           MachineNameLen;

    SHORT           mgid;                       // The message group i.d. counter

//
// The following is used to keep store the state of the messenger service
// Either it is RUNNING or STOPPING.
//
    DWORD           MsgrState;



//
// Handle returned by RegisterServiceCtrlHandle and needed to
// set the service status via SetServiceStatus
//
SERVICE_STATUS_HANDLE           MsgrStatusHandle;


//
// This string is used to mark the location of the time string in
// a message header so that the display thread can find after it reads
// it from the queue.
//
LPSTR           GlobalTimePlaceHolder        = "***";
LPWSTR          GlobalTimePlaceHolderUnicode = L"***";

//
// This is the string used in the title bar of the Message Box used
// to display messages.
// GlobalMessageBoxTitle will either point to the default string, or
// to the string allocated in the FormatMessage Function.
//
    WCHAR           DefaultMessageBoxTitle[]= L"Messenger Service";
    LPWSTR          GlobalAllocatedMsgTitle=NULL;
    LPWSTR          GlobalMessageBoxTitle=DefaultMessageBoxTitle;

//
// This is where well-known SIDs and pointers to RpcServer routines are
// stored.
//
    PSVCHOST_GLOBAL_DATA     MsgsvcGlobalData;


//
// Functions
//
//  The following routines are defined for creating and destroying the
//  data (arrays, etc.) defined above.
//

/* MsgInitSupportSeg
 *
 *  Allocates and initializes the segment containing the Support
 *  arrays.
 *
 */

NET_API_STATUS
MsgInitSupportSeg(VOID)
{

    unsigned int    size;
    DWORD           i;
    char far *      memPtr;
    DWORD           status;

    //
    // Calculate the buffer size.
    // *ALIGNMENT*      (Note the extra four bytes for alignment)
    //
    
    size = ((SD_NUMNETS() + 1) * sizeof(HANDLE));    

    wakeupSem = (PHANDLE) LocalAlloc(LMEM_ZEROINIT, size);
    if (wakeupSem == NULL) {
        status = GetLastError();
        MSG_LOG(ERROR,"[MSG]InitSupportSeg:LocalAlloc Failure %X\n", status);
        return(status);
    }

    return (NERR_Success);

}


VOID
MsgFreeSupportSeg(VOID)
{
    HANDLE  status;

    status = LocalFree (wakeupSem);
    if (status != 0) {
        MSG_LOG(ERROR,"FreeSupportSeg:LocalFree Failed %X\n",
        GetLastError());
    }
    wakeupSem = NULL;
    return;
}


BOOL
MsgDatabaseLock(
    IN MSG_LOCK_REQUEST request,
    IN LPSTR            idString
    )

/*++

Routine Description:

    This routine handles all access to the Messenger Service database
    lock.  This lock is used to protect access in the shared data segment.

    Reading the Database is handled with shared access.  This allows several
    threads to read the database at the same time.

    Writing (or modifying) the database is handled with exclusive access.
    This access is not granted if other threads have read access.  However,
    shared access can be made into exclusive access as long as no other
    threads have shared or exclusive access.

Arguments:

    request - This indicates what should be done with the lock.  Lock
        requests are listed in dataman.h

    idString - This is a string that identifies who is requesting the lock.
        This is used for debugging purposes so I can see where in the code
        a request is coming from.

Return Value:

    none:


--*/

{
    BOOL                fRet = TRUE;
    NTSTATUS            status;

    static RTL_RESOURCE MSG_DatabaseLock;
    static BOOL         s_fInitialized;

    switch(request) {

    case MSG_INITIALIZE:

        if (!s_fInitialized)
        {
            status = MsgInitResource(&MSG_DatabaseLock);

            if (!NT_SUCCESS(status))
            {
                MSG_LOG1(ERROR,
                         "MsgDatabaseLock: MsgInitResource failed %#x\n",
                         status);

                fRet = FALSE;
            }
            else
            {
                s_fInitialized = TRUE;
            }
        }
        break;

    case MSG_GET_SHARED:
        MSG_LOG(LOCKS,"%s:Asking for MSG Database Lock shared...\n",idString);
        fRet = RtlAcquireResourceShared( &MSG_DatabaseLock, TRUE );
        MSG_LOG(LOCKS,"%s:Acquired MSG Database Lock shared\n",idString);
        break;

    case MSG_GET_EXCLUSIVE:
        MSG_LOG(LOCKS,"%s:Asking for MSG Database Lock exclusive...\n",idString);
        fRet = RtlAcquireResourceExclusive( &MSG_DatabaseLock, TRUE );
        MSG_LOG(LOCKS,"%s:Acquired MSG Database Lock exclusive\n",idString);
        break;

    case MSG_RELEASE:
        MSG_LOG(LOCKS,"%s:Releasing MSG Database Lock...\n",idString);
        RtlReleaseResource( &MSG_DatabaseLock );
        MSG_LOG(LOCKS,"%s:Released MSG Database Lock\n",idString);
        break;

    default:
        break;
    }

    return fRet;
}


BOOL
MsgConfigurationLock(
    IN MSG_LOCK_REQUEST request,
    IN LPSTR            idString
    )

/*++

Routine Description:

    This routine handles all access to the Messenger Service Pnp Configuration
    lock.  This lock is used to protect access in the shared data segment.

    Reading the Database is handled with shared access.  This allows several
    threads to read the database at the same time.

    Writing (or modifying) the database is handled with exclusive access.
    This access is not granted if other threads have read access.  However,
    shared access can be made into exclusive access as long as no other
    threads have shared or exclusive access.

Arguments:

    request - This indicates what should be done with the lock.  Lock
        requests are listed in dataman.h

    idString - This is a string that identifies who is requesting the lock.
        This is used for debugging purposes so I can see where in the code
        a request is coming from.

Return Value:

    none:


--*/

{
    BOOL                fRet = TRUE;
    NTSTATUS            status;

    static RTL_RESOURCE MSG_ConfigurationLock;
    static BOOL         s_fInitialized;

    switch(request) {

    case MSG_INITIALIZE:
        if (!s_fInitialized)
        {
            status = MsgInitResource(&MSG_ConfigurationLock);

            if (!NT_SUCCESS(status))
            {
                MSG_LOG1(ERROR,
                         "MsgConfigurationLock: MsgInitResource failed %#x\n",
                         status);

                fRet = FALSE;
            }
            else
            {
                s_fInitialized = TRUE;
            }
        }
        break;

    case MSG_GET_SHARED:
        MSG_LOG(LOCKS,"%s:Asking for MSG Configuration Lock shared...\n",idString);
        fRet = RtlAcquireResourceShared( &MSG_ConfigurationLock, TRUE );
        MSG_LOG(LOCKS,"%s:Acquired MSG Configuration Lock shared\n",idString);
        break;

    case MSG_GET_EXCLUSIVE:
        MSG_LOG(LOCKS,"%s:Asking for MSG Configuration Lock exclusive...\n",idString);
        fRet = RtlAcquireResourceExclusive( &MSG_ConfigurationLock, TRUE );
        MSG_LOG(LOCKS,"%s:Acquired MSG Configuration Lock exclusive\n",idString);
        break;

    case MSG_RELEASE:
        MSG_LOG(LOCKS,"%s:Releasing MSG Configuration Lock...\n",idString);
        RtlReleaseResource( &MSG_ConfigurationLock );
        MSG_LOG(LOCKS,"%s:Released MSG Configuration Lock\n",idString);
        break;

    default:
        break;
    }

    return fRet;
}


NTSTATUS
MsgInitCriticalSection(
    PRTL_CRITICAL_SECTION  pCritsec
    )
{
    NTSTATUS  ntStatus;

    //
    // RtlInitializeCriticalSection will raise an exception
    // if it runs out of resources
    //

    try
    {
        ntStatus = RtlInitializeCriticalSection(pCritsec);

        if (!NT_SUCCESS(ntStatus))
        {
            MSG_LOG1(ERROR,
                     "MsgInitCriticalSection: RtlInitializeCriticalSection failed %#x\n",
                     ntStatus);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        MSG_LOG1(ERROR,
                 "MsgInitCriticalSection: Exception %#x caught initializing critsec\n",
                 GetExceptionCode());

        ntStatus = STATUS_NO_MEMORY;
    }

    return ntStatus;
}


NTSTATUS
MsgInitResource(
    PRTL_RESOURCE  pResource
    )
{
    NTSTATUS  ntStatus = STATUS_SUCCESS;

    //
    // RtlInitializeResource will raise an exception
    // if it runs out of resources
    //

    try
    {
        RtlInitializeResource(pResource);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        MSG_LOG1(ERROR,
                 "MsgInitResource: Exception %#x caught initializing resource\n",
                 GetExceptionCode());

        ntStatus = STATUS_NO_MEMORY;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\grpmsngr.c ===
/*--

Copyright (c) 1991  Microsoft Corporation

Module Name:

    grpmsngr.c

Abstract:

    This file contains the routines that provide support for messaging
    in a multi-domaign lan.  These routines comprise the group message thread
    of the messenger service.  The support of domain messaging is broken up
    into two phases.  The first, which takes place at initialization time of
    the messenger, sets up a mailslot thru which the second phase receives the
    information that it will need to process.  The second, phase, which runs
    in parallel with the existing messenger thread, reads messages out of this
    mailslot and logs them.

Author:

    Dan Lafferty (danl)     17-Jul-1991

Environment:

    User Mode -Win32

Notes:

     These routines receive and manipulate ansi strings, not UNICODE strings.
     The ANSI to UNICODE translation will be done in logsmb().

Revision History:

    17-Jul-1991     danl
        ported from LM2.0

--*/

#include "msrv.h"
#include <string.h>
#include <stdio.h>
#include <netlib.h>     // UNUSED macro

#include "msgdbg.h"     // MSG_LOG
#include "msgdata.h"

//
// GLOBALS
//
    LPSTR          DieMessage = "DIE";

    extern HANDLE  g_hGrpEvent;

//
// PROTOTYPES of internal functions
//


STATIC VOID
MsgDisectMessage(
    IN  LPSTR   message,
    OUT LPSTR   *from,
    OUT LPSTR   *to,
    IN  LPSTR   text);


//
// Defines
//


//
// Size of mailslot messages (bytes)
//
#define MESSNGR_MS_MSIZE    512

//
// size of mailslot (bytes)
//
#define MESSNGR_MS_SIZE     (5*MESSNGR_MS_MSIZE)



static char       Msg_Buf[MESSNGR_MS_MSIZE + 3];  // Buffer for messages + 3 NULs

static OVERLAPPED Overlapped;

static DWORD   bytes_read = 0;


NET_API_STATUS
MsgInitGroupSupport(DWORD iGrpMailslotWakeupSem)
{
    DWORD    err = 0;         // Error code info from the group  processor.

    GrpMailslotHandle = CreateMailslotA(
                        MESSNGR_MS_NAME,           // lpName
                        MESSNGR_MS_MSIZE,          // nMaxMessageSize
                        MAILSLOT_WAIT_FOREVER,     // lReadTimeout
                        NULL);                     // lpSecurityAttributes

    if (GrpMailslotHandle == INVALID_HANDLE_VALUE) {
        err = GetLastError();
        MSG_LOG(ERROR,"GroupMsgProcessor: CreateMailslot FAILURE %d\n",
            err);
    }
    else {
        MSG_LOG1(GROUP,"InitGroupSupport: MailSlotHandle = 0x%lx\n",
            GrpMailslotHandle);
    }

    return err;
}

VOID
MsgReadGroupMailslot(
    VOID
    )
{
    NET_API_STATUS Err = 0;

    //
    // Clean out receive buffers before each message
    //
    memset(Msg_Buf, 0, sizeof(Msg_Buf));
    memset(&Overlapped, 0, sizeof(Overlapped));

    if (!ReadFile(
                GrpMailslotHandle,
                Msg_Buf,
                sizeof(Msg_Buf) - 3,  // Leave 3 NULs at the end (see MsgDisectMessage)
                &bytes_read,
                &Overlapped) )
    {
        Err = GetLastError();

        if (Err == ERROR_INVALID_HANDLE)
        {
            //
            // If this handle is no longer good, it means the
            // mailslot system is down.  So we can't go on using
            // mailslots in the messenger.  Therefore, we want to
            // log that fact and shutdown this thread.
            //
            MsgErrorLogWrite(
                Err,         // Error Code
                SERVICE_MESSENGER,  // Component
                NULL,               // Buffer
                0L,                 // BufferSize
                NULL,               // Insertion strings
                0);                 // NumStrings
        }
    }

    return;
}

NET_API_STATUS
MsgServeGroupMailslot()
{
    LPSTR   from;
    LPSTR   to;
    CHAR    text[MAXGRPMSGLEN+3];   // +3 is for length word at
                                    // start of string (for
                                    // logsbm) and for NULL
                                    // terminator at end. NOTE:
                                    // disect_message() below
                                    // makes assumptions about
                                    // the length of this array.
    DWORD code;

    //
    // Process the message
    //
    if( !GetOverlappedResult( GrpMailslotHandle,
                               &Overlapped,
                               &bytes_read,
                               TRUE ) ) {
        MSG_LOG1(ERROR,"MsgServeGroupMailslot: GetOverlappedResult failed %d\n",
            GetLastError());
        return(GetMsgrState());
    }

    //
    // Check for Shutdown...
    //
    if ((bytes_read == 4) && (strcmp(Msg_Buf, DieMessage)==0)) {
        return(GetMsgrState());
    }

    MSG_LOG(TRACE,"MailSlot Message Received\n",0);

    __try {
        MsgDisectMessage( Msg_Buf, &from, &to, text );

        if (g_IsTerminalServer)
        {
            Msglogsbm (from, to, text, (ULONG)EVERYBODY_SESSION_ID);
        }
        else
        {
            Msglogsbm (from, to, text, 0);
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER, code = GetExceptionCode() ) {
        MSG_LOG(ERROR,"MsgServerGroupMailslot: Caught exception %d\n",code);
    }

    return(RUNNING);
}


/* Function: MsgDisectMessage
 *
 *        This function isolates the details of the structure of the message
 *  that gets sent through the mailslot from the rest of the thread.  Given
 *  the message buffer, this routine fills in the module globals From, To
 *  and Text with the proper parts of the message.
 *
 *  ENTRY
 *
 *        Expects one argument, which is a pointer to the buffer containing
 *        the message.
 *
 *  EXIT
 *
 *        This function does not return a value.
 *
 *  SIDE EFFECTS
 *
 *        Modifies the variables from, to and text.  The Msg_Buf
 *        may also be modified.
 *        Assumes the length of Text is at least MAXGRPMSGLEN+3.
 *
 */


VOID
MsgDisectMessage(
    IN  LPSTR   message,
    OUT LPSTR   *from,
    OUT LPSTR   *to,
    IN  LPSTR   text)
{

    LPSTR   txt_ptr;
    PSHORT  size_ptr;

    //
    // Note that message (a.k.a. Msg_Buf) is always triple-NUL terminated,
    // so calling strlen twice and adding 1 will always succeed, even if
    // the message isn't properly NUL-terminated (in that case, "from" will
    // point to all the text in the buffer and both "to" and "text will
    // point to empty strings).
    //
    *from = message;

    *to = (*from) + strlen(*from) +1;

    txt_ptr = (*to) + strlen(*to) +1;

    text[2] = '\0';

    strncpy(text+2, txt_ptr, MAXGRPMSGLEN);

    //
    // make sure it is NULL terminated
    //

    text[MAXGRPMSGLEN+2] = '\0';

    //
    // The first two bytes in the text buffer are to contain the length
    // the message. (in bytes).
    //
    size_ptr = (PSHORT)text;
    *size_ptr = (SHORT)strlen(text+2);

}

VOID
MsgGrpThreadShutdown(
    VOID
    )

/*++

Routine Description:

    This routine wakes up the wait on the Group Mailslot handle.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD       i;
    DWORD       numWritten;
    HANDLE      mailslotHandle;

    // If already stopped, don't bother
    if (GrpMailslotHandle == INVALID_HANDLE_VALUE) {
        MSG_LOG0(TRACE,"MsgGroupThreadShutdown: Group Thread has completed\n");
        return;
    }

    //
    // Wake up the Group Thread by sending "DIE" to its mailbox.
    //

    MSG_LOG(TRACE,"MsgThreadWakeup:Wake up Group Thread & tell it to DIE\n",0);

    mailslotHandle = CreateFileA (
                        MESSNGR_MS_NAME,        // lpFileName
                        GENERIC_WRITE,          // dwDesiredAccess
                        FILE_SHARE_WRITE | FILE_SHARE_READ, // dwShareMode
                        NULL,                   // lpSecurityAttributes
                        OPEN_EXISTING,          // dwCreationDisposition
                        FILE_ATTRIBUTE_NORMAL,  // dwFileAttributes
                        0L);                    // hTemplateFile

    if (mailslotHandle == INVALID_HANDLE_VALUE) {
        //
        // A failure occured.  It is assumed that the mailslot hasn't
        // been created yet.  In which case, the GrpMessageProcessor will
        // check the MsgrState directly after it creates the Mailslot and
        // will shut down as required.
        //
        MSG_LOG(TRACE,"MsgThreadWakeup: CreateFile on Mailslot Failed %d\n",
            GetLastError());

        //
        // Deregister the group work item lest the mailslot handle get closed
        // while the thread pool is still waiting on it when this function returns
        //
        DEREGISTER_WORK_ITEM(g_hGrpEvent);

        return;
    }

    MSG_LOG(TRACE,"MsgGroupThreadShutdown: MailSlotHandle = 0x%lx\n",mailslotHandle);
    if ( !WriteFile (
                mailslotHandle,
                DieMessage,
                strlen(DieMessage)+1,
                &numWritten,
                NULL)) {

        MSG_LOG(TRACE,"MsgThreadWakeup: WriteFile on Mailslot Failed %d\n",
            GetLastError())

        //
        // Since we can't wake up the group thread,
        // deregister the work item here instead
        //
        DEREGISTER_WORK_ITEM(g_hGrpEvent);
    }

    CloseHandle(mailslotHandle);

    //
    // Wait for the group messenger to be shutdown.
    // We will wait up to 20.300 seconds for this before going on.
    //
    Sleep(300);
    for (i=0; i<20; i++) {

        if (GrpMailslotHandle == INVALID_HANDLE_VALUE) {
            MSG_LOG0(TRACE,"MsgGroupThreadShutdown: Group Thread has completed\n");
            break;
        }

        MSG_LOG1(TRACE,"MsgGroupThreadShutdown: Group Thread alive after %d seconds\n",
                 (i + 1) * 1000);
        Sleep(1000);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\heap.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

#ifndef _HEAP_INCLUDED
#define _HEAP_INCLUDED

//static char *SCCSID = "@(#)heap.h    1.1 85/10/09";
//
//  Shared Memory Heap Allocator include file
// 


//
//  Constant definitions
// 
#define INULL   ((DWORD) -1)

//
//  Structure and macro definitions
//
 
//
// Heap Block Header
//
typedef struct blk {    
    DWORD   hp_size;    // Size of block incl. header
    DWORD   hp_flag;    // Allocation flag
}HEAPHDR, *PHEAPHDR, *LPHEAPHDR;

#define HP_SIZE(x)      (x).hp_size
#define HP_FLAG(x)      (x).hp_flag
#define HPTR(x)         ((LPHEAPHDR) &heap[(x)])
#define CPTR(x)         (&heap[(x)])
#define Msgheapfree(x)     HP_FLAG(*HPTR(x)) = 0

//
//  Data
// 
extern LPBYTE           heap;       // Pointer to start of heap
extern DWORD            heapln;     // Length of heap 

//
//  Functions
// 

DWORD 
Msgheapalloc(
    IN  DWORD   NumBytes
    );


#endif // _HEAP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\heap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    Contains a heap allocator function.

Author:

    Dan Lafferty (danl) 10-Jul-1991

Environment:

    User Mode - Win32

Revision History:

    10-Jul-1991 danl
        Ported from LM2.0

--*/

// static char *SCCSID = "@(#)heap.c    9.1 86/10/12";
//
//  Simple heap allocator for small heaps in shared memory areas.
// 

#include <windef.h>         // USHORT definitions
#include <heap.h>           // Constants, macros, etc.
#include <align.h>          // ROUND_UP_COUNT

    LPBYTE  heap = 0;       // Pointer to start of heap
    DWORD   heapln = 0;     // Length of heap


/*
 *  Msgheapalloc - simple heap allocator
 *
 *  This function allocates blocks out of a far heap.
 *  It assumes that when it is called the static variable
 *  heap points to the far heap and the static variable heapln
 *  contains the length of the far heap.
 *
 *  Msgheapalloc (cb)
 *
 *  ENTRY
 *    cb        - number of bytes to allocate including header
 *
 *  RETURN
 *    index in far heap to start of block of length cb, or
 *    INULL if no such block can be found or if cb < sizeof(HEAPHDR).
 *
 *  This function maintains a heap in which all
 *  blocks are implicitly linked.  The header of a block is
 *  three bytes long.  It contains the size of the block including
 *  the header and a one-byte flag which indicates whether the block
 *  is allocated or not.  Any non-zero value indicates that a block
 *  is allocated.  Note: Msgheapalloc() does NOT set the flag when it
 *  returns a block.  It is up to the caller to mark a block as
 *  allocated.  Unlike most heap allocators, Msgheapalloc() returns a
 *  pointer (index) to the header rather than just past the header.
 *  It does this because the message logging routines will need to
 *  know the lengths of blocks they process.  Also, in addition to
 *  indicating that a block is allocated, the flag byte will be used
 *  to indicate the type of the block (i.e. single block message,
 *  multi-block message header, etc.).  Since the logging routines
 *  will use the size of a block, it must be exactly the size
 *  requested.  
 *
 *  The algorithm used was chosen to minimize the size of the
 *  heap managing routines and to conform to the requirements
 *  of the logging routines.
 *
 *  SIDE EFFECTS
 *
 *  Changes the structure of the heap.
 */

DWORD                 
Msgheapalloc(
    IN DWORD   NumBytes     // No. of bytes to allocate
    )
{
    DWORD   i;              // Index to return
    DWORD   newi;           // New block index 
    DWORD   nexti;          // Next block index
    DWORD   numBytesNew;    // New block size

    //
    // Must request at least siz bytes
    //
    if(NumBytes < sizeof(HEAPHDR)) {
        return(INULL);
    }

    //
    // *ALIGNMENT*
    // If necessary, increase the requested size to cause the allocated
    // block to fall on a 4-byte aligned boundary.
    //

    NumBytes = ROUND_UP_COUNT(NumBytes,4);
    
    //
    // This loop is used to traverse the heap by following the
    // chain of blocks until either the end of the heap is reached
    // or a free block of suitable size is found.  Coalescing of
    // adjacent free blocks is performed herein also.
    //
    //
    // Loop to allocate block
    //
    for(i = 0; i < heapln; i += HP_SIZE(*HPTR(i))) {
        //
        // If free block found (hp_flag=0 indicates free),
        //
        if(HP_FLAG(*HPTR(i)) == 0) {
            //
            // A free block was found.
            // At this point, check to see if the current block can be
            // coalesced with the next block.  We start with the offset of
            // the current block.

            nexti = i;

            //
            // Add to it the size of the next consecutive 
            // free blocks until we reach the end of the heap, or an
            // allocated block is found.
            //
            while(  (nexti < heapln) && (HP_FLAG(*HPTR(nexti))==0) ) {
                nexti += HP_SIZE(*HPTR(nexti));
            }

            //
            // Coalesce blocks all free blocks found thus far
            //
            HP_SIZE(*HPTR(i)) = nexti - i;

            //
            // At this point, attempt to allocate from the current
            // free block.  The current free block must be exactly
            // the size we want or large enough to split, since we
            // must return a block whose size is EXACTLY the size
            // requested.
            // 
            if(HP_SIZE(*HPTR(i)) ==  NumBytes) {
                //
                // Size is perfect
                //
                return(i);      
            }

            if(HP_SIZE(*HPTR(i)) >= NumBytes + sizeof(HEAPHDR)) {
                //
                // If block is splittable, then get the index and size of
                // the block that is left over after taking out what is
                // needed from this allocate request.
                //
                newi = i + NumBytes;
                numBytesNew = HP_SIZE(*HPTR(i)) - NumBytes;

                //
                // Create a header for the left-over block by marking
                // it as free, and inserting the size.
                //
                HP_SIZE(*HPTR(newi)) = numBytesNew;
                HP_FLAG(*HPTR(newi)) = 0;

                //
                // Update the header for the allocated block and
                // return its index to the caller.
                // NOTE:  The caller is responsible for marking this block
                // as allocated.
                //
                HP_SIZE(*HPTR(i)) = NumBytes; 
                return(i);
            }
        }
    }
    return(INULL);      // Heap full
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgdbg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgdbg.h 

Abstract:

    Contains definitions used in debugging the messenger service.

Author:

    Dan Lafferty (danl)     08-Jul-1991

Environment:

    User Mode -Win32

Revision History:

    14-Jan-1993     Danl
        Created MSG_LOG functions for various number of arguments (up to 3).

--*/

#ifndef _MSGDBG_INCLUDED
#define _MSGDBG_INCLUDED

//
// Information levels used in switch statements.
//
#define LEVEL_0     0L
#define LEVEL_1     1L
#define LEVEL_2     2L

//
// Debug macros and constants.
//
extern DWORD    MsgsvcDebugLevel;

//
// The following allow debug print syntax to look like:
//
//   SC_LOG(DEBUG_TRACE, "An error occured %x\n",status)
//

#if DBG

#define MSG_LOG0(level,string)                      \
    if( MsgsvcDebugLevel & (DEBUG_ ## level)){      \
            DbgPrint("[MSGR]");                     \
            DbgPrint(string);                       \
    }

#define MSG_LOG1(level,string,var)                  \
    if( MsgsvcDebugLevel & (DEBUG_ ## level)){      \
        DbgPrint("[MSGR]");                         \
        DbgPrint(string,var);                       \
    }

#define MSG_LOG2(level,string,var1,var2)            \
    if( MsgsvcDebugLevel & (DEBUG_ ## level)){      \
        DbgPrint("[MSGR]");                         \
        DbgPrint(string,var1,var2);                 \
    }

#define MSG_LOG3(level,string,var1,var2,var3)       \
    if( MsgsvcDebugLevel & (DEBUG_ ## level)){      \
        DbgPrint("[MSGR]");                         \
        DbgPrint(string,var1,var2,var3);            \
    }

#define MSG_LOG(level,string,var)                   \
    if( MsgsvcDebugLevel & (DEBUG_ ## level)){      \
        DbgPrint("[MSGR]");                         \
        DbgPrint(string,var);                       \
    }

#define STATIC

#else //DBG

#define MSG_LOG0(level,string)
#define MSG_LOG1(level,string,var)
#define MSG_LOG2(level,string,var1,var2)
#define MSG_LOG3(level,string,var1,var2,var3)
#define MSG_LOG(level,string,var)

#define STATIC  static

#endif //DBG

#define DEBUG_NONE      0x00000000
#define DEBUG_ERROR     0x00000001
#define DEBUG_TRACE     0x00000002
#define DEBUG_LOCKS     0x00000004
#define DEBUG_GROUP     0x00000008
#define DEBUG_REINIT    0x00000010

#define DEBUG_ALL       0xffffffff

#endif // _MSGDBG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgdata.h ===
/*****************************************************************/ 
/**               Microsoft LAN Manager                         **/ 
/**            Copyright(c) Microsoft Corp., 1990               **/ 
/*****************************************************************/ 

#ifndef _MSGDATA_INCLUDED
#define _MSGDATA_INCLUDED

#include <winsvc.h>     // SERVICE_STATUS_HANDLE
#include <lmsname.h>    // SERVICE_MESSENGER
#include <msrv.h>       // NCBNAMSZ
#include <svcs.h>       // Intrinsic service data
//
//  See the file data.c for an explanation of all of these variables.
//

extern LPTSTR   MessageFileName;

extern HANDLE   wakeupEvent;         // Master copy of wakeup event
extern HANDLE   GrpMailslotHandle;   // Event to signal mailslot has data
extern PHANDLE   wakeupSem;         // Event to set on NCB completion


extern TCHAR    machineName[NCBNAMSZ+sizeof(TCHAR)]; // The local machine name

extern SHORT    MachineNameLen;         // The length of the machine name

extern SHORT    mgid;                   // The message group i.d. counter

extern USHORT   g_install_state;


extern SERVICE_STATUS_HANDLE MsgrStatusHandle;

extern LPSTR            GlobalTimePlaceHolder;
extern LPWSTR           GlobalTimePlaceHolderUnicode;

extern LPWSTR           DefaultMessageBoxTitle;
extern LPWSTR           GlobalAllocatedMsgTitle;
extern LPWSTR           GlobalMessageBoxTitle;
extern LPSTR            g_lpAlertSuccessMessage;
extern DWORD            g_dwAlertSuccessLen;
extern LPSTR            g_lpAlertFailureMessage;
extern DWORD            g_dwAlertFailureLen;
extern HANDLE           g_hNetTimeoutEvent;

extern PSVCHOST_GLOBAL_DATA  MsgsvcGlobalData;

#endif // _MSGDATA_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\mesprint.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mesprint.c

Abstract:

    Routines that format messages and place them in the alert buffer.

Author:

    Dan Lafferty (danl)     16-Jul-1991

Environment:

    User Mode -Win32

Revision History:

    16-Jul-1991     danl
        ported from LM2.0

--*/

//
// Includes
//

#include "msrv.h"

#include <string.h>     // memcpy
#include <tstring.h>    // Unicode string macros
#include <netdebug.h>   // NetpAssert

#include <netlib.h>     // UNUSED macro
#include <smbtypes.h>   // needed for smb.h
#include <smb.h>        // Server Message Block definitions
#include <apperr.h>     // APE_MSNGR_ definitions

#include "msgdbg.h"     // MSG_LOG
#include "heap.h"
#include "msgdata.h"
#include <time.h>       // struct tm, time_t


//
// Local Functions
//

DWORD
Msgappend_message(
    IN USHORT   msgno,
    IN LPSTR    buf,
    IN LPSTR    *strarr,
    IN USHORT   nstrings
    );

DWORD
Msglog_write(
    LPSTR   text,
    HANDLE  file_handle
    );

//
// Global alert buffer data areas. Not used when called from API
//

LPSTR           alert_buf_ptr;    // Pointer to DosAlloc'ed alert buffer
USHORT          alert_len;        // Currently used length of alert buffer

extern LPTSTR   MessageFileName;


/*
** append_message --
**
**   Gets a message from the message file, and appends it to the
**   given string buffer.
**   The message file used is the one named in the Global MessageFileName,
**   and thus in the Messenger we assume that SetUpMessageFile is called
**   before this to properly fill in this variable.
**
**  NOTE: This function deals only with Ansi Strings - Not Unicode Strings.
**      The Unicode translation is done all at once just before the alert
**      is raised.
**
**/

DWORD
Msgappend_message(
    IN USHORT   msgno,
    IN LPSTR    buf,
    IN LPSTR    *strarr,
    IN USHORT   nstrings
    )
{

    WORD    msglen=0;
    DWORD   result;

    LPSTR   mymsgbuf = 0;
    LPSTR   msgfile = 0;
    LPSTR   pmb;


    //
    // get a segment to read the message into
    //

    result = 0;

    mymsgbuf = LocalAlloc(LMEM_ZEROINIT,(int)max(MAXHEAD+1, MAXEND+1));

    if (mymsgbuf == NULL) {
        result = GetLastError();
        MSG_LOG(ERROR,"append_message:LocalAlloc failed %X\n",result);
        return (result);
    }

    //
    // Need to fix DosGetMessage to only take ansi strings.
    //

    if (result == 0)
    {
        result = DosGetMessage(
                    strarr,                     // String substitution table
                    nstrings,                   // Num Entries in table above
                    mymsgbuf,                   // Buffer receiving message
                    (WORD)max(MAXHEAD, MAXEND), // size of buffer receiving msg
                    msgno,                      // message num to retrieve
                    MessageFileName,            // Name of message file
                    &msglen);                   // Num bytes returned

#ifdef later  // Currently there is no backup name

        if ( result != 0) {
            //
            // if the attempt to get the message out of the message file fails,
            // get it out of the messages that were bound in to our exe at
            // build time.  These are the same, but are from bak.msg. The
            // Backup message file is never really there, but the messages
            // needed from it are bound in to the exe, so we will get them.
            //

            result = DosGetMessage(
                        strarr,
                        nstrings,
                        mymsgbuf,
                        (int)max(MAXHEAD, MAXEND),
                        msgno,
                        BACKUP_MSG_FILENAME,
                        (unsigned far *) &msglen);
        }
#endif
    }

    //
    // if there is still an error we are in big trouble.  Return whatever
    // dosgetmessage put into the buffer for us.  It is supposed to be
    // printable.
    //

    if ( result != 0 ) {
        LocalFree (mymsgbuf);
        return (result);
    }

    mymsgbuf[msglen] = 0;

#ifdef removeForNow
    //
    // NOTE:  The following logic is skipped because DosGetMessage doesn't
    //        seem to return any NETxxxx field.
    //
    // now get rid of the NETxxxx:   from the beginning (9 chars)
    //

    pmb = strchrf(mymsgbuf,' ');    // find first space

    if ( pmb == NULL ) {
        pmb = mymsgbuf;             // Just so strcatf doesn't GP Fault.
    }
    else {
        pmb++;                      // start with next char
    }

    strcatf(buf,pmb);               // copy over the buffer
#else
    UNUSED(pmb);
    strcpy(buf,mymsgbuf);           // copy over the buffer
#endif

    LocalFree (mymsgbuf);

    return (result);

}


/*
**  Msghdrprint - print a message header
**
**  This function prints a message header using the time and
**  date format appropriate for the current country.
**
**  hdrprint (action, from, to, date, time, file_handle)
**
**  ENTRY
**        action                : 0 = alert and file
**                         -1 = file only
**                          1 = alert only
**        from                - name of sender
**        to                - name of intended recipient
**        bigtime                - bigtime of message
**        file_handle        - log file handle
**
**  RETURN
**        0 - Success, else file system error
**
**  This function prints the given information in the appropriate
**  format.  The names are passed as far pointers so that names in
**  the shared data area do not have to be copied into the automatic
**  data segment in order to print them.
**
**  SIDE EFFECTS
**
**  Calls the DOS to get country-dependent information.
**/

#define SINGLE_SPACE        "\n\r"
#define SINGLE_SPACE_LEN    (sizeof("\n\r") - 1)

DWORD
Msghdrprint(
    int          action,         // Where to log the header to.
    LPSTR        from,           // Name of sender
    LPSTR        to,             // Name of recipient
    SYSTEMTIME   bigtime,        // Bigtime of message
    HANDLE       file_handle     // Output file handle
    )
{
    //
    // hdr_buf didn't account for the extra line feed, carriage ret.
    //
    char    hdr_buf[MAXHEAD + SINGLE_SPACE_LEN + 1]; // Buffer header text
    char    time_buf[TIME_BUF_SIZE];
    DWORD   status;                         // file write status
    DWORD   i=0;                            // Index into header_buf
    LPSTR   str_table[3];                   // For DosGetMessage

    *(hdr_buf + MAXHEAD) = '\0';            // for strlen
    hdr_buf[0] = '\0';

    str_table[0] = from;
    str_table[1] = to;

    //******************************
    //
    // Because we queue messages, and a user my not be logged on when the
    // message is queued.  We want to instead, put a place-holder in the
    // message buffer for the time.  Later, when we read from the queue, we
    // will add the time string formatted for the logged on user.
    //
    strcpy (time_buf, GlobalTimePlaceHolder);

    //******************************

    str_table[2] = time_buf;

    // Try to get the message from the message file or from the backup
    // in memory.  This will always leave something in the hdr_buf that
    // is printable, if not correct.
    //
    // 11-13-96 : It is not sufficient to ignore the Msgappend_message return
    //            code and plod onward.  If Msgappend_message fails, there
    //            may be simply "\r\n" left in hdr_buf. Printable, yes, but
    //            it will cause an A/V later. Check the return code and bail
    //            if this call fails.
    //

    status = Msgappend_message(APE_MSNGR_HDR, hdr_buf, str_table, 3);

    if (status) {
        return(status);
    }

    strcat( hdr_buf,"\r\n");

    status = 0;                        // assume success

    if( action >= 0 ) {

        //
        // If alert and file or alert only,
        // then copy hdr_buf to alert buffer.
        //
        memcpy( &(alert_buf_ptr[alert_len]),
                hdr_buf,
                i = strlen(hdr_buf));

        alert_len += (USHORT)i;
    }

    if( action < 1) {

        DbgPrint("mesprint.c:hdrprint:We should never get here\n");
        NetpAssert(0);
        //
        // if file and alert or file only, attempt to write
        // header to log file.
        //
        status = Msglog_write(hdr_buf, file_handle);
    }
    return(status);
}

/*
**  Msgmbmfree - deallocate the pieces of a multi-block message
**
**  Given an index to the header of a multi-block message, this function
**  deallocates the header block and all of the text blocks.
**
**  mbmfree (mesi)
**
**  ENTRY
**        mesi                - index into the message buffer
**
**  RETURN
**        nothing
**
**  This function deallocates a multi-block message piece by piece.
**
**  SIDE EFFECTS
**
**  Calls heapfree() to deallocate each piece.
**/

VOID
Msgmbmfree(
    DWORD   mesi        // Message index
    )

{
    DWORD  text;        // Index to text

    text = MBB_FTEXT(*MBBPTR(mesi));    // Get the index to the text
    Msgheapfree(mesi);                  // Deallocate the message header

    //
    // The following loop deallocates each text block in the chain.
    //

    while(text != INULL) {              // While not at end of chain
        mesi = text;                    // Save index
        text = MBT_NEXT(*MBTPTR(text)); // Get link to next block
        Msgheapfree(mesi);              // Free this block
    }
}


/*
**  Msgmbmprint - print a multi-block message
**
**  This function writes a multi-block message to the log file.
**
**  mbmprint (action, mesi, file_handle)
**
**  ENTRY
**        action                : 0 = alert and file
**                         -1 = file only
**                          1 = alert only
**        mesi                - index into the message buffer
**        file_handle        - log file handle
**
**  RETURN
**        0 - Success, else file system error
**
**  This function writes the message starting at the mesi'th byte in the
**  message buffer (in the shared data area) to the log file.  It returns
**  the value EOF if the writing of the message fails.
**
**  SIDE EFFECTS
**
**  Calls hdrprint(), txtprint(), and endprint().
**/

DWORD
Msgmbmprint(
    int     action,         // Alert, File, or Alert and file
    DWORD   mesi,           // Message index
    HANDLE  file_handle,    // Log file handle
    LPDWORD pdwAlertFlag
    )

{
    LPSTR   from;           // Sender
    LPSTR   to;             // Recipient
    DWORD   text;           // Index to text
    DWORD   state;          // Final state of message
    DWORD   status;         // File write status

    from  = &CPTR(mesi)[sizeof(MBB)];   // Get pointer to sender name
    to    = &from[strlen(from) + 1];    // Get pointer to recipient name

    state = MBB_STATE(*MBBPTR(mesi));   // Save the state
    text  = MBB_FTEXT(*MBBPTR(mesi));   // Get the index to the text

    //
    // Hack to drop messages sent by pre-Whistler Spoolers.  As of
    // Whistler, print notifications are done as shell balloon tips
    // so don't display print alerts sent from the server as well.
    //
    // This same check is done in Msglogsbm for single-block messages.
    //

    if ((g_lpAlertSuccessMessage
         &&
         _strnicmp(&CPTR(text)[sizeof(MBT)], g_lpAlertSuccessMessage, g_dwAlertSuccessLen) == 0)
        ||
        (g_lpAlertFailureMessage
         &&
         _strnicmp(&CPTR(text)[sizeof(MBT)], g_lpAlertFailureMessage, g_dwAlertFailureLen) == 0))
    {
        //
        // Tell the caller not to output this message
        //

        *pdwAlertFlag = 0xffffffff;
        return NO_ERROR;
    }

    if ((status = Msghdrprint(
                     action,
                     from,
                     to,
                     MBB_BIGTIME(*MBBPTR(mesi)),
                     file_handle)) != 0)
    {
        return status;                 // Fail if error on header write
    }

    //
    // The following loop prints out each text block in the chain.
    //
    while(text != INULL) {              // While not at end of chain

        if((status = Msgtxtprint(
                        action,
                        &CPTR(text)[sizeof(MBT)],
                        MBT_COUNT(*MBTPTR(text)),   // *ALIGNMENT2*
                        file_handle)) != 0) {

            break;                      // If write error
        }
        text = MBT_NEXT(*MBTPTR(text)); // Get link to next block
    }

    return status;
}


/*
**  Msgtxtprint - print text of message
**
**  This function prints a block of text.
**
**  txtprint ( action, text, length, file_handle)
**
**  ENTRY
**        action                : 0 = alert and file
**                         -1 = file only
**                          1 = alert only
**        text                - pointer to text
**        length                - length of text
**        file_handle        - log file handle
**
**  RETURN
**        0 - Success, else file system error
**
**  This function prints the given amount of text.  The text pointer is
**  a far pointer so that text blocks in the shared data area do not have
**  to be copied into the automatic data segment in order to process
**  them.
**
**  SIDE EFFECTS
**
**  Converts the character '\024' to the sequence '\015', '\012' on output.
**/

DWORD
Msgtxtprint(
    int     action,         // Alert, File, or Alert and file
    LPSTR   text,           // Pointer to text
    DWORD   length,         // Length of text
    HANDLE  file_handle     // Log file handle
    )

{
    LPSTR   buffer;             // Text buffer
    LPSTR   cp;                 // Character pointer
    DWORD   i;                  // Counter
    DWORD   status = 0;         // error return

// [wlees 3/6/98] This code path is used by larger messages than just single
// block messages, so size the buffer dynamically.
// Double space to be paranoid for eol expansion

    if (length == 0)
    {
        return 1;
    }

    //
    // Add 1 to prevent a message of all linefeed characters
    // from causing a buffer overrun when we add the '\0'
    //
    buffer = LocalAlloc( LMEM_FIXED, 2 * length + 1);

    if (buffer == NULL)
    {
        return 1;
    }

    cp = buffer;                        // Initialize

    //
    // Loop to translate text
    //
    for(i = length; i != 0; --i)
    {
        if(*text == '\024')
        {
            //
            // If IBM end-of-line character
            //

            ++length;                   // Length has increased
            *cp++ = '\r';               // Carriage return
            *cp++ = '\n';               // Linefeed
        }
        else
        {
            //
            // Else copy character as is
            //

            *cp++ = *text;
        }
        ++text;                         // Increment pointer
    }
    *cp = '\0';                         // So can use log_write

    if( action >= 0)
    {
        //
        // if alert and file or alert only
        //

        if( alert_len < ALERT_MAX_DISPLAYED_MSG_SIZE + 1)
        {
            memcpy( &alert_buf_ptr[alert_len], buffer, strlen(buffer));
            alert_len += (USHORT)strlen(buffer);
        }
    }

    if( action < 1)
    {
        //
        // if file and alert or file only, write text to log file
        //
        status = Msglog_write(buffer,file_handle);
    }

    LocalFree( buffer );

    return status;          // Cannot fail on alert only
}


/*
**  Msgopen_append - opens the requested file for read/write and seeks to the
**                   end of the file.
**
**   open_append - ( file_name, file_handle_ptr)
**
**  ENTRY
**        file_name        - pointer to file_name
**        file_handle_ptr        - pointer to unsigned short to store file pointer
**
**  RETURN
**        0 - Success, else file system error
**
**  SIDE EFFECTS
**
**/

DWORD
Msgopen_append(
    LPSTR       file_name,          // Name of file to open
    PHANDLE     file_handle_ptr    // pointer to storage for file handle
    )
{
    NetpAssert(0);
    UNUSED (file_name);
    UNUSED (file_handle_ptr);
    return(0);
}





/*
**  Msglog_write - writes a text string to the log file..
**
**   log_write - ( text, file_handle)
**
**  ENTRY
**      text                - text string to write to file.
**        file_handle        - log file handle
**
**  RETURN
**        0 - Success, else file system error
**
**  SIDE EFFECTS
**
**/

DWORD
Msglog_write(
    LPSTR   text,           // String to write to log file*/
    HANDLE  file_handle     // log file handle
    )
{
    NetpAssert(0);
    UNUSED (text);
    UNUSED (file_handle);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgapi.c

Abstract:

    Provides API functions for the messaging system.

Author:

    Dan Lafferty (danl)     23-Jul-1991

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

    02-Sep-1993     wlees
        Provide synchronization between rpc routines and Pnp reconfiguration

    13-Jan-1993     danl
        NetrMessageNameGetInfo: Allocation size calculation was incorrectly
        trying to take the sizeof((NCBNAMSZ+1)*sizeof(WCHAR)).  NCBNAMSZ is
        a #define constant value.

    22-Jul-1991     danl
        Ported from LM2.0

--*/

//
// Includes
//

#include "msrv.h"

#include <tstring.h>    // Unicode string macros
#include <lmmsg.h>

#include <netlib.h>     // UNUSED macro
#include <netlibnt.h>   // NetpNtStatusToApiStatus

#include <msgrutil.h>   // NetpNetBiosReset
#include <rpc.h>
#include <msgsvc.h>     // MIDL generated header file
#include "msgdbg.h"     // MSG_LOG
#include "heap.h"
#include "msgdata.h"
#include "apiutil.h"
#include "msgsec.h"     // Messenger Security Information

#include "msgsvcsend.h"   // Broadcast message send interface
// Static data descriptor strings for remoting the Message APIs

static char nulstr[] = "";



NET_API_STATUS
NetrMessageNameEnum(
    IN      LPWSTR              ServerName,
    IN OUT  LPMSG_ENUM_STRUCT   InfoStruct,
    IN      DWORD               PrefMaxLen,
    OUT     LPDWORD             TotalEntries,
    IN OUT  LPDWORD             ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    This function provides information about the message service name table
    at two levels of detail.

Arguments:

    ServerName - Pointer to a string containing the name of the computer
        that is to execute the API function.

    InfoStruct - Pointer to a structure that contains the information that
        RPC needs about the returned data.  This structure contains the
        following information:
            Level - The desired information level - indicates how to
                interpret the structure of the returned buffer.
            EntriesRead - Indicates how many elements are returned in the
                array of structures that are returned.
            BufferPointer - Location for the pointer to the array of
                structures that are being returned.

    PrefMaxLen - Indicates a maximum size limit that the caller will allow
        for the return buffer.

    TotalEntries - Pointer to a value that upon return indicates the total
        number of entries in the "active" database.

    ResumeHandle - Inidcates where in the linked list to start the
        enumeration.  This is an optional parameter and can be NULL.

Return Value:

    NERR_Success - The operation was successful.  EntriesRead is valid.

    ERROR_INVALID_LEVEL - An invalid info level was passed in.

    ERROR_MORE_DATA - Not all the information in the database could be
        returned due to the limititation placed on buffer size by
        PrefMaxLen.  One or more information records will be found in
        the buffer.  EntriesRead is valid.

    ERROR_SERVICE_NOT_ACTIVE - The service is stopping.

    NERR_BufTooSmall - The limitation (PrefMaxLen) on buffer size didn't
        allow any information to be returned.  Not even a single record
        could be fit in a buffer that small.

    NERR_InternalError - A name in the name table could not be translated
        from ansi characters to unicode characters.  (Note:  this
        currently causes 0 entries to be returned.)


--*/
{

    DWORD           hResume = 0;    // resume handle value
    DWORD           entriesRead = 0;
    DWORD           retBufSize;
    LPBYTE          infoBuf;
    LPBYTE          infoBufTemp;
    LPBYTE          stringBuf;

    DWORD           entry_length;   // Length of one name entry in buf
    DWORD           i,j,k;          // index for name loop and flags
    NET_API_STATUS  status=0;
    DWORD           neti;           // net index
    ULONG           SessionId = 0;  // client session Id

    DWORD           dwMsgrState = GetMsgrState();

    UNUSED (ServerName);

    if (dwMsgrState == STOPPING || dwMsgrState == STOPPED) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Synchronize with Pnp configuration routine
    //
    MsgConfigurationLock(MSG_GET_SHARED,"NetrMessageNameEnum");

    //
    // If ResumeHandle is present and valid, initialize it.
    //
    if (ARGUMENT_PRESENT(ResumeHandle) && (*ResumeHandle < NCBMAX(0))) {
        hResume = *ResumeHandle;
    }

    //
    //  In Hydra case, the display thread never goes asleep.
    //
    if (!g_IsTerminalServer)
    {
        //
        // Wakeup the display thread so that any queue'd messages can be
        // displayed.
        //
        MsgDisplayThreadWakeup();
    }

    //
    // Initialize some of the return counts.
    //

    *TotalEntries = 0;

    //
    // API security check. This call can be called by anyone locally,
    // but only by admins in the remote case.
    //

    status = NetpAccessCheckAndAudit(
                SERVICE_MESSENGER,              // Subsystem Name
                (LPWSTR)MESSAGE_NAME_OBJECT,    // Object Type Name
                MessageNameSd,                  // Security Descriptor
                MSGR_MESSAGE_NAME_ENUM,         // Desired Access
                &MsgMessageNameMapping);        // Generic Mapping

    if (status != NERR_Success) {
        MSG_LOG(TRACE,
            "NetrMessageNameEnum:NetpAccessCheckAndAudit FAILED %X\n",
            status);
        status = ERROR_ACCESS_DENIED;
        goto exit;
    }

    if (g_IsTerminalServer)
    {
        // get the client session id
        status = MsgGetClientSessionId(&SessionId);
        if (status != NERR_Success) {
            MSG_LOG(TRACE,
                "NetrMessageNameEnum:Could not get client session Id \n",0);
            goto exit;
        }
    }

    //
    // Determine the size of one element in the returned array.
    //
    switch( InfoStruct->Level) {
    case 0:
        if (InfoStruct->MsgInfo.Level0 == NULL)
        {
            status = ERROR_INVALID_PARAMETER;
            goto exit;
        }
        entry_length = sizeof(MSG_INFO_0);
        break;

    case 1:
        if (InfoStruct->MsgInfo.Level0 == NULL)
        {
            status = ERROR_INVALID_PARAMETER;
            goto exit;
        }
        entry_length = sizeof(MSG_INFO_1);
        break;

    default:
        status = ERROR_INVALID_LEVEL;
        goto exit;
    }

    //
    // Allocate enough space for return buffer
    //
    if (PrefMaxLen == -1) {
        //
        // If the caller has not specified a size, calculate a size
        // that will hold the entire enumeration.
        //
        retBufSize =
            ((NCBMAX(0) * ((NCBNAMSZ+1) * sizeof(WCHAR))) +  // max possible num strings
             (NCBMAX(0) * entry_length));                    // max possible num structs
    }
    else {
        retBufSize = PrefMaxLen;
    }

    infoBuf = (LPBYTE)MIDL_user_allocate(retBufSize);

    if (infoBuf == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    stringBuf = infoBuf + (retBufSize & ~1);    // & ~1 to align Unicode strings

    //
    // Block until data free
    //
    MsgDatabaseLock(MSG_GET_EXCLUSIVE,"NetrMessageNameEnum");

    //
    // Now copy as many names from the shared data name table as will fit
    // into the callers buffer. The shared data is locked so that the name
    // table can not change while it is being copied (eg by someone
    // deleting a forwarded name on this station after the check for a valid
    // name has been made but before the name has been read). The level 1
    // information is not copied in this loop as it requires network
    // activity which must be avoided while the shared data is locked.
    //

    //
    // HISTORY:
    //
    // The original LM2.0 code looked at the names on all nets, and
    // threw away duplicate ones.  This implies that a name may appear
    // on one net and not on another.  Although, this can never happen if
    // the names are always added via NetMessageNameAdd since that API
    // will not add the name unless it can be added to all nets.  However,
    // forwarded names are added via a network receive, and may be added
    // from one net only.
    //
    // Since NT is not supporting forwarding, it is no longer necessary to
    // check each net.  Since the only way to add names if via NetServiceAdd,
    // this will assure that the name listed for one network are the same
    // as the names listed for the others.
    //

    infoBufTemp = infoBuf;
    neti=j=0;
    status = NERR_Success;

    for(i=hResume; (i<NCBMAX(neti)) && (status==NERR_Success); ++i) {

        if (!(SD_NAMEFLAGS(neti,i) & (NFDEL | NFDEL_PENDING))) {
            //
            // in HYDRA case, we also consider the SessionId
            //
            if ((g_IsTerminalServer) && (!(MsgIsSessionInList(&(SD_SIDLIST(neti,i)), SessionId )))) {
                continue;
            }

            //
            // If a name is found we put it in the buffer if the
            // following conditions are met.  If we are processing
            // the first net's names, put it in, it cannot be a
            // duplicate.  Otherwise, only put it in if it is not
            // a duplicate of a name that is already in the user
            // buffer.
            // (NT_NOTE:  duplicate names cannot occur).
            //

            //
            // translate the name to unicode and put it into the buffer
            //
            status = MsgGatherInfo (
                        InfoStruct->Level,
                        SD_NAMES(neti,i),
                        &infoBufTemp,
                        &stringBuf);

            if (status == NERR_Success) {
                entriesRead++;
                hResume++;
            }
        }
    }

    //
    // Calculate the total number of entries by seeing how many names are
    // left in the table and adding that to the entries read.
    //
    if (status == ERROR_NOT_ENOUGH_MEMORY) {

        status = ERROR_MORE_DATA;

        for (k=0; i < NCBMAX(neti); i++) {
            if(!(SD_NAMEFLAGS(neti,i) & (NFDEL | NFDEL_PENDING))) {
                k++;
            }
        }
        *TotalEntries = k;
    }
    *TotalEntries += entriesRead;

    //
    // Free up the shared data table
    //
    MsgDatabaseLock(MSG_RELEASE,"NetrMessageNameEnum");

    //
    // If some unexpected error occured, ( couldn't unformat the name
    // - or a bogus info level was passed in), then return the error.
    //

    if ( ! ((status == NERR_Success) || (status == ERROR_MORE_DATA)) ) {
        MIDL_user_free(infoBuf);
        infoBuf = NULL;
        entriesRead = 0;
        hResume = 0;
        goto exit;
    }

    //
    // if there were no entries read then either there were no more
    // entries in the table, or the resume number was bogus.
    // In this case, we want to free the allocated buffer storage.
    //
    if (entriesRead == 0) {
        MIDL_user_free(infoBuf);
        infoBuf = NULL;
        entriesRead = 0;
        hResume = 0;
        status = NERR_Success;
        if (*TotalEntries > 0) {
            status = NERR_BufTooSmall;
        }
    }

    //
    // If we have finished enumerating everything, reset the resume
    // handle to start at the beginning next time.
    //
    if (entriesRead == *TotalEntries) {
        hResume = 0;
    }

    //
    // Load up the information to return
    //
    switch(InfoStruct->Level) {
    case 0:
        InfoStruct->MsgInfo.Level0->EntriesRead = entriesRead;
        InfoStruct->MsgInfo.Level0->Buffer = (PMSG_INFO_0)infoBuf;
        break;

    case 1:
        InfoStruct->MsgInfo.Level0->EntriesRead = entriesRead;
        InfoStruct->MsgInfo.Level0->Buffer = (PMSG_INFO_0)infoBuf;
        break;

    default:
        //
        // This was checked above
        //
        ASSERT(FALSE);
    }

    if (ARGUMENT_PRESENT(ResumeHandle)) {
        *ResumeHandle = hResume;
    }

exit:

    MsgConfigurationLock(MSG_RELEASE,"NetrMessageNameEnum");

    return (status);
}


NET_API_STATUS
NetrMessageNameGetInfo(
    IN  LPWSTR      ServerName,     // unicode server name, NULL if local
    IN  LPWSTR      Name,           // Ptr to asciz name to query
    IN  DWORD       Level,          // Level of detail requested
    OUT LPMSG_INFO  InfoStruct      // Ptr to buffer for info
    )

/*++

Routine Description:

   This funtion provides forwarding information about a known message server
   name table entry.  However, since we do not support forwarding in NT,
   this API is totally useless.  We'll support it anyway though for
   compatibility purposes.

Arguments:

    ServerName - Pointer to a string containing the name of the computer
        that is to execute the API function.

    Name - The Messaging name that we are to get info on.

    Level - The level of information desired

    InfoStruct - Pointer to a location where the pointer to the returned
        information structure is to be placed.


Return Value:



--*/
{
    NET_API_STATUS  status=NERR_Success;
    LPMSG_INFO_0    infoBuf0;
    LPMSG_INFO_1    infoBuf1;
    CHAR            formattedName[NCBNAMSZ];
    ULONG           SessionId = 0;    // Client Session Id

    DWORD           dwMsgrState = GetMsgrState();

    UNUSED (ServerName);

    if (dwMsgrState == STOPPING || dwMsgrState == STOPPED)
    {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    if (MsgIsValidMsgName(Name) != 0)
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Synchronize with Pnp configuration routine
    //
    MsgConfigurationLock(MSG_GET_SHARED,"NetrMessageNameGetInfo");

    //
    //  In Hydra case, the display thread never goes asleep.
    //
    if (!g_IsTerminalServer)
    {
        //
        // Wakeup the display thread so that any queue'd messages can be
        // displayed.
        //
        MsgDisplayThreadWakeup();
    }

    //
    // API security check. This call can be called by anyone locally,
    // but only by admins in the remote case.
    //

    status = NetpAccessCheckAndAudit(
                SERVICE_MESSENGER,              // Subsystem Name
                (LPWSTR)MESSAGE_NAME_OBJECT,    // Object Type Name
                MessageNameSd,                  // Security Descriptor
                MSGR_MESSAGE_NAME_INFO_GET,     // Desired Access
                &MsgMessageNameMapping);        // Generic Mapping

    if (status != NERR_Success) {
        MSG_LOG(TRACE,
            "NetrMessageNameGetInfo:NetpAccessCheckAndAudit FAILED %X\n",
            status);
        status = ERROR_ACCESS_DENIED;
        goto exit;
    }

    //
    // Format the name so it matches what is stored in the name table.
    //
    status = MsgFmtNcbName(formattedName, Name, NAME_LOCAL_END);
    if (status != NERR_Success) {
        MSG_LOG(ERROR,"NetrMessageGetInfo: could not format name\n",0);
        status = NERR_NotLocalName;
        goto exit;
    }


    status = NERR_Success;

    //
    // Look for the name in the shared data name array.  (1st net only).
    //

    if (g_IsTerminalServer)
    {
	    //	get the client session id
	    status = MsgGetClientSessionId(&SessionId);
        if (status != NERR_Success) {
            MSG_LOG(ERROR,"NetrMessageGetInfo: could not get session id\n",0);
            goto exit;
        }
    }

	// look for the name in the database
    if (MsgLookupNameForThisSession(0, formattedName, SessionId) == -1) {
        MSG_LOG(ERROR,"NetrMessageGetInfo: Name not in table\n",0);
        status = NERR_NotLocalName;
        goto exit;
    }

    //
    // Allocate storage for the returned buffer, and fill it in.
    //

    switch(Level) {
    case 0:
        infoBuf0 = (LPMSG_INFO_0)MIDL_user_allocate(
                    sizeof(MSG_INFO_0) + ((NCBNAMSZ+1)*sizeof(WCHAR)));
        if (infoBuf0 == NULL) {
            MSG_LOG(ERROR,
                "NetrMessageNameGetInfo MIDL allocate FAILED %X\n",
                GetLastError());
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        //
        // copy the name and set the pointer in the structure to point
        // to it.
        //
        STRCPY((LPWSTR)(infoBuf0 + 1), Name);
        infoBuf0->msgi0_name = (LPWSTR)(infoBuf0 + 1);
        (*InfoStruct).MsgInfo0 = infoBuf0;

        break;

    case 1:
        infoBuf1 = (LPMSG_INFO_1)MIDL_user_allocate(
                    sizeof(MSG_INFO_1) + ((NCBNAMSZ+1)*sizeof(WCHAR)) );

        if (infoBuf1 == NULL) {
            MSG_LOG(ERROR,
                "NetrMessageNameGetInfo MIDL allocate FAILED %X\n",
                GetLastError());
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        //
        // Copy the name, update pointers, and set forward info fields.
        //
        STRCPY((LPWSTR)(infoBuf1 + 1), Name);

        infoBuf1->msgi1_name = (LPWSTR)(infoBuf1 + 1);
        infoBuf1->msgi1_forward_flag = 0;
        infoBuf1->msgi1_forward = NULL;

        (*InfoStruct).MsgInfo1 = infoBuf1;
        break;

    default:
        status = ERROR_INVALID_LEVEL;
        goto exit;
    }

    status = NERR_Success;

exit:
    MsgConfigurationLock(MSG_RELEASE,"NetrMessageNameGetInfo");

    return status;
}



NET_API_STATUS
NetrMessageNameAdd(
    LPWSTR  ServerName,    // NULL = local
    LPWSTR  Name            // Pointer to name to add.
    )

/*++

Routine Description:

    This function performs a security check for all calls to this
    RPC interface.  Then it adds a new name to the Message
    Server's name table by calling the MsgAddName function.

Arguments:

    ServerName - Pointer to a string containing the name of the computer
        that is to execute the API function.

    Name - A pointer to the name to be added.

Return Value:

    NERR_Success - The operation was successful.

    ERROR_ACCESS_DENIED - If the Security Check Failed.

    ERROR_SERVICE_NOT_ACTIVE - The service is stopping

    Assorted Error codes from MsgAddName.

--*/

{
    NET_API_STATUS  status=0;
    ULONG           SessionId = 0;

    DWORD           dwMsgrState = GetMsgrState();

    UNUSED (ServerName);

    if (dwMsgrState == STOPPING || dwMsgrState == STOPPED) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Synchronize with Pnp configuration routine
    //
    MsgConfigurationLock(MSG_GET_SHARED,"NetrMessageNameAdd");

    //
    // API security check. This call can be called by anyone locally,
    // but only by admins in the remote case.
    //

    status = NetpAccessCheckAndAudit(
                SERVICE_MESSENGER,              // Subsystem Name
                (LPWSTR)MESSAGE_NAME_OBJECT,    // Object Type Name
                MessageNameSd,                  // Security Descriptor
                MSGR_MESSAGE_NAME_ADD,          // Desired Access
                &MsgMessageNameMapping);        // Generic Mapping

    if (status != NERR_Success) {
        MSG_LOG(TRACE,
            "NetrMessageNameAdd:NetpAccessCheckAndAudit FAILED %X\n",
            status);
        status = ERROR_ACCESS_DENIED;
        goto exit;
    }

    //
    //  In Hydra case, the display thread never goes asleep.
    //
    if (!g_IsTerminalServer)
    {
        //
        // Since a new user may have just logged on, we want to check to see if
        // there are any messages to be displayd.
        //
        MsgDisplayThreadWakeup();

    }
    else
    {
        // get the client session id
        status = MsgGetClientSessionId(&SessionId);

        if (status != NERR_Success) 
        {
            MSG_LOG(ERROR, "NetrMessageNameAdd: could not get client session id\n",0);
            goto exit;
        }
    }

    //
    // Call the function that actually adds the name.
    //
    MSG_LOG(TRACE, "NetrMessageNameAdd: call MsgAddName for Session %x\n",SessionId);

    status = MsgAddName(Name, SessionId);

exit:
    MsgConfigurationLock(MSG_RELEASE,"NetrMessageNameAdd");

    return status;
}


NET_API_STATUS
MsgAddName(
    LPWSTR  Name,
	ULONG	SessionId
    )
/*++

Routine Description:

    This function adds a new name to the Message Server's name table.
    It is available to be called internally (from within the Messenger
    service).

    The task of adding a new name to the Message Server's name table consists
    of verifying that a session can be established for a new name (Note: this
    check is subject to failure in a multiprocessing environment, since the
    state of the adapter may change between the time of the check and the time
    of the attempt to establish a session), verifying that the name does not
    already exist in the local name table, adding the name to the local adapter
    via an ADD NAME net bios call, adding the name to the Message Server's name
    table and marking it as new, waking up the Message Server using the wakeup
    semaphore,  and checking to see if messages for the new name have been
    forwarded (if they have been forwarded, the value of the fwd_action
    flag is used to determine the action to be taken).


    SIDE EFFECTS

    Calls the net bios.  May modify the Message Server's shared data area.
    May call DosSemClear() on the wakeup semaphore.

Arguments:

    Name - A pointer to the name to be added.

Return Value:

    NERR_Success - The operation was successful.

    assorted errors.

--*/
{
    NCB             ncb;                    // Network control block
    TCHAR           namebuf[NCBNAMSZ+2];    // General purpose name buffer
    UCHAR           net_err=0;              // Storage for net error codes
    NET_API_STATUS  err_code=0;             // Storage for return error codes
    DWORD           neti,i,name_i;          // Index
    NET_API_STATUS  status=0;

    if (MsgIsValidMsgName(Name) != 0)
    {
        return ERROR_INVALID_NAME;
    }

    MSG_LOG(TRACE,"Attempting to add the following name: %ws\n",Name);

    STRNCPY( namebuf, Name, NCBNAMSZ+1);
    namebuf[NCBNAMSZ+1] = '\0';

    //
    // Initialize the NCB
    //
    clearncb(&ncb);

    //
    // Format the name for NetBios.
    // This converts the Unicode string to ansi.
    //
    status = MsgFmtNcbName(ncb.ncb_name, namebuf, NAME_LOCAL_END);

    if (status != NERR_Success) {
        MSG_LOG(ERROR,"MsgAddName: could not format name\n",0);
        return (ERROR_INVALID_NAME);
    }

    //
    // Check if the local name already exists on any netcard
    // in this machine.  This check does not mean the name dosn't
    // exist on some other machine on the network(s).
    //

    for ( neti = 0; neti < SD_NUMNETS(); neti++ ) {

        //
        // Gain access to the shared database.
        //
        MsgDatabaseLock(MSG_GET_EXCLUSIVE,"MsgAddName");

        for( i = 0, err_code = 0; i < 10; i++) {

			// check if this alias is not already existing for this session
            name_i = MsgLookupNameForThisSession(neti, ncb.ncb_name, SessionId);	

            if ((name_i) == -1) {
                break;
            }

            if( (SD_NAMEFLAGS(neti,name_i) & NFDEL_PENDING) && (i < 9)) {

                //
                // Delete is pending so wait for it
                //
                Sleep(500L);
            }
            else {

                //
                // Setup error code
                //
                err_code = NERR_AlreadyExists;
                break;
            }
        }

        MsgDatabaseLock(MSG_RELEASE,"MsgAddName");

        if ( err_code == NERR_AlreadyExists ) {
            break;
        }
    }

    if( err_code == 0)
    {
        //
        // Either the name was not forwarded or the fwd_action flag
        // was set so go ahead and try to add the name to each net.
        //

        ncb.ncb_name[NCBNAMSZ - 1] = NAME_LOCAL_END;

        //
        // on each network
        //
        for ( neti = 0; neti < SD_NUMNETS(); neti++ ) {

            //
            // Gain access to the shared database.
            //
            MsgDatabaseLock(MSG_GET_EXCLUSIVE,"MsgAddName");

            if (g_IsTerminalServer)
            {
			    // before looking for an empty slot, 
			    // check if this alias does not already exist for another session
                for( i = 0; i < 10; i++) 
                {
                    name_i = MsgLookupName(neti, ncb.ncb_name);

                    if ((name_i != -1) && (SD_NAMEFLAGS(neti, name_i) & NFDEL_PENDING))
                    {
                        //
                        // Delete is pending so wait for it
                        //
                        Sleep(500L);
                    }
                    else
                    {
                        break;
                    }
                }

                if (name_i != -1)       
                {	
                    if (SD_NAMEFLAGS(neti, name_i) & NFDEL_PENDING)   // still there ?
                    {
                        err_code = NERR_InternalError;  // what else can we do ?
                        MsgDatabaseLock(MSG_RELEASE, "MsgAddName");
                        break;
                    }

                    // this alias already exists for another session, so just add the session id in the list
                    MSG_LOG(TRACE,"MsgAddName: Alias already existing. Just adding Session %x \n", SessionId);

                    MsgAddSessionInList(&(SD_SIDLIST(neti, name_i)), SessionId);    //There is not much we can do if this call fails
                    MsgDatabaseLock(MSG_RELEASE, "MsgAddName");
                    continue;
                }
            }

            for(i = 0; i < NCBMAX(neti); ++i)
            {
                //
                // Loop to find empty slot
                //
                if (SD_NAMEFLAGS(neti,i) & NFDEL)
                {
                    //
                    // If empty slot found, Lock slot in table and
                    // end the search
                    //
                    SD_NAMEFLAGS(neti,i) = NFLOCK;
                    MSG_LOG2(TRACE,"MsgAddName: Lock slot %d in table "
                                       "for net %d\n",i,neti);
                    break;
                }
            }

            if ((i == NCBMAX(neti)) && (i < NCB_MAX_ENTRIES))
            {
                // We can add another NCB - must hold the lock.
                PNCB_DATA pNcbDataNew;
                PNET_DATA pNetData = GETNETDATA(neti);

                if (pNcbDataNew = (PNCB_DATA) LocalAlloc(LMEM_ZEROINIT,
                                                         sizeof(NCB_DATA)))
                {
                    // Initialize and lock the NCB
                    pNcbDataNew->Ncb.ncb_cmd_cplt = 0xff;
                    pNcbDataNew->NameFlags = NFLOCK;
                    // Add the new NCB to the list
                    pNetData->NcbList[i] = pNcbDataNew;
                    //
                    //create an empty session list
                    //
                    InitializeListHead(&(SD_SIDLIST(neti,i)));
                    pNetData->NumNcbs++;  // This must be done last
                }
                else
                {
                    err_code = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            //
            // Unlock the shared database
            //
            MsgDatabaseLock(MSG_RELEASE, "MsgAddName");

            if( i >= NCBMAX(neti))
            {
                //
                // If no room in name table
                //
                err_code = NERR_TooManyNames;
            }
            else if (err_code == NERR_Success)
            {
                //
                // Send ADDNAME
                //
                ncb.ncb_command = NCBADDNAME;      // Add name (wait)
                ncb.ncb_lana_num = GETNETLANANUM(neti);

                MSG_LOG1(TRACE,"MsgNameAdd: Calling sendncb for lana #%d...\n",
                    GETNETLANANUM(neti));

                if ((net_err = Msgsendncb(&ncb,neti)) == 0)
                {
                    MSG_LOG(TRACE,"MsgAddName: sendncb returned SUCCESS\n",0);
                    //
                    // successful add - Get the Lock.
                    //
                    MsgDatabaseLock(MSG_GET_EXCLUSIVE,"MsgAddName");
                    //
                    // Copy the name to shared memory
                    //
                    MSG_LOG3(TRACE,"MsgAddName: copy name (%s)\n\tto "
                        "shared data table (net,loc)(%d,%d)\n",
                        ncb.ncb_name, neti, i);
                    memcpy(SD_NAMES(neti,i),ncb.ncb_name, NCBNAMSZ);
                    //
                    // Set the name no.
                    //
                    SD_NAMENUMS(neti,i) = ncb.ncb_num ;
                    //
                    // Set new name flag
                    //
                    SD_NAMEFLAGS(neti,i) = NFNEW;

                    if (g_IsTerminalServer)
                    {
                        // Add the session id in the list
                        MSG_LOG(TRACE,"MsgAddName: Alias created for Session %x \n", SessionId);
                        MsgAddSessionInList(&(SD_SIDLIST(neti, i)), SessionId);
                        // If this fails due to low memory, we would find the name in the list and messages will
                        // not get deliviered. Doesn't cause any crashes. This is the best we can do
                    }
                    //
                    // Unlock share table
                    //
                    MsgDatabaseLock(MSG_RELEASE, "MsgAddName");

                    //
                    // START A SESSION for this name.
                    //

                    err_code = MsgNewName(neti,i);

                    if (err_code != NERR_Success) {
                        MSG_LOG(TRACE, "MsgAddName: A Session couldn't be "
                            "created for this name %d\n",err_code);


                        MSG_LOG(TRACE,"MsgAddName: Delete the name "
                            "that failed (%s)\n",ncb.ncb_name)
                        ncb.ncb_command = NCBDELNAME;

                        ncb.ncb_lana_num = GETNETLANANUM(i);
                        net_err = Msgsendncb( &ncb, i);
                        if (net_err != 0) {
                            MSG_LOG(ERROR,"MsgAddName: Delete name "
                            "failed %d - pretend it's deleted anyway\n",net_err);
                        }

                        //
                        // Re-mark slot empty
                        //
                        SD_NAMEFLAGS(neti,i) = NFDEL;

                        MSG_LOG2(TRACE,"MsgAddName: UnLock slot %d in table "
                            "for net %d\n",i,neti);
                        MSG_LOG(TRACE,"MsgAddName: Name Deleted\n",0)
                    }
                    else {
                        //
                        //
                        // Wakeup the worker thread for that network.
                        //

                        SetEvent(wakeupSem[neti]);

                    }

                }
                else {
                    //
                    // else set error code
                    //
                    MSG_LOG(TRACE,
                        "MsgAddName: sendncb returned FAILURE 0x%x\n",
                        net_err);
                    err_code = MsgMapNetError(net_err);
                    //
                    // Re-mark slot empty
                    //
                    SD_NAMEFLAGS(neti,i) = NFDEL;
                    MSG_LOG2(TRACE,"MsgAddName: UnLock slot %d in table "
                        "for net %d\n",i,neti);
                }
            }

            if ( err_code != NERR_Success )
            {
                //
                //Try to delete the add names that were successful
                //

                for ( i = 0; i < neti; i++ )
                {
                    MsgDatabaseLock(MSG_GET_EXCLUSIVE,"MsgAddName");

                    // try to delete only the alias for this session
                    name_i = MsgLookupNameForThisSession(i,
                                                         (char far *)(ncb.ncb_name),
                                                         SessionId);

                    if (name_i == -1)
                    {
                        err_code = NERR_InternalError;
                        MsgDatabaseLock(MSG_RELEASE, "MsgAddName");
                        break;
                    }

                    if (g_IsTerminalServer)
                    {
                        // in any case remove the reference to the session
                        MSG_LOG(TRACE,"MsgAddName: Removing Session %x from list\n", SessionId);
                        MsgRemoveSessionFromList(&(SD_SIDLIST(i, name_i)), SessionId);
                    }

                    MsgDatabaseLock(MSG_RELEASE, "MsgAddName");

                    // if it was the last session using this alias then delete the alias 
                    if ((!g_IsTerminalServer) || (IsListEmpty(&(SD_SIDLIST(i, name_i)))))
                    {
                        MSG_LOG(TRACE,"MsgAddName: Session list empty. Deleting the alias \n", 0);
                        //
                        // Delete name from card.
                        // If this call fails, we can't do much about it.
                        //
                        MSG_LOG1(TRACE,"MsgAddName: Delete the name that failed "
                            "for lana #%d\n",GETNETLANANUM(i))
                        ncb.ncb_command = NCBDELNAME;

                        ncb.ncb_lana_num = GETNETLANANUM(i);
                        Msgsendncb( &ncb, i);

                        //
                        // Re-mark slot empty
                        //
			SD_NAMEFLAGS(i,name_i) = NFDEL;
			MSG_LOG2(TRACE,"MsgAddName: UnLock slot %d in table "
                                           "for net %d\n",i,neti);
                    }
                }

                //
                // If an add was unsuccessful, stop the loop
                //
                break;

            }       // end else (err_code != NERR_Success)
        }       // end add names to net loop
    }       // end if ( !err_cd )

    MSG_LOG(TRACE,"MsgAddName: exit with err_code = %x\n",err_code);

    return(err_code);
}


NET_API_STATUS
NetrMessageNameDel(
    IN LPWSTR   ServerName,    // Blank = local, else remote.
    IN LPWSTR   Name            // Pointer to name to be deleted
    )

/*++

Routine Description:

    This function deletes a name from the Message Server's name table.

    This function is called to delete a name that has been added by the
    user or by a remote computer via a Start Forwarding request to the
    Message Server.  The user has no way of specifying whether the given
    name is an additional name or a forwarded name, but since forwarding
    of messages to one's own computer is prohibited, both forms of the
    name cannot exist on one machine (unless the message system has been
    circumvented--a simple enough thing to do).  The given name is looked
    up in the shared data area, and, if it is found, a DELETE NAME net bios
    call is issued.  If this call is successful, then the Message Server
    will remove the name from its name table in shared memory, so this
    function does not have to do so.

    SIDE EFFECTS

    Calls the net bios.  Accesses the shared data area.


Arguments:

    ServerName - Pointer to a string containing the name of the computer
        that is to execute the API function.

    Name - A pointer to the name to be deleted.


Return Value:

    NERR_Success - The operation was successful.

    ERROR_SERVICE_NOT_ACTIVE - The service is stopping.

--*/

{
    NCB             ncb;            // Network control block
    DWORD           flags;          // Name flags
    DWORD           i;              // Index into name table
    DWORD           neti;           // Network Index

    NET_API_STATUS  end_result;
    DWORD           name_len;
    UCHAR           net_err;
    ULONG           SessionId = 0;  // Client Session Id 

    DWORD           dwMsgrState = GetMsgrState();

    UNUSED (ServerName);

    if (dwMsgrState == STOPPING || dwMsgrState == STOPPED)
    {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    if (MsgIsValidMsgName(Name) != 0)
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Synchronize with Pnp configuration routine
    //
    MsgConfigurationLock(MSG_GET_SHARED,"NetrMessageNameDel");

    //
    //  In Hydra case, the display thread never goes asleep.
    //
    if (!g_IsTerminalServer)
    {
        //
        // Wakeup the display thread so that any queue'd messages can be
        // displayed.
        //
        MsgDisplayThreadWakeup();

    }

    //
    // API security check. This call can be called by anyone locally,
    // but only by admins in the remote case.
    //

    end_result = NetpAccessCheckAndAudit(
                     SERVICE_MESSENGER,              // Subsystem Name
                     (LPWSTR) MESSAGE_NAME_OBJECT,   // Object Type Name
                     MessageNameSd,                  // Security Descriptor
                     MSGR_MESSAGE_NAME_DEL,          // Desired Access
                     &MsgMessageNameMapping);        // Generic Mapping

    if (end_result != NERR_Success)
    {
        MSG_LOG(ERROR,
                "NetrMessageNameDel:NetpAccessCheckAndAudit FAILED %d\n",
                end_result);

        goto exit;
    }

    //
    // Initialize the NCB
    //
    clearncb(&ncb);

    //
    // Format the username (this makes it non-unicode);
    //
    end_result = MsgFmtNcbName(ncb.ncb_name, Name, NAME_LOCAL_END);

    if (end_result != NERR_Success)
    {
        MSG_LOG(ERROR,
                "NetrMessageNameDel: could not format name %d\n",
                end_result);

        goto exit;
    }

    if (g_IsTerminalServer)
    {
        end_result = MsgGetClientSessionId(&SessionId);
        
        if (end_result != NERR_Success)
        {
            MSG_LOG(ERROR,
                    "NetrMessageNameDel: could not get session id %d\n",
                    end_result);

            goto exit;
	}
    }

    end_result = NERR_Success;

    //
    // for all nets
    //
    for ( neti = 0; neti < SD_NUMNETS(); neti++ ) {

        //
        // Block until data free
        //
        MsgDatabaseLock(MSG_GET_EXCLUSIVE,"NetrMessageNameDel");

        name_len = STRLEN(Name);

        if((name_len > NCBNAMSZ)
             ||
           ((i = MsgLookupNameForThisSession( neti, ncb.ncb_name, SessionId))) == -1)
        {
            MSG_LOG(TRACE,"NetrMessageNameDel: Alias not found for Session %x \n", SessionId);

            //
            // No such name to delete - exit
            //
            MsgDatabaseLock(MSG_RELEASE, "NetrMessageNameDel");
            end_result = NERR_NotLocalName;
            goto exit;
        }

        if (g_IsTerminalServer)
        {
            // remove the session id from the list
            MSG_LOG(TRACE,"NetrMessageNameDel: Removing Session %x from list\n", SessionId);
            MsgRemoveSessionFromList(&(SD_SIDLIST(neti,i)), SessionId);
        }

        //
        // in Hydra case, if it is not the last session using this alias, do not delete the alias
        //
        if ((g_IsTerminalServer) && (!IsListEmpty(&(SD_SIDLIST(neti,i)))))
        {
            MSG_LOG(TRACE,"NetrMessageNameDel: Session list is not empty. Do not delete the alias\n", 0);
            MsgDatabaseLock(MSG_RELEASE, "NetrMessageNameDel");
            continue;
        }
        else
        {
            MSG_LOG(TRACE,"NetrMessageNameDel: Session list is empty. Deleting the alias\n", 0);
        }

        flags = SD_NAMEFLAGS(neti,i);

        if(!(flags & (NFMACHNAME | NFLOCK))
            &&
           !(flags & NFFOR))
        {
            //
            // Show delete pending
            //
            SD_NAMEFLAGS(neti,i) |= NFDEL_PENDING;
        }

        MsgDatabaseLock(MSG_RELEASE, "NetrMessageNameDel");

        if (flags & NFMACHNAME)
        {
            //
            // If name is computer name
            //
            end_result = NERR_DelComputerName;
            goto exit;
        }

        if(flags & NFLOCK)
        {
            //
            // If name is locked
            //
            end_result = NERR_NameInUse;
    	    MSG_LOG(TRACE,"NetrMessageNameDel: Deleting a locked name is forbidden\n", 0);
            goto exit;
        }

        //
        // Delete the Name
        //

        ncb.ncb_command = NCBDELNAME;   // Delete name (wait)
        ncb.ncb_lana_num = GETNETLANANUM(neti);

        if( (net_err = Msgsendncb( &ncb, neti)) != 0 )
        {
            MSG_LOG(ERROR,"NetrMessageNameDel:send NCBDELNAME failed 0x%x\n",
                net_err);
            //
            // The name that has been marked as delete pending was not
            // successfully deleted so now go through all the work of
            // finding the name again (cannot even use the same index
            // in case deleted by another process) and remove the
            // Del pending flag
            //

            //
            // Attempt to block until data free but don't stop
            // the recovery if can not block the data
            //

            MsgDatabaseLock(MSG_GET_EXCLUSIVE,"NetrMessageNameDel");

            i = MsgLookupName(neti,ncb.ncb_name);

            if(i != -1)
            {
                SD_NAMEFLAGS(neti,i) &= ~NFDEL_PENDING;

                if (g_IsTerminalServer)
                {
                    MSG_LOG(TRACE,"NetrMessageNameDel: Unable to delete alias. Re-adding Session %x \n", SessionId);

                    // re-insert the session id in the list
                    MsgAddSessionInList(&(SD_SIDLIST(neti,i)), SessionId);
                }

                end_result = NERR_IncompleteDel;    // Unable to delete name
            }
            else
            {
                //
                // Another thread deleted this name while we were executing
                // above, so this name no longer exists.
                //
                end_result = NERR_NotLocalName;
            }

            MsgDatabaseLock(MSG_RELEASE, "NetrMessageNameDel");
        }

    } // End for all nets

exit:

    MsgConfigurationLock(MSG_RELEASE,"NetrMessageNameDel");

    return(end_result);
}


DWORD
NetrSendMessage(
    RPC_BINDING_HANDLE  hRpcBinding,
    LPSTR               From,
    LPSTR               To,
    LPSTR               Text
    )

/*++

Routine Description:

This is the RPC handler for the SendMessage RPC.  It takes the arguments, transforms them, and
passes them to Msglogsbm for display.

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD   length;
    PCHAR   newText;
    DWORD   dwMsgrState = GetMsgrState();

    UNUSED(hRpcBinding);

    if (dwMsgrState == STOPPING || dwMsgrState == STOPPED) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    MSG_LOG3(TRACE,
            "NetrSendMessage, From '%s' To '%s' Text '%s'\n",
             From, To, Text);

    // Msglogsbm takes a wierd counted string argument with a short of length in the front.
    // Whip one up

    length = strlen( Text );

    newText = LocalAlloc( LMEM_FIXED, length + 3 );    // newText should be aligned

    if (newText == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *((PUSHORT) newText) = (USHORT) length;

    strcpy( newText + 2, Text );

    // Display the message

    if (g_IsTerminalServer)
    {
        Msglogsbm( From, To, newText, (ULONG)EVERYBODY_SESSION_ID );
    }
    else
    {
        Msglogsbm (From, To, newText, 0);
    }

    LocalFree( newText );

    return STATUS_SUCCESS;
}


NET_API_STATUS
MsgGetClientSessionId(
    OUT PULONG pSessionId
    )
/*++

Routine Description:

    This function gets the session id of the client thread. 

  Note: it should be called only on HYDRA context, never in regular NT

    Arguments:

    pSessionId - 

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    HANDLE CurrentThreadToken;
    ULONG SessionId;
    ULONG ReturnLength;

    ntstatus = RpcImpersonateClient(NULL);

    if (ntstatus != RPC_S_OK)
    {
        MSG_LOG1(ERROR,
                 "MsgGetClientSessionId: RpcImpersonateClient FAILED %#x\n",
                 ntstatus);

        return NetpNtStatusToApiStatus(ntstatus);
    }

    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,              // Use messenger service's security context to open thread token
                   &CurrentThreadToken
                   );

    if (! NT_SUCCESS(ntstatus))	   // error
    {
        MSG_LOG(ERROR,"MsgGetClientSessionId : Cannot open the current thread token %08lx\n", ntstatus);
    }
    else    // OK
    {
        //
        // Get the session id of the client thread
        //

        ntstatus = NtQueryInformationToken(
                       CurrentThreadToken,
                       TokenSessionId,
                       &SessionId,
                       sizeof(ULONG),
                       &ReturnLength);

        if (! NT_SUCCESS(ntstatus))    // Error
        {
            MSG_LOG(ERROR,
                    "MsgGetClientSessionId: Cannot query current thread's token %08lx\n",
                     ntstatus);

            NtClose(CurrentThreadToken);
        }
        else    // OK
        {
            NtClose(CurrentThreadToken);
            *pSessionId = SessionId;
        }
    }

    RpcRevertToSelf();

    status = NetpNtStatusToApiStatus(ntstatus);

    //
    //  temporary security to avoid any problem:
    //  if we cannot get the session id,
    //  assume it is for the console.
    //
    if (status != NERR_Success)
    {
        *pSessionId = 0;
        status = NERR_Success;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\meslog.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1992          **/
/********************************************************************/


/*
**  Routines to log messages
**
**  If message logging is off, all messages are buffered.  Further,
**  even if messages are being logged, multi-block messages must
**  be buffered since they must be spooled to the logging file or
**  device.  Since there is only one message buffer in which to
**  buffer all messages, this buffer must be managed as a heap.
**  Also, messages are logged in a first-in-first-out manner,
**  so messages in the buffer must be kept in a queue.  In order
**  to meet these goals, the following message blocks are defined:
**
**  SBM - single-block message
**
**        length        - length of entire block (2 bytes)
**        code        - identifies block as single-block message (1 byte)
**        link        - link to next message in message queue (2 bytes)
**        date        - date message received (2 bytes)
**        time        - time message received (2 bytes)
**        from        - name of sender (null-terminated string)
**        to        - name of recipient (null-terminated string)
**        text        - text of message (remainder of block)
**
**  MBB - multi-block message header
**
**        length        - length of entire block (2 bytes)
**        code        - identifies block as multi-block message header (1 byte)
**        link        - link to next message in message queue (2 bytes)
**        date        - date message received (2 bytes)
**        time        - time message received (2 bytes)
**        btext        - link to last text block (2 bytes)
**        ftext        - link to first text block (2 bytes)
**        error        - error flag (1 byte)
**        from        - name of sender (null-terminated string)
**        to        - name of recipient (null-terminated string)
**
**  MBT - multi-block message text block
**
**        length        - length of entire block (2 bytes)
**        code        - identifies block a multi-block message text (1 byte)
**        link        - link to next text block (2 bytes)
**        text        - text of message (remainder of block)
**/

//
// Includes
//

#include "msrv.h"

#include <string.h>     // memcpy
#include <tstring.h>    // Unicode string macros
#include <netdebug.h>   // NetpAssert

#include <lmalert.h>    // Alert stuff

#include <netlib.h>     // UNUSED macro
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include <netdebug.h>   // NetpDbgHexDump
#include <smbtypes.h>   // needed for smb.h
#include <smb.h>        // Server Message Block definitions
#include <lmerrlog.h>   // NELOG_ messages
#include <smbgtpt.h>    // SMB field manipulation macros

#include <winuser.h>    // MessageBox
#include <winsock2.h>   // Windows sockets

#include "msgdbg.h"     // MSG_LOG
#include "msgdata.h"

//
// Defines for Hex Dump Function
//
#ifndef MIN
#define MIN(a,b)    ( ( (a) < (b) ) ? (a) : (b) )
#endif

#define DWORDS_PER_LINE         4
#define BYTES_PER_LINE          (DWORDS_PER_LINE * sizeof(DWORD))
#define SPACE_BETWEEN_BYTES     NetpKdPrint((" "))
#define SPACE_BETWEEN_DWORDS    NetpKdPrint((" "))
//
// Local Functions
//

NET_API_STATUS
MsgOutputMsg (
    USHORT       AlertLength,
    LPSTR        AlertBuffer,
    ULONG        SessionId,
    SYSTEMTIME   BigTime
    );

#if DBG
VOID
MsgDbgHexDumpLine(
    IN LPBYTE StartAddr,
    IN DWORD BytesInThisLine
    );

VOID
MsgDbgHexDump(
    IN LPBYTE StartAddr,
    IN DWORD Length
    );
#endif //DBG

//
//  Data
//

PSTD_ALERT  alert_buf_ptr;      // Pointer to DosAlloc'ed alert buffer
USHORT      alert_len;          // Currently used length of alert buffer

//
// Defines
//
#define ERROR_LOG_SIZE  1024


/*
**  Msglogmbb - log a multi-block message header
**
**  This function is called to log a multi-block message header.
**  The message header is placed in the message buffer which resides
**  in the shared data area.
**
**  This function stores the from and to information in the shared data
**  buffer and initializes the multi-block message header.  Then it puts
**  a pointer to the multi-block header into the shared data pointer
**  location for that net index and name index.
**
**  logmbb (from, to, net, ncbi)
**
**  ENTRY
**        from                - sender name
**        to                - recipient name
**        net                - network index
**        ncbi                - Network Control Block index
**
**  RETURN
**        zero if successful, non-zero if unable to buffer the message header
**
**  SIDE EFFECTS
**
**  Calls heapalloc() to obtain buffer space.
**/

DWORD
Msglogmbb(
    LPSTR   from,       // Name of sender
    LPSTR   to,         // Name of recipient
    DWORD   net,        // Which network ?
    DWORD   ncbi        // Network Control Block index
    )

{
    DWORD   i;          // Heap index
    LPSTR   fcp;        // Far character pointer
    LONG    ipAddress;
    struct hostent *pHostEntry;

    //
    // Synchronize with Pnp configuration routine
    //
    MsgConfigurationLock(MSG_GET_SHARED,"Msglogmbb");

    //
    // Block until the shared database is free
    //
    MsgDatabaseLock(MSG_GET_EXCLUSIVE,"logmbb");

    //
    // Check whether the recipient name needs to be formatted
    //

    ipAddress = inet_addr( to );
    if (ipAddress != INADDR_NONE) {
        pHostEntry = gethostbyaddr( (char *)&ipAddress,sizeof( LONG ),AF_INET);
        if (pHostEntry) {
            to = pHostEntry->h_name;
        } else {
       MSG_LOG2(ERROR,"Msglogmbb: could not lookup addr %s, error %d\n",
                to, WSAGetLastError());
        }
    }

    //
    // Allocate space for header
    //
    i = Msgheapalloc(sizeof(MBB) + strlen(from) + strlen(to) + 2);

    if(i == INULL) {                    // If no buffer space
        //
        // Unlock the shared database
        //

        MsgDatabaseLock(MSG_RELEASE,"logmbb");
        MsgConfigurationLock(MSG_RELEASE,"Msglogmbb");

        return((int) i);                // Log fails
    }

    //
    // Multi-block message
    //
    MBB_CODE(*MBBPTR(i)) = SMB_COM_SEND_START_MB_MESSAGE;
    MBB_NEXT(*MBBPTR(i)) = INULL;               // Last message in buffer
    GetLocalTime(&MBB_BIGTIME(*MBBPTR(i)));     // Time of message
    MBB_BTEXT(*MBBPTR(i)) = INULL;              // No text yet
    MBB_FTEXT(*MBBPTR(i)) = INULL;              // No text yet
    MBB_STATE(*MBBPTR(i)) = MESCONT;            // Message in progress
    fcp = CPTR(i + sizeof(MBB));                // Get far pointer into buffer
    strcpy(fcp, from);                          // Copy the sender name
    fcp += strlen(from) + 1;                    // Increment pointer
    strcpy(fcp, to);                            // Copy the recipient name
    SD_MESPTR(net,ncbi) = i;                    // Save index to this record

    //
    // Unlock the shared database
    //

    MsgDatabaseLock(MSG_RELEASE,"logmbb");
    MsgConfigurationLock(MSG_RELEASE,"Msglogmbb");

    return(0);                                  // Message logged successfully
}

/*
**  Msglogmbe - log end of a multi-block message
**
**  This function is called to log a multi-block message end.
**  The message is marked as finished, and if logging is enabled,
**  an attempt is made to write the message to the log file.  If
**  this attempt fails, or if logging is disabled, then the message
**  is placed in the message queue in the message buffer.
**
**  The message is gathered up and placed in the alert buffer and an alert
**  is raised.
**
**  logmbe (state, net,ncbi)
**
**  ENTRY
**        state                - final state of message
**        net                - Network index
**        ncbi                - Network Control Block index
**
**  RETURN
**        int                - BUFFERED if the message is left in the buffer
**        int                - LOGGED if the message is written to the log file
**
**      FOR NT:
**        SMB_ERR_SUCCESS - success in alerting
**        SMB_ERR_...     - an error occured
**
**
**
**  SIDE EFFECTS
**
**  Calls mbmprint() to print the message if logging is enabled.  Calls
**  mbmfree() to free the message if logging succeeds.
**/

UCHAR
Msglogmbe(
    DWORD   state,      // Final state of message
    DWORD   net,        // Which network?
    DWORD   ncbi        // Network Control Block index
    )
{
    DWORD       i;                  // Heap index
    DWORD       error;              // Error code
    DWORD       meslog;             // Message logging status
    DWORD       alert_flag;         // Alert buffer allocated flag
    DWORD       status;             // Dos error for error log
    DWORD       bufSize;            // Buffer Size
    SYSTEMTIME  bigtime;            // Date and time of message

    PMSG_SESSION_ID_ITEM    pItem;                              
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pList;

    //
    // Synchronize with Pnp configuration routine
    //
    MsgConfigurationLock(MSG_GET_SHARED,"Msglogmbe");

    //
    // Block until the shared database is free
    //
    MsgDatabaseLock(MSG_GET_EXCLUSIVE,"logmbe");

    pHead = &(SD_SIDLIST(net,ncbi));
    pList = pHead;

    //
    // First get a buffer for an alert
    //

    bufSize =   sizeof( STD_ALERT) +
                ALERT_MAX_DISPLAYED_MSG_SIZE +
                (2*TXTMAX) + 2;

    alert_buf_ptr = (PSTD_ALERT)LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (alert_buf_ptr == NULL) {
        MSG_LOG(ERROR,"logmbe:Local Alloc failed\n",0);
        alert_flag = 0xffffffff;        // No alerting if Alloc failed
    }
    else {
        alert_flag = 0;                        // File and alerting
        alert_len = 0;

    }

    error = 0;                              // Assume no error
    i = SD_MESPTR(net,ncbi);                // Get index to message header
    MBB_STATE(*MBBPTR(i)) = state;          // Record final state

    //
    // If logging now disabled ...
    //

    if(!SD_MESLOG())
    {
        if( alert_flag == 0)
        {
            //
            // Format the message and put it in the alert buffer.
            //
            // Alert only.  alert_flag is only modified if Msgmbmprint
            // returns success and we should skip the message (i.e.,
            // it's a print notification from a pre-Whistler machine).
            //
            if (Msgmbmprint(1,i,0, &alert_flag))
            {
                alert_flag = 0xffffffff;
            }
        }
    }

    //
    // Add message to buffer queue if logging is off,
    // or if the attempt to log the message failed.
    //

    meslog = SD_MESLOG();           // Get logging status

    if(!meslog) {                   // If logging disabled
        Msgmbmfree(i);
    }

    if(error != 0)  {

        //
        // Report to error log
        //

        NetpAssert(0);              // NT code should never get here.

        MsgErrorLogWrite(
            error,
            SERVICE_MESSENGER,
            (LPBYTE)&status,
            sizeof(DWORD),
            NULL,
            0);
    }

    //
    // Now alert and free up alert buffer if it was successfully allocated
    //

    if( alert_flag == 0) {
        //
        // There is an alert buffer, output it.
        //
        GetLocalTime(&bigtime);                        // Get the time

        if (g_IsTerminalServer)
        {
            //
            // Output the message for all the sessions sharing that name
            //

                while (pList->Flink != pHead)           // loop all over the list
                {
                pList = pList->Flink;  
                        pItem = CONTAINING_RECORD(pList, MSG_SESSION_ID_ITEM, List);
                MsgOutputMsg(alert_len, (LPSTR)alert_buf_ptr, pItem->SessionId, bigtime);
            }
        }
        else        // regular NT
        {
            MsgOutputMsg(alert_len, (LPSTR)alert_buf_ptr, 0, bigtime);
        }
    }

    LocalFree(alert_buf_ptr);

    //
    // Unlock the shared database
    //

    MsgDatabaseLock(MSG_RELEASE,"logmbe");

    MsgConfigurationLock(MSG_RELEASE,"Msglogmbe");

    return(SMB_ERR_SUCCESS);                        // Message arrived
}

/*
**  Msglogmbt - log a multi-block message text block
**
**  This function is called to log a multi-block message text block.
**  The text block is placed in the message buffer which resides
**  in the shared data area.  If there is insufficient room in the
**  buffer, logmbt() removes the header and any previous blocks of
**  the message from the buffer.
**
**  This function gets the current message from the message pointer in
**  the shared data (for that net & name index).  It looks in the header
**  to see if there are any text blocks already there.  If so, it adds
**  this new one to the list and fixes the last block pointer to point to
**  it.
**
**  logmbt (text, net, ncbi)
**
**  ENTRY
**        text                - text header
**        net                - Network index
**        ncbi                - Network Control Block index
**
**  RETURN
**        zero if successful, non-zero if unable to buffer the message header
**
**  SIDE EFFECTS
**
**  Calls heapalloc() to obtain buffer space.  Calls mbmfree() if a call to
**  heapalloc() fails.
**/

DWORD
Msglogmbt(
    LPSTR   text,       // Text of message
    DWORD   net,        // Which network?
    DWORD   ncbi        // Network Control Block index
    )
{
    DWORD   i;          // Heap index
    DWORD   j;          // Heap index
    DWORD   k;          // Heap index
    USHORT  length;     // Length of text

    //
    // Synchronize with Pnp configuration routine
    //
    MsgConfigurationLock(MSG_GET_SHARED,"Msglogmbt");

    // *ALIGNMENT*
    length = SmbGetUshort( (PUSHORT)text);  // Get length of text block
//    length = *((PSHORT) text);            // Get length of text block
    text += sizeof(short);                  // Skip over length word

    //
    // Block until the shared database is free
    //

    MsgDatabaseLock(MSG_GET_EXCLUSIVE,"logmbt");

    i = Msgheapalloc(sizeof(MBT) + length);    // Allocate space for block

    //
    // If buffer space is available
    //

    if(i != INULL) {

        //
        // Multi-block message text
        //
        MBT_CODE(*MBTPTR(i)) = SMB_COM_SEND_TEXT_MB_MESSAGE;

        MBT_NEXT(*MBTPTR(i)) = INULL;            // Last text block so far

        MBT_COUNT(*MBTPTR(i)) = (DWORD)length;  // *ALIGNMENT2*

        memcpy(CPTR(i + sizeof(MBT)), text, length);

                                            // Copy text into buffer
        j = SD_MESPTR(net, ncbi);           // Get index to current message

        if(MBB_FTEXT(*MBBPTR(j)) != INULL) {
            //
            // If there is text already, Get pointer to last block and
            // add new block
            //
            k = MBB_BTEXT(*MBBPTR(j));      // Get pointer to last block
            MBT_NEXT(*MBTPTR(k)) = i;       // Add new block
        }
        else {
            MBB_FTEXT(*MBBPTR(j)) = i;      // Else set front pointer
        }

        MBB_BTEXT(*MBBPTR(j)) = i;          // Set back pointer
        i = 0;                              // Success
    }
    else {
        Msgmbmfree(SD_MESPTR(net,ncbi));       // Else deallocate the message
    }

    //
    // Unlock the shared database
    //

    MsgDatabaseLock(MSG_RELEASE,"logmbt");

    MsgConfigurationLock(MSG_RELEASE,"Msglogmbt");

    return((int) i);                        // Return status
}


/*
**  Msglogsbm - log a single-block message
**
**  This function is called to log a single-block message.  If
**  logging is enabled, the message is written directly to the
**  logging file or device.  If logging is disabled or if the
**  attempt to log the message fails, the message is placed in
**  the message buffer which resides in the shared data area.
**
**  logsbm (from, to, text)
**
**  ENTRY
**        from                - sender name
**        to                - recipient name
**        text                - text of message
**
**  RETURN
**        zero if successful, non-zero if unable to log the message
**
**  SIDE EFFECTS
**
**  Calls hdrprint(), txtprint(), and endprint() to print the message if
**  logging is enabled.  Calls heapalloc() to obtain buffer space if
**  the message must be buffered.
**/

DWORD
Msglogsbm(
    LPSTR   from,       // Name of sender
    LPSTR   to,         // Name of recipient
    LPSTR   text,       // Text of message
    ULONG   SessionId   // Session Id 
    )
{
    DWORD        i;                  // Heap index
    DWORD        error;              // Error code
    SHORT        length;             // Length of text
    DWORD        meslog;             // Message logging status
    DWORD        alert_flag;         // Alert buffer allocated flag
    DWORD        status;             // DOS error from mespeint functions
    SYSTEMTIME   bigtime;            // Date and time of message
    DWORD   bufSize;            // Buffer Size

    //
    // Synchronize with Pnp configuration routine
    //
    MsgConfigurationLock(MSG_GET_SHARED,"Msglogsbm");

    //
    // Block until the shared database is free
    //
    MsgDatabaseLock(MSG_GET_EXCLUSIVE,"logsbm");

    //
    // First get a buffer for an alert
    //

    bufSize =   sizeof( STD_ALERT) +
                ALERT_MAX_DISPLAYED_MSG_SIZE +
                (2*TXTMAX) + 2;

    alert_buf_ptr = (PSTD_ALERT)LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (alert_buf_ptr == NULL) {
        MSG_LOG(ERROR,"Msglogsbm:Local Alloc failed\n",0);
        alert_flag = 0xffffffff;        // No alerting if Alloc failed
    }
    else {
        alert_flag = 0;                        // File and alerting
        alert_len = 0;
    }

    // *ALIGNMENT*
    length = SmbGetUshort( (PUSHORT)text);  // Get length of text block
    text += sizeof(short);                  // Skip over length word
    error = 0;                              // Assume no errors

    //
    // Hack to drop messages sent by pre-Whistler Spoolers.  As of
    // Whistler, print notifications are done as shell balloon tips
    // so don't display print alerts sent from the server as well.
    //
    // This check is also made in Msgmbmprint to catch multi-block messages.
    //

    if ((g_lpAlertSuccessMessage
         &&
         _strnicmp(text, g_lpAlertSuccessMessage, g_dwAlertSuccessLen) == 0)
        ||
        (g_lpAlertFailureMessage
         &&
         _strnicmp(text, g_lpAlertFailureMessage, g_dwAlertFailureLen) == 0))
    {
        MsgDatabaseLock(MSG_RELEASE,"logsbm");
        MsgConfigurationLock(MSG_RELEASE,"Msglogsbm");
        return 0;
    }

    GetLocalTime(&bigtime);                 // Get the time


    if(!SD_MESLOG())                        // If logging disabled
    {
        if( alert_flag == 0)                  // If alert buf is valid
        {
            if (!Msghdrprint(1,from, to, bigtime,0))
            {
                if (Msgtxtprint(1, text,length,0))
                {
                    alert_flag = 0xffffffff;
                }
            }
            else
            {
                alert_flag = 0xffffffff;
            }
        }
    }

    meslog = SD_MESLOG();                   // Get logging status
    i = 0;                                  // No way to fail if not logging

    if(error != 0) {
        DbgPrint("meslog.c:logsbm(before ErrorLogWrite): We should never get here\n");
        NetpAssert(0);

        MsgErrorLogWrite(                   // Report to error log
            error,
            SERVICE_MESSENGER,
            (LPBYTE)&status,
            sizeof(DWORD),
            NULL,
            0);
    }


    // Now alert and free up alert buffer if it was successfully allocated

    if( alert_flag == 0) {                      // There is an alert buffer

        //
        // There is an alert buffer, output it.
        //
        MsgOutputMsg(alert_len, (LPSTR)alert_buf_ptr, SessionId, bigtime);
    }

    LocalFree(alert_buf_ptr);

    //
    // Unlock the shared database
    //

    MsgDatabaseLock(MSG_RELEASE,"logsbm");

    MsgConfigurationLock(MSG_RELEASE,"Msglogsbm");

    return((int) i);                        // Return status

}


NET_API_STATUS
MsgErrorLogWrite(
    IN  DWORD   Code,
    IN  LPTSTR  Component,
    IN  LPBYTE  Buffer,
    IN  DWORD   BufferSize,
    IN  LPSTR   Strings,
    IN  DWORD   NumStrings
    )

/*++

Routine Description:

    Writes an entry to the event manager on the local computer.

    This function needs to get the error message text out of the message
    file and send it to the event logger.

Arguments:

    Code - Specifies the code of the error that occured.

    Component - Points to a NUL terminated string that specifies which
        component encountered the error.  UNICODE STRING.

    Buffer - Points to a string of raw data associated with the error
        condition.

    BufferSize - size (in bytes) of the buffer.

    Strings - NOT USED.
        Points to NUL terminated strings that contain the
        error message.  ANSI STRINGS.

    NumStrings - NOT USED.
        Specifies how many concatenated NUL terminated strings
        are stored in Strings.


Return Value:



--*/
{
    DWORD   status;
    WORD    msglen=0;
    LPBYTE  msgBuf;

    //
    // Get a message associated with the message code from the message
    // file.
    //

    msgBuf = (LPBYTE)LocalAlloc(LMEM_ZEROINIT, ERROR_LOG_SIZE);

    if (msgBuf == NULL) {
        status = GetLastError();
        MSG_LOG(ERROR,"MsgErrorLogWrite: LocalAlloc FAILURE %X\n",
            status);
        return(status);
    }

    //
    //  TODO ITEM:
    //  If we actually used strings, then they must be converted to unicode.
    //  However, since they are never used, this isn't very important.
    //

    status = DosGetMessage (
                &Strings,                   // String substitution table
                (USHORT)NumStrings,         // Num Entries in table above
                msgBuf,                     // Buffer receiving message
                ERROR_LOG_SIZE,             // size of buffer receiving msg
                (USHORT)Code,               // message num to retrieve
                MessageFileName,            // Name of message file
                &msglen);                   // Num bytes returned

    if (status != NERR_Success) {
        LocalFree(msgBuf);
        return(status);
    }

#if DBG

    DbgPrint("MsgErrorLogWrite: COMPONENT = %ws\n",Component);
    DbgPrint("MsgErrorLogWrite: %s\n",msgBuf);

    if ( Buffer != NULL )
    {
        MsgDbgHexDump( (LPBYTE)Buffer, BufferSize);
    }

#endif //DBG

    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);

    LocalFree(msgBuf);
    return(NERR_Success);
}


NET_API_STATUS
MsgOutputMsg (
    USHORT       AlertLength,
    LPSTR        AlertBuffer,
    ULONG        SessionId,
    SYSTEMTIME   BigTime
    )

/*++

Routine Description:

    This function translates the alert buffer from an Ansi String to a
    Unicode String and outputs the buffer to whereever it is to go.
    Currently this just becomes a DbgPrint.

Arguments:

    AlertLength - The number of bytes in the AlertBuffer.

    AlertBuffer - This is a pointer to the buffer that contains the message
        that is to be output.  The buffer is expected to contain a
        NUL Terminated Ansi String.

    BigTime - The SYSTEMTIME that indicates the time the end of the
        messsage was received.

Return Value:



--*/

{
    UNICODE_STRING  unicodeString;
    OEM_STRING     ansiString;

    NTSTATUS        ntStatus;

    //
    // NUL Terminate the message.
    // Translate the Ansi message to a Unicode Message.
    //
    AlertBuffer[AlertLength++] = '\0';

    ansiString.Length = AlertLength;
    ansiString.MaximumLength = AlertLength;
    ansiString.Buffer = AlertBuffer;

    ntStatus = RtlOemStringToUnicodeString(
                &unicodeString,      // Destination
                &ansiString,         // Source
                TRUE);               // Allocate the destination.

    if (!NT_SUCCESS(ntStatus)) {
        MSG_LOG(ERROR,
            "MsgOutputMsg:RtlOemStringToUnicodeString Failed rc=%X\n",
            ntStatus);

        //
        // EXPLANATION OF WHY IT RETURNS SUCCESS HERE.
        // Returning success even though the alert is not raised is
        // consistent with the LM2.0 code which doesn't check the
        // return code for the NetAlertRaise API anyway.  Returning
        // anything else would require a re-design of how errors are
        // handled by the caller of this routine.
        //
        return(NERR_Success);
    }

    //*******************************************************************
    //
    //  PUT THE MESSAGE IN THE DISPLAY QUEUE
    //

    MsgDisplayQueueAdd( AlertBuffer, (DWORD)AlertLength, SessionId, BigTime);

    //
    //
    //*******************************************************************

    RtlFreeUnicodeString(&unicodeString);
    return(NERR_Success);
}

#if DBG
VOID
MsgDbgHexDumpLine(
    IN LPBYTE StartAddr,
    IN DWORD BytesInThisLine
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    LPBYTE BytePtr;
    DWORD BytesDone;
    DWORD HexPosition;

    DbgPrint(FORMAT_LPVOID " ", (LPVOID) StartAddr);

    BytePtr = StartAddr;
    BytesDone = 0;
    while (BytesDone < BytesInThisLine) {
        DbgPrint("%02X", *BytePtr);  // space for "xx" (see pad below).
        SPACE_BETWEEN_BYTES;
        ++BytesDone;
        if ( (BytesDone % sizeof(DWORD)) == 0) {
            SPACE_BETWEEN_DWORDS;
        }
        ++BytePtr;
    }

    HexPosition = BytesDone;
    while (HexPosition < BYTES_PER_LINE) {
        DbgPrint("  ");  // space for "xx" (see byte above).
        SPACE_BETWEEN_BYTES;
        ++HexPosition;
        if ( (HexPosition % sizeof(DWORD)) == 0) {
            SPACE_BETWEEN_DWORDS;
        }
    }

    BytePtr = StartAddr;
    BytesDone = 0;
    while (BytesDone < BytesInThisLine) {
        if (isprint(*BytePtr)) {
            DbgPrint( FORMAT_CHAR, (CHAR) *BytePtr );
        } else {
            DbgPrint( "." );
        }
        ++BytesDone;
        ++BytePtr;
    }
    DbgPrint("\n");

} // MsgDbgHexDumpLine

VOID
MsgDbgHexDump(
    IN LPBYTE StartAddr,
    IN DWORD Length
    )
/*++

Routine Description:

    MsgDbgHexDump: do a hex dump of some number of bytes to the debug
    terminal or whatever.  This is a no-op in a nondebug build.

Arguments:


Return Value:


--*/
{
    DWORD BytesLeft = Length;
    LPBYTE LinePtr = StartAddr;
    DWORD LineSize;

    while (BytesLeft > 0) {
        LineSize = MIN(BytesLeft, BYTES_PER_LINE);
        MsgDbgHexDumpLine( LinePtr, LineSize );
        BytesLeft -= LineSize;
        LinePtr += LineSize;
    }

} // NetpDbgHexDump

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msginit.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    msginit.c

Abstract:

    Messenger Service Initialization Routines.
    The following is a list of functions in this file:

        MsgInitializeMsgr
        BufferInit
        InitSharedData
        SetComputerName
        GetNumNets
        MsgGetBufSize
        SetUpMessageFile

Author:

    Dan Lafferty (danl) 18-Jul-1991

Environment:

    User Mode - Win32

Notes:

    optional-notes

Revision History:

    19-Aug-1997 wlees
        PNP support.  Retry if lana's not present yet.

    27-Jun-1995 AnirudhS
        LocalFree(dataPtr) must be called AFTER MsgFreeSupportSeg, because
        the latter tries to _close a handle stored in dataPtr.

    08-Feb-1994 Danl
        Removed the restriction that the memory allocated had to be
        restricted to less than a 64K segment.  We don't worry about
        segments anymore.

    12-Jan-1993 Danl
        In error paths where we call MsgCloseWakeupSems, I need to do the
        LocalFree(dataPtr) after the call to MsgCloseWakeupSems.  Otherwise,
        it access violates because MsgCloseWakeupSems uses the shared date
        in the block pointed to by the dataPtr.

    21-Apr-1992 JohnRo
        Fixed bug printing a status when message name add fails.
        Changed to use FORMAT_ equates throughout.

    18-Feb-1992 ritaw
        Convert to Win32 service control APIs.

    18-Jul-1991 danl
        Created as a composite of the original LM2,0 routines.


--*/
//
// Includes
//

#include <stdlib.h>     // atol
#include "msrv.h"       // Messenger prototypes and constants
#include <winsvc.h>     // Service control APIs
#include <winsock2.h>   // Windows sockets

#include <netdebug.h>   // NetpAssert, FORMAT_ equates.
#include <rpc.h>        // DataTypes and runtime APIs
#include <msgsvc.h>     // generated by the MIDL complier

#include <netlibnt.h>   // NetpNtStatusToApiStatus prototypes

#include <tstring.h>    // Unicode string macros
#include <string.h>     // memcpy
#include <lmwksta.h>    // NetWrkstaTransportEnum
#include <lmapibuf.h>   // NetApiBufferFree
#include <netlib.h>     // UNUSED macro
#include <msgrutil.h>   // NetpNetBiosReset
#include <apperr2.h>    // APE2_ALERTER_PRINTING_SUCCESS

#include "msgdbg.h"     // MSG_LOG
#include "heap.h"       // heap management routines and macros.
#include "msgdata.h"    // Global data
#include "msgsec.h"     // Messenger security information

#include "msgnames.h"   // MSGR_INTERFACE_NAME
#include "msgtext.h"    // MTXT_MsgsvcTitle

#include "msgsvcsend.h"   // Broadcast message send interface

#include "apiutil.h"      // for MsgAddSessionInList

// The per net data and heap buffer are allocated once. Later on we may
// wish to keep them separate.
#define BOOKKEEPING_SIZE(n) (n * sizeof(NET_DATA))

#define MAXSEG              (0xffff)

#define LMI_PARM_M_SIZMESSBUF   TEXT("/sizmessbuf")


//
//  Global Data
//

    static DWORD    bufferSize;         // Message buffer size
    static DWORD    msrv_pid;           // pid of message server

    extern LPTSTR   MessageFileName;

//
// Local Function Prototypes
//

VOID
MsgBufferInit(
    IN DWORD  dwBufLen
    );

NET_API_STATUS
MsgInitSharedData(
    DWORD NumNets
    );

NET_API_STATUS
MsgSetComputerName(
    DWORD NumNets
    );

DWORD
MsgGetNumNets(VOID);

NET_API_STATUS
MsgGetBufSize (
    OUT LPDWORD bufferSize
    );

DWORD
MsgSetUpMessageFile(VOID);


STATIC VOID
MsgInitMessageBoxTitle(
    VOID
    );

NET_API_STATUS
MsgrInitializeMsgrInternal1(
    void
    );

NET_API_STATUS
MsgrInitializeMsgrInternal2(
    void
    );

VOID
MsgInitEndpoint(
    PVOID  Context           // This passed in as context
    );


NET_API_STATUS
MsgInitializeMsgr(
    IN  DWORD   argc,
    IN  LPTSTR  *argv
    )

/*++

Routine Description:

    Registers the control handler with the dispatcher thread.  Then it
    performs all initialization including the starting of the RPC server.
    If any of the initialization fails, MsgStatusUpdate is called so that the
    status is updated and the thread is terminated.

Arguments:


Return Value:



--*/

{
    NET_API_STATUS      status;
    DWORD               msgrState;
    DWORD               bufLen;
    WSADATA             wsaData;
    NTSTATUS            ntStatus;

    //
    // Initialize the Thread Manager.  This initializes some locks used
    // on the Thread and Status databases.
    //
    status = MsgThreadManagerInit();

    if (status != NO_ERROR)
    {
        MSG_LOG1(ERROR,
                 "MsgInitializeMsgr:  Thread manager init failed %d\n",
                 status);

        return MsgBeginForcedShutdown(IMMEDIATE, status);
    }

    //
    // Initialize the status structure
    //
    MsgStatusInit();

    //
    // Register this service with the ControlHandler.
    // Now we can accept control requests and be requested to UNINSTALL.
    //

    MSG_LOG(TRACE, "Calling RegisterServiceCtrlHandlerEx\n",0);
    if ((MsgrStatusHandle = RegisterServiceCtrlHandlerEx(
                                SERVICE_MESSENGER,
                                MsgrCtrlHandler,
                                NULL
                                )) == (SERVICE_STATUS_HANDLE) NULL) {

        status = GetLastError();

        MSG_LOG(ERROR,
            "FAILURE: RegisterServiceCtrlHandlerEx status = " FORMAT_API_STATUS
            "\n", status);

        return( MsgBeginForcedShutdown (
                    IMMEDIATE,
                    status));
    }

    //
    // Notify that installation is pending
    //

    msgrState = MsgStatusUpdate(STARTING);

    if (msgrState != STARTING) {
        //
        // An UNINSTALL control request must have been received
        //
        return(msgrState);
    }

    //
    // Init the _HYDRA_ WinStation message support
    //
    status = MultiUserInitMessage();

    if (status != NERR_Success)
    {
        MSG_LOG(ERROR, "MultiUser Initialization Failed " FORMAT_RPC_STATUS "\n",
                status);

        return (MsgBeginForcedShutdown(
                IMMEDIATE,
                status));
    }

    //
    // Check that the workstation is started
    //

    MSG_LOG(TRACE, "Calling NetServiceControl\n",0);

    if (! NetpIsServiceStarted(SERVICE_WORKSTATION)) {

        MSG_LOG(ERROR, "WorkStation Service is not started\n",0);

        return (MsgBeginForcedShutdown(
                     IMMEDIATE,
                     NERR_WkstaNotStarted));
    }

    // *** INSTALLATION HINT ***
    msgrState = MsgStatusUpdate(STARTING);
    if (msgrState != STARTING) {
        return(msgrState);
    }

    //
    //  Get the default buffer size.
    //

    status = MsgGetBufSize(&bufferSize);

    if (status != NERR_Success)
    {
        MSG_LOG(ERROR, "MsgGetBufSize Failed\n",0);
        return (MsgBeginForcedShutdown(
                    IMMEDIATE,
                    status));
    }

    // *** INSTALLATION HINT ***
    msgrState = MsgStatusUpdate(STARTING);
    if (msgrState != STARTING) {
        return(msgrState);
    }


    if (bufferSize > MAX_SIZMESSBUF || bufferSize < MIN_SIZMESSBUF) {
        MSG_LOG(ERROR, "Message Buffer Size is illegal\n",0);
        return (MsgBeginForcedShutdown(
                    IMMEDIATE,
                    ERROR_INVALID_PARAMETER));
    }

    //
    // This is the size of the buffer (that SDBUFFER points to) in the
    // shared data area.  This is calculated as:
    //
    //   The size of a message buffer (bufferSize)
    //          plus
    //   space for 4 Multi-block message headers and names,
    //          plus
    //   space for one Multi-block text header for each text block that
    //   fits into the message buffer.  (bufferSize/TXTMAX).
    //
    //  The number of headers is rounded up by one.
    //      (bufferSize+TXTMAX-1)/TXTMAX
    //
    bufferSize += (4 * (sizeof(MBB) + (2 * NCBNAMSZ))) +
        ((( (bufferSize+TXTMAX-1)/TXTMAX) + 1) * sizeof(MBT));



    // ***** INSTALLATION HINT *****
    msgrState = MsgStatusUpdate(STARTING);
    if (msgrState != STARTING) {
        return(msgrState);
    }

    //
    // Ask the Worksta for the computer name.  If the computer
    // has no name, then abort.
    //
    // The computername and the username are in unicode format.
    //
    // NOTE:  the username that is returned is a name we may want to add
    //        to the table.
    //

    MSG_LOG(TRACE, "Getting the ComputerName\n",0);

    bufLen = sizeof(machineName);

    *machineName = TEXT('\0');

    if (!GetComputerName(machineName,&bufLen)) {
        MSG_LOG(ERROR,"GetComputerName failed \n",0);
        status = GetLastError();
    }

    if ( (status != NERR_Success) ||
         (*machineName == TEXT('\0')) || (*machineName == TEXT(' ')))
    {
        //
        // fatal error if no name
        //
        MSG_LOG(ERROR, "GetWkstaNames Failed\n",0);
        return (MsgBeginForcedShutdown(
                    IMMEDIATE,
                    NERR_NoComputerName));
    }

    machineName[NCBNAMSZ] = TEXT('\0');           // make sure it's terminated
    MachineNameLen = (SHORT) STRLEN(machineName);


    // ***** INSTALLATION HINT *****
    msgrState = MsgStatusUpdate(STARTING);

    if (msgrState != STARTING)
    {
        return(msgrState);
    }

    //
    // Initialize the configuration lock.  This lock covers the allocation and deallocation
    // of the data structures related to lan adapters.
    //
    if (MsgConfigurationLock(MSG_INITIALIZE,"MsgInitializeMsgr"))
    {
        //
        // Do first phase of lan adapter related configuration
        //
        status = MsgrInitializeMsgrInternal1();

        if (status != NERR_Success)
        {
            MSG_LOG1(ERROR, "MsgrInitializeMsgrInternal1 Failure %d\n", status);
        }
    }
    else
    {
        MSG_LOG0(ERROR, "MsgConfigurationLock -- MSG_INITIALIZE failed\n");

        status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (status != NERR_Success)
    {
        MsgFreeSharedData();

        if (wakeupSem != NULL)
        {
            MsgFreeSupportSeg();
        }

        MsgCloseWakeupSems();          // Close the ones that have been created

        return (MsgBeginForcedShutdown(
                    IMMEDIATE,
                    status));
    }


    // ***** INSTALLATION HINT *****
    msgrState = MsgStatusUpdate(STARTING);

    if (msgrState != STARTING)
    {
        return(msgrState);
    }

    //
    // Change from IMMEDIATE Shutdowns to PENDING shutdowns.
    // This is because at this point we have names on the adapters
    // to clean up.
    //

    status = MsgrInitializeMsgrInternal2();

    if (status != NERR_Success)
    {
        MSG_LOG1(ERROR, "MsgrInitializeMsgrInternal2 Failure\n", status);

        return (MsgBeginForcedShutdown(
                    PENDING,
                    status));
    }

    //
    // Build the name of the file that is to be used to get the
    // message header and tail.  Don't care about errors, since
    // any error will result in the file not being used and is
    // resorting to the old standby strings.
    //

    MSG_LOG(TRACE, "Calling MsgSetUpMessageFile\n",0);
    MsgSetUpMessageFile();

    //
    // Start the Group messenger thread to handle all domain messaging
    //

    MSG_LOG(TRACE, "Calling MsgInitGroupSupport\n",0);

    if ( status = MsgInitGroupSupport( SD_NUMNETS() ) )
    {
        MSG_LOG(ERROR, "InitGroupSupport Failed\n",0);
        return (MsgBeginForcedShutdown(
                    PENDING,
                    NERR_GrpMsgProcessor));
    }

    //
    // Initialize the Display Code
    //
    status = MsgDisplayInit();

    if (status != NO_ERROR)
    {
        MSG_LOG1(ERROR, "Could not initialize the display functions %d\n", status);
        return (MsgBeginForcedShutdown(
                    PENDING,
                    status));
    }


    //
    // Create the security descriptor that is to be used in access
    // checks on the API interface.
    //

    MSG_LOG(TRACE, "Calling MsgCreateMessageNameObject\n",0);
    status = MsgCreateMessageNameObject();

    if (status != NERR_Success)
    {
        MSG_LOG(ERROR, "MsgCreateMessageNameObject (security descriptor) "
                "Failed\n", 0);

        return (MsgBeginForcedShutdown(
                    PENDING,
                    status));
    }

    //
    // Initialize the text for the message box title.
    //
    MsgInitMessageBoxTitle();

    //
    // Start the Messengers RPC server.
    //
    // NOTE:  Now all RPC servers in services.exe share the same pipe name.
    // However, in order to support communication with version 1.0 of WinNt,
    // it is necessary for the Client Pipe name to remain the same as
    // it was in version 1.0.  Mapping to the new name is performed in
    // the Named Pipe File System code.
    //

    MSG_LOG(TRACE,
        "MsgInitializeMsgr:Getting ready to start RPC server\n",0);

    status = MsgsvcGlobalData->StartRpcServer(
                MSGR_INTERFACE_NAME,
                msgsvc_ServerIfHandle);

    if (!NT_SUCCESS(status)) {
        MSG_LOG(ERROR, "RPC Initialization Failed " FORMAT_RPC_STATUS "\n",
                status);

        return (MsgBeginForcedShutdown(
                PENDING,
                status));
    }

    //
    // Start thread to register with endpoint mapper (may take a while)
    //
    ntStatus = RtlQueueWorkItem(MsgInitEndpoint,      // Callback
                                NULL,                 // pContext
                                WT_EXECUTEONLYONCE |  // Long one-shot callback
                                  WT_EXECUTELONGFUNCTION);

    if (!NT_SUCCESS(ntStatus)) {
        MSG_LOG(ERROR, "MsgInit: failed to start endpoint registration thread: %#x\n",
                ntStatus);

        return (MsgBeginForcedShutdown(
                PENDING,
                status));
    }

    // Initialize winsock (needed for name resolution)
    //

    status = WSAStartup(MAKEWORD(2,1),&wsaData);
    if (status != ERROR_SUCCESS) {
        MSG_LOG(ERROR, "Initialization of Winsock DLL failed " FORMAT_RPC_STATUS "\n",
                status);

        return (MsgBeginForcedShutdown(
                PENDING,
                status));
    }

    //
    //  Update the status to indicate that installation is complete.
    //  Get the current state back in case the ControlHandling thread has
    //  told us to shutdown.
    //

    MSG_LOG(TRACE, "Exiting MsgInitializeMsgr - Init Done!\n",0);

    return (MsgStatusUpdate(RUNNING));
}


NET_API_STATUS
MsgrInitializeMsgrInternal1(
    void
    )

/*++

Routine Description:

Initialize volatile state related to lanas.
These initializations can be undone immediately if there is an error.

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD NumNets;
    NET_API_STATUS      status;

    MSG_LOG(TRACE, "Calling MsgGetNumNets\n",0);
    NumNets = MsgGetNumNets();

    if (NumNets == 0)
    {
        MSG_LOG(TRACE, "FYI: No lana's enabled at this time\n",0);
        // Not having any networks is no longer an error, ie Numnets == 0 is ok
    }

    //
    // Initialize shared memory areas.
    //
    MSG_LOG(TRACE, "Calling MsgInitSharedData\n",0);
    status = MsgInitSharedData(NumNets);

    if (status != NERR_Success)
    {
        return status;
    }

    //*****************************************
    //
    // STUFF FROM Init_msrv() in MSRV.C
    //
    //*****************************************

    heap   = SD_BUFFER();           // Initialize data heap pointer
    heapln = SD_BUFLEN();           // Initialize data heap length

    //
    // Set up the segement to hold the net bios handles, lana-nums
    // and wakeup Semaphores.
    //

    MSG_LOG(TRACE, "Calling MsgInitSupportSeg\n",0);

    status = MsgInitSupportSeg();

    if (status != NERR_Success)
    {
        MSG_LOG(ERROR, "InitSupportSeg Failed\n",0);
        return status;
    }

    //
    // Now initialize global net bios handles & lana nums. Initializes net_lana_num[]
    //

    MSG_LOG(TRACE, "Calling MsgInit_NetBios\n",0);

    status = MsgInit_NetBios();

    if (status != NERR_Success)
    {
        MSG_LOG1(ERROR, "MsgInit_NetBios failed %d\n", status);
        return status;
    }

    //
    // Get the wake up semaphore handles.  Initializes wakeupSem[]
    //

    MSG_LOG(TRACE, "Calling MsgCreateWakeupSems\n",0);

    //
    // This always returns TRUE
    //
    MsgCreateWakeupSems(SD_NUMNETS());

    //
    // Open NETBIOS for use by messenger.
    // If any failures occur beyond this we must remember to close.
    //
    MsgsvcGlobalData->NetBiosOpen();

    //
    // Set computer name on adapters - if any
    //
    MSG_LOG(TRACE, "Calling MsgSetComputerName\n",0);

    status = MsgSetComputerName(SD_NUMNETS());

    if(status != NERR_Success)
    {
        MSG_LOG1(ERROR, "SetComputerName failed %d\n", status);
        MsgsvcGlobalData->NetBiosClose();
        return status;
    }

    return NERR_Success;
}


NET_API_STATUS
MsgrInitializeMsgrInternal2(
    void
    )

/*++

Routine Description:

Initialize volatile lana state.  These initializations cannot be undone easily.  If this routine
fails we must go through a full shutdown in order to clean up.

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // Installation is successful and complete. If there is a
    // user logged on then an attempt is made to add the user name
    // to this message server. No attempt is made at error reporting
    // if this fails, there may not be a user logged on, and if there is,
    // the user name may already exist as a message name on another
    // station.
    //
    //  This is when we add usernames to the message table if we can.
    //  Sometime this needs to handle multiple users??? (not in version 1)
    //

    if (g_IsTerminalServer)
    {
        MsgAddAlreadyLoggedOnUserNames();
    }
    else
    {
        MsgAddUserNames();
    }

    return NERR_Success;
}


VOID
MsgBufferInit(
    IN DWORD  dwBufLen
    )

/*++

Routine Description:

    This function is called during initialization to set up
    the message buffer in the shared data area.

    This function assumes that the shared data area is locked
    in memory, that the access semaphore for the shared data
    area is set, and that the global far pointer, dataPtr, is
    valid.  BufferInit() initializes the heap structure of the
    buffer.

    SIDE EFFECTS

    The buffer in shared memory is initialized.

Arguments:

    dwBuflen - buffer length

Return Value:

    none

--*/

{
    LPHEAPHDR   hp;         // Heap block pointer

    hp = (LPHEAPHDR) SD_BUFFER();       // Get the address of buffer
    HP_SIZE(*hp) = dwBufLen;            // Set the size of the first block
    HP_FLAG(*hp) = 0;                   // Unallocated
    SD_BUFLEN() = dwBufLen;             // Save the length of the buffer
}

DWORD
MsgInitSharedData(
    DWORD   NumNets
    )

/*++

Routine Description:

    This function creates and initializes the shared data area.
    It sets up the computer name and initializes the message
    buffer.

    SIDE EFFECTS

    Calls MsgBufferInit().


Arguments:

    NumNets - Number of network adapters to support.

Return Value:

    RETURN
        NERR_Success if the operation was successful

        ERROR_NOT_ENOUGH_MEMORY - If the memory alloc for the shared
            memory segment fails.

--*/

{

    DWORD       i,j;        // Index
    ULONG       size;
    PNCB_DATA   pNcbData;
    DWORD       MinimumNumNets = ((NumNets == 0)? 1 : NumNets); // 1 is the minimum

    //
    // Create and initialize shared data area.
    //
    size = bufferSize + BOOKKEEPING_SIZE(MinimumNumNets);

    if ((GlobalData.NetData = (PNET_DATA)LocalAlloc(LMEM_ZEROINIT, size)) == NULL) {
        goto NoMemory;
    }
    //
    //  In case NumNets = 0, keep 1 dummy NetData.
    //  This is not very pretty but should avoid any trouble, without having to modify
    //  too much code.
    //
    GlobalData.Buffer = (PCHAR) (&GlobalData.NetData[MinimumNumNets]); 

    for (i = 0; i < NumNets ; i++ )
    {
        // Allocate the list array at the maximum size, but only allocate
        // a small initial number of NCBs.
        if ((GlobalData.NetData[i].NcbList =
             LocalAlloc(LMEM_ZEROINIT,
                        sizeof(PNCB_DATA) * NCB_MAX_ENTRIES)) == NULL)
        {
            goto NoMemory;
        }
        GlobalData.NetData[i].NumNcbs = NCB_INIT_ENTRIES;

        for (j=0; j < NCB_INIT_ENTRIES; j++)
        {
            if ((GlobalData.NetData[i].NcbList[j] = pNcbData =
                (PNCB_DATA) LocalAlloc(LMEM_ZEROINIT,
                                       sizeof(NCB_DATA))) == NULL)
            {
                goto NoMemory;
            }

            pNcbData->Ncb.ncb_cmd_cplt = 0xff;
            pNcbData->Ncb.ncb_retcode = 0;
        }
    }

    //
    // Initialize the shared data lock.  The shared data is shared between
    // the API threads and the worker threads.
    //
    if (!MsgDatabaseLock(MSG_INITIALIZE,"InitSharedData"))
    {
        MSG_LOG0(ERROR,
                 "MsgInitSharedData: MsgDatabaseLock failed\n");

        goto NoMemory;
    }

    //
    // Initialize the "used-to-be shared" data
    //
    SD_NUMNETS()   = NumNets;
    SD_MSRV()      = 0;         // No message server active
    SD_LOGNAM()[0] = '\0';      // No log file yet
    SD_MESLOG()    = 0;         // Message logging disabled
    SD_MESQF()     = INULL;     // Message queue is empty
    SD_MESQB()     = INULL;

    for ( j = 0; j < SD_NUMNETS(); j++ )
    {
        for(i = 0; i < NCBMAX(j); ++i)
        {
            //
            // Mark entries as free
            //
            SD_NAMEFLAGS(j,i) = NFDEL;

            //create empty session lists
            InitializeListHead(&(SD_SIDLIST(j,i)));
        }
    }

    //
    // Initialize the message buffer
    //
    MsgBufferInit(bufferSize);

    //
    // NT NOTE:
    // Skip Initializing the Support Set and Wakeup sems.
    // Init_msrv will end up doing that.
    //

    return(NERR_Success);

NoMemory:
    MSG_LOG(ERROR,"[MSG]InitSharedData:LocalAlloc Failure "
            FORMAT_API_STATUS "\n", GetLastError());
    return(ERROR_NOT_ENOUGH_MEMORY);

}

VOID
MsgFreeSharedData(VOID)
{
    PNET_DATA pNetData;
    PNCB_DATA pNcbData;
    DWORD i,j;

    if (pNetData = GlobalData.NetData) {
        for (i = 0; i < SD_NUMNETS() ; i++, pNetData++ ) {
            if (pNetData->NcbList) {
                for (j = 0; j < NCBMAX(i) ; j++ ) {
                    if (pNcbData = GETNCBDATA(i,j)) {
                        LocalFree(pNcbData);
                    }
                }
                LocalFree(pNetData->NcbList);
            }
        }
        LocalFree(GlobalData.NetData);
        GlobalData.NetData = NULL;
    }
}


NET_API_STATUS
MsgSetComputerName(
    IN DWORD NumNets
    )

/*++

Routine Description:

    This function sets up the shared data area for the computer name
    so that it can receive messages.

    This function sets things up so that the computer name will be able
    to receive messages.  First, it adds the user name form of the computer
    name to the local adapter.  If successful, it then initializes one slot
    in the name table in the shared data area: a computer name
    receiving messages

    SIDE EFFECTS

    Locks the init data segment around net bios usage.
    Calls the net bios.  Makes entries in the shared data area.


Arguments:

    NumNets - The number of network adapters that is supported

Return Value:

        0 = success
        non-zero = failure

--*/

{
    NET_API_STATUS          status = NERR_Success;
    NCB                     ncb;
    UCHAR                   res;
    DWORD                   i;
    unsigned short          j;

    struct {
        ADAPTER_STATUS  AdapterStatus;
        NAME_BUFFER     NameBuffer[16];
    } Astat;


    //
    // Loop for each net.
    //

    for ( i = 0; i < NumNets; i++ )
    {
        // NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW
        //
        // Reset the adapter
        //
        MSG_LOG1(TRACE,"Calling NetBiosReset for lana #%d\n",GETNETLANANUM(i));

        status = MsgsvcGlobalData->NetBiosReset(GETNETLANANUM(i));

        if (status != NERR_Success)
        {
            MSG_LOG(ERROR,"MsgSetComputerName: NetBiosReset failed "
                    FORMAT_API_STATUS "\n", status);
            MSG_LOG(ERROR,"MsgSetComputerName: AdapterNum " FORMAT_DWORD
                    "\n",i);
            //
            // If it fails, skip to the Next Net.
            //
            continue;
        }

        //
        //
        // NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW

        //
        // Set call name for local adapter
        //
        clearncb(&ncb);
        status = MsgFmtNcbName(ncb.ncb_name, machineName, 3);

        if (status != NERR_Success)
        {
            MSG_LOG1(ERROR, "SetComputerName: Format name failed!", status);
            return status;
        }

        ncb.ncb_command = NCBADDNAME;              // Add name (wait)
        ncb.ncb_lana_num = GETNETLANANUM(i);        // Use the LANMAN adapter

        //
        // Copy the name
        // (At this point the name is ansi - not unicode)
        //
        memcpy(SD_NAMES(i,0), ncb.ncb_name, NCBNAMSZ);

        if (g_IsTerminalServer)
        {
            MSG_LOG(TRACE,"SetComputerName: Adding session EVERYBODY_SESSION_ID in the list\n",0);
            MsgAddSessionInList(&(SD_SIDLIST(i,0)),(ULONG)EVERYBODY_SESSION_ID);
        }

        MSG_LOG1(TRACE,"MsgSetComputerName: Adding ComputerName to lana #%d\n",
            GETNETLANANUM(i));

        res = Msgsendncb( &ncb, i);

        //
        // If the lana is being reinitialized we need to force a reset
        //
        if ((res & 0xff) == NRC_ENVNOTDEF)
        {
            MSG_LOG1(TRACE,"SetComputerName: NetBios ADDNAME failed 0x%x - doing reset\n",res);
            status = NetpNetBiosReset(GETNETLANANUM(i));

            if (status == NERR_Success)
            {
                //
                // rebuild the add name request
                //
                clearncb(&ncb);
                status = MsgFmtNcbName(ncb.ncb_name, machineName, 3);

                if (status != NERR_Success)
                {
                    MSG_LOG1(ERROR, "SetComputerName: Format name failed %d!", status);
                    return status;
                }

                ncb.ncb_command = NCBADDNAME;              // Add name (wait)
                ncb.ncb_lana_num = GETNETLANANUM(i);       // Use the LANMAN adapter

                MSG_LOG1(TRACE,"MsgSetComputerName: Adding ComputerName<03> to lana #%d\n",
                         GETNETLANANUM(i));

                res = Msgsendncb(&ncb, i);  // reissue the ncb
            }
        }

        if(res != 0)
        {
            MSG_LOG1(TRACE,"SetComputerName: NetBios ADDNAME failed 0x%x\n",res);

            if((res & 0xff) == NRC_DUPNAME)
            {
                //
                // If the name already exists on the adapter card (the
                // workstation may have added it), we want to get the
                // name number and pretend that we just added it.
                //
                // Name already exists. Issue an ASTAT to find the name
                // number.
                //
                clearncb(&ncb);
                ncb.ncb_buffer = (char FAR *) &Astat;   // Set buffer address
                ncb.ncb_length = sizeof(Astat);         // Set buffer length
                ncb.ncb_callname[0] = '*';              // local adapter status
                ncb.ncb_command = NCBASTAT;             // Adapter status (wait)

                res = Msgsendncb(&ncb,i);
                if( res != NRC_GOODRET)
                {
                    //
                    // Failed to add name
                    //
                    MSG_LOG1(ERROR, "SetComputerName:sendncb (ASTAT) failed 0x%x\n", res);
                    return MsgMapNetError(res);
                }

                //
                // Loop to name number
                //
                for(j = 0; j< Astat.AdapterStatus.name_count; ++j)
                {
                    if (((Astat.NameBuffer[j].name_flags & 7) == 4)
                          &&
                        (memcmp( Astat.NameBuffer[j].name,
                                 SD_NAMES(i,0),
                                 NCBNAMSZ) == 0))
                    {
                        break;            // Found the name
                    }
                }

                if (j == Astat.AdapterStatus.name_count)
                {
                    //
                    // Failed to find
                    //

                    MSG_LOG(ERROR,
                        "SetComputerName:DupName-failed to find NameNum\n",0);

                    return NERR_NoComputerName;
                }

                SD_NAMENUMS(i,0) = Astat.NameBuffer[j].name_num; // Save num
                MSG_LOG1(TRACE,"SetComputerName: use existing name num (%d) instead\n",
                    Astat.NameBuffer[j].name_num);
            }
            else
            {
                //
                // Fail if name not on the card after the call
                //
                MSG_LOG(ERROR, "SetComputerName:Name Not on Card. netbios rc = 0x%x\n",res);
                return NERR_NoComputerName;
            }
        }
        else
        {
            SD_NAMENUMS(i,0) = ncb.ncb_num; // Save the name number
        }


        SD_NAMEFLAGS(i,0) = NFNEW | NFMACHNAME;   // Name is new


    }   // End for all nets

    return NERR_Success;
}


DWORD
MsgGetNumNets(VOID)

/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    NCB             ncb;
    LANA_ENUM       lanaBuffer;
    unsigned char   nbStatus;

    //
    // Find the number of networks by sending an enum request via Netbios.
    //

    clearncb(&ncb);
    ncb.ncb_command = NCBENUM;          // Enumerate LANA nums (wait)
    ncb.ncb_buffer = (char FAR *)&lanaBuffer;
    ncb.ncb_length = sizeof(LANA_ENUM);

    nbStatus = Netbios (&ncb);
    if (nbStatus != NRC_GOODRET) {
        MSG_LOG(ERROR, "GetNumNets:Netbios LanaEnum failed rc="
                FORMAT_DWORD "\n", (DWORD) nbStatus);
        return(FALSE);
    }

    return((DWORD)lanaBuffer.length);

#ifdef replaced

    LPBYTE          transportInfo;
    int             count=0;
    USHORT          loopback_found = 0;
    NET_API_STATUS  status;
    DWORD           entriesRead;
    DWORD           totalEntries;

    //
    // First try and find the networks mananged by the LAN manager
    //
    // NOTE: This call will fail if there are more than MSNGR_MAX_NETS
    // in the machine.    This is not a problem unless there are fewer
    // than MSNGR_MAX_NETS that would qualify for messaging service.
    // In this case, it might be argued that the messenger should start.
    // For now, this is not the case. - ERICPE
    //

    status = NetWkstaTransportEnum (
                NULL,               // server name (local)
                0,                  // level
                &transportInfo,     // bufptr
                -1,                 // preferred maximum length
                &entriesRead,       // entries read
                &totalEntries,      // total entries
                NULL);              // resumeHandle

    //
    // Free up the buffer that RPC allocated for us.
    //
    NetApiBufferFree(transportInfo);

    if (status != NERR_Success) {
        MSG_LOG(ERROR,"GetNumNets:NetWkstaTransportEnum failed "
                FORMAT_API_STATUS "\n", status);
        return(0);
    }
    MSG_LOG(TRACE,"GetNumNets: numnets = " FORMAT_DWORD "\n", totalEntries);

    return(totalEntries);
#endif
}

NET_API_STATUS
MsgGetBufSize (
    OUT LPDWORD bufferSize
    )

/*++

Routine Description:

    This routine fills in the default buffer size

Arguments:

    bufferSize - This is a pointer to where the buffer size is to be stored.

Return Value:

    NERR_Success - No errors, the returned bufferSize is valid.

--*/
{
    //
    // Use the default.
    //

    *bufferSize = 8192;

    return NERR_Success;
}


DWORD
MsgSetUpMessageFile (
    VOID
    )

/*++

Routine Description:

    Builds the name of the message file that is to be used in any
    subsequent DosGetMessage calls.  The name is built in the Global
    variable MessageFileName.

Arguments:

    none

Return Value:

    NERR_Success - The operation was successful

    ERROR_NOT_ENOUGH_MEMORY - Couldn't allocate memory for MessageFileName.


--*/

{

    //
    // allocate some space for the message file name to be built.
    //
    MessageFileName = (LPTSTR)LocalAlloc(LMEM_ZEROINIT, (MSGFILENAMLEN+sizeof(TCHAR)));

    if (MessageFileName == NULL) {
        MSG_LOG(ERROR,"[MSG]SetUpMessageFile:LocalAlloc Failure "
                FORMAT_API_STATUS "\n", GetLastError());
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // This message filename (netmsg.dll) is defined in lmcons.h
    //

    STRCPY(MessageFileName,MESSAGE_FILENAME);

    return (NERR_Success);

}

STATIC VOID
MsgInitMessageBoxTitle(
    VOID
    )

/*++

Routine Description:

    Obtains the title text for the message box used to display messages.
    If the title is successfully obtained from the message file, then
    that title is pointed to by GlobalAllocatedMsgTitle and
    GlobalMessageBoxTitle.  If unsuccessful, then GlobalMessageBoxTitle
    left pointing to the DefaultMessageBoxTitle.

    NOTE:  If successful, a buffer is allocated by this function.  The
    pointer stored in GlobalAllocatedMsgTitle and it should be freed when
    done with this buffer.

Arguments:

Return Value:

    none

--*/
{
    LPVOID      hModule;
    DWORD       msgSize;
    DWORD       status=NO_ERROR;

    GlobalAllocatedMsgTitle = NULL;

    hModule = LoadLibrary( L"netmsg.dll");
    if ( hModule == NULL) {
        status = GetLastError();
        MSG_LOG1(ERROR, "LoadLibrary() fails with winError = %d\n", GetLastError());
        return;
    }

    msgSize = FormatMessageW(
                FORMAT_MESSAGE_FROM_HMODULE |       //  dwFlags
                  FORMAT_MESSAGE_ARGUMENT_ARRAY |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hModule,
                MTXT_MsgsvcTitle,                   //  MessageId
                0,                                  //  dwLanguageId
                (LPWSTR)&GlobalAllocatedMsgTitle,   //  lpBuffer
                0,                                  //  nSize
                NULL);

    if (msgSize == 0) {
        status = GetLastError();
        MSG_LOG1(ERROR,"Could not find MessageBox title in a message file %d\n",
        status);
    }
    else {
        GlobalMessageBoxTitle = GlobalAllocatedMsgTitle;
    }

    //
    // Get the messages as Ansi since we'll be comparing them to an
    // Ansi message that comes in from a remote Alerter service.
    //

    msgSize = FormatMessageA(
                FORMAT_MESSAGE_FROM_HMODULE |       //  dwFlags
                  FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hModule,
                APE2_ALERTER_PRINTING_SUCCESS,      //  MessageId
                0,                                  //  dwLanguageId
                (LPSTR) &g_lpAlertSuccessMessage,   //  lpBuffer
                0,                                  //  nSize
                NULL);

    if (msgSize == 0)
    {
        // No loss -- we just won't be able to filter print success alerts

        status = GetLastError();
        MSG_LOG1(ERROR,
                 "Could not find Alerter print success message %d\n",
                 status);
    }
    else
    {
        //
        // Trim the message to end after the "Printing Complete" line.
        //

        LPSTR  lpTemp = g_lpAlertSuccessMessage;

        g_dwAlertSuccessLen = 0;

        while (*lpTemp && *lpTemp != '\r')
        {
            lpTemp++;
            g_dwAlertSuccessLen++;
        }

        *lpTemp = '\0';
    }

    msgSize = FormatMessageA(
                FORMAT_MESSAGE_FROM_HMODULE |       //  dwFlags
                  FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hModule,
                APE2_ALERTER_PRINTING_FAILURE,      //  MessageId
                0,                                  //  dwLanguageId
                (LPSTR) &g_lpAlertFailureMessage,   //  lpBuffer
                0,                                  //  nSize
                NULL);

    if (msgSize == 0)
    {
        // No loss -- we just won't be able to filter print success alerts

        status = GetLastError();
        MSG_LOG1(ERROR,
                 "Could not find Alerter print failure message %d\n",
                 status);
    }
    else
    {
        //
        // Trim the message to end after the "Printing Complete" line.
        //

        LPSTR  lpTemp = g_lpAlertFailureMessage;

        g_dwAlertFailureLen = 0;

        while (*lpTemp && *lpTemp != '\r')
        {
            lpTemp++;
            g_dwAlertFailureLen++;
        }

        *lpTemp = '\0';
    }

    FreeLibrary(hModule);
    return;
}


VOID
MsgInitEndpoint(
    PVOID   Context              // This passed in as context.
    )

/*++

Routine Description:

    This function is called to initialize our RPC server entry point. We
    do this in a separate thread because we may have to wait because
    RpcSS is not ready yet.

Arguments:

    Context - Context parameter

Return Value:

    None

--*/
{
    RPC_BINDING_VECTOR *bindingVector = NULL;
    DWORD status, tries;

    MSG_LOG(TRACE, "MsgInitEndpoint starting in separate thread\n",0);

    //
    // Create endpoint for receiving RPC calls
    // This is for netbiosless notifications
    //

    for( tries = 0; tries < 3; tries++ ) {

        status = RpcServerUseProtseq(
            TEXT("ncadg_ip_udp"),
            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
            NULL         // Do we need an empty SD here?
            );

        if ( (status == RPC_S_OK) || (status == RPC_S_DUPLICATE_ENDPOINT) ) {
            break;
        }

        MSG_LOG(ERROR, "RPC Init (UseProt Udp) Failed "
                FORMAT_RPC_STATUS " - trying again\n", status);
        Sleep( 30 * 1000 );
    }

    if ( (status != RPC_S_OK) && (status != RPC_S_DUPLICATE_ENDPOINT) ) {
        if (status == RPC_S_SERVER_UNAVAILABLE) {
            MSG_LOG( ERROR, "Failed to use UDP, check RPCSS service\n",0 );
        } else {
            MSG_LOG( ERROR, "Failed to use UDP, check TCP/IP\n",0 );
        }
        // give up
        return;
    }

    status = RpcServerInqBindings(
        &bindingVector
        );
    if (status != ERROR_SUCCESS) {
        MSG_LOG( ERROR, "RpcServerInqBindings failed with %d\n",status );
        return;
    }

    // Try to register in a loop in case RPCSS is not running yet

    for( tries = 0; tries < 3; tries++ ) {

        status = RpcEpRegister(
            msgsvcsend_ServerIfHandle,
            bindingVector,
            NULL,
            TEXT("Messenger Service")
            );

        if (status == RPC_S_OK) {
            break;
        }

        MSG_LOG( ERROR, "Msgr: RpcEpRegister failed with %d - trying again\n", status );

        RpcEpUnregister( msgsvcsend_ServerIfHandle,
                         bindingVector,
                         NULL );
        // ignore error

        Sleep( 10 * 1000 );
    }

    RpcBindingVectorFree( &bindingVector );

    if (status != RPC_S_OK) {
        // give up
        return;
    }

    //
    // Register RPC interface
    //

    status = RpcServerRegisterIf(
        msgsvcsend_ServerIfHandle,  // interface to register
        NULL,   // MgrTypeUuid
        NULL);  // MgrEpv; null means use default

    if (status != RPC_S_OK) {
        MSG_LOG(ERROR, "RPC Init (RegIf MsgSvcSend) Failed "
                FORMAT_RPC_STATUS "\n", status);
        return;
    }

    MSG_LOG(TRACE, "MsgInitEndpoint final status %d\n", status);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgsec.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgsec.h

Abstract:

    Private header file to be included by Messenger service modules that
    need to enforce security.

Author:

    Dan Lafferty (danl)     20-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    07-Aug-1991     danl
        created

--*/
#ifndef _MSGSEC_INCLUDED
#define _MSGSEC_INCLUDED

#include <secobj.h>

//
// Object specific access masks
//

#define MSGR_MESSAGE_NAME_INFO_GET      0x0001
#define MSGR_MESSAGE_NAME_ENUM          0x0002
#define MSGR_MESSAGE_NAME_ADD           0x0004
#define MSGR_MESSAGE_NAME_DEL           0x0008


#define MSGR_MESSAGE_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED   |   \
                                         MSGR_MESSAGE_NAME_INFO_GET |   \
                                         MSGR_MESSAGE_NAME_ENUM     |   \
                                         MSGR_MESSAGE_NAME_ADD      |   \
                                         MSGR_MESSAGE_NAME_DEL)


//
// Object type name for audit alarm tracking
//
#define MESSAGE_NAME_OBJECT     TEXT("MsgrNameObject")

//
// Security descriptor for the messenger name object.
//
extern  PSECURITY_DESCRIPTOR    MessageNameSd;

//
// Generic mapping for the messenger name object
//
extern GENERIC_MAPPING  MsgMessageNameMapping;

NET_API_STATUS
MsgCreateMessageNameObject(
    VOID
    );


#endif // ifndef _MSGSEC_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgsec.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgsec.c

Abstract:

    This module contains the Messenger service support routines 
    which create security objects and enforce security _access checking.

Author:

    Dan Lafferty (danl)     07-Aug-1991

Environment:

    User Mode -Win32

Revision History:

    07-Aug-1991     danl
        created

--*/

//
// Includes
//

#include <nt.h>   
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>

#include <lmcons.h>             // NET_API_STATUS.
#include <lmerr.h>
#include <netlibnt.h>

#include "msgdbg.h"
#include "msgsec.h"
#include "msgdata.h"


//
// Global Variables -
//
//  Security Descriptor for Messenger Name object.  This is used to control
//  access to the Messenger Name Table.
//

PSECURITY_DESCRIPTOR    MessageNameSd;


//
// Structure that describes the mapping of Generic access rights to object
// specific access rights for the Messenger Name Object.
//

GENERIC_MAPPING MsgMessageNameMapping = {
    STANDARD_RIGHTS_READ            |   // Generic Read
        MSGR_MESSAGE_NAME_INFO_GET  |
        MSGR_MESSAGE_NAME_ENUM,
    STANDARD_RIGHTS_WRITE           |   // Generic Write
        MSGR_MESSAGE_NAME_ADD       |
        MSGR_MESSAGE_NAME_DEL,
    STANDARD_RIGHTS_EXECUTE,            // Generic Execute
    MSGR_MESSAGE_ALL_ACCESS             // Generic all
    };



NET_API_STATUS
MsgCreateMessageNameObject(
    VOID
    )

/*++

Routine Description:

    This function creates the Messenger Message Name Object.

Arguments:

    None.

Return Value:

    NET_API_STATUS - translated status returned from NetpCreateSecurityObject.

--*/
{
    NTSTATUS    ntStatus;

    //
    // Order matters!  These ACEs are inserted into the DACL in the
    // following order.  Security access is granted or denied based on
    // the order of the ACEs in the DACL.
    //
    // Admins, and local users are allowed to get and change all information.
    //

#define MESSAGE_NAME_ACES   2               // Number of ACES in this DACL

    ACE_DATA    AceData[MESSAGE_NAME_ACES] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &MsgsvcGlobalData->LocalSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &MsgsvcGlobalData->AliasAdminsSid}
    };

    ntStatus = NetpCreateSecurityObject(
                AceData,                             // Ace Data
                MESSAGE_NAME_ACES,                   // Ace Count
                MsgsvcGlobalData->LocalSystemSid,   // Owner Sid
                MsgsvcGlobalData->LocalSystemSid,   // Group Sid
                &MsgMessageNameMapping,              // Generic Mapping
                &MessageNameSd);                     // New Descriptor

    return(NetpNtStatusToApiStatus(ntStatus));           
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgmain.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    msgmain.c

Abstract:

    This is the main routine for the NT OS/2 LAN Manager Messenger Service.
    Functions in the file include:

        SvcEntry_Messenger
        ParseArgs

Author:

    Dan Lafferty    (danl)  20-Mar-1991

Environment:

    User Mode - Win32

Revision History:

    27-Feb-1999     jschwart
        Remove polling loop to detect lana changes -- use PnP events instead
    15-Dec-1998     jschwart
        Convert messenger to use NT thread pool APIs instead of Service
        Controller thread pool
    19-Aug-1997     wlees
        Add polling loop to detect lana changes.
        Provide synchronization between rpc routines and Pnp reconfiguration
    14-Jun-1994     danl
        Fixed problem where messenger put up an empty message as if it
        received a mailslot message during init.  The problem was the
        order of the following events:  CreateMailslot -> wait on handle ->
        submit an async _read with that handle.
        The new order was changed to: CreateMailslot -> submit async _read ->
        wait on handle.
        This causes the handle to not get signaled right away.
    20-Mar-1991     danl
        created

--*/

//
// INCLUDES
//

#include "msrv.h"       // AdapterThread prototype,SESSION_STATUS

#include <winuser.h>    // RegisterDeviceNotification
#include <dbt.h>        // DEV_BROADCAST_DEVICEINTERFACE
#include <tstring.h>    // Unicode string macros
#include <winsock2.h>   // Windows sockets

#include <netlib.h>     // UNUSED macro
#include "msgdbg.h"     // MSG_LOG & STATIC definitions
#include "msgdata.h"    // msrv_status

#include "msgsvc.h"     // Messenger RPC interface
#include "msgsvcsend.h" // Broadcast message send interface


//
// GLOBALS
//

    //
    // Handles for messenger work items.  These are necessary since
    // the Rtl thread pool work items aren't automatically deleted
    // when the callback is called.
    //
    HANDLE  g_hGrpEvent;
    HANDLE  g_hNetEvent;
    HANDLE  g_hNetTimeoutEvent;

    //
    // PNP device notification handle
    //
    HANDLE  g_hPnPNotify;

    //
    // Warning: this definitions of GUID_NDIS_XXX is in ndisguid.h
    // but dragging that file in drags in a whole bunch of guids that
    // won't get thrown out by the linker.
    //
    static const GUID GUID_NDIS_LAN_CLASS =
        {0xad498944,0x762f,0x11d0,{0x8d,0xcb,0x00,0xc0,0x4f,0xc3,0x35,0x8c}};

    //
    // Global buffer pointers used to hold Alerter print text
    //

    LPSTR  g_lpAlertSuccessMessage;
    DWORD  g_dwAlertSuccessLen;
    LPSTR  g_lpAlertFailureMessage;
    DWORD  g_dwAlertFailureLen;


//
// Local Function Prototypes
//

STATIC VOID
Msgdummy_complete(
    short   c,
    int     a,
    char    b
    );

VOID
MsgGrpEventCompletion(
    PVOID       pvContext,      // This passed in as context.
    BOOLEAN     fWaitStatus
    );

VOID
MsgrShutdownInternal(
    void
    );

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    MsgsvcGlobalData = pGlobals;
}
    

VOID
ServiceMain(
    IN DWORD            argc,
    IN LPTSTR           argv[]
    )

/*++

Routine Description:

    This is the main routine for the Messenger Service

Arguments:


Return Value:

    None.

Note:


--*/
{
    DWORD       msgrState;
    NTSTATUS    ntStatus;
    BOOL        fGrpThreadCreated = FALSE;
    BOOL        fNetThreadCreated = FALSE;

    DEV_BROADCAST_DEVICEINTERFACE dbdPnpFilter;

    //
    // Make sure svchost.exe gave us the global data
    //
    ASSERT(MsgsvcGlobalData != NULL);

    MsgCreateWakeupEvent();  // do this once

    msgrState = MsgInitializeMsgr(argc, argv);

    if (msgrState != RUNNING)
    {
        MSG_LOG(ERROR,"[MSG],Shutdown during initialization\n",0);
        MsgsvcGlobalData->NetBiosClose();

        //
        // To get here, the msgrState must either be STOPPING or STOPPED.
        // Shutdown the Messenger Service
        //

        if (msgrState == STOPPING) {
            MsgrShutdown();
            MsgStatusUpdate(STOPPED);
        }

        MSG_LOG(TRACE,"MESSENGER_main: Messenger main thread is returning\n\n",0);
        return;
    }
    else
    {
        //
        // Read the Group Mailslot
        //

        MSG_LOG0(GROUP,"MESSENGER_main: Submit the Group Mailslot ReadFile\n");

        MsgReadGroupMailslot();

        //
        // Submit the work item that will wait on the mailslot handle.
        // When the handle becomes signaled, the MsgGrpEventCompletion
        // function will be called.
        //
        MSG_LOG1(GROUP,"MESSENGER_main: Mailslot handle to wait on "
            " = 0x%lx\n",GrpMailslotHandle);

        ntStatus = RtlRegisterWait(&g_hGrpEvent,            // Work item handle
                                   GrpMailslotHandle,       // Waitable handle
                                   MsgGrpEventCompletion,   // Callback
                                   NULL,                    // pContext
                                   INFINITE,                // Timeout
                                   WT_EXECUTEONLYONCE);     // One-shot

        if (!NT_SUCCESS(ntStatus)) {

            //
            // We want to exit in this case
            //
            MSG_LOG1(ERROR,"MESSENGER_main: RtlRegisterWait failed %#x\n",
                     ntStatus);

            goto ErrorExit;
        }

        fGrpThreadCreated = TRUE;

        ntStatus = RtlRegisterWait(&g_hNetEvent,            // Work item handle
                                   wakeupEvent,             // Waitable handle
                                   MsgNetEventCompletion,   // Callback
                                   NULL,                    // pContext
                                   INFINITE,                // Timeout
                                   WT_EXECUTEONLYONCE |     // One-shot and potentially lengthy 
                                     WT_EXECUTELONGFUNCTION);

        if (!NT_SUCCESS(ntStatus)) {

            //
            // We want to exit in this case
            //
            MSG_LOG1(ERROR,"MsgNetEventCompletion: RtlRegisterWait failed %#x\n",
                     ntStatus);

            goto ErrorExit;
        }

        fNetThreadCreated = TRUE;

        //
        // Register for device notifications.  Specifically, we're interested
        // in network adapters coming and going.  If this fails, we exit.
        //
        MSG_LOG1(TRACE, "SvcEntry_Messenger: Calling RegisterDeviceNotification...\n", 0);

        ZeroMemory (&dbdPnpFilter, sizeof(dbdPnpFilter));
        dbdPnpFilter.dbcc_size         = sizeof(dbdPnpFilter);
        dbdPnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
        dbdPnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

        g_hPnPNotify = RegisterDeviceNotification (
                                MsgrStatusHandle,
                                &dbdPnpFilter,
                                DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!g_hPnPNotify)
        {
            //
            // We want to exit in this case
            //
            MSG_LOG1(ERROR, "SvcEntry_Messenger: RegisterDeviceNotificationFailed %d!\n", 
                     GetLastError());

            goto ErrorExit;
        }

        MSG_LOG(TRACE,"MESSENGER_main: Messenger main thread is returning\n\n",0);
        return;
    }

ErrorExit:

    //
    //  We want to stop the messenger in this case.
    //

    MsgBeginForcedShutdown(PENDING, GetLastError());

    //
    //  In Hydra case, the display thread never goes asleep.
    //
    if (!g_IsTerminalServer)
    {
        MsgDisplayThreadWakeup();
    }

    //
    // MsgNetEventCompletion will shut down the group thread, call
    // MsgrShutdown, and update the status to SERVICE_STOPPED
    //
    if (fNetThreadCreated)
    {
        SetEvent(wakeupEvent);
    }
    else
    {
        if (fGrpThreadCreated)
        {
            MsgGrpThreadShutdown();
        }

        MsgrShutdown();
        MsgStatusUpdate(STOPPED);
    }

    return;
}


STATIC VOID
MsgrShutdown(
    )

/*++

Routine Description:

    Tidies up the network card prior to exiting.  All message server async
    NCBs are cancelled, and message names are deleted.

    When this routine is entered, it is expected that all the worker
    threads have been notified of the impending shutdown.  This routine
    starts out by waiting for all of them to terminate.  Then it continues
    with cleaning up the NCB's and deleting names.

Arguments:

    none

Return Value:

    none

--*/

{
    NET_API_STATUS          status;
    DWORD                   neti;                   // Network index
    DWORD                   ncb_i,i;                // ncb array index
    NCB                     l_ncb;                  // local ncb
    UCHAR                   ncbStatus;
    int                     nbStatus;
    DWORD                   index;
    PNCB_DATA               pNcbData;
    PNCB                    pNcb;
    RPC_BINDING_VECTOR      *bindingVector = NULL;

    MSG_LOG(TRACE," in MsgrShutdown\n",0);

    // *** SHUTDOWN HINT ***
    MsgStatusUpdate (STOPPING);

    // Shutdown winsock
    WSACleanup();

    // *** SHUTDOWN HINT ***
    MsgStatusUpdate (STOPPING);

    //
    // Shut down the RPC interfaces
    //

    status = RpcServerInqBindings(&bindingVector);

    if (status != ERROR_SUCCESS) {
        MSG_LOG(ERROR, "RpcServerInqBindings failed with %d\n", status);
    }

    if (bindingVector != NULL) {
        status = RpcEpUnregister(msgsvcsend_ServerIfHandle, bindingVector, NULL);

        if (status != ERROR_SUCCESS && status != EPT_S_NOT_REGISTERED) {
            MSG_LOG(ERROR, "RpcEpUnregister failed with %d\n", status);
        }
        status = RpcBindingVectorFree(&bindingVector);
    }

    status = RpcServerUnregisterIf(msgsvcsend_ServerIfHandle, NULL, FALSE);
    if (status != ERROR_SUCCESS) {
        MSG_LOG(ERROR,
                "MsgrShutdown: Failed to unregister msgsend rpc interface %d\n",
                status);
    }

    MSG_LOG(TRACE,"MsgrShutdown: Shut down RPC server\n",0);

    MsgsvcGlobalData->StopRpcServer( msgsvc_ServerIfHandle );

    // *** SHUTDOWN HINT ***
    MsgStatusUpdate (STOPPING);

    // Release lana state

    if (g_hPnPNotify != NULL)
    {
        if (!UnregisterDeviceNotification(g_hPnPNotify))
        {
            //
            // Note that if this call fails, PnP will get an error back from the
            // SCM the next time it tries to send us a PnP message (since the
            // service will no longer be running) -- it shouldn't crash things
            //
            MSG_LOG(ERROR, "MsgrShutdown: UnregisterDeviceNotification failed %d!\n",
                    GetLastError());
        }
    }

    MsgrShutdownInternal();

    // *** SHUTDOWN HINT ***
    MsgStatusUpdate (STOPPING);

    //
    // Stop the display thread
    // Note: here the RPC server is stopped so we can stop the display thread
    //       (NB: a RPC API call may call MsgDisplayThreadWakeup)
    //
    MsgDisplayEnd();

    //
    // All cleaning up done. Now free up all resources.  The list of
    // possible resources is as follows:
    //
    //  memory to free:             Handles to Close:
    //  ---------------             -----------------
    //      ncbArray                    wakeupSems
    //      mpncbistate                 threadHandles
    //      net_lana_num
    //      MessageFileName
    //      dataPtr
    //

    MSG_LOG(TRACE,"MsgrShutdown: Free up Messenger Resources\n",0);

    // Group mailslot for domain messaging
    MsgGrpThreadShutdown();

    CLOSE_HANDLE(GrpMailslotHandle, INVALID_HANDLE_VALUE);

    MsgCloseWakeupEvent();  // do this once

    MsgThreadCloseAll();    // Thread Handles

    LocalFree(MessageFileName);
    MessageFileName = NULL;

    LocalFree(GlobalAllocatedMsgTitle);
    GlobalAllocatedMsgTitle = NULL;

    LocalFree(g_lpAlertSuccessMessage);
    g_lpAlertSuccessMessage = NULL;
    g_dwAlertSuccessLen = 0;

    LocalFree(g_lpAlertFailureMessage);
    g_lpAlertFailureMessage = NULL;
    g_dwAlertFailureLen = 0;

    MSG_LOG(TRACE,"MsgrShutdown: Done with shutdown\n",0);
    return;
}


void
MsgrShutdownInternal(
    void
    )

/*++

Routine Description:

Release all state related to the lana's known to the system.

Arguments:

    None

Return Value:

    None

--*/

{
    NET_API_STATUS          status;
    DWORD                   neti;                   // Network index
    DWORD                   ncb_i,i;                // ncb array index
    NCB                     l_ncb;                  // local ncb
    PMSG_SESSION_STATUS     psess_stat;
    UCHAR                   ncbStatus;
    int                     nbStatus;
    DWORD                   index;
    PNCB_DATA               pNcbData;
    PNCB                    pNcb;

    MSG_LOG(TRACE," in MsgrShutdownInternal\n",0);

    if (GlobalData.NetData != NULL)
    {
        psess_stat = LocalAlloc(LMEM_FIXED, sizeof(MSG_SESSION_STATUS));

        if (psess_stat == NULL)
        {
            //
            // Not much else we can do here...
            //
            MSG_LOG(ERROR, "MsgrShutdownInternal:  LocalAlloc FAILED!\n",0);
            return;
        }

        //
        // Now clean up the NCB's
        //

        MSG_LOG(TRACE,"MsgrShutdown: Clean up NCBs\n",0);

        for ( neti = 0; neti < SD_NUMNETS(); neti++ )   // For all nets
        {
            clearncb(&l_ncb);

            //
            // First check for any incomplete Async NCBs and cancel them.
            // As a precaution set the function handler for all the
            // async NCBs to point to a dummy function which will not reissue
            // the NCBs when the complete with cancelled status.
            //

            l_ncb.ncb_lana_num = GETNETLANANUM(neti);   // Use the LANMAN adapter
            l_ncb.ncb_command = NCBCANCEL;              // Cancel (wait)

            for(ncb_i = 0; ncb_i < NCBMAX(neti); ++ncb_i)
            {
                pNcbData = GETNCBDATA(neti,ncb_i);
                pNcb = &pNcbData->Ncb;
                pNcbData->IFunc = (LPNCBIFCN)Msgdummy_complete;// Set function pointer

                if((pNcb->ncb_cmd_cplt == (UCHAR) 0xff) &&
                   (pNcb->ncb_retcode  == (UCHAR) 0xff)) {

                    //
                    // If pending NCB found
                    //

                    l_ncb.ncb_buffer = (PCHAR) pNcb;

                    //
                    // There will always be an NCB reserved for cancels in the rdr
                    // but it may be in use so loop if the cancel status
                    // is NRC_NORES.
                    //

                    while( (ncbStatus = Msgsendncb(&l_ncb, neti)) == NRC_NORES) {
                        //
                        // Wait for half a sec
                        //
                        Sleep(500L);
                    }

                    MSG_LOG(TRACE,"Shutdown:Net #%d\n",neti);
                    MSG_LOG(TRACE,"Shutdown:Attempt to cancel rc = 0x%x\n",
                        ncbStatus);

                    //
                    // Now loop waiting for the cancelled ncb to complete.
                    // Any ncbs types which are not valid to cancel (eg Delete
                    // name) must complete so a wait loop here is safe.
                    //
                    // NT Change - This will only loop for 30 seconds before
                    //  leaving - whether or not the CANCEL is complete.
                    //
                    status = NERR_InternalError;

                    for (i=0; i<60; i++) {
                        if (pNcb->ncb_cmd_cplt != (UCHAR) 0xff) {
                            status = NERR_Success;
                            break;
                        }
                        //
                        // Wait for half a sec
                        //
                        Sleep(500L);
                    }
                    if (status != NERR_Success) {
                        MSG_LOG(ERROR,
                        "MsgrShutdown: NCBCANCEL did not complete\n",0);
                    }
                }
            }

            //
            // All asyncronous ncbs cancelled completed. Now delete any
            // messaging names active on the network card.
            //

            MSG_LOG(TRACE,"MsgrShutdown: All Async NCBs are cancelled\n",0);
            MSG_LOG(TRACE,"MsgrShutdown: Delete messaging names\n",0);

            for(i = 0; i < NCBMAX(neti); ++i)     // Loop to find active names slot
            {
                //
                // If any of the NFDEL or NFDEL_PENDING flags are set for
                // this name slot then there is no name on the card associated
                // with it.
                //

                clearncb(&l_ncb);

                if(!(SD_NAMEFLAGS(neti, i) &
                    (NFDEL | NFDEL_PENDING)))
                {

                    //
                    // If there is a session active on this name, hang it up
                    // now or the delete name will fail
                    //

                    l_ncb.ncb_command = NCBSSTAT;           // session status (wait)

                    memcpy(l_ncb.ncb_name, (SD_NAMES(neti, i)), NCBNAMSZ);

                    l_ncb.ncb_buffer = (char far *)psess_stat;
                    l_ncb.ncb_length = sizeof(MSG_SESSION_STATUS);
                    l_ncb.ncb_lana_num = GETNETLANANUM(neti);


                    nbStatus = Msgsendncb(&l_ncb, neti);
                    if(nbStatus == NRC_GOODRET)                 // If success
                    {
                        for (index=0; index < psess_stat->SessHead.num_sess ;index++) {

                            l_ncb.ncb_command = NCBHANGUP;      // Hangup (wait)
                            l_ncb.ncb_lsn = psess_stat->SessBuffer[index].lsn;
                            l_ncb.ncb_lana_num = GETNETLANANUM(neti);

                            nbStatus = Msgsendncb(&l_ncb, neti);
                            MSG_LOG3(TRACE,"HANGUP NetBios for Net #%d Session #%d "
                                "status = 0x%x\n",
                                neti,
                                psess_stat->SessBuffer[index].lsn,
                                nbStatus);

                        }
                    }
                    else {
                        MSG_LOG2(TRACE,"SessionSTAT NetBios Net #%d failed = 0x%x\n",
                            neti, nbStatus);
                    }

                    //
                    // With the current design of the message server there can
                    // be only one session per name so the name should now be
                    // clear of sessions and the delete name should work.
                    //

                    l_ncb.ncb_command = NCBDELNAME;         // Del name (wait)
                    l_ncb.ncb_lana_num = GETNETLANANUM(neti);

                    //
                    // Name is still in l_ncb.ncb_name from previous SESSTAT
                    //

                    nbStatus = Msgsendncb(&l_ncb, neti);
                    MSG_LOG2(TRACE,"DELNAME NetBios Net #%d status = 0x%x\n",
                        neti, nbStatus);
                }
            }
        } // End for all nets loop

        LocalFree(psess_stat);
    }

    MsgsvcGlobalData->NetBiosClose();

    MsgCloseWakeupSems();           // wakeupSems

    MsgFreeSharedData();

    if (wakeupSem != NULL) {
        MsgFreeSupportSeg();            // wakeupSem
    }
}


VOID
Msgdummy_complete(
    short   c,
    int     a,
    char    b
    )
{
    // just to shut up compiler

    MSG_LOG(TRACE,"In dummy_complete module\n",0);
    UNUSED (a);
    UNUSED (b);
    UNUSED (c);
}


VOID
MsgNetEventCompletion(
    PVOID       pvContext,         // This passed in as context.
    BOOLEAN     fWaitStatus
    )

/*++

Routine Description:

    This function is called when the event handle for one of the
    nets becomes signaled.

Arguments:

    pvContext   - This should always be zero.

    fWaitStatus - TRUE if we're being called because of a timeout.
                  FALSE if we're being called because the waitable
                        event was signalled

Return Value:

    None

--*/
{
    DWORD           neti, numNets;
    DWORD           msgrState;
    BOOL            ncbComplete = FALSE;
    NET_API_STATUS  success;
    NTSTATUS        ntStatus;

    if (fWaitStatus)
    {
        //
        // We timed out (i.e., this came from the control handler)
        //

        DEREGISTER_WORK_ITEM(g_hNetTimeoutEvent);
    }
    else
    {
        //
        // We were signalled
        //

        DEREGISTER_WORK_ITEM(g_hNetEvent);
    }

    //
    // Sychronize this routine in the following manner:
    //
    //    1.  Protection against two threads executing simultaneously while
    //        the service is marked RUNNING is done by exclusively acquiring
    //        the MsgConfigurationLock below.
    //
    //    2.  Protection against one thread executing below while another
    //        thread stops and cleans up the Messenger (and frees/NULLs out
    //        the data touched in the routines called below) is done by
    //        the MsgrBlockStateChange call below -- it blocks threads
    //        executing MsgrShutdown since the first thing that routine does
    //        is to call MsgStatusUpdate, which requires the exclusive
    //        resource that MsgrBlockStateChange acquires shared.  This also
    //        blocks threads here until MsgrShutdown is done changing the
    //        state to STOPPING, which will prevent the same race condition.
    //

    MsgrBlockStateChange();

    msgrState = GetMsgrState();

    if (msgrState == STOPPED)
    {
        MsgrUnblockStateChange();
        return;
    }

    if (msgrState == STOPPING)
    {
        //
        // Net 0 is considered the main Net, and this thread will
        // stay around until all the other messenger threads are
        // done shutting down.
        // Threads for all the other nets simply return.
        //

        MsgrUnblockStateChange();
        MsgrShutdown();
        MsgStatusUpdate(STOPPED);

        MSG_LOG(TRACE,"MsgNetEventCompletion: Messenger main thread is returning\n\n",0);
        return;
    }

    //
    // Lock out other activity during reconfiguration
    //

    MsgConfigurationLock(MSG_GET_EXCLUSIVE, "MsgNetEventCompletion" );


    //
    // Look through the NCB's for all nets and service all
    // NCB's that are complete.  Continue looping until one pass
    // is made through the loop without any complete NCB's being found.
    //
    do
    {
        ncbComplete = FALSE;

        MSG_LOG0(TRACE,"MsgNetEventCompletion: Loop through all nets to look "
                 "for any complete NCBs\n");
        
        for ( neti = 0; neti < SD_NUMNETS(); neti++ )
        {
            //
            // For all nets
            //

            ncbComplete |= MsgServeNCBs((DWORD) neti);
            MsgServeNameReqs((DWORD) neti);
        }
    }
    while (ncbComplete);

    numNets = MsgGetNumNets();

    //
    // Only rescan if the number of LANAs has changed, as this callback can be invoked
    // multiple times in the course of one PnP event and when a message is received
    //
    if (numNets != SD_NUMNETS())
    {
        MSG_LOG2(ERROR,"MsgNetEventCompletion: number of lanas changed from %d to %d\n",
                 SD_NUMNETS(), numNets );

        //
        // The number of LAN Adapters has changed -- reinitialize data structures
        //
        // Note that by doing so, we lose all aliases other than usernames and machinename
        //

        MsgrShutdownInternal();
        success = MsgrInitializeMsgrInternal1();

        if (success == NERR_Success)
        {
            success = MsgrInitializeMsgrInternal2();
        }

        if (success != NERR_Success)
        {
            MSG_LOG1(ERROR,
                     "MsgNetEventCompletion: reinit of LANAs failed %d - shutdown\n",
                     success);

            MsgConfigurationLock(MSG_RELEASE, "MsgNetEventCompletion" );
            MsgrUnblockStateChange();
            MsgBeginForcedShutdown(PENDING, success);
            return;
        }

        //
        // Loop again to see if any NCBs completed while we were reinitializing
        //
        do
        {
            ncbComplete = FALSE;

            MSG_LOG0(TRACE,"MsgNetEventCompletion: Loop through all nets to look "
                     "for any complete NCBs\n");
        
            for ( neti = 0; neti < SD_NUMNETS(); neti++ ) {  // For all nets
                ncbComplete |= MsgServeNCBs((DWORD)neti);
                MsgServeNameReqs((DWORD)neti);
            }
        }
        while (ncbComplete);
    }

    MsgConfigurationLock(MSG_RELEASE, "MsgNetEventCompletion" );

    if (!fWaitStatus)
    {
        //
        // Setup for the next request if we were signalled
        // (submit another WorkItem to the Rtl thread pool)
        //

        MSG_LOG0(TRACE,"MsgNetEventCompletion: Setup for next Net Event\n");

        ntStatus = RtlRegisterWait(&g_hNetEvent,            // Work item handle
                                   wakeupEvent,             // Waitable handle
                                   MsgNetEventCompletion,   // Callback
                                   NULL,                    // pContext
                                   INFINITE,                // Timeout
                                   WT_EXECUTEONLYONCE |     // One-shot and potentially lengthy 
                                     WT_EXECUTELONGFUNCTION);

        if (!NT_SUCCESS(ntStatus))
        {
            //
            // If we can't add the work item, then we won't ever listen
            // for these kind of messages again.
            //

            MSG_LOG1(ERROR,"MsgNetEventCompletion: RtlRegisterWait failed %#x\n",
                     ntStatus);
        }
    }

    MsgrUnblockStateChange();

    //
    // This thread has done all that it can do.  So we can return it
    // to the thread pool.
    //

    return;
}


VOID
MsgGrpEventCompletion(
    PVOID       pvContext,         // This passed in as context.
    BOOLEAN     fWaitStatus
    )

/*++

Routine Description:

    This function is called when the mailslot handle for group
    (domain-wide) messages becomes signalled.

Arguments:

    pvContext - not used

    fWaitStatus - TRUE if we're being called because of a timeout.
                  FALSE if we're being called because the waitable
                        event was signalled

Return Value:

    None

--*/
{
    DWORD       msgrState;
    NTSTATUS    ntStatus;

    MSG_LOG0(GROUP,"MsgGroupEventCompletion: entry point\n",);

    //
    // We registered an infinite wait, so we can't have timed
    // out (TRUE indicates a timeout)
    //
    ASSERT(fWaitStatus == FALSE);

    DEREGISTER_WORK_ITEM(g_hGrpEvent);

    msgrState = MsgServeGroupMailslot();
    if (msgrState == STOPPING || msgrState == STOPPED)
    {
        //
        // Close the Mailslot Handle
        //

        CLOSE_HANDLE(GrpMailslotHandle, INVALID_HANDLE_VALUE);

        MSG_LOG0(TRACE,"MsgGroupEventCompletion: No longer listening for "
            "group messages\n");
    }
    else {
        //
        // Read the Group Mailslot
        //

        MsgReadGroupMailslot();

        //
        // Setup for the next request.
        // (submit another WorkItem to the Rtl thread pool.)
        //
        MSG_LOG0(TRACE,"MsgGroupEventCompletion: Setup for next Group Event\n");
        MSG_LOG1(GROUP,"MsgGroupEventCompletion: Mailslot handle to wait on "
            " = 0x%lx\n",GrpMailslotHandle);

        ntStatus = RtlRegisterWait(&g_hGrpEvent,            // Work item handle
                                   GrpMailslotHandle,       // Waitable handle
                                   MsgGrpEventCompletion,   // Callback
                                   NULL,                    // pContext
                                   INFINITE,                // Timeout
                                   WT_EXECUTEONLYONCE);     // One-shot

        if (!NT_SUCCESS(ntStatus)) {
            //
            // If we can't add the work item, then we won't ever listen
            // for these kind of messages again.
            //
            MSG_LOG1(ERROR,"MsgGrpEventCompletion: RtlRegisterWait failed %#x\n",
                     ntStatus);
        }

    }
    //
    // This thread has done all that it can do.  So we can return it
    // to the thread pool.
    //
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgsvcsend_s_stub.c ===
#include "msgsvcsend_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgnbios.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgnbios.c

Abstract:

    This file contains Routines used by the messenger to make netbios
    calls and to obtain the computer and user names.  
    The following functions are included:

        MsgInit_NetBios
        Msgsendncb
        MsgAddUserNames
        MsgAddAlreadyLoggedOnUserNames (HYDRA specific)

    
     NT_NOTE:
    
     We need some way to determine which NCB's have unanswered listens
     pending.  For these, we need to send an NCBCANCEL command via 
     another NetBios call.  The buffer will contain a pointer to the
     listening NCB.  Also, listens that are in the process of being
     serviced must either be hung up, or allowed to complete.
    
     All this is done during the MsgrShutdown.

Author:

    Dan Lafferty (danl)     27-Jun-1991

Environment:

    User Mode -Win32

Notes:

    NetBios3.0 is not a handle-based api.  Therefore, there is no open or
    close associated with it.  In order to shut down properly, the 
    messenger will have to hangup or complete listens that are being
    serviced.   And it will have to send a cancel NCB for each listen 
    that is pending.  

Revision History:

    08-Apr-1994     danl
        MsgAddUserNames: If call to NetWkstaUserEnum failed, this function
        was still attempting to free the buffer that was returned.
        Since no buffer is allocated in a failure case, the free mem
        call in the path is being removed.
    27-Jun-1991     danl
        ported from LM2.0

--*/


#include "msrv.h"

#include "msgdbg.h"     // MSG_LOG

#include <tstring.h>    // Unicode string macros
#include <icanon.h>     // I_NetNameCanonicalize
#include <netlib.h>     // UNUSED macro

#include <lmwksta.h>    // NetWorkstation API prototypes
#include <lmapibuf.h>   // NetApiBufferFree
#include <netdebug.h>   // NetpAssert, FORMAT_ equates.
#include "msgdata.h"
#include "apiutil.h"    // MsgMapNetError

    //
    // Note: we use the internal entrypoints to the apis because this
    // file is shared by the message apis, which cannot call the net
    // bios apis because of different required permissions.
    // 



NET_API_STATUS 
MsgInit_NetBios(
    VOID
    )

/*++

Routine Description:

    This function fills the global array called net_lana_num with the
    lan adapter numbers retrieved from A NetBios Enum call

    NOTE:  This assumes that space for the array is already set up.

    The LM2.0 version of this also filled an array of NetBios Handles.
    In LM2.0, the loopback driver was not included unless it was the only
    network installed.

Arguments:

    none

Return Value:

    TRUE  - No Error.
    FALSE - An error occured.

--*/

{
    DWORD                   count=0;
    NCB                     ncb;
    LANA_ENUM               lanaBuffer;
    unsigned char           i;  
    unsigned char           nbStatus;


    //
    // Find the number of networks by sending an enum request via Netbios.
    // 

    clearncb(&ncb);
    ncb.ncb_command = NCBENUM;          // Enumerate LANA nums (wait)
    ncb.ncb_buffer = (char FAR *)&lanaBuffer;
    ncb.ncb_length = sizeof(LANA_ENUM);

    nbStatus = Netbios(&ncb);

    if (nbStatus != NRC_GOODRET)
    {
        MSG_LOG(ERROR, "Netbios LanaEnum failed rc=%d\n",nbStatus);
        return MsgMapNetError(nbStatus);
    }

    //
    // Move the Adapter Numbers (lana) into the array that will contain them.
    //
    for (i=0; i < lanaBuffer.length; i++)
    {
        MSG_LOG(TRACE,"adapter %d",i);
        MSG_LOG(TRACE,"\b\b\b\b\b\b lananum= %d      \n", lanaBuffer.lana[i]);
        GETNETLANANUM(count) = lanaBuffer.lana[i];
        count++;

        //
        // Internal consistancy check.  Make sure the arrays are only
        // SD_NUMNETS long.
        //
        if (count > SD_NUMNETS())
        {
            MSG_LOG(ERROR,
                    "NumNets from NetBios greater than value from Wksta count=%d\n",
                    count);

            return NERR_WkstaInconsistentState;
        }
    }

    //
    // Internal consistancy check again. We better not have opened
    // more nets than the messenger thinks there are.
    // 

    if (count != SD_NUMNETS())
    {
        return NERR_WkstaInconsistentState;
    }

    return NERR_Success;

}

UCHAR
Msgsendncb(
    PNCB    NCB_ptr,
    DWORD   neti)

/*++

Routine Description:


    This function performs a DosDevIOCtl call to send an NCB to the
    net bios via a previously openned redirector and netbios handle.

Arguments:

    NCB_ptr - Points to the NCB to send to the net bios.
    neti - Network index.  Which netbios to submit it to?


Return Value:


    Error code from Net bios.

--*/
{
    //
    // NOTE:  The new Netbios call doesn't use any handles, so the neti
    //  info is not used.
    //

    UNUSED (neti);
    return (Netbios(NCB_ptr));

#ifdef remove
    return( NetBiosSubmit( NetBios_Hdl[neti], 0, (NCB far *) NCB_ptr));
#endif
}


VOID
MsgAddUserNames(
    VOID
    )

/*++

Routine Description:

   This function used to get it's information about the username and
   computername from the workstation service.  Now, in NT, the username
   is added when the user logs on.  It is not automatically added by the
   messenger.

Arguments:


    CompName - Pointer to buf for computer name. (must be NCBNAMSZ+1)
    CompNameSize - Size in bytes of the buffer to receive the name.

    UserName - Pointer to buffer for user name. (must be UNLEN+1)
    UserNameSize - Size in bytes of the buffer to receive the name.

Return Value:

    NERR_Success - Aways returned. (Names are returned as NUL strings).


--*/

{

    TCHAR               UserName[UNLEN+1];
    DWORD               UserNameSize = sizeof(UserName);
    DWORD               i;
    LPWKSTA_USER_INFO_0 userInfo0;
    DWORD               entriesRead;
    DWORD               totalEntries;
    NET_API_STATUS      status;
    
    *UserName = TEXT('\0');

    status = NetWkstaUserEnum( 
                NULL, 
                0,
                (LPBYTE *)&userInfo0,
                0xffffffff,             // PreferredMaximiumLength
                &entriesRead,
                &totalEntries,
                NULL);                  // resume handle

    if (status != NERR_Success) {
        MSG_LOG(ERROR,"GetWkstaNames:NetWkstaUserEnum FAILURE %X/n",status);
        return;
    }

    for (i=0; i<entriesRead; i++ ) {

        if (entriesRead == 0) {
            //
            // There are no users logged on at the time of this query.
            //
            MSG_LOG(TRACE,
                "GetWkstaNames:NetWkstaUserEnum entriesRead=%d\n",
                entriesRead);
        }
        
        if(userInfo0[i].wkui0_username != NULL) {
            status = I_NetNameCanonicalize(
                        NULL,
                        userInfo0[i].wkui0_username,
                        UserName,
                        UserNameSize,
                        NAMETYPE_USER,
                        0);
            if (status != NERR_Success) {
                MSG_LOG(ERROR,"I_NetNameCanonicalize failed %X\n",status);
            }
        }
                
        if( *UserName != TEXT('\0')) {        // Set up in GetWkstaNames */
            MSG_LOG(TRACE, "Calling MsgAddName\n",0);

            status = MsgAddName(UserName,0);

            if (status != NERR_Success) {
                MSG_LOG(
                    TRACE,
                    "MsgAddUserNames,MessageAddName FAILURE " FORMAT_API_STATUS
                    "\n",
                    status);
            }
        }
    }
    NetApiBufferFree(userInfo0);
}


VOID
MsgAddAlreadyLoggedOnUserNames(
    VOID
    )

/*++

Routine Description:

   This function is used to get information about the previously logged on usernames
   by calling WinStationEnumerate and WinStationQueryInformationW, instead of NetWkstaUserEnum.
   (same job as MsgAddUserNames, adapted for multi-user)

  Note: It could (should ?) be located elsewhere than in msgnbios. I kept it here just because
        MsgAddUserName itself was already here. (NicolasBD)

Arguments:

Return Value:

    NERR_Success - Always returned. 


--*/

{

    TCHAR               UserName[NCBNAMSZ+1];
    DWORD               UserNameSize = sizeof(UserName);
    UINT WdCount, i;
    PLOGONID pWd, pWdTmp;
    ULONG AmountRet;
    WINSTATIONINFORMATIONW QueryBuffer;
    NET_API_STATUS      status;
    
    *UserName = TEXT('\0');

    // Enumerate the Sessions

    if ( gpfnWinStationEnumerate( SERVERNAME_CURRENT, &pWd, &WdCount ) ) 
    {
        // Success; get all the previously logged on user names and session ids

        pWdTmp = pWd;
        for( i=0; i < WdCount; i++ ) {

            if( ((pWdTmp->State == State_Connected) ||
                 (pWdTmp->State == State_Active) ||
                 (pWdTmp->State == State_Disconnected)))
            {
                if( !gpfnWinStationQueryInformation( SERVERNAME_CURRENT,
                                                     pWdTmp->LogonId,
                                                      WinStationInformation,
                                                      &QueryBuffer,
                                                      sizeof(QueryBuffer),
                                                      &AmountRet ) )
                {
                    // Error
                    MSG_LOG(ERROR, "MsgAddAlreadyLoggedOnUserNames: Error in QueryInfo %d\n",GetLastError());
                }
                else
                {
                    if (QueryBuffer.UserName != NULL) 
                    {
                        MSG_LOG(TRACE,"MsgAddAlreadyLoggedOnUserNames: calling I_NetNameCanonicalize for %ws\n",QueryBuffer.UserName);

                        status = I_NetNameCanonicalize(
                                    NULL,
                                    QueryBuffer.UserName,
                                    UserName,
                                    UserNameSize,
                                    NAMETYPE_USER,
                                    0);
                        if (status != NERR_Success) 
                        {
                            MSG_LOG(ERROR,"I_NetNameCanonicalize failed %X\n",status);
                        }
                    }
                
                    if( *UserName != TEXT('\0')) 
                    {   
	                    MSG_LOG(TRACE,"MsgAddAlreadyLoggedOnUserNames: Calling MsgAddName for Session %x \n", pWdTmp->LogonId);
                        status = MsgAddName(UserName, pWdTmp->LogonId);

                        if (status != NERR_Success) 
                        {
                            MSG_LOG(TRACE, "MsgAddAlreadyLoggedOnUserNames,MessageAddName FAILURE " FORMAT_API_STATUS "\n", status);
                        }
                    }
                }
            }

            pWdTmp++;
        }

        // Free enumeration memory

        gpfnWinStationFreeMemory(pWd);

    }
    else
    {
        MSG_LOG (ERROR, "MsgAddAlreadyLoggedOnUserNames: WinStationEnumerate failed, error = %d:\n",GetLastError());
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msgsvc_s_stub.c ===
#include "msgsvc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\msrv.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

#ifndef _MSRV_INCLUDED
#define _MSRV_INCLUDED

#include <nt.h>         // for ntrtl.h
#include <ntrtl.h>      // DbgPrint prototypes
#include <nturtl.h>     // needed for windows.h when I have nt.h
#define WINMM_H
#include <windows.h>    // ExitThread prototype
#include <lmcons.h>
#include <lmerr.h>
#include <nb30.h>       // NetBios Prototypes and constants
#include <winsta.h>     // Winstation functions (for HYDRA)
#include "heap.h"

#ifdef  LINT
#define near
#define far
#define void    int
#endif  // LINT


#define clearncb(x)     memset((char *)x,'\0',sizeof(NCB))
#define clearncbf(x)    memsetf((char far *)x,'\0',sizeof(NCB))

#define so_to_far(seg, off) \
    ((((long)(unsigned)(seg)) << 16) + (unsigned)(off))

//
// Constant definitions
//

#define BUFLEN          200         // Length of NCB_BUF
#define LOGNAMLEN       PATHLEN     // Log file name length (max)
#define TXTMAX          128         // Maximum bytes of text per block
#define MAXHEAD         80          // Maximum message header length
#define MAXEND          60          // Maximum message end length
#define MAXGRPMSGLEN    128         // Max domain message length

#define MAX_SIZMESSBUF  62000       // The max size for the message buffer
#define MIN_SIZMESSBUF  512         // The min size for the message buffer
#define MSNGR_MAX_NETS  MAX_LANA    // The maximum number of nets the messenger
                                    // can handle. (Currently 12)

#define TIME_BUF_SIZE   128         // Size of the buffer to hold the message time

#define MSGFILENAMLEN   PATHLEN*sizeof(TCHAR)

//
// Messaging name end bytes
//
#define NAME_LOCAL_END  '\003'      // 16th byte in local NCB name
#define NAME_REMOTE_END '\005'      // 16th byte in remote NCB name

//
// Messenger Thread Manager States (used as return codes)
//

#define UPDATE_ONLY         0   // no change in state - just send current status.
#define STARTING            1   // the messenger is initializing.
#define RUNNING             2   // initialization completed normally - now running
#define STOPPING            3   // uninstall pending
#define STOPPED             4   // uninstalled

//
// Forced Shutdown PendingCodes
//
#define PENDING     TRUE
#define IMMEDIATE   FALSE

//
// Message transfer states
//
#define MESSTART        0           // Message start state
#define MESSTOP         1           // Message stop state
#define MESCONT         2           // Message continued state
#define MESERR          3           // Message error state


//
// Alert Size
//
#define ALERT_MAX_DISPLAYED_MSG_SIZE    4096

//
//  Special Session Id = -1 (used to indicate that the message has to be broadcasted to every session)
//

#define EVERYBODY_SESSION_ID    -1

// Structure definitions

//
// ncb worker function type
//
typedef VOID (*PNCBIFCN) (
    DWORD   NetIndex,   // Network Index
    DWORD   NcbIndex,   // Network Control Block Index
    CHAR    RetVal      // value returned by net bios
    );

typedef PNCBIFCN LPNCBIFCN;

typedef struct _NCB_STATUS {
    int             this_immediate;
    int             last_immediate;
    unsigned char   this_final;
    unsigned char   last_final;
    unsigned char   rep_count;
    unsigned char   align;      // *ALIGNMENT*
}NCB_STATUS, *PNCB_STATUS, *LPNCB_STATUS;

// structure used for keeping the session id list for each alias
typedef struct _MSG_SESSION_ID_ITEM
{
	LIST_ENTRY	List;
	ULONG	SessionId;        
}	
 MSG_SESSION_ID_ITEM, *PMSG_SESSION_ID_ITEM;

// Per NCB Information
typedef struct _NCB_DATA {
    DWORD MsgPtr;
    LPNCBIFCN IFunc;
    NCB_STATUS Status;
    NCB   Ncb;   // Structure passed to Netbios
    CHAR Buffer[BUFLEN];
    CHAR Name[NCBNAMSZ + 4];
    CHAR Fname[NCBNAMSZ + 4];
    SHORT mgid;
    CHAR State;
    UCHAR NameFlags;
    UCHAR NameNum;
    LIST_ENTRY SessionList;
    UCHAR Pad[3];
} NCB_DATA, *PNCB_DATA;

// Per Network Information
typedef struct _NET_DATA {
    ULONG NumNcbs;
    PNCB_DATA *NcbList;
    UCHAR net_lana_num;
    UCHAR Pad[3];
} NET_DATA, *PNET_DATA;

// Global Information
typedef struct _GLOBAL_DATA
{
    ULONG NumNets;
    DWORD StartFlags;
    DWORD LogStatus;
    DWORD BufSize;
    DWORD MsgQueueF;
    DWORD MsgQueueB;
    PNET_DATA NetData;
    CHAR LogFileName[LOGNAMLEN];
    PCHAR Buffer;
} GLOBAL_DATA, *PGLOBAL_DATA;

extern GLOBAL_DATA GlobalData;

#define NCB_INIT_ENTRIES 16  // Initial number of NCB allocated per network

// For Multi-user systems, we allow up to 256 NCBs per network
#define NCB_MAX_ENTRIES 256  // Maximum number of NCBs per network
#define SESSION_MAX 256

//
// Name Flag definitions
//
#define NFNEW          0x01        // New name
#define NFDEL          0x02        // Name deleted
#define NFFOR          0x04        // Messages forwarded
#define NFFWDNAME      0x10        // Forward-name
#define NFMACHNAME     0x20        // Machine name (undeletable)
#define NFLOCK         0x40        // Name entry locked
#define NFDEL_PENDING  0x80        // Delete name issued but not complete*/

//
// Memory area names
//
#define    DATAMEM        "\\SHAREMEM\\MSRV.DAT"
#define    INITMEM        "\\SHAREMEM\\MSRVINIT.DAT"

//
// System semaphore definitions
//
#define WAKEUP_SEM    "\\SEM\\MSRVWU"
#define WAKEUPSEM_LEN    13        // The number of characters in WAKEUP_SEM +2


//
// The messenger mailslot for domain messaging
//
#ifdef remove
#define MESSNGR_MS_NAME     "\\mailslot\\messngr"
#define MESSNGR_MS_NAME_LEN    17
#endif

#define MESSNGR_MS_NAME     "\\\\.\\mailslot\\messngr"
#define MESSNGR_MS_NAME_LEN    20


//
// The character used to separate the components of a domain message
//
#define SEPCHAR     "\6"


//
// Memory allocator flags
//
// #define MEMMOVE     0x0002        // Movable memory flag
// #define MEMWRIT     0x0080        // Writable memory flag


//
// Structure and macro definitions
//

#ifdef    INULL                // If heap structures defined

//
// Single-block message header
//
typedef struct {
    HEAPHDR         sbm_hp;         // Heap block header
    unsigned short  sbm_next;       // Link to next message
    unsigned short  align;          // *ALIGNMENT*
    SYSTEMTIME      sbm_bigtime;    // Date and time of message
}SBM;

#define SBM_SIZE(x)     HP_SIZE((x).sbm_hp)
#define SBM_CODE(x)     HP_FLAG((x).sbm_hp)
#define SBM_NEXT(x)     (x).sbm_next
#define SBM_BIGTIME(x)  (x).sbm_bigtime
#define SBMPTR(x)       ((SBM far *) &heap[(x)])

//
// Multi-block message header
//
typedef struct {
    HEAPHDR         mbb_hp;         // Heap block header
    DWORD           mbb_next;       // Link to next message
    SYSTEMTIME      mbb_bigtime;    // Date of message
    DWORD           mbb_btext;      // Link to last text block
    DWORD           mbb_ftext;      // Link to first text block
    DWORD           mbb_state;      // State flag
}MBB;


#define MBB_SIZE(x)     HP_SIZE((x).mbb_hp)
#define MBB_CODE(x)     HP_FLAG((x).mbb_hp)
#define MBB_NEXT(x)     (x).mbb_next
#define MBB_BIGTIME(x)  (x).mbb_bigtime
#define MBB_BTEXT(x)    (x).mbb_btext
#define MBB_FTEXT(x)    (x).mbb_ftext
#define MBB_STATE(x)    (x).mbb_state
#define MBBPTR(x)       ((MBB far *) &heap[(x)])

//
// Multi-block message text
//
typedef struct {
    HEAPHDR             mbt_hp;         // Heap block header
    DWORD               mbt_next;       // Link to next block (offset)
    DWORD               mbt_bytecount;  // *ALIGNMENT2*
}MBT, *PMBT, *LPMBT;

#define MBT_SIZE(x)     HP_SIZE((x).mbt_hp)
#define MBT_CODE(x)     HP_FLAG((x).mbt_hp)
#define MBT_NEXT(x)     (x).mbt_next
#define MBT_COUNT(x)    (x).mbt_bytecount       // *ALIGNMENT2*
#define MBTPTR(x)       ((LPMBT) &heap[(x)])

#endif    // INULL  -  End heap access macros

//
// A one session/name status structure
//
typedef struct _MSG_SESSION_STATUS{
    SESSION_HEADER  SessHead;
    SESSION_BUFFER  SessBuffer[SESSION_MAX];
}MSG_SESSION_STATUS, *PMSG_SESSION_STATUS, *LPMSG_SESSION_STATUS;


//
// Shared data access macros
//
#define GETNCBDATA(n, x)    GlobalData.NetData[(n)].NcbList[(x)]
#define GETNCB(n, x)        &GlobalData.NetData[(n)].NcbList[(x)]->Ncb
#define GETNETLANANUM(n)    GlobalData.NetData[(n)].net_lana_num
#define NETLANANUM          GETNETLANANUM
#define GETNETDATA(n)       &GlobalData.NetData[(n)]
#define SD_NUMNETS()        GlobalData.NumNets
#define SD_MSRV()           GlobalData.StartFlags
#define SD_NAMEFLAGS(n, x)  GlobalData.NetData[(n)].NcbList[(x)]->NameFlags
#define SD_NAMENUMS(n, x)   GlobalData.NetData[(n)].NcbList[(x)]->NameNum
#define SD_NAMES(n, x)      GlobalData.NetData[(n)].NcbList[(x)]->Name
#define SD_FWDNAMES(n, x)   GlobalData.NetData[(n)].NcbList[(x)]->Fname
#define SD_LOGNAM()         GlobalData.LogFileName
#define SD_BUFLEN()         GlobalData.BufSize
#define SD_MESLOG()         GlobalData.LogStatus
#define SD_MESQF()          GlobalData.MsgQueueF
#define SD_MESQB()          GlobalData.MsgQueueB
#define SD_MESPTR(n, x)     GlobalData.NetData[(n)].NcbList[(x)]->MsgPtr
#define SD_BUFFER()         GlobalData.Buffer
#define SD_SIDLIST(n,x)     GlobalData.NetData[(n)].NcbList[(x)]->SessionList
#define NCBMAX(n)           GlobalData.NetData[(n)].NumNcbs


NCB_STATUS  ncb_status;


#define SIG_IGNORE  1
#define SIG_ACCEPT  2
#define SIG_ERROR   3
#define SIG_RESET   4

//
// g_install_state bit definitions
//
//#define IS_EXECED_MAIN  0x0001
//#define IS_ALLOC_SEG    0x0002

//
// Timeout for waiting for the shared segment before giving up
// and reporting an internal error.
//
//#define MSG_SEM_TO      60000L      // 60 second timeout

//
// No. of repeated consectutive NCB errors required to abort the
// message server.
//

#define SHUTDOWN_THRESHOLD  10

// net send timeout and retry constatnts
#define MAX_CALL_RETRY      5       // Retry a failed send up to 5 times
#define CALL_RETRY_TIMEOUT  1       // second delay between retries

//
// Database Lock requests for the MsgDatabaseLock function.
//
typedef enum    _MSG_LOCK_REQUEST
{
    MSG_INITIALIZE,
    MSG_GET_SHARED,
    MSG_GET_EXCLUSIVE,
    MSG_RELEASE
}
MSG_LOCK_REQUEST, *PMSG_LOCK_REQUEST, *LPMSG_LOCK_REQUEST;

//
// Macros to deregister a thread pool item and close
// a handle once and only once
//

#define DEREGISTER_WORK_ITEM(g_hWorkItem) \
            { \
                HANDLE  hTemp = InterlockedExchangePointer(&g_hWorkItem, NULL); \
              \
                if (hTemp != NULL) \
                { \
                    NTSTATUS Status = RtlDeregisterWait(hTemp); \
                  \
                    if (!NT_SUCCESS(Status)) \
                    { \
                        MSG_LOG2(ERROR, \
                                 "RtlDeregisterWait on %p failed %x\n", \
                                 hTemp, \
                                 Status); \
                    } \
                } \
            }

#define CLOSE_HANDLE(HandleToClose, InvalidHandleValue) \
            { \
                HANDLE  hTemp = InterlockedExchangePointer(&HandleToClose, InvalidHandleValue); \
              \
                if (hTemp != InvalidHandleValue) \
                { \
                    CloseHandle(hTemp); \
                } \
            }


//
//  global variables
//

extern BOOL      g_IsTerminalServer;

// WinStationQueryInformationW

typedef BOOLEAN (*PWINSTATION_QUERY_INFORMATION) (
                    HANDLE hServer,
                    ULONG SessionId,
                    WINSTATIONINFOCLASS WinStationInformationClass,
                    PVOID  pWinStationInformation,
                    ULONG WinStationInformationLength,
                    PULONG  pReturnLength
                    );

extern PWINSTATION_QUERY_INFORMATION gpfnWinStationQueryInformation;

// WinStationSendMessageW

typedef BOOLEAN (*PWINSTATION_SEND_MESSAGE) (
                    HANDLE hServer,
                    ULONG SessionId,
                    LPWSTR  pTitle,
                    ULONG TitleLength,
                    LPWSTR  pMessage,
                    ULONG MessageLength,
                    ULONG Style,
                    ULONG Timeout,
                    PULONG pResponse,
                    BOOLEAN DoNotWait
                    );
extern PWINSTATION_SEND_MESSAGE gpfnWinStationSendMessage;

// WinStationFreeMemory

typedef BOOLEAN (*PWINSTATION_FREE_MEMORY) (
                    PVOID   pBuffer
                    );
extern PWINSTATION_FREE_MEMORY gpfnWinStationFreeMemory;


// WinStationEnumerateW

typedef BOOLEAN (*PWINSTATION_ENUMERATE) (
                    HANDLE  hServer,
                    PLOGONIDW *ppLogonId,
                    PULONG  pEntries
                    );
extern PWINSTATION_ENUMERATE gpfnWinStationEnumerate;


//
// Function Prototypes
//


DWORD
GetMsgrState(
    VOID
    );

VOID
MsgrBlockStateChange(
    VOID
    );

VOID
MsgrUnblockStateChange(
    VOID
    );

NET_API_STATUS
MsgAddName(
    LPTSTR  Name,
    ULONG   SessionId
    );

VOID
MsgAddUserNames(
    VOID
    );

VOID
MsgAddAlreadyLoggedOnUserNames(
    VOID
    );

DWORD
MsgBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    ExitCode
    );

BOOL
MsgDatabaseLock(
    IN MSG_LOCK_REQUEST request,
    IN LPSTR            idString
    );

BOOL
MsgConfigurationLock(
    IN MSG_LOCK_REQUEST request,
    IN LPSTR            idString
    );

NTSTATUS
MsgInitCriticalSection(
    PRTL_CRITICAL_SECTION  pCritsec
    );

NTSTATUS
MsgInitResource(
    PRTL_RESOURCE  pResource
    );

DWORD
MsgDisplayInit(
    VOID
    );

BOOL
MsgDisplayQueueAdd(
    IN  LPSTR        pMsgBuffer,
    IN  DWORD        MsgSize,
    IN  ULONG        SessionId,
    IN  SYSTEMTIME   BigTime
    );

VOID
MsgDisplayThreadWakeup(
    VOID
    );

VOID
MsgDisplayEnd(
    VOID
    );

NET_API_STATUS
MsgErrorLogWrite(
    IN  DWORD   Code,
    IN  LPTSTR  Component,
    IN  LPBYTE  Buffer,
    IN  DWORD   BufferSize,
    IN  LPSTR   Strings,
    IN  DWORD   NumStrings
    );

NET_API_STATUS
MsgInitializeMsgr(
    IN  DWORD   argc,
    IN  LPTSTR  *argv
    );

NET_API_STATUS
MsgrInitializeMsgrInternal1(
    void
    );

NET_API_STATUS
MsgrInitializeMsgrInternal2(
    void
    );

NET_API_STATUS
MsgNewName(
    IN DWORD    neti,
    IN DWORD    ncbi
    );

VOID
MsgrShutdown(
    );

VOID
MsgThreadWakeup(
    VOID
    );

VOID
MsgStatusInit(
    VOID
    );

DWORD
MsgStatusUpdate(
    IN DWORD    NewState
    );

VOID
MsgThreadCloseAll(
    VOID
    );

DWORD
MsgThreadManagerInit(
    VOID
    );

NET_API_STATUS
MsgInit_NetBios(
    VOID
    );

BOOL
MsgServeNCBs(
    DWORD   net         // Which network am I serving?
    );

VOID
MsgServeNameReqs(
    IN DWORD    net
    );

VOID
MsgReadGroupMailslot(
    VOID
    );

NET_API_STATUS
MsgServeGroupMailslot(
    VOID
    );

NET_API_STATUS
MsgFmtNcbName(
    OUT PCHAR   DestBuf,
    IN  LPTSTR  Name,
    IN  DWORD   Type);

DWORD
Msghdrprint(
    int          action,         // Where to log the header to.
    LPSTR        from,           // Name of sender
    LPSTR        to,             // Name of recipient
    SYSTEMTIME   bigtime,        // Bigtime of message
    HANDLE  file_handle     // Output file handle*/
    );

DWORD
Msglogmbb(
    LPSTR   from,       // Name of sender
    LPSTR   to,         // Name of recipient
    DWORD   net,        // Which network ?
    DWORD   ncbi        // Network Control Block index
    );

UCHAR
Msglogmbe(
    DWORD   state,      // Final state of message
    DWORD   net,        // Which network?
    DWORD   ncbi        // Network Control Block index
    );

DWORD
Msglogmbt(
    LPSTR   text,       // Text of message
    DWORD   net,        // Which network?
    DWORD   ncbi        // Network Control Block index
    );

DWORD
Msglogsbm(
    LPSTR   from,       // Name of sender
    LPSTR   to,         // Name of recipient
    LPSTR   text,       // Text of message
    ULONG   SessionId   // Session Id
   );

VOID
Msgmbmfree(
    DWORD   mesi
    );

DWORD
Msgmbmprint(
    int     action,
    DWORD   mesi,
    HANDLE  file_handle,
    LPDWORD pdwAlertFlag
    );

DWORD
MsgrCtrlHandler(
    IN DWORD    dwControl,
    IN DWORD    dwEventType,
    IN LPVOID   lpEventData,
    IN LPVOID   lpContext
    );

DWORD
Msgopen_append(
    LPSTR       file_name,          // Name of file to open
    PHANDLE     file_handle_ptr    // pointer to storage for file handle
    );

UCHAR
Msgsendncb(
    PNCB    NcbPtr,
    DWORD   neti
    );

int
Msgsmbcheck(
    LPBYTE  buffer,
    USHORT  size,
    UCHAR   func,
    int     parms,
    LPSTR   fields
    );

NET_API_STATUS
MsgStartListen(
    DWORD   net,
    DWORD   ncbi
    );

DWORD
Msgtxtprint(
    int     action,         // Alert, File, or Alert and file
    LPSTR   text,           // Pointer to text
    DWORD   length,         // Length of text
    HANDLE  file_handle     // Log file handle
    );

NET_API_STATUS
MsgInitSupportSeg(
    VOID
    );

VOID
MsgFreeSupportSeg(
    VOID
    );

VOID
MsgFreeSharedData(
    VOID
    );

BOOL
MsgCreateWakeupSems(
    DWORD   NumNets
    );

BOOL
MsgCreateWakeupEvent(
    void
    );

VOID
MsgCloseWakeupSems(
    VOID
    );

VOID
MsgCloseWakeupEvent(
    VOID
    );

NET_API_STATUS
MsgInitGroupSupport(
    DWORD iGrpMailslotWakeupSem
    );

VOID
MsgGrpThreadShutdown(
    VOID
    );

DWORD
MsgGetNumNets(
    VOID
    );

NET_API_STATUS
MultiUserInitMessage(
    VOID
    );

VOID
MsgArrivalBeep(
    ULONG SessionId
    );

INT
DisplayMessage(
    LPWSTR pMessage,
    LPWSTR pTitle,
    ULONG SessionId
    );

NET_API_STATUS
MsgGetClientSessionId(
    OUT PULONG pSessionId
    );

VOID
MsgNetEventCompletion(
    PVOID       pvContext,      // This passed in as context.
    BOOLEAN     fWaitStatus
    );

#endif // MSRV_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\sighandl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sighandl.c

Abstract:

    The Messenger Service ControlHandling routines.  This file contains
    the following functions:

        MsgrCtrlHandler
        uninstall

Author:

    Dan Lafferty (danl)     17-Jul-1991

Environment:

    User Mode -Win32

Revision History:

    17-Jul-1991     danl
        Ported from LM2.0

--*/

//
// Includes
// 

#include "msrv.h"       // Message server declarations
#include <winsvc.h>     // SERVICE_STOP
#include <dbt.h>        // DBT_DEVICEARRIVAL, DBT_DEVICEREMOVECOMPLETE

#include <netlib.h>     // UNUSED macro
#include <msgdbg.h>     // MSG_LOG
#include "msgdata.h"       



DWORD
MsgrCtrlHandler(
    IN DWORD    dwControl,
    IN DWORD    dwEventType,
    IN LPVOID   lpEventData,
    IN LPVOID   lpContext
    )

/*++

Routine Description:

    This function receives control requests that come in from the 
    Service Controller

Arguments:

    dwControl   - This is the control code.
    dwEventType - In the case of a PnP control, the PNP event that occurred
    lpEventData - Event-specific data for PnP controls
    lpContext   - Context data

Return Value:



--*/

{
    DWORD          dwRetVal = NO_ERROR;
    static HANDLE  s_hNeverSetEvent;

    MSG_LOG(TRACE,"Control Request Received\n",0);

    switch (dwControl) {
    case SERVICE_CONTROL_SHUTDOWN:

        MSG_LOG(TRACE,"Control Request = SHUTDOWN\n",0);

        // Fall through

    case SERVICE_CONTROL_STOP:

        MSG_LOG(TRACE,"Control Request = STOP\n",0);

        //
        // Start the de-installation.  This call includes the sending of
        // the new status to the Service Controller.
        //

        //
        // Update the Service Status to the pending state.  And wake up
        // the display thread (if running) so it will read it.
        //

        MsgStatusUpdate (STOPPING);

        if (s_hNeverSetEvent != NULL)
        {
            CloseHandle(s_hNeverSetEvent);
            s_hNeverSetEvent = NULL;
        }
        

        //
        //  In Hydra case, the display thread never goes asleep.
        //

        if (!g_IsTerminalServer)
        {
            MsgDisplayThreadWakeup();
        }

        SetEvent( wakeupEvent );
        break;

    case SERVICE_CONTROL_INTERROGATE:
        MSG_LOG(TRACE,"Control Request = INTERROGATE\n",0);
        MsgStatusUpdate (UPDATE_ONLY);
        break;

    case SERVICE_CONTROL_DEVICEEVENT:
        MSG_LOG(TRACE,"Control Request = DEVICEEVENT\n",0);
        
        if (dwEventType == DBT_DEVICEARRIVAL
             ||
            dwEventType == DBT_DEVICEREMOVECOMPLETE)
        {
            NTSTATUS   ntStatus;

            if (s_hNeverSetEvent == NULL)
            {
                s_hNeverSetEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

                if (s_hNeverSetEvent == NULL)
                {
                    MsgStatusUpdate(UPDATE_ONLY);
                    break;
                }
            }

            //
            // Assert that we're only getting the notifications we requested.
            // If this fails, we'll do an extra rescan of the LANAs but find
            // no changes and therefore do no extra work past that.
            //
            ASSERT(lpEventData
                    &&
                   ((PDEV_BROADCAST_DEVICEINTERFACE) lpEventData)->dbcc_devicetype
                        == DBT_DEVTYP_DEVICEINTERFACE);

            MSG_LOG1(TRACE,"    Device has been %s\n",
                     (dwEventType == DBT_DEVICEARRIVAL ? "added" : "removed"));

            //
            // We're currently waiting on LAN adapter install/removal, which does
            // not directly coincide with NetBios binding/unbinding.  We need to
            // wait about 5 seconds to allow NetBios itself to process the event.
            // Don't do this synchronously or else sleep/hibernate takes 5 seconds
            // per LAN adapter to occur.
            //

            if (g_hNetTimeoutEvent == NULL)
            {
                ntStatus = RtlRegisterWait(&g_hNetTimeoutEvent,        // Work item handle
                                           s_hNeverSetEvent,           // Waitable handle
                                           MsgNetEventCompletion,      // Callback
                                           NULL,                       // pContext
                                           5000,                       // Timeout
                                           WT_EXECUTEONLYONCE |        // One-shot and potentially lengthy
                                             WT_EXECUTELONGFUNCTION);

                if (!NT_SUCCESS(ntStatus))
                {
                    MSG_LOG1(ERROR,
                             "MsgrCtrlHandler:  RtlRegisterWait failed %x\n",
                             ntStatus);

                    //
                    // Asynchronous failed -- do it synchronously
                    //

                    Sleep(5000);
                    SetEvent(wakeupEvent);
                }
            }
        }

        //
        // As long as we're here...
        //
        MsgStatusUpdate (UPDATE_ONLY);
        break;

    default:
        MSG_LOG(TRACE,"Control Request = OTHER (%#x)!!!\n", dwControl);
        ASSERT(FALSE);
        dwRetVal = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\servencb.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    servencb.c

Abstract:

    Routines to service completed NCB's.  This file contains the following
    functions:

        MsgCallNetBios
        MsgDeleteName
        MsgGetMachineName
        MsgHangupService
        MsgListenService
        Msgmblockbeg
        Msgmblockend
        Msgmblocktxt
        MsgNetBiosError
        MsgRecBcastService
        MsgReceiveService
        MsgRestart
        Msgsblockmes
        MsgSendAck
        MsgSendService
        MsgServeNCBs
        MsgSesFullService
        MsgStartListen
        MsgStartRecBcast
        MsgVerifySmb

Author:

    Dan Lafferty (danl)     15-Jul-1991

Environment:

    User Mode -Win32

Revision History:

    19-Aug-1997     wlees
        Add PNP support for lana's

    27-Jul-1994     danl
        MsgServeNCBs:  This function now returns FALSE when the service
        is to shut down.

    29-May-1992     danl
        MsgListenService:  reset the NRC_NORES error count when a good
        return code accompanies the Listen completion.

    18-Feb-1992     ritaw
        Convert to Win32 service control APIs.

    15-Jul-1991     danl
        Ported from LM2.0

--*/

//
// SMB translation
//
//
//  OLD            NEW
//  SMB            SMB_HEADER or PSMB_HEADER
//  --------       -------------------------
//  smb_idf        Protocol
//  smb_com        Command
//  smb_rcls       ErrorClass
//  smb_reh        Reserved
//  smb_err        Error
//  smb_flg        Flags
//  smb_flag2      Flags2
//  smb_res        Reserved2
//  smb_gid        Tid
//  smb_tid        Pid
//  smb_pid        Uid
//  smb_uid        Mid
//  smb_mid        Kludge

//
// Includes
//

#include "msrv.h"

#include <tstring.h>    // Unicode string macros
#include <string.h>     // memcpy
#include <netdebug.h>   // NetpAssert
#include <lmerrlog.h>   // NELOG_ messages

#include <netlib.h>     // UNUSED macro
#include <smbtypes.h>   // needed for smb.h
#include <smb.h>        // Server Message Block definitions
#include <smbgtpt.h>    // SMB field manipulation macros
//#include <msgrutil.h>   // NetpNetBiosReset
#include <nb30.h>       // NRC_GOODRET, ASYNC

#include "msgdbg.h"     // MSG_LOG
#include "heap.h"
#include "msgdata.h"
#include "apiutil.h"    // MsgMapNetError


#define MAX_RETRIES     10

//
//  Local Functions
//

STATIC NET_API_STATUS
MsgCallNetBios(
    DWORD   net,
    PNCB    ncb,
    DWORD   ncbi
    );

STATIC VOID
MsgDeleteName(
    DWORD   net,
    DWORD   ncbi
    );

STATIC VOID
MsgGetMachineName(
    DWORD   net,
    DWORD   ncbi
    );

STATIC VOID
MsgHangupService(
    DWORD   net,
    DWORD   ncbi,
    CHAR    retval
    );

STATIC VOID
MsgListenService(
    DWORD   net,
    DWORD   ncbi,
    CHAR    retval
    );

STATIC VOID
Msgmblockbeg(
    DWORD   net,
    DWORD   ncbi
    );

STATIC VOID
Msgmblockend(
    DWORD   net,
    DWORD   ncbi
    );

STATIC VOID
Msgmblocktxt(
    DWORD   net,
    DWORD   ncbi
    );

STATIC DWORD
MsgNetBiosError(
    DWORD   net,
    PNCB    ncb,
    char    retval,
    DWORD   ncbi
    );


STATIC VOID
MsgReceiveService(
    DWORD   net,
    DWORD   ncbi,
    char    retval
    );

STATIC VOID
MsgRestart(
    DWORD   net,
    DWORD   ncbi
    );

STATIC VOID
Msgsblockmes(
    DWORD   net,
    DWORD   ncbi
    );

STATIC VOID
MsgSendAck(
    DWORD   net,
    DWORD   ncbi,
    UCHAR   smbrclass,
    USHORT  smbrcode
    );

STATIC VOID
MsgSendService(
    DWORD   net,
    DWORD   ncbi,
    CHAR    retval
    );

STATIC VOID
MsgSesFullService(
    DWORD   net,
    DWORD   ncbi,
    char    retval
    );


STATIC int
MsgVerifySmb(
    DWORD   net,
    DWORD   ncbi,
    UCHAR   func,
    int     parms,
    char    *buffers
    );


#if DBG

VOID
MsgDumpNcb(
    IN PNCB     pNcb
    );

#endif //DBG


/*
 *  MsgCallNetBios - issue a net bios call
 *
 *  This function issues a net bios call and calls the
 *  error handler if that call results in an error.
 *
 *  MsgCallNetBios (net, ncb, ncbi)
 *
 *  ENTRY
 *    net    - network index
 *    ncb    - pointer to a Network Control Block
 *    ncbi    - index of ncb in ncb array
 *
 *  RETURN
 *    state of the Messenger:  Either RUNNING or STOPPING.
 *
 *  SIDE EFFECTS
 *
 *  Calls NetBios() to actually issue the net bios call.
 *  Calls MsgNetBiosError() if there is an error.
 */

STATIC NET_API_STATUS
MsgCallNetBios(
    DWORD   net,        // Which network?
    PNCB    ncb,        // Pointer to Network Control Block
    DWORD   ncbi
    )
{
    int     retval;
    PNCB_DATA pNcbData;

    retval = Msgsendncb(ncb, net);

    pNcbData = GETNCBDATA(net,ncbi);
    if (retval == NRC_GOODRET)  {

        //
        // Clear err on success
        //
        pNcbData->Status.last_immediate = 0;
        pNcbData->Status.this_immediate = 0;
    }
    else {
        //
        // NEW (11-4-91):
        // --------------
        // It is ok to get a Session Closed error if the state is STOP.
        //
        if ( (pNcbData->State == MESSTOP) &&
             (retval == NRC_SCLOSED) ) {

            MSG_LOG(TRACE,"CallNetBios: At end of msg, Session is closed for NET %d\n",
                net);
            pNcbData->Status.last_immediate = 0;
            pNcbData->Status.this_immediate = 0;
        }
        else {
            //
            // Else mark error
            //
            pNcbData->Status.this_immediate = retval;
            //
            // Call the error handler if err
            //
            MSG_LOG(TRACE,"CallNetBios: net bios call failed 0x%x\n",retval);
            MsgNetBiosError(net,ncb,(char)retval,ncbi);
            return(MsgMapNetError((UCHAR)retval));
        }
        //
        // Make sure the event for this thread is in the signaled state
        // so that we can wake up and properly handle the error.
        //
        if (SetEvent(ncb->ncb_event) != TRUE) {
            MSG_LOG(ERROR,"CallNetBios: SetEvent Failed\n",0);
        }
    }
    return(NERR_Success);
}

/*
 *  MsgDeleteName - Delete a name from the Message Server's name table
 *
 *  This function is called when a LISTEN, a RECEIVE BROADCAST DATAGRAM,
 *  or a RECEIVE ANY completes with the error code specifying that the
 *  name in question has been deleted.  This function marks the appropriate
 *  entry in the flag table in the shared data area and sets the NCB_CPLT
 *  field of the appropriate NCB to 0xFF (so that FindCompletedNCB() will
 *  never find it).
 *
 *  MsgDeleteName (net, ncbi)
 *
 *  ENTRY
 *    net    - network index
 *    ncbi    - Network Control Block index
 *
 *  RETURN
 *    nothing
 *
 *  SIDE EFFECTS
 *
 *  Modifies an NCB and the shared data area.
 */

STATIC VOID
MsgDeleteName(
    DWORD   net,        // Which network?
    DWORD   ncbi        // Network Control Block index
    )
{
    NCB             ncb;
    PNCB            pNcb;
    NET_API_STATUS  status;

    MSG_LOG(TRACE,"In MsgDeleteName %d\n",net);

    if( SD_NAMEFLAGS(net,ncbi) & NFMACHNAME) {
        //
        // Name is the machine name. It may have been removed from the
        // card by a board reset, so try to re-add it.
        //
        // NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW
        //
        // First reset the adapter
        //
        MSG_LOG1(TRACE,"Calling NetBiosReset for lana #%d\n",GETNETLANANUM(net));
        status = MsgsvcGlobalData->NetBiosReset(GETNETLANANUM(net));

        if (status != NERR_Success) {
            MSG_LOG(ERROR,"MsgDeleteName: NetBiosReset failed %d\n",
            status);
            MSG_LOG(ERROR,"MsgDeleteName: AdapterNum %d\n",net);
            //
            //  I'm not sure what to do if this fails.
            //
        }
        //
        //
        // NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW-NEW

        memcpy((char far *) ncb.ncb_name, SD_NAMES(net,ncbi),NCBNAMSZ);
        ncb.ncb_command = NCBADDNAME;               // Add name (wait)
        ncb.ncb_lana_num = GETNETLANANUM(net);       // Use the LANMAN adapter
        Msgsendncb( &ncb, net);
        MsgStartListen(net,ncbi);
    }
    else {
        MsgDatabaseLock(MSG_GET_EXCLUSIVE,"MsgDeleteName"); // Wait for write access
        SD_NAMEFLAGS(net,ncbi) = NFDEL;             // Name is deleted
        MsgDatabaseLock(MSG_RELEASE,"MsgDeleteName");  // Free lock on share table
        pNcb = GETNCB(net,ncbi);
        pNcb->ncb_cmd_cplt = 0xff;    // Simulate command in progress
    }
}

/*
 *  MsgGetMachineName - process a Get Machine Name Server Message Block
 *
 *  This function sends to the caller the local machine name in
 *  response to a Get Machine Name Server Message Block.
 *
 *  MsgGetMachineName (net, ncbi)
 *
 *  ENTRY
 *    net        - Network index
 *    ncbi        - Network Control Block index
 *
 *    Globals used as input:
 *
 *      machineName - Unicode version of the machine name.
 *
 *      machineNameLen - The number of unicode characters in the machine
 *          name.
 *
 *  RETURN
 *    nothing
 *
 *  MsgGetMachineName() is called by MsgReceiveService (RecAnyService()).
 *  After verifying that the request is valid, this function builds
 *  an SMB containing the local machine name and sends it back to the
 *  caller.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgVerifySmb() and MsgCallNetBios().  Sets MsgSendService() to be the
 *  next service routine to be executed for the ncbi'th NCB.
 */

STATIC VOID
MsgGetMachineName(
    DWORD   net,        // Which network?
    DWORD   ncbi        // Index to NCB
    )
{
    PNCB    ncb;        // Pointer to NCB
    PNCB_DATA pNcbData; // Pointer to NCB Data
    LPBYTE  buffer;     // Pointer to SMB buffer
    LPBYTE  cp;         // Save pointer
    PSHORT  bufLen;     // Pointer to buffer length field in SMB;

    NTSTATUS        ntStatus;
    OEM_STRING     ansiString;
    UNICODE_STRING  unicodeString;

    MSG_LOG(TRACE,"In MsgGetMachineName %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;          // Get pointer to NCB

    if(pNcbData->State != MESSTART) {
        //
        // If wrong time for this block
        //
        // Hang up and start a new listen,
        // log an error if mpncbistate[net][ncbi] == MESCONT;
        // otherwise, do not log the error.
        //

        if(pNcbData->State == MESCONT) {
            //
            // Log error if message in progress
            //
            Msglogmbe(MESERR,net,ncbi);
        }
        //
        // HANGUP and LISTEN again
        //
        MsgRestart(net,ncbi);
        return;
    }

    pNcbData->State = MESSTOP;   // End of message state

    //
    // Check if SMB is malformed
    //
    if(MsgVerifySmb(net,ncbi,SMB_COM_GET_MACHINE_NAME,0,"") != 0) {
        return;
    }

    buffer = ncb->ncb_buffer;           // Get pointer to buffer
    cp = &buffer[sizeof(SMB_HEADER)];   // Skip to end of header
    *cp++ = '\0';                       // Return no parameters

    //
    // Length of name plus two
    //
    bufLen = (PSHORT)&cp[0];
    *bufLen = MachineNameLen + (SHORT)2;

    cp += sizeof(MachineNameLen);           // Skip over buffer length field

    *cp++ = '\004';                         // Null-terminated string next

#ifdef UNICODE
    //
    // Translate the machineName from Unicode to Ansi and place it into
    // the buffer at the temp pointer location.
    //
    unicodeString.Length = (USHORT)(STRLEN(machineName)*sizeof(WCHAR));
    unicodeString.MaximumLength = (USHORT)((STRLEN(machineName)+1) * sizeof(WCHAR));
    unicodeString.Buffer = machineName;

    ansiString.Length = MachineNameLen;
    ansiString.MaximumLength = *bufLen;
    ansiString.Buffer = cp;

    ntStatus = RtlUnicodeStringToOemString(
                    &ansiString,
                    &unicodeString,
                    FALSE);           // Don't Allocate the ansiString Buffer

    if (!NT_SUCCESS(ntStatus)) {
        MSG_LOG(ERROR,
            "MsgGetMachineName:RtlUnicodeStringToOemString Failed rc=%X\n",
            ntStatus);
        return;   // They return for other errors, so I will here too.
    }

    *(cp + ansiString.Length) = '\0';

#else
    UNUSED(unicodeString);
    UNUSED(ansiString);
    UNUSED(ntStatus);
    strcpy( cp, (LPSTR)machineName);        // Copy machine name
#endif

    cp += MachineNameLen + 1;               // Skip over machine name

    //
    // Set length of buffer
    //
    ncb->ncb_length = (USHORT)(cp - buffer);

    ncb->ncb_command = NCBSEND | ASYNCH;    // Send (no wait)
    pNcbData->IFunc = (LPNCBIFCN)MsgSendService;     // Set function pointer
    MsgCallNetBios(net,ncb,ncbi);              // Issue the net bios call
}

/*
 *  MsgHangupService - Service completed HANGUP net bios calls
 *
 *  This function is invoked by NCBService() to process completed
 *  HANGUP net bios calls.  In response to a completed HANGUP,
 *  this function issues a new LISTEN net bios call.
 *
 *  MsgHangupService (net, ncbi, retval)
 *
 *  ENTRY
 *    net    - network index
 *    ncbi    - Network Control Block index
 *    retval    - value returned from net bios call
 *
 *  RETURN
 *    nothing
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgStartListen() to issue a new LISTEN net bios call.  Calls
 *  MsgNetBiosError() on errors it does not know how to deal with.
 */

STATIC VOID
MsgHangupService(
    DWORD   net,        // Which network
    DWORD   ncbi,       // Index of completed NCB
    CHAR    retval      // HANGUP return value
    )
{
    PNCB pNcb;
    MSG_LOG(TRACE,"In MsgHangupService %d\n",net);

    switch(retval) {        // Switch on return value
    case NRC_GOODRET:       // Success
    case NRC_CMDTMO:        // Command timed out
    case NRC_SCLOSED:       // Session closed
    case NRC_SABORT:        // Session ended abnormally

        //
        // BBSP - check if the name for this NCB ends in 0x3.  If so,
        // add the 0x5 version and don't reissue the listen on the 0x03.
        // No need to worry about doing it on all nets, since on a machine
        // with more than one the 0x05 name will never leave home, and
        // the 0x03 version will never get a message.
        //

        MSG_LOG(TRACE," MsgHangupService: Issue a new LISTEN\n",0);
        MsgStartListen(net,ncbi);      // Issue a new LISTEN net bios call
        break;

    default:
        //
        // Invoke error handler
        //
        MSG_LOG(TRACE," MsgHangupService: Unknown return value %x\n",retval);
        pNcb = GETNCB(net,ncbi);
        MsgNetBiosError(net,pNcb,retval,ncbi);

        //
        // BBSP - check if the name for this NCB ends in 0x3.  If so,
        // add the 0x5 version and don't reissue the listen on the 0x03.
        // See note above.
        //

        MSG_LOG(TRACE," MsgHangupService: Issue a new LISTEN\n",0);
        MsgStartListen(net,ncbi);      // Issue a new LISTEN net bios call
        break;
    }
}

/*
 *  MsgListenService - service completed LISTEN net bios calls
 *
 *  This function is called when a LISTEN net bios call completes
 *  either due to an error or due to the establishment of a
 *  session.  In the latter case, it initiates message reception.
 *
 *  MsgListenService (net, ncbi, retval)
 *
 *  ENTRY
 *    net    - network index
 *    ncbi    - Network Control Block index
 *    retval    - value returned from NCB call
 *
 *  RETURN
 *    nothing
 *
 *  If a session is established, this function issues a RECEIVE ANY
 *  net bios call to initiate reception of a message.  If the function
 *  is invoked because the net bios call has failed due to the deletion
 *  of a name from the local network adapter's name table, then this
 *  function calls the routine responsible for deleting names from the
 *  Message Server's data area.  This is the mechanism by which the
 *  NETNAME command notofies the Message Server of a deletion.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgCallNetBios() to issue a RECEIVE ANY net bios call.  Calls
 *  MsgDeleteName() if it is informed of the deletion of a name.  Calls
 *  MsgNetBiosError() on errors it does not know how to deal with.  Sets
 *  mpncbifun[ncbi] according to the net bios call it issues.
 */

STATIC VOID
MsgListenService(
    DWORD   net,        // Which network?
    DWORD   ncbi,       // Index of completed NCB
    CHAR    retval      // LISTEN return value
    )
{
    PNCB      ncb;        // Pointer to completed NCB
    PNCB_DATA pNcbData;   // Corresponding NCB data

    static    DWORD   SaveCount = 0;


    MSG_LOG(TRACE,"In MsgListenService %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;   // Get pointer to completed NCB

    switch(retval) {
    case NRC_GOODRET:
        //
        // Success
        //

        //
        // Reset the No Resources error count if a good return code comes
        // in for this name.
        //

        SaveCount = 0;

        pNcbData->State = MESSTART;      // Message start state
        pNcbData->IFunc = (LPNCBIFCN)MsgReceiveService;
        //
        // Set function pointer
        //
        ncb->ncb_command = NCBRECV | ASYNCH;

        //
        // Receive any (no wait)
        //
        ncb->ncb_length = BUFLEN;           // Reset length of buffer
        MsgCallNetBios(net,ncb,ncbi);          // Issue the net bios call
        break;

    case NRC_LOCTFUL:
        //
        // Session Table Full
        // Log error in system error log file
        //
        MSG_LOG(TRACE,"[%d]MsgListenService: Session Table is full\n",net);
        pNcbData->IFunc = (LPNCBIFCN)MsgSesFullService;  // Set function pointer
        ncb->ncb_command = NCBDELNAME | ASYNCH; // Delete name (no wait)
        MsgCallNetBios(net,ncb,ncbi);              // Issue the net bios call
        break;

    case NRC_NOWILD:            // Name not found
        // Name not found
        // Name deleted between end of one session and start of next

    case NRC_NAMERR:
        //
        // Name was deleted
        //
        MSG_LOG(TRACE,"[%d]MsgListenService: Name was deleted for some reason\n",net);
        MsgDeleteName(net,ncbi);         // Handle the deletion
        break;

    case NRC_NORES:

        //
        // We need to cover the case where we are adding a new name and
        // starting a new listen.  In this case, the thread that is adding
        // the names will hangup and delete the name.
        //
        // So here we will sleep for a moment and then check to see if the
        // name is still there.  If not we just return without setting
        // up to handle the NCB anymore.  If the name is still there, then
        // we travel down the default path and try again.
        //

        MSG_LOG(TRACE,"[%d]No Net Resources.  SLEEP FOR A WHILE\n",net);
        Sleep(1000);
        MSG_LOG(TRACE,"[%d]No Net Resources.  WAKEUP\n",net);

        if (pNcbData->NameFlags == NFDEL)
        {
            MSG_LOG(TRACE,"[%d]MsgListenService: No Net Resources & Name Deleted\n",net);
            ncb->ncb_cmd_cplt = 0xff;
        }
        else
        {
            //
            // If a session goes away and we can't gain the resources for
            // it again, then we will attempt to re-connect MAX_RETRIES
            // times.  If we still cannot connect, then the name will be
            // deleted.
            //
            // Don't deal with retries per net/ncbi -- if we've had
            // "out of resources" failures MAX_RETRIES times, odds are
            // the situation's not getting better even if we sleep/retry
            // for each individual net/ncbi combo.
            //

            if (SaveCount >= MAX_RETRIES)
            {
                //
                // Delete the Name
                //

                MSG_LOG(ERROR,
                        "Out of Resources, Deleting %s\n",
                        SD_NAMES(net,ncbi));

                MsgDeleteName(net,ncbi);

                //
                // Mark this as 0xff now to avoid another callback call the
                // next time this net/ncbi combo is hit in the loop (since that
                // call will simply set this value.
                //

                ncb->ncb_cmd_cplt = 0xff;

                //
                // Don't roll SaveCount back to zero until we have an NCB
                // completed with NRC_GOODRET in the future.  This lets us
                // avoid rewaiting MAX_RETRIES times for every net/ncbi
                // combo as long as we keep getting NRC_NORES.
                //
            }
            else
            {
                SaveCount++;

                MSG_LOG(TRACE,
                        "MsgListenService: new SaveCount = %d\n",
                        SaveCount);
            }
        }
        break;

    case NRC_BRIDGE:
        //
        // Lana number no longer valid (network interface went away)
        //
        MSG_LOG(TRACE,"[%d] lana has become invalid\n", net);
        MsgNetBiosError(net, ncb, retval, ncbi);

        //
        // Indicate lana is now invalid
        //
        GETNETLANANUM(net) = 0xff;

        //
        // Mark current operation as deleted
        //
        ncb->ncb_cmd_cplt = 0xff;
        ncb->ncb_retcode = 0;
        break;

    default:
        //
        // Other failure
        //
        MSG_LOG(TRACE,"MsgListenService: Unrecognized retval %x\n",retval);

        MsgNetBiosError(net,ncb,retval,ncbi);

        // The listen error has been logged. Now as much as possible to
        // get another listen staterd. This involves performing
        // a HangUp for this name (which should fail but might help
        // to clear out the err) and then re-issuing the listen. If the
        // same error occurs SHUTDOWN_THRESHOLD consecutive times then
        // MsgNetBiosError will shut down the message server.
        //

        MsgRestart(net,ncbi);            // Attempt to restart the Listen
        break;
    }
}

/*
 *  Msgmblockbeg - process the header of a multi-block message
 *
 *  This function acknowledges receipt of the header of a multi-block
 *  message and initiates logging of that message.
 *
 *  Msgmblockbeg (net, ncbi)
 *
 *  ENTRY
 *    net        - network index
 *    ncbi        - Network Control Block index
 *
 *  RETURN
 *    nothing
 *
 *  This function is called from ReceivePost() (RecAnyPost()).
 *  It first check to see if it is appropriate for the ncbi'th
 *  name to have received a begin-multi-block-message SMB at the
 *  current time.  It verifies the correctness of the SMB in the
 *  ncbi'th buffer.  It initiates logging of the multi-block message,
 *  and it sends an acknowledgement to the sender of the message.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgRestart() to terminate the session if the SMB has arrived
 *  at a bad time.  Calls MsgVerifySmb() to check the SMB for correctness.
 *  Calls logmbb() to begin logging.  Calls MsgSendAck() to send an
 *  acknowledgement to the sender of the message.
 */

STATIC VOID
Msgmblockbeg(
    DWORD   net,        // Which network?
    DWORD   ncbi        // Index to NCB
    )
{
    PNCB        ncb;        // Pointer to NCB
    PNCB_DATA   pNcbData;   // Pointer to NCB Data
    LPBYTE      buffer;     // Pointer to SMB buffer
    LPSTR       cp;         // Save pointer
    LPSTR       from;       // From-name
    LPSTR       to;         // To-name

    MSG_LOG(TRACE,"In Msgmblockbeg %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;                // Get pointer to NCB
    if(pNcbData->State != MESSTART) {    // If wrong time for this block

        //
        // Hang up and start a new listen,
        // log an error if mpncbistate[net][ncbi] == MESCONT;
        // otherwise, do not log the error.
        //
        if(pNcbData->State == MESCONT) {
            //
            // Log error if message in progress
            //
            Msglogmbe(MESERR,net,ncbi);
        }

        //
        // HANGUP and LISTEN again
        //
        MsgRestart(net,ncbi);
        return;
    }
    pNcbData->State = MESCONT;         // Processing multi-block message
    if(MsgVerifySmb(net,ncbi,SMB_COM_SEND_START_MB_MESSAGE,0,"ss") != 0) {
        //
        // Check for malformed SMB
        //
        return;
    }

    buffer = ncb->ncb_buffer;               // Get pointer to buffer
    from = &buffer[sizeof(SMB_HEADER) + 4]; // Save pointer to from-name
    to = &from[strlen(from) + 2];           // Save pointer to to-name

    if(Msglogmbb(from,to,net,ncbi)) {          // If attempt to log header fails
        pNcbData->State = MESERR;    // Enter error state
        //
        // Send negative acknowledgement
        //
        MsgSendAck(net,ncbi,'\002',SMB_ERR_NO_ROOM);
        return;
    }

    //
    // Indicate message received
    //
    SmbPutUshort(&(((PSMB_HEADER)buffer)->Error), (USHORT)SMB_ERR_SUCCESS);

//    ((PSMB_HEADER)buffer)->Error = (USHORT)SMB_ERR_SUCCESS;

    cp = &buffer[sizeof(SMB_HEADER)];           // Point just past header
    *cp++ = '\001';                             // One parameter
    ((short UNALIGNED far *) cp)[0] = ++mgid;             // Message group ID
    pNcbData->mgid = mgid;               // Save message group i.d.
    ((short UNALIGNED far *) cp)[1] = 0;                  // No buffer
    ncb->ncb_length = sizeof(SMB_HEADER) + 5;   // Set length of buffer
    ncb->ncb_command = NCBSEND | ASYNCH;        // Send(no wait)

    //
    // Set function pointer & issue the net bios call
    //

    pNcbData->IFunc = (LPNCBIFCN)MsgSendService;

    MsgCallNetBios(net,ncb,ncbi);
}

/*
 *  Msgmblockend - process end of a multi-block message
 *
 *  This function acknowledges receipt of the end of a
 *  multi-block message and terminates logging of the message.
 *
 *  Msgmblockend (net, ncbi)
 *
 *  ENTRY
 *    net        - network index
 *    ncbi        - Network Control Block index
 *
 *  RETURN
 *    nothing
 *
 *  This function is called from ReceivePost() (RecAnyPost()).
 *  It first check to see if it is appropriate for the ncbi'th
 *  name to have received an end-multi-block-message SMB at the
 *  current time.  It verifies the correctness of the SMB in the
 *  ncbi'th buffer.  It terminates logging, and it sends an
 *  acknowledgement to the sender of the message.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgRestart() to terminate the session if the SMB has arrived
 *  at a bad time.  Calls MsgVerifySmb() to check the SMB for correctness.
 *  Calls logmbe() to terminate logging.  Calls MsgSendAck() to send an
 *  acknowledgement to the sender of the message.
 */

STATIC VOID
Msgmblockend(
    DWORD   net,        // Which network?
    DWORD   ncbi        // Index to NCB
    )
{
    PNCB            ncb;        // Pointer to NCB
    PNCB_DATA       pNcbData;   // Pointer to NCB Data
    LPBYTE          buffer;     // Pointer to SMB buffer
    int             error;      // Error flag
    char            smbrclass;  // SMB return class
    unsigned short  smbrcode;   // SMB return code

    MSG_LOG(TRACE,"In Msgmblockend %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;             // Get pointer to NCB
    if(pNcbData->State != MESCONT) { // If wrong time for this block
        //
        // Hang up and start a new listen,
        // no error to log since no message in progress.
        // HANGUP and LISTEN again
        //
        MsgRestart(net,ncbi);
        return;
    }
    pNcbData->State = MESSTOP;         // End of message state
    if(MsgVerifySmb(net,ncbi,SMB_COM_SEND_END_MB_MESSAGE,1,"") != 0) {
        //
        // If SMB is malformed, log error and return
        //
        Msglogmbe(MESERR,net,ncbi);
        return;
    }
    buffer = ncb->ncb_buffer;         // Get pointer to buffer

    if(*((short UNALIGNED far *) &buffer[sizeof(SMB_HEADER) + 1]) != pNcbData->mgid) {

        //
        // If i.d. does not match
        //
        error = 1;                  // Error found
        smbrclass = '\002';         // Error return
        smbrcode = SMB_ERR_ERROR;   // Non-specific error
    }
    else {
        //
        // Else if message group i.d. okay
        //
        error = 0;                          // No error found
        smbrclass = '\0';                   // Good return
        smbrcode = (USHORT)SMB_ERR_SUCCESS; // Message received
    }
    MsgSendAck(net,ncbi,smbrclass,smbrcode);   // Send acknowledgement
    if(!error) Msglogmbe(MESSTOP,net,ncbi);    // Log end of message
}

/*
 *  Msgmblocktxt - process text of a multi-block message
 *
 *  This function acknowledges receipt of a block of text of a
 *  multi-block message and logs that block.
 *
 *  Msgmblocktxt (net, ncbi)
 *
 *  ENTRY
 *    net        - Network index
 *    ncbi        - Network Control Block index
 *
 *  RETURN
 *    nothing
 *
 *  This function is called from ReceivePost() (RecAnyPost()).
 *  It first check to see if it is appropriate for the ncbi'th
 *  name to have received a multi-block-message-text SMB at the
 *  current time.  It verifies the correctness of the SMB in the
 *  ncbi'th buffer.  It logs the text block, and it sends an
 *  acknowledgement to the sender of the message.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgRestart() to terminate the session if the SMB has arrived
 *  at a bad time.  Calls MsgVerifySmb() to check the SMB for correctness.
 *  Calls logmbt() to log the text block.  Calls MsgSendAck() to send an
 *  acknowledgement to the sender of the message.
 */

STATIC VOID
Msgmblocktxt(
    DWORD   net,        // Which network?
    DWORD   ncbi        // Index to NCB
    )
{
    PNCB        ncb;            // Pointer to NCB
    PNCB_DATA   pNcbData;       // Pointer to NCB Data
    LPBYTE      buffer;         // Pointer to SMB buffer
    LPSTR       cp;             // Save pointer
    char        smbrclass;      // SMB return class
    unsigned short    smbrcode; // SMB return code

    MSG_LOG(TRACE,"In Msgmblocktxt %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;             // Get pointer to NCB
    if(pNcbData->State != MESCONT) { // If wrong time for this block
        //
        // HANGUP and start a new LISTEN.
        // no error to log since no message in progress.
        //
        MsgRestart(net,ncbi);
        return;
    }
    if(MsgVerifySmb(net,ncbi,SMB_COM_SEND_TEXT_MB_MESSAGE,1,"b") != 0) {
        //
        // If SMB is malformed
        //
        Msglogmbe(MESERR,net,ncbi);            // Log error
        return;
    }
    buffer = ncb->ncb_buffer;               // Get pointer to buffer
    cp = &buffer[sizeof(SMB_HEADER) + 1];   // Skip to message group i.d.

    if(*((short UNALIGNED far *) cp) != pNcbData->mgid) {
        //
        // If i.d. does not match
        //
        smbrclass = '\002';                 // Error return
        smbrcode = SMB_ERR_ERROR;           // Non-specific error
    }
    else if(Msglogmbt(&buffer[sizeof(SMB_HEADER) + 6], net, ncbi)) {
        //
        // Else if text cannot be logged
        //
        pNcbData->State = MESERR;    // Enter error state
        smbrclass = '\002';                 // Error return
        smbrcode = SMB_ERR_NO_ROOM;         // No room in buffer
    }
    else {
        //
        // Else if message logged okay
        //
        smbrclass = '\0';                   // Good return
        smbrcode = (USHORT)SMB_ERR_SUCCESS; // Message received
    }

    MsgSendAck(net,ncbi,smbrclass,smbrcode);   // Send acknowledgement
}

/*
 *  MsgNetBiosError - process an error returned by a net bios call
 *
 *  This function performs generic error handling for
 *  failed net bios calls.  If the error is a fatal one because the error
 *  counted exceeded the SHUTDOWN_THRESHOLD, this routine begins a forced
 *  shutdown of the messenger.  This shutdown will not complete until all
 *  threads have woken up and returned to the main loop where the
 *  messenger status is examined.
 *
 *  MsgNetBiosError (net, ncb, retval, ncbi)
 *
 *  ENTRY
 *    net    - Network index
 *    ncb    - Network Control Block pointer
 *    retval    - value returned from the net bios call
 *    ncbi    - ncb array index of ncb which resulted in this error
 *
 *  RETURN
 *    state of the Messenger:  Either RUNNING or STOPPING.
 *
 *    Chcks in ncbStatus array that this is not a repeated error
 *    that has already been entered in the error log, and logs
 *    the error.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgErrorLogWrite() to log errors in the Network System Error Log.
 *  If this is a new error, the error status in the ncbStatus array for this
 *  ncb is updated so that the same error will not be reported if it is
 *  repeated.
 */

STATIC DWORD
MsgNetBiosError(
    DWORD       net,        // Which network?
    PNCB        ncb,        // Pointer to NCB
    char        retval,     // Error code
    DWORD       ncbi        // Index of array causing the error
    )
{
    PNCB_DATA pNcbData;
    //
    // First check the immediate status for this ncb. If it is in error
    // then this must be the error, else it is a final error code.
    //

    pNcbData = GETNCBDATA(net,ncbi);
    if (pNcbData->Status.this_immediate != 0) {

        if(pNcbData->Status.this_immediate ==
           pNcbData->Status.last_immediate)   {

            if (++(pNcbData->Status.rep_count) >= SHUTDOWN_THRESHOLD) {

                //
                // The same error has occured SHUTDOWN_THRESHOLD times in
                // a row.  Write to the event log and shutdown the messenger.
                //

                MsgErrorLogWrite(
                    NELOG_Msg_Shutdown,
                    SERVICE_MESSENGER,
                    (LPBYTE) ncb,
                    sizeof(NCB),
                    NULL,
                    0);

                MSG_LOG(ERROR,"MsgNetBiosError1:repeated MsgNetBiosError(ncb error) - shutting down\n",0);
                return(MsgBeginForcedShutdown(
                            PENDING,
                            NERR_InternalError));
            }
            return(RUNNING);     // Same as last error so don't report it
        }
        else {
            //
            // This error was not the same as the last error.  So just
            // update the last error place holder.
            //
            pNcbData->Status.last_immediate =
            pNcbData->Status.this_immediate;
        }
    }
    else {
        //
        // Must have been a final ret code (ncb completion code) that was
        // in error.
        //
        if(pNcbData->Status.this_final == pNcbData->Status.last_final) {

            if (++(pNcbData->Status.rep_count) >= SHUTDOWN_THRESHOLD) {

                MsgErrorLogWrite(
                    NELOG_Msg_Shutdown,
                    SERVICE_MESSENGER,
                    (LPBYTE) ncb,
                    sizeof(NCB),
                    NULL,
                    0);

                MSG_LOG(ERROR,"MsgNetBiosError2:repeated MsgNetBiosError (final ret code) - shutting down\n",0);
                return(MsgBeginForcedShutdown(
                            PENDING,
                            NERR_InternalError));
            }
            return(RUNNING);     // Same as last error so don't report it
        }
        else {
            pNcbData->Status.last_final = pNcbData->Status.this_final;
        }
    }
    //
    // Here if a new error has occured so log it in the error log.
    //

    MsgErrorLogWrite(
        NELOG_Ncb_Error,
        SERVICE_MESSENGER,
        (LPBYTE) ncb,
        sizeof(NCB),
        NULL,
        0);      // Enter error in system error log


    MSG_LOG(ERROR,"MsgNetBiosError3:An unexpected NCB was received 0x%x\n",retval);

    UNUSED(retval);

#if DBG
    MsgDumpNcb(ncb);
#endif

    return (RUNNING);
}

/*
 *  MsgReceiveService - service a completed RECEIVE net bios call
 *
 *  This function is called to service a completed RECEIVE  net
 *  bios call.  For successful completions, it examines the data
 *  received to determine which of the SMB-processing functions
 *  should be called.
 *
 *  MsgReceiveService (net, ncbi, retval)
 *
 *  ENTRY
 *    net        - network index
 *    ncbi        - Network Control Block index
 *    retval        - value returned by the net bios
 *
 *  RETURN
 *    nothing
 *
 *  This function dispatches SMB's received to the proper processing
 *  function.  It also handles a number of error conditions (noted
 *  in the code below).
 *
 *  SIDE EFFECTS
 *
 *  See handling of error conditions.
 */

STATIC VOID
MsgReceiveService(
    DWORD       net,        // Which network?
    DWORD       ncbi,       // Index to completed NCB
    char        retval      // SEND return value
    )
{
    PNCB        ncb;        // Pointer to completed NCB
    PNCB_DATA   pNcbData;   // Pointer to NCB Data
    PSMB_HEADER smb;        // Pointer to SMB header


    MSG_LOG(TRACE,"In MsgReceiveService %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;         // Get pointer to NCB

    switch(retval)  {

    case NRC_GOODRET:                   // Success
        if(ncb->ncb_length >= sizeof(SMB_HEADER)) {
            //
            // If we could have an SMB
            //
            smb = (PSMB_HEADER)ncb->ncb_buffer;

            // Get pointer to buffer
            switch(smb->Command) {      // Switch on SMB function code
            case SMB_COM_SEND_MESSAGE:              // Single block message
                Msgsblockmes(net,ncbi);
                return;

            case SMB_COM_SEND_START_MB_MESSAGE:           // Beginning of multi-block message
                Msgmblockbeg(net,ncbi);
                return;

            case SMB_COM_SEND_END_MB_MESSAGE:            // End of multi-block message
                Msgmblockend(net,ncbi);
                return;

            case SMB_COM_SEND_TEXT_MB_MESSAGE:            // Text of multi-block message
                Msgmblocktxt(net,ncbi);
                return;

            case SMB_COM_GET_MACHINE_NAME:             // Get Machine Name
                MsgGetMachineName(net,ncbi);
                return;

            case SMB_COM_FORWARD_USER_NAME:            // Add forward-name
                //
                // Not supported in NT.
                // for now fall through as if unrecognized SMB.
                //

            case SMB_COM_CANCEL_FORWARD:            // Delete forward-name
                //
                // Not supported in NT.
                // for now fall through as if unrecognized SMB.
                //

            default:                    // Unrecognized SMB
                break;
            }
        }

        if(pNcbData->State == MESCONT) {
            //
            // If middle of multi-block message, Log an error
            //
            Msglogmbe(MESERR,net,ncbi);
        }

        //
        // Enter error in system error log
        //

        MsgErrorLogWrite(
            NELOG_Msg_Unexpected_SMB_Type,
            SERVICE_MESSENGER,
            (LPBYTE)ncb->ncb_buffer,
            ncb->ncb_length,
            NULL,
            0);

        MSG_LOG(ERROR,"MsgReceiveService:An illegal SMB was received\n",0);
        //
        // HANGUP and LISTEN again
        //
        MsgRestart(net,ncbi);
        break;

    case NRC_CMDTMO:            // Command timed out

        if(pNcbData->State == MESCONT) {
            //
            // If middle of multi-block message
            //
            Msglogmbe(MESERR,net,ncbi);        // Log an error
        }
        //
        // HANGUP and start new LISTEN
        //
        MsgRestart(net,ncbi);
        break;

    case NRC_SCLOSED:           // Session closed
    case NRC_SABORT:            // Session ended abnormally

        if(pNcbData->State == MESCONT) {
            //
            // If middle of multi-block message, Log an error
            //
            Msglogmbe(MESERR,net,ncbi);
        }
        //
        // Start a new LISTEN
        //
        MsgStartListen(net,ncbi);
        break;

    default:            // Other errors
        MSG_LOG(TRACE,"MsgReceiveService: Unrecognized retval %x\n",retval);

        MsgNetBiosError(net,ncb,retval,ncbi);

        if(pNcbData->State == MESCONT) {
            //
            // If middle of multi-block message, Log an error
            //
            Msglogmbe(MESERR,net,ncbi);
        }

        MsgRestart(net,ncbi);            // HANGUP and LISTEN again
        break;
    }
}

/*
 *  MsgRestart - issue a HANGUP net bios call
 *
 *  This function is invoked to issue a HANGUP net bios call using
 *  a particular Network Control Block.
 *
 *  MsgRestart (net, ncbi)
 *
 *  ENTRY
 *    net    - network index
 *    ncbi    - Network Control Block index
 *
 *  RETURN
 *    nothing
 *
 *  This function assumes that the NCB_LSN, NCB_POST, and NCB_LANA
 *  fields of the Network Control Block are already properly set.
 *  It sets the NCB_CMD field.
 *
 *  This function is named "MsgRestart" since the very next routine
 *  to process the NCB used to issue the HANGUP should be
 *  MsgHangupService() which always invokes MsgStartListen() (assuming
 *  the HANGUP completes properly).  Thus, the net effect of
 *  calling MsgRestart() is to terminate the current session and
 *  issue a LISTEN to start a new one.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgCallNetBios() to issue the net bios call.  Sets mpncbifun[ncbi]
 *  to the address of MsgHangupService().
 */

STATIC VOID
MsgRestart(
    DWORD   net,        // Which network?
    DWORD   ncbi        // Index to NCB
    )
{
    PNCB    ncb;        // Pointer to Network Control Block
    PNCB_DATA pNcbData; // Pointer to NCB Data

    MSG_LOG(TRACE,"In MsgRestart %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;

    pNcbData->IFunc = (LPNCBIFCN)MsgHangupService;   // Set function pointer
    ncb->ncb_command = NCBHANGUP | ASYNCH;  // Hang up (no wait)

    MsgCallNetBios(net,ncb,ncbi);  // Issue the net bios call
}

/*
 *  Msgsblockmes - process a single block message
 *
 *  This function logs and acknowledges a single block message.
 *
 *  Msgsblockmes (net, ncbi)
 *
 *  ENTRY
 *    net        - network index
 *    ncbi        - Network Control Block index
 *
 *  RETURN
 *    nothing
 *
 *  This function is called from ReceivePost() (RecAnyPost()).
 *  It first check to see if it is appropriate for the ncbi'th
 *  name to have received a single block message SMB at the current
 *  time.  It verifies the correctness of the SMB in the ncbi'th
 *  buffer.  It attempts to log the single block message, and it
 *  sends an acknowledgement to the sender of the message.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgRestart() to terminate the session if the SMB has arrived
 *  at a bad time.  Calls MsgVerifySmb() to check the SMB for correctness.
 *  Calls logsbm() to log the message.  Calls MsgSendAck() to send an
 *  acknowledgement to the sender of the message.
 */

STATIC VOID
Msgsblockmes(
    DWORD       net,        // Which network ?
    DWORD       ncbi        // Index to NCB
    )
{
    PNCB        ncb;        // Pointer to NCB
    PNCB_DATA   pNcbData;   // Pointer to NCB
    LPBYTE      buffer;     // Pointer to SMB buffer
    LPSTR       cp;         // Save pointer
    LPSTR       from;       // From-name
    LPSTR       to;         // To-name

    // to browse the SessionId List :
    PMSG_SESSION_ID_ITEM	pItem;  // item in the list
    PLIST_ENTRY     pHead;          // head of the list
    PLIST_ENTRY     pList;          // list pointer
    DWORD           bError = 0;     // error flag
    
    MSG_LOG(TRACE,"In Msgsblockmes %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;         // Get pointer to NCB

    if(pNcbData->State != MESSTART) {

        //
        // If wrong time for this block
        // Hang up and start a new listen,
        // log an error if mpncbistate[net][ncbi] == MESCONT;
        // otherwise, do not log the error.
        //
        // Log error if message in progress
        //

        if(pNcbData->State == MESCONT) {
            Msglogmbe(MESERR,net,ncbi);
        }

        //
        // HANGUP and LISTEN again
        //

        MsgRestart(net,ncbi);
        return;
    }

    pNcbData->State = MESSTOP;   // End of message state

    //
    // Check for malformed SMB
    //

    if(MsgVerifySmb(net,ncbi,(unsigned char)SMB_COM_SEND_MESSAGE,0,"ssb") != 0) {
        return;
    }

    buffer = ncb->ncb_buffer;                   // Get pointer to buffer

    from   = &buffer[sizeof(SMB_HEADER) + 4];   // Save pointer to from-name
    to     = &from[strlen(from) + 2];           // Save pointer to to-name
    cp     = &to[strlen(to) + 2];               // Skip over the name


    if (g_IsTerminalServer)
    {
        MsgDatabaseLock(MSG_GET_EXCLUSIVE,"Msgsblockmes");
        pHead = &(SD_SIDLIST(net,ncbi));
        pList = pHead; 
        while (pList->Flink != pHead)        // loop all over the list
        {
            pList = pList->Flink;  
            pItem = CONTAINING_RECORD(pList, MSG_SESSION_ID_ITEM, List);
            bError = Msglogsbm(from,to,cp, pItem->SessionId);

            if (bError)
            {
                break;
            }
        }
        MsgDatabaseLock(MSG_RELEASE,"Msgsblockmes");
    }
    else        //regular NT
    {
        bError = Msglogsbm(from,to,cp,0);
    }

    if (bError)
    {
        //
        // If message cannot be logged, enter error state
        // and send error acknowledgement.
        //
        pNcbData->State = MESERR;
        MsgSendAck(net,ncbi,'\002',SMB_ERR_NO_ROOM);
    }
    else 
    {
        //
        // Otherwise acknowledge success
        //
        MsgSendAck(net, ncbi, SMB_ERR_SUCCESS, (USHORT)SMB_ERR_SUCCESS);
    }
}

/*
 *  MsgSendAck - send an SMB to acknowledge a network transaction
 *
 *  This function is used to send a Server Message Block to some
 *  machine with whom a session has been established acknowledging
 *  (positively or negatively) the occurrence of some event pertaining
 *  to the session.
 *
 *  MsgSendAck (net, ncbi, smbrclass, smbrcode)
 *
 *  ENTRY
 *    net        - Network index
 *    ncbi        - Network Control Block index
 *    smbrclass    - SMB return class
 *    smbrcode    - SMB return code
 *
 *  RETURN
 *    nothing
 *
 *  Using the NCB index to locate the buffer containing the last SMB
 *  received in the session, this function sets the return class and
 *  the return code in that SMB according to its arguments and sends
 *  the SMB to the other party in the session.  This function will
 *  not return any parameters or buffers in that SMB.
 *
 *  SIDE EFFECTS
 *
 *  This function calls MsgCallNetBios() to send the SMB, and it sets
 *  the function vector so that control will pass to Send Service()
 *  when the NCB completes (assuming, of course, that it doesn't
 *  fail immediately).
 */

STATIC VOID
MsgSendAck(
    DWORD           net,            // Which network?
    DWORD           ncbi,           // Network Control Block Index
    UCHAR           smbrclass,      // SMB return class
    USHORT          smbrcode        // SMB return code
    )
{
    PNCB            ncb;            // Pointer to NCB
    PNCB_DATA       pNcbData;       // Pointer to NCB Data
    LPBYTE          buffer;         // Pointer to buffer

    MSG_LOG(TRACE,"In MsgSendAck %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;     // Get pointer to NCB
    buffer = ncb->ncb_buffer;       // Get pointer to buffer

    //
    // No parameters, buffers
    //
    buffer[sizeof(SMB_HEADER)+2]=
    buffer[sizeof(SMB_HEADER)+1]=
    buffer[sizeof(SMB_HEADER)]= '\0';

    //
    // Set return information
    //

    ((PSMB_HEADER)buffer)->ErrorClass = smbrclass;      // Set return class

    SmbPutUshort( &(((PSMB_HEADER)buffer)->Error),smbrcode);// Set return code

//    ((PSMB_HEADER)buffer)->Error = smbrcode;          // Set return code
    ncb->ncb_length = sizeof(SMB_HEADER) + 3;           // Set length of buffer
    ncb->ncb_command = NCBSEND | ASYNCH;                // Send (no wait)
    pNcbData->IFunc = (LPNCBIFCN)MsgSendService;   // Set function pointer

    MsgCallNetBios(net,ncb,ncbi);                       // Issue the net bios call
}

/*
 *  MsgSendService - service a completed SEND net bios call
 *
 *  This function is called to service a completed SEND net bios
 *  call.  The usual course of action is to issue a RECEIVE (ANY)
 *  net bios call.
 *
 *  MsgSendService (net, ncbi, retval)
 *
 *  ENTRY
 *    net        - network index
 *    ncbi        - Network Control Block index
 *    retval        - value returned by net bios
 *
 *  RETURN
 *    nothing
 *
 *  If a SEND net bios call has completed successfully, this function
 *  will issue a RECEIVE (ANY) net bios call in all cases.  The com-
 *  pleted SEND represents one of the following cases:
 *
 *  - Acknowledgement of a Single Block Message
 *    The message originator will HANG UP, completing the RECEIVE (ANY) call.
 *  - Acknowledgement of the start of a Multi-block Message
 *    The message originator will SEND a text block, completing the RECEIVE
 *    (ANY) call.
 *  - Acknowledgement of text of a Multi-block Message
 *    The message originator will SEND more text or the end of the message,
 *    completing the RECEIVE (ANY) call.
 *  - Acknowledgement of the end of a Multi-block Message
 *    The message originator will HANG UP, completing the RECEIVE (ANY) call.
 *  -    Response to a Get Machine Name request
 *    The message originator will HANG UP, completing the RECEIVE (ANY) call.
 *  -    Acknowledgement of a Forward Name request
 *    The message originator will HANG UP, completing the RECEIVE (ANY) call.
 *  -    Acknowledgement of a Cancel Forward request
 *    The message originator will HANG UP, completing the RECEIVE (ANY) call.
 *  - An error response
 *    The message originator will HANG UP, completing the RECEIVE (ANY) call.
 *
 *  In all cases, it is clear to the RECEIVE (ANY) service function what its
 *  course of action is.
 *
 *  SIDE EFFECTS
 *
 *  If a SEND has completed normally, this function issues a RECEIVE (ANY)
 *  net bios call.  In some abnormal cases, this function calls MsgStartListen()
 *  to initiate a new session.  In all other abnormal cases, it calls
 *  MsgNetBiosError().
 */

STATIC VOID
MsgSendService(
    DWORD   net,        // Which network?
    DWORD   ncbi,       // Index of completed NCB
    char    retval      // SEND return value
    )
{
    PNCB        ncb;    // Pointer to completed NCB
    PNCB_DATA   pNcbData; // Pointer to NCB Data
    PSMB_HEADER smb;    // Pointer to SMB header

    MSG_LOG(TRACE,"In MsgSendService %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb; // Get pointer to completed NCB

    switch(retval) {

    case NRC_GOODRET:               // Success
        pNcbData->IFunc = (LPNCBIFCN)MsgReceiveService;

        //
        // Set function pointer
        //
        ncb->ncb_command = NCBRECV | ASYNCH;    // Receive (no wait)
        ncb->ncb_length = BUFLEN;               // Set length of buffer
        MsgCallNetBios(net,ncb,ncbi);              // Issue the net bios call
        break;

    case NRC_CMDTMO:                // Timeout
    case NRC_SCLOSED:               // Session closed
    case NRC_SABORT:                // Session ended abnormally

        smb = (PSMB_HEADER)ncb->ncb_buffer;       // Get pointer to SMB

        if(smb->Command == SMB_COM_SEND_START_MB_MESSAGE || smb->Command == SMB_COM_SEND_TEXT_MB_MESSAGE) {

            //
            // Message ended abnormally
            //
            Msglogmbe(MESERR,net,ncbi);
        }
        //
        // Issue a new LISTEN
        //
        MsgStartListen(net,ncbi);
        break;

    default:                        // Other failure
        MSG_LOG(TRACE,"MsgSendService: Unrecognized retval %x\n",retval);
        MsgNetBiosError(net,ncb,retval,ncbi);
        //
        // HANGUP and LISTEN again
        //
        MsgRestart(net,ncbi);
        break;
    }
}

/*
 *  MsgServeNCBs - service completed Network Control Blocks
 *
 *  This function scans the array of NCB's looking for NCB's in
 *  need of service.
 *
 *  MsgServeNCBs (net)
 *
 *  ENTRY
 *    net        - network to service NCBs on
 *
 *  RETURN
 *    TRUE - If this function actually services a completed NCB.
 *    FALSE - If this function didn't find any completed NCB's, or if
 *      the service is supposed to stop.
 *
 *  This function scans the array of NCB's until a completed NCB cannot be
 *  found.  Each time a completed NCB is found, the service function specified
 *  in the service function vector (mpncbifun[]) is called to service that
 *  NCB.
 *
 *  SIDE EFFECTS
 *
 *  Maintains a private static index of the last NCB examined.
 *  Starts each search at first NCB after the last one serviced.
 */

BOOL
MsgServeNCBs(
    DWORD   net         // Which network am I serving?
    )
{
    PNCB      pNcb;
    PNCB_DATA pNcbData;
    int     counter;        // A counter
    BOOL    found = FALSE;  // Indicates if a completed NCB was found.

    // Bugfix: each net has its own index, addressing
    // its part NCB array. All index values are initiliazed to zero
    // when the messenger starts. This solves the muti thread
    // problem.

    static int  ncbIndexArray[MSNGR_MAX_NETS] = {0};
                            // NCB index  array
    DWORD       ncbi;       // NCB index for this net


    //
    // get NCB index for this net
    //
    ncbi = ncbIndexArray[net];

    //
    // Loop until none completed found
    //
    do  {
        //
        // Loop to search NCB array
        //
        for(counter = NCBMAX(net); counter != 0; --counter, ++ncbi) {

            if(ncbi >= NCBMAX(net)) {
                ncbi = 0;// Wrap around
            }

            pNcbData = GETNCBDATA(net,ncbi);
            pNcb = &pNcbData->Ncb;
            if(pNcb->ncb_cmd_cplt != (unsigned char) 0xff) {
                found=TRUE;
                //
                // If completed NCB found
                //
                if(pNcb->ncb_cmd_cplt == 0) {
                    //
                    // Clear err on success and error count
                    //
                    pNcbData->Status.last_final = 0;
                    pNcbData->Status.rep_count = 0;
                }
                else {
                    //
                    // Else mark error
                    //
                    pNcbData->Status.this_final = pNcb->ncb_cmd_cplt;


                    //
                    // If NetBios is failing with every call, we never
                    // return from this routine be cause there is always
                    // another NCB to service.  Therefore, in error
                    // conditions it is necessary to check to see if a
                    // shutdown is in progress.  If so, we want to return
                    // so that the adapter loop can handle the shutdown
                    // properly.
                    //
                    if (GetMsgrState() == STOPPING) {
                        ncbIndexArray[net] = ncbi;
                        return(FALSE);
                    }
                }

                //
                // Call the service function
                //
                (*pNcbData->IFunc)(net,ncbi,pNcb->ncb_cmd_cplt);

                ++ncbi;         // Start next search after this NCB
                break;          // Exit loop
            }
        }
    }
    while(counter != 0);        // Loop until counter zero

    // update NCB index
    ncbIndexArray[net] = ncbi;
    return(found);
}

/*
 *  MsgSesFullService - complete deletion of a name after a system error
 *
 *  MsgSesFullService() completes the process of deleting a name from
 *  the message system when the message server is unable to establish
 *  a session for that name.
 *
 *  MsgSesFullService (net, ncbi, retval)
 *
 *  ENTRY
 *    net        - Network index
 *    ncbi        - Network Control Block index
 *    retval        - value returned by net bios
 *
 *  RETURN
 *    nothing
 *
 *  MsgSesFullService() is called to finish the job of cleaning up when
 *  a LISTEN fails because the local network adapter's session table
 *  is full.  Specifically, this function is called when the DELETE
 *  NAME net bios call completes.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgDeleteName() to release the deleted name's entry in the
 *  shared data area.  Calls MsgNetBiosError() if the DELETE NAME net
 *  bios call produced unexpected results.
 */

STATIC VOID
MsgSesFullService(
    DWORD       net,        // Which network ?
    DWORD       ncbi,       // Index of completed NCB
    char        retval      // SEND return value
    )

{
    PNCB pNcb;
    MSG_LOG(TRACE,"In MsgSesFullService %d\n",net);

    switch(retval)  {

    case NRC_GOODRET:           // Success
    case NRC_ACTSES:            // Name deregistered

        //
        // Log deletion in system error log file
        //
        MsgDeleteName(net,ncbi);   // Delete name from database
        break;

    default:                    // Failure

      MSG_LOG(TRACE,"MsgSesFullService: Unrecognized retval %x\n",retval);
      pNcb = GETNCB(net,ncbi);
      MsgNetBiosError(net, pNcb, retval, ncbi);
      break;
    }
}

/*
 *  MsgStartListen - issue a LISTEN net bios call
 *
 *  This function is invoked to issue a LISTEN net bios call using
 *  a particular Network Control Block.  This function does not
 *  examine or change any of the shareable data corresponding to
 *  the NCB in question.
 *
 *  MsgStartListen (net, ncbi)
 *
 *  ENTRY
 *    net    - network index
 *    ncbi    - Network Control Block index
 *
 *  RETURN
 *    DWORD status from the netbios call.
 *
 *  This function assumes that the NCB_NAME, NCB_POST, and NCB_LANA
 *  fields of the Network Control Block are already set to the
 *  proper values.  It sets the NCB_CNAME, NCB_RTO, NCB_STO, and
 *  NCB_CMD fields.
 *
 *  SIDE EFFECTS
 *
 *  Calls MsgCallNetBios() to issue the net bios call.  Calls FmtNcbName()
 *  to set the NCB_CNAME field of the NCB.  Sets mpncbifun[ncbi] to
 *  the address of MsgListenService().
 */

NET_API_STATUS
MsgStartListen(
    DWORD       net,        // Which network?
    DWORD       ncbi        // Network Control Block index
    )
{
    PNCB            ncb;        // Pointer to NCB
    PNCB_DATA       pNcbData;   // Pointer to NCB Data

    NET_API_STATUS  status;
    TCHAR           name[2] = TEXT("*");

    MSG_LOG(TRACE,"In MsgStartListen %d\n",net);

    pNcbData = GETNCBDATA(net,ncbi);
    ncb = &pNcbData->Ncb;
    pNcbData->IFunc = (LPNCBIFCN)MsgListenService;   // Set function pointer

    //
    // Set call name to a"anyone"
    //
    status = MsgFmtNcbName(ncb->ncb_callname,name,' ');
    if (status != NERR_Success) {
        //
        // This is a bug if this can't be done.
        //
        MSG_LOG(ERROR,"MsgStartListen: NASTY BUG!  Cannot format \"*\" name! %X\n",
            status);
        NetpAssert(0);
    }

    ncb->ncb_rto = 60;                      // Receives time out in 30 sec
    ncb->ncb_sto = 40;                      // Sends time out in 20 sec
    ncb->ncb_command = NCBLISTEN | ASYNCH;  // Listen (no wait)

    return(MsgCallNetBios(net,ncb,ncbi));   // Issue the net bios call
}

/*
 *  MsgVerifySmb - Verify the correctness of a Server Message Block
 *
 *  This function verifies that a Server Message Block is properly
 *  formed.  If it detects a malformed SMB, it terminates the session
 *  and returns a non-zero value.
 *
 *  MsgVerifySmb (net, ncbi, func, parms, buffers)
 *
 *  ENTRY
 *    net    - network index
 *    ncbi    - index to a Network Control Block
 *    func    - SMB function code
 *    parms    - number of parameters in SMB
 *    buffers    - dope vector describing buffers in the SMB
 *
 *  RETURN
 *    int    - error code (zero means no error)
 *
 *  SIDE EFFECTS
 *
 *  Calls smbcheck() to check the SMB.  Calls MsgRestart() if
 *  smbcheck() reports an error.
 */

STATIC int
MsgVerifySmb(
    DWORD           net,        // Which network?
    DWORD           ncbi,       // Index to Network Control Block
    UCHAR           func,       // SMB function code
    int             parms,      // Count of parameters in SMB
    LPSTR           buffers     // Dope vector of SMB buffers
    )
{
    PNCB        ncb;            // Pointer to Network Control Block
    int         i;              // Return code


    ncb = GETNCB(net,ncbi); // Get pointer to NCB

    i = Msgsmbcheck(
            (ncb->ncb_buffer),
            ncb->ncb_length,
            func,
            (char)parms,
            buffers);

    if (i != 0 ) {

        //
        // if SMB malformed, Enter error in system error log
        //

        MsgErrorLogWrite(
            NELOG_SMB_Illegal,
            SERVICE_MESSENGER,
            (LPBYTE)ncb->ncb_buffer,
            ncb->ncb_length,
            NULL,
            0);

        MSG_LOG(ERROR,"MsgVerifySmb:An illegal SMB was received\n",0);
        //
        // HANGUP
        //
        MsgRestart(net,ncbi);
    }
    return(i);                // Return error code
}

#if DBG
VOID
MsgDumpNcb(
    IN PNCB     pNcb
    )

/*++

Routine Description:

    Displays the NCB on a debug terminal.

Arguments:



Return Value:



--*/
{
    DbgPrint("NCBADDR: 0x%x\n"
             "Command: 0x%x\n"
             "RetCode: 0x%x\n"
             "LanaNum: 0x%x\n"
             "CmdCplt: 0x%x\n"
             "Name   : %s\n"
             "callNam: %s\n",
             pNcb, pNcb->ncb_command, pNcb->ncb_retcode, pNcb->ncb_lana_num,
             pNcb->ncb_cmd_cplt, pNcb->ncb_name, pNcb->ncb_callname);

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\servenam.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    servenam.c

Abstract:

    Routines to service name requests.  This file contains the following
    functions:
        FindNewName
        NewName
        ServeNameReqs

Author:

    Dan Lafferty (danl)     26-Jul-1991

Environment:

    User Mode -Win32

Revision History:

    26-Jul-1991     danl
        ported from LM2.0
    17-Oct-1991     JohnRo
        Got rid of a MIPS compiler warning.

--*/
#include "msrv.h"

#include <smbtypes.h>   // needed for smb.h
#include <smb.h>        // Server Message Block definitions
#include <string.h>     // memcpy

#include "msgdata.h"
#include "msgdbg.h"     // MSG_LOG


//
// Local Functions
// 

DWORD            
MsgFindNewName(
    IN DWORD    net      
    );


/*
 *  MsgFindNewName - find a new name
 *
 *  This function scans the name table for a new entry and returns its index.
 *
 *  FindNewName (net)
 *
 *  ENTRY
 *    net        - the network index to use
 *
 *  RETURN
 *    int        - index of new name if found, -1 if none found
 *
 *  This function assumes the shared data segment is accessible.
 */

DWORD            
MsgFindNewName(
    IN DWORD   net      
    )

{
    ULONG     i;

    //
    // Loop to find new name
    //

    for(i = 0; i < NCBMAX(net); ++i) {
        if(SD_NAMEFLAGS(net,i) & NFNEW)

        //
        // Return index if new name found
        //
        return(i);

      }

    return(0xffffffff);         // No new names

}

/*
 *  MsgNewName - process a new name
 *
 *  This function initializes the Network Control Block for a new name
 *  and calls the appropriate function to issue the first net bios call
 *  for that name.
 *
 *  MsgNewName (neti,ncbi)
 *
 *  ENTRY
 *    neti        - Network index
 *    ncbi        - Network Control Block index
 *
 *  RETURN
 *    This function returns the status from calls to MsgStartListen().
 *    In NT when we add a name, we also need to make sure that we can
 *    get a session for that name before telling the user that the  
 *    name was added successfully.  If a failure occurs in StartListen,
 *    that will be returned thru here.
 *
 *
 *  This function assumes the shared data area is accessible.
 */

NET_API_STATUS
MsgNewName(
    IN DWORD   neti,       // Network index
    IN DWORD   ncbi        // Name index
    )

{
    unsigned char   flags;
    NET_API_STATUS  status = NERR_Success;
    PNCB_DATA pNcbData;
    PNCB      pNcb;
    PNET_DATA pNetData;

    //
    // Block until shared data area is free
    //
    MsgDatabaseLock(MSG_GET_EXCLUSIVE,"NetName");

    pNetData = GETNETDATA(neti);
    pNcbData = GETNCBDATA(neti,ncbi);
    pNcb = &pNcbData->Ncb;

    //
    // If name still marked as new
    //
    if (SD_NAMEFLAGS(neti,ncbi) & NFNEW) {

        //
        // Turn off the new name bit
        //
        pNcbData->NameFlags &= ~NFNEW; 
        
        //
        // copy the name into the NCB
        //
        memcpy(pNcb->ncb_name, pNcbData->Name,NCBNAMSZ);

        //
        // Set the buffer address
        //
        pNcb->ncb_buffer = pNcbData->Buffer;

        //
        // Wake up semaphore address
        //
        pNcb->ncb_event = (HANDLE) wakeupSem[neti];

        //
        // Use the LANMAN adapter
        //
        pNcb->ncb_lana_num = pNetData->net_lana_num;

        //
        // Set the name number
        //
        pNcb->ncb_num = pNcbData->NameNum;

        flags = pNcbData->NameFlags;

        //
        // Unlock the share table
        //

        MsgDatabaseLock(MSG_RELEASE, "NewName");


        status = MsgStartListen(neti,ncbi);  // Start listening for messages
        MSG_LOG(TRACE,"MsgNewName: MsgStartListen Status = %ld\n",status);
    }
    else {
        //
        // Unlock the share table
        //
        MsgDatabaseLock(MSG_RELEASE, "NewName");
    }
    return(status);
}

/*
 *  MsgServeNameReqs - service new names
 *
 *  This function scans the name table for new names to process.  It scans
 *  and processes names until no more new names can be found.
 *
 *  MsgServeNameReqs ()
 *
 *  RETURN
 *    nothing
 *
 *  This function gains access to the shared data area, finds and processes
 *  new names until no more can be found, and then releases the shared data
 *  area.
 */

VOID            
MsgServeNameReqs(
    IN DWORD    net     // Net Index
    )
{
    DWORD   i;          // Name index

    //
    // While new names are found, add them.
    //

    while( (i = MsgFindNewName(net)) != -1) {
        MsgNewName(net,i);           
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\smbcheck.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smbcheck.c

Abstract:

    Contains a routine for checking Server Message Block for
    syntactical correctness.

Author:

    Dan Lafferty (danl)     17-Jul-1991

Environment:

    User Mode -Win32

Notes:

    These files assume that the buffers and strings are NOT Unicode - just
    straight ansi.

Revision History:

    17-Jul-1991     danl
        ported from LM2.0

--*/


#include <windows.h>
#include <lmcons.h>     // network constants and stuff
#include <smbtypes.h>   // needed for smb.h
#include <smb.h>        // Server Message Block definitions
#include <string.h>     // strlen
#include <nb30.h>       // Needed in msrv.h

/*
**  Msgsmbcheck - check Server Message Block for syntactical correctness
**
**  This function is called to verify that a Server Message Block
**  is of the specified form.  The function returns zero if the
**  SMB is correct; if an error is detected, a non-zero value
**  indicating the nature of the error is returned.
**
**  smbcheck (buffer, size, func, parms, fields)
**
**  ENTRY
**   buffer   - a pointer to the buffer containing the SMB
**   size   - the number of bytes in the buffer
**   func   - the expected SMB function code
**   parms   - the expected number of parameters
**   fields   - a dope vector describing the expected buffer fields
**        within the SMB's buffer area (see below).
**
**  RETURN
**   an integer status code; zero indicates no errors.
**
**  An SMB is a variable length structure whose exact size
**  depends on the setting of certain fixed-offset fields
**  and whose exact format cannot be determined except by
**  examination of the whole structure.  Smbcheck checks to
**  see that an SMB conforms to a set of specified conditions.
**  The "fields" parameter is a dope vector that describes the
**  individual fields to be found in the buffer section at the
**  end of the SMB.  The vector is a null-terminated character
**  string.  Currently, the elements of the string must be as
**  follows:
**
**   'b' - the next element in the buffer area should be
**         a variable length buffer prefixed with a byte
**         containing either 1 or 5 followed by two bytes
**         containing the size of the buffer.
**   'd' - the next element in the buffer area is a null-terminated
**         string prefixed with a byte containing 2.
**   'p' - the next element in the buffer area is a null-terminated
**         string prefixed with a byte containing 3.
**   's' - the next element in the buffer area is a null-terminated
**         string prefixed with a byte containing 4.
**
**  SIDE EFFECTS
**
**  none
**/

int
Msgsmbcheck(
    LPBYTE  buffer,     // Buffer containing SMB
    USHORT  size,       // size of SMB buffer (in bytes)
    UCHAR   func,       // Function code
    int     parms,      // Parameter count
    LPSTR   fields      // Buffer fields dope vector
    )

{
    PSMB_HEADER     smb;        // SMB header pointer
    LPBYTE          limit;      // Upper limit
    int             errRet = 0;


    smb = (PSMB_HEADER) buffer;         // Overlay header with buffer

    //
    // Must be long enough for header
    //
    if(size <= sizeof(SMB_HEADER)) {
        return(2);
    }

    //
    // Message type must be 0xFF
    //
    if(smb->Protocol[0] != 0xff) {
        return(3);
    }

    //
    // Server must be "SMB"
    //
    if( smb->Protocol[1] != 'S'   ||
        smb->Protocol[2] != 'M'   ||
        smb->Protocol[3] != 'B')  {
        return(4);
    }

    //
    // Must have proper function code
    //
    if(smb->Command != func) {
        return(5);
    }

    limit = &buffer[size];              // Set upper limit of SMB

    buffer += sizeof(SMB_HEADER);       // Skip over header

    //
    // Parameter counts must match
    //
    if(*buffer++ != (BYTE)parms) {
        return(6);
    }

    //
    // Skip parameters and buffer size
    //
    buffer += (((SHORT)parms & 0xFF) + 1)*sizeof(SHORT);

    //
    // Check for overflow
    //
    if(buffer > limit) { // 342440: RC2SS:MSGSVC: Off by one error in Msgsmbcheck
                         // JonN 8/9/99: I'm not convinced that this should be >=, if
                         // the dope vector is empty then this is correct
        return(7);
    }

    //
    // Loop to check buffer fields
    //
    try {

    while(*fields) {

            //
            // Check for overflow
            //
            if(buffer >= limit) {
                errRet = 14;
                break;
            }

            //
            // Switch on dope vector character
            //
            switch(*fields++)  {

            case 'b':       // Variable length data block

                if(*buffer != '\001' && *buffer != '\005') {
                    errRet = 8;
                    break;
                }

                //
                // Check for block code
                //

                // 342440: RC2SS:MSGSVC: Off by one error in Msgsmbcheck
                if(buffer+3 > limit) {
                    errRet = 15;
                    break;
                }

                ++buffer;                                       // Skip over block code
                size =  (USHORT)*buffer++ & (USHORT)0xFF;       // Get low-byte size
                size += ((USHORT)*buffer++ & (USHORT)0xFF)<< 8; // Get high-byte of buffer size
                buffer += size;                                 // Increment pointer

                break;

            case 'd':       // Null-terminated dialect string

                if(*buffer++ != '\002') {           // Check for string code
                    errRet = 9;
                    break;
                }
                // 342440: RC2SS:MSGSVC: Off by one error in Msgsmbcheck
                // buffer += strlen(buffer) + 1;       // Skip over the string
                for ( ; buffer < limit; buffer++) {
                    if ('\0' == *buffer)
                        break;
                }
                buffer++;

                break;

            case 'p':       // Null-terminated path string

                if(*buffer++ != '\003') {           // Check for string code
                    errRet = 10;
                    break;
                }
                // 342440: RC2SS:MSGSVC: Off by one error in Msgsmbcheck
                // buffer += strlen(buffer) + 1;       // Skip over the string
                for ( ; buffer < limit; buffer++) {
                    if ('\0' == *buffer)
                        break;
                }
                buffer++;
                break;

            case 's':       // Null-terminated string

                if(*buffer++ != '\004') {           // Check for string code
                    errRet = 11;
                    break;
                }
                // 342440: RC2SS:MSGSVC: Off by one error in Msgsmbcheck
                // buffer += strlen(buffer) + 1;       // Skip over the string
                for ( ; buffer < limit; buffer++) {
                    if ('\0' == *buffer)
                        break;
                }
                buffer++;

                break;
            }

            if ( errRet ) {
                break;
            }

            //
            // Check against end of block
            //

            if(buffer > limit) {
                errRet = 12;
                break;
            }
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return(13);
    }
    return(errRet ? errRet : (buffer != limit) );      // Should be false
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\threads.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    threads.c

Abstract:

    This file contains routines that manage access to a database of
    worker thread handles and a database containing the current messenger
    status (used to report status to the Service Controller).  Access to
    these two databases is controled via a Critical Section.

    Functions for managing worker threads:

        MsgThreadManagerInit
        MsgThreadCloseAll

    Routines for managing _access to the status information and reporting:

        MsgStatusInit
        MsgBeginForcedShutdown
        MsgStatusUpdate
        GetMsgrState

Author:

    Dan Lafferty (danl)     17-Jul-1991

Environment:

    User Mode -Win32

Notes:

    These functions must be used carefully in order to be effective in
    shutting the messenger threads down nicely if the shutdown happens
    to occur during Messenger Initialization.  This note explains when
    each function is to be called.

    MsgThreadManagerInit
        This function must be called early on in the initialization process.
        It should be called before NetRegisterCtrlDispatcher.  This way,
        it is impossible for an UNINSTALL request to be received prior to
        initializing the Critical Section and the Messenger State.


Revision History:

    15-Dec-1998     jschwart
        Eliminated MsgThreadManagerEnd.  The DLL is no longer unloaded by
        services.exe, so deleting the critical section can create a race
        condition (stop service, new service starts and calls init, first
        thread deletes critsec, first thread tries to enter critsec and AVs)

    03-Nov-1992     Danl
        Changed status reporting so that we only accept STOP controls if
        the service is in the RUNNING state.

    18-Feb-1992     RitaW
        Convert to Win32 service control APIs.

    02-Oct-1991     JohnRo
        Work toward UNICODE.

    17-Jul-1991     danl
        created

--*/
//
// Includes
//
#include "msrv.h"

#include <string.h>     // strlen

#include <winsvc.h>     // SERVICE_STATUS
#include <netlib.h>     // UNUSED Macro
#include "msgdbg.h"     // MSG_LOG
#include "msgdata.h"

//
// Global Data
//

RTL_RESOURCE     g_StateResource;
SERVICE_STATUS   MsgrStatus;
DWORD            HintCount;
DWORD            MsgrUninstallCode;  // reason for uninstalling
BOOL             g_fResourceCreated;
DWORD            MsgrState;



DWORD
MsgThreadManagerInit(
    VOID
    )

/*++

Routine Description:

    Initializes the critical section that is used to guard access to the
    thread and status database.  Note that this critsec is created and
    never deleted (OK since the DLL is never unloaded by services.exe) to
    fix synchronization problems with stopping/restarting the service.

Arguments:

    none

Return Value:

    NO_ERROR on success, ERROR_NOT_ENOUGH_MEMORY if the init fails

Note:


--*/
{
    DWORD     dwError = NO_ERROR;
    NTSTATUS  status;

    if (!g_fResourceCreated)
    {
        status = MsgInitResource(&g_StateResource);

        if (NT_SUCCESS(status))
        {
            g_fResourceCreated = TRUE;
        }
        else
        {
            MSG_LOG1(ERROR,
                     "MsgThreadManagerInit:  MsgInitResource failed %#x\n",
                     status);

            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return dwError;
}


VOID
MsgThreadCloseAll(
    VOID
    )

/*++

Routine Description:

    Closes all handles stored in the table of worker thread handles.

Arguments:

    none

Return Value:

    none

Note:


--*/
{
    RtlAcquireResourceExclusive(&g_StateResource, TRUE);
    MsgrState = STOPPING;
    RtlReleaseResource(&g_StateResource);
}



VOID
MsgStatusInit(VOID)

/*++

Routine Description:

    Initializes the status database.

Arguments:

    none.

Return Value:

    none.

Note:


--*/
{
    RtlAcquireResourceExclusive(&g_StateResource, TRUE);

    MsgrState = STARTING;

    HintCount = 1;
    MsgrUninstallCode = 0;

    MsgrStatus.dwServiceType        = SERVICE_WIN32;
    MsgrStatus.dwCurrentState       = SERVICE_START_PENDING;
    MsgrStatus.dwControlsAccepted   = 0;
    MsgrStatus.dwCheckPoint         = HintCount;
    MsgrStatus.dwWaitHint           = 20000;  // 20 seconds

    SET_SERVICE_EXITCODE(
        NO_ERROR,
        MsgrStatus.dwWin32ExitCode,
        MsgrStatus.dwServiceSpecificExitCode
        );


    RtlReleaseResource(&g_StateResource);
    return;
}


DWORD
MsgBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    ExitCode
    )

/*++

Routine Description:

    This function is called to set the appropriate status when a shutdown
    is to occur due to an error in the Messenger.  NOTE:  if a shutdown is
    based on a request from the Service Controller, MsgStatusUpdate is
    called instead.

    On a PENDING call, this routine will also wake up all messenger
    threads so that they will also shut down.


Arguments:

    PendingCode - Indicates if the Shutdown is immediate or pending.  If
        PENDING, the shutdown will take some time, so a pending status is
        sent to the ServiceController.

    ExitCode - Indicates the reason for the shutdown.

Return Value:

    CurrentState - Contains the current state that the messenger is in
        upon exit from this routine.  In this case it will be STOPPED
        if the PendingCode is PENDING, or STOPPING if the PendingCode
        is IMMEDIATE.

Note:


--*/
{
    NET_API_STATUS  status;

    RtlAcquireResourceExclusive(&g_StateResource, TRUE);

    //
    // See if the messenger is already stopping for some reason.
    // It could be that the ControlHandler thread received a control to
    // stop the messenger just as we decided to stop ourselves.
    //
    if ((MsgrState != STOPPING) && (MsgrState != STOPPED)) {
        if (PendingCode == PENDING) {
            MsgrStatus.dwCurrentState = SERVICE_STOP_PENDING;
            MsgrState = STOPPING;
        }
        else {
            //
            // The shutdown is to take immediate effect.
            //
            MsgrStatus.dwCurrentState = SERVICE_STOPPED;
            MsgrStatus.dwControlsAccepted = 0;
            MsgrStatus.dwCheckPoint = 0;
            MsgrStatus.dwWaitHint = 0;
            MsgrState = STOPPED;
        }

        MsgrUninstallCode = ExitCode;

        SET_SERVICE_EXITCODE(
            ExitCode,
            MsgrStatus.dwWin32ExitCode,
            MsgrStatus.dwServiceSpecificExitCode
            );
    }

    //
    // Send the new status to the service controller.
    //
    if (MsgrStatusHandle == (SERVICE_STATUS_HANDLE) NULL) {
        MSG_LOG(ERROR,
            "MsgBeginForcedShutdown, no handle to call SetServiceStatus\n", 0);

    }
    else if (! SetServiceStatus( MsgrStatusHandle, &MsgrStatus )) {

        status = GetLastError();

        if (status != NERR_Success) {
            MSG_LOG(ERROR,
                "MsgBeginForcedShutdown,SetServiceStatus Failed %X\n",
                status);
        }
    }

    status = MsgrState;
    RtlReleaseResource(&g_StateResource);
    return status;
}


DWORD
MsgStatusUpdate(
    IN DWORD    NewState
    )

/*++

Routine Description:

    Sends a status to the Service Controller via SetServiceStatus.

    The contents of the status message is controlled by this routine.
    The caller simply passes in the desired state, and this routine does
    the rest.  For instance, if the Messenger passes in a STARTING state,
    This routine will update the hint count that it maintains, and send
    the appropriate information in the SetServiceStatus call.

    This routine uses transitions in state to send determine which status
    to send.  For instance if the status was STARTING, and has changed
    to RUNNING, this routine sends out an INSTALLED to the Service
    Controller.

Arguments:

    NewState - Can be any of the state flags:
                UPDATE_ONLY - Simply send out the current status
                STARTING - The Messenger is in the process of initializing
                RUNNING - The Messenger has finished with initialization
                STOPPING - The Messenger is in the process of shutting down
                STOPPED - The Messenger has completed the shutdown.

Return Value:

    CurrentState - This may not be the same as the NewState that was
        passed in.  It could be that the main thread is sending in a new
        install state just after the Control Handler set the state to
        STOPPING.  In this case, the STOPPING state will be returned so as
        to inform the main thread that a shut-down is in process.

Note:


--*/

{
    DWORD       status;
    BOOL        inhibit = FALSE;    // Used to inhibit sending the status
                                    // to the service controller.

    RtlAcquireResourceExclusive(&g_StateResource, TRUE);


    if (NewState == STOPPED) {
        if (MsgrState == STOPPED) {
            //
            // It was already stopped, don't send another SetServiceStatus.
            //
            inhibit = TRUE;
        }
        else {
            //
            // The shut down is complete, indicate that the messenger
            // has stopped.
            //
            MsgrStatus.dwCurrentState =  SERVICE_STOPPED;
            MsgrStatus.dwControlsAccepted = 0;
            MsgrStatus.dwCheckPoint = 0;
            MsgrStatus.dwWaitHint = 0;

            SET_SERVICE_EXITCODE(
                MsgrUninstallCode,
                MsgrStatus.dwWin32ExitCode,
                MsgrStatus.dwServiceSpecificExitCode
                );
        }
        MsgrState = NewState;
    }
    else {
        //
        // We are not being asked to change to the STOPPED state.
        //
        switch(MsgrState) {

        case STARTING:
            if (NewState == STOPPING) {

                MsgrStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                MsgrStatus.dwControlsAccepted = 0;
                MsgrStatus.dwCheckPoint = HintCount++;
                MsgrStatus.dwWaitHint = 20000;  // 20 seconds
                MsgrState = NewState;
            }

            else if (NewState == RUNNING) {

                //
                // The Messenger Service has completed installation.
                //
                MsgrStatus.dwCurrentState =  SERVICE_RUNNING;
                MsgrStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
                MsgrStatus.dwCheckPoint = 0;
                MsgrStatus.dwWaitHint = 0;

                MsgrState = NewState;
            }

            else {
                //
                // The NewState must be STARTING.  So update the pending
                // count
                //

                MsgrStatus.dwCurrentState =  SERVICE_START_PENDING;
                MsgrStatus.dwControlsAccepted = 0;
                MsgrStatus.dwCheckPoint = HintCount++;
                MsgrStatus.dwWaitHint = 20000;  // 20 seconds
            }
            break;

        case RUNNING:
            if (NewState == STOPPING) {

                MsgrStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                MsgrStatus.dwControlsAccepted = 0;
                MsgrStatus.dwCheckPoint = HintCount++;
                MsgrStatus.dwWaitHint = 20000;  // 20 seconds

                MsgrState = NewState;
            }

            break;

        case STOPPING:
            //
            // No matter what else was passed in, force the status to
            // indicate that a shutdown is pending.
            //
            MsgrStatus.dwCurrentState =  SERVICE_STOP_PENDING;
            MsgrStatus.dwControlsAccepted = 0;
            MsgrStatus.dwCheckPoint = HintCount++;
            MsgrStatus.dwWaitHint = 20000;  // 20 seconds

            break;

        case STOPPED:
            //
            // We're already stopped.  Therefore, an uninstalled status
            // as already been sent.  Do nothing.
            //
            inhibit = TRUE;
            break;
        }
    }

    if (!inhibit) {
        if (MsgrStatusHandle == (SERVICE_STATUS_HANDLE) NULL) {
            MSG_LOG(ERROR,
                "MsgStatusUpdate, no handle to call SetServiceStatus\n", 0);

        }
        else if (! SetServiceStatus( MsgrStatusHandle, &MsgrStatus )) {

            status = GetLastError();

            if (status != NERR_Success) {
                MSG_LOG(ERROR,
                    "MsgStatusUpdate, SetServiceStatus Failed %d\n",
                    status);
            }
        }
    }

    status = MsgrState;
    RtlReleaseResource(&g_StateResource);
    return status;
}


DWORD
GetMsgrState (
    VOID
    )

/*++

Routine Description:

    Obtains the state of the Messenger Service.  This state information
    is protected as a critical section such that only one thread can
    modify or read it at a time.

Arguments:

    none

Return Value:

    The Messenger State is returned as the return value.

--*/
{
    DWORD   status;

    RtlAcquireResourceShared(&g_StateResource, TRUE);
    status = MsgrState;
    RtlReleaseResource(&g_StateResource);

    return status;
}


VOID
MsgrBlockStateChange(
    VOID
    )
{
    RtlAcquireResourceShared(&g_StateResource, TRUE);
}


VOID
MsgrUnblockStateChange(
    VOID
    )
{
    RtlReleaseResource(&g_StateResource);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\winstmsg.c ===
/*************************************************************************
*
* winstmsg.c
*
* Handle the directing of messages to a specific Session
* for the event notification service. (net send NAME msg...)
*
*
* This also supports directing print spooler messages sent to
* the machine name to the Session of the user who spooled the
* request.
*
*************************************************************************/

//
// Includes
//
#include "msrv.h"
#include <msgdbg.h>     // STATIC and MSG_LOG
#include <string.h>     // memcpy
#include <wchar.h>
#include <winuser.h>    // MessageBox
#include "msgdata.h"    // GlobalMsgDisplayEvent



#define CONSOLE_LOGONID  0

BOOL  g_IsTerminalServer;

PWINSTATION_QUERY_INFORMATION   gpfnWinStationQueryInformation;
PWINSTATION_SEND_MESSAGE        gpfnWinStationSendMessage;
PWINSTATION_FREE_MEMORY         gpfnWinStationFreeMemory;
PWINSTATION_ENUMERATE           gpfnWinStationEnumerate;


//
// Functions defined here
//

BOOL 
InitializeMultiUserFunctionsPtrs (void);

void 
SendMessageBoxToSession(LPWSTR  pMessage,
                        LPWSTR  pTitle,
                        ULONG   SessionId
                        );

/*****************************************************************************
 *
 *  MultiUserInitMessage
 *
 *   Init the _HYDRA_ message support.
 *
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/


NET_API_STATUS
MultiUserInitMessage( VOID )
{
    HANDLE hInst;
    NET_API_STATUS  Status = NERR_Success;

    MSG_LOG(TRACE,"Entering MultiUserInitMessage\n",0)

    g_IsTerminalServer = !!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));

    if (g_IsTerminalServer)
    {
        if ( !InitializeMultiUserFunctionsPtrs() )
        {
            Status = NERR_InternalError;
        }
    }

    return Status;
}
/****************************************************************************\
*
* FUNCTION: InitializeMultiUserFunctions
*
* PURPOSE:  Load Winsta.dll and store function pointers
*
* HISTORY:
*
*
\****************************************************************************/
BOOL
InitializeMultiUserFunctionsPtrs (void)
{

    HANDLE          dllHandle;

    //
    // Load winsta.dll
    //
    dllHandle = LoadLibraryW(L"winsta.dll");
    if (dllHandle == NULL) {
        return FALSE;
    }

    //
    // get the pointers to the required functions
    //

    //WinStationQueryInformationW
     gpfnWinStationQueryInformation = (PWINSTATION_QUERY_INFORMATION) GetProcAddress(
                                                                        dllHandle,
                                                                        "WinStationQueryInformationW"
                                                                       );
    if (gpfnWinStationQueryInformation == NULL) {
        DbgPrint("InitializeMultiUserFunctions: Failed to get WinStationQueryInformationW Proc %d\n",GetLastError());
        FreeLibrary(dllHandle);
        return FALSE;
    }

    //WinStationEnumerateW
    gpfnWinStationEnumerate = (PWINSTATION_ENUMERATE) GetProcAddress(
                                                                     dllHandle,
                                                                     "WinStationEnumerateW"
                                                                     );
    if (gpfnWinStationEnumerate == NULL) {
        DbgPrint("InitializeMultiUserFunctions: Failed to get WinStationEnumerateW Proc %d\n",GetLastError());
        FreeLibrary(dllHandle);
        return FALSE;
    }

    //WinStationSendMessageW

    gpfnWinStationSendMessage = (PWINSTATION_SEND_MESSAGE) GetProcAddress(
                                                                          dllHandle,
                                                                          "WinStationSendMessageW"
                                                                          );
    if (gpfnWinStationSendMessage == NULL) {
        DbgPrint("InitializeMultiUserFunctions: Failed to get WinStationSendMessageW Proc %d\n",GetLastError());
        FreeLibrary(dllHandle);
        return FALSE;
    }

    //WinStationFreeMemory
    gpfnWinStationFreeMemory = (PWINSTATION_FREE_MEMORY) GetProcAddress(
                                                                         dllHandle,
                                                                         "WinStationFreeMemory"
                                                                         );
    if (gpfnWinStationFreeMemory == NULL) {
        DbgPrint("InitializeMultiUserFunctions: Failed to get WinStationFreeMemory Proc %d\n",GetLastError());
        FreeLibrary(dllHandle);
        return FALSE;
    }

    return TRUE;

}
/*****************************************************************************
 *
 *  MsgArrivalBeep
 *
 *   Handle the decision of whether we should Beep the console
 *   when a message arrives.
 *
 * ENTRY:
 *
 *   SessionId
 *     Session Id of the recipient
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
MsgArrivalBeep(
    ULONG SessionId
    )
{
    // very simple, isn'nt it ?

    //
    // only beep on the console
    //
    if (( SessionId == 0) || (SessionId == EVERYBODY_SESSION_ID))
    {
        MessageBeep(MB_OK);
    }

}

/*****************************************************************************
 *
 *  DisplayMessage
 *
 *   Display the incoming message to the proper user, regardless of
 *   whether they are on the Console or a connected Session.
 *
 *   The target user is embedded in the message and must be parsed out.
 *
 * ENTRY:
 *   pMessage (input)
 *     Message to deliver
 *
 *   pTitle (input)
 *     Title for the message box to use
 *
 * EXIT:
 *   TRUE - At least once instance of user was found
 *          and the message sent.
 *
 *   FALSE - No instances of the user on any Sessions where
 *           found.
 *
 ****************************************************************************/

INT
DisplayMessage(
    LPWSTR  pMessage,
    LPWSTR  pTitle,
    ULONG   SessionId
    )
{
    LPWSTR  pName;
    INT Result = FALSE;
    UINT WdCount, i;
    PLOGONID pWd, pWdTmp;

    if (SessionId != EVERYBODY_SESSION_ID)        // if it is not a message broadcasted to every session
    {
        SendMessageBoxToSession(pMessage,
                                pTitle,
                                SessionId);
    }
    else
   {
        // Enumerate the Sessions

        if ( gpfnWinStationEnumerate( SERVERNAME_CURRENT, &pWd, &WdCount ) ) 
        {
            pWdTmp = pWd;
            for( i=0; i < WdCount; i++ ) {

                if  ((pWdTmp->State == State_Connected) ||
                     (pWdTmp->State == State_Active) ||
                     (pWdTmp->State == State_Disconnected))
                {
                    SendMessageBoxToSession(pMessage,
                                            pTitle,
                                            pWdTmp->SessionId);
                }

                pWdTmp++;
            }

            // Free enumeration memory

            gpfnWinStationFreeMemory(pWd);

        }
        else
        {
            MSG_LOG (ERROR, "DisplayMessageW: WinStationEnumerate failed, error = %d:\n",GetLastError());

            //
            // Termsrv is now started by default on platforms so if this fails there is something wrong in termsrv
        }
    }

    return (TRUE);

}



/*****************************************************************************
 *
 *  SendMessageBoxToSession 
 *
 *   Sends the message to the indicated Winstation
 *
 * ENTRY:
 *   pMessage
 *   pTitle
 *   SessionId
 *
 ****************************************************************************/
void 
SendMessageBoxToSession(LPWSTR  pMessage,
                        LPWSTR  pTitle,
                        ULONG   SessionId
                        )
{
    ULONG TitleLength, MessageLength, Response;

    // Now send the message

    TitleLength = (wcslen( pTitle ) + 1) * sizeof(WCHAR);
    MessageLength = (wcslen( pMessage ) + 1) * sizeof(WCHAR);

    if( !gpfnWinStationSendMessage( SERVERNAME_CURRENT,
                                    SessionId,
                                    pTitle,
                                    TitleLength,
                                    pMessage,
                                    MessageLength,
                                    MB_OK | MB_DEFAULT_DESKTOP_ONLY,
                                   (ULONG)-1,
                                    &Response,
                                    TRUE ) ) {

        MSG_LOG(ERROR," Error in WinStationSendMessage for session %d\n", SessionId);
        //
        // We have actually found the user, but some WinStation
        // problem prevented delivery. If we return false here, the
        // top level message service code will try to keep sending the
        // message forever. So we return success here so that the message
        // gets dropped, and we do not hang the msgsvc thread as it
        // continually tries to re-send the message.
        //
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\msgsvc\server\wakupsem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wakeupsem.c

Abstract:

    Contains functions for creating and deleting Events on which the
    messenger threads will wait.  The events get set if either data is
    received, or a new name is added to the name table.  These routines
    were originally written for OS/2 semaphores.

    Contains:
        CreateWakeupSems
        CloseWakeupSems

Author:

    Dan Lafferty (danl) 25-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    25-Jun-1991 danl
        Ported from LM2.0

--*/

#include "msrv.h"
#include "msgdbg.h"     // MSG_LOG
#include <netlib.h>     // UNUSED macro
#include "msgdata.h"


BOOL
MsgCreateWakeupEvent(
    void
    )

/*++

Routine Description:

There is now one master event that is shared by everything.  Create it.

Arguments:

    None

Return Value:

    None

--*/

{
    //
    //  Create event
    //

    wakeupEvent = CreateEvent(
                NULL,       // Event Attributes
                FALSE,      // ManualReset  (auto-reset selected)
                TRUE,       // Initial State(signaled)
                NULL);      // Name

    if (wakeupEvent == NULL) {
        MSG_LOG(ERROR, "CreateWakeupSems:CreateEvent: FAILURE %X\n",
            GetLastError());
        return(FALSE);
    }

    return (wakeupEvent != NULL );
}


VOID
MsgCloseWakeupEvent(
    void
    )

/*++

Routine Description:

Release the master event.

Arguments:

    None

Return Value:

    None

--*/

{
    CLOSE_HANDLE(wakeupEvent, NULL);
}


BOOL
MsgCreateWakeupSems(
    DWORD   NumNets
    )

/*++

Routine Description:

    This routine fills in the WakeupSem array with event handles for
    each net.  All nets share the same event handle, so when the handle
    becomes signalled, the NCB array for each net needs to be examined.

Arguments:


Return Value:


Note:


--*/

{
    DWORD i;

    for ( i = 0; i < NumNets; i++ )  // One per net + one group
    {
        wakeupSem[i] = wakeupEvent;
    }

    return TRUE;
}


VOID
MsgCloseWakeupSems()
{
    // Noop
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\nwsap\saplpc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\saplpc.h

Abstract:

Author:

    Brian Walker (MCS) 06-30-1993

Revision History:

--*/

#ifndef _NWSAP_LPC_
#define _NWSAP_LCP_

/**
    Structure used to pass LPC messages between the client
    library and the main server.  Note the the PORT_MESSAGE is first
    and that the request and reply structures are VERY similar.
**/

typedef struct _NWSAP_REQUEST_MESSAGE {

    PORT_MESSAGE PortMessage;
    ULONG MessageType;

    union {

        struct {
            USHORT  ServerType;
            UCHAR   ServerName[48];
            UCHAR   ServerAddr[12];
            BOOL    RespondNearest;
        } AdvApi;

        struct {
            ULONG   ObjectID;
            UCHAR   ObjectName[48];
            USHORT  ObjectType;
            UCHAR   ObjectAddr[12];
            USHORT  ScanType;
        } BindLibApi;

    } Message;

} NWSAP_REQUEST_MESSAGE, *PNWSAP_REQUEST_MESSAGE;


typedef struct _NWSAP_REPLY_MESSAGE {

    PORT_MESSAGE PortMessage;
    ULONG Error;

    union {

        struct {
            USHORT  ServerType;
            UCHAR   ServerName[48];
            UCHAR   ServerAddr[12];
            BOOL    RespondNearest;
        } AdvApi;

        struct {
            ULONG   ObjectID;
            UCHAR   ObjectName[48];
            USHORT  ObjectType;
            UCHAR   ObjectAddr[12];
            USHORT  ScanType;
        } BindLibApi;

    } Message;
} NWSAP_REPLY_MESSAGE, *PNWSAP_REPLY_MESSAGE;

/** Message Types **/

#define NWSAP_LPCMSG_ADDADVERTISE           0
#define NWSAP_LPCMSG_REMOVEADVERTISE        1
#define NWSAP_LPCMSG_GETOBJECTID            2
#define NWSAP_LPCMSG_GETOBJECTNAME          3
#define NWSAP_LPCMSG_SEARCH                 4

/** Name of our port **/

#define NWSAP_BIND_PORT_NAME_W   L"\\BaseNamedObjects\\NwSapLpcPort"
#define NWSAP_BIND_PORT_NAME_A    "\\BaseNamedObjects\\NwSapLpcPort"

/** Max message length we need **/

#define NWSAP_BS_PORT_MAX_MESSAGE_LENGTH                                         \
    ( sizeof(NWSAP_REQUEST_MESSAGE) > sizeof(NWSAP_REPLY_MESSAGE) ?    \
         sizeof(NWSAP_REQUEST_MESSAGE) : sizeof(NWSAP_REPLY_MESSAGE) )

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\nwsap\client\init.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\client\init.c

Abstract:

    This routine initializes the SAP Library

Author:

    Brian Walker (MCS) 06-15-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

/** Global Variables **/

INT SapLibInitialized = 0;
HANDLE SapXsPortHandle;


/*++
*******************************************************************
        S a p L i b I n i t

Routine Description:

        This routine initializes the SAP interface for a program

Arguments:
            None

Return Value:

            0 = Ok
            Else = Error
*******************************************************************
--*/

DWORD
SapLibInit(
    VOID)
{
    UNICODE_STRING unistring;
    NTSTATUS status;
    SECURITY_QUALITY_OF_SERVICE qos;

    /** If already initialized - return ok **/

    if (SapLibInitialized) {
        return 0;
    }

    /** Connect the port **/

    /** Fill out the security quality of service **/

    qos.Length = sizeof(qos);
    qos.ImpersonationLevel  = SecurityImpersonation;
    qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    qos.EffectiveOnly       = TRUE;

    /** Setup the unicode string of the port name **/

    RtlInitUnicodeString(&unistring, NWSAP_BIND_PORT_NAME_W);

    /** Do the connect **/

    status = NtConnectPort(
            &SapXsPortHandle,           /* We get a handle back     */
            &unistring,                 /* Port name to connect to  */
            &qos,                       /* Quality of service       */
            NULL,                       /* Client View              */
            NULL,                       /* Server View              */
            NULL,                       /* MaxMessageLength         */
            NULL,                       /* ConnectionInformation    */
            NULL);                      /* ConnectionInformationLength */

    /** If error - just return it **/

    if (!NT_SUCCESS(status))
        return status;

    /** All Done **/

    SapLibInitialized = 1;
    return 0;
}


/*++
*******************************************************************
        S a p L i b S h u t d o w n

Routine Description:

        This routine shuts down the SAP interface for a program

Arguments:
            None

Return Value:

            0 = Ok
            Else = Error
*******************************************************************
--*/

DWORD
SapLibShutdown(
    VOID)
{
    /** If not initialized - leave **/

    if (!SapLibInitialized)
        return 0;

    /** Close the port **/

    NtClose(SapXsPortHandle);

    /** All Done **/

    SapLibInitialized = 0;
    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\nwsap\client\advapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\client\advapi.c

Abstract:

    This routine handles the Advertise API for the SAP Agent

Author:

    Brian Walker (MCS) 06-15-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


/*++
*******************************************************************
        S a p A d d A d v e r t i s e

Routine Description:

        This routine adds an entry to the list of servers
        that we advertise.

Arguments:
            ServerName = Ptr to AsciiZ server name
            ServerType = USHORT of object type to add
            ServerAddr = Ptr to 12 byte aerver address
            RespondNearest = TRUE  = Use me for respond nearest call
                             FALSE = Don't use me for respond nearest call

Return Value:

            SAPRETURN_SUCCESS  - Added OK
            SAPRETURN_NOMEMORY - Error allocating memory
            SAPRETURN_EXISTS   - Already exists in list
            SAPRETURN_NOTINIT  - SAP Agent is not running
*******************************************************************
--*/

INT
SapAddAdvertise(
    IN PUCHAR ServerName,
    IN USHORT ServerType,
	IN PUCHAR ServerAddr,
    IN BOOL   RespondNearest)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not running - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** Make sure name is not too long **/

    if (strlen(ServerName) > NWSAP_MAXNAME_LENGTH) {
        return SAPRETURN_INVALIDNAME;
    }

    /** Build the Add Advertise message **/

    request.MessageType = NWSAP_LPCMSG_ADDADVERTISE;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;

    memset(request.Message.AdvApi.ServerName, 0, NWSAP_MAXNAME_LENGTH+1);
    strcpy(request.Message.AdvApi.ServerName, ServerName);
    memcpy(request.Message.AdvApi.ServerAddr, ServerAddr, 12);
    request.Message.AdvApi.ServerType = ServerType;
    request.Message.AdvApi.RespondNearest = RespondNearest;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** Return the entry **/

    memcpy(ServerAddr, reply.Message.AdvApi.ServerAddr, 12);

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}


/*++
*******************************************************************
        S a p R e m o v e A d v e r t i s e

Routine Description:

        This routine removes an entry to the list of servers
        that we advertise.

Arguments:
            ServerName = Ptr to AsciiZ server name
            ServerType = USHORT of object type to remove

Return Value:

            SAPRETURN_SUCCESS  - Added OK
            SAPRETURN_NOTEXIST - Entry does not exist in list
            SAPRETURN_NOTINIT  - SAP Agent is not running
*******************************************************************
--*/

INT
SapRemoveAdvertise(
    IN PUCHAR ServerName,
    IN USHORT ServerType)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not running - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** Make sure name is not too long **/

    if (strlen(ServerName) > NWSAP_MAXNAME_LENGTH) {
        return SAPRETURN_INVALIDNAME;
    }

    /** Build the Add Advertise message **/

    request.MessageType = NWSAP_LPCMSG_REMOVEADVERTISE;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;

    memset(request.Message.AdvApi.ServerName, 0, NWSAP_MAXNAME_LENGTH+1);
    strcpy(request.Message.AdvApi.ServerName, ServerName);
    request.Message.AdvApi.ServerType = ServerType;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\nwsap\client\precomp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\client\precomp.h

Abstract:

    Include files for the SAP Agent library

Author:

    Brian Walker (MCS)	13-Jun-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <stdlib.h>
#include <nwsap.h>
#include "..\saplpc.h"

/** Global Variables **/

extern INT SapLibInitialized;
extern HANDLE SapXsPortHandle;

#define NWSAP_MAXNAME_LENGTH    47

/** Functions **/






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\nwsap\client\bindlib.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\client\bindlib.c

Abstract:

    This routine handles the BindLib API for the SAP Agent

Author:

    Brian Walker (MCS) 06-15-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


/*++
*******************************************************************
        S a p G e t O b j e c t N a m e

Routine Description:

        This routine converts an Object ID into an Object Name
        and Type.

Arguments:
            ObjectID   = Object ID to convert
            ObjectName = Ptr to where to store 48 byte object name
            ObjectType = Ptr to where to store the object type
            ObjectAddr = Ptr to where to store NET_ADDRESS (12 bytes)

            ObjectName, ObjectType, ObjectAddr can be NULL.

Return Value:

            SAPRETURN_SUCCESS  = OK - name and type are filled in
            SAPRETURN_NOTEXIST = Invalid object id.
*******************************************************************
--*/

INT
SapGetObjectName(
    IN ULONG   ObjectID,
    IN PUCHAR  ObjectName,
    IN PUSHORT ObjectType,
    IN PUCHAR  ObjectAddr)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not initialized - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** Build the Get Object Name message **/

    request.MessageType = NWSAP_LPCMSG_GETOBJECTNAME;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;
    request.PortMessage.MessageId         = 0;

    request.Message.BindLibApi.ObjectID = ObjectID;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** Return the entry **/

    if (ObjectType)
        *ObjectType = reply.Message.BindLibApi.ObjectType;

    if (ObjectName)
        memcpy(ObjectName, reply.Message.BindLibApi.ObjectName, NWSAP_MAXNAME_LENGTH+1);

    if (ObjectAddr)
        memcpy(ObjectAddr, reply.Message.BindLibApi.ObjectAddr, 12);

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}


/*++
*******************************************************************
        S a p G e t O b j e c t I D

Routine Description:

        This routine converts a name and type into an object ID.

Arguments:
            ObjectName = Ptr to AsciiZ object name (Must be uppercase)
            ObjectType = Object type to look for
            ObjectID   = Ptr to where to store the object ID.

Return Value:

            SAPRETURN_SUCCESS  = OK - Object ID is filled in
            SAPRETURN_NOTEXIST = Name/Type not found
*******************************************************************
--*/

INT
SapGetObjectID(
    IN PUCHAR ObjectName,
    IN USHORT ObjectType,
	IN PULONG ObjectID)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not initialized - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** If the name is too long - error **/

    if (strlen(ObjectName) > NWSAP_MAXNAME_LENGTH)
        return SAPRETURN_INVALIDNAME;

    /** Build the Get Object Name message **/

    request.MessageType = NWSAP_LPCMSG_GETOBJECTID;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;

    memset(request.Message.BindLibApi.ObjectName, 0, NWSAP_MAXNAME_LENGTH+1);
    strcpy(request.Message.BindLibApi.ObjectName, ObjectName);
    request.Message.BindLibApi.ObjectType = ObjectType;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** Return the entry **/

    *ObjectID = reply.Message.BindLibApi.ObjectID;

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}


/*++
*******************************************************************
        S a p S c a n O b j e c t

Routine Description:

        This routine is used to scan thru the database list.

Arguments:
            ObjectID   = Ptr to last Object ID we saw.  On first call
                         this should point to a 0xFFFFFFFF.
            ObjectName = Ptr to where to store 48 byte object name
            ObjectType = Ptr to where to store the object type
            ScanType   = Object Type that we are scanning for
                         (0xFFFF = All)

            ObjectName, ObjectType can be NULL.

Return Value:

            SAPRETURN_SUCCESS  = OK - name and type are filled in
                                 ObjectID has the object ID of this entry.
            SAPRETURN_NOTEXIST = Invalid object id.
*******************************************************************
--*/

INT
SapScanObject(
    IN PULONG  ObjectID,
    IN PUCHAR  ObjectName,
    IN PUSHORT ObjectType,
    IN USHORT  ScanType)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not initialized - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** Build the Get Object Name message **/

    request.MessageType = NWSAP_LPCMSG_SEARCH;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;

    request.Message.BindLibApi.ObjectID = *ObjectID;
    request.Message.BindLibApi.ScanType = ScanType;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** Return the entry **/

    if (ObjectType)
        *ObjectType = reply.Message.BindLibApi.ObjectType;

    if (ObjectName)
        memcpy(ObjectName, reply.Message.BindLibApi.ObjectName, NWSAP_MAXNAME_LENGTH+1);

    *ObjectID = reply.Message.BindLibApi.ObjectID;

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\repl\client\impstub.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ImpStub.c

Abstract:

    Client stubs of the replicator service import directory APIs.

Author:

    John Rogers (JohnRo) 17-Dec-1991

Environment:

    User Mode - Win32

Revision History:

    17-Dec-1991 JohnRo
        Created dummy file.
    17-Dec-1991 JohnRo
        Actually include my header file (LmRepl.h) so we can test against it.
    17-Jan-1992 JohnRo
        Wrote stubs for first 3 RPCable APIs.
    20-Jan-1992 JohnRo
        Added import APIs, config APIs, and rest of export APIs.
    27-Jan-1992 JohnRo
        Split stubs into 3 files: ReplStub.c, ImpStub.c, and ExpStub.c.
        Changed to use LPTSTR etc.
        Added handling of getinfo and setinfo APIs when service isn't started.
        Tell NetRpc.h macros that we need replicator service.
    05-Feb-1992 JohnRo
        Added debug messages when service is not started.
    13-Feb-1992 JohnRo
        Moved section name equates to ConfName.h.
    21-Feb-1992 JohnRo
        Make NetReplImportDir{Del,Enum,Get,Lock,Unlock} work w/o svc running.
        Fixed usage of union/container.
    21-Feb-1992 JohnRo
        Changed ImportDirBuildApiRecord() so master name is not a UNC name.
    27-Feb-1992 JohnRo
        Preserve state from last time service was running.
        Changed state not started to state never replicated.
    15-Mar-1992 JohnRo
        Update registry with new values.
    23-Mar-1992 JohnRo
        Fixed enum when service is running.
    09-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
        Avoid compiler warnings.
        Use PREFIX_ equates.
    27-Jul-1992 JohnRo
        RAID 2274: repl svc should impersonate caller.
    09-Nov-1992 JohnRo
        RAID 7962: Repl APIs in wrong role kill svc.
        Fix remote repl admin.
    02-Apr-1993 JohnRo
        Use NetpKdPrint() where possible.
        Made changes suggested by PC-LINT 5.0
        Removed some obsolete comments about retrying APIs.
    20-Jan-2000 JSchwart
        No longer supported

--*/


#include <windows.h>
#include <winerror.h>
#include <lmcons.h>     // NET_API_STATUS, etc.


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirAdd (
    IN LPCWSTR UncServerName OPTIONAL,
    IN DWORD Level,
    IN const LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL      // Set implicitly by NetpSetParmError().
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirDel (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirEnum (
    IN LPCWSTR UncServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirGetInfo (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName,
    IN DWORD Level,
    OUT LPBYTE * BufPtr
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirLock (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirUnlock (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName,
    IN DWORD UnlockForce
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\repl\client\replstub.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ReplStub.c

Abstract:

    Client stubs of the replicator service config APIs.

Author:

    John Rogers (JohnRo) 17-Dec-1991

Environment:

    User Mode - Win32

Revision History:

    17-Dec-1991 JohnRo
        Created dummy file.
    17-Dec-1991 JohnRo
        Actually include my header file (LmRepl.h) so we can test against it.
    17-Jan-1992 JohnRo
        Wrote stubs for first 3 RPCable APIs.
    20-Jan-1992 JohnRo
        Added import APIs, config APIs, and rest of export APIs.
    27-Jan-1992 JohnRo
        Split stubs into 3 files: ReplStub.c, ImpStub.c, and ExpStub.c.
        Changed to use LPTSTR etc.
        Added handling of getinfo and setinfo APIs when service isn't started.
        Tell NetRpc.h macros that we need replicator service.
    05-Feb-1992 JohnRo
        Added debug messages when service is not started.
    18-Feb-1992 JohnRo
        NetReplGetInfo() does too much with bad info level.
        Fixed usage of union/container.
        Added code for NetReplSetInfo() when service is not started.
    15-Mar-1992 JohnRo
        Added support for setinfo info levels in ReplConfigIsLevelValid().
    19-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
        Use PREFIX_ equates.
    20-Jul-1992 JohnRo
        RAID 2252: repl should prevent export on Windows/NT.
    14-Aug-1992 JohnRo
        RAID 3601: repl APIs should checked import & export lists.
        Use PREFIX_NETAPI instead of PREFIX_REPL for repl API stubs.
    01-Dec-1992 JohnRo
        RAID 3844: remote NetReplSetInfo uses local machine type.
    05-Jan-1993 JohnRo
        Repl WAN support (get rid of repl name list limits).
        Made changes suggested by PC-LINT 5.0
        Corrected debug bit usage.
        Removed some obsolete comments about retrying APIs.
    20-Jan-2000 JSchwart
        No longer supported

--*/

#include <windows.h>
#include <winerror.h>
#include <lmcons.h>


NET_API_STATUS NET_API_FUNCTION
NetReplGetInfo (
    IN LPCWSTR UncServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * BufPtr
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplSetInfo (
    IN LPCWSTR UncServerName OPTIONAL,
    IN DWORD Level,
    IN const LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\repl\client\expstub.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ExpStub.c

Abstract:

    Client stubs of the replicator service export directory APIs.

Author:

    John Rogers (JohnRo) 17-Dec-1991

Environment:

    User Mode - Win32

Revision History:

    17-Dec-1991 JohnRo
        Created dummy file.
    17-Dec-1991 JohnRo
        Actually include my header file (LmRepl.h) so we can test against it.
    17-Jan-1992 JohnRo
        Wrote stubs for first 3 RPCable APIs.
    20-Jan-1992 JohnRo
        Added import APIs, config APIs, and rest of export APIs.
    27-Jan-1992 JohnRo
        Split stubs into 3 files: ReplStub.c, ImpStub.c, and ExpStub.c.
        Changed to use LPTSTR etc.
        Added handling of getinfo and setinfo APIs when service isn't started.
        Tell NetRpc.h macros that we need replicator service.
    30-Jan-1992 JohnRo
        Made changes suggested by PC-LINT.
    03-Feb-1992 JohnRo
        Corrected NetReplExportDirGetInfo's handling of level errors.
    13-Feb-1992 JohnRo
        Implement NetReplExportDirDel() when svc is not running.
        Added debug messages when processing APIs without service running.
    20-Feb-1992 JohnRo
        Use ExportDirIsLevelValid() where possible.
        Fixed enum when array is empty.
        Fixed forgotten net handle closes in enum code.
        Make NetRepl{Export,Import}Dir{Lock,Unlock} work w/o svc running.
        Fixed usage of union/container.
    15-Mar-1992 JohnRo
        Update registry with new values.
    23-Mar-1992 JohnRo
        Fixed enum when service is running.
    06-Apr-1992 JohnRo
        Fixed trivial MIPS compile problem.
    28-Apr-1992 JohnRo
        Fixed another trivial MIPS compile problem.
    19-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
        Use PREFIX_ equates.
    27-Jul-1992 JohnRo
        RAID 2274: repl svc should impersonate caller.
    26-Aug-1992 JohnRo
        RAID 3602: NetReplExportDirSetInfo fails regardless of svc status.
    29-Sep-1992 JohnRo
        RAID 7962: Repl APIs in wrong role kill svc.
        Also fix remote repl admin.
    05-Apr-1993 JohnRo
        Use NetpKdPrint() where possible.
        Made changes suggested by PC-LINT 5.0
        Removed some obsolete comments about retrying APIs.
    20-Jan-2000 JSchwart
        No longer supported

--*/

#include <windows.h>
#include <winerror.h>
#include <lmcons.h>     // NET_API_STATUS, etc.


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirAdd (
    IN LPCWSTR UncServerName OPTIONAL,
    IN DWORD Level,                     // Must be 1.
    IN const LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirDel (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirEnum (
    IN LPCWSTR UncServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirGetInfo (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName,
    IN DWORD Level,
    OUT LPBYTE * BufPtr
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirLock (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName
    )
{
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirSetInfo (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName,
    IN DWORD Level,
    IN const LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_NOT_SUPPORTED;
}

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirUnlock (
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR DirName,
    IN DWORD UnlockForce
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\seclogon\server\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifdef __cplusplus
    extern "C" 
    {
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000
#define DBG_SS_CATDBSVC                     0x00800000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                DBG_SS_CATDBSVC,    "CATDBSV",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG 

	void DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);


#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define SET_DWRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    dwResult = (DWORD) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)
#define SET_DWRESULT(name,err)          SET_DWRESULT_EX(DBG_SS_CRYPT32,name,err)


#define _JumpCondition(condition, label) \
    if (condition) \
    { \
	goto label; \
    } \
    else { } 

#define _JumpConditionWithExpr(condition, label, expr) \
    if (condition) \
    { \
        expr; \
	goto label; \
    } \
    else { } 

#ifdef __cplusplus
    }       // balance of extern "C"
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\seclogon\notify\resource.h ===
//*************************************************************
//
//  Resource.h      -   Header file for userenv.rc
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uevents.h"

#define IDS_FAILED_GET_DSROLE         1
#define IDS_ERROR_LOAD_USERENV        2
#define IDS_ERROR_GET_PROC_ADDR       3
#define IDS_ERROR_CREATE_GPO_INSTANCE 4
#define IDS_ERROR_OPEN_LPO            5
#define IDS_ERROR_GET_REGISTRY_KEY    6
#define IDS_ERROR_OPEN_EFSKEY         7
#define IDS_ERROR_CREATE_EFSBLOB      8
#define IDS_ERROR_SAVE_EFSBLOB        9
#define IDS_ERROR_SAVE_LPO            10
#define IDS_ERROR_GET_DSROOT          11
#define IDS_ERROR_BIND_DS             12
#define IDS_DEFAULT_EFS_POLICY        13
#define IDS_DEFAULT_DOMAIN_POLICY     14
#define IDS_ERROR_LINK_GPO            15
#define IDS_ERROR_NO_MEMORY           16
#define IDS_ERROR_GET_EFS_GPOPATH     17
#define IDS_ERROR_GET_DEFAULT_GPOPATH 18
#define IDS_ERROR_NEW_GPO             19
#define IDS_ERROR_GETGPO_FILE_PATH    20
#define IDS_ERROR_CREATE_DIRECTORY    21
#define IDS_ERROR_COPY_TEMPLATE       22
#define IDS_ERROR_GETGPO_REGKEY       23
#define IDS_ERROR_SAVE_GPO            24
#define IDS_ERROR_ADD_CERTIFICATE     25
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\seclogon\notify\recovery.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    recovery.cpp

Abstract:

    This module implements the callout from winlogon to set
    recovery policy.

Author:

    Robert Reichel (RobertRe)

Revision History:

--*/

//
// Turn off lean and mean so we get wincrypt.h and winefs.h included
//

#undef WIN32_LEAN_AND_MEAN

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <stdio.h>
#include <lmcons.h>
#include <cryptui.h>
#include <winwlx.h>
#include <malloc.h>
#include <feclient.h>
#include <efsstruc.h>
#include <netlib.h>
#include <secobj.h>

#include <initguid.h>
#include <gpedit.h>
#include <wincrypt.h>
#include <winreg.h>
#include <dsrole.h>


#include <winldap.h>
#include <dsgetdc.h>
#include <ntdsapi.h>

#include "sclgntfy.hxx"

#define YEARCOUNT (LONGLONG) 10000000*3600*24*365 // One Year's tick count

typedef BOOL (WINAPI *PFREFRESHPOLICY)(BOOL);

extern  HINSTANCE g_hDllInstance;

HANDLE  hEventLog = NULL;
TCHAR   EventSourceName[] = TEXT("SclgNtfy");

GUID guidExtension = { 0xb1be8d72, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a }};
GUID guidRegExt = REGISTRY_EXTENSION_GUID;
GUID guidSnapin = {0x53D6AB1B,0x2488,0x11d1,{0xA2,0x8C,0x00,0xC0,0x4F,0xB9,0x4F,0x17}}; // CLSID_CertificateManager

//
// Event handle
//

PTOKEN_USER
GetTokenUser(
    HANDLE TokenHandle
    );

BOOLEAN
CreateSelfSignedRecoveryCertificate(
    IN BOOL bIsDC,
    OUT PCCERT_CONTEXT * pCertContext
    );

BOOL
EncodeAndAlloc(
    DWORD dwEncodingType,
    LPCSTR lpszStructType,
    const void * pvStructInfo,
    PBYTE * pbEncoded,
    PDWORD pcbEncoded
    );

LPWSTR
MakeDNName(
    VOID
    );

DWORD
CreatePublicKeyInformationCertificate(
    IN PSID  pUserSid OPTIONAL,
    PBYTE pbCert,
    DWORD cbCert,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation
    );

DWORD
GetDefaultRecoveryPolicy(
    IN HANDLE hToken,
    IN BOOL bIsDC,
    OUT PUCHAR *pRecoveryPolicyBlob,
    OUT ULONG *PolicySize,
    OUT PCCERT_CONTEXT *ppCertContext
    );

HRESULT
CreateLocalMachinePolicy(
    IN PWLX_NOTIFICATION_INFO pInfo,
    IN BOOL bIsDC,
    OUT PUCHAR *pEfsBlob,
    OUT ULONG *pEfsSize,
    OUT PCCERT_CONTEXT *ppCertContext
    );

typedef DWORD (WINAPI *PFNDSGETDCNAME)(LPCTSTR, LPCTSTR, GUID *, LPCTSTR, ULONG, PDOMAIN_CONTROLLER_INFO *);

HRESULT
CreateEFSDefaultPolicy(
    IN HANDLE    hToken,
    IN PUCHAR    *pEfsBlob,
    IN DWORD     *pEfsSize,
    IN PCCERT_CONTEXT *ppCertContext,
    IN LPTSTR DomainName
    );

DWORD
MyLdapOpen(
    OUT PLDAP *pLdap
    );

DWORD
MyGetDsObjectRoot(
    IN PLDAP pLdap,
    OUT PWSTR *pDsRootName
    );

HRESULT
CreateGroupPolicyObjectInDomain(
    IN HANDLE hToken,
    IN PWSTR DomainNCName,
    IN PWSTR GPObjectName,
    IN PUCHAR EfsBlob,
    IN ULONG EfsSize,
    IN PCCERT_CONTEXT pCertContext,
    OUT LPGROUPPOLICYOBJECT *ppObject
    );

DWORD
CheckExistingEFSPolicy(
    IN PLDAP phLdap,
    IN LPTSTR DomainNCName,
    OUT BOOL *bExist
    );

DWORD
MyLdapClose(
    IN PLDAP *pLdap
    );

LPWSTR
GetCertDisplayInformation(
    IN PCCERT_CONTEXT pCertContext
    );

BOOLEAN
IsSelfSignedPolicyExpired(
    IN PRECOVERY_POLICY_1_1 RecoveryPolicy OPTIONAL
    );

#define EFS_NOTIFY_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\EFS")


extern "C"
BOOL
EfsRecInit(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServerEFS(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp;

    lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                              EFS_NOTIFY_PATH,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp
                              );

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegSetValueEx( hKey,
                   TEXT("Logon"),
                   0,
                   REG_SZ,
                   (LPBYTE)TEXT("WLEventLogon"),
                   (lstrlen(TEXT("WLEventLogon")) + 1) * sizeof(TCHAR)
                   );

    RegSetValueEx( hKey,
                   TEXT("DllName"),
                   0,
                   REG_EXPAND_SZ,
                   (LPBYTE)TEXT("sclgntfy.dll"),
                   (lstrlen(TEXT("sclgntfy.dll")) + 1) * sizeof(TCHAR)
                   );
    //
    // increase the wait limit to 10 minutes
    //
    DWORD dwValue = 120;

    RegSetValueEx( hKey,
                   TEXT("MaxWait"),
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(DWORD)
                   );

    RegCloseKey (hKey);

    return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServerEFS(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, EFS_NOTIFY_PATH);

    return S_OK;
}


DWORD WINAPI
EFSRecPolicyPostProcess(
    IN LPVOID Param
    )
/*++
Routine Description:

    Enumerate the volumes and do the possible recovery jobs caused by
    power outage or crash during encryption or decryption.

Arguments:

    Param -- Standard parameter for thread. Not used.

Return Value:

    Operation result.

--*/
{
    PEFS_POLICY_POST_PROCESS pPcType = (PEFS_POLICY_POST_PROCESS) Param;
    LPWSTR  objName = NULL;
    LPWSTR  popUpMsg = NULL;
    LPWSTR  popUpTitle = NULL;
    DWORD   dRet;

    DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1;

    if ( pPcType == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if (!SetThreadDesktop( pPcType->ShellWnd )){
        return GetLastError();
    }

    if (!(pPcType->PCIsDC)) {

        //
        // Get the PC name
        //

        BOOL b = GetComputerName ( pPcType->ObjName, &nSize );

        if (b) {
            objName = pPcType->ObjName;
        }

    } else {
        objName = pPcType->ObjName;
    }

    dRet = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        g_hDllInstance,
        EFS_POLICY_WARNING,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &popUpMsg,
        0,
        (va_list *)&objName
        );

    if (dRet) {
        dRet = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY | 80,
                    g_hDllInstance,
                    EFS_POLICY_WARNING_TITLE,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &popUpTitle,
                    0,
                    NULL
                    );
        if (dRet) {
            MessageBox(NULL, popUpMsg, popUpTitle, MB_OK | MB_ICONINFORMATION);
            LocalFree( popUpTitle );
        }
        LocalFree( popUpMsg );
    }

    //
    // free the buffer allocated
    //
    LocalFree(pPcType);

    return 0;

}

#if 0
DWORD
EFSRecPolicyPopup(
    IN DSROLE_MACHINE_ROLE MachineRole,
    IN LPTSTR DomainNameFlat OPTIONAL
    )
{

    DWORD EFSRecPolicyThreadID;
    HANDLE EfsWarningThread;
    PEFS_POLICY_POST_PROCESS PcType = NULL;

    //
    // Pop the dialog warning the user that the recovery policy has been created.
    //

    PcType = (PEFS_POLICY_POST_PROCESS)LocalAlloc(LPTR, sizeof(EFS_POLICY_POST_PROCESS));

    if ( PcType == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (MachineRole == DsRole_RolePrimaryDomainController ||
        MachineRole == DsRole_RoleBackupDomainController ) {

        //
        // The PC is a DC.
        //

        PcType->PCIsDC = TRUE;
        if ( DomainNameFlat) {
            wcscpy(PcType->ObjName,DomainNameFlat);
        } else {
            PcType->ObjName[0] = L'\0';
        }

    } else {

        PcType->PCIsDC = FALSE;
        PcType->ObjName[0] = L'\0';

    }

    DWORD rc=ERROR_SUCCESS;

    PcType->ShellWnd = GetThreadDesktop( GetCurrentThreadId() );

    if (PcType->ShellWnd) {

        EfsWarningThread = CreateThread( NULL,
                              0,
                              EFSRecPolicyPostProcess,
                              PcType,
                              0,
                              &EFSRecPolicyThreadID
                              );
        if (EfsWarningThread) {
            CloseHandle(EfsWarningThread);
        } else {
            //
            // free the buffer allocated
            //
            LocalFree(PcType);
            rc = GetLastError();
        }

    } else {
        //
        // free the buffer allocated
        //
        LocalFree(PcType);
        rc = GetLastError();
    }

    return rc;

}
#endif

VOID WLEventLogon(
    PWLX_NOTIFICATION_INFO pInfo
    )
{

    //
    // First, local EFS policy is always created on all products (wks, srv, DC)
    //

    DWORD rc;
    LONG lResult;
    HKEY hKey;
    DWORD IsCreated=0;

    //
    // even if we were unregistered, without a reboot, we still get this event.
    // use the EFS... key to see if we were deregistered, and if so, leave.
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            EFS_NOTIFY_PATH,
                            0,
                            MAXIMUM_ALLOWED,
                            &hKey
                            );

    if (lResult != ERROR_SUCCESS) {
        return;
    } else {

        //
        // query if a domain EFS policy was created before
        //
        DWORD RegType;
        DWORD nSize=sizeof(DWORD);

        RegQueryValueEx(
                 hKey,
                 L"EFSDomainGPOCreated",
                 0,
                 &RegType,
                 (LPBYTE)&IsCreated,
                 &nSize
                 );

        RegCloseKey( hKey );
    }

    if (IsCreated != 0) {

        //
        // The DC recovery policy is already set
        //

        DllUnregisterServerEFS();

        return;

    }

    //
    // check the current logon user. If not a member of administrators, quit
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminAccountSid;
    BOOL bIsMemberOfAdmins = FALSE;

    if ( NT_SUCCESS( RtlAllocateAndInitializeSid(
                             &NtAuthority,
                             2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_ADMINS,
                             0, 0, 0, 0, 0, 0,
                             &AdminAccountSid
                             ) ) ) {

        HANDLE NewToken;

        if ( DuplicateToken( pInfo->hToken, SecurityImpersonation, &NewToken )) {

            if ( FALSE == CheckTokenMembership(
                                NewToken,
                                AdminAccountSid,
                                &bIsMemberOfAdmins
                                ) ) {

                //
                // error occured when checking membership, assume it is not a member
                //

                bIsMemberOfAdmins = FALSE;

            }

            CloseHandle(NewToken);

        }

        RtlFreeSid( AdminAccountSid);

    }

    if ( bIsMemberOfAdmins == FALSE ) {
        //
        // if it's not admin logon, or for some reason token membership can't
        // be checked, quit ???
        //
        return;
    }

    //
    // impersonate the token
    //

    if ( FALSE == ImpersonateLoggedOnUser(pInfo->hToken) ) {

        return;
    }

    //
    // initialize event log. If failed, will try later for each LogEvent call.
    //

    (void) InitializeEvents();

    //
    // check the machine role
    //

    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsRole;

    rc = DsRoleGetPrimaryDomainInformation(
                 NULL,
                 DsRolePrimaryDomainInfoBasic,
                 (PBYTE *)&pDsRole
                 );

    if (rc != ERROR_SUCCESS) {

        //
        // Try again some other time?  Deregister?
        // This isn't supposed to happen.
        //

        LogEvent(STATUS_SEVERITY_ERROR,
                 GPOEVENT_ERROR_DSROLE,
                 IDS_FAILED_GET_DSROLE,
                 GetLastError()
                 );

        (void) ShutdownEvents();

        RevertToSelf();

        return;
    }

    DSROLE_MACHINE_ROLE MachineRole = pDsRole->MachineRole;

    if (MachineRole != DsRole_RolePrimaryDomainController) {

        //
        // We don't create EFS recovery policy on non-PDC
        //

        (void) ShutdownEvents();
        DsRoleFreeMemory( pDsRole );
        RevertToSelf();
        DllUnregisterServerEFS();
        return;

    }


    //
    // create the EFS local policy if not exist
    //

    CoInitialize(NULL);

    HRESULT             hr = ERROR_SUCCESS;
    PUCHAR              EfsBlob=NULL;
    ULONG               EfsSize=0;
    PCCERT_CONTEXT      pCertContext=NULL;

/*
    //
    // check/create EFS policy in the local machine object
    //

    hr = CreateLocalMachinePolicy(
                pInfo,
                ( MachineRole == DsRole_RolePrimaryDomainController ) ? TRUE : FALSE,
                &EfsBlob,
                &EfsSize,
                &pCertContext
                );

    if ( SUCCEEDED(hr) ) {

        //
        // local machine policy has been successfully created
        // delete the SystemClone flag if it exists (or set it to 0 if it can't be deleted)
        //
        lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                EFS_NOTIFY_PATH,
                                0,
                                MAXIMUM_ALLOWED,
                                &hKey
                                );

        if (lResult == ERROR_SUCCESS) {

            lResult = RegDeleteValue (hKey, TEXT("SystemCloned") );

            if ( lResult == ERROR_ACCESS_DENIED ) {

                //
                // can't delete it, now set it to 0
                //
                DWORD dwClone = 0;

                RegSetValueEx( hKey,
                               TEXT("SystemCloned"),
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwClone,
                               sizeof(DWORD)
                               );

            }

            RegCloseKey( hKey );
        }

        //
        // detect the role of this computer and create the default EFS group
        // policies for domain controllers
        //
        // this code is also executed for replicas because if the user logs on
        // to replica first (before logging onto the PDC), we still want to
        // have EFS recovery policy created.
        //
        // if the replica is a READ ONLY replica (BDC), this call will fail
        //

        if ( (MachineRole == DsRole_RolePrimaryDomainController) &&
             ( IsCreated == 0) ) {

            //
            // Create the default group policy object and add it to the gPLink list.
            //

            if ( EfsBlob == NULL ) {
                EfsSize = 0;

                if ( pCertContext ) {
                    //
                    // free it first
                    //
                    CertFreeCertificateContext( pCertContext );
                    pCertContext = NULL;
                }
            }

 */
    //
    // create both EFS default policy and domain account policy objects.
    //

    hr = CreateEFSDefaultPolicy(pInfo->hToken,
                                &EfsBlob,
                                &EfsSize,
                                &pCertContext,
                                pDsRole->DomainNameFlat);

    if ( SUCCEEDED(hr) ) {

        //
        // update the registry value EFSDomainGPOCreated
        //
        lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                EFS_NOTIFY_PATH,
                                0,
                                MAXIMUM_ALLOWED,
                                &hKey
                                );

        if (lResult == ERROR_SUCCESS) {

            //
            // set the flag
            //

            IsCreated = 1;
            RegSetValueEx( hKey,
                           L"EFSDomainGPOCreated",
                           0,
                           REG_DWORD,
                           (LPBYTE)&IsCreated,
                           sizeof(DWORD)
                           );

            RegCloseKey( hKey );
        }

    }
/*
        } else {

            //
            // the domain GPO is already created, or
            //
            // If it's workstation or server (either standalone or member), local policy
            // (existing or just created) is enough.
            //

            //
            // If it's a backup domain controller (replica), no need to create any
            // default ( because either the one replicated from the primary domain
            // or the one created by server setup will take effect );
            //

            // !!! do nothing !!!

        }
*/

    if ( SUCCEEDED(hr) ) {

        DllUnregisterServerEFS();

        HINSTANCE hUserEnvDll = LoadLibrary(TEXT("userenv.dll"));
        PFREFRESHPOLICY pfRefreshPolicy=NULL;

        if ( hUserEnvDll) {
            pfRefreshPolicy = (PFREFRESHPOLICY)GetProcAddress(
                                                   hUserEnvDll,
                                                   "RefreshPolicy");

            if ( pfRefreshPolicy ) {
                //
                // do not care errors
                //
                (void) (*pfRefreshPolicy)(TRUE);

            } else {

                LogEvent(STATUS_SEVERITY_WARNING,
                         GPOEVENT_WARNING_NOT_REFRESH,
                         IDS_ERROR_GET_PROC_ADDR,
                         GetLastError()
                         );
            }

            FreeLibrary(hUserEnvDll);

        } else {

            LogEvent(STATUS_SEVERITY_WARNING,
                     GPOEVENT_WARNING_NOT_REFRESH,
                     IDS_ERROR_LOAD_USERENV,
                     GetLastError()
                     );
        }
    }
//    }

    if (pDsRole) {
        DsRoleFreeMemory( pDsRole );
    }
    (void) ShutdownEvents();

    //
    // uninitialize OLE
    //

    CoUninitialize();

    RevertToSelf();

    //
    // clean up buffers
    //

    if ( EfsBlob ) {
        free(EfsBlob);
    }

    if ( pCertContext ) {
        CertFreeCertificateContext( pCertContext );
    }

}

#if 0

HRESULT
CreateLocalMachinePolicy(
    IN PWLX_NOTIFICATION_INFO pInfo,
    IN BOOL bIsDC,
    OUT PUCHAR *pEfsBlob,
    OUT ULONG *pEfsSize,
    OUT PCCERT_CONTEXT *ppCertContext
    )
{

    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT             hr;
    HKEY                hKeyPolicyRoot;
    HKEY                hKey;
    DWORD               rc=ERROR_SUCCESS;

    //
    // create Policy Object instance
    //

    hr = CoCreateInstance( CLSID_GroupPolicyObject,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IGroupPolicyObject,
                           (PVOID *)&pGPO
                           );

    if (SUCCEEDED(hr) && pGPO) {

        //
        // open LPO and load policy into registry
        // if LPO does not exist, create it (under system context now)
        //

        hr = pGPO->OpenLocalMachineGPO( TRUE );

        if (SUCCEEDED(hr)) {

            //
            // get the registry key for the root of machine policy object
            //

            hr = pGPO->GetRegistryKey( GPO_SECTION_MACHINE,
                                       &hKeyPolicyRoot
                                       );

            if (SUCCEEDED(hr)) {

                //
                // open EFS recovery policy base key in the registry
                //

                BOOL fContinue = TRUE;
                DWORD dwDisposition;

                if ( (rc = RegCreateKeyEx(
                                 hKeyPolicyRoot,
                                 CERT_EFSBLOB_REGPATH,
                                 0,
                                 TEXT("REG_SZ"),
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hKey,
                                 &dwDisposition
                                 )) == ERROR_SUCCESS ) {

                    //
                    // check to see if there is EFS blob
                    // if not, create it.
                    //

                    DWORD RegType;
                    DWORD EfsSize;
                    PUCHAR pEfsOldBlob=NULL;
                    BOOL  bIsExpired=FALSE;

                    rc = RegQueryValueEx(
                                 hKey,
                                 CERT_EFSBLOB_VALUE_NAME,
                                 0,
                                 &RegType,
                                 NULL,
                                 &EfsSize
                                 );

                    if ( rc == ERROR_SUCCESS && EfsSize > 0 ) {

                        //
                        // query if this machine is cloned
                        //
                        HKEY hKeyClone;

                        rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                           EFS_NOTIFY_PATH,
                                           0,
                                           MAXIMUM_ALLOWED,
                                           &hKeyClone
                                         );

                        if (rc == ERROR_SUCCESS) {

                            DWORD nSize=sizeof(DWORD);
                            DWORD dwClone=0;

                            RegQueryValueEx(
                                     hKeyClone,
                                     L"SystemCloned",
                                     0,
                                     &RegType,
                                     (LPBYTE)&dwClone,
                                     &nSize
                                     );

                            RegCloseKey( hKeyClone );

                            if ( dwClone > 0 ) {
                                bIsExpired = TRUE;
                            }
                        }

                        if ( !bIsExpired ) {

                            //
                            // EFS recovery policy already exists
                            // query the blob and check if this policy needs to be
                            // upgraded (change expiration date)
                            //
                            pEfsOldBlob = (PUCHAR)LocalAlloc(LPTR, EfsSize+1);

                            if ( pEfsOldBlob ) {

                                rc = RegQueryValueEx(
                                             hKey,
                                             CERT_EFSBLOB_VALUE_NAME,
                                             0,
                                             &RegType,
                                             pEfsOldBlob,
                                             &EfsSize
                                             );

                                if ( rc == ERROR_SUCCESS ) {

                                    //
                                    // check if the policy should be recreated.
                                    //
                                    bIsExpired = IsSelfSignedPolicyExpired((PRECOVERY_POLICY_1_1)pEfsOldBlob);


                                }

                                LocalFree(pEfsOldBlob);
                                pEfsOldBlob = NULL;

                            } else {
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                    }

                    if ( rc != ERROR_SUCCESS || EfsSize == 0 || bIsExpired ) {

                        //
                        // the EFSBlob registry value does not exis
                        // this means that local EFS policy should be created
                        //

                        *pEfsSize = 0;

                        rc = GetDefaultRecoveryPolicy(pInfo->hToken,
                                                      bIsDC,
                                                      pEfsBlob,
                                                      pEfsSize,
                                                      ppCertContext
                                                     );

                        if ( ERROR_SUCCESS == rc && *ppCertContext ) {

                            //
                            // add to the cert store of this GPO first
                            //

                            CERT_SYSTEM_STORE_RELOCATE_PARA paraRelocate;
                            paraRelocate.hKeyBase = hKeyPolicyRoot;
                            paraRelocate.pwszSystemStore = L"EFS";

                            HCERTSTORE hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                                        0,
                                                        NULL,
                                                        CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY |
                                                        CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                                        (void *)&paraRelocate
                                                        );

                            if ( hCertStore ) {

                                if ( bIsExpired ) {
                                    //
                                    // delete all old certs from the store first
                                    //

                                    PCCERT_CONTEXT pEnumCertContext = CertEnumCertificatesInStore(
                                                                            hCertStore,
                                                                            NULL
                                                                            );
                                    PCCERT_CONTEXT pCertContextDelete=NULL;

                                    while ( pEnumCertContext ) {

                                        //
                                        // duplicate the cert context
                                        //
                                        pCertContextDelete = CertDuplicateCertificateContext( pEnumCertContext );

                                        //
                                        // enumerate the next certificate context
                                        //
                                        pEnumCertContext = CertEnumCertificatesInStore(
                                                                            hCertStore,
                                                                            pEnumCertContext
                                                                            );

                                        if ( pCertContextDelete ) {

                                            //
                                            // delete the cert from store
                                            //
                                            CertDeleteCertificateFromStore( pCertContextDelete );

                                            //
                                            // no need to free the cert context
                                            // because it's freed by the previous call (even under error case)
                                            //
                                            pCertContextDelete = NULL;
                                        }

                                    }

                                }

                                if ( !CertAddCertificateContextToStore(
                                        hCertStore,
                                        *ppCertContext,
                                        CERT_STORE_ADD_ALWAYS,
                                        NULL
                                        ) ) {

                                    rc = GetLastError();
                                }

                                //
                                // close the store
                                //
                                CertCloseStore(hCertStore, 0);
                                hCertStore = NULL;

                            } else {
                                rc = GetLastError();
                            }

                            if ( ERROR_SUCCESS == rc ) {

                                rc = RegSetValueEx(
                                         hKey,
                                         CERT_EFSBLOB_VALUE_NAME,
                                         0,
                                         REG_BINARY,
                                         (PBYTE)(*pEfsBlob),
                                         *pEfsSize
                                         );

                                if (rc == ERROR_SUCCESS) {

                                    hr = pGPO->Save(TRUE, TRUE, &guidExtension, &guidSnapin );
                                    hr = pGPO->Save(TRUE, TRUE, &guidRegExt, &guidSnapin );

                                    if ( FAILED(hr) ) {

                                        LogEvent(STATUS_SEVERITY_ERROR,
                                             GPOEVENT_ERROR_CREATE_LPO,
                                             IDS_ERROR_SAVE_LPO,
                                             hr
                                             );
                                    } else {
/*                                      comment out due to PM request
                                        //
                                        // popup a message to warn user
                                        //

                                        EFSRecPolicyPopup(
                                                DsRole_RoleStandaloneWorkstation,  // this value doesn't matter
                                                NULL
                                                );
*/
                                    }

                                } else {

                                    LogEvent(STATUS_SEVERITY_ERROR,
                                         GPOEVENT_ERROR_CREATE_LPO,
                                         IDS_ERROR_SAVE_EFSBLOB,
                                         rc
                                         );
                                }
                            } else {

                                LogEvent(STATUS_SEVERITY_ERROR,
                                         GPOEVENT_ERROR_CREATE_LPO,
                                         IDS_ERROR_ADD_CERTIFICATE,
                                         rc
                                         );
                            }

                        } else {

                            LogEvent(STATUS_SEVERITY_ERROR,
                                     GPOEVENT_ERROR_CREATE_LPO,
                                     IDS_ERROR_CREATE_EFSBLOB,
                                     rc
                                     );
                        }
                    }

                    //
                    // close the registry key
                    //

                    RegCloseKey(hKey);

                } else {

                    LogEvent(STATUS_SEVERITY_ERROR,
                             GPOEVENT_ERROR_CREATE_LPO,
                             IDS_ERROR_OPEN_EFSKEY,
                             rc
                             );
                }

                if ( rc != ERROR_SUCCESS ) {
                    hr = HRESULT_FROM_WIN32(rc);
                }

                RegCloseKey(hKeyPolicyRoot);

            } else {

                LogEvent(STATUS_SEVERITY_ERROR,
                         GPOEVENT_ERROR_CREATE_LPO,
                         IDS_ERROR_GET_REGISTRY_KEY,
                         hr
                         );
            }

        } else {

            LogEvent(STATUS_SEVERITY_ERROR,
                     GPOEVENT_ERROR_CREATE_LPO,
                     IDS_ERROR_OPEN_LPO,
                     hr
                     );
        }

        //
        // release the policy object instance
        //

        pGPO->Release();

    } else {

        LogEvent(STATUS_SEVERITY_ERROR,
                 GPOEVENT_ERROR_CREATE_LPO,
                 IDS_ERROR_CREATE_GPO_INSTANCE,
                 hr
                 );
    }

    return hr;
}

#endif

DWORD
GetDefaultRecoveryPolicy(
    IN HANDLE hToken,
    IN BOOL bIsDC,
    OUT PUCHAR *pRecoveryPolicyBlob,
    OUT ULONG *BlobSize,
    OUT PCCERT_CONTEXT *ppCertContext
    )
/*++

Routine Description:

    This routine creates the default recovery policy for the current system.
    It does this by auto-generating a recovery key based on the name of the
    machine.

Arguments:

    hToken  - the token of current user

    pRecoveryPolicyBlob - the output buffer to hold EFSBlob

    BlobSize - the size of EFSBlob

Return Value:


--*/
{
    DWORD rc = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext;

    *pRecoveryPolicyBlob = NULL;
    *BlobSize = 0;
    *ppCertContext = NULL;

    if (CreateSelfSignedRecoveryCertificate(
            bIsDC,
            &pCertContext
            )) {

        PEFS_PUBLIC_KEY_INFO PublicKeyInformation;

        PBYTE pbCert = pCertContext->pbCertEncoded;
        DWORD cbCert = pCertContext->cbCertEncoded;

        PTOKEN_USER pTokenUser = GetTokenUser( hToken );

        if (pTokenUser) {

            rc = CreatePublicKeyInformationCertificate(
                               pTokenUser->User.Sid,
                               pbCert,
                               cbCert,
                               &PublicKeyInformation
                               );

            if (rc == ERROR_SUCCESS) {

                //
                // Compute the total size of the RECOVERY_POLICY_1_1 structure, which
                // is the size of the structure minus the size of the EFS_PUBLIC_KEY_INFO
                // plus the size of the thing we just created above.
                //

                ULONG RecoveryKeySize = sizeof( RECOVERY_KEY_1_1 ) - sizeof( EFS_PUBLIC_KEY_INFO ) + PublicKeyInformation->Length;

                ULONG PolicySize = sizeof( RECOVERY_POLICY_1_1 ) + RecoveryKeySize - sizeof( RECOVERY_KEY_1_1 );

                //
                // Allocate the policy block
                //

                PRECOVERY_POLICY_1_1 RecoveryPolicy = (PRECOVERY_POLICY_1_1)malloc( PolicySize );

                if (RecoveryPolicy != NULL) {

                    RecoveryPolicy->RecoveryPolicyHeader.MajorRevision = EFS_RECOVERY_POLICY_MAJOR_REVISION_1;
                    RecoveryPolicy->RecoveryPolicyHeader.MinorRevision = EFS_RECOVERY_POLICY_MINOR_REVISION_1;
                    RecoveryPolicy->RecoveryPolicyHeader.RecoveryKeyCount = 1;

                    PRECOVERY_KEY_1_1 RecoveryKey = (PRECOVERY_KEY_1_1) &(RecoveryPolicy->RecoveryKeyList[0]);

                    memcpy( &RecoveryKey->PublicKeyInfo, PublicKeyInformation, PublicKeyInformation->Length );
                    RecoveryKey->TotalLength = sizeof( RECOVERY_KEY_1_1 ) + PublicKeyInformation->Length - sizeof( EFS_PUBLIC_KEY_INFO );

                    *pRecoveryPolicyBlob = (PUCHAR)RecoveryPolicy;
                    *BlobSize = PolicySize;
                    *ppCertContext = pCertContext;

                    //
                    // will free this outside this function
                    //
                    pCertContext = NULL;

                } else {

                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                free( PublicKeyInformation );
            }

            free( pTokenUser );

        } else {

            rc = GetLastError();
        }

    //
    // free the certificate context if not outputted
    //
        if ( pCertContext ) {
        CertFreeCertificateContext( pCertContext );
        }

    } else {

        rc = GetLastError();
    }

    return( rc );

}



BOOLEAN
CreateSelfSignedRecoveryCertificate(
    IN BOOL bIsDC,
    OUT PCCERT_CONTEXT * pCertContext
    )
/*++

Routine Description:

    This routine sets up and creates a self-signed certificate.

Arguments:


Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    BOOLEAN fReturn = FALSE;
    DWORD rc = ERROR_SUCCESS;

    LPWSTR lpContainerName = NULL;
    LPWSTR lpProviderName  = NULL;
    PBYTE  pbHash          = NULL;
    LPWSTR lpDisplayInfo   = NULL;

    HCRYPTKEY hKey = NULL;
    HCRYPTPROV hProv = NULL;

    *pCertContext = NULL;

    //
    // Croft up a key pair
    //

    //
    // Container name
    //

    GUID    guidContainerName;

    if ( ERROR_SUCCESS != UuidCreate(&guidContainerName) ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(fReturn);
    }

    LPWSTR TmpContainerName;

    if (ERROR_SUCCESS == UuidToStringW(&guidContainerName, (unsigned short **)&lpContainerName )) {

        //
        // Copy the container name into LSA heap memory
        //

        lpProviderName = MS_DEF_PROV;

        //
        // Create the key container
        //

        if (CryptAcquireContext(&hProv, lpContainerName, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET )) {

            if (CryptGenKey(hProv, AT_KEYEXCHANGE, RSA1024BIT_KEY | CRYPT_EXPORTABLE, &hKey)) {

                DWORD NameLength = 64;
                LPWSTR AgentName = NULL;

                //
                // Construct the subject name information
                //

                //lpDisplayInfo = MakeDNName();

                AgentName = (LPWSTR)malloc(NameLength * sizeof(WCHAR));
                if (AgentName){
                    if (!GetUserName(AgentName, &NameLength)){
                        free(AgentName);
                        AgentName = (LPWSTR)malloc(NameLength * sizeof(WCHAR));

                        //
                        // Try again with big buffer
                        //

                        if ( AgentName ){

                            if (!GetUserName(AgentName, &NameLength)){
                                rc = GetLastError();
                                free(AgentName);
                                AgentName = NULL;
                            }

                        } else {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                if (AgentName) {

                    LPCWSTR     DNNameTemplate = L"CN=%ws,L=EFS,OU=EFS File Encryption Certificate";
                    DWORD       cbDNName = 0;

                    cbDNName = (wcslen( DNNameTemplate ) + 1) * sizeof( WCHAR ) + (wcslen( AgentName ) + 1) * sizeof( WCHAR );
                    lpDisplayInfo = (LPWSTR)malloc( cbDNName );
                    if (lpDisplayInfo) {
                        swprintf( lpDisplayInfo, DNNameTemplate, AgentName );
                    } else {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    free(AgentName);
                    AgentName = NULL;

                }

                if (lpDisplayInfo) {

                    //
                    // Use this piece of code to create the PCERT_NAME_BLOB going into CertCreateSelfSignCertificate()
                    //

                    CERT_NAME_BLOB SubjectName;

                    SubjectName.cbData = 0;

                    if(CertStrToNameW(
                           CRYPT_ASN_ENCODING,
                           lpDisplayInfo,
                           0,
                           NULL,
                           NULL,
                           &SubjectName.cbData,
                           NULL)) {

                        SubjectName.pbData = (BYTE *) malloc(SubjectName.cbData);

                        if (SubjectName.pbData) {

                            if (CertStrToNameW(
                                    CRYPT_ASN_ENCODING,
                                    lpDisplayInfo,
                                    0,
                                    NULL,
                                    SubjectName.pbData,
                                    &SubjectName.cbData,
                                    NULL) ) {

                                //
                                // Make the enhanced key usage
                                //

                                CERT_ENHKEY_USAGE certEnhKeyUsage;
                                LPSTR lpstr;
                                CERT_EXTENSION certExt;

                                lpstr = szOID_EFS_RECOVERY;
                                certEnhKeyUsage.cUsageIdentifier = 1;
                                certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;

                                // now call CryptEncodeObject to encode the enhanced key usage into the extension struct

                                certExt.Value.cbData = 0;
                                certExt.Value.pbData = NULL;
                                certExt.fCritical = FALSE;
                                certExt.pszObjId = szOID_ENHANCED_KEY_USAGE;

                                //
                                // Encode it
                                //

                                if (EncodeAndAlloc(
                                        CRYPT_ASN_ENCODING,
                                        X509_ENHANCED_KEY_USAGE,
                                        &certEnhKeyUsage,
                                        &certExt.Value.pbData,
                                        &certExt.Value.cbData
                                        )) {

                                    //
                                    // finally, set up the array of extensions in the certInfo struct
                                    // any further extensions need to be added to this array.
                                    //

                                    CERT_EXTENSIONS certExts;

                                    certExts.cExtension = 1;
                                    certExts.rgExtension = &certExt;

                                    CRYPT_KEY_PROV_INFO KeyProvInfo;

                                    memset( &KeyProvInfo, 0, sizeof( CRYPT_KEY_PROV_INFO ));

                                    KeyProvInfo.pwszContainerName = lpContainerName;
                                    KeyProvInfo.pwszProvName      = lpProviderName;
                                    KeyProvInfo.dwProvType        = PROV_RSA_FULL;
                                    KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;

                                    SYSTEMTIME  StartTime;
                                    FILETIME    FileTime;
                                    LARGE_INTEGER TimeData;
                                    SYSTEMTIME  EndTime;

                                    GetSystemTime(&StartTime);
                                    SystemTimeToFileTime(&StartTime, &FileTime);
                                    TimeData.LowPart = FileTime.dwLowDateTime;
                                    TimeData.HighPart = (LONG) FileTime.dwHighDateTime;

                                    if ( bIsDC ) {
                                        TimeData.QuadPart += YEARCOUNT * 3;
                                    } else {
                                        TimeData.QuadPart += YEARCOUNT * 100;

                                    }
                                    FileTime.dwLowDateTime = TimeData.LowPart;
                                    FileTime.dwHighDateTime = (DWORD) TimeData.HighPart;

                                    FileTimeToSystemTime(&FileTime, &EndTime);

                                    *pCertContext = CertCreateSelfSignCertificate(
                                                       hProv,
                                                       &SubjectName,
                                                       0,
                                                       &KeyProvInfo,
                                                       NULL,
                                                       &StartTime,
                                                       &EndTime,
                                                       &certExts
                                                       );

                                    if (*pCertContext) {

                                        HCERTSTORE hStore;

                                        hStore = CertOpenSystemStoreW( NULL, L"MY" );

                                        if (hStore) {

                                            //
                                            // save the temp cert
                                            //

                                            if(CertAddCertificateContextToStore(
                                                   hStore,
                                                   *pCertContext,
                                                   CERT_STORE_ADD_NEW,
                                                   NULL) ) {

                                                fReturn = TRUE;

                                            } else {

                                                rc = GetLastError();
                                            }

                                            CertCloseStore( hStore, 0 );

                                        } else {

                                            rc = GetLastError();
                                        }

                                    } else {

                                        rc = GetLastError();
                                    }

                                    free( certExt.Value.pbData );

                                } else {

                                    rc = GetLastError();
                                }

                            } else {

                                rc = GetLastError();
                            }

                            free( SubjectName.pbData );

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {

                        rc = GetLastError();
                    }

                    free( lpDisplayInfo );

                } else {

                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                CryptDestroyKey( hKey );

            } else {

                 rc = GetLastError();
            }

            CryptReleaseContext( hProv, 0 );

        } else {

            rc = GetLastError();
        }

        RpcStringFree( (unsigned short **)&lpContainerName );

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError( rc );

    if (!fReturn) {

        if (*pCertContext) {
            CertFreeCertificateContext( *pCertContext );
            *pCertContext = NULL;
        }
    }

    return( fReturn );
}

BOOL
EncodeAndAlloc(
    DWORD dwEncodingType,
    LPCSTR lpszStructType,
    const void * pvStructInfo,
    PBYTE * pbEncoded,
    PDWORD pcbEncoded
    )
{
    BOOL b = FALSE;

    if (CryptEncodeObject(
          dwEncodingType,
          lpszStructType,
          pvStructInfo,
          NULL,
          pcbEncoded )) {

        *pbEncoded = (PBYTE)malloc( *pcbEncoded );

        if (*pbEncoded) {

            if (CryptEncodeObject(
                  dwEncodingType,
                  lpszStructType,
                  pvStructInfo,
                  *pbEncoded,
                  pcbEncoded )) {

                b = TRUE;

            } else {

                free( *pbEncoded );
                *pbEncoded = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return( b );
}


LPWSTR
MakeDNName(
    VOID
    )
/*++

Routine Description:

    Fabricates a display name for a locally built self-signed cert

Arguments:

    RecoveryKey - Specifies if this is a recovery key or not.

Return Value:

    Returns a string containing a display name, or NULL.

--*/

{
    LPWSTR      DNName = NULL;
    LPCWSTR     DNNameTemplate = L"CN=%ws,L=EFS,OU=EFS File Encryption Certificate";
    DWORD       cbDNName = 0;

    DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1;

    WCHAR lpComputerName[(MAX_COMPUTERNAME_LENGTH + 1)  * sizeof( WCHAR )];

    BOOL b = GetComputerName ( lpComputerName, &nSize );

    if (b) {

        cbDNName = (wcslen( DNNameTemplate ) + 1) * sizeof( WCHAR ) + (wcslen( lpComputerName ) + 1) * sizeof( WCHAR );

        DNName = (LPWSTR)malloc( cbDNName );

        if (DNName) {

            swprintf( DNName, DNNameTemplate, lpComputerName );

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return( DNName );
}

DWORD
CreatePublicKeyInformationCertificate(
    IN PSID  pUserSid OPTIONAL,
    PBYTE pbCert,
    DWORD cbCert,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation
    )
{
    DWORD PublicKeyInformationLength = 0;
    DWORD UserSidLength = 0;
    PWCHAR Base;

    if (pUserSid != NULL) {
        UserSidLength = GetLengthSid( pUserSid );
    }

    //
    // Total size is the size of the public key info structure, the size of the
    // cert hash data structure, the length of the thumbprint, and the lengths of the
    // container name and provider name if they were passed.
    //

    PublicKeyInformationLength = sizeof( EFS_PUBLIC_KEY_INFO )  + UserSidLength + cbCert;

    //
    // Allocate and fill in the PublicKeyInformation structure
    //

    *PublicKeyInformation = (PEFS_PUBLIC_KEY_INFO)malloc( PublicKeyInformationLength );

    if (*PublicKeyInformation == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    (*PublicKeyInformation)->Length = PublicKeyInformationLength;
    (*PublicKeyInformation)->KeySourceTag = (ULONG)EfsCertificate;

    //
    // Copy the string and SID data to the end of the structure.
    //

    Base = (PWCHAR)(*PublicKeyInformation);
    Base = (PWCHAR)((PBYTE)Base + sizeof( EFS_PUBLIC_KEY_INFO ));

    if (pUserSid != NULL) {

        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );
        CopySid( UserSidLength, (PSID)Base, pUserSid );

    } else {

        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)0;
    }

    Base = (PWCHAR)((PBYTE)Base + UserSidLength);

    (*PublicKeyInformation)->CertificateInfo.CertificateLength = cbCert;
    (*PublicKeyInformation)->CertificateInfo.Certificate = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );

    memcpy( (PBYTE)Base, pbCert, cbCert );

    return( ERROR_SUCCESS );

}

#if 0

BOOLEAN
Admin(
    IN LSA_HANDLE LsaPolicyHandle,
    IN HANDLE hToken,
    OUT PSID * Sid
    )
/*++

Routine Description:

    This routine determines if the passed token belongs to an administrator.

    If we are in a domain, the user must be a domain admin for this to succeed.

    If we are standalne, the user must be in the local administrator's group.

Arguments:

    hToken - Supplies the token of the user to be examined.

    bDomain - Returns TRUE if the caller is a domain administrator.

    Sid - Returns the Sid of the user.

Return Value:

    TRUE if the user is an administrator of the type we need, FALSE otherwise.

    Note that this routine does not attempt to set last error, it either works
    or it doesn't.

--*/

{
    NET_API_STATUS NetStatus;
    PSID DomainId;
    NTSTATUS Status;
    BOOLEAN fReturn = FALSE;

    DWORD ReturnLength;

    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;

    //
    // Initialize OUT parameters
    //

    *Sid = NULL;

    Status = NtQueryInformationToken (
                 hToken,
                 TokenGroups,
                 NULL,
                 0,
                 &ReturnLength
                 );

    if (STATUS_BUFFER_TOO_SMALL == Status) {

        PTOKEN_GROUPS Groups = (PTOKEN_GROUPS)malloc( ReturnLength );

        if (Groups) {

            Status = NtQueryInformationToken (
                         hToken,
                         TokenGroups,
                         Groups,
                         ReturnLength,
                         &ReturnLength
                         );

            if (NT_SUCCESS( Status )) {

                //
                // We've got the groups, build the SIDs and see if
                // they're in the token.
                //

                //
                // We're standalone
                //

                SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

                PSID AdminAccountSid;

                Status = RtlAllocateAndInitializeSid(
                             &NtAuthority,
                             2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_ADMINS,
                             0, 0, 0, 0, 0, 0,
                             &AdminAccountSid
                             );

                if (NT_SUCCESS( Status )) {

                    DWORD i;

                    for (i=0; i<Groups->GroupCount; i++) {

                        if (RtlEqualSid(Groups->Groups[i].Sid, AdminAccountSid)) {
                            *Sid = AdminAccountSid;
                            fReturn = TRUE;
                            break;
                        }
                    }
                }
            }

            free( Groups );
        }

        if (!fReturn) {

            //
            // Something failed, clean up any allocated OUT parameters
            //

            if (*Sid) {

                if (*bDomain == FALSE) {
                    FreeSid( *Sid );
                } else {
                    free( *Sid );
                }

                *Sid = NULL;
            }
        }
    }

    return( fReturn );
}

#endif


PTOKEN_USER
GetTokenUser(
    HANDLE TokenHandle
    )
/*++

Routine Description:

    This routine returns the TOKEN_USER structure for the
    current user, and optionally, the AuthenticationId from his
    token.

Arguments:

    AuthenticationId - Supplies an optional pointer to return the
        AuthenticationId.

Return Value:

    On success, returns a pointer to a TOKEN_USER structure.

    On failure, returns NULL.  Call GetLastError() for more
    detailed error information.

--*/

{
    NTSTATUS Status;
    ULONG ReturnLength;
    TOKEN_STATISTICS TokenStats;
    PTOKEN_USER pTokenUser = NULL;
    BOOLEAN b = FALSE;

    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 NULL,
                 0,
                 &ReturnLength
                 );

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        pTokenUser = (PTOKEN_USER)malloc( ReturnLength );

        if (pTokenUser) {

            Status = NtQueryInformationToken (
                         TokenHandle,
                         TokenUser,
                         pTokenUser,
                         ReturnLength,
                         &ReturnLength
                         );

            if ( NT_SUCCESS( Status )) {

                //
                // We're done, mark that everything worked
                //

                b = TRUE;

            } else {

                SetLastError( RtlNtStatusToDosError( Status ));
            }

            if (!b) {

                //
                // Something failed, clean up what we were going to return
                //

                free( pTokenUser );
                pTokenUser = NULL;
            }

        } else {

            SetLastError( RtlNtStatusToDosError( STATUS_INSUFFICIENT_RESOURCES ));
        }

    } else {

        SetLastError( RtlNtStatusToDosError( Status ));
    }

    return( pTokenUser );
}

VOID
InitializeOtherPolicies(LPGROUPPOLICYOBJECT pGPO, HKEY hKeyRoot)
{
    TCHAR szPath[2*MAX_PATH];
    GUID guidRIClient = {0x3060e8d0, 0x7020, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4};
    GUID guidRISnap = {0x3060e8ce, 0x7020, 0x11d2, 0x84, 0x2d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4};


    //
    // Initialize Remote Install settings
    //

    if (SUCCEEDED(pGPO->GetFileSysPath (GPO_SECTION_USER, szPath, 2*MAX_PATH)))
    {
        lstrcat (szPath, TEXT("\\Microsoft"));
        if (!CreateDirectory(szPath, NULL)) {
            return;
        }

        lstrcat (szPath, TEXT("\\RemoteInstall"));
        if (!CreateDirectory(szPath, NULL)) {
            return;
        }

        lstrcat (szPath, TEXT("\\oscfilter.ini"));

        WritePrivateProfileString(TEXT("choice"), TEXT("custom"), TEXT("0"), szPath);
        WritePrivateProfileString(TEXT("choice"), TEXT("tools"), TEXT("0"), szPath);
        WritePrivateProfileString(TEXT("choice"), TEXT("restart"), TEXT("0"), szPath);

        pGPO->Save(FALSE, TRUE, &guidRIClient, &guidRISnap);
    }
}


HRESULT
CreateEFSDefaultPolicy(
    IN HANDLE    hToken,
    IN PUCHAR    *pEfsBlob,
    IN DWORD     *pEfsSize,
    IN PCCERT_CONTEXT *ppCertContext,
    IN LPTSTR DomainName
    )
/*++

Routine Description:

    Creates the default domain-wide EFS recovery policy object.

Arguments:

    hToken      - the current logged on user's token

    EfsBlob     - EFS recovery policy blob

    EfsSize     - the size of the blob ( in bytes)

Return:

    HRESULT

--*/
{
    //
    // bind to DS to find the domain DNS name
    //

    DWORD               rc;
    PLDAP               phLdap=NULL;
    PWSTR               DsRootName=NULL;


    rc = MyLdapOpen(&phLdap);

    if ( ERROR_SUCCESS == rc ) {

        rc = MyGetDsObjectRoot(
                        phLdap,
                        &DsRootName
                        );

        if ( ERROR_SUCCESS != rc ) {

            LogEvent(STATUS_SEVERITY_ERROR,
                     GPOEVENT_ERROR_CREATE_GPO,
                     IDS_ERROR_GET_DSROOT,
                     rc
                     );
        }

    } else {

        LogEvent(STATUS_SEVERITY_ERROR,
                 GPOEVENT_ERROR_CREATE_GPO,
                 IDS_ERROR_BIND_DS,
                 rc
                 );
    }

    HRESULT hr = HRESULT_FROM_WIN32(rc);

//    if ( SUCCEEDED(hr) && DsRootName ) {

/*      Get the default recovery policy only when there is no existing one

        if ( *pEfsBlob == NULL ) {

            rc = GetDefaultRecoveryPolicy(hToken,
                                        TRUE,
                                        pEfsBlob,
                                        pEfsSize,
                                        ppCertContext);

            if ( ERROR_SUCCESS != rc ) {

                LogEvent(STATUS_SEVERITY_ERROR,
                         GPOEVENT_ERROR_CREATE_GPO,
                         IDS_ERROR_CREATE_EFSBLOB,
                         rc
                         );
            }

            hr = HRESULT_FROM_WIN32(rc);
        }
*/
//    }

    if ( SUCCEEDED(hr) && DsRootName) {

        LPGROUPPOLICYOBJECT pEfsGPO = NULL;

        //
        // OLE is already initialized before this call
        // create Policy Object instances
        //

        TCHAR szPolicyName[MAX_PATH];

        pLoadResourceString(IDS_DEFAULT_EFS_POLICY,
                            szPolicyName,
                            MAX_PATH,
                            L"Domain EFS Recovery Policy"
                           );

        hr = CreateGroupPolicyObjectInDomain(hToken,
                                           DsRootName,
                                           szPolicyName,
                                           *pEfsBlob,
                                           *pEfsSize,
                                           *ppCertContext,
                                           &pEfsGPO);

        if ( FAILED(hr) ) {

            //
            // if any of the creation failed, delet both objects
            //

            if ( pEfsGPO ) {
                pEfsGPO->Delete();
            }

        }

        //
        // release the instances
        //

        if ( pEfsGPO ) {
            pEfsGPO->Release();
        }

    }


    //
    // close LDAP port
    //
    if ( phLdap ) {
        MyLdapClose(&phLdap);
    }
    if ( DsRootName ) {
        LocalFree(DsRootName);
    }

    return hr;
}


HRESULT
CreateGroupPolicyObjectInDomain(
    IN HANDLE    hToken,
    IN PWSTR DomainNCName,
    IN PWSTR GPObjectName,
    IN PUCHAR EfsBlob,
    IN ULONG EfsSize,
    IN PCCERT_CONTEXT pCertContext,
    OUT LPGROUPPOLICYOBJECT *ppObject
    )
/*++

Routine Description:

    Creates a group policy object in DS (and sysvol).

Arguments:

    DomainNCName - The DS domain's ADSI name

    GPObjectName - the display name for the group policy object to create

    EfsBlob      - The EFS recovery policy blob (ignored if to create default
                    domain policy)

    EfsSize      - the size of EfsBlob (in bytes)

    ppObject     - the created group policy object instance. This will be
                    released by the caller.

Return:

    HRESULT

--*/
{

    LPGROUPPOLICYOBJECT pGPO;

    HRESULT hr = CoCreateInstance( CLSID_GroupPolicyObject,
                                   NULL,
                                   CLSCTX_SERVER,
                                   IID_IGroupPolicyObject,
                                   (PVOID *)&pGPO
                                   );

    if (SUCCEEDED(hr) && pGPO) {

        LPWSTR lpPath;

        //
        // Build the path to the default GPO
        //

        lpPath = (LPWSTR) LocalAlloc (LPTR, (lstrlen(DomainNCName) + 100) * sizeof(WCHAR));

        if (lpPath) {

            lstrcpy (lpPath, TEXT("LDAP://CN={31B2F340-016D-11D2-945F-00C04FB984F9},CN=Policies,CN=System,"));
            lstrcat (lpPath, (DomainNCName+7));


            //
            // Open the default GPO
            //

            hr = pGPO->OpenDSGPO(lpPath, GPO_OPEN_LOAD_REGISTRY);

            LocalFree (lpPath);

            if ( SUCCEEDED(hr) ) {

                //
                // save EFS blob into the object
                //

                HKEY hKeyPolicyRoot;

                hr = pGPO->GetRegistryKey( GPO_SECTION_MACHINE,
                                           &hKeyPolicyRoot
                                           );

                if (SUCCEEDED(hr)) {

                    //
                    // create EFS recovery policy in the registry
                    // open reg key CERT_EFSBLOB_REGPATH defined in wincrypt.h
                    //

                    DWORD dwDisposition;
                    HKEY hKey;
                    DWORD Win32rc;

                    if ( (Win32rc = RegCreateKeyEx(
                                 hKeyPolicyRoot,
                                 CERT_EFSBLOB_REGPATH,
                                 0,
                                 TEXT("REG_SZ"),
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hKey,
                                 &dwDisposition
                                 ) ) == ERROR_SUCCESS ) {


                        //
                        // check to see if there is EFS blob
                        // if not, create it.
                        //

                        DWORD RegType;
                        DWORD BlobSize;
                        PUCHAR pNewBlob=NULL;
                        PCCERT_CONTEXT pNewCert=NULL;

                        Win32rc = RegQueryValueEx(
                                     hKey,
                                     CERT_EFSBLOB_VALUE_NAME,
                                     0,
                                     &RegType,
                                     NULL,
                                     &BlobSize
                                     );


                        if ( Win32rc != ERROR_SUCCESS || BlobSize == 0 ) {

                            if ( EfsBlob == NULL ) {

                                Win32rc = GetDefaultRecoveryPolicy(hToken,
                                                            TRUE,
                                                            &pNewBlob,
                                                            &BlobSize,
                                                            &pNewCert);

                                if ( ERROR_SUCCESS != Win32rc ) {

                                    LogEvent(STATUS_SEVERITY_ERROR,
                                             GPOEVENT_ERROR_CREATE_GPO,
                                             IDS_ERROR_CREATE_EFSBLOB,
                                             Win32rc
                                             );
                                }

                            } else {

                                //
                                // EFS blob is already created, just use it
                                //
                                pNewBlob = EfsBlob;
                                BlobSize = EfsSize;
                                pNewCert = pCertContext;

                                Win32rc = ERROR_SUCCESS;
                            }

                            if ( ERROR_SUCCESS == Win32rc ) {

                                //
                                // add to the cert store of this GPO first
                                //

                                CERT_SYSTEM_STORE_RELOCATE_PARA paraRelocate;

                                paraRelocate.hKeyBase = hKeyPolicyRoot;
                                paraRelocate.pwszSystemStore = L"EFS";

                                HCERTSTORE hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                                                0,
                                                                NULL,
                                                                CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY |
                                                                CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                                                (void *)&paraRelocate
                                                                );

                                if ( hCertStore ) {

                                    if ( !CertAddCertificateContextToStore(
                                                hCertStore,
                                                pNewCert, // pCertContext,
                                                CERT_STORE_ADD_ALWAYS,
                                                NULL
                                                ) ) {

                                        Win32rc = GetLastError();
                                    }

                                    //
                                    // close the store
                                    //
                                    CertCloseStore(hCertStore, 0);
                                    hCertStore = NULL;

                                } else {

                                    Win32rc = GetLastError();
                                }

                                if ( ERROR_SUCCESS == Win32rc ) {
                                    //
                                    // set EFS recovery policy binary data to registry
                                    // open reg key CERT_EFSBLOB_REGPATH defined in wincrypt.h
                                    //

                                    Win32rc = RegSetValueEx(
                                                 hKey,
                                                 CERT_EFSBLOB_VALUE_NAME,
                                                 0,
                                                 REG_BINARY,
                                                 (PBYTE)pNewBlob,    // EfsBlob
                                                 BlobSize  // EfsSize
                                                 );

                                    if (Win32rc == ERROR_SUCCESS) {

                                        hr = pGPO->Save(TRUE, TRUE, &guidExtension, &guidSnapin);
                                        hr = pGPO->Save(TRUE, TRUE, &guidRegExt, &guidSnapin );

                                        if ( FAILED(hr) ) {

                                            LogEvent(STATUS_SEVERITY_ERROR,
                                                 GPOEVENT_ERROR_CREATE_GPO,
                                                 IDS_ERROR_SAVE_GPO,
                                                 hr,
                                                 GPObjectName
                                                 );
                                        }

                                    } else {

                                        LogEvent(STATUS_SEVERITY_ERROR,
                                             GPOEVENT_ERROR_CREATE_GPO,
                                             IDS_ERROR_SAVE_EFSBLOB,
                                             Win32rc
                                             );
                                    }
                                } else {

                                    LogEvent(STATUS_SEVERITY_ERROR,
                                             GPOEVENT_ERROR_CREATE_GPO,
                                             IDS_ERROR_ADD_CERTIFICATE,
                                             Win32rc
                                             );
                                }

                                //
                                // free allocated blob and certificate
                                //
                                if ( pNewBlob != EfsBlob ) {

                                    if ( pNewBlob ) {
                                        free(pNewBlob);
                                    }

                                    if ( pNewCert ) {
                                        CertFreeCertificateContext( pNewCert );
                                    }
                                }

                            } else {

                                LogEvent(STATUS_SEVERITY_ERROR,
                                         GPOEVENT_ERROR_CREATE_GPO,
                                         IDS_ERROR_CREATE_EFSBLOB,
                                         Win32rc
                                         );
                            }
                        }

                        //
                        // close the registry key
                        //

                        RegCloseKey(hKey);

                    } else {

                        LogEvent(STATUS_SEVERITY_ERROR,
                             GPOEVENT_ERROR_CREATE_GPO,
                             IDS_ERROR_OPEN_EFSKEY,
                             Win32rc
                             );
                    }

                    if ( Win32rc != ERROR_SUCCESS ) {

                        hr = HRESULT_FROM_WIN32(Win32rc);

                    }

                    InitializeOtherPolicies(pGPO, hKeyPolicyRoot);

                    RegCloseKey(hKeyPolicyRoot);

                } else {

                    LogEvent(STATUS_SEVERITY_ERROR,
                             GPOEVENT_ERROR_CREATE_GPO,
                             IDS_ERROR_GETGPO_REGKEY,
                             hr,
                             GPObjectName
                             );
                }

            } else {

                LogEvent(STATUS_SEVERITY_ERROR,
                         GPOEVENT_ERROR_CREATE_GPO,
                         IDS_ERROR_NEW_GPO,
                         hr,
                         GPObjectName,
                         DomainNCName
                         );
            }

        }

    } else {

        LogEvent(STATUS_SEVERITY_ERROR,
                 GPOEVENT_ERROR_CREATE_GPO,
                 IDS_ERROR_CREATE_GPO_INSTANCE,
                 hr
                 );
    }

    if ( SUCCEEDED(hr) ) {

        *ppObject = pGPO;

    } else if ( pGPO ) {

        //
        // failed, release the instance
        //

        pGPO->Release();
    }

    return hr;
}

DWORD
MyGetDsObjectRoot(
    IN PLDAP pLdap,
    OUT PWSTR *pDsRootName
    )
/*++

Routine Description:

    Get the root domain name of the current domain. The returned domain's
    name is in ADSI format, for example,
        LDAP://DC=test_dom,DC=ntdev,DC=microsoft,DC=com

Arguments:

    pLdap       - the ldap handle

    pDsRootName - the domain's ADSI name to output

Return:

    Win32 error

--*/
{
    DWORD retErr;
    LDAPMessage *Message = NULL;          // for LDAP calls.
    PWSTR    Attribs[2];                  // for LDAP calls.

    if ( pLdap == NULL || pDsRootName == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    Attribs[0] = L"defaultNamingContext";
    Attribs[1] = NULL;


    retErr = ldap_search_s(pLdap,
                          L"",
                          LDAP_SCOPE_BASE,
                          L"(objectClass=*)",
                          Attribs,
                          0,
                          &Message);

    if( Message ) { // should not check for error code

        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;
        //
        // read the first entry.
        // we did base level search, we have only one entry.
        // Entry does not need to be freed (it is freed with the message)
        //
        Entry = ldap_first_entry(pLdap, Message);
        if(Entry != NULL) {

            PWSTR *Values = ldap_get_values(pLdap, Entry, Attribs[0]);

            if(Values != NULL) {
                //
                // should only get one value for the default naming context
                // Values[0] here is the DN.
                //
                *pDsRootName = (PWSTR)LocalAlloc(0, (wcslen(Values[0])+1+7)*sizeof(WCHAR));

                if ( *pDsRootName ) {
                    swprintf(*pDsRootName, L"LDAP://%s\0", Values[0]);
                } else {
                    retErr = ERROR_NOT_ENOUGH_MEMORY;
                }

                ldap_value_free(Values);

            } else
                retErr = LdapMapErrorToWin32(pLdap->ld_errno);

        } else
            retErr = LdapMapErrorToWin32(pLdap->ld_errno);

        ldap_msgfree(Message);
        Message = NULL;
    }

    return(retErr);

}

DWORD
MyLdapOpen(
    OUT PLDAP *pLdap
    )
/*++

Routine Description:

    Open a LDAP port and bind to it.

Arguments:

    pLdap   - the ldap handle to output

Return:

    Win32 error

--*/
{

    DWORD               Win32rc;
    WCHAR               sysName[256];
    DWORD               dSize = (sizeof(sysName) / sizeof(sysName[0]));

    if ( pLdap == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }
    //
    // get current computer and IP address
    //
    if ( !GetComputerName(sysName, &dSize) ) {
        Win32rc = GetLastError();

    } else {

        PDOMAIN_CONTROLLER_INFOW   DCInfo;    // for DsGetDcName

        HINSTANCE hDsGetDcDll = LoadLibrary(TEXT("netapi32.dll"));
        PFNDSGETDCNAME pfnDsGetDcName=NULL;


        if ( hDsGetDcDll) {
#if defined(UNICODE)
            pfnDsGetDcName = (PFNDSGETDCNAME)GetProcAddress(hDsGetDcDll,
                                                           "DsGetDcNameW");
#else
            pfnDsGetDcName = (PFNDSGETDCNAME)GetProcAddress(hDsGetDcDll,
                                                           "DsGetDcNameA");
#endif
        }

        if ( pfnDsGetDcName ) {
            Win32rc = (*pfnDsGetDcName)(sysName,
                                      NULL,
                                      NULL,
                                      NULL,
                                      DS_IP_REQUIRED,
                                      &DCInfo
                                      );
        } else {
            Win32rc = ERROR_PROC_NOT_FOUND;
        }

        if ( hDsGetDcDll ) {
            FreeLibrary(hDsGetDcDll);
        }

        if(Win32rc == ERROR_SUCCESS) {

            PWSTR   pwszAddress = DCInfo[0].DomainControllerAddress;
            if(*pwszAddress == L'\\') {
               pwszAddress += 2;
            }
            //
            // bind to ldap
            //
            *pLdap = ldap_open(pwszAddress, LDAP_PORT);

            if ( *pLdap == NULL ) {

                Win32rc = ERROR_FILE_NOT_FOUND;

            } else {
                Win32rc = ldap_bind_s(*pLdap,
                                    NULL,
                                    NULL,
                                    LDAP_AUTH_SSPI);

            }

            //
            // free DCInfo
            //
            LocalFree(DCInfo);
        }
    }

    return(Win32rc);

}

DWORD
MyLdapClose(
    IN PLDAP *pLdap
    )
/*++

Routine Description:

    Close the LDAP bind.

Arguments:

    pLdap   - the ldap handle

Return:

    Win32 error

--*/
{
    if ( pLdap != NULL ) {

        //
        // unbind pLDAP
        //
        if ( *pLdap != NULL )
            ldap_unbind(*pLdap);

        *pLdap = NULL;
    }

    return(ERROR_SUCCESS);
}


//*************************************************************
// Routines to handle events
//*************************************************************

BOOL InitializeEvents (void)
/*++

Routine Description:

    Opens the event log

Arguments:

    None

Return:

    TRUE if successful
    FALSE if an error occurs

--*/
{

    //
    // Open the event source
    //

    hEventLog = RegisterEventSource(NULL, EventSourceName);

    if (hEventLog) {
        return TRUE;
    }

    return FALSE;
}

int
LogEvent(
    IN DWORD LogLevel,
    IN DWORD dwEventID,
    IN UINT  idMsg,
    ...)
/*++

Routine Description:

    Logs a verbose event to the event log

Arguments:

    bLogLevel   - the severity level of the log
                        STATUS_SEVERITY_SUCCESS
                        STATUS_SEVERITY_INFORMATIONAL
                        STATUS_SEVERITY_WARNING
                        STATUS_SEVERITY_ERROR

    dwEventID   - the event ID (defined in uevents.mc)

    idMsg       - Message id

Return:

    TRUE if successful
    FALSE if an error occurs

--*/
{

    TCHAR szMsg[MAX_PATH];
    TCHAR szErrorMsg[2*MAX_PATH+40];
    LPTSTR aStrings[2];
    WORD wType;
    va_list marker;

    //
    // Load the message
    //
    if (idMsg != 0) {

        pLoadResourceString(idMsg, szMsg, MAX_PATH,
                     TEXT("Error loading resource string. Params : %x"));

    } else {
        lstrcpy (szMsg, TEXT("%s"));
    }


    //
    // Plug in the arguments
    //
    szErrorMsg[0] = L'\0';
    va_start(marker, idMsg);
    __try {
        wvsprintf(szErrorMsg, szMsg, marker);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    va_end(marker);

    //
    // Check for the event log being open.
    //

    if (!hEventLog) {
        if (!InitializeEvents()) {
            return -1;
        }
    }

    //
    // Report the event to the eventlog
    //

    aStrings[0] = szErrorMsg;

    switch (LogLevel) {
    case STATUS_SEVERITY_WARNING:
        wType = EVENTLOG_WARNING_TYPE;
        break;
    case STATUS_SEVERITY_SUCCESS:
        wType = EVENTLOG_SUCCESS;
        break;
    case STATUS_SEVERITY_ERROR:
        wType = EVENTLOG_ERROR_TYPE;
        break;
    default:
        wType = EVENTLOG_INFORMATION_TYPE;
        break;
    }

    if (!ReportEvent(hEventLog,
                     wType,
                     0,
                     dwEventID,
                     NULL,
                     1,
                     0,
                     (LPCTSTR *)aStrings,
                     NULL) ) {
        return 1;
    }

    return 0;
}


BOOL
ShutdownEvents (void)
/*++
Routine Description:

    Stops the event log

Arguments:

    None

Return:

    TRUE if successful
    FALSE if an error occurs
--*/
{
    BOOL bRetVal = TRUE;

    if (hEventLog) {
        bRetVal = DeregisterEventSource(hEventLog);
        hEventLog = NULL;
    }

    return bRetVal;
}

LPWSTR
GetCertDisplayInformation(
    IN PCCERT_CONTEXT pCertContext
    )
/*++

Routine Description:

    Returns the display string from the passed certificate context.

Arguments:

    pCertContext - Supplies a pointer to an open certificate context.

Return Value:

    On success, pointer to display string.  Caller must call
    free() to free.

    NULL on failure.

--*/

{
    DWORD Format = CERT_X500_NAME_STR  | CERT_NAME_STR_REVERSE_FLAG;

    //
    // First, try to get the email name
    //

    DWORD cchNameString;
    LPWSTR wszNameString = NULL;

    cchNameString = CertGetNameString(
                        pCertContext,
                        CERT_NAME_RDN_TYPE,
                        0,
                        &Format,
                        NULL,
                        0
                        );

    if (cchNameString != 1) {

        //
        // String was found
        //

        wszNameString = (LPWSTR)malloc( cchNameString * sizeof( WCHAR ));

        if (wszNameString) {

            cchNameString = CertGetNameString(
                                pCertContext,
                                CERT_NAME_RDN_TYPE,
                                0,
                                &Format,
                                wszNameString,
                                cchNameString
                                );
        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }

    } else {

        //
        // This shouldn't happen.  If it does, we'll return NULL.
        // Try to complain about it.
        //

        ASSERT( FALSE );
    }

    return( wszNameString );
}


BOOLEAN
IsSelfSignedPolicyExpired(
    IN PRECOVERY_POLICY_1_1 RecoveryPolicy OPTIONAL
    )

/*++

Routine Description:

    This routine checks if the existing recovery cert expiring within one year

Arguments:

    PolicyEfsInfo - Supplies a pointer to the current EFS recovery policy.

Return Value:

    return-value - TRUE if it is within one year

--*/

{
    BOOLEAN GetNewCert = TRUE;

    if (RecoveryPolicy == NULL) {
        //
        // We need to create a new one if none exists.
        //

        return TRUE;
    }

    if (RecoveryPolicy->RecoveryPolicyHeader.RecoveryKeyCount > 1){

        //
        // Default recovery policy changed.
        //

        return FALSE;
    }


    __try {

        //
        // Scan the recovery data looking for recovery keys in a format we understand
        //


        PEFS_PUBLIC_KEY_INFO PublicKeyInfo = &((PRECOVERY_KEY_1_1) &(RecoveryPolicy->RecoveryKeyList[0]))->PublicKeyInfo;


        if (PublicKeyInfo->KeySourceTag != EfsCertificate) {

            //
            //  Out dated recovery cert. Get a new one
            //

            return TRUE;
        }


        PBYTE pbCert = (PBYTE)OFFSET_TO_POINTER(CertificateInfo.Certificate, PublicKeyInfo);
        DWORD cbCert = PublicKeyInfo->CertificateInfo.CertificateLength;

        PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(
                              CRYPT_ASN_ENCODING,
                              (const PBYTE)pbCert,
                              cbCert);

        if (pCertContext) {

            SYSTEMTIME CertTime;
            SYSTEMTIME CrntTime;

            if (FileTimeToSystemTime(&(pCertContext->pCertInfo->NotAfter), &CertTime)){

                GetSystemTime( &CrntTime);

                if ( CertTime.wYear <= CrntTime.wYear + 1) {
                    //
                    // Get the display information
                    //

                    LPWSTR lpDisplayInfo = GetCertDisplayInformation( pCertContext );

                    if (lpDisplayInfo ) {

                        if (!wcstok( lpDisplayInfo, L"OU=EFS File Encryption Certificate" )){
                            GetNewCert = FALSE;
                        }

                        free(lpDisplayInfo);
                    }
                } else {

                    GetNewCert = FALSE;

                }
            }

            CertFreeCertificateContext( pCertContext );

        }


    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // There was something wrong with the recovery policy.
        // Get a new recovery cert.
        //

    }

    return GetNewCert;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\seclogon\server\profile.c ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997 - 1998.
 *
 * Name : seclogon.cxx
 * Author:Jeffrey Richter (v-jeffrr)
 *
 * Abstract:
 * This is the service DLL for Secondary Logon Service
 * This service supports the CreateProcessWithLogon API implemented
 * in advapi32.dll
 *
 * Revision History:
 * PraeritG    10/8/97  To integrate this in to services.exe
 *
-*/


#define STRICT

#include <Windows.h>
#include <userenv.h>
#include <lm.h>
#include <dsgetdc.h>
#include <sddl.h>

PTOKEN_USER
SlpGetTokenUser(
    HANDLE  TokenHandle,
    PLUID AuthenticationId OPTIONAL
    )
/*++

Routine Description:

    This routine returns the TOKEN_USER structure for the
    current user, and optionally, the AuthenticationId from his
    token.

Arguments:

    AuthenticationId - Supplies an optional pointer to return the
        AuthenticationId.

Return Value:

    On success, returns a pointer to a TOKEN_USER structure.

    On failure, returns NULL.  Call GetLastError() for more
    detailed error information.

--*/

{
    ULONG ReturnLength;
    TOKEN_STATISTICS TokenStats;
    PTOKEN_USER pTokenUser = NULL;
    BOOLEAN b = FALSE;

        if(!GetTokenInformation (
                     TokenHandle,
                     TokenUser,
                     NULL,
                     0,
                     &ReturnLength
                     ))
        {

            pTokenUser = (PTOKEN_USER)HeapAlloc( GetProcessHeap(), 0, 
                                                ReturnLength );

            if (pTokenUser) {

                if ( GetTokenInformation (
                             TokenHandle,
                             TokenUser,
                             pTokenUser,
                             ReturnLength,
                             &ReturnLength
                             ))
                {

                    if (AuthenticationId) {

                        if(GetTokenInformation (
                                     TokenHandle,
                                     TokenStatistics,
                                     (PVOID)&TokenStats,
                                     sizeof( TOKEN_STATISTICS ),
                                     &ReturnLength
                                     ))
                        {

                            *AuthenticationId = TokenStats.AuthenticationId;
                            b = TRUE;

                        } 

                    } else {

                        //
                        // We're done, mark that everything worked
                        //

                        b = TRUE;
                    }

                }

                if (!b) {

                    //
                    // Something failed, clean up what we were going to return
                    //

                    HeapFree( GetProcessHeap(), 0, pTokenUser );
                    pTokenUser = NULL;
                }
            } 
        } 

    return( pTokenUser );
}


DWORD
SlpGetUserName(
    IN  HANDLE  TokenHandle,
    OUT LPTSTR UserName,
    IN OUT PDWORD   UserNameLen,
    OUT LPTSTR DomainName,
    IN OUT PDWORD   DomNameLen
    )

/*++

Routine Description:

    This routine is the LSA Server worker routine for the LsaGetUserName
    API.


    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    UserName - Receives name of the current user.

    DomainName - Optionally receives domain name of the current user.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and all Sids have
            been translated to names.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.
--*/

{
    LUID LogonId;
    PTOKEN_USER TokenUserInformation = NULL;
    SID_NAME_USE    Use;

    //
    // Let's see if we're trying to look up the currently logged on
    // user.
    //
    //
    // TokenUserInformation from this call must be freed by calling
    // HeapFree().
    //

    TokenUserInformation = SlpGetTokenUser( TokenHandle, &LogonId );

    if ( TokenUserInformation ) {

        //
        // Simply do LookupAccountSid...
        //
        if(LookupAccountSid(NULL, TokenUserInformation->User.Sid,
                            UserName, UserNameLen, DomainName, DomNameLen,
                            &Use))
        {
            HeapFree( GetProcessHeap(), 0, TokenUserInformation );
            return ERROR_SUCCESS;
        }
        HeapFree( GetProcessHeap(), 0, TokenUserInformation );
        return GetLastError();

    }

    HeapFree( GetProcessHeap(), 0, TokenUserInformation );
    return GetLastError();

}


BOOL
SlpIsDomainUser(
    HANDLE  Token,
    PBOOLEAN IsDomain
    )
/*++

Routine Description:

    Determines if the current user is logged on to a domain account
    or a local machine account.

Arguments:

    IsDomain - Returns TRUE if the current user is logged on to a domain
        account, FALSE otherwise.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{
    TCHAR UserName[MAX_PATH];
    DWORD UserNameLen = MAX_PATH;
    TCHAR Domain[MAX_PATH];
    DWORD  DomNameLen = MAX_PATH;
    DWORD   Status;
    WCHAR pwszMachineName[(MAX_COMPUTERNAME_LENGTH + 1) * sizeof( WCHAR )];
    DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL b = FALSE;

    *IsDomain = FALSE;

    Status = SlpGetUserName( Token, UserName, &UserNameLen, 
                                    Domain, &DomNameLen );

    if (Status == ERROR_SUCCESS) {

        if (GetComputerName ( pwszMachineName, &nSize )) {

            *IsDomain = (lstrcmp( pwszMachineName, Domain ) != 0);

            b = TRUE;
        }

    }

    return( b );
}

BOOL
SlpLoadUserProfile(
    IN  HANDLE hToken,
    OUT PHANDLE hProfile
    )
/*++

Routine Description:

    This routine attempts to determine if the user's profile is loaded,
    and if it is not, loads it.

    Callers are expected to call SlpUnloadUserProfile() during their cleanup.

Arguments:

    hToken - Returns a handle to the user's token.

    hProfile - Returns a handle to the user's profile.

Return Value:

    TRUE if the profile is already loaded or if this routine loads it successfully,
    FALSE otherwise.

--*/

{
    BOOLEAN         b            = FALSE;
    BOOLEAN         DomainUser;
    BOOL            fReturn      = FALSE;
    TCHAR           lpDomainName[MAX_PATH];
    DWORD           DomNameLen = MAX_PATH;
    LPWSTR          lpServerName = NULL;
    PUSER_INFO_3    lpUserInfo;
    TCHAR           lpUserName[MAX_PATH];
    DWORD           UserNameLen = MAX_PATH;
    DWORD           rc           = ERROR_SUCCESS;
    LPWSTR          SidString    = NULL;
    NTSTATUS        Status;
    DWORD           dwResult; 

    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;

    *hProfile = NULL;

    //
    // First, see if the profile is loaded.  If it is,
    // make a simple call to LoadUserProfile just to refcount it
    // and return.
    //
        Status = SlpGetUserName(
                     hToken,
                     lpUserName,
                     &UserNameLen, 
                     lpDomainName,
                     &DomNameLen
                     );

        if (Status == ERROR_SUCCESS) {

            PTOKEN_USER TokenInfo = SlpGetTokenUser( hToken, NULL );

            if (TokenInfo != NULL) {

                PSID UserSid = TokenInfo->User.Sid;

                if(ConvertSidToStringSid( UserSid, &SidString ))
                {

                    LONG lRet;
                    HKEY phKeyCurrentUser;
                    
                    //
                    // Impersonate the user before doing this.
                    //
                    if (ImpersonateLoggedOnUser(hToken)) {
                        lRet = RegOpenKeyExW(
                                             HKEY_USERS,
                                             SidString,
                                             0,      // dwOptions
                                             MAXIMUM_ALLOWED,
                                             &phKeyCurrentUser
                                             );

                        RevertToSelf();
                    }
                    else {
                        lRet = GetLastError();
                        if (ERROR_SUCCESS == lRet) { 
                            lRet = ERROR_INTERNAL_ERROR; 
                        }
                    }

                    LocalFree(SidString);

                    if (ERROR_SUCCESS == lRet) {

                        //
                        // The profile is loaded.  Ref it so it doesn't disappear.
                        //

                        PROFILEINFO pi;

                        ZeroMemory (&pi, sizeof(pi));
                        pi.dwSize = sizeof(pi);
                        pi.lpUserName = lpUserName;

                        fReturn = LoadUserProfile (hToken, &pi);

                        if (!fReturn) {

                            rc = GetLastError();

                        } else {

                            *hProfile = pi.hProfile;
                        }

                        RegCloseKey( phKeyCurrentUser );

                    } else {

                        //
                        // The profile is not loaded.  Load it.
                        //

                        if (SlpIsDomainUser( hToken, &DomainUser )) {

                            if (DomainUser) {

                                //
                                // Determine the name of the DC for this domain
                                //

                                if (ImpersonateLoggedOnUser(hToken)) {
                                    if (ERROR_SUCCESS == (dwResult = DsGetDcName
							  (NULL,
							   lpDomainName,
							   NULL,
							   NULL,
							   0,
							   &DomainControllerInfo
							   ))) {

                                        lpServerName = DomainControllerInfo->DomainControllerName;
                                        b = TRUE;
                                    } else { 
					SetLastError(dwResult); 
				    }
                                    RevertToSelf();
                                }

                            } else {

                                lpServerName = NULL;

                                b = TRUE;
                            }

                        }

                        if (b) {

                            //
                            // Impersonate the user to get the information
                            //
                            if (ImpersonateLoggedOnUser(hToken)) { 
                                Status = NetUserGetInfo( lpServerName, lpUserName, 3, (LPBYTE *)&lpUserInfo );
                            
                                // we must revert before calling LoadUserProfile
                                RevertToSelf();
                            } else { 
                                Status = GetLastError();
                                if (ERROR_SUCCESS == Status) { 
                                    Status = ERROR_INTERNAL_ERROR; 
                                }
                            }

                            if (Status == ERROR_SUCCESS) {

                                PROFILEINFO pi;

                                ZeroMemory (&pi, sizeof(pi));
                                pi.dwSize = sizeof(pi);
                                pi.lpUserName = lpUserName;
                                pi.lpProfilePath = lpUserInfo->usri3_profile;

                                fReturn = LoadUserProfile (hToken, &pi);

                                if (fReturn) {
                                    *hProfile = pi.hProfile;
                                }

                                NetApiBufferFree( lpUserInfo );

                            }

                        }
                    }
                }
            }
            if(TokenInfo)
            {
                HeapFree( GetProcessHeap(), 0, TokenInfo );
            }
        }

        if (lpServerName) {
            NetApiBufferFree( DomainControllerInfo );
        }

    return( fReturn );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\seclogon\server\seclogon_s_stub.c ===
#include "seclogon_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\seclogon\server\stringid.h ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997
 *
 * Name : stringid.h
 * Author:PraeritG
 *
-*/

#define SECLOGON_STRING_DESCRIPTION        7000
#define SECLOGON_STRING_NAME               7001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\seclogon\notify\sclgntfy.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sclgntfy.cxx

Abstract:

    Notification dll for secondary logon service

Author:

    Praerit Garg (Praeritg)

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <winwlx.h>
#include "seclogon.h"
#include    <stdio.h>

#include "sclgntfy.hxx"

//
//  Some helpful tips about winlogon's notify events
//
//  1)  The logoff and shutdown notifications are always done
//      synchronously regardless of the Asynchronous registry entry.
//
//  2)  If you need to spawn child processes, you have to use
//      CreateProcessAsUser() otherwise the process will start
//      on winlogon's desktop (not the user's)
//
//  3)  The logon notification comes before the user's network
//      connections are restored.  If you need the user's persisted
//      net connections, use the StartShell event.
//
//  4)  Don't put any UI up during either screen saver event.
//      These events are intended for background processing only.
//


HINSTANCE g_hDllInstance=NULL;

#define NOTIFY_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\sclgntfy")

BOOL
SlpCreateProcessWithLogon(
      ULONG   LogonIdLowPart,
      LONG    LogonIdHighPart
      );

extern "C" void *__cdecl _alloca(size_t);

BOOL
SlpCreateProcessWithLogon(
      ULONG   LogonIdLowPart,
      LONG    LogonIdHighPart
      )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{

   BOOL                fOk          = FALSE;
   DWORD               dwResult;
   LPWSTR              pwszBinding  = NULL;
   RPC_BINDING_HANDLE  hRPCBinding  = NULL;
   SECL_BLOB           sbNULL       = { 0, NULL };
   SECL_SLI            sli;
   SECL_SLRI           slri;
   SECL_STRING         ssNULL       = { 0, 0, NULL };

   ZeroMemory(&sli,   sizeof(sli));
   ZeroMemory(&slri,  sizeof(slri));

   __try {
       sli.ulLogonIdLowPart    = LogonIdLowPart;
       sli.lLogonIdHighPart    = LogonIdHighPart;
       sli.ulProcessId         = GetCurrentProcessId();
       sli.ssUsername          = ssNULL;
       sli.ssDomain            = ssNULL;
       sli.ssPassword          = ssNULL;
       sli.ssApplicationName   = ssNULL;
       sli.ssCommandLine       = ssNULL;
       sli.ulCreationFlags     = 0;
       sli.sbEnvironment       = sbNULL;
       sli.ssCurrentDirectory  = ssNULL;
       sli.ssTitle             = ssNULL;
       sli.ssDesktop           = ssNULL;

      // Make the RPC call:
      //
      dwResult = RpcStringBindingCompose
          (NULL,
           (unsigned short *)L"ncacn_np",
           NULL,
           (unsigned short *)L"\\PIPE\\" wszSeclogonSharedProcEndpointName,
           NULL,
           (unsigned short **)&pwszBinding);
      if (RPC_S_OK != dwResult) { __leave; }

      dwResult = RpcBindingFromStringBinding((unsigned short *)pwszBinding, &hRPCBinding);
      if (0 != dwResult) { __leave; }

      __try {
          SeclCreateProcessWithLogonW
            (hRPCBinding,
             &sli,
             &slri);
      }
      __except(EXCEPTION_EXECUTE_HANDLER) {
          dwResult = RpcExceptionCode();
      }
      if (0 != dwResult) { __leave; }

      fOk = (slri.ulErrorCode == NO_ERROR);  // This function succeeds if the server's function succeeds
      if (!fOk) {
         //
         // If the server function failed, set the server's
         // returned eror code as this thread's error code
         //
         SetLastError(slri.ulErrorCode);
      }
   }
   __finally {
       if (NULL != pwszBinding) { RpcStringFree((unsigned short **)&pwszBinding); }
       if (NULL != hRPCBinding) { RpcBindingFree(&hRPCBinding); }
   }
   return(fOk);
}


//////////////////////////////// End Of File /////////////////////////////////


BOOL WINAPI DllMain(HANDLE hInstance, ULONG dwReason, LPVOID lpReserved)
//BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
//            DisableThreadLibraryCalls (hInstance);
            g_hDllInstance = (HINSTANCE)hInstance;

            }
            break;
    }

    return TRUE;
}

//
// WLEventLogon moved to recovery.cpp
//


VOID WLEventLogoff (PWLX_NOTIFICATION_INFO pInfo)
{
    TOKEN_STATISTICS    TokenStats;
    DWORD               ReturnLength;
    LUID                LogonId;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    // OutputDebugString (TEXT("NOTIFY:  Entering WLEventLogff.\r\n"));

    //
    // We are interested in this event.
    //

    //
    // We will basically call CreateProcessWithLogon
    // in a specially formed message such that secondary logon
    // service can cleanup processes associated with this
    // logon id.
    //

    if(GetTokenInformation(pInfo->hToken, TokenStatistics,
                            (PVOID *)&TokenStats,
                            sizeof(TOKEN_STATISTICS),
                            &ReturnLength))
    {
        LogonId.HighPart = TokenStats.AuthenticationId.HighPart;
        LogonId.LowPart = TokenStats.AuthenticationId.LowPart;

        SlpCreateProcessWithLogon(
                                LogonId.LowPart,
                                LogonId.HighPart
                                );
    }

}

VOID WLEventStartup (PWLX_NOTIFICATION_INFO pInfo)
{
    // OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartup.\r\n"));
}

VOID WLEventShutdown (PWLX_NOTIFICATION_INFO pInfo)
{
    // OutputDebugString (TEXT("NOTIFY:  Entering WLEventShutdown.\r\n"));
}

VOID WLEventStartScreenSaver (PWLX_NOTIFICATION_INFO pInfo)
{
    // OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartScreenSaver.\r\n"));
}

VOID WLEventStopScreenSaver (PWLX_NOTIFICATION_INFO pInfo)
{
    // OutputDebugString (TEXT("NOTIFY:  Entering WLEventStopScreenSaver.\r\n"));
}

VOID WLEventLock (PWLX_NOTIFICATION_INFO pInfo)
{
    // OutputDebugString (TEXT("NOTIFY:  Entering WLEventLock.\r\n"));
}

VOID WLEventUnlock (PWLX_NOTIFICATION_INFO pInfo)
{
    // OutputDebugString (TEXT("NOTIFY:  Entering WLEventUnlock.\r\n"));
}

VOID WLEventStartShell (PWLX_NOTIFICATION_INFO pInfo)
{
    // OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartShell.\r\n"));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwTemp;

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, NOTIFY_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    DllRegisterServerEFS();


    RegSetValueEx (hKey, TEXT("Logoff"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLogoff"),
                   (lstrlen(TEXT("WLEventLogoff")) + 1) * sizeof(TCHAR));

#if 0

    RegSetValueEx (hKey, TEXT("Logon"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLogon"),
                   (lstrlen(TEXT("WLEventLogon")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Startup"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartup"),
                   (lstrlen(TEXT("WLEventStartup")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Shutdown"), 0, REG_SZ, (LPBYTE)TEXT("WLEventShutdown"),
                   (lstrlen(TEXT("WLEventShutdown")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StartScreenSaver"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartScreenSaver"),
                   (lstrlen(TEXT("WLEventStartScreenSaver")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StopScreenSaver"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStopScreenSaver"),
                   (lstrlen(TEXT("WLEventStopScreenSaver")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Lock"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLock"),
                   (lstrlen(TEXT("WLEventLock")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Unlock"), 0, REG_SZ, (LPBYTE)TEXT("WLEventUnlock"),
                   (lstrlen(TEXT("WLEventUnlock")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StartShell"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartShell"),
                   (lstrlen(TEXT("WLEventStartShell")) + 1) * sizeof(TCHAR));
#endif

    dwTemp = 0;
    RegSetValueEx (hKey, TEXT("Impersonate"), 0, REG_DWORD, (LPBYTE)&dwTemp, sizeof(dwTemp));

    dwTemp = 1;
    RegSetValueEx (hKey, TEXT("Asynchronous"), 0, REG_DWORD, (LPBYTE)&dwTemp, sizeof(dwTemp));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("sclgntfy.dll"),
                   (lstrlen(TEXT("sclgntfy.dll")) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, NOTIFY_PATH);

    return S_OK;
}

BOOL
pLoadResourceString(
    IN UINT idMsg,
    OUT LPTSTR lpBuffer,
    IN int nBufferMax,
    IN LPTSTR lpDefault
    )
{
    if ( lpBuffer == NULL || lpDefault == NULL ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( g_hDllInstance == NULL ||
         !LoadString (g_hDllInstance,
                      idMsg,
                      lpBuffer,
                      nBufferMax)) {

        wcscpy(lpBuffer, lpDefault);
        lpBuffer[nBufferMax-1] = L'\0';
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\seclogon\server\seclogon.c ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997 - 1998.
 *
 * Name : seclogon.cxx
 * Author:Jeffrey Richter (v-jeffrr)
 *
 * Abstract:
 * This is the service DLL for Secondary Logon Service
 * This service supports the CreateProcessWithLogon API implemented
 * in advapi32.dll
 *
 * Revision History:
 * PraeritG    10/8/97  To integrate this in to services.exe
 *
-*/


#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <Windows.h>
#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>
#include <secint.h>
#include <winsafer.h>
#include <shellapi.h>
#include <svcs.h>
#include <userenv.h>
#include <sddl.h>

#include "seclogon.h"
#include <stdio.h>
#include "stringid.h"
#include "dbgdef.h"

//
// must move to winbase.h soon!
#define LOGON_WITH_PROFILE              0x00000001
#define LOGON_NETCREDENTIALS_ONLY       0x00000002

#define MAXIMUM_SECLOGON_PROCESSES      MAXIMUM_WAIT_OBJECTS*4

#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ALL  (WINSTA_ENUMDESKTOPS     | WINSTA_READATTRIBUTES    | \
                     WINSTA_ACCESSCLIPBOARD  | WINSTA_CREATEDESKTOP     | \
                     WINSTA_WRITEATTRIBUTES  | WINSTA_ACCESSGLOBALATOMS | \
                     WINSTA_EXITWINDOWS      | WINSTA_ENUMERATE         | \
                     WINSTA_READSCREEN       | \
                     STANDARD_RIGHTS_REQUIRED)


struct SECL_STATE { 
    SERVICE_STATUS         serviceStatus; 
    SERVICE_STATUS_HANDLE  hServiceStatus; 
} g_state; 

typedef struct _SECONDARYLOGONINFOW {
    // First fields should all be quad-word types to avoid alignment errors:
    LPSTARTUPINFO  lpStartupInfo; 
    LPWSTR         lpUsername;
    LPWSTR         lpDomain;
    LPWSTR         lpPassword;
    LPWSTR         lpApplicationName;
    LPWSTR         lpCommandLine;
    LPVOID         lpEnvironment;
    LPCWSTR        lpCurrentDirectory;

    // Next group of fields are double-word types: 
    DWORD          dwProcessId;
    ULONG          LogonIdLowPart;
    LONG           LogonIdHighPart;
    DWORD          dwLogonFlags;
    DWORD          dwCreationFlags;

    DWORD          dwSeclogonFlags; 
    HANDLE         hWinsta; 
    HANDLE         hDesk; 
    // Insert smaller types below:  
    BOOL           fFreeWinsta; 
    BOOL           fFreeDesk; 
} SECONDARYLOGONINFOW, *PSECONDARYLOGONINFOW;


typedef struct _SECONDARYLOGONRETINFO {
   PROCESS_INFORMATION pi;
   DWORD   dwErrorCode;
} SECONDARYLOGONRETINFO, *PSECONDARYLOGONRETINFO;

typedef struct _SECONDARYLOGINWATCHINFO {
   HANDLE hProcess;
   HANDLE hToken;
   HANDLE hProfile;
   LUID LogonId;
   PSECONDARYLOGONINFOW psli;
} SECONDARYLOGONWATCHINFO, *PSECONDARYLOGONWATCHINFO;

typedef struct _JOBINFO {
    HANDLE  Job;
    LUID    LogonId;
} JOBINFO, *PJOBINFO;

#define _JumpCondition(condition, label) \
    if (condition) \
    { \
	goto label; \
    } \
    else { } 

#define _JumpConditionWithExpr(condition, label, expr) \
    if (condition) \
    { \
        expr; \
	goto label; \
    } \
    else { } 

#define ARRAYSIZE(array)  ((sizeof(array)) / (sizeof(array[0])))
#define FIELDOFFSET(s,m)  ((size_t)(ULONG_PTR)&(((s *)0)->m))

HANDLE                 g_hThreadWatchdog;
JOBINFO                g_Jobs[MAXIMUM_SECLOGON_PROCESSES];
HANDLE                 g_hProcess[MAXIMUM_SECLOGON_PROCESSES];
HANDLE                 g_hToken[MAXIMUM_SECLOGON_PROCESSES];
HANDLE                 g_hProfile[MAXIMUM_SECLOGON_PROCESSES];
LUID                   g_LogonId[MAXIMUM_SECLOGON_PROCESSES];
PSECONDARYLOGONINFOW   g_psli[MAXIMUM_SECLOGON_PROCESSES];
int                    g_nNumSecondaryLogonProcesses         = 0;
CRITICAL_SECTION       csForProcessCount;
CRITICAL_SECTION       csForDesktop;
BOOL                   g_fIsCsInitialized                    = FALSE; 
BOOL                   g_fTerminateSecondaryLogonService     = FALSE;
PSVCHOST_GLOBAL_DATA   GlobalData;
HANDLE                 g_hIOCP                               = NULL;
BOOL                   g_fCleanupThreadActive                = FALSE; 

//
// function prototypes
//
void  Free_SECONDARYLOGONINFOW(PSECONDARYLOGONINFOW psli); 
void  FreeGlobalState(); 
DWORD InitGlobalState(); 
DWORD MySetServiceStatus(DWORD dwCurrentState, DWORD dwCheckPoint, DWORD dwWaitHint, DWORD dwExitCode);
DWORD MySetServiceStopped(DWORD dwExitCode);
DWORD SeclStartRpcServer();
DWORD SeclStopRpcServer();
VOID  SecondaryLogonCleanupJob(LPVOID pvJobIndex, BOOL *pfLastJob); 
BOOL  SlpLoadUserProfile(HANDLE hToken, PHANDLE hProfile);
DWORD To_SECONDARYLOGONINFOW(PSECL_SLI pSeclSli, PSECONDARYLOGONINFOW *ppsli);
DWORD To_SECL_SLRI(SECONDARYLOGONRETINFO *pslri, PSECL_SLRI pSeclSlri);


void DbgPrintf( DWORD dwSubSysId, LPCSTR pszFormat , ...)
{
    va_list args; 
    CHAR    pszBuffer[1024]; 
    
    va_start(args, pszFormat);
    _vsnprintf(pszBuffer, 1024, pszFormat, args); 
    va_end(args);
}

BOOL
IsSystemProcess(
        VOID
        )
{
    PTOKEN_USER User;
    HANDLE      Token;
    DWORD       RetLen;
    PSID        SystemSid = NULL;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
    BYTE        Buffer[100];

    if(AllocateAndInitializeSid(&SidAuthority,1,SECURITY_LOCAL_SYSTEM_RID,
                                0,0,0,0,0,0,0,&SystemSid))
    {
        if(OpenThreadToken(GetCurrentThread(), MAXIMUM_ALLOWED, FALSE, &Token))
        {
            if(GetTokenInformation(Token, TokenUser, Buffer, 100, &RetLen))
            {
                User = (PTOKEN_USER)Buffer;

                CloseHandle(Token);

                if(EqualSid(User->User.Sid, SystemSid))
                {
                    FreeSid(SystemSid);
                    return TRUE;
                }
            }
            else
                CloseHandle(Token);
        }
        FreeSid(SystemSid);
    }
    return FALSE;
}



DWORD
SlpGetClientLogonId(
    HANDLE  Process,
    PLUID    LogonId
    )

{
    HANDLE  Token;
    TOKEN_STATISTICS    TokenStats;
    DWORD   ReturnLength;

    //
    // Get handle to the process token.
    //
    if(OpenProcessToken(Process, MAXIMUM_ALLOWED, &Token))
    {
        if(GetTokenInformation (
                     Token,
                     TokenStatistics,
                     (PVOID)&TokenStats,
                     sizeof( TOKEN_STATISTICS ),
                     &ReturnLength
                     ))
        {

            *LogonId = TokenStats.AuthenticationId;
            CloseHandle(Token);
            return ERROR_SUCCESS;

        }
        CloseHandle(Token);
    }
    return GetLastError();
}


DWORD ModifyUserAccessToObject
(IN  HANDLE  hObject, 
 IN  PSID    pUserSid, 
 IN  DWORD   dwAccessMask,  // access mask to apply IF granting access
 IN  BYTE    bAceFlags,     // flags to supply with Ace IF granting access
 IN  BOOL    fAdd           // true if we're granting access
)
{
    ACL_SIZE_INFORMATION  asiSize;
    PACCESS_ALLOWED_ACE   pAce             = NULL;
    PACCESS_ALLOWED_ACE   pAceNew          = NULL;
    BOOL                  fRemovedAccess   = FALSE; 
    BOOL                  fDaclDefaulted;
    BOOL                  fDaclPresent; 
    DWORD                 dwIndex; 
    DWORD                 dwNeeded;
    DWORD                 dwNewAclSize; 
    DWORD                 dwResult; 
    PACL                  pDaclNew         = NULL; 
    PACL                  pDaclReadOnly    = NULL;
    SECURITY_DESCRIPTOR   SdNew;
    PSECURITY_DESCRIPTOR  pSdReadOnly      = NULL; 
    SECURITY_INFORMATION  siRequested;

    // Initialize non-pointer data: 
    ZeroMemory(&SdNew, sizeof(SdNew)); 

    // Query the security descriptor
    siRequested = DACL_SECURITY_INFORMATION;
    if (!GetUserObjectSecurity(hObject, &siRequested, pSdReadOnly, 0, &dwNeeded))
    {
        // allocate buffer large for returned SD and another ACE.
        pSdReadOnly = (PSECURITY_DESCRIPTOR) HeapAlloc (GetProcessHeap(), 0, dwNeeded + 100);
        if (NULL == pSdReadOnly)
            goto MemoryError; 
        
        if (!GetUserObjectSecurity(hObject, &siRequested, pSdReadOnly, dwNeeded, &dwNeeded))
            goto GetUserObjectSecurityError; 
    }
    else 
    {
        // There's no security descriptor, not much we can do here!
        goto SuccessReturn;
    }

    if (!GetSecurityDescriptorDacl(pSdReadOnly, &fDaclPresent, &pDaclReadOnly, &fDaclDefaulted))
        goto GetSecurityDescriptorDaclError; 

    // if Dacl is null, we don't need to do anything
    // because it gives WORLD full control...
    if (!fDaclPresent || NULL == pDaclReadOnly)
        goto SuccessReturn; 

    // Compute the size for the new ACL, based on the size of the current
    // ACL, and the operation to be performed on it. 
    if (!GetAclInformation(pDaclReadOnly, (PVOID)&asiSize, sizeof(asiSize), AclSizeInformation))
        goto GetAclInformationError; 

    if (fAdd) 
        dwNewAclSize = asiSize.AclBytesInUse + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pUserSid) + sizeof(DWORD); 
    else
        dwNewAclSize = asiSize.AclBytesInUse - sizeof(ACCESS_ALLOWED_ACE) - GetLengthSid(pUserSid) + sizeof(DWORD); 
            
    pDaclNew = (PACL)HeapAlloc(GetProcessHeap(), 0, dwNewAclSize); 
    if (NULL == pDaclNew) 
        goto MemoryError; 

    if (!InitializeAcl(pDaclNew, dwNewAclSize, ACL_REVISION))
        goto InitializeAclError; 

    if (fAdd) // We're granting the user access
    {
        if (!AddAccessAllowedAce(pDaclNew, ACL_REVISION, dwAccessMask, pUserSid))
            goto AddAccessAllowedAceError; 

        if (!GetAce(pDaclNew, 0, &pAceNew))
            goto GetAceError; 

        pAceNew->Header.AceFlags = bAceFlags; 
    }

    // Copy over the ACEs that are still valid
    // (all if adding, all but the user's SID if removing). 
    for (dwIndex = 0; dwIndex < asiSize.AceCount; dwIndex++)
    {
        if (!GetAce(pDaclReadOnly, dwIndex, (PVOID*)(&pAce)))
            goto GetAceError; 

        // We're removing -- check if this ACE contains the user's SID
        if (!fAdd && !fRemovedAccess)
        {
            if ((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) 
            {
                if (EqualSid(pUserSid, (PSID)(&(pAce->SidStart))))
                {
                    // Don't add this ACE to the new ACL we're constructing.
                    // NOTE: we only want to remove one ACCESS_ALLOWED_ACE.  Otherwise, if the
                    //       user already had access to the desktop, we could
                    //       be removing the access they previously had!
                    fRemovedAccess = TRUE; 
                    continue; 
                }
            }
        }
        
        if (!AddAce(pDaclNew, ACL_REVISION, 0xFFFFFFFF, pAce, ((PACE_HEADER)pAce)->AceSize))
            goto AddAceError; 
    }
    
    // Create the new security descriptor to assign to the object: 
    if (!InitializeSecurityDescriptor(&SdNew, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError; 

    // Add the new DACL to the descriptor: 
    if (!SetSecurityDescriptorDacl(&SdNew, TRUE, pDaclNew, fDaclDefaulted))
        goto SetSecurityDescriptorDaclError; 

    // Finally, set the object security using our new security descriptor.  
    siRequested = DACL_SECURITY_INFORMATION;
    if (!SetUserObjectSecurity(hObject, &siRequested, &SdNew))
        goto SetUserObjectSecurityError; 

 SuccessReturn:
    dwResult = ERROR_SUCCESS; 
 ErrorReturn:
    if (NULL != pSdReadOnly)  { HeapFree(GetProcessHeap(), 0, pSdReadOnly); }
    if (NULL != pDaclNew)     { HeapFree(GetProcessHeap(), 0, pDaclNew); } 
    return dwResult; 
    
SET_DWRESULT(AddAceError,                        GetLastError()); 
SET_DWRESULT(AddAccessAllowedAceError,           GetLastError()); 
SET_DWRESULT(GetAceError,                        GetLastError());
SET_DWRESULT(GetAclInformationError,             GetLastError()); 
SET_DWRESULT(GetSecurityDescriptorDaclError,     GetLastError()); 
SET_DWRESULT(GetUserObjectSecurityError,         GetLastError()); 
SET_DWRESULT(InitializeAclError,                 GetLastError()); 
SET_DWRESULT(InitializeSecurityDescriptorError,  GetLastError()); 
SET_DWRESULT(MemoryError,                        ERROR_NOT_ENOUGH_MEMORY); 
SET_DWRESULT(SetSecurityDescriptorDaclError,     GetLastError()); 
SET_DWRESULT(SetUserObjectSecurityError,         GetLastError()); 
}

DWORD ModifyUserAccessToDesktop
(IN HANDLE  hWinsta, 
 IN HANDLE  hDesk, 
 IN HANDLE  hToken, 
 IN BOOL    fAdd)
{
    BOOL                  fEnteredCriticalSection = FALSE; 
    BYTE                  rgbSidBuff[256]; 
    DWORD                 dwResult             = ERROR_SUCCESS; 
    DWORD                 dwReturnedLen; 
    PTOKEN_USER           pTokenUser           = NULL; 

    // Get the SID from the token: 
    pTokenUser = (PSID)&rgbSidBuff[0]; 
    if (!GetTokenInformation(hToken, TokenUser, pTokenUser, sizeof(rgbSidBuff), &dwReturnedLen))
        goto GetTokenInformationError; 

    // We don't want any other threads messing with the desktop ACL
    EnterCriticalSection(&csForDesktop); 
    fEnteredCriticalSection = TRUE; 

    if (NULL != hWinsta)
    {
        dwResult = ModifyUserAccessToObject(hWinsta, pTokenUser->User.Sid, WINSTA_ALL, NO_PROPAGATE_INHERIT_ACE, fAdd); 
        if (ERROR_SUCCESS != dwResult)
            goto ModifyUserAccessToObjectError; 
    }

    if (NULL != hDesk)
    {
        dwResult = ModifyUserAccessToObject(hDesk, pTokenUser->User.Sid, DESKTOP_ALL, 0, fAdd); 
        if (ERROR_SUCCESS != dwResult)
            goto ModifyUserAccessToObjectError; 
    }

    dwResult = ERROR_SUCCESS; 
 ErrorReturn:
    if (fEnteredCriticalSection)  { LeaveCriticalSection(&csForDesktop); }
    return dwResult;

SET_DWRESULT(GetTokenInformationError,     GetLastError()); 
TRACE_ERROR (ModifyUserAccessToObjectError);
}

DWORD 
WINAPI 
WaitForNextJobTermination(PVOID pvIgnored)
{
    BOOL        fResult; 
    DWORD       dwNumberOfBytes; 
    DWORD       dwResult; 
    OVERLAPPED *po; 
    ULONG_PTR   ulptrCompletionKey; 

    while (TRUE)
    {
	fResult = GetQueuedCompletionStatus(g_hIOCP, &dwNumberOfBytes, &ulptrCompletionKey, &po, INFINITE); 
	if (!fResult) { 
	    // We've encountered an error.  Shutdown our cleanup thread -- the next runas will queue another one.
	    EnterCriticalSection(&csForProcessCount);
	    g_fCleanupThreadActive = FALSE; 
	    LeaveCriticalSection(&csForProcessCount);

	    goto GetQueuedCompletionStatusError; 
	}

	// When waiting on job objects, the dwNumberOfBytes contains a message ID, indicating
	// the event which just occured. 
	switch (dwNumberOfBytes)
	{
	case JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO:
	    {
		BOOL fLastJob; 

		// All of our processes have terminated.  Call our cleanup function. 
		SecondaryLogonCleanupJob((LPVOID)ulptrCompletionKey /*job index*/, &fLastJob); 
		if (fLastJob) 
		{ 
		    // There are no more jobs -- we're done processing notification.  
		    goto CommonReturn;
		} 
		else 
		{ 
		    // More jobs left to clean up.  Keep processing...
		}
	    }
	default:;  
	    // some message we don't care about.  Try again. 
	}
    }
    
 CommonReturn:
    dwResult = ERROR_SUCCESS; 
 ErrorReturn:
    return dwResult; 

SET_DWRESULT(GetQueuedCompletionStatusError, GetLastError()); 
}

VOID
SecondaryLogonCleanupJob(
    LPVOID   pvJobIndex,
    BOOL    *pfLastJob
    )
/*++

Routine Description:
    This routine is a process cleanup handler when one of the secondary
    logon process goes away.

Arguments:
    dwProcessIndex -- the actual index to the process, the pointer is cast
                      back to dword.  THIS IS SAFE IN SUNDOWN.
    fWaitStatus -- status of the wait done by one of services.exe threads.

Return Value:
   always 0.

--*/
{
    DWORD   dwJobIndex  = PtrToUlong(pvJobIndex);
    DWORD   ProcessNum  = dwJobIndex;  // 1-to-1 mapping between jobs and runas'd processes
    DWORD   dwResult; 

    EnterCriticalSection(&csForProcessCount);

    // We've found another process in this job.  
    if(g_psli[ProcessNum])
    {
        // we don't care about return value.
	ModifyUserAccessToDesktop(g_psli[ProcessNum]->hWinsta, g_psli[ProcessNum]->hDesk, g_hToken[ProcessNum], FALSE /*remove*/);
	Free_SECONDARYLOGONINFOW(g_psli[ProcessNum]);
	g_psli[ProcessNum] = NULL;
    }
	
    if(g_hProcess[ProcessNum])
    {
	CloseHandle(g_hProcess[ProcessNum]);
	g_hProcess[ProcessNum] = NULL;
    }
    
    if(g_hProfile[ProcessNum] != NULL)
    {
	UnloadUserProfile(g_hToken[ProcessNum], g_hProfile[ProcessNum]);
	g_hProfile[ProcessNum] = NULL;
    }
    
    if(g_hToken[ProcessNum])
    {
	CloseHandle(g_hToken[ProcessNum]);
	g_hToken[ProcessNum] = NULL;
    }
    
    // Close off this job: 
    CloseHandle(g_Jobs[dwJobIndex].Job); 
    g_Jobs[dwJobIndex].Job = NULL; 

    *pfLastJob  = --g_nNumSecondaryLogonProcesses == 0;

    // If it's the last job, the cleanup thread terminates:
    g_fCleanupThreadActive = !(*pfLastJob); 
    
    // Update the service status to reflect whether there is a runas'd process alive.  
    MySetServiceStatus(SERVICE_RUNNING, 0, 0, 0); 

    LeaveCriticalSection(&csForProcessCount);

    return;
}



VOID
APIENTRY
SecondaryLogonProcessWatchdogNewProcess(
      PSECONDARYLOGONWATCHINFO dwParam
      )

/*++

Routine Description:
    This routine puts the secondary logon process created on the wait queue
    such that cleanup can be done after the process dies.

Arguments:
    dwParam -- the pointer to the process information.

Return Value:
    none.

--*/
{
    DWORD                                j, FirstFreeJob; 
    unsigned __int3264                   i;
    BOOL                                 JobFound;
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT  joacp;
    LUID                                 ProcessLogonId;
    ULONG_PTR                            ulptrJobIndex; 

    if (dwParam != NULL) {
	PSECONDARYLOGONWATCHINFO pslwi = (PSECONDARYLOGONWATCHINFO) dwParam;
	EnterCriticalSection(&csForProcessCount);
	for(i=0;i<MAXIMUM_SECLOGON_PROCESSES;i++)
	{
	    // if(g_hProcess[i] == LongToHandle(0xDEADBEEF)) break;
	    if(g_hProcess[i] == NULL) break;
	}

	g_hProcess[i] = pslwi->hProcess;
	g_hToken[i] = pslwi->hToken;
	g_hProfile[i] = pslwi->hProfile;
	g_LogonId[i].LowPart = pslwi->LogonId.LowPart;
	g_LogonId[i].HighPart = pslwi->LogonId.HighPart;
	g_psli[i] = pslwi->psli;
      
	// Initialize this job with the logon ID of the client process.  
	// If this is a recursive runas, we'll override this value in the following loop
	g_Jobs[i].LogonId.LowPart  = g_LogonId[i].LowPart; 
	g_Jobs[i].LogonId.HighPart = g_LogonId[i].HighPart;
	
	// Determine which logon session the new process should be associated with. 
	for(j=0;j<MAXIMUM_SECLOGON_PROCESSES;j++)
	{
	    if(g_Jobs[j].Job != NULL)
	    {
		SlpGetClientLogonId(g_hProcess[j], &ProcessLogonId);
		if(ProcessLogonId.LowPart == g_LogonId[i].LowPart && ProcessLogonId.HighPart == g_LogonId[i].HighPart)
		{
		    JobFound = TRUE; 
		    g_Jobs[i].LogonId.LowPart  = g_Jobs[j].LogonId.LowPart;
		    g_Jobs[i].LogonId.HighPart = g_Jobs[j].LogonId.HighPart;
		    
		    break;
		}
		
	    }
	}
	
	// Increment the number of runas'd processes 
	g_nNumSecondaryLogonProcesses++; 

	// BUGBUG:  we currently have no means of recovering from failures
	//          in the functions below.  

	// we have to create a new one;
	g_Jobs[i].Job = CreateJobObject(NULL, NULL);
	if (NULL != g_Jobs[i].Job)
	{
	    if (AssignProcessToJobObject(g_Jobs[i].Job, g_hProcess[i]))
	    {
		ulptrJobIndex = i; 
      
		// Register our IO completion port to wait for events from this job: 
		joacp.CompletionKey  = (LPVOID)ulptrJobIndex; 
		joacp.CompletionPort = g_hIOCP; 

		if (SetInformationJobObject(g_Jobs[i].Job, JobObjectAssociateCompletionPortInformation, &joacp, sizeof(joacp)))
		{
		    
		    // If we don't already have a cleanup thread running, start one now: 
		    if (!g_fCleanupThreadActive) 
		    {
			g_fCleanupThreadActive = QueueUserWorkItem(WaitForNextJobTermination, NULL, WT_EXECUTELONGFUNCTION); 
		    }
		}
	    }
	}

	// Update the service status to reflect that there is a runas'd process
	// This prevents the service from receiving SERVICE_STOP controls
	// while runas'd processes are alive. 
	MySetServiceStatus(SERVICE_RUNNING, 0, 0, 0); 
	
	LeaveCriticalSection(&csForProcessCount);
    } else {
	//
	// We were just awakened in order to terminate the service (nothing to do)
	//
    }
}

DWORD ServiceStop(BOOL fShutdown, DWORD dwExitCode) 
{ 
    DWORD   dwCheckPoint = 0; 
    DWORD   dwIndex; 
    DWORD   dwResult; 

    // Don't want the process count to change while we're shutting down the service!
    EnterCriticalSection(&csForProcessCount);
    
    // Only stop if we have no runas'd processes, or if we're shutting down
    if (fShutdown || 0 == g_nNumSecondaryLogonProcesses) { 
        dwResult = MySetServiceStatus(SERVICE_STOP_PENDING, dwCheckPoint++, 0, 0); 
        _JumpCondition(ERROR_SUCCESS != dwResult && !fShutdown, MySetServiceStatusError); 

        // We shouldn't hold the critical section while we're shutting down the RPC server, 
        // because RPC threads may be trying to acquire it. 
        LeaveCriticalSection(&csForProcessCount); 

        dwResult = SeclStopRpcServer(); 
        _JumpCondition(ERROR_SUCCESS != dwResult && !fShutdown, SeclStopRpcServerError); 

        dwResult = MySetServiceStatus(SERVICE_STOP_PENDING, dwCheckPoint++, 0, 0); 
        _JumpCondition(ERROR_SUCCESS != dwResult && !fShutdown, MySetServiceStatusError); 

        g_fTerminateSecondaryLogonService = TRUE;

        if (g_fIsCsInitialized)
        {
            DeleteCriticalSection(&csForProcessCount);
            DeleteCriticalSection(&csForDesktop); 
            g_fIsCsInitialized = FALSE; 
        }

	if (NULL != g_hIOCP)
	{
	    CloseHandle(g_hIOCP); 
	    g_hIOCP = NULL; 
	}

        // Unlike MySetServiceStatus, this routine doesn't access any 
        // global state which could have been freed: 
        dwResult = MySetServiceStopped(dwExitCode); 
        _JumpCondition(ERROR_SUCCESS != dwResult && !fShutdown, MySetServiceStopped); 
    }        

    dwResult = ERROR_SUCCESS; 
 ErrorReturn:
    return dwResult; 

SET_DWRESULT(MySetServiceStatusError, dwResult);
SET_DWRESULT(MySetServiceStopped,     dwResult);
SET_DWRESULT(SeclStopRpcServerError,  dwResult);
}

void
WINAPI
ServiceHandler(
    DWORD fdwControl
    )
/*++

Routine Description:

    Service handler which wakes up the main service thread when ever
    service controller needs to send a message.

Arguments:

    fdwControl -- the control from the service controller.

Return Value:
    none.

--*/
{
    BOOL    fResult; 
    BOOL    fCanStopService    = TRUE; 
    DWORD   dwNextState        = g_state.serviceStatus.dwCurrentState; 
    DWORD   dwResult; 

    switch (fdwControl) 
    {
    case SERVICE_CONTROL_CONTINUE:
        dwResult = MySetServiceStatus(SERVICE_CONTINUE_PENDING, 0, 0, 0); 
        _JumpCondition(ERROR_SUCCESS != dwResult, MySetServiceStatusError); 
        dwResult = SeclStartRpcServer(); 
        _JumpCondition(ERROR_SUCCESS != dwResult, StartRpcServerError); 
        dwNextState = SERVICE_RUNNING; 
        break; 

    case SERVICE_CONTROL_INTERROGATE: 
        break; 

    case SERVICE_CONTROL_PAUSE:
        dwResult = MySetServiceStatus(SERVICE_PAUSE_PENDING, 0, 0, 0); 
        _JumpCondition(ERROR_SUCCESS != dwResult, MySetServiceStatusError); 
        dwResult = SeclStopRpcServer(); 
        _JumpCondition(ERROR_SUCCESS != dwResult, StopRpcServerError); 
        dwNextState = SERVICE_PAUSED; 
        break; 

    case SERVICE_CONTROL_STOP:
        dwResult = ServiceStop(FALSE /*fShutdown*/, ERROR_SUCCESS); 
        _JumpCondition(ERROR_SUCCESS != dwResult, ServiceStopError);
        return ; // All global state has been freed, just exit. 

    case SERVICE_CONTROL_SHUTDOWN:
        dwResult = ServiceStop(TRUE /*fShutdown*/, ERROR_SUCCESS); 
        _JumpCondition(ERROR_SUCCESS != dwResult, ServiceStopError); 
        return ; // All global state has been freed, just exit. 
        
    default:
        // Unhandled service control!
        goto ErrorReturn; 
    }

 CommonReturn:
    // Restore the original state on error, set the new state on success. 
    dwResult = MySetServiceStatus(dwNextState, 0, 0, 0); 
    return; 

 ErrorReturn: 
    goto CommonReturn; 

SET_ERROR(MySetServiceStatusError,  dwResult); 
SET_ERROR(ServiceStopError,         dwResult);
SET_ERROR(StartRpcServerError,      dwResult); 
SET_ERROR(StopRpcServerError,       dwResult); 
}



VOID
SlrCreateProcessWithLogon
(IN  RPC_BINDING_HANDLE      hRPCBinding,
 IN  PSECONDARYLOGONINFOW    psli,
 OUT PSECONDARYLOGONRETINFO  pslri)

/*++

Routine Description:
    The core routine -- it handles a client request to start a secondary
    logon process.

Arguments:
    psli -- the input structure with client request information
    pslri -- the output structure with response back to the client.

Return Value:
    none.

--*/
{
    BOOL fAccessWasAllowed = FALSE; 
   HANDLE hCurrentThread = NULL; 
   HANDLE hCurrentThreadToken = NULL; 
   HANDLE hToken = NULL;
   HANDLE hProfile = NULL;
   HANDLE hProcessClient = NULL;
   PVOID  pvEnvBlock = NULL, pvUserProfile = NULL;
   BOOL fCreatedEnvironmentBlock   = FALSE; 
   BOOL fIsImpersonatingRpcClient  = FALSE; 
   BOOL fIsImpersonatingClient     = FALSE; 
   BOOL fInheritHandles            = FALSE;
   BOOL fOpenedSTDIN               = FALSE; 
   BOOL fOpenedSTDOUT              = FALSE; 
   BOOL fOpenedSTDERR              = FALSE; 
   PROFILEINFO pi;
   SECURITY_ATTRIBUTES sa;
   SECONDARYLOGONWATCHINFO slwi;
   DWORD dwResult; 
   DWORD SessionId;
   DWORD dwLogonProvider; 
   SECURITY_LOGON_TYPE  LogonType;

   __try {

       //
       // Do some security checks: 
     
       // 
       // 1) We should impersonate the client and then try to open
       //    the process so that we are assured that they didn't
       //    give us some fake id.
       //
       dwResult = RpcImpersonateClient(hRPCBinding); 
       _JumpCondition(RPC_S_OK != dwResult, leave_with_last_error); 
       fIsImpersonatingRpcClient = TRUE; 

       hProcessClient = OpenProcess(MAXIMUM_ALLOWED, FALSE, psli->dwProcessId);
       _JumpCondition(hProcessClient == NULL, leave_with_last_error); 

#if 0
       //
       // 2) Check that the client is not running from a restricted account.
       // 
       hCurrentThread = GetCurrentThread();  // Doesn't need to be freed with CloseHandle(). 
       _JumpCondition(NULL == hCurrentThread, leave_with_last_error); 
       
       _JumpCondition(FALSE == OpenThreadToken(hCurrentThread, 
                                               TOKEN_QUERY | TOKEN_DUPLICATE,
                                               TRUE, 
                                               &hCurrentThreadToken), 
                      leave_with_last_error); 

#endif
       dwResult = RpcRevertToSelfEx(hRPCBinding);
       if (RPC_S_OK != dwResult) 
       {
           __leave; 
       }
       fIsImpersonatingRpcClient = FALSE; 

#if 0
       if (TRUE == IsTokenUntrusted(hCurrentThreadToken))
       {
           dwResult = ERROR_ACCESS_DENIED;
           __leave; 
       }
#endif
       
       //
       // We should get the session id from process id
       // we will set this up in the token so that create process
       // happens on the correct session.
       //
       _JumpCondition(!ProcessIdToSessionId(psli->dwProcessId, &SessionId), leave_with_last_error); 

       //
       // Get the unique logonId.
       // we will use this to cleanup any running processes
       // when the logoff happens.
       //
       dwResult = SlpGetClientLogonId(hProcessClient, &slwi.LogonId);
       if(dwResult != ERROR_SUCCESS)
       {
	   __leave;
       }

       if ((psli->lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) != 0) 
       {
           _JumpCondition(!DuplicateHandle 
                          (hProcessClient, 
                           psli->lpStartupInfo->hStdInput,
                           GetCurrentProcess(),
                           &psli->lpStartupInfo->hStdInput, 
                           0,
                           TRUE, DUPLICATE_SAME_ACCESS), 
                          leave_with_last_error);
           fOpenedSTDIN = TRUE; 

           _JumpCondition(!DuplicateHandle
                          (hProcessClient, 
                           psli->lpStartupInfo->hStdOutput,
                           GetCurrentProcess(),
                           &psli->lpStartupInfo->hStdOutput, 
                           0, 
                           TRUE,
                           DUPLICATE_SAME_ACCESS),
                          leave_with_last_error);
           fOpenedSTDOUT = TRUE; 

           _JumpCondition(!DuplicateHandle
                          (hProcessClient, 
                           psli->lpStartupInfo->hStdError,
                           GetCurrentProcess(),
                           &psli->lpStartupInfo->hStdError, 
                           0, 
                           TRUE,
                           DUPLICATE_SAME_ACCESS),
                          leave_with_last_error); 
           fOpenedSTDERR = TRUE; 

           fInheritHandles = TRUE;
       } 
       else 
       {
           psli->lpStartupInfo->hStdInput   = INVALID_HANDLE_VALUE;
           psli->lpStartupInfo->hStdOutput  = INVALID_HANDLE_VALUE;
           psli->lpStartupInfo->hStdError   = INVALID_HANDLE_VALUE;
       }

      if(psli->dwLogonFlags & LOGON_NETCREDENTIALS_ONLY)
      {
          LogonType        = (SECURITY_LOGON_TYPE)LOGON32_LOGON_NEW_CREDENTIALS;
          dwLogonProvider  = LOGON32_PROVIDER_WINNT50; 
      }
      else
      {
          LogonType        = (SECURITY_LOGON_TYPE) LOGON32_LOGON_INTERACTIVE;
          dwLogonProvider  = LOGON32_PROVIDER_DEFAULT; 
      }

      // Duplicate windowstation handles received from the client process 
      // so that they're valid in this process. 
      if (NULL != psli->hWinsta) 
      {
          _JumpCondition(!DuplicateHandle(hProcessClient, psli->hWinsta, GetCurrentProcess(), &psli->hWinsta, 0, TRUE, DUPLICATE_SAME_ACCESS), 
                         leave_with_last_error); 
	  psli->fFreeWinsta = TRUE; 
      }

      if (NULL != psli->hDesk)
      {
          _JumpCondition(!DuplicateHandle(hProcessClient, psli->hDesk, GetCurrentProcess(), &psli->hDesk, 0, TRUE, DUPLICATE_SAME_ACCESS), 
                         leave_with_last_error); 
	  psli->fFreeDesk = TRUE; 
      }

      // LogonUser does not return profile information, we need to grab
      // that out of band after the logon has completed.
      //
       dwResult = RpcImpersonateClient(hRPCBinding); 
       _JumpCondition(RPC_S_OK != dwResult, leave_with_last_error); 
       fIsImpersonatingRpcClient = TRUE; 

      _JumpCondition(!LogonUser(psli->lpUsername,
                                psli->lpDomain,
                                psli->lpPassword,
                                LogonType,
                                dwLogonProvider, 
                                &hToken),
		     leave_with_last_error); 

       if (0 == (SECLOGON_CALLER_SPECIFIED_DESKTOP & psli->dwSeclogonFlags))
       {
           // If the caller did not specify their own desktop, it is our responsibility 
           // to grant the user access to the default desktop:
           dwResult = ModifyUserAccessToDesktop(psli->hWinsta, psli->hDesk, hToken, TRUE /*grant*/); 
           if (ERROR_SUCCESS != dwResult) 
               __leave; 
           fAccessWasAllowed = TRUE; 
       }

       dwResult = RpcRevertToSelfEx(hRPCBinding);
       if (RPC_S_OK != dwResult) 
       {
           __leave; 
       }

       fIsImpersonatingRpcClient = FALSE; 
      // Let us set the SessionId in the Token.
      _JumpCondition(!SetTokenInformation(hToken, TokenSessionId, &SessionId, sizeof(DWORD)),
		     leave_with_last_error); 

      // Load the user's profile.
      // if this fails, we will not continue
      //
      if(psli->dwLogonFlags & LOGON_WITH_PROFILE)
      {
          _JumpCondition(!SlpLoadUserProfile(hToken, &hProfile), leave_with_last_error); 
      }

      // we should now impersonate the user.
      //
      _JumpCondition(!ImpersonateLoggedOnUser(hToken), leave_with_last_error); 
      fIsImpersonatingClient = TRUE;

      // Query Default Owner/ACL from token. Make SD with this stuff, pass for
      sa.nLength = sizeof(sa);
      sa.bInheritHandle = FALSE;
      sa.lpSecurityDescriptor = NULL;

      //
      // We should set the console control handler so CtrlC is correctly
      // handled by the new process.
      //

      // SetConsoleCtrlHandler(NULL, FALSE);

      //
      // if lpEnvironment is NULL, we create new one for this user
      // using CreateEnvironmentBlock
      //
      if(NULL == (psli->lpEnvironment))
      {
	  if(FALSE == CreateEnvironmentBlock( &(psli->lpEnvironment), hToken, FALSE ))
	  {
	      psli->lpEnvironment = NULL;
	  }
	  else
	  {
	      // Successfully created environment block. 
	      fCreatedEnvironmentBlock = TRUE; 
	  }
      }

      _JumpCondition(!CreateProcessAsUser(hToken, 
					  psli->lpApplicationName,
					  psli->lpCommandLine, 
					  &sa, 
					  &sa,
					  fInheritHandles,
					  psli->dwCreationFlags | CREATE_UNICODE_ENVIRONMENT,
					  psli->lpEnvironment,
					  psli->lpCurrentDirectory,
					  psli->lpStartupInfo, 
					  &pslri->pi),
		     leave_with_last_error); 

      SetLastError(NO_ERROR); 
      
   leave_with_last_error: 
      dwResult = GetLastError();
      __leave; 
      
   }
   __finally {
      pslri->dwErrorCode = dwResult; 

      if (fCreatedEnvironmentBlock)      { DestroyEnvironmentBlock(psli->lpEnvironment); }
      if (fIsImpersonatingClient)        { RevertToSelf(); /* Ignore retval: nothing we can do on failure! */ }
      if (fIsImpersonatingRpcClient)     { RpcRevertToSelfEx(hRPCBinding); /* Ignore retval: nothing we can do on failure! */ } 
      if (fOpenedSTDIN)                  { CloseHandle(psli->lpStartupInfo->hStdInput);  } 
      if (fOpenedSTDOUT)                 { CloseHandle(psli->lpStartupInfo->hStdOutput); } 
      if (fOpenedSTDERR)                 { CloseHandle(psli->lpStartupInfo->hStdError);  } 

      if(pslri->dwErrorCode != NO_ERROR)
      {
          if (NULL != hProfile)  { UnloadUserProfile(hToken, hProfile); } 
          if (fAccessWasAllowed) { ModifyUserAccessToDesktop(psli->hWinsta, psli->hDesk, hToken, FALSE /*remove*/); }
          if (NULL != hToken)    { CloseHandle(hToken); } 
      }
      else 
      {
	  // Start the watchdog process last so it won't delete psli before we're done with it.  
	  slwi.hProcess = pslri->pi.hProcess;
	  slwi.hToken = hToken;
	  slwi.hProfile = hProfile;
	  // LogonId was already filled up.. right at the begining.
	  slwi.psli = psli;      
	  
	  SecondaryLogonProcessWatchdogNewProcess(&slwi);
	  
	  // SetConsoleCtrlHandler(NULL, TRUE);
	  //
	  // Have the watchdog watch this newly added process so that
	  // cleanup will occur correctly when the process terminates.
	  //
	  
	  // Set up the windowstation and desktop for the process
	  
	  DuplicateHandle(GetCurrentProcess(), pslri->pi.hProcess,
			  hProcessClient, &pslri->pi.hProcess, 0, FALSE,
			  DUPLICATE_SAME_ACCESS);
	  
	  DuplicateHandle(GetCurrentProcess(), pslri->pi.hThread, hProcessClient,
			  &pslri->pi.hThread, 0, FALSE,
			  DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);
      }

      if (NULL != hProcessClient)      { CloseHandle(hProcessClient); } 
      if (NULL != hCurrentThreadToken) { CloseHandle(hCurrentThreadToken); } 
   }
}

void
WINAPI
ServiceMain
(IN DWORD dwArgc,
 IN WCHAR ** lpszArgv)
/*++

Routine Description:
    The main service handler thread routine.

Arguments:

Return Value:
    none.

--*/
{
    DWORD    i, dwResult, dwWaitResult; 
    HANDLE   rghWait[4]; 

    for (i = 0; i < MAXIMUM_SECLOGON_PROCESSES; i++)
    {
        // g_hProcess[i] = LongToHandle(0xDEADBEEF);
        g_Jobs[i].Job = NULL;
        g_hProcess[i] = NULL;
        g_hProfile[i] = NULL;
        g_hToken[i] = NULL;
    }

    __try {
        InitializeCriticalSection(&csForProcessCount);
        InitializeCriticalSection(&csForDesktop); 
        g_fIsCsInitialized = TRUE; 
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return; // We can't do anything if we can't initialize this critsec
    }

    g_hIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0,0); 
    _JumpCondition(NULL == g_hIOCP, CreateIoCompletionPortError); 

    dwResult = InitGlobalState(); 
    _JumpCondition(ERROR_SUCCESS != dwResult, InitGlobalStateError); 

   // NOTE: hSS does not have to be closed.
   g_state.hServiceStatus = RegisterServiceCtrlHandler(wszSvcName, ServiceHandler);
   _JumpCondition(NULL == g_state.hServiceStatus, RegisterServiceCtrlHandlerError); 

   dwResult = SeclStartRpcServer();
   _JumpCondition(ERROR_SUCCESS != dwResult, StartRpcServerError); 

   // Tell the SCM we're up and running:
   dwResult = MySetServiceStatus(SERVICE_RUNNING, 0, 0, ERROR_SUCCESS); 
   _JumpCondition(ERROR_SUCCESS != dwResult, MySetServiceStatusError); 

   SetLastError(ERROR_SUCCESS); 
 ErrorReturn:
   // Shut down the service if we couldn't fully start: 
   if (ERROR_SUCCESS != GetLastError()) { 
       ServiceStop(TRUE /*fShutdown*/, GetLastError()); 
   }
   return; 

SET_ERROR(InitGlobalStateError,            dwResult)
SET_ERROR(MySetServiceStatusError,         dwResult);
SET_ERROR(RegisterServiceCtrlHandlerError, dwResult);
SET_ERROR(StartRpcServerError,             dwResult);
TRACE_ERROR(CreateIoCompletionPortError); 
}




DWORD
InstallService()
/*++

Routine Description:
    It installs the service with service controller, basically creating
    the service object.

Arguments:
    none.

Return Value:
    several - as returned by the service controller.

--*/
{
   // TCHAR *szModulePathname;
   TCHAR AppName[MAX_PATH];
    LPTSTR                   ptszAppName         = NULL; 
   SC_HANDLE hService;
   DWORD dw;
   HANDLE   hMod;

    //
    // Open the SCM on this machine.
    //
   SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if(hSCM == NULL) {
      dw = GetLastError();
      return dw;
    }

    //
    // Let us give the service a useful description
    // This is not earth shattering... if it works fine, if it
    // doesn't it is just too bad :-)
    //
    hMod = GetModuleHandle(L"seclogon.dll");

    //
    // we'll try to get the localized name for the service,
    // if it fails, we'll just put an english string...
    //
   if(hMod != NULL)
   {
	LoadString(hMod,
		   SECLOGON_STRING_NAME,
		   AppName,
		   MAX_PATH
		   );
	
	ptszAppName = AppName;
    }
    else
	ptszAppName = L"RunAs Service";


   //
   // Add this service to the SCM's database.
   //
    hService = CreateService
	(hSCM, 
	 wszSvcName, 
	 ptszAppName, 
	 SERVICE_ALL_ACCESS,
	 SERVICE_WIN32_SHARE_PROCESS, 
	 SERVICE_AUTO_START, 
	 SERVICE_ERROR_IGNORE,
	 L"%SystemRoot%\\system32\\svchost.exe -k netsvcs", 
	 NULL, 
	 NULL, 
	 NULL, 
	 NULL, 
	 NULL);
    if(hService == NULL) {
      dw = GetLastError();
      CloseServiceHandle(hSCM);
      return dw;
    }

    if(hMod != NULL)
    {
	WCHAR   DescString[500];
	SERVICE_DESCRIPTION SvcDesc;
	
	LoadString( hMod,
		    SECLOGON_STRING_DESCRIPTION,
		    DescString,
		    500
		    );
	
	SvcDesc.lpDescription = DescString;
	ChangeServiceConfig2( hService,
			      SERVICE_CONFIG_DESCRIPTION,
			      &SvcDesc
			      );
	
    }

    //
    // Close the service and the SCM
    //
   CloseServiceHandle(hService);
   CloseServiceHandle(hSCM);
    return S_OK;
}



DWORD
RemoveService()
/*++

Routine Description:
    deinstalls the service.

Arguments:
    none.

Return Value:
    as returned by service controller apis.

--*/
{
   DWORD dw;
   SC_HANDLE hService;
   //
   // Open the SCM on this machine.
   //
   SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
   if(hSCM == NULL) {
      dw = GetLastError();
      return dw;
   }

   //
   // Open this service for DELETE access
   //
   hService = OpenService(hSCM, wszSvcName, DELETE);
   if(hService == NULL) {
      dw = GetLastError();
      CloseServiceHandle(hSCM);
      return dw;
   }

   //
   // Remove this service from the SCM's database.
   //
   DeleteService(hService);

   //
   // Close the service and the SCM
   //
   CloseServiceHandle(hService);
   CloseServiceHandle(hSCM);
   return S_OK;
}



void SvchostPushServiceGlobals(PSVCHOST_GLOBAL_DATA pGlobalData) {
    // this entry point is called by svchost.exe
    GlobalData=pGlobalData;
}

void SvcEntry_Seclogon
(IN DWORD argc,
 IN WCHAR **argv)
/*++

Routine Description:
    Entry point for the service dll when running in svchost.exe

Arguments:

Return Value:

--*/
{
    ServiceMain(0,NULL);

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
}



STDAPI
DllRegisterServer(void)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return InstallService();
}

STDAPI
DllUnregisterServer(void)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   return RemoveService();
}



DWORD InitGlobalState() { 
    ZeroMemory(&g_state, sizeof(g_state)); 
    return ERROR_SUCCESS; 
}


DWORD MySetServiceStatus(DWORD dwCurrentState, DWORD dwCheckPoint, DWORD dwWaitHint, DWORD dwExitCode) {
    BOOL   fResult; 
    DWORD  dwResult;
    DWORD  dwAcceptStop; 
    int    nNumProcesses; 

    EnterCriticalSection(&csForProcessCount);
    nNumProcesses = g_nNumSecondaryLogonProcesses; 
    dwAcceptStop = 0 == nNumProcesses ? SERVICE_ACCEPT_STOP : 0; 

    g_state.serviceStatus.dwServiceType  = SERVICE_WIN32_SHARE_PROCESS; 
    g_state.serviceStatus.dwCurrentState = dwCurrentState;

    switch (dwCurrentState) 
    {
    case SERVICE_STOPPED:
    case SERVICE_STOP_PENDING:
        g_state.serviceStatus.dwControlsAccepted = 0;
        break;
    case SERVICE_RUNNING:
    case SERVICE_PAUSED:
        g_state.serviceStatus.dwControlsAccepted =
	    // SERVICE_ACCEPT_SHUTDOWN
              SERVICE_ACCEPT_PAUSE_CONTINUE
            | dwAcceptStop; 
        break;
    case SERVICE_START_PENDING:
    case SERVICE_CONTINUE_PENDING:
    case SERVICE_PAUSE_PENDING:
        g_state.serviceStatus.dwControlsAccepted =
	    // SERVICE_ACCEPT_SHUTDOWN
            dwAcceptStop; 
        break;
    }
    g_state.serviceStatus.dwWin32ExitCode  = dwExitCode; 
    g_state.serviceStatus.dwCheckPoint     = dwCheckPoint;
    g_state.serviceStatus.dwWaitHint       = dwWaitHint;

    fResult = SetServiceStatus(g_state.hServiceStatus, &g_state.serviceStatus);
    _JumpCondition(FALSE == fResult, SetServiceStatusError); 

    dwResult = ERROR_SUCCESS; 
 CommonReturn: 
    LeaveCriticalSection(&csForProcessCount); 
    return dwResult;

 ErrorReturn:
    goto CommonReturn;

SET_DWRESULT(SetServiceStatusError, GetLastError()); 
}

DWORD MySetServiceStopped(DWORD dwExitCode) {
    BOOL   fResult; 
    DWORD  dwResult;

    g_state.serviceStatus.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS; 
    g_state.serviceStatus.dwCurrentState     = SERVICE_STOPPED;
    g_state.serviceStatus.dwControlsAccepted = 0;
    g_state.serviceStatus.dwWin32ExitCode    = dwExitCode; 
    g_state.serviceStatus.dwCheckPoint       = 0; 
    g_state.serviceStatus.dwWaitHint         = 0; 

    fResult = SetServiceStatus(g_state.hServiceStatus, &g_state.serviceStatus);
    _JumpCondition(FALSE == fResult, SetServiceStatusError); 

    dwResult = ERROR_SUCCESS; 
 CommonReturn: 
    return dwResult;

 ErrorReturn:
    goto CommonReturn;

SET_DWRESULT(SetServiceStatusError, GetLastError()); 
}

////////////////////////////////////////////////////////////////////////
//
// Implementation of RPC interface: 
//
////////////////////////////////////////////////////////////////////////

void WINAPI SeclCreateProcessWithLogonW
(IN   handle_t    hRPCBinding, 
 IN   SECL_SLI   *pSeclSli, 
 OUT  SECL_SLRI  *pSeclSlri)
{
    BOOL                  fIsImpersonatingClient  = FALSE;
    DWORD                 dwResult; 
    HANDLE                hHeap                   = NULL;
    PSECONDARYLOGONINFOW  psli                    = NULL;
    SECL_SLRI             SeclSlri;
    SECONDARYLOGONRETINFO slri;

    ZeroMemory(&SeclSlri,  sizeof(SeclSlri)); 
    ZeroMemory(&slri,      sizeof(slri)); 

    // We don't want the service to be stopped while we're creating a process.  
    EnterCriticalSection(&csForProcessCount);
    // Service isn't running anymore ... don't create the process. 
    _JumpCondition(SERVICE_RUNNING != g_state.serviceStatus.dwCurrentState, ServiceStoppedError);

    hHeap = GetProcessHeap();
    _JumpCondition(NULL == hHeap, MemoryError); 

    __try {
        dwResult = To_SECONDARYLOGONINFOW(pSeclSli, &psli); 
        _JumpCondition(ERROR_SUCCESS != dwResult, To_SECONDARYLOGONINFOW_Error); 

        if (psli->LogonIdHighPart != 0 || psli->LogonIdLowPart != 0)
        {
            // This is probably a notification from winlogon.exe that 
            // a client is logging off.  If so, we must clean up all processes
            // they've left running.  

            int i;
            LUID  LogonId;

            //
            // We should impersonate the client,
            // check it is LocalSystem and only then proceed.
            //
            fIsImpersonatingClient = RPC_S_OK == RpcImpersonateClient((RPC_BINDING_HANDLE)hRPCBinding); 
            if(FALSE == fIsImpersonatingClient || FALSE == IsSystemProcess())
            {
                slri.dwErrorCode = ERROR_INVALID_PARAMETER;
                ZeroMemory(&slri.pi, sizeof(slri.pi));
            }
            else 
            {
                LogonId.HighPart = psli->LogonIdHighPart;
                LogonId.LowPart = psli->LogonIdLowPart;
			      
                for(i=0;i<MAXIMUM_SECLOGON_PROCESSES;i++)
                {
                    //
                    // Let us destroy all jobs associated with
                    // this user.  There could be more than one. 
                    //
                    if(g_Jobs[i].Job == NULL) 
			continue;
                    
                    if(g_Jobs[i].LogonId.HighPart == LogonId.HighPart && g_Jobs[i].LogonId.LowPart == LogonId.LowPart)
                    {
                        TerminateJobObject(g_Jobs[i].Job, 0);
                    }
                }
                slri.dwErrorCode = ERROR_SUCCESS;
                ZeroMemory(&slri.pi, sizeof(slri.pi));
                
            }
            
            if (fIsImpersonatingClient) 
            { 
                // Ignore error: nothing we can do on failure!
                if (RPC_S_OK == RpcRevertToSelfEx((RPC_BINDING_HANDLE)hRPCBinding))
                {
                    fIsImpersonatingClient = FALSE; 
                }
            } 
        }
        else
        {
            // Ok, this isn't notification from winlogon, it's really a user
            // trying to use the service.  Create a process for them. 
            // 

            DWORD currentNumber;
            
             currentNumber = g_nNumSecondaryLogonProcesses;
            
            if(currentNumber == MAXIMUM_SECLOGON_PROCESSES)
            {
                slri.dwErrorCode = ERROR_NO_SYSTEM_RESOURCES;
                ZeroMemory(&slri.pi, sizeof(slri.pi));
            }
            else
            {
                SlrCreateProcessWithLogon((RPC_BINDING_HANDLE)hRPCBinding, psli, &slri); 
            }
        }

        // If we've errored out, jump to the error handler. 
        _JumpCondition(NO_ERROR != slri.dwErrorCode, UnspecifiedSeclogonError); 
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        // If anything goes wrong, return the exception code to the client
        dwResult = GetExceptionCode(); 
        goto ExceptionError; 
    }

 CommonReturn:
    // Do not free slri: this will be freed by the watchdog!
    SeclSlri.hProcess    = (unsigned __int64)slri.pi.hProcess;
    SeclSlri.hThread     = (unsigned __int64)slri.pi.hThread; 
    SeclSlri.ulProcessId = slri.pi.dwProcessId; 
    SeclSlri.ulThreadId  = slri.pi.dwThreadId; 
    SeclSlri.ulErrorCode = slri.dwErrorCode; 

    LeaveCriticalSection(&csForProcessCount);
    
    // Assign the OUT parameter: 
    *pSeclSlri = SeclSlri; 
    return; 

 ErrorReturn:
    ZeroMemory(&slri.pi, sizeof(slri.pi));
    if (NULL != psli) { Free_SECONDARYLOGONINFOW(psli); } 

    slri.dwErrorCode = dwResult; 
    goto CommonReturn; 

SET_DWRESULT(ExceptionError,                dwResult); 
SET_DWRESULT(MemoryError,                   ERROR_NOT_ENOUGH_MEMORY); 
SET_DWRESULT(ServiceStoppedError,           ERROR_SERVICE_NOT_ACTIVE); 
SET_DWRESULT(To_SECONDARYLOGONINFOW_Error,  dwResult); 
SET_DWRESULT(UnspecifiedSeclogonError,      slri.dwErrorCode); 
}

////////////////////////////////////////////////////////////////////////
//
// RPC Utility methods:
//
////////////////////////////////////////////////////////////////////////

DWORD SeclStartRpcServer() { 
    DWORD        dwResult;
    RPC_STATUS   RpcStatus;

    EnterCriticalSection(&csForProcessCount); 

    if (NULL != GlobalData) {
        // we are running under services.exe - we have to play nicely and share
        // the process's RPC server. (The other services wouldn't be happy if we 
        // shut it down while they were still using it.)
        RpcStatus = GlobalData->StartRpcServer(wszSeclogonSharedProcEndpointName, ISeclogon_v1_0_s_ifspec);
        _JumpCondition(RPC_S_OK != RpcStatus, StartRpcServerError);
    }

    dwResult = ERROR_SUCCESS;

 CommonReturn: 
    LeaveCriticalSection(&csForProcessCount); 
    return dwResult;
    
 ErrorReturn:
    goto CommonReturn; 
    
SET_DWRESULT(StartRpcServerError, RpcStatus); 
}

DWORD SeclStopRpcServer() { 
    DWORD      dwResult;
    RPC_STATUS RpcStatus;

    EnterCriticalSection(&csForProcessCount); 

    if (NULL != GlobalData) {
        // we are running under services.exe - we have to play nicely and share
        // the process's RPC server. (The other services wouldn't be happy if we 
        // shut it down while they were still using it.)
        RpcStatus = GlobalData->StopRpcServer(ISeclogon_v1_0_s_ifspec); 
        _JumpCondition(RPC_S_OK != RpcStatus, StopRpcServerError); 
    } 

    dwResult = ERROR_SUCCESS; 
 CommonReturn:
    LeaveCriticalSection(&csForProcessCount); 
    return dwResult;

 ErrorReturn:
    goto CommonReturn; 

SET_DWRESULT(StopRpcServerError, RpcStatus);     
}

HRESULT To_LPWSTR(IN  SECL_STRING *pss, 
                  OUT LPWSTR      *ppwsz)
{
    DWORD   dwResult;
    HANDLE  hHeap     = NULL; 
    LPWSTR  pwsz      = NULL;
 
    hHeap = GetProcessHeap();
    _JumpCondition(NULL == hHeap, GetProcessHeapError); 

    __try { 
        if (pss->ccLength > 0) { 
            // Prevent large heap allocs: 
            _JumpCondition(pss->ccLength > 4096, InvalidArgError); 

            pwsz = (LPWSTR)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, pss->ccLength * sizeof(WCHAR)); 
            _JumpCondition(NULL == pwsz, MemoryError); 
            CopyMemory(pwsz, pss->pwsz, pss->ccLength * sizeof(WCHAR)); 
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) { 
        dwResult = GetExceptionCode(); 
        goto ExceptionError; 
    }

    *ppwsz = pwsz; 
    dwResult = ERROR_SUCCESS;

 CommonReturn:
    return dwResult;

 ErrorReturn:
    if (NULL != pwsz) { HeapFree(hHeap, 0, pwsz); } 
    goto CommonReturn; 

SET_DWRESULT(ExceptionError,       dwResult); 
SET_DWRESULT(GetProcessHeapError,  GetLastError()); 
SET_DWRESULT(InvalidArgError,      ERROR_INVALID_PARAMETER); 
SET_DWRESULT(MemoryError,          ERROR_NOT_ENOUGH_MEMORY); 
}

void Free_SECONDARYLOGONINFOW(IN PSECONDARYLOGONINFOW psli) { 
    HANDLE hHeap = GetProcessHeap(); 

    if (NULL == hHeap) 
        return;

    if (NULL != psli) { 
        if (NULL != psli->lpStartupInfo) { 
            if (NULL != psli->lpStartupInfo->lpDesktop) { HeapFree(hHeap, 0, psli->lpStartupInfo->lpDesktop); } 
            if (NULL != psli->lpStartupInfo->lpTitle)   { HeapFree(hHeap, 0, psli->lpStartupInfo->lpTitle); } 
            HeapFree(hHeap, 0, psli->lpStartupInfo); 
        }

        if (NULL != psli->lpUsername)         { HeapFree(hHeap, 0, psli->lpUsername);                  } 
        if (NULL != psli->lpDomain)           { HeapFree(hHeap, 0, psli->lpDomain);                    } 
        if (NULL != psli->lpPassword)         { HeapFree(hHeap, 0, psli->lpPassword);                  } 
        if (NULL != psli->lpApplicationName)  { HeapFree(hHeap, 0, psli->lpApplicationName);           } 
        if (NULL != psli->lpCommandLine)      { HeapFree(hHeap, 0, psli->lpCommandLine);               } 
        if (NULL != psli->lpCurrentDirectory) { HeapFree(hHeap, 0, (LPVOID)psli->lpCurrentDirectory);  } 
        if (NULL != psli->hWinsta && psli->fFreeWinsta) { CloseHandle(psli->hWinsta); } 
        if (NULL != psli->hDesk && psli->fFreeDesk)     { CloseHandle(psli->hDesk); } 
        HeapFree(hHeap, 0, psli); 
    }
}

DWORD To_SECONDARYLOGONINFOW(IN  PSECL_SLI             pSeclSli, 
                             OUT PSECONDARYLOGONINFOW *ppsli) 
{
    DWORD                 dwAllocFlags  = HEAP_ZERO_MEMORY; 
    DWORD                 dwIndex; 
    DWORD                 dwResult; 
    HANDLE                hHeap         = NULL;
    PSECONDARYLOGONINFOW  psli          = NULL;

    hHeap = GetProcessHeap(); 
    _JumpCondition(NULL == hHeap, GetProcessHeapError); 

    psli = (PSECONDARYLOGONINFOW)HeapAlloc(hHeap, dwAllocFlags, sizeof(SECONDARYLOGONINFOW)); 
    _JumpCondition(NULL == psli, MemoryError); 

    psli->lpStartupInfo = (LPSTARTUPINFO)HeapAlloc(hHeap, dwAllocFlags, sizeof(STARTUPINFO)); 
    _JumpCondition(NULL == psli->lpStartupInfo, MemoryError); 

    __try { 
        {
            struct { 
                SECL_STRING *pss;
                LPWSTR      *ppwsz; 
            } rg_StringsToMap[] = { 
                { &(pSeclSli->ssDesktop),          /* Is mapped to ----> */ &(psli->lpStartupInfo->lpDesktop)      }, 
                { &(pSeclSli->ssTitle),            /* Is mapped to ----> */ &(psli->lpStartupInfo->lpTitle)        }, 
                { &(pSeclSli->ssUsername),         /* Is mapped to ----> */ &(psli->lpUsername)                    }, 
                { &(pSeclSli->ssDomain),           /* Is mapped to ----> */ &(psli->lpDomain)                      },
                { &(pSeclSli->ssPassword),         /* Is mapped to ----> */ &(psli->lpPassword)                    }, 
                { &(pSeclSli->ssApplicationName),  /* Is mapped to ----> */ &(psli->lpApplicationName)             }, 
                { &(pSeclSli->ssCommandLine),      /* Is mapped to ----> */ &(psli->lpCommandLine)                 }, 
                { &(pSeclSli->ssCurrentDirectory), /* Is mapped to ----> */ (LPWSTR *)&(psli->lpCurrentDirectory)  }
            }; 

            for (dwIndex = 0; dwIndex < ARRAYSIZE(rg_StringsToMap); dwIndex++) { 
                dwResult = To_LPWSTR(rg_StringsToMap[dwIndex].pss, rg_StringsToMap[dwIndex].ppwsz); 
                _JumpCondition(ERROR_SUCCESS != dwResult, To_LPWSTR_Error); 
            }
        }

        if (pSeclSli->sbEnvironment.cb > 0) { 
            psli->lpEnvironment = HeapAlloc(hHeap, dwAllocFlags, pSeclSli->sbEnvironment.cb);
            _JumpCondition(NULL == psli->lpEnvironment, MemoryError); 
            CopyMemory(psli->lpEnvironment, pSeclSli->sbEnvironment.pb, pSeclSli->sbEnvironment.cb); 
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) { 
        dwResult = GetExceptionCode(); 
        goto ExceptionError; 
    }

    psli->dwProcessId     = pSeclSli->ulProcessId; 
    psli->LogonIdLowPart  = pSeclSli->ulLogonIdLowPart; 
    psli->LogonIdHighPart = pSeclSli->lLogonIdHighPart; 
    psli->dwLogonFlags    = pSeclSli->ulLogonFlags; 
    psli->dwCreationFlags = pSeclSli->ulCreationFlags; 
    psli->dwSeclogonFlags = pSeclSli->ulSeclogonFlags; 
    psli->hWinsta         = (HANDLE)pSeclSli->hWinsta; 
    psli->hDesk           = (HANDLE)pSeclSli->hDesk; 

    *ppsli = psli; 
    dwResult = ERROR_SUCCESS; 
 CommonReturn: 
    return dwResult; 

 ErrorReturn:
    Free_SECONDARYLOGONINFOW(psli); 
    goto CommonReturn; 

SET_DWRESULT(ExceptionError,       dwResult); 
SET_DWRESULT(GetProcessHeapError,  GetLastError());
SET_DWRESULT(MemoryError,          ERROR_NOT_ENOUGH_MEMORY); 
SET_DWRESULT(To_LPWSTR_Error,      dwResult); 
}

//////////////////////////////// End Of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\adtwrap.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    adtwrap.c

Abstract:

    These are the Admin Tools Service API RPC client stubs.

Author:

    Dan Lafferty    (danl)  25-Mar-1993

Environment:

    User Mode - Win32 

Revision History:

    25-Mar-1993     Danl
        Created

--*/

//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for windows.h when I have nt.h
#include <windows.h>

#include <srvsvc.h>     // MIDL generated - includes windows.h & rpc.h

#include <rpc.h>
#include <lmcons.h> 
#include <lmerr.h>      // NERR_ error codes
#include <lmuse.h>      // LPUSE_INFO_0
#include <lmapibuf.h>   // NetApiBufferFree
#include <adtcomn.h>
                                     
//
// GLOBALS
//
    DWORD   AdtsvcDebugLevel = DEBUG_ERROR;

//
// LOCAL PROTOTYPES
//

DWORD
AdtParsePathName(
    LPWSTR  lpPathName,
    LPWSTR  *pNewFileName,
    LPWSTR  *pServerName,
    LPWSTR  *pShareName
    );

LPWSTR
AdtFindNextToken(
    WCHAR   Token,
    LPWSTR  String,
    LPDWORD pNumChars
    );


DWORD
NetpGetFileSecurity(
    IN  LPWSTR                  lpFileName,
    IN  SECURITY_INFORMATION    RequestedInformation,
    OUT PSECURITY_DESCRIPTOR    *pSecurityDescriptor,
    OUT LPDWORD                 pnLength
    )

/*++

Routine Description:

    This function returns to the caller a copy of the security descriptor 
    protecting a file or directory.

    NOTE:  The buffer containing the security descriptor is allocated for
    the caller.  It is the caller's responsibility to free the buffer by
    calling the NetApiBufferFree() function.

Arguments:

    lpFileName - A pointer to the name fo the file or directory whose
        security is being retrieved.

    SecurityInformation -  security information being requested.
 
    pSecurityDescriptor - A pointer to a location where the pointer 
        to the security descriptor is to be placed.  The security
        descriptor is returned in the self-relative format.

    pnLength - The size, in bytes, of the returned security descriptor.


Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate memory for the security
        descriptor.

    This function can also return any error that GetFileSecurity can 
    return.

--*/
{
    NET_API_STATUS  status;
    ADT_SECURITY_DESCRIPTOR     returnedSD;
    PADT_SECURITY_DESCRIPTOR    pReturnedSD;
    LPWSTR                      pServerName;
    LPWSTR                      pShareName;
    LPWSTR                      pNewFileName;

    RpcTryExcept {
        //
        // Pick the server name out of the filename.  Or translate the
        // local drive name into a \\servername\sharename.
        //

        status = AdtParsePathName(lpFileName,&pNewFileName,&pServerName,&pShareName);
    }
    RpcExcept (1) {
        //
        // Get RPC exception code.
        //
        status = RpcExceptionCode();
        
    }
    RpcEndExcept
    if (status != NO_ERROR) {
        LocalFree(pServerName);
        return(status);
    }

    if (pServerName == NULL) {
        //
        // Call Locally.
        //
        ADT_LOG0(TRACE,"Call Local version (PrivateGetFileSecurity)\n");

        status = PrivateGetFileSecurity (
                    lpFileName,
                    RequestedInformation,
                    pSecurityDescriptor,
                    pnLength
                    );
        return(status);
    }
    //
    // This is a remote call - - use RPC
    //
    //
    // Initialize the fields in the structure so that RPC does not
    // attempt to marshall anything on input.
    //
    ADT_LOG0(TRACE,"Call Remote version (NetrpGetFileSecurity)\n");
    returnedSD.Length = 0;
    returnedSD.Buffer = NULL;
    
    RpcTryExcept {
    
        pReturnedSD = NULL;
        status = NetrpGetFileSecurity (
                    pServerName,
                    pShareName,
                    pNewFileName,
                    RequestedInformation,
                    &pReturnedSD);
    
    }
    RpcExcept (1) {
        //
        // Get RPC exception code.
        //
        status = RpcExceptionCode();
        
    }
    RpcEndExcept
    
    if (status == NO_ERROR) {
        *pSecurityDescriptor = pReturnedSD->Buffer;
        *pnLength = pReturnedSD->Length;
    }
    LocalFree(pServerName);

    return (status);
}

DWORD
NetpSetFileSecurity (
    IN LPWSTR                   lpFileName,
    IN SECURITY_INFORMATION     SecurityInformation,
    IN PSECURITY_DESCRIPTOR     pSecurityDescriptor
    )

/*++

Routine Description:

    This function can be used to set the security of a file or directory.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer or
        string specifies the local machine.

    lpFileName - A pointer to the name of the file or directory whose
        security is being changed.

    SecurityInformation - information describing the contents
        of the Security Descriptor.

    pSecurityDescriptor - A pointer to a well formed Security Descriptor.

Return Value:

    NO_ERROR - The operation was successful.

    This function can also return any error that SetFileSecurity can 
    return.

--*/
{
    DWORD                       status= NO_ERROR;
    NTSTATUS                    ntStatus=STATUS_SUCCESS;
    ADT_SECURITY_DESCRIPTOR     descriptorToPass;
    DWORD                       nSDLength;
    LPWSTR                      pNewFileName=NULL;
    LPWSTR                      pServerName=NULL;
    LPWSTR                      pShareName;

    nSDLength = 0;

    RpcTryExcept {
        //
        // Pick the server name out of the filename.  Or translate the
        // local drive name into a \\servername\sharename.
        //

        status = AdtParsePathName(lpFileName,&pNewFileName,&pServerName,&pShareName);
    }
    RpcExcept (1) {
        //
        // Get RPC exception code.
        //
        status = RpcExceptionCode();
        
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        if (pServerName != NULL) {
            LocalFree(pServerName);
        }
        return(status);
    }

    if (pServerName == NULL) {
        //
        // Call Locally and return result.
        // 
        status = PrivateSetFileSecurity (
                    lpFileName,
                    SecurityInformation,
                    pSecurityDescriptor);
        return(status);
    }
    
    //
    // Call remotely
    //

    RpcTryExcept {
        //
        // Force the Security Descriptor to be self-relative if it is not
        // already.
        // The first call to RtlMakeSelfRelativeSD is used to determine the
        // size.
        //
        ntStatus = RtlMakeSelfRelativeSD(
                    pSecurityDescriptor,
                    NULL,
                    &nSDLength);
        
        if (ntStatus != STATUS_BUFFER_TOO_SMALL) {
            status = RtlNtStatusToDosError(ntStatus);
            goto CleanExit;
        }
        descriptorToPass.Length = nSDLength;
        descriptorToPass.Buffer = LocalAlloc (LMEM_FIXED,nSDLength);
        
        if (descriptorToPass.Buffer == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
        //
        // Make an appropriate self-relative security descriptor.
        //
        ntStatus = RtlMakeSelfRelativeSD(
                    pSecurityDescriptor,
                    descriptorToPass.Buffer,
                    &nSDLength);
        
        if (ntStatus != NO_ERROR) {
            LocalFree (descriptorToPass.Buffer);
            status = RtlNtStatusToDosError(ntStatus);
            goto CleanExit;
        }
        
        status = NetrpSetFileSecurity (
                pServerName,
                pShareName,
                pNewFileName,
                SecurityInformation,
                &descriptorToPass);

        LocalFree (descriptorToPass.Buffer);

CleanExit:
        ;
    }
    RpcExcept (1) {
        //
        // Get RPC exception code.
        //
        status = RpcExceptionCode();
        
    }
    RpcEndExcept
    LocalFree(pServerName);
    return (status);

}


DWORD
AdtParsePathName(
    LPWSTR  lpPathName,
    LPWSTR  *pNewFileName,
    LPWSTR  *pServerName,
    LPWSTR  *pShareName
    )

/*++

Routine Description:

    NOTE:  This function allocates memory when the path contains a remote name.
    The pShareName and pServerName strings are in a single buffer that is
    to be freed at pServerName.

    pNewFileName is NOT allocate by this routine.  It points to a substring
    within the passed in lpPathName.

Arguments:

    lpPathName -  This is a pointer to the filename-path string.  It can have
        any of the following formats:

            x:\filedir\file.nam                    (remote)
            \\myserver\myshare\filedir\file.nam    (remote)
            filedir\file.nam                       (local)

        This could also just contain a directory name (and not a filename).
      
    pNewFileName -  This is a location where a pointer to the buffer
        containing the file name can be placed.  This will just contain the
        filename or directory name relative to the root directory.

    pServerName - This is a location where a pointer to the buffer containing
        the server name can be placed.  If this is for the local machine, then
        a NULL will be placed in this location.

    pShareName - This is a location where a pointer to a buffer containing
        the share name can be placed.  If this is for the local machine, then
        a NULL will be placed in this location.

Return Value:


--*/
#define     REMOTE_DRIVE    0
#define     REMOTE_PATH     1
#define     LOCAL           2
{
    DWORD           status = NO_ERROR;
    NET_API_STATUS  netStatus=NERR_Success;
    WCHAR           useName[4];
    LPUSE_INFO_0    pUseInfo=NULL;
    LPWSTR          pNewPathName=NULL;
    DWORD           DeviceType = LOCAL;
    LPWSTR          pPrivateServerName;
    LPWSTR          pPrivateShareName;
    LPWSTR          pEnd;
    DWORD           numServerChars;
    DWORD           numChars;
    WCHAR           token;

    *pServerName = NULL;
    *pShareName = NULL;
    //
    // If the fileName starts with a drive letter, then use NetUseGetInfo
    // to get the remote name.
    //
    if (lpPathName[1] == L':')  {
        if (((L'a' <= lpPathName[0]) && (lpPathName[0] <= L'z'))  ||
            ((L'A' <= lpPathName[0]) && (lpPathName[0] <= L'Z'))) {
            //
            // This is in the form of a local device.  Get the server/sharename
            // associated with this device.
            //
            wcsncpy(useName, lpPathName, 2);
            useName[2]=L'\0';
            netStatus = NetUseGetInfo(
                            NULL,                   // server name
                            useName,                // use name
                            0,                      // level
                            (LPBYTE *)&pUseInfo);   // buffer
    
            if (netStatus != NERR_Success) {
                //
                // if we get NERR_UseNotFound back, then this must be
                // a local drive letter, and not a redirected one.
                // In this case we return success.
                //
                if (netStatus == NERR_UseNotFound) {
                    return(NERR_Success);
                }
                return(netStatus);
            }
            DeviceType = REMOTE_DRIVE;
            pNewPathName = pUseInfo->ui0_remote;
        }
    }
    else {
        if (wcsncmp(lpPathName,L"\\\\",2) == 0) {
            DeviceType = REMOTE_PATH;
            pNewPathName = lpPathName;
        }
    }
    if (DeviceType != LOCAL) {

        //
        // Figure out how many characters for the server and share portion
        // of the string.
        // Add 2 characters for the leading "\\\\", allocate a buffer, and
        // copy the characters.
        //
        numChars = 2;
        pPrivateShareName = AdtFindNextToken(L'\\',pNewPathName+2,&numChars);
        if (pPrivateShareName == NULL) {
            status = ERROR_BAD_PATHNAME;
            goto CleanExit;
        }
        numServerChars = numChars;

        token = L'\\';
        if (DeviceType == REMOTE_DRIVE) {
            token = L'\0';
        }
        pEnd = AdtFindNextToken(token,pPrivateShareName+1,&numChars);
        if (pEnd == NULL) {
            status = ERROR_BAD_PATHNAME;
            goto CleanExit;
        }
        //
        // If this is a remotepath name, then the share name portion will
        // also contain the '\' token.  Remove this by decrementing the
        // count.
        //
        if (DeviceType == REMOTE_PATH) {
            numChars--;
        }
        pPrivateServerName = LocalAlloc(LMEM_FIXED,(numChars+1) * sizeof(WCHAR));
        if (pPrivateServerName == NULL) {
            status = GetLastError();
            goto CleanExit;
        }

        //
        // Copy the the "\\servername\sharename" to the new buffer and
        // place NUL characters in place of the single '\'.
        //
        wcsncpy(pPrivateServerName, pNewPathName, numChars);
        pPrivateShareName = pPrivateServerName + numServerChars;

        *(pPrivateShareName -1) = L'\0';            // NUL terminate the server name
        pPrivateServerName[ numChars ] = L'\0';     // NUL terminate the share name

        if (DeviceType == REMOTE_PATH) {
            *pNewFileName = pEnd;
        }
        else {
            *pNewFileName = lpPathName+2;
        }
        *pServerName = pPrivateServerName;
        *pShareName = pPrivateShareName;
    }
CleanExit:
    if (pUseInfo != NULL) {
        NetApiBufferFree(pUseInfo);
    }
    return(status);
}

LPWSTR
AdtFindNextToken(
    WCHAR   Token,
    LPWSTR  pString,
    LPDWORD pNumChars
    )

/*++

Routine Description:

    Finds the first occurance of Token in the pString.

Arguments:

    Token - This is the unicode character that we are searching for in the
        string.

    pString - This is a pointer to the string in which the token is to be
        found.

    pNumChars - This is a pointer to a DWORD that will upon exit increment
        by the number of characters found in the string (including the
        token).

Return Value:

    If the token is found this returns a pointer to the Token.
    Otherwise, it returns NULL.

--*/
{
    DWORD   saveNum=*pNumChars;

    while ((*pString != Token) && (*pString != L'\0')) {
        pString++;
        (*pNumChars)++;
    }
    if (*pString != Token) {
        *pNumChars = saveNum;
        return(NULL);
    }
    (*pNumChars)++;
    return(pString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\csc.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    csc.c

Abstract:

    These are the server service API RPC client stubs for CSC

--*/

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <time.h>
#include    <rpcutil.h>
#include    <lmcons.h>
#include    <lmerr.h>
#include    <lmapibuf.h>
#include    <lmshare.h>
#include    "cscp.h"

static FARPROC pCSCFindFirstFile = NULL;
static FARPROC pCSCFindNextFile = NULL;
static FARPROC pCSCFindClose = NULL;
static FARPROC pCSCIsServerOffline = NULL;

//
// Load the cscdll.dll library, and pull out the functions that we need.
//
GetCSCEntryPoints()
{
    HANDLE hMod;

    if( pCSCFindFirstFile == NULL ) {

        //
        // Get the entry points in reverse order for multithread protection
        //
        hMod = LoadLibrary(L"cscdll.dll");
        if( hMod == NULL ) {
            return 0;
        }

        pCSCFindClose = GetProcAddress(hMod,"CSCFindClose");
        if( pCSCFindClose == NULL ) {
            return 0;
        }

        pCSCFindNextFile = GetProcAddress(hMod,"CSCFindNextFileW" );
        if( pCSCFindNextFile == NULL ) {
            return 0;
        }

        pCSCIsServerOffline = GetProcAddress(hMod, "CSCIsServerOfflineW" );
        if( pCSCIsServerOffline == NULL ) {
            return 0;
        }

        pCSCFindFirstFile = GetProcAddress(hMod,"CSCFindFirstFileW" );
    }
    return pCSCFindFirstFile != 0;
}

//
// return TRUE if we think this server is in the offline state
//
BOOLEAN
CSCIsServerOffline(
    IN LPWSTR servername
)
{
    BOOL isOffline;

    if( GetCSCEntryPoints() &&
        pCSCIsServerOffline( servername, &isOffline ) &&
        isOffline == TRUE ) {

        return TRUE;
    }

    return FALSE;
}
//
// Emulate NetShareEnum() for offline servers
//
NET_API_STATUS NET_API_FUNCTION
CSCNetShareEnum (
    IN  LPWSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries
    )
{
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    sFind32;
    DWORD dwError, dwStatus, dwPinCount, dwHintFlags;
    FILETIME ftOrgTime;
    NET_API_STATUS apiStatus;
    LPWSTR server, share;
    PBYTE outbuf = NULL, endp;
    DWORD count, numFound, sharelen;

    if( (level != 0 && level != 1) ) {
        return ERROR_INVALID_PARAMETER;
    }

    try {

        if (servername[0] != L'\\')
        {
            // OK            
        }
        else if ((servername[0] == L'\\') && (servername[1] == L'\\'))
        {
            servername += 2;
        }
        else{
            apiStatus = ERROR_NOT_SUPPORTED;
            goto try_exit;
        }


        count = 1024;

retry:
        numFound = 0;

        //
        // Allocate space for the results
        //
        if( outbuf != NULL ) {
            NetApiBufferFree( outbuf );
            outbuf = NULL;
            count *= 2;
        }
        apiStatus = NetApiBufferAllocate( count, &outbuf );

        if( apiStatus != NO_ERROR ) {
            goto try_exit;
        }
        endp = outbuf + count;

        RtlZeroMemory( outbuf, count );

        //
        // See if we can enumerate the cached servers and shares
        //
        if( hFind != INVALID_HANDLE_VALUE ) {
            pCSCFindClose( hFind );
            hFind = INVALID_HANDLE_VALUE;
        }
        hFind = (HANDLE)pCSCFindFirstFile(  NULL,
                                            &sFind32,
                                            &dwStatus,
                                            &dwPinCount,
                                            &dwHintFlags,
                                            &ftOrgTime
                                        );

        if( hFind == INVALID_HANDLE_VALUE ) {
            NetApiBufferFree( outbuf );
            apiStatus =  ERROR_NOT_SUPPORTED;
            goto try_exit;
        }

        do {
            //
            // For each entry, take a look to see if it's one that we want.  If
            //   it is one, pack the results into the output buffer.  If the output
            //   buffer is too small, grow the buffer and start over again.
            //

            //
            // The name returned should be \\server\sharename
            //
            if( sFind32.cFileName[0] != L'\\' || sFind32.cFileName[1] != L'\\' ||
                sFind32.cFileName[2] == L'\0' ) {

                //
                // We got a strange server name entry
                //
                continue;
            }

            server = &sFind32.cFileName[2];

            for( share = server; *share && *share != '\\'; share++ );

            if( share[0] != '\\' ) {
                //
                // No share component?
                //
                continue;
            }

            //
            // NULL terminate the servername
            //
            *share++ = L'\0';

            if( lstrcmpiW( servername, server ) ) {
                continue;
            }

            //
            // We've found an entry for this server!
            //

            for( sharelen = 0; share[sharelen]; sharelen++ ) {
                if( share[ sharelen ] == L'\\' )
                    break;
            }

            if( sharelen == 0 ) {
                //
                // No share component?
                //
                continue;
            }

            sharelen *= sizeof( WCHAR );            // it's UNICODE
            sharelen += sizeof( WCHAR );            // the NULL

            if( level == 0 ) {
                PSHARE_INFO_0 s0 = (PSHARE_INFO_0)outbuf + numFound;;

                if( (PBYTE)(endp - sharelen) < (PBYTE)(s0 + sizeof( s0 )) ) {
                    goto retry;
                }

                endp -= sharelen;
                RtlCopyMemory( endp, share, sharelen );
                s0->shi0_netname = (LPWSTR)endp;

            } else {
                PSHARE_INFO_1 s1 = (PSHARE_INFO_1)outbuf + numFound;

                if( (PBYTE)(endp - sharelen) < (PBYTE)(s1 + sizeof( s1 )) ) {
                    goto retry;
                }

                endp -= sharelen;
                RtlCopyMemory( endp, share, sharelen );

                s1->shi1_netname = (LPWSTR)endp;
                s1->shi1_type = STYPE_DISKTREE;
                s1->shi1_remark = (LPWSTR)(endp + sharelen - sizeof(WCHAR));
            }

            numFound++;

        } while( pCSCFindNextFile(hFind, &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime) );

        pCSCFindClose(hFind);

        apiStatus = NERR_Success;

        if( numFound == 0 ) {
            NetApiBufferFree( outbuf );
            outbuf = NULL;
        }

        *bufptr = outbuf;

        *entriesread = numFound;

        *totalentries = numFound;

try_exit:;

    } except(  EXCEPTION_EXECUTE_HANDLER ) {

        if( outbuf ) {
            NetApiBufferFree( outbuf );
        }

        if( hFind != INVALID_HANDLE_VALUE ) {
            pCSCFindClose( hFind );
        }

        apiStatus = ERROR_INVALID_PARAMETER;
    }
        
    return apiStatus;
}

//
// Emulate NetShareGetInfo() for an offline server
//
NET_API_STATUS NET_API_FUNCTION
CSCNetShareGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    sFind32;
    DWORD dwError, dwStatus, dwPinCount, dwHintFlags;
    FILETIME ftOrgTime;
    NET_API_STATUS apiStatus = ERROR_NOT_SUPPORTED;
    LPWSTR server, share;
    DWORD netNameSize;

    if( (level != 0 && level != 1) ) {
        return ERROR_NOT_SUPPORTED;
    }

    try {

        hFind = (HANDLE)pCSCFindFirstFile(  NULL,
                                            &sFind32,
                                            &dwStatus,
                                            &dwPinCount,
                                            &dwHintFlags,
                                            &ftOrgTime
                                        );

        if( hFind == INVALID_HANDLE_VALUE ) {
            goto try_exit;
        }

        //
        // Loop through the entries until we find one we want
        //
        do {

            server = &sFind32.cFileName[0];

            for( share = server; *share && *share != '\\'; share++ );

            if( share[0] != '\\' ) {
                //
                // No share component?
                //
                continue;
            }

            //
            // NULL terminate the servername
            //
            *share++ = L'\0';

            if( lstrcmpiW( servername, server ) || lstrcmpiW( share, netname ) ) {
                continue;
            }

            for( netNameSize = 0; netname[ netNameSize ]; netNameSize++ )
                ;

            netNameSize += 1;
            netNameSize *= sizeof( WCHAR );

            //
            // Got the match!
            //
            if( level == 0 ) {
                PSHARE_INFO_0 s0;

                apiStatus = NetApiBufferAllocate( sizeof(*s0) + netNameSize, &s0 );
                if( apiStatus == NO_ERROR ) {
                    s0->shi0_netname = (LPTSTR)(s0 + 1);
                    RtlCopyMemory( s0->shi0_netname, netname, netNameSize );
                    *bufptr = (LPBYTE)s0;
                    apiStatus = NERR_Success;
                }

            } else {
                PSHARE_INFO_1 s1;

                apiStatus = NetApiBufferAllocate( sizeof(*s1) + netNameSize, &s1 );
                if( apiStatus == NO_ERROR ) {
                    s1->shi1_netname = (LPTSTR)(s1 + 1);
                    RtlCopyMemory( s1->shi1_netname, netname, netNameSize );
                    s1->shi1_type = STYPE_DISKTREE;
                    s1->shi1_remark = s1->shi1_netname + netNameSize/sizeof(WCHAR) - sizeof(WCHAR);
                    *bufptr = (LPBYTE)s1;
                    apiStatus = NERR_Success;
                }
            }

            break;

        } while( pCSCFindNextFile(hFind,&sFind32,&dwStatus,&dwPinCount,&dwHintFlags, &ftOrgTime) );

        pCSCFindClose( hFind );

try_exit:;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        if( hFind != INVALID_HANDLE_VALUE ) {
            pCSCFindClose( hFind );
        }

        apiStatus = ERROR_INVALID_PARAMETER;

    }

    return apiStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\srvsvc_c_stub.c ===
#include "srvsvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\srvbind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Server
    Service.

Author:

    Dan Lafferty (danl)     01-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    01-Mar-1991     danl
        created
    07-Jun-1991 JohnRo
        Allowed debug output of failures.

--*/

//
// INCLUDES
//
#include <nt.h>      // DbgPrint prototype
#include <rpc.h>        // DataTypes and runtime APIs
#include <srvsvc.h>     // generated by the MIDL complier
#include <rpcutil.h>    // NetRpc utils
#include <netlib.h>     // UNUSED macro
#include <srvnames.h>   // SERVER_INTERFACE_NAME



handle_t
SRVSVC_HANDLE_bind (
    SRVSVC_HANDLE   ServerName)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle;
    RPC_STATUS  status;

    status = NetpBindRpc (
                ServerName,
                SERVER_INTERFACE_NAME,
                TEXT("Security=Impersonation Dynamic False"),
                &bindingHandle);

    return( bindingHandle);
}



void
SRVSVC_HANDLE_unbind (
    SRVSVC_HANDLE   ServerName,
    handle_t        BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNUSED(ServerName);     // This parameter is not used

    NetpUnbindRpc ( BindingHandle);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\cscp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    adtdbg.h 

Abstract:

    Contains definitions used for accessing the CSC share database

--*/

//
// These functions are callouts from srvstub.c to the CSC subsystem.  They help with
//  offline access to servers and shares
//

BOOLEAN NET_API_FUNCTION
CSCIsServerOffline(
    IN LPWSTR servername
    );

NET_API_STATUS NET_API_FUNCTION
CSCNetShareEnum (
    IN  LPWSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries
    );

NET_API_STATUS NET_API_FUNCTION
CSCNetShareGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\dfsstub.c ===
/*++

Copyright (c) 1991-1996  Microsoft Corporation

Module Name:

    dfsstub.c

Abstract:

    These are the server service API RPC client stubs for DFS operations

Environment:

    User Mode - Win32

--*/

//
// INCLUDES
//

#include <nt.h>         // DbgPrint prototype

#include <ntrtl.h>      // DbgPrint
#include <rpc.h>        // DataTypes and runtime APIs

#include <srvsvc.h>     // generated by the MIDL complier
#include <lmcons.h>     // NET_API_STATUS
#include <debuglib.h>   // (needed by netrpc.h)
#include <lmsvc.h>      // (needed by netrpc.h)
#include <netdebug.h>   // (needed by netrpc.h)
#include <lmerr.h>      // NetError codes
#include <netrpc.h>     // NET_REMOTE_ macros.
#include <nturtl.h>
#include <winbase.h>
#include <dfspriv.h>
#include <Winsock2.h>
#include <Dsgetdc.h>
#include <malloc.h>
#include <stdio.h>
#include <Lm.h>



NET_API_STATUS NET_API_FUNCTION
I_NetDfsGetVersion(
    IN  LPWSTR  servername,
    OUT LPDWORD Version)
{
    NET_API_STATUS apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsGetVersion( servername, Version );

    NET_REMOTE_RPC_FAILED(
            "I_NetDfsGetVersion",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

}


NET_API_STATUS NET_API_FUNCTION
I_NetDfsCreateLocalPartition (
    IN  LPWSTR                          servername,
    IN  LPWSTR                          ShareName,
    IN  LPGUID                          EntryUid,
    IN  LPWSTR                          EntryPrefix,
    IN  LPWSTR                          ShortName,
    IN  LPNET_DFS_ENTRY_ID_CONTAINER    RelationInfo,
    IN  BOOL                            Force
    )
{
    NET_API_STATUS  apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsCreateLocalPartition (
                        servername,
                        ShareName,
                        EntryUid,
                        EntryPrefix,
                        ShortName,
                        RelationInfo,
                        Force
                        );

    NET_REMOTE_RPC_FAILED(
            "NetDfsCreateLocalPartition",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

}

NET_API_STATUS NET_API_FUNCTION
I_NetDfsDeleteLocalPartition (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPGUID  Uid,
    IN  LPWSTR  Prefix
    )
{
    NET_API_STATUS  apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsDeleteLocalPartition (
                        servername,
                        Uid,
                        Prefix
                        );

    NET_REMOTE_RPC_FAILED(
            "NetDfsDeleteLocalPartition",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END;

    return apiStatus;
}

NET_API_STATUS NET_API_FUNCTION
I_NetDfsSetLocalVolumeState (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPGUID  Uid,
    IN  LPWSTR  Prefix,
    IN  ULONG   State
    )
{
    NET_API_STATUS  apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsSetLocalVolumeState (
                        servername,
                        Uid,
                        Prefix,
                        State
                        );

    NET_REMOTE_RPC_FAILED(
            "NetDfsSetLocalVolumeState",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END;

    return apiStatus;
}

NET_API_STATUS NET_API_FUNCTION
I_NetDfsSetServerInfo (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPGUID  Uid,
    IN  LPWSTR  Prefix
    )
{
    NET_API_STATUS  apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsSetServerInfo (
                        servername,
                        Uid,
                        Prefix
                        );

    NET_REMOTE_RPC_FAILED(
            "NetDfsSetServerInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END;

    return apiStatus;
}

NET_API_STATUS NET_API_FUNCTION
I_NetDfsCreateExitPoint (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPGUID  Uid,
    IN  LPWSTR  Prefix,
    IN  ULONG   Type,
    IN  ULONG   ShortPrefixSize,
    OUT LPWSTR  ShortPrefix
    )
{
    NET_API_STATUS  apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsCreateExitPoint (
                        servername,
                        Uid,
                        Prefix,
                        Type,
                        ShortPrefixSize,
                        ShortPrefix
                        );

    NET_REMOTE_RPC_FAILED(
            "NetDfsCreateExitPoint",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END;

    return apiStatus;
}

NET_API_STATUS NET_API_FUNCTION
I_NetDfsDeleteExitPoint (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPGUID  Uid,
    IN  LPWSTR  Prefix,
    IN  ULONG   Type
    )
{
    NET_API_STATUS  apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsDeleteExitPoint (
                        servername,
                        Uid,
                        Prefix,
                        Type
                        );

    NET_REMOTE_RPC_FAILED(
            "NetDfsDeleteExitPoint",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END;

    return apiStatus;
}

NET_API_STATUS NET_API_FUNCTION
I_NetDfsModifyPrefix (
    IN  LPWSTR  servername OPTIONAL,
    IN  LPGUID  Uid,
    IN  LPWSTR  Prefix
    )
{
    NET_API_STATUS  apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsModifyPrefix (
                        servername,
                        Uid,
                        Prefix
                        );

    NET_REMOTE_RPC_FAILED(
            "NetDfsModifyPrefix",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END;

    return apiStatus;
}

NET_API_STATUS NET_API_FUNCTION
I_NetDfsFixLocalVolume (
    IN  LPWSTR                          servername OPTIONAL,
    IN  LPWSTR                          VolumeName,
    IN  ULONG                           EntryType,
    IN  ULONG                           ServiceType,
    IN  LPWSTR                          StgId,
    IN  LPGUID                          EntryUid,       // unique id for this partition
    IN  LPWSTR                          EntryPrefix,    // path prefix for this partition
    IN  LPNET_DFS_ENTRY_ID_CONTAINER    RelationInfo,
    IN  ULONG                           CreateDisposition
    )
{
    NET_API_STATUS  apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsFixLocalVolume (
                        servername,
                        VolumeName,
                        EntryType,
                        ServiceType,
                        StgId,
                        EntryUid,
                        EntryPrefix,
                        RelationInfo,
                        CreateDisposition
                        );

    NET_REMOTE_RPC_FAILED(
            "NetDfsFixLocalVolume",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END;

    return apiStatus;
}

NET_API_STATUS NET_API_FUNCTION
I_NetDfsManagerReportSiteInfo (
    IN  LPWSTR                          ServerName,
    OUT LPDFS_SITELIST_INFO            *ppSiteInfo
    )
{
    struct sockaddr_in Destination;
    struct hostent * pHostEnt;
    SOCKET_ADDRESS SocketAddress;
    NET_API_STATUS  apiStatus;
    LPWSTR *SiteName = NULL;
    char* ServerNameA = NULL;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrDfsManagerReportSiteInfo (
                        ServerName,
                        ppSiteInfo
                        );



    NET_REMOTE_RPC_FAILED(
             "NetDfsMangerReportSiteInfo",
             ServerName,
             apiStatus,
             NET_REMOTE_FLAG_NORMAL,
             SERVICE_SERVER)


    NET_REMOTE_END;


    if(apiStatus != ERROR_SUCCESS) {
        WORD wVersionRequested;
        WSADATA wsaData;
        DWORD dwErr = ERROR_SUCCESS;
        int err;
        PDOMAIN_CONTROLLER_INFO pDCInfo;

        wVersionRequested = MAKEWORD( 2, 2 );
 
        err = WSAStartup( wVersionRequested, &wsaData );
        if ( err != 0 ) {
            /* We could not find a usable */
            /* WinSock DLL.                                  */
            return apiStatus;
        }
 
 

        // we couldn't get the site name
        ServerNameA = malloc(wcslen(ServerName) + 1);

        if(ServerNameA == NULL) {
            apiStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            // need to convert from WCHAR* to char*
            sprintf(ServerNameA, "%ws", ServerName);

            if ((pHostEnt = gethostbyname(ServerNameA)) != NULL) {
                memcpy(&(Destination.sin_addr), pHostEnt->h_addr, pHostEnt->h_length);
                Destination.sin_family = pHostEnt->h_addrtype;

                if(pHostEnt->h_addrtype != AF_INET) {
                    apiStatus = ERROR_NOT_SUPPORTED;
                } else {
                    SocketAddress.lpSockaddr = (struct sockaddr *)&Destination;
                    SocketAddress.iSockaddrLength = sizeof(Destination);
                    Destination.sin_port = 0;
                    
                    dwErr = DsGetDcName(
                        NULL,                            // Computer to remote to
                        NULL,                            // Domain - use local domain
                        NULL,                            // Domain Guid
                        NULL,                            // Site Guid
                        0,                 // Flags
                        &pDCInfo);

                    if(dwErr == ERROR_SUCCESS) {
                        apiStatus = DsAddressToSiteNames(pDCInfo->DomainControllerAddress,
                                                         1,
                                                         &SocketAddress,
                                                         &SiteName
                                                         );

                        NetApiBufferFree( pDCInfo );
                    } else {
                        apiStatus = ERROR_NOT_SUPPORTED;
                    }

                    if(apiStatus == NO_ERROR) {
			if((SiteName == NULL) || (*SiteName == NULL)) {
			    // If DsAddressToSiteNames can't map to a site name,
			    // it returns success but sets the buffer to NULL.
			    apiStatus = ERROR_NO_SITENAME;
			} else {
			    // we got the site name
			    apiStatus = NetApiBufferAllocate(
				sizeof(DFS_SITELIST_INFO) + ((wcslen(*SiteName) + 1) * sizeof(WCHAR)),
				ppSiteInfo
				);

			    if(apiStatus == ERROR_SUCCESS) {
				(*ppSiteInfo)->cSites = 1;
				(*ppSiteInfo)->Site[0].SiteName = (LPWSTR)((ULONG_PTR)(*ppSiteInfo) + sizeof(DFS_SITELIST_INFO));
				wcscpy((*ppSiteInfo)->Site[0].SiteName, *SiteName);
			    }
			}
                    }
                } 
            } else {
                apiStatus = WSAGetLastError();
                apiStatus = ERROR_NOT_SUPPORTED;
            }
            free(ServerNameA);

        }

        WSACleanup();
    }


    return apiStatus;
}



#include    <dsgetdc.h>
#include    <winldap.h>
#include    <lmapibuf.h>

//
// This is the container which holds the DFS configuration data
//
static const WCHAR DfsConfigContainer[] = L"CN=Dfs-Configuration,CN=System";

typedef struct
{
    int         cPieces;
    PCHAR       rpPieces[1];
} DNS_NAME, *PDNS_NAME;

static
DWORD
BreakDnsName(
    IN  CHAR        *pName,
    OUT PDNS_NAME   *ppDnsName
    )

/*++

Routine Description:

    Breaks a DNS name in dotted string format (eg: dbsd.microsoft.com) into
    its constituent parts.

Arguments:

    pName - pointer to string representing dotted DNS name to break.

    ppDnsName - pointer to pointer to DNS_NAME struct which should be
        deallocated by NetApiBufferFree().
--*/

{
    int     cPieces;
    CHAR    *p;
    DWORD   cBytes;
    CHAR    *buffer;
    int     i;
    LPSTR   seps = ".";

    if ( (NULL == pName) || ('\0' == *pName) || ('.' == *pName) )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    // Count number of pieces so we can figure out how much to allocate.

    cPieces = 1;
    p = pName;

    for ( p = pName; '\0' != *p; p++ )
    {
        if ( '.' == *p )
        {
            cPieces++;
        }
    }

    // Calculate bytes to allocate.  Allocate memory which will hold (in order)
    // the DNS_NAME struct, the DNS_NAME.rpPieces pointer array, and finally
    // a scratch buffer where we can strtok the input name.

    cBytes = sizeof(DNS_NAME);
    cBytes += cPieces * sizeof(PCHAR);
    cBytes += strlen(pName) + 1;

    NetApiBufferAllocate( cBytes, (PVOID *)ppDnsName );

    if ( *ppDnsName == NULL )
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Fill in the buffer and call strtok as often as required to chop it
    // into pieces filling the DNS_NAME as we go.

    buffer = (CHAR *) &((*ppDnsName)->rpPieces[cPieces]);
    strcpy(buffer, pName);

    (*ppDnsName)->cPieces = cPieces;
    (*ppDnsName)->rpPieces[0] = strtok(buffer, seps);

    for ( i = 1; i < cPieces; i++ )
    {
        (*ppDnsName)->rpPieces[i] = strtok(NULL, seps);
    }

    return(NO_ERROR);
}

static
DWORD
FindContext(
    IN  CHAR    *pName,
    IN  int     cDnValues,
    IN  CHAR    **rpDnValues,
    OUT int     *pMatchingValueIndex
    )

/*++

Routine Description:

    Determines the best match of a DNS name (eg: dbsd.microsoft.com)
    to a set of RFC 1779 DNs (eg: ou=dbsd, ou=microsoft, c=us).  We assume
    that the array of DNs represent NT5 DS naming contexts (i.e. domains)
    which is true with the exception of the Configuration naming context.
    For example, let's say a DC hosted three naming contexts:

        1 - ou=dbsd, ou=microsoft, c=us
        2 - ou=nt, ou=dbsd, ou=microsoft, c=us
        3 - ou=configuration, ou=microsoft, c=us

    Then dbsd.microsoft.com would match the 1st DN in the list.  This is not
    foolproof in the case of a deviant namespace which has a domain structure
    like:

        ou=dbsd, ou=microsoft, ou=com, ou=dbsd, ou=microsoft, c=us

    But anyone with a namespace like that is going to have other problems
    anyway.

Arguments:

    pName - pointer to DNS name to match.

    cDnValues - count of values in rpDnValues.

    rpDnValues - array of pointers to DNs to match against.

    pMatchingValueIndex - pointer to int which will identify the best
        matching DN in rpDnValues on successful return.

Return Value:

    NO_ERROR                        - success
    ERROR_NOT_ENOUGH_MEMORY         - allocation error
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_INVALID_DOMAINNAME        - bad DNS or DN domain name

--*/
{
    DWORD       dwErr;
    int         i, j;
    CHAR        **rpDn = NULL;
    int         currentMatchLength;
    int         bestMatchLength;
    int         bestMatchIndex;
    PDNS_NAME   pDomainDnsName = NULL;

    dwErr = BreakDnsName(pName, &pDomainDnsName);

    if ( NO_ERROR != dwErr )
    {
        return(dwErr);
    }

    // Iterate over the DN values and see which one has the longest match.

    bestMatchIndex = 0;
    bestMatchLength = -1;

    for ( i = 0; i < cDnValues; i++ )
    {
        rpDn = ldap_explode_dn(rpDnValues[i], 1);   // 1 ==> notypes

        if ( NULL == rpDn )
        {
            dwErr = ERROR_INVALID_DOMAINNAME;
            goto Cleanup;
        }

        currentMatchLength = 0;

        // Try to match each piece of the domain name to each piece of the
        // DN.  Fortunately, RFC 1779 DNs are ordered least to most significant
        // just as DNS domain names are.  rpDn[] is "terminated" with a NULL.

        for ( j = 0; (j < pDomainDnsName->cPieces) && (NULL != rpDn[j]); j++ )
        {
            if ( 0 == _stricmp(pDomainDnsName->rpPieces[j], rpDn[j]) )
            {
                currentMatchLength++;
            }
        }

        if ( (0 != currentMatchLength) &&
             (currentMatchLength > bestMatchLength) )
        {
            bestMatchLength = currentMatchLength;
            bestMatchIndex = i;
        }

        ldap_value_free(rpDn);
    }

    *pMatchingValueIndex = bestMatchIndex;
    dwErr = NO_ERROR;

Cleanup:

    if ( pDomainDnsName != NULL ) {
        NetApiBufferFree( pDomainDnsName );
    }

    return(dwErr);
}

/*
 * This API returns a vector of \\server\share combinations which form the
 *  root of a Fault Tolerant DFS.  This  null-terminated vector should be
 *  freed by the caller with NetApiBufferFree().
 *
 * If pLDAP is supplied, we asssume that this is the handle to the DS server
 *  holding the configuration data.  Else, we use wszDomainName to locate the
 *  proper DS server.
 *
 * wszDfsName is the name of the fault tolerant DFS for which individual servers
 *  are to be discovered.
 *
 */
NET_API_STATUS NET_API_FUNCTION
I_NetDfsGetFtServers(
    IN PVOID  LdapInputArg OPTIONAL,
    IN LPWSTR wszDomainName OPTIONAL,
    IN LPWSTR wszDfsName OPTIONAL,
    OUT LPWSTR **List
    )
{
    PLDAP pLDAP = (PLDAP)LdapInputArg;
    BOOLEAN bUnbindNeeded = FALSE;
    DWORD dwErr;
    NTSTATUS status;
    PWCHAR attrs[2];
    LDAPMessage *pMsg = NULL;
    LDAPMessage *pEntry = NULL;
    WCHAR *pAttr = NULL;
    WCHAR **rpValues = NULL;
    WCHAR **allValues = NULL;
    WCHAR ***rpValuesToFree = NULL;
    INT cValues = 0;
    INT i;
    WCHAR *dfsDn = NULL;
    DWORD len;
    USHORT cChar;
    PWCHAR *resultVector;
    ULONG cBytes;

    if (List == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *List = NULL;

    if (!ARGUMENT_PRESENT(pLDAP)) {

        DOMAIN_CONTROLLER_INFO *pInfo = NULL;
        ULONG dsAdditionalFlags = 0;
        ULONG retry;

        for (retry = 0; pLDAP == NULL && retry < 2; retry++) {

            //
            // Find a DC for the given domain.
            //
            dwErr = DsGetDcName(
                        NULL,                       // computer name
                        wszDomainName,              // DNS domain name
                        NULL,                       // domain guid
                        NULL,                       // site guid
                        DS_DIRECTORY_SERVICE_REQUIRED |
                            DS_IP_REQUIRED |
                            dsAdditionalFlags,
                        &pInfo);

            if (dwErr != NO_ERROR) {
                return dwErr;
            }

            //
            // DomainControllerAddress is prefixed with "\\" so
            // aditionally ensure there's some useful data there.
            //

            if (DS_INET_ADDRESS != pInfo->DomainControllerAddressType ||
                 (cChar = (USHORT)wcslen(pInfo->DomainControllerAddress)) < 3) {

                NetApiBufferFree(pInfo);
                return ERROR_NO_SUCH_DOMAIN;
            }

            //
            // Try to connect to the DS server on the DC
            //

            pLDAP = ldap_openW(&pInfo->DomainControllerAddress[2], 0);

            if (pLDAP == NULL) {
                //
                // Couldn't connect.  Let's force rediscovery and see if we
                //  can connect to a DC which is working!
                //
                NetApiBufferFree(pInfo);
                dsAdditionalFlags |= DS_FORCE_REDISCOVERY;

            } else {

              dwErr = ldap_bind_s(pLDAP, NULL, NULL, LDAP_AUTH_SSPI);

            }

            NetApiBufferFree(pInfo);

        }

        if (pLDAP == NULL || dwErr != LDAP_SUCCESS) {
            return ERROR_PATH_NOT_FOUND;
        }

        bUnbindNeeded = TRUE;

    }

    //
    // Read the namingContexts operational attribute.
    //

    pLDAP->ld_sizelimit = 0;                    // no search limit
    pLDAP->ld_timelimit = 0;                    // no time limit
    pLDAP->ld_deref = LDAP_DEREF_NEVER;

    attrs[0] = L"defaultnamingContext";
    attrs[1] = NULL;

    if ((dwErr = ldap_search_sW(
                    pLDAP,
                    L"",                         // search base
                    LDAP_SCOPE_BASE,
                    L"(objectClass=*)",          // filter
                    attrs,
                    0,                          // attrs and values
                    &pMsg)) != LDAP_SUCCESS) {

        goto Cleanup;

    }

    //
    // Make sure we got back something reasonable
    //
    if (ldap_count_entries(pLDAP, pMsg) != 1 ||
        (pEntry = ldap_first_entry(pLDAP, pMsg)) == NULL ||
        (rpValues = ldap_get_valuesW(pLDAP, pEntry, attrs[0])) == NULL ||
        (cValues = ldap_count_valuesW(rpValues)) == 0
    ) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(wszDfsName)) {

        //
        // Looks good.  Allocate enough memory to hold the DN of the
        // DFS configuration data for the fault tolerant DFS in question
        //

        len = (DWORD)(3 * sizeof(WCHAR) +
                (wcslen(wszDfsName) + 1) * sizeof(WCHAR) +
                    (wcslen(DfsConfigContainer) + 1) * sizeof(WCHAR) +
                        (wcslen(rpValues[0]) + 1) * sizeof(WCHAR));

        dwErr = NetApiBufferAllocate(len, (PVOID *)&dfsDn);

        if (dfsDn == NULL) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Construct the DN
        //

        RtlZeroMemory(dfsDn, len);
        wcscpy(dfsDn, L"CN=");
        wcscat(dfsDn, wszDfsName);
        wcscat(dfsDn, L",");
        wcscat(dfsDn, DfsConfigContainer);
        wcscat(dfsDn, L",");
        wcscat(dfsDn, rpValues[0]);

        //
        // Now see if we can get at the 'remoteServerName' property of this object.
        //  This property holds the names of the servers hosting this DFS
        //

        pLDAP->ld_sizelimit = 0;
        pLDAP->ld_timelimit= 0;
        pLDAP->ld_deref = LDAP_DEREF_NEVER;

        ldap_msgfree(pMsg);
        pMsg = NULL;

        ldap_value_freeW(rpValues);
        rpValues = NULL;

        attrs[0] = L"remoteServerName";
        attrs[1] = NULL;

        dwErr = ldap_search_sW(
                            pLDAP,
                            dfsDn,
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            attrs,
                            0,
                            &pMsg);

        //
        // Make sure the result is reasonable
        //
        if (ldap_count_entries(pLDAP, pMsg) == 0 ||
            (pEntry = ldap_first_entry(pLDAP, pMsg)) == NULL ||
            (rpValues = ldap_get_valuesW(pLDAP, pEntry, attrs[0])) == NULL ||
            rpValues[0][0] == L'\0'
        ) {

            dwErr = ERROR_PATH_NOT_FOUND;
            goto Cleanup;
        }

        //
        // The result is reasonable, just point allValues to rpValues
        //

        allValues = rpValues;

    } else {

        //
        // The caller is trying to retrieve the names of all the FT DFSs in the domain
        //
        // Allocate enough memory to hold the DN of the
        // DFS configuration container
        //

        len = (wcslen(DfsConfigContainer) + 1) * sizeof(WCHAR) +
                (wcslen(rpValues[0]) + 1) * sizeof(WCHAR);

        dwErr = NetApiBufferAllocate(len, (PVOID *)&dfsDn);

        if (dfsDn == NULL) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Construct the DN
        //

        RtlZeroMemory(dfsDn, len);
        wcscpy(dfsDn, DfsConfigContainer);
        wcscat(dfsDn, L",");
        wcscat(dfsDn, rpValues[0]);

        //
        // Now see if we can enumerate the objects below this one.  The names
        //   of these objects will be the different FT dfs's available
        //
        pLDAP->ld_sizelimit = 0;
        pLDAP->ld_timelimit= 0;
        pLDAP->ld_deref = LDAP_DEREF_NEVER;

        ldap_msgfree(pMsg);
        pMsg = NULL;

        ldap_value_freeW(rpValues);
        rpValues = NULL;

        attrs[0] = L"CN";
        attrs[1] = NULL;

        dwErr = ldap_search_sW(
                            pLDAP,
                            dfsDn,
                            LDAP_SCOPE_ONELEVEL,
                            L"(objectClass=fTDfs)",
                            attrs,
                            0,
                            &pMsg);

        //
        // Make sure the result is reasonable
        //
        if (
            ((cValues = ldap_count_entries(pLDAP, pMsg)) == 0) ||
             (pEntry = ldap_first_entry(pLDAP, pMsg)) == NULL
        ) {
            dwErr = ERROR_PATH_NOT_FOUND;
            goto Cleanup;
        }

        //
        // The search for all FTDfs's returns multiple entries, each with
        // one value for the object's CN. Coalesce these into a single array.
        //

        dwErr = NetApiBufferAllocate(2 * (cValues + 1) * sizeof(PWSTR), (PVOID *)&allValues);

        if (dwErr != ERROR_SUCCESS) {
            goto Cleanup;
        }

        rpValuesToFree = (WCHAR ***) &allValues[cValues + 1];

        for (i = 0; (i < cValues) && (dwErr == ERROR_SUCCESS); i++) {

            rpValues = ldap_get_valuesW(pLDAP, pEntry, attrs[0]);
            rpValuesToFree[i] = rpValues;
            //
            // Sanity check
            //
            if (ldap_count_valuesW(rpValues) == 0 || rpValues[0][0] == L'\0') {
                dwErr = ERROR_PATH_NOT_FOUND;
            } else {
                allValues[i] = rpValues[0];
                pEntry = ldap_next_entry(pLDAP, pEntry);
            }

        }

        if (dwErr == ERROR_SUCCESS) {
            allValues[i] = NULL;
            rpValuesToFree[i] = NULL;
        } else {
            goto Cleanup;
        }

    }

    if (dwErr != LDAP_SUCCESS) {
        dwErr = ERROR_PATH_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Now we need to allocate the memory to hold this vector and return the results.
    //
    // First see how much space we need
    //

    for (len = cValues = 0; allValues[cValues]; cValues++) {
        len += sizeof(LPWSTR) + (wcslen(allValues[cValues]) + 1) * sizeof(WCHAR);
    }
    len += sizeof(LPWSTR);        // for the final NULL pointer

    dwErr = NetApiBufferAllocate(len, (PVOID *)&resultVector); 

    if (dwErr == NO_ERROR) {

        LPWSTR pstr = (LPWSTR)((PCHAR)resultVector + (cValues + 1) * sizeof(LPWSTR));
        ULONG slen;

        RtlZeroMemory(resultVector, len);

        len -= (cValues+1) * sizeof(LPWSTR);

        for (cValues = 0; allValues[cValues] && len >= sizeof(WCHAR); cValues++) {

            resultVector[cValues] = pstr;
            wcscpy(pstr, allValues[cValues]);
            slen = wcslen(allValues[cValues]);
            pstr += slen + 1;
            len -= (slen + 1) * sizeof(WCHAR);

        }

    }

    if (dwErr == NO_ERROR) {
        *List = resultVector;
    }

Cleanup:

    if (ARGUMENT_PRESENT(wszDfsName)) {
        if (rpValues != NULL) {
            ldap_value_freeW(rpValues);
        }
    } else {
        if (rpValuesToFree != NULL) {
            for (i = 0; rpValuesToFree[i] != NULL; i++) {
                ldap_value_freeW(rpValuesToFree[i]);
            }
        }
        if (allValues != NULL) {
            NetApiBufferFree(allValues);
        }
    }

    if (pMsg != NULL) {
        ldap_msgfree(pMsg);
    }

    if (dfsDn != NULL) {
        NetApiBufferFree(dfsDn);
    }

    if (pLDAP != NULL && bUnbindNeeded == TRUE) {
        ldap_unbind(pLDAP);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\tsrvsvc.c ===
#include <windows.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmshare.h>
#include <lmserver.h>

int
main (
    int argc,
    char *argv[]
    )
{
    LPBYTE buffer;
    DWORD entries;
    DWORD totalEntries;
    NET_API_STATUS status;

#if 0
    status = I_NetServerSetServiceBits( NULL, 0x5555AAAA );

    if ( status != NERR_Success ) {

        printf( "I_NetServerSetServiceBits failed: %ld\n", status );

    }
#endif

#if 0
    status = NetServerDiskEnum(
                NULL,
                0,
                &buffer,
                -1,
                &entries,
                &totalEntries,
                NULL
                );

    if ( status != NERR_Success ) {

        printf( "NetServerDiskEnum failed: %ld\n", status );

    } else {

        PSZ p = buffer;
        DWORD i = 0;

        while ( *p != 0 ) {
            printf( "Disk %ld is %s\n", i, p );
            while ( *(++p) != 0 ) ;
            p++;
            i++;
        }

        if ( i != entries ) {
            printf( "Incorrect entry count returned: %ld\n", entries );
        }

    }

    return status;
#endif

#if 1
    status = NetShareEnum(
                "",
                0,
                &buffer,
                8192,
                &entries,
                &totalEntries,
                NULL
                );

    if ( status != NERR_Success ) {

        printf( "NetShareEnum failed: %ld\n", status );

    } else {

        printf( "NetShareEnum worked.\n" );
        printf( "  entries = %ld, totalEntries = %ld\n",
                entries, totalEntries );

    }

    return status;
#endif

} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\radmin.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    radmin.c  (remote admin)

Abstract:

    This file exercises the various NetAdminTools API.

Author:

    Dan Lafferty (danl)     19-Sept-1991

Environment:

    User Mode -Win32

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for windows.h when I have nt.h
#include <windows.h>

#include <stdlib.h>     // atoi
#include <stdio.h>      // printf
#include <tstr.h>       // STRICMP

#include <ntseapi.h>    // SECURITY_DESCRIPTOR_CONTROL
#include <srvsvc.h>
#include <filesec.h>    // NetpGetFileSecurity, NetpSetFileSecurity

//
// DataStructures
//

typedef struct _TEST_SID {
    UCHAR   Revision;
    UCHAR   SubAuthorityCount;
    UCHAR   IdentifierAuthority[6];
    ULONG   SubAuthority[10];
} TEST_SID, *PTEST_SID, *LPTEST_SID;

typedef struct _TEST_ACL {
    UCHAR   AclRevision;
    UCHAR   Sbz1;
    USHORT  AclSize;
    UCHAR   Dummy1[];
} TEST_ACL, *PTEST_ACL;

typedef struct _TEST_SECURITY_DESCRIPTOR {
   UCHAR                        Revision;
   UCHAR                        Sbz1;
   SECURITY_DESCRIPTOR_CONTROL  Control;
   PTEST_SID                    Owner;
   PTEST_SID                    Group;
   PTEST_ACL                    Sacl;
   PTEST_ACL                    Dacl;
} TEST_SECURITY_DESCRIPTOR, *PTEST_SECURITY_DESCRIPTOR;

//
// GLOBALS
//

    TEST_SID     OwnerSid = { 
                        1, 5,
                        1,2,3,4,5,6,
                        0x999, 0x888, 0x777, 0x666, 0x12345678};

    TEST_SID     GroupSid = {
                        1, 5,
                        1,2,3,4,5,6,
                        0x999, 0x888, 0x777, 0x666, 0x12345678};

    TEST_ACL     SaclAcl  = { 1, 2, 4+1, 3};
    TEST_ACL     DaclAcl  = { 1, 2, 4+5, 4, 4, 4, 4, 4, };

    TEST_SECURITY_DESCRIPTOR TestSd = {
                                    1, 2, 0x3333,
                                    &OwnerSid,
                                    &GroupSid,
                                    &SaclAcl,
                                    NULL };



//
// Function Prototypes
//

NET_API_STATUS
TestGetFileSec(
    LPTSTR   ServerName,
    LPTSTR  FileName
    );

NET_API_STATUS
TestSetFileSec(
    LPTSTR   ServerName,
    LPTSTR  FileName
    );

VOID
Usage(VOID);


VOID
DisplaySecurityDescriptor(
    PTEST_SECURITY_DESCRIPTOR    pSecDesc
    );
    
BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    );

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    );





VOID __cdecl
main (
    DWORD           argc,
    PUCHAR          argv[]
    )

/*++

Routine Description:

    Allows manual testing of the AdminTools API.
        
        radmin GetNameFromSid      - calls NetpGetNameFromSid
        radmin SetFileSec          - calls NetpSetFileSecurity

        etc...


Arguments:



Return Value:



--*/

{
    DWORD       status;
    LPTSTR      FileName;
    LPTSTR      *FixArgv;
    LPTSTR      pServerName;
    DWORD       argIndex;

    //
    // Make the arguments unicode if necessary.
    //
#ifdef UNICODE

    if (!MakeArgsUnicode(argc, argv)) {
        return;
    }

#endif
    FixArgv = (LPTSTR *)argv;
    argIndex = 1;
    pServerName = NULL;

    if (STRNCMP (FixArgv[1], TEXT("\\\\"), 2) == 0) {
        pServerName = FixArgv[1];
        argIndex = 2;
    }
    if (argc < 2) {
        printf("ERROR: \n");
        Usage();
        return;
    }

    if (STRICMP (FixArgv[argIndex], TEXT("GetFileSec")) == 0) {
        if (argc > argIndex ) {
            FileName = FixArgv[argIndex+1];
        }
        else {
            FileName = NULL;
        }
        status = TestGetFileSec(pServerName,FileName);
    }

    else if (STRICMP (FixArgv[argIndex], TEXT("SetFileSec")) == 0) {
        if (argc > argIndex ) {
            FileName = FixArgv[argIndex+1];
        }
        else {
            FileName = NULL;
        }
        status = TestSetFileSec(pServerName,FileName);
    }

    else {
        printf("[sc] Unrecognized Command\n");
        Usage();
    }

    return;
}




NET_API_STATUS
TestGetFileSec(
    LPTSTR   ServerName,
    LPTSTR   FileName
    )
{
    NET_API_STATUS              status;
    SECURITY_INFORMATION        secInfo;
    PTEST_SECURITY_DESCRIPTOR   pSecurityDescriptor;
    LPBYTE                      pDest;
    DWORD                       Length;

    if (FileName == NULL ) {
        FileName = TEXT("Dan.txt");
    }

//    secInfo = (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
//               DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION);
    secInfo = (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
               DACL_SECURITY_INFORMATION );

    status = NetpGetFileSecurity(
                FileName,               // FileName,
                secInfo,                // pRequestedInformation,
                (PSECURITY_DESCRIPTOR *)&pSecurityDescriptor, // pSecurityDescriptor,
                &Length);               // pnLength

    if (status != NO_ERROR) {
        printf("NetpGetFileSecurity Failed %d,0x%x\n",status,status);
    }
    else{

        pDest = (LPBYTE) pSecurityDescriptor;

        if (!IsValidSecurityDescriptor(pSecurityDescriptor)) {
            printf("FAILURE:  SECURITY DESCRIPTOR IS INVALID\n");
        }
        else {
            printf("SUCCESS:  SECURITY DESCRIPTOR IS VALID\n");
        }

        //
        // Make the self-releative SD absolute for display.
        //
        pSecurityDescriptor->Owner = (PTEST_SID)(pDest + (DWORD)pSecurityDescriptor->Owner);
        pSecurityDescriptor->Group = (PTEST_SID)(pDest + (DWORD)pSecurityDescriptor->Group);
        pSecurityDescriptor->Sacl  = (PTEST_ACL)(pDest + (DWORD)pSecurityDescriptor->Sacl);
        pSecurityDescriptor->Dacl  = (PTEST_ACL)(pDest + (DWORD)pSecurityDescriptor->Dacl);
        pSecurityDescriptor->Control &= (~SE_SELF_RELATIVE);

        if (pSecurityDescriptor->Sacl == (PTEST_ACL)pDest) {
            pSecurityDescriptor->Sacl = NULL;
        }
        if (pSecurityDescriptor->Dacl == (PTEST_ACL)pDest) {
            pSecurityDescriptor->Dacl = NULL;
        }

        printf("Size of Security Descriptor = %ld \n",Length);
        DisplaySecurityDescriptor(pSecurityDescriptor);
    }

    return (NO_ERROR);
}

NET_API_STATUS
TestSetFileSec(
    LPTSTR   ServerName,
    LPTSTR   FileName
    )
{
    NET_API_STATUS          status;
    SECURITY_INFORMATION    secInfo;


    if (FileName == NULL ) {
        FileName = TEXT("Dan.txt");
    }

    secInfo = 0x55555555;
    
    status = NetpSetFileSecurity(
                FileName,                       // FileName,
                secInfo,                        // pRequestedInformation,
                (PSECURITY_DESCRIPTOR)&TestSd); // pSecurityDescriptor,

    if (status != NO_ERROR) {
        printf("NetpSetFileSecurity Failed %d,0x%x\n",status,status);
    }
    return (NO_ERROR);
}


VOID
Usage(VOID)
{

    printf("USAGE:\n");
    printf("radmin <server> <function>\n");
    printf("Functions: GetFileSec, SetFileSec...\n\n");

    printf("SYNTAX EXAMPLES    \n");

    printf("radmin \\\\DANL2 GetFileSec     - calls NetpGetFileSecurity on \\DANL2\n");
    printf("radmin \\\\DANL2 SetFileSec     - calls NetpSetFileSecurity on \\DANL2\n");
}



// ***************************************************************************
VOID
DisplaySecurityDescriptor(
    PTEST_SECURITY_DESCRIPTOR    pSecDesc
    )
{

    DWORD   i;
    DWORD   numAces;

    if (!IsValidSecurityDescriptor(pSecDesc)) {
        printf("FAILURE:  SECURITY DESCRIPTOR IS INVALID\n");
    }

    printf("[ADT]:Security Descriptor Received\n");
    printf("\tSECURITY_DESCRIPTOR HEADER:\n");
    printf("\tRevision: %d\n", pSecDesc->Revision);
    printf("\tSbz1:     0x%x\n", pSecDesc->Sbz1);
    printf("\tControl:  0x%x\n", pSecDesc->Control);

    //-------------------
    // OWNER SID
    //-------------------
    printf("\n\tOWNER_SID\n");
    printf("\t\tRevision:             %u\n",pSecDesc->Owner->Revision);
    printf("\t\tSubAuthorityCount:    %u\n",pSecDesc->Owner->SubAuthorityCount);

    printf("\t\tIdentifierAuthority:  ");
    for(i=0; i<6; i++) {
        printf("%u ",pSecDesc->Owner->IdentifierAuthority[i]);
    }
    printf("\n");

    printf("\t\tSubAuthority:         ");
    for(i=0; i<pSecDesc->Group->SubAuthorityCount; i++) {
        printf("0x%x ",pSecDesc->Owner->SubAuthority[i]);
    }
    printf("\n");

    //-------------------
    // GROUP SID
    //-------------------
    printf("\n\tGROUP_SID\n");
    printf("\t\tRevision:             %u\n",pSecDesc->Group->Revision);
    printf("\t\tSubAuthorityCount:    %u\n",pSecDesc->Group->SubAuthorityCount);

    printf("\t\tIdentifierAuthority:  ");
    for(i=0; i<6; i++) {
        printf("%u ",pSecDesc->Group->IdentifierAuthority[i]);
    }
    printf("\n");

    printf("\t\tSubAuthority:         ");
    for(i=0; i<pSecDesc->Group->SubAuthorityCount; i++) {
        printf("0x%x ",pSecDesc->Group->SubAuthority[i]);
    }
    printf("\n");

    if (pSecDesc->Sacl != NULL) {
        printf("\n\tSYSTEM_ACL\n");
        printf("\t\tRevision:         %d\n",pSecDesc->Sacl->AclRevision);
        printf("\t\tSbz1:             %d\n",pSecDesc->Sacl->Sbz1);
        printf("\t\tAclSize:          %d\n",pSecDesc->Sacl->AclSize);
        printf("\t\tACE:              %u\n",(unsigned short)pSecDesc->Sacl->Dummy1[0]);
    }
    else {
        printf("\n\tSYSTEM_ACL = NULL\n");
    }

    if (pSecDesc->Dacl != NULL) {
        printf("\n\tDISCRETIONARY_ACL\n");
        printf("\t\tRevision:         %d\n",pSecDesc->Dacl->AclRevision);
        printf("\t\tSbz1:             %d\n",pSecDesc->Dacl->Sbz1);
        printf("\t\tAclSize:          %d\n",pSecDesc->Dacl->AclSize);

        numAces = pSecDesc->Dacl->AclSize - 4;

        for (i=0; i<numAces; i++) {
            //
            // NOTE:  I couldn't get this to print out the right value in DOS16.
            //  So I gave up.  It puts the 04 into the AL register and then
            //  clears the AH register, then pushes AX (both parts).  But when
            //  it prints, it only prints 0.
            //
            printf("\t\tACE%u:             %u\n",i,(unsigned short)pSecDesc->Dacl->Dummy1[i]);
        }
    }
    else {
        printf("\n\tDISCRETIONARY_ACL = NULL\n");
    }
}


BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   i;

    //
    // ScConvertToUnicode allocates storage for each string. 
    // We will rely on process termination to free the memory.
    //
    for(i=0; i<argc; i++) {

        if(!ConvertToUnicode( (LPWSTR *)&(argv[i]), argv[i])) {
            printf("Couldn't convert argv[%d] to unicode\n",i);
            return(FALSE);
        }


    }
    return(TRUE);
}

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    ) 

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to 
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.


Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = (strlen(AnsiIn)+1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (UINT)bufSize);

    if (*UnicodeOut == NULL) {
        printf("ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlAnsiStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                (BOOLEAN)FALSE);    // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        printf("ScConvertToUnicode:RtlAnsiStringToUnicodeString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    //
    // Fill in the pointer location with the unicode string buffer pointer.
    //
    *UnicodeOut = unicodeString.Buffer;

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\client\srvstub.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    SrvStub.C

Abstract:

    These are the server service API RPC client stubs.

Author:

    Dan Lafferty    (danl)  06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     Danl
        Created
    07-Jun-1991 JohnRo
        Added downlevel support for NetServer APIs.
        Added NET_API_FUNCTION where necessary.
    15-Jul-1991 RFirth
        Integrated RxNetShare routines into NetShare stubs
    24-Jul-1991 JohnRo
        Implement downlevel NetConnectionEnum.  Try using <netrpc.h> macros.
    25-Jul-1991 JohnRo
        Quiet DLL stub debug output.  Use NetRpc.h macros for NetServer APIs.
    06-Sep-1991 JohnRo
        Downlevel NetFile APIs.
    25-Sep-1991 JohnRo
        Use NetRpc.h macros for all other APIs, to quiet normal debug output.
    07-Oct-1991 JohnRo
        RAID 3210: "NET FILE 0" causes assertion.  (Was bug in NetFileGetInfo
        DLL stub.)
    16-Oct-1991 JohnRo
        Implement remote NetSession APIs.  Changed LPSTR to LPTSTR.
    07-Nov-1991 JohnRo
        RAID 4186: assert in RxNetShareAdd and other DLL stub problems.
    12-Nov-1991 JohnRo
        APIs in this file need SERVICE_SERVER started to run locally.
    04-Dec-1991 JohnRo
        Change RxNetServerSetInfo() to new-style interface.
        Fixed bug in calling RxNetShareSetInfo().
    09-May-1992 rfirth
        Resurrect NetStatisticsGet as NetServerStatisticsGet
    5-Aug-1992 JohnsonA
        Added new share info level 502 to enable passing of security
        descriptors.
    08-Sep-1992 JohnRo
        Fix NET_API_FUNCTION references.
--*/

//
// INCLUDES
//

#include <nt.h>         // DbgPrint prototype

#include <ntrtl.h>      // DbgPrint

#include <rpc.h>        // DataTypes and runtime APIs

#include <srvsvc.h>     // generated by the MIDL complier
#include <rpcutil.h>    // GENERIC_ENUM_STRUCT
#include <lmcons.h>     // NET_API_STATUS
#include <debuglib.h>   // (needed by netrpc.h)
#include <lmsvc.h>      // (needed by netrpc.h)
#include <netdebug.h>   // (needed by netrpc.h)
#include <lmerr.h>      // NetError codes
#include <netlib.h>     // NetpIsServiceStarted().
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include <netrpc.h>     // NET_REMOTE_ macros.
#include <lmremutl.h>   // SUPPORTS_RPC
#include <lmshare.h>    // Required by rxsess.h.
#include <rap.h>        // Needed by <rxserver.h>.
#include <rxconn.h>     // RxNetConnection routines.
#include <rxfile.h>     // RxNetFile routines.
#include <rxremutl.h>   // RxNetRemoteTOD
#include <rxserver.h>   // RxNetServer routines.
#include <rxsess.h>     // RxNetSession routines.
#include <rxshare.h>    // RxNetShare routines
#include <icanon.h>     // NetpIsRemote
#include <netstats.h>   // NetServerStatisticsGet private prototype
#include <rxstats.h>    // RxNetStatisticsGet (down-level)
#include <netcan.h>     // prototypes for Netps canonicalization functions
#include <rxcanon.h>    // prototypes for down-level canonicalization functions
#include <tstr.h>
#include "cscp.h"

#define SET_ERROR_PARAMETER(a) \
    if ( ARGUMENT_PRESENT( parm_err ) ) { *parm_err = a; }


NET_API_STATUS NET_API_FUNCTION
NetCharDevControl (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  devname,
    IN  DWORD   opcode
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetCharDevControl.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    devname --A pointer to the ASCIIZ string containing the name of
        the device to control

    opcode --Control opcode: currently defined are:
        CHARDEV_CLOSE for the device closed.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrCharDevControl (
                        (LPWSTR)servername,
                        (LPWSTR)devname,
                        opcode);

    NET_REMOTE_RPC_FAILED(
            "NetCharDevControl",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

    apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetCharDevControl


NET_API_STATUS NET_API_FUNCTION
NetCharDevEnum (
    IN  LPCWSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetCharDevEnum.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 0 and 1 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

    prefmaxlen --Prefered maximum length of returned data (in 8-bit
        bytes). 0xffffffff specifies no limit.

    entriesread --On return the actual enumerated element count is
        located in the DWORD pointed to by entriesread.

    totalentries --On return the total entries available to be
        enumerated is located in the DWORD pointed to by
        totalentries.

    resumehandle --On return, a resume handle is stored in the DWORD
        pointed to by resumehandle, and is used to continue an
        existing character device search. The handle should be zero
        on the first call and left unchanged for subsequent calls. If
        resumehandle is NULL, then no resume handle is stored..

Return Value:



--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;

    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrCharDevEnum (
                (LPWSTR)servername,
                (LPCHARDEV_ENUM_STRUCT)&infoStruct,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr         = (LPBYTE)genericInfoContainer.Buffer;
            *entriesread    = genericInfoContainer.EntriesRead;
        } else {
            *bufptr = NULL;
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED(
            "NetCharDevEnum",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

    apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetCharDevEnum


NET_API_STATUS NET_API_FUNCTION
NetCharDevGetInfo (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  devname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetCharDevGetInfo.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    devname --A pointer to the ASCIIZ string containing the name of
        the device to return information on.

    level --Level of information required. 0 and 1 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:



--*/

{
    NET_API_STATUS              apiStatus;


    *bufptr = NULL;         // Must be NULL so RPC knows to till it in.

    NET_REMOTE_TRY_RPC

        apiStatus = NetrCharDevGetInfo (
            (LPWSTR)servername,
            (LPWSTR)devname,
            level,
            (LPCHARDEV_INFO) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetCharDevGetInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

    apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetCharDevGetInfo


NET_API_STATUS NET_API_FUNCTION
NetCharDevQEnum (
    IN  LPCWSTR      servername,
    IN  LPCWSTR      username,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetCharDevQEnum.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    username --A pointer to an ASCIIZ string containing an a username
        for the active queues of interest. This parameter is
        optional, if NULL then all device queues  are enumerated.

    level --Level of information required. 0 and 1 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

    prefmaxlen --Prefered maximum length of returned data (in 8-bit
        bytes). 0xffffffff specifies no limit.

    entriesread --On return the actual enumerated element count is
        located in the DWORD pointed to by entriesread.

    totalentries --On return the total entries available to be
        enumerated is located in the DWORD pointed to by
        totalentries.

    resumehandle --On return, a resume handle is stored in the DWORD
        pointed to by resumehandle, and is used to continue an
        existing character device queue search. The handle should be

Return Value:


--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;


    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrCharDevQEnum (
                (LPWSTR)servername,
                (LPWSTR)username,
                (LPCHARDEVQ_ENUM_STRUCT) &infoStruct,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr         = (LPBYTE)genericInfoContainer.Buffer;
            *entriesread    = genericInfoContainer.EntriesRead;
        } else {
            *bufptr = NULL;
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED(
            "NetCharDevQEnum",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

    apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetCharDevQEnum


NET_API_STATUS NET_API_FUNCTION
NetCharDevQGetInfo (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  queuename,
    IN  LPCWSTR  username,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetCharDevQGetInfo.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    queuename --A pointer to an ASCIIZ string containing the name of
        the queue to return information on.

    username --A pointer to an ASCIIZ string containing the username
        of the a user whose job of of interest for the cq1_numahead
        count.

    level --Level of information required. 0 and 1 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *bufptr = NULL;         // Must be NULL so RPC knows to till it in.

    NET_REMOTE_TRY_RPC

        apiStatus = NetrCharDevQGetInfo (
            (LPWSTR)servername,
            (LPWSTR)queuename,
            (LPWSTR)username,
            level,
            (LPCHARDEVQ_INFO) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetCharDevQGetInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

    apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetCharDevQGetInfo


NET_API_STATUS NET_API_FUNCTION
NetCharDevQPurge (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  queuename
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetCharDevQPurge.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    queuename --A pointer to an ASCIIZ string containing the name of
        the queue to be purged.

Return Value:


--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrCharDevQPurge (
                        (LPWSTR)servername,
                        (LPWSTR)queuename);

    NET_REMOTE_RPC_FAILED(
            "NetCharDevQPurge",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

    apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetCharDevQPurge


NET_API_STATUS NET_API_FUNCTION
NetCharDevQPurgeSelf (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  queuename,
    IN  LPCWSTR  computername
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetCharDevQPurgeSelf.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    queuename --A pointer to an ASCIIZ string containing the name of
        the queue to be purged of pending entries from the specified
        computer.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrCharDevQPurgeSelf (
                        (LPWSTR)servername,
                        (LPWSTR)queuename,
                        (LPWSTR)computername);

    NET_REMOTE_RPC_FAILED(
            "NetCharDevQPurgeSelf",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

    apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetCharDevQPurgeSelf


NET_API_STATUS NET_API_FUNCTION
NetCharDevQSetInfo (
    IN  LPCWSTR  servername,
    IN  LPCWSTR  queuename,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetCharDevQSetInfo.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    queuename --A pointer to an ASCIIZ string containing the name of
        the queue to set information on.

    level --Level of information to set.

    buf --A pointer to a buffer containing the chardev information.
        If parmnum is non zero then the buffer contains only the
        appropriate data for the specific element. If parmnum is
        zero, then the buffer contains the whole chardev information
        structure.

    parm_err --Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is
        returned. If NULL the parameter is not returned on error.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrCharDevQSetInfo (
            (LPWSTR)servername,
            (LPWSTR)queuename,
            level,
            (LPCHARDEVQ_INFO) &buf,
            parm_err);

    NET_REMOTE_RPC_FAILED(
            "NetCharDevQSetInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

    apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetCharDevQSetInfo


NET_API_STATUS NET_API_FUNCTION
NetConnectionEnum (
    IN  LPTSTR      servername,
    IN  LPTSTR      qualifier,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetConnectionEnum.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    qualifier --A pointer to an ASCIIZ string containing a sharename
        or computername for the connections of interest. If it is a
        sharename, then all the connections made to that sharename
        are listed. If it is a computername (i.e. it starts with two
        backslash characters), then NetConnectionEnum lists all
        connections made from that computer to the server specified.

    level --Level of information required. 0 and 1 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

    prefmaxlen --Prefered maximum length of returned data (in 8-bit
        bytes). 0xffffffff specifies no limit.

    entriesread --On return the actual enumerated element count is
        located in the DWORD pointed to by entriesread.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;

    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrConnectionEnum (
                servername,
                qualifier,
                (LPCONNECT_ENUM_STRUCT)&infoStruct,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr         = (LPBYTE)genericInfoContainer.Buffer;
            *entriesread    = genericInfoContainer.EntriesRead;
        } else {
            *bufptr = NULL;
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED(
            "NetConnectionEnum",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Try call to downlevel.
        //
        apiStatus = RxNetConnectionEnum(
                servername,
                qualifier,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle
                );

    NET_REMOTE_END

    return(apiStatus);

} // NetConnectionEnum


NET_API_STATUS NET_API_FUNCTION
NetFileClose (
    IN LPTSTR   servername,
    IN DWORD    fileid
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetFileClose.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    fileid --The fileid of the opened resource instance to be closed.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrFileClose (
            servername,
            fileid);

    NET_REMOTE_RPC_FAILED(
            "NetFileClose",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = RxNetFileClose (
            servername,
            fileid);

    NET_REMOTE_END

    return(apiStatus);
}


NET_API_STATUS NET_API_FUNCTION
NetFileEnum (
    IN  LPTSTR         servername,
    IN  LPTSTR         basepath,
    IN  LPTSTR         username,
    IN  DWORD          level,
    OUT LPBYTE         *bufptr,
    IN  DWORD          prefmaxlen,
    OUT LPDWORD        entriesread,
    OUT LPDWORD        totalentries,
    IN OUT PDWORD_PTR  resume_handle
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetFileEnum.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    basepath --A pointer to an ASCIIZ string containing a qualifier
        for the returned information. If NULL then all open resources
        are enumerated, else only resources which have basepath as a
        prefix are enumerated.

    username --A pointer to an ASCIIZ string that specifies the name
        of the user. If not NULL, username serves as a qualifier to
        the ennumeration. The files returned are limited to those
        that have usernames matching the qualifier. If username is
        NULL, no username qualifier is used.

    level --Level of information required. 2 and 3 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

    prefmaxlen --Prefered maximum length of returned data (in 8-bit
        bytes). 0xffffffff specifies no limit.

    entriesread --On return the actual enumerated element count is
        located in the DWORD pointed to by entriesread.

    totalentries --On return the total entries available to be
        enumerated is located in the DWORD pointed to by
        totalentries.

    resumehandle --On return, a resume handle is stored in the DWORD
        pointed to by resumehandle, and is used to continue an
        existing file search. The handle should be zero on the first
        call and left unchanged for subsequent calls. If resumehandle
        is NULL, then no resume handle is stored..

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;


    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        //
        // NetrFileEnum's resume_handle parm is a true index that will remain
        // 32 bits wide for on-the-wire compatibility.  Thus, the cast to
        // (PDWORD) here works.
        //

        apiStatus = NetrFileEnum (
                servername,
                basepath,
                username,
                (LPFILE_ENUM_STRUCT) &infoStruct,
                prefmaxlen,
                totalentries,
                (PDWORD)resume_handle);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr         = (LPBYTE)genericInfoContainer.Buffer;
            *entriesread    = genericInfoContainer.EntriesRead;
        } else {
            *bufptr = NULL;
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED(
            "NetFileEnum",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = RxNetFileEnum(
                servername,
                basepath,
                username,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle);

    NET_REMOTE_END

    return(apiStatus);

} // NetFileEnum


NET_API_STATUS NET_API_FUNCTION
NetFileGetInfo (
    IN  LPTSTR  servername,
    IN  DWORD   fileid,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetFileGetInfo.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    fileid --The fileid of the open resource to return information
        on. The fileid value must be that returned in a previous
        enumeration call.

    level --Level of information required. 2 and 3 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *bufptr = NULL;         // Must be NULL so RPC knows to fill it in.

    NET_REMOTE_TRY_RPC

        apiStatus = NetrFileGetInfo (
                servername,
                fileid,
                level,
                (LPFILE_INFO) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetFileGetInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        apiStatus = RxNetFileGetInfo (
                servername,
                fileid,
                level,
                bufptr);

    NET_REMOTE_END

    return(apiStatus);

} // NetFileGetInfo


NET_API_STATUS NET_API_FUNCTION
NetSessionDel (
    IN  LPTSTR  servername,
    IN  LPTSTR  clientname,
    IN  LPTSTR  username
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetSessionDel.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    clientname --A pointer to an ASCIIZ string containing the
        computername of the client to disconnect.

    username --A pointer to an ASCIIZ string containing the name of
        the user whose session is to be terminated. A NULL indicates
        that all users' sessions from the computername specified are
        to be terminated.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrSessionDel (
                        servername,
                        clientname,
                        username);

    NET_REMOTE_RPC_FAILED("NetSessionDel", servername, apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER )

        //
        // Call downlevel version of the API.
        //

        apiStatus = RxNetSessionDel (
                servername,
                clientname,
                username);

    NET_REMOTE_END

    return(apiStatus);

} // NetSessionDel


NET_API_STATUS NET_API_FUNCTION
NetSessionEnum (
    IN      LPTSTR      servername,
    IN      LPTSTR      clientname,
    IN      LPTSTR      username,
    IN      DWORD       level,
    OUT     LPBYTE      *bufptr,
    IN      DWORD       prefmaxlen,
    OUT     LPDWORD     entriesread,
    OUT     LPDWORD     totalentries,
    IN OUT  LPDWORD     resume_handle
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetSessionEnum.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    clientname --A pointer to an ASCIIZ string containing the name of
        the computer session for which information is to be returned.
        A NULL pointer or string specifies that all computer sessions
        on the server are to be ennumerated.

    username --A pointer to an ASCIIZ string containing the name of
        the the user for which to ennumerate the sessions. A NULL
        pointer or string specifies that sessions for all users are
        to be ennumerated.

    level --Level of information required. 0, 1, 2 and 10 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

    prefmaxlen --Prefered maximum length of returned data (in 8-bit
        bytes). 0xffffffff specifies no limit.

    entriesread --On return the actual enumerated element count is
        located in the DWORD pointed to by entriesread.

    totalentries --On return the total entries available to be
        enumerated is located in the DWORD pointed to by
        totalentries.

    resumehandle --On return, a resume handle is stored in the DWORD
        pointed to by resumehandle, and is used to continue an
        existing session search. The handle should be zero on the
        first call and left unchanged for subsequent calls. If
        resumehandle is NULL, then no resume handle is stored.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;

    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrSessionEnum (
                servername,
                clientname,
                username,
                (PSESSION_ENUM_STRUCT) &infoStruct,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr         = (LPBYTE)genericInfoContainer.Buffer;
            *entriesread    = genericInfoContainer.EntriesRead;
        } else {
            *bufptr = NULL;
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED("NetSessionEnum", servername, apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER )

        //
        // Call downlevel version of the API.
        //

        apiStatus = RxNetSessionEnum (
                servername,
                clientname,
                username,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle);

    NET_REMOTE_END

    return(apiStatus);

} // NetSessionEnum


NET_API_STATUS NET_API_FUNCTION
NetSessionGetInfo (
    IN      LPTSTR      servername,
    IN      LPTSTR      clientname,
    IN      LPTSTR      username,
    IN      DWORD       level,
    OUT     LPBYTE      *bufptr
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetSessionEnum.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    clientname --A pointer to an ASCIIZ string containing the name of
        the computer session for which information is to be returned.
        This field cannot be NULL.

    username --A pointer to an ASCIIZ string containing the name of
        the the user for which to ennumerate the sessions.  This field
        cannot be NULL.

    level --Level of information required. 0, 1, 2 and 10 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;
    DWORD                       totalentries;

    if ( clientname == NULL || username == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrSessionEnum (
                servername,
                clientname,
                username,
                (PSESSION_ENUM_STRUCT) &infoStruct,
                (DWORD)-1,
                &totalentries,
                NULL);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr = (LPBYTE)genericInfoContainer.Buffer;
        } else {
            *bufptr = NULL;
            if ( apiStatus == NO_ERROR ) {
                return NERR_ClientNameNotFound;
            }
        }

    NET_REMOTE_RPC_FAILED("NetSessionGetInfo", servername, apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER )

        //
        // Call downlevel version of the API.
        //

        apiStatus = RxNetSessionGetInfo (
                servername,
                clientname,
                username,
                level,
                bufptr);

    NET_REMOTE_END

    return(apiStatus);

} // NetSessionGetInfo


NET_API_STATUS NET_API_FUNCTION
NetShareAdd (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetShareAdd.  Only levels 2 and 502
    are allowed.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information provided. Must be 2.

    buf --A pointer to a buffer containing the share information
        structure.

    parm_err --Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is
        returned. If NULL the parameter is not returned on error.

Return Value:



--*/

{
    NET_API_STATUS              apiStatus;
    NTSTATUS                    status;
    ULONG                       SDLength = 0;
    ULONG                       oldSDLength;
    PSECURITY_DESCRIPTOR        securityDescriptor = NULL;
    PSECURITY_DESCRIPTOR        oldSecurityDescriptor = NULL;


    //
    // do the parameter validation here - this way we only need do it once and
    // in a centralized place
    //

    if (level != 2 && level != 502) {
        return ERROR_INVALID_LEVEL;
    }

    NET_REMOTE_TRY_RPC

        if ( level == 502 ) {

            PSHARE_INFO_502 shi502 = (LPSHARE_INFO_502) buf;

            //
            // Save this. We need to restore this later.
            //

            oldSecurityDescriptor = shi502->shi502_security_descriptor;
            oldSDLength = shi502->shi502_reserved;

            if ( oldSecurityDescriptor != NULL ) {

                if ( !RtlValidSecurityDescriptor( oldSecurityDescriptor) ) {
                    SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
                    return ERROR_INVALID_PARAMETER;
                }

                //
                // Make a self relative security descriptor for use in the
                // RPC call..
                //

                status = RtlMakeSelfRelativeSD(
                               oldSecurityDescriptor,
                               NULL,
                               &SDLength
                               );

                if (status != STATUS_BUFFER_TOO_SMALL) {

                    SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
                    return(ERROR_INVALID_PARAMETER);

                } else {

                    securityDescriptor = MIDL_user_allocate( SDLength );

                    if ( securityDescriptor == NULL) {

                        return ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        //
                        // make an appropriate self-relative security descriptor
                        //

                        status = RtlMakeSelfRelativeSD(
                                       oldSecurityDescriptor,
                                       (PSECURITY_DESCRIPTOR) securityDescriptor,
                                       &SDLength
                                       );

                        if ( !NT_SUCCESS(status) ) {
                            MIDL_user_free( securityDescriptor );
                            SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
                            return(ERROR_INVALID_PARAMETER);
                        }

                        shi502->shi502_security_descriptor = securityDescriptor;
                        shi502->shi502_reserved = SDLength;

                    }
                }

            } else {

                shi502->shi502_reserved = 0;

            }
        }

        apiStatus = NetrShareAdd (
                        servername,
                        level,
                        (LPSHARE_INFO) &buf,
                        parm_err);

        if ( securityDescriptor != NULL ) {

            //
            // restore old values
            //

            PSHARE_INFO_502 shi502 = (LPSHARE_INFO_502) buf;
            shi502->shi502_security_descriptor = oldSecurityDescriptor;
            shi502->shi502_reserved = oldSDLength;
            MIDL_user_free( securityDescriptor );
        }

    NET_REMOTE_RPC_FAILED(
            "NetShareAdd",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Call downlevel server.
        //

        if ( level != 502 ) {
            apiStatus = RxNetShareAdd(
                            servername,
                            2,
                            buf,
                            parm_err
                            );
        } else {
            apiStatus = ERROR_NOT_SUPPORTED;
        }

    NET_REMOTE_END

    return(apiStatus);

} // NetShareAdd


NET_API_STATUS NET_API_FUNCTION
NetShareCheck   (
    IN  LPTSTR  servername,
    IN  LPTSTR  device,
    OUT LPDWORD type
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetShareCheck

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    device --A pointer to an ASCIIZ string containing the name of the
        device to check for shared access.

    type --On return the address pointed to by the type parameter
        contains the type of share the device is offered with. This
        field is only set if success was returned.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;


    if (!(device && *device) || !type) {
        return ERROR_INVALID_PARAMETER;
    }

    NET_REMOTE_TRY_RPC

        apiStatus = NetrShareCheck (
                        servername,
                        device,
                        type);

    NET_REMOTE_RPC_FAILED(
            "NetShareCheck",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Call downlevel server.
        //

        apiStatus = RxNetShareCheck(servername, device, type);

    NET_REMOTE_END

    return(apiStatus);

} // NetShareCheck


NET_API_STATUS NET_API_FUNCTION
NetShareDel     (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   reserved
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetShareDel.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    netname --A pointer to an ASCIIZ string containing the netname of
        the share to delete.

    reserved --Reserved, must be zero.

Return Value:

--*/

{
    NET_API_STATUS apiStatus;
    BOOL committingIpcDelete = FALSE;
    SHARE_DEL_HANDLE handle;
    BOOL tryDownLevel = FALSE;

    if ( !netname || (*netname == 0) || reserved ) {
        return ERROR_INVALID_PARAMETER;
    }

    RpcTryExcept {

        if ( STRICMP( netname, TEXT("IPC$") ) != 0 ) {

            apiStatus = NetrShareDel(
                            servername,
                            netname,
                            reserved
                            );

        } else {

            apiStatus = NetrShareDelStart(
                            servername,
                            netname,
                            reserved,
                            &handle
                            );

            if ( apiStatus == NERR_Success ) {
                committingIpcDelete = TRUE;
                apiStatus = NetrShareDelCommit( &handle );
            }

        }

    } RpcExcept ( 1 ) {

        RPC_STATUS rpcStatus;

        rpcStatus = RpcExceptionCode( );

        if ( committingIpcDelete && (rpcStatus == RPC_S_CALL_FAILED) ) {

            apiStatus = NERR_Success;

        } else {

            apiStatus = NetpHandleRpcFailure(
                            "NetShareDel",
                            rpcStatus,
                            servername,
                            SERVICE_SERVER,
                            NET_REMOTE_FLAG_NORMAL,
                            &tryDownLevel
                            );

        }

    }

    RpcEndExcept

    if (apiStatus == NERR_TryDownLevel) {
        tryDownLevel = TRUE;
    }

    if ( tryDownLevel ) {

        //
        // Call downlevel server.
        //
        // note: push value 0 instead of real reserved
        //

        apiStatus = RxNetShareDel(servername, netname, 0);

    }

    return apiStatus;

} // NetShareDel


NET_API_STATUS NET_API_FUNCTION
NetShareDelSticky (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   reserved
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetShareDelSticky.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    netname --A pointer to an ASCIIZ string containing the netname of
        the share to delete.

    reserved --Reserved, must be zero.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;


    if (!(netname && *netname) || reserved) {
        return ERROR_INVALID_PARAMETER;
    }

    NET_REMOTE_TRY_RPC

        apiStatus = NetrShareDelSticky (
                        servername,
                        netname,
                        reserved);

    NET_REMOTE_RPC_FAILED(
            "NetShareDelSticky",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // No downlevel call.
        //

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetShareDelSticky


NET_API_STATUS NET_API_FUNCTION
NetShareEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetShareEnum

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 0, 1 and 2 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

    prefmaxlen --Prefered maximum length of returned data (in 8-bit
        bytes). 0xffffffff specifies no limit.

    entriesread --On return the actual enumerated element count is
        located in the DWORD pointed to by entriesread.

    totalentries --On return the total entries available to be
        enumerated is located in the DWORD pointed to by
        totalentries.

    resumehandle --On return, a resume handle is stored in the DWORD
        pointed to by resumehandle, and is used to continue an
        existing share search. The handle should be zero on the first
        call and left unchanged for subsequent calls. If resumehandle
        is NULL, then no resume handle is stored..

Return Value:


--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;

    //
    // check the caller's parameters
    //

    *totalentries = *entriesread = 0;
    *bufptr = NULL;

    if ( (level > 2) && (level != 501) && (level != 502) ) {
        return ERROR_INVALID_LEVEL;
    }

    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrShareEnum (
                servername,
                (LPSHARE_ENUM_STRUCT) &infoStruct,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr         = (LPBYTE)genericInfoContainer.Buffer;
            *entriesread    = genericInfoContainer.EntriesRead;

        } else {
            *bufptr = NULL;
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED(
            "NetShareEnum",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Call downlevel server.
        //
        if ( level != 502 && level != 501 ) {
            apiStatus = RxNetShareEnum(servername, level, bufptr,
                    prefmaxlen, entriesread, totalentries, resume_handle);
        } else {
            apiStatus = ERROR_NOT_SUPPORTED;
        }

    NET_REMOTE_END

    //
    // If we haven't gotten anything, and the server is offline,
    //  return the offline share state
    //
    if( ( *bufptr == NULL || *entriesread == 0 ) &&
        ARGUMENT_PRESENT( servername ) &&
        CSCIsServerOffline( servername ) ) {

        NET_API_STATUS cscStatus;

        cscStatus = CSCNetShareEnum(
                                servername,
                                level,
                                bufptr,
                                entriesread,
                                totalentries
                                );

        if( cscStatus == NERR_Success ) {
            apiStatus = cscStatus;
        }
    }

    return(apiStatus);

} // NetShareEnum

NET_API_STATUS NET_API_FUNCTION
NetShareEnumSticky (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetShareEnumSticky

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 0, 1 and 2 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

    prefmaxlen --Prefered maximum length of returned data (in 8-bit
        bytes). 0xffffffff specifies no limit.

    entriesread --On return the actual enumerated element count is
        located in the DWORD pointed to by entriesread.

    totalentries --On return the total entries available to be
        enumerated is located in the DWORD pointed to by
        totalentries.

    resumehandle --On return, a resume handle is stored in the DWORD
        pointed to by resumehandle, and is used to continue an
        existing share search. The handle should be zero on the first
        call and left unchanged for subsequent calls. If resumehandle
        is NULL, then no resume handle is stored..

Return Value:


--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;


    //
    // check the caller's parameters
    //

    *totalentries = *entriesread = 0;
    *bufptr = NULL;

    if ( (level > 2) && (level != 501) && (level != 502) ) {
        return ERROR_INVALID_LEVEL;
    }

    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrShareEnumSticky (
                servername,
                (LPSHARE_ENUM_STRUCT) &infoStruct,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr         = (LPBYTE)genericInfoContainer.Buffer;
            *entriesread    = genericInfoContainer.EntriesRead;
        } else {
            *bufptr = NULL;
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED(
            "NetShareEnum",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // No downlevel support
        //

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetShareEnumSticky


NET_API_STATUS NET_API_FUNCTION
NetShareGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    NetShareGetInfo

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    netname --A pointer to an ASCIIZ string containing the netname of
        the share to return information on.

    level --Level of information required. 0, 1 and 2 are valid.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    if (bufptr == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *bufptr = NULL;         // Must be NULL so RPC knows to fill it in.

    if ( (level > 2)     &&
         (level != 501)  &&
         (level != 502)  &&
         (level != 1005) ) {

        return ERROR_INVALID_LEVEL;
    }

    if (!(netname && *netname)) {
        return ERROR_INVALID_PARAMETER;
    }

    NET_REMOTE_TRY_RPC

        apiStatus = NetrShareGetInfo (
            servername,
            netname,
            level,
            (LPSHARE_INFO) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetShareGetInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Call downlevel server.
        //

        if( level == 0 || level == 1 || level == 2 ) {
            apiStatus = RxNetShareGetInfo(servername, netname, level, bufptr);
        } else {
            apiStatus = ERROR_NOT_SUPPORTED;
        }

    NET_REMOTE_END

    if( *bufptr == NULL &&
        ARGUMENT_PRESENT( servername ) &&
        ARGUMENT_PRESENT( netname ) &&
        CSCIsServerOffline( servername) ) {

        NET_API_STATUS cscStatus;

        cscStatus = CSCNetShareGetInfo ( servername, netname, level, bufptr );

        if( cscStatus == NERR_Success ) {
            apiStatus = cscStatus;
        }
    }
    return(apiStatus);

} // NetShareGetInfo


NET_API_STATUS NET_API_FUNCTION
NetShareSetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetShareSetInfo

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    netname --A pointer to an ASCIIZ string containing the netname of
        the share to set information on.

    level --Level of information to set.

    buf --A pointer to a buffer containing the share information. If
        parmnum is non zero then the buffer contains only the
        appropriate data for the specific element.

    parm_err --Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is
        returned. If NULL the parameter is not returned on error.

Return Value:

--*/

{

    NET_API_STATUS              apiStatus;
    NTSTATUS                    status;
    ULONG                       sdLength = 0;
    ULONG                       oldSdLength;
    PSECURITY_DESCRIPTOR        securityDescriptor = NULL;
    PSECURITY_DESCRIPTOR        oldSecurityDescriptor = NULL;
    LPSHARE_INFO_1501           shi1501 = NULL;

    NET_REMOTE_TRY_RPC

        //
        // If the info level can change the security descriptor, get
        // the necessary information.
        //
        // *** Note that this code expects the layout of the reserved
        //     and security_descriptor fields in the 502 struct to
        //     match the 1501 struct.
        //

        if ( level == 502 ) {

            if (buf == NULL) {

                SET_ERROR_PARAMETER(PARM_ERROR_UNKNOWN);
                return ERROR_INVALID_PARAMETER;
            }

            shi1501 =
                (LPSHARE_INFO_1501)&((LPSHARE_INFO_502)buf)->shi502_reserved;

        } else if ( level == SHARE_FILE_SD_INFOLEVEL ) {

            shi1501 = (LPSHARE_INFO_1501)buf;

        }

        if ( shi1501 != NULL ) {

            oldSdLength = shi1501->shi1501_reserved;
            oldSecurityDescriptor = shi1501->shi1501_security_descriptor;

            if ( oldSecurityDescriptor != NULL ) {

                //
                // Make a self relative security descriptor for use in the
                // RPC call.
                //

                if ( !RtlValidSecurityDescriptor( oldSecurityDescriptor) ) {
                    SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
                    return ERROR_INVALID_PARAMETER;
                }

                status = RtlMakeSelfRelativeSD(
                               oldSecurityDescriptor,
                               NULL,
                               &sdLength
                               );

                if ( status != STATUS_BUFFER_TOO_SMALL ) {
                    SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
                    return ERROR_INVALID_PARAMETER;

                } else {

                    securityDescriptor = MIDL_user_allocate( sdLength );

                    if ( securityDescriptor == NULL) {
                        return ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        //
                        // Make an appropriate self-relative security
                        // descriptor.
                        //

                        status = RtlMakeSelfRelativeSD(
                                       oldSecurityDescriptor,
                                       securityDescriptor,
                                       &sdLength
                                       );

                        if ( !NT_SUCCESS(status) ) {
                            MIDL_user_free( securityDescriptor );
                            SET_ERROR_PARAMETER( SHARE_FILE_SD_PARMNUM );
                            return ERROR_INVALID_PARAMETER;
                        }

                        shi1501->shi1501_reserved = sdLength;
                        shi1501->shi1501_security_descriptor =
                                                    securityDescriptor;

                    }

                }

            } else {

                shi1501->shi1501_reserved = 0;

            }
        }

        apiStatus = NetrShareSetInfo(
                                servername,
                                netname,
                                level,
                                (LPSHARE_INFO) &buf,
                                parm_err);

        if ( shi1501 != NULL ) {

            //
            // restore old values
            //

            shi1501->shi1501_reserved = oldSdLength;
            shi1501->shi1501_security_descriptor = oldSecurityDescriptor;

            MIDL_user_free( securityDescriptor );

        }


    NET_REMOTE_RPC_FAILED(
            "NetShareSetInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Call downlevel server.
        //

        if ( level != 502 &&
             level != 501 &&
             level != SHARE_FILE_SD_INFOLEVEL &&
             level != 1005 ) {

            apiStatus = RxNetShareSetInfo(
                    servername,
                    netname,
                    level,
                    buf,
                    parm_err);
        } else {
            apiStatus = ERROR_NOT_SUPPORTED;
        }

    NET_REMOTE_END

    return(apiStatus);

} // NetShareSetInfo


NET_API_STATUS NET_API_FUNCTION
NetServerDiskEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetServerDiskEnum.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 0 is the only valid level.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

    prefmaxlen --Prefered maximum length of returned data (in 8-bit
        bytes). 0xffffffff specifies no limit.

    entriesread --On return the actual enumerated element count is
        located in the DWORD pointed to by entriesread.

    totalentries --On return the total entries available to be
        enumerated is located in the DWORD pointed to by totalentries

    resumehandle --On return, a resume handle is stored in the DWORD
        pointed to by resumehandle, and is used to continue an
        existing server disk search. The handle should be zero on the
        first call and left unchanged for subsequent calls. If
        resumehandle is NULL, then no resume handle is stored..

Return Value:

--*/
{
    NET_API_STATUS              apiStatus;
    DISK_ENUM_CONTAINER         diskEnumContainer;


    diskEnumContainer.Buffer = NULL;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrServerDiskEnum (
                servername,
                level,
                &diskEnumContainer,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (diskEnumContainer.Buffer != NULL) {
            *bufptr = (LPBYTE)diskEnumContainer.Buffer;
        } else {
            *bufptr = NULL;
        }

        if (diskEnumContainer.EntriesRead > 0) {

            //
            // We must subtract out the extra count that we added so
            // that RPC would buffer the extra NUL at the end of the list.
            //

            *entriesread = diskEnumContainer.EntriesRead - 1;

        } else {
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED(
            "NetServerDiskEnum",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Call downlevel version of the API.
        //

        apiStatus = RxNetServerDiskEnum(
                servername,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle);

    NET_REMOTE_END

    return(apiStatus);

} // NetServerDiskEnum


NET_API_STATUS NET_API_FUNCTION
NetServerGetInfo (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServerGetInfo

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 100, 101 and 102 are valid
        for all platforms. 302, 402, 403, 502 are valid for the
        appropriate platform.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *bufptr = NULL;     // Must be NULL so RPC knows to fill it in.

    NET_REMOTE_TRY_RPC

        apiStatus = NetrServerGetInfo (
                servername,
                level,
                (LPSERVER_INFO) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetServerGetInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Call downlevel version of the API.
        //
        apiStatus = RxNetServerGetInfo (
                servername,
                level,
                bufptr);

    NET_REMOTE_END

    return(apiStatus);

} // NetServerGetInfo


NET_API_STATUS NET_API_FUNCTION
NetServerSetInfo (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetServerSetInfo.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information to set.

    buf --A pointer to a buffer containing the server information. If
        parmnum is non zero then the buffer contains only the
        appropriate data for the specific element.

    parm_err --Optional pointer to a DWORD to return the index of the
        first parameter in error when ERROR_INVALID_PARAMETER is
        returned. If NULL the parameter is not returned on error.

Return Value:

--*/
{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrServerSetInfo (
                servername,
                level,
                (LPSERVER_INFO ) &buf,
                parm_err);

    NET_REMOTE_RPC_FAILED(
            "NetServerSetInfo",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // Call downlevel server.
        //

        apiStatus = RxNetServerSetInfo(
                servername,
                level,
                buf,
                parm_err);

    NET_REMOTE_END

    return(apiStatus);

} // NetServerSetInfo


NET_API_STATUS NET_API_FUNCTION
NetServerStatisticsGet (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  DWORD   options,
    OUT LPBYTE  *bufptr
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetStatisticsGet.

Arguments:

    servername --Points to an ASCIIZ string that contains the name of the
        server on which to execute NetStatisticsGet. A NULL pointer or
        NULL string specifies the local computer.

    level --Specifies the level of detail requested; must be 0.

    options --Specifies the options flags.

          Bit(s)            Meaning
          0                 Clear statistics.
          1-31              Reserved; must be 0.

    bufptr --On return a pointer to the returned information is
        returned in the address pointed to by bufptr.

Return Value:

--*/
{
    NET_API_STATUS              apiStatus;

    *bufptr = NULL;     // Must be NULL so RPC knows to fill it in.

    NET_REMOTE_TRY_RPC


        apiStatus = NetrServerStatisticsGet (
                servername,
                SERVICE_SERVER,
                level,
                options,
                (LPSTAT_SERVER_0 *) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetServerStatisticsGet",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // RPC call didn't work - try down-level routine
        //

        apiStatus = RxNetStatisticsGet(
            servername,
            SERVICE_SERVER,
            level,
            options,
            bufptr
            );

    NET_REMOTE_END

    return(apiStatus);

} // NetServerStatisticsGet


NET_API_STATUS NET_API_FUNCTION
NetServerTransportAdd (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  bufptr
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetServerTransportAdd

Arguments:

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrServerTransportAdd (
                servername,
                level,
                (LPSERVER_TRANSPORT_INFO_0) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetServerTransportAdd",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // No downlevel call.
        //

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetServerTransportAdd

NET_API_STATUS NET_API_FUNCTION
NetServerTransportDelEx (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  bufptr
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetServerTransportAdd

Arguments:

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrServerTransportDelEx (
                servername,
                level,
                (LPTRANSPORT_INFO) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetServerTransportDel",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // No downlevel call.
        //

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    // Around the Win2K/NT4 time frame a bug was introduced for TransportDel with
    // level other than 0.  In these cases, the buffer was cast instead of marshalled
    // correctly over RPC.  This means that Level 1 never worked anyway.  To fix this,
    // we added a new RPC interface that supports all the other levels.  However, downlevel
    // servers will not support this interface.  In these cases, we call back with the TRUE
    // level 0 interface to satisfy backwards compatibility
    if( apiStatus == RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        apiStatus = NetServerTransportDel( servername, 0, bufptr );
    }

    return(apiStatus);

} // NetServerTransportDel



NET_API_STATUS NET_API_FUNCTION
NetServerTransportDel (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  bufptr
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetServerTransportAdd

Arguments:

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    if( level == 0 )
    {

        NET_REMOTE_TRY_RPC

            apiStatus = NetrServerTransportDel (
                    servername,
                    level,
                    (LPSERVER_TRANSPORT_INFO_0) bufptr);

        NET_REMOTE_RPC_FAILED(
                "NetServerTransportDel",
                servername,
                apiStatus,
                NET_REMOTE_FLAG_NORMAL,
                SERVICE_SERVER)

            //
            // No downlevel call.
            //

            apiStatus = ERROR_NOT_SUPPORTED;

        NET_REMOTE_END
    }
    else
    {
        // If they want level 1, we need to use the new RPC interface.  See
        // the comment in the TransportDelEx code above
        apiStatus = NetServerTransportDelEx( servername, level, bufptr );
    }

    return(apiStatus);

} // NetServerTransportDel


NET_API_STATUS NET_API_FUNCTION
NetServerTransportEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetServerTransportEnum

Arguments:

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;
    GENERIC_INFO_CONTAINER      genericInfoContainer;
    GENERIC_ENUM_STRUCT         infoStruct;

    genericInfoContainer.Buffer = NULL;
    genericInfoContainer.EntriesRead = 0;

    infoStruct.Container = &genericInfoContainer;
    infoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrServerTransportEnum (
                servername,
                (LPSERVER_XPORT_ENUM_STRUCT) &infoStruct,
                prefmaxlen,
                totalentries,
                resume_handle);

        if (genericInfoContainer.Buffer != NULL) {
            *bufptr         = (LPBYTE)genericInfoContainer.Buffer;
            *entriesread    = genericInfoContainer.EntriesRead;
        } else {
            *bufptr = NULL;
            *entriesread = 0;
        }

    NET_REMOTE_RPC_FAILED(
            "NetServerTransportEnum",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // No downlevel call.
        //

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // NetServerTransportEnum


NET_API_STATUS NET_API_FUNCTION
NetRemoteTOD (
    IN  LPCWSTR       servername,
    OUT LPBYTE      *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetRemoteTOD

Arguments:

    servername - name of the server on which the API so to be executed.
    bufptr     - the location where the address of the buffer allocated
                 for the time-of-day information is placed.

Return Value:

    NERR_SUCCESS if there was no error. Otherwise, the error code is
    returned.


--*/
{
    NET_API_STATUS          apiStatus;

    //
    // Call API
    //
    *bufptr = NULL;           // Must be NULL so RPC knows to fill it in.

    NET_REMOTE_TRY_RPC

        apiStatus = NetrRemoteTOD (
                (LPWSTR)servername,
                (TIME_OF_DAY_INFO **) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetRemoteTOD",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_TIMESOURCE )

        apiStatus = RxNetRemoteTOD (
                (LPWSTR)servername,
                (LPBYTE *) bufptr);

    NET_REMOTE_END

    return(apiStatus);
}


NET_API_STATUS
I_NetServerSetServiceBitsEx (
    IN  LPWSTR  ServerName,
    IN  LPWSTR  EmulatedServerName OPTIONAL,
    IN  LPTSTR  TransportName      OPTIONAL,
    IN  DWORD   ServiceBitsOfInterest,
    IN  DWORD   ServiceBits,
    IN  DWORD   UpdateImmediately
    )

/*++

Routine Description:

    This is the DLL entrypoint for I_NetServerSetServiceBitsEx.  This
    routine sets the value of the Server Type as sent in server
    announcement messages.  It is an internal API used only by the
    service controller.

Arguments:

    ServerName - Used by RPC to direct the call.  This API may only be
        issued locally.  This is enforced by the client stub.

    EmulatedServerName - the name server using for accepting connections
        on the network and for announcements.  If null, use the priamary
        server name.

    TransportName - the name of one of the transports the server is bound
        on.  If null, set the bits for all the transports.

    ServiceBitsOfInterest - a mask indicating which bits are significant
        in 'ServiceBits'

    ServiceBits - Bits (preassigned to various components by Microsoft)
        indicating which services are active.  This field is not
        interpreted by the server service.

Return Value:

    NET_API_STATUS - NO_ERROR or ERROR_NOT_SUPPORTED.

--*/

{
    NET_API_STATUS              apiStatus;
    DWORD                       localOrRemote;

    //
    // Don't let this API go remote.
    //

    if ((ServerName != NULL) && (*ServerName != '\0')) {
        apiStatus = NetpIsRemote(ServerName, &localOrRemote, NULL, 0);
        if (apiStatus != NERR_Success) {
            return apiStatus;
        }
        if (localOrRemote == ISREMOTE) {
            return ERROR_NOT_SUPPORTED;
        }
    }

    //
    // Do the call.
    //

    NET_REMOTE_TRY_RPC

        apiStatus = I_NetrServerSetServiceBitsEx (
                ServerName,
                EmulatedServerName,
                TransportName,
                ServiceBitsOfInterest,
                ServiceBits,
                UpdateImmediately);

    NET_REMOTE_RPC_FAILED(
            "I_NetServerSetServiceBitsEx",
            ServerName,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // No downlevel call.
        //

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // I_NetServerSetServiceBitsEx

NET_API_STATUS
I_NetServerSetServiceBits (
    IN  LPTSTR  servername,
    IN  LPTSTR  transportname,
    IN  DWORD   servicebits,
    IN  DWORD   updateimmediately
    )

/*++

Routine Description:

    This is the DLL entrypoint for I_NetServerSetServiceBits.  This
    routine sets the value of the Server Type as sent in server
    announcement messages.  It is an internal API used only by the
    service controller.

Arguments:

    ServerName - Used by RPC to direct the call.  This API may only be
        issued locally.  This is enforced by the client stub.

    ServiceBits - Bits (preassigned to various components by Microsoft)
        indicating which services are active.  This field is not
        interpreted by the server service.

Return Value:

    NET_API_STATUS - NO_ERROR or ERROR_NOT_SUPPORTED.

--*/

{
    NET_API_STATUS              apiStatus;
    DWORD                       localOrRemote;

    //
    // Don't let this API go remote.
    //

    if ((servername != NULL) && (*servername != '\0')) {
        apiStatus = NetpIsRemote(servername, &localOrRemote, NULL, 0);
        if (apiStatus != NERR_Success) {
            return apiStatus;
        }
        if (localOrRemote == ISREMOTE) {
            return ERROR_NOT_SUPPORTED;
        }
    }

    //
    // Do the call.
    //

    NET_REMOTE_TRY_RPC

        apiStatus = I_NetrServerSetServiceBits (
                servername,
                transportname,
                servicebits,
                updateimmediately);

    //
    // This API is called by the Service Controller only.  Don't let
    // the failure path call any SCM APIs since that may deadlock
    // services.exe in the loopback.
    //

    NET_REMOTE_RPC_FAILED(
            "I_NetServerSetServiceBits",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_SVC_CTRL,
            SERVICE_SERVER)

        //
        // No downlevel call.
        //

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return(apiStatus);

} // I_NetServerSetServiceBits
//
// Netps canonicalization functions. These are essentially private functions
// and are called from the API stubs in canonapi.c. The canonicalization
// functions have to be usable locally without going via the server service
// hence they live in NETAPI.DLL, but call local functions in NETLIB if the
// ServerName parameter is NULL (or designates the local machine). If the
// ServerName parameter is not NULL and designates a remote computer then the
// RPC function (here) will be called, hence the remote server must be
// running in order to make remote canonicalization requests
//

NET_API_STATUS
NET_API_FUNCTION
NetpsNameCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Canonicalizes a name

Arguments:

    ServerName  - where to run this API
    Name        - name to canonicalize
    Outbuf      - where to put canonicalized name
    OutbufLen   - length of Outbuf
    NameType    - type of name to canonicalize
    Flags       - control flags

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetprNameCanonicalize(ServerName,
                                            Name,
                                            Outbuf,
                                            OutbufLen,
                                            NameType,
                                            Flags
                                            );

    NET_REMOTE_RPC_FAILED("NetpsNameCanonicalize",
                            ServerName,
                            apiStatus,
                            NET_REMOTE_FLAG_NORMAL,
                            SERVICE_SERVER)

        //
        // RPC call didn't work - try down-level routine
        //

        apiStatus = RxNetpNameCanonicalize(ServerName,
                                            Name,
                                            Outbuf,
                                            OutbufLen,
                                            NameType,
                                            Flags
                                            );

    NET_REMOTE_END

    return apiStatus;
}

LONG
NET_API_FUNCTION
NetpsNameCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Compares two names. Must be of same type

Arguments:

    ServerName  - where to run this API
    Name1       - 1st name to compare
    Name2       - 2nd
    NameType    - type of names
    Flags       - control flags

Return Value:

    LONG

--*/

{
    NET_API_STATUS apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetprNameCompare(ServerName, Name1, Name2, NameType, Flags);

    NET_REMOTE_RPC_FAILED("NetpsNameCompare",
                            ServerName,
                            apiStatus,
                            NET_REMOTE_FLAG_NORMAL,
                            SERVICE_SERVER)

        //
        // RPC call didn't work - try down-level routine
        //

        apiStatus = RxNetpNameCompare(ServerName, Name1, Name2, NameType, Flags);

    NET_REMOTE_END

    return apiStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpsNameValidate(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Validates a name - checks whether a name of a certain type conforms to
    canonicalization rules for that name type. Canonicalization rules mean
    character set, name syntax and length

Arguments:

    ServerName  - where to perform this function
    Name        - name to validate
    NameType    - what type of name it is
    Flags       - MBZ

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetprNameValidate(ServerName, Name, NameType, Flags);

    NET_REMOTE_RPC_FAILED("NetpsNameValidate",
                            ServerName,
                            apiStatus,
                            NET_REMOTE_FLAG_NORMAL,
                            SERVICE_SERVER)

        //
        // RPC call didn't work - try down-level routine
        //

        apiStatus = RxNetpNameValidate(ServerName, Name, NameType, Flags);

    NET_REMOTE_END

    return apiStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpsPathCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix OPTIONAL,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Canonicalizes a directory path or a device name

Arguments:

    ServerName  - where to run this API
    PathName    - path to canonicalize
    Outbuf      - where to write the canonicalized version
    OutbufLen   - length of Outbuf in bytes
    Prefix      - optional prefix which will be prepended to Path
    PathType    - the type of path to canonicalize. May be different at output
    Flags       - control flags

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetprPathCanonicalize(ServerName,
                                            PathName,
                                            (LPBYTE)Outbuf,
                                            OutbufLen,
                                            Prefix,
                                            PathType,
                                            Flags
                                            );

    NET_REMOTE_RPC_FAILED("NetpsPathCanonicalize",
                            ServerName,
                            apiStatus,
                            NET_REMOTE_FLAG_NORMAL,
                            SERVICE_SERVER)

        //
        // RPC call didn't work - try down-level routine
        //

        apiStatus = RxNetpPathCanonicalize(ServerName,
                                            PathName,
                                            Outbuf,
                                            OutbufLen,
                                            Prefix,
                                            PathType,
                                            Flags
                                            );

    NET_REMOTE_END

    return apiStatus;
}

LONG
NET_API_FUNCTION
NetpsPathCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Compares two paths. The paths are assumed to be of the same type

Arguments:

    ServerName  - where to run this API
    PathName1   - 1st path to compare
    PathName2   - 2nd
    PathType    - types of paths
    Flags       - control flags

Return Value:

    LONG

--*/

{
    NET_API_STATUS apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetprPathCompare(ServerName,
                                    PathName1,
                                    PathName2,
                                    PathType,
                                    Flags
                                    );

    NET_REMOTE_RPC_FAILED("NetpsPathCompare",
                            ServerName,
                            apiStatus,
                            NET_REMOTE_FLAG_NORMAL,
                            SERVICE_SERVER)

        //
        // RPC call didn't work - try down-level routine
        //

        apiStatus = RxNetpPathCompare(ServerName,
                                        PathName1,
                                        PathName2,
                                        PathType,
                                        Flags
                                        );

    NET_REMOTE_END

    return apiStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpsPathType(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Determines the type of a path

Arguments:

    ServerName  - where to run this API
    PathName    - to find type of
    PathType    - returned path type
    Flags       - control flags

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetprPathType(ServerName, PathName, PathType, Flags);

    NET_REMOTE_RPC_FAILED("NetpsPathType",
                            ServerName,
                            apiStatus,
                            NET_REMOTE_FLAG_NORMAL,
                            SERVICE_SERVER)

        //
        // RPC call didn't work - try down-level routine
        //

        apiStatus = RxNetpPathType(ServerName, PathName, PathType, Flags);

    NET_REMOTE_END

    return apiStatus;
}

NET_API_STATUS NET_API_FUNCTION
NetServerTransportAddEx (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  bufptr
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetServerTransportAddEx.  It functions
     just like NetServerTransportAdd, but it supports level 1 as well as 0

--*/

{
    NET_API_STATUS              apiStatus;

    NET_REMOTE_TRY_RPC

        apiStatus = NetrServerTransportAddEx (
                servername,
                level,
                (LPTRANSPORT_INFO) bufptr);

    NET_REMOTE_RPC_FAILED(
            "NetServerTransportAddEx",
            servername,
            apiStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SERVER)

        //
        // No downlevel call.
        //

        apiStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    if( apiStatus == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
        apiStatus = NERR_InvalidAPI;
    }

    return(apiStatus);

} // NetServerTransportAddEx


NET_API_STATUS NET_API_FUNCTION
NetServerComputerNameAdd(
    IN LPWSTR ServerName         OPTIONAL,
    IN LPWSTR EmulatedDomainName OPTIONAL,
    IN LPWSTR EmulatedServerName
)
/*++

Routine Description:

    This is the DLL entrypoint for NetServerComputerNameAdd.  This api
      causes 'ServerName' to respond to requests for 'EmulatedServerName'.

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    EmulatedServerName --A pointer to the ASCIIZ string containing the
        name which the server should stop supporting

    EmulatedDomainName --A pointer to the ASCIIZ string containing the
        domain name the server should use when announcing the presence of
        'EmulatedServerName'

Return Value:

    NERR_Success, or reason for failure

--*/
{
    DWORD resumehandle = 0;
    NET_API_STATUS retval;
    DWORD entriesread, totalentries;
    DWORD i, j;
    BOOLEAN AddedOne = FALSE;
    UCHAR NetBiosName[ MAX_PATH ];
    OEM_STRING NetBiosNameString;
    UNICODE_STRING UniName;

    //
    // Ensure a valid EmulatedServerName was passed in
    //
    if( EmulatedServerName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the EmulatedServerName to an OEM string
    //
    RtlInitUnicodeString( &UniName, EmulatedServerName );
    NetBiosNameString.Buffer = (PCHAR)NetBiosName;
    NetBiosNameString.MaximumLength = sizeof( NetBiosName );
    (VOID) RtlUpcaseUnicodeStringToOemString(
                                &NetBiosNameString,
                                &UniName,
                                FALSE
                                );

    if( ARGUMENT_PRESENT( EmulatedDomainName ) ) {

        //
        // The caller wants to set a new computer name and domain name to the
        //  server.  This requires level 1, which is new in 4.0
        //
        PSERVER_TRANSPORT_INFO_1 psti1;

        //
        // Enumerate all the transports so we can add the name and domain
        //  to each one.
        //
        retval = NetServerTransportEnum ( ServerName,
                                          1,
                                          (LPBYTE *)&psti1,
                                          (DWORD)-1,
                                          &entriesread,
                                          &totalentries,
                                          &resumehandle );
        if( retval == NERR_Success ) {
            //
            // Add the new name and domain to all of the transports
            //
            for( i=0; i < entriesread; i++ ) {

                //
                // Make sure we haven't already added to this transport
                //
                for( j = 0; j < i; j++ ) {
                    if( wcscmp( psti1[j].svti1_transportname, psti1[i].svti1_transportname ) == 0 )
                        break;
                }

                if( i != j )
                    continue;

                psti1[i].svti1_transportaddress = NetBiosName;
                psti1[i].svti1_transportaddresslength = strlen( NetBiosName );
                psti1[i].svti1_domain = EmulatedDomainName;

                retval = NetServerTransportAddEx( ServerName, 1, (LPBYTE)&psti1[ i ]  );

                if( retval == NERR_Success ) {
                    AddedOne = TRUE;
                }
            }

            MIDL_user_free( psti1 );
        }


    } else {

        //
        // The caller just wants to set an alternate server name.  Use level 0,
        //  since 3.51 servers support level 0
        //
        PSERVER_TRANSPORT_INFO_0 psti0;

        //
        // Enumerate all the transports so we can add the name and domain
        //  to each one.
        //
        retval = NetServerTransportEnum ( ServerName,
                                          0,
                                          (LPBYTE *)&psti0,
                                          (DWORD)-1,
                                          &entriesread,
                                          &totalentries,
                                          &resumehandle );
        if( retval == NERR_Success ) {
            //
            // Add the new name to all of the transports
            //
            for( i=0; i < entriesread; i++ ) {

                //
                // Make sure we haven't already added to this transport
                //
                for( j = 0; j < i; j++ ) {
                    if( wcscmp( psti0[j].svti0_transportname, psti0[i].svti0_transportname ) == 0 )
                        break;
                }

                if( i != j )
                    continue;

                psti0[i].svti0_transportaddress = NetBiosName;
                psti0[i].svti0_transportaddresslength = strlen( NetBiosName );

                retval = NetServerTransportAdd( ServerName, 0, (LPBYTE)&psti0[ i ]  );

                if( retval == NERR_Success ) {
                    AddedOne = TRUE;
                }
            }

            MIDL_user_free( psti0 );
        }
    }

    return AddedOne ? NERR_Success : retval;
}

NET_API_STATUS NET_API_FUNCTION
NetServerComputerNameDel (
    IN LPWSTR ServerName        OPTIONAL,
    IN LPWSTR EmulatedServerName
)
/*++

Routine Description:

    This is the DLL entrypoint for NetServerComputerNameDel.  This api
      causes 'ServerName' to cease responding to requests for 'EmulatedServerName'

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    EmulatedServerName --A pointer to the ASCIIZ string containing the
        name which the server should stop supporting

Return Value:

    NERR_Success, or reason for failure

--*/
{
    DWORD resumehandle = 0;
    NET_API_STATUS retval, tmpretval;
    DWORD entriesread, totalentries;
    DWORD i;
    UCHAR NetBiosName[MAX_PATH];
    OEM_STRING NetBiosNameString;
    UNICODE_STRING UniName;
    PSERVER_TRANSPORT_INFO_0 psti0;
    BOOLEAN nameDeleted = FALSE;

    //
    // Ensure a valid EmulatedServerName was passed in
    //
    if( EmulatedServerName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the EmulatedServerName to an OEM string
    //
    RtlInitUnicodeString( &UniName, EmulatedServerName );
    NetBiosNameString.Buffer = (PCHAR)NetBiosName;
    NetBiosNameString.MaximumLength = sizeof( NetBiosName );
    (VOID) RtlUpcaseUnicodeStringToOemString(
                                &NetBiosNameString,
                                &UniName,
                                FALSE
                                );

    //
    // Enumerate all the transports so we can delete the name from each one
    //
    retval = NetServerTransportEnum ( ServerName,
                                      0,
                                      (LPBYTE *)&psti0,
                                      (DWORD)-1,
                                      &entriesread,
                                      &totalentries,
                                      &resumehandle );
    if( retval != NERR_Success ) {
        return retval;
    }

    retval = ERROR_BAD_NET_NAME;

    //
    // Delete the name from all of the transports.  If we were successful at least once,
    //  then we return success.
    //
    for( i=0; i < entriesread; i++ ) {

        if( psti0[i].svti0_transportaddresslength != NetBiosNameString.Length ) {
            continue;
        }

        if( RtlCompareMemory( psti0[i].svti0_transportaddress,
                              NetBiosName,
                              NetBiosNameString.Length) != NetBiosNameString.Length )  {
            continue;
        }

        tmpretval = NetServerTransportDel( ServerName, 0, (LPBYTE)&psti0[ i ]  );

        if( nameDeleted == FALSE ) {
            retval = tmpretval;
            if( retval == NERR_Success ) {
                nameDeleted = TRUE;
            }
        }
    }

    if( entriesread ) {
        MIDL_user_free( psti0 );
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\idl\adtcomn.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    adtdbg.h 

Abstract:

    Contains definitions used in debugging the messenger service.

Author:

    Dan Lafferty    (danl)  25-Mar-1993

Environment:

    User Mode -Win32

Revision History:


--*/

#ifndef _ADTDBG_INCLUDED
#define _ADTDBG_INCLUDED

//
// Debug macros and constants.
//
#if DBG

#define STATIC

#else

#define STATIC static

#endif

extern DWORD    AdtsvcDebugLevel;

//
// The following allow debug print syntax to look like:
//
//   SC_LOG1(DEBUG_TRACE, "An error occured %x\n",status)
//

#if DBG
#define ADT_LOG0(level,string)                  \
    if( AdtsvcDebugLevel & (DEBUG_ ## level)){  \
        (VOID) KdPrint(("[ADT]"));              \
        (VOID) KdPrint((string));               \
    }
#define ADT_LOG1(level,string,var)              \
    if( AdtsvcDebugLevel & (DEBUG_ ## level)){  \
        (VOID)KdPrint(("[ADT]"));               \
        (VOID)KdPrint((string,var));            \
    }
#else

#define ADT_LOG0(level,string)
#define ADT_LOG1(level,string,var)

#endif

#define DEBUG_NONE      0x00000000
#define DEBUG_ERROR     0x00000001
#define DEBUG_TRACE     0x00000002
#define DEBUG_LOCKS     0x00000004

#define DEBUG_ALL       0xffffffff


DWORD
PrivateGetFileSecurity (
    LPWSTR                      FileName,
    SECURITY_INFORMATION        RequestedInfo,
    PSECURITY_DESCRIPTOR        *pSDBuffer,
    LPDWORD                     pBufSize
    );

DWORD
PrivateSetFileSecurity (
    LPWSTR                          FileName,
    SECURITY_INFORMATION            SecurityInfo,
    PSECURITY_DESCRIPTOR            pSecurityDescriptor
    );

#endif // _ADTDBG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\idl\srvnames.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    srvnames.h

Abstract:

    Private header file which defines the Server Service names.

Author:

    Dan Lafferty (danl) 07-Jan-1993

Revision History:

--*/

#define SERVER_INTERFACE_NAME    TEXT("srvsvc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\idl\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

//#include <windef.h>
#include <nt.h>
#include <ntrtl.h>

// #include <rpc.h>
#include <windef.h>
#include <winerror.h>

#include <lmcons.h>

#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR      [string] wchar_t*
#else
#define LPTSTR      [string] LPTSTR
#endif
#define LPSTR       [string] LPSTR
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#endif

#include <lmchdev.h>
#include <lmremutl.h>
#include <lmserver.h>
#include <lmshare.h>
#include <lmstats.h>
#include <lmdfs.h>
#include <dfspriv.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\cdevq.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    CDevQ.c

Abstract:

    This module contains support for the Character Device Queue catagory
    of APIs for the NT server service.

Author:

    David Treadwell (davidtr)    31-Dec-1991

Revision History:

--*/

#include "srvsvcp.h"


NET_API_STATUS NET_API_FUNCTION
NetrCharDevQEnum (
    IN LPTSTR ServerName,
    IN LPTSTR UserName,
    IN OUT LPCHARDEVQ_ENUM_STRUCT InfoStruct,
    IN DWORD PreferedMaximumLength,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetCharDevEnum function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    ServerName;
    UserName;
    InfoStruct;
    PreferedMaximumLength;
    TotalEntries;
    ResumeHandle;

    return ERROR_NOT_SUPPORTED;
} // NetrCharDevQEnum


/****************************************************************************/
NET_API_STATUS
NetrCharDevQGetInfo (
    IN  LPTSTR          ServerName,
    IN  LPTSTR          QueueName,
    IN  LPTSTR          UserName,
    IN  DWORD           Level,
    OUT LPCHARDEVQ_INFO CharDevQInfo
    )

{
    ServerName;
    QueueName;
    UserName;
    Level;
    CharDevQInfo;

    return ERROR_NOT_SUPPORTED;
}


/****************************************************************************/
NET_API_STATUS
NetrCharDevQSetInfo (
    IN  LPTSTR          ServerName,
    IN  LPTSTR          QueueName,
    IN  DWORD           Level,
    IN  LPCHARDEVQ_INFO CharDevQInfo,
    OUT LPDWORD         ParmErr
    )
{
    ServerName;
    QueueName;
    Level;
    CharDevQInfo;
    ParmErr;

    return ERROR_NOT_SUPPORTED;
}


/****************************************************************************/
NET_API_STATUS
NetrCharDevQPurge (
    IN  LPTSTR   ServerName,
    IN  LPTSTR   QueueName
    )

{
    ServerName;
    QueueName;

    return ERROR_NOT_SUPPORTED;
}



/****************************************************************************/
NET_API_STATUS
NetrCharDevQPurgeSelf (
    IN  LPTSTR   ServerName,
    IN  LPTSTR   QueueName,
    IN  LPTSTR   ComputerName
    )
{
    ServerName;
    QueueName;
    ComputerName;

    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\lib\adtcomn.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    adtcomn.c

Abstract:

    AdminTools common Routines.

    This file contains the calls to GetFileSecurity and
    SetFileSecurity that is used on both the client and server
    sides of this RPC server.

Author:

    Dan Lafferty (danl) 23-Mar-1993

Environment:

    User Mode - Win32


Revision History:

    23-Mar-1993 danl
        Created

--*/

//
// Includes
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <lmerr.h>

#include <rpc.h>
#include <srvsvc.h>
#include <netlibnt.h>   // NetpNtStatusToApiStatus

#include "adtcomn.h"

//
// LOCAL FUNCTIONS
//


DWORD
PrivateGetFileSecurity (
    LPWSTR                      FileName,
    SECURITY_INFORMATION        RequestedInfo,
    PSECURITY_DESCRIPTOR        *pSDBuffer,
    LPDWORD                     pBufSize
    )

/*++

Routine Description:

    This function returns to the caller a copy of the security descriptor 
    protecting a file or directory.  It calls GetFileSecurity.  The
    Security Descriptor is always returned in the self-relative format.

    NOTE:  This function allocates storage for the pSDBuffer.  Therefore,
    this pointer must be free'd by the caller.

Arguments:

    FileName - A pointer to the name fo the file or directory whose
        security is being retrieved.

    RequestedInfo - The type of security information being requested.
 
    pSDBuffer -  A pointer to a location where a pointer for the
        security descriptor and a length field for the security descriptor.

    pBufSize - A pointer to the location where the size, in bytes, of
        the returned security descriptor is to be placed.


Return Value:

    NERR_Success - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate memory for the security
        descriptor.

    This function can also return any error that GetFileSecurity can 
    return.


--*/
{

    NET_API_STATUS          status;
    DWORD                   sizeNeeded;

    *pSDBuffer = NULL;
    //
    // Determine the buffer size for the Descriptor
    //
    if (GetFileSecurityW(
            FileName,               // File whose security is being retrieved
            RequestedInfo,          // security info being requested
            *pSDBuffer,             // buffer to receive security descriptor
            0,                      // size of the buffer
            &sizeNeeded)) {         // size of buffer required

        //
        // We should have a failed due to a buffer size being too small.
        //
        status = ERROR_INVALID_PARAMETER;
        goto CleanExit;
    }

    status = GetLastError();

    if ((status == ERROR_INSUFFICIENT_BUFFER) && (sizeNeeded > 0)) {

        *pSDBuffer = MIDL_user_allocate(sizeNeeded);

        if (pSDBuffer == NULL) {
            status = GetLastError();
            ADT_LOG1(ERROR,"NetrpGetFileSecurity:MIDL_user_alloc1 failed %d\n",status);
            goto CleanExit;
        }
        *pBufSize = sizeNeeded;

        if (!GetFileSecurityW(
                FileName,               // File whose security is being retrieved
                RequestedInfo,          // security info being requested
                *pSDBuffer,             // buffer to receive security descriptor
                sizeNeeded,             // size of the buffer
                &sizeNeeded)) {         // size of buffer required

            //
            // The call with the proper buffer size failed.
            //
            status = GetLastError();
            ADT_LOG1(ERROR, "GetFileSecurity Failed %d\n", status);
            MIDL_user_free(*pSDBuffer);
            goto CleanExit;
        }

        ADT_LOG0(TRACE,"NetrpGetFileSecurity:GetFileSecurity Success\n");

        if (!IsValidSecurityDescriptor(*pSDBuffer)) {
            ADT_LOG0(TRACE,"FAILURE:  SECURITY DESCRIPTOR IS INVALID\n");
        }
        else {
            ADT_LOG0(TRACE,"SUCCESS:  SECURITY DESCRIPTOR IS GOOD\n");
        }
        status = NO_ERROR;
    }

CleanExit:
    return(status);
}


DWORD
PrivateSetFileSecurity (
    LPWSTR                          FileName,
    SECURITY_INFORMATION            SecurityInfo,
    PSECURITY_DESCRIPTOR            pSecurityDescriptor
    )

/*++

Routine Description:

    This function can be used to set the security of a file or directory.
    It calls SetFileSecurity().

Arguments:

    FileName - A pointer to the name of the file or directory whose
        security is being changed.

    SecurityInfo - Information describing the contents
        of the Security Descriptor.

    pSecurityDescriptor - A pointer to a structure that contains a
        self-relative security descriptor and a length.

Return Value:

    NERR_Success - The operation was successful.

    This function can also return any error that GetFileSecurity can 
    return.

--*/
{
    DWORD   status=NO_ERROR;

    //
    // Call SetFileSecurity
    //
    if (!SetFileSecurityW (
            FileName,
            SecurityInfo,
            pSecurityDescriptor)) {

        status = GetLastError();
        return(status);
    }
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\cdev.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    CDev.c

Abstract:

    This module contains support for the Character Device catagory of
    APIs for the NT server service.

Author:

    David Treadwell (davidtr)    20-Dec-1991

Revision History:

--*/

#include "srvsvcp.h"


NET_API_STATUS NET_API_FUNCTION
NetrCharDevControl (
    IN LPTSTR ServerName,
    IN LPTSTR DeviceName,
    IN DWORD OpCode
    )

/*++

Routine Description:

    This routine communicates with the server FSP to implement the
    NetCharDevControl function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    ServerName, DeviceName, OpCode;
    return ERROR_NOT_SUPPORTED;

} // NetrCharDevControl


NET_API_STATUS NET_API_FUNCTION
NetrCharDevEnum (
	SRVSVC_HANDLE ServerName,
	LPCHARDEV_ENUM_STRUCT InfoStruct,
	DWORD PreferedMaximumLength,
	LPDWORD TotalEntries,
	LPDWORD ResumeHandle
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetCharDevEnum function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    ServerName, InfoStruct, PreferedMaximumLength, TotalEntries, ResumeHandle;
    return ERROR_NOT_SUPPORTED;

} // NetrCharDevEnum


NET_API_STATUS
NetrCharDevGetInfo (
    IN LPTSTR ServerName,
    IN LPTSTR DeviceName,
    IN DWORD Level,
    OUT LPCHARDEV_INFO CharDevInfo
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetCharDevGetInfo function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    ServerName, DeviceName, Level, CharDevInfo;
    return ERROR_NOT_SUPPORTED;
} // NetrCharDevGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\adtsrv.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    adtsrv.c

Abstract:

    AdminTools Server functions.

    This file contains the remote interface for NetpGetFileSecurity and
    NetpSetFileSecurity API.

Author:

    Dan Lafferty (danl) 25-Mar-1993

Environment:

    User Mode - Win32


Revision History:

    27-Oct-1994 IsaacHe
        Make sure the share permissions allow these operations.
    05-Sep-1994 Danl
        Free memory and NULL the pointer to the SecurityDescriptor if
        a failure occurs.  Also free the buffer returned from
        NetShareGetInfo.
    25-Mar-1993 danl
        Created

--*/

//
// Includes
//

#include "srvsvcp.h"

#include <lmerr.h>
#include <adtcomn.h>
#include <tstr.h>

DWORD AdtsvcDebugLevel = DEBUG_ERROR;

//
// LOCAL FUNCTIONS
//

NET_API_STATUS
AdtCheckShareAccessAndGetFullPath(
    LPWSTR      pShare,
    LPWSTR      pFileName,
    LPWSTR      *pPath,
    ACCESS_MASK DesiredAccess
    );

NET_API_STATUS NET_API_FUNCTION
NetrpGetFileSecurity (
    IN  LPWSTR            ServerName,
    IN  LPWSTR            ShareName,
    IN  LPWSTR             FileName,
    IN  SECURITY_INFORMATION    RequestedInfo,
    OUT PADT_SECURITY_DESCRIPTOR    *pSecurityDescriptor
    )

/*++

Routine Description:

    This function returns to the caller a copy of the security descriptor
    protecting a file or directory.  It calls GetFileSecurity.  The
    Security Descriptor is always returned in the self-relative format.

    This function is called only when accessing remote files.  In this case,
    the filename is broken into ServerName, ShareName, and FileName components.
    The ServerName gets the request to this routine.  The ShareName must be
    expanded to find the local path associated with it.  This is combined
    with the FileName to create a fully qualified pathname that is local
    to this machine.

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer or
        string specifies the local machine.

    ShareName - A pointer to a string that identifies the share name
        on which the file is found.

    FileName - A pointer to the name fo the file or directory whose
        security is being retrieved.

    RequestedInfo - The type of security information being requested.

    pSecurityDescriptor - A pointer to a pointer to a structure which
        contains the buffer pointer for the security descriptor and
        a length field for the security descriptor.

Return Value:

    NERR_Success - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate memory for the security
        descriptor.

    Other - This function can also return any error that
                GetFileSecurity,
                RpcImpersonateClient, or
                ShareEnumCommon
            can return.


--*/
{
    NET_API_STATUS        status;
    PSECURITY_DESCRIPTOR    pNewSecurityDescriptor;
    DWORD            bufSize;
    LPWSTR            FullPath=NULL;
    ACCESS_MASK        DesiredAccess = 0;

    *pSecurityDescriptor = MIDL_user_allocate(sizeof(ADT_SECURITY_DESCRIPTOR));

    if (*pSecurityDescriptor == NULL) {
        ADT_LOG0( ERROR, "NetrpGetFileSecurity:MIDL_user_alloc failed\n" );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Figure out accesses needed to perform the indicated operation(s).
    // This code is taken from ntos\se\semethod.c
    //
    if ((RequestedInfo & OWNER_SECURITY_INFORMATION) ||
        (RequestedInfo & GROUP_SECURITY_INFORMATION) ||
        (RequestedInfo & DACL_SECURITY_INFORMATION)) {
        DesiredAccess |= READ_CONTROL;
    }

    if ((RequestedInfo & SACL_SECURITY_INFORMATION)) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    //
    // Check share perms and create a full path string by getting
    // the path for the share name, and adding the FileName string to it.
    //
    status = AdtCheckShareAccessAndGetFullPath(
            ShareName,
            FileName,
            &FullPath,
            DesiredAccess
        );

    if( status == NO_ERROR ) {
        if( (status = RpcImpersonateClient(NULL)) == NO_ERROR ) {
            //
            // Get the File Security information
            //
            status = PrivateGetFileSecurity(
                    FullPath,
                    RequestedInfo,
                    &pNewSecurityDescriptor,
                    &bufSize);

            if ( status == NO_ERROR ) {
                (*pSecurityDescriptor)->Length = bufSize;
                (*pSecurityDescriptor)->Buffer = pNewSecurityDescriptor;
            }

            (VOID)RpcRevertToSelf();
        }
        MIDL_user_free( FullPath );
    }

    if ( status != NO_ERROR ) {
        MIDL_user_free(*pSecurityDescriptor);
        *pSecurityDescriptor = NULL;
    }

    return status;
}


NET_API_STATUS NET_API_FUNCTION
NetrpSetFileSecurity (
    IN  LPWSTR            ServerName OPTIONAL,
    IN  LPWSTR            ShareName,
    IN  LPWSTR            FileName,
    IN  SECURITY_INFORMATION    SecurityInfo,
    IN  PADT_SECURITY_DESCRIPTOR    pSecurityDescriptor
    )

/*++

Routine Description:

    This function can be used to set the security of a file or directory.
    It calls SetFileSecurity().

Arguments:

    ServerName - A pointer to a string containing the name of the remote
        server on which the function is to execute.  A NULL pointer or
        string specifies the local machine.

    ShareName - A pointer to a string that identifies the share name
        on which the file or directory is found.

    FileName - A pointer to the name of the file or directory whose
        security is being changed.

    SecurityInfo - Information describing the contents
        of the Security Descriptor.

    pSecurityDescriptor - A pointer to a structure that contains a
        self-relative security descriptor and a length.

Return Value:

    NERR_Success - The operation was successful.

    Other - This function can also return any error that
                SetFileSecurity,
                RpcImpersonateClient, or
                ShareEnumCommon
            can return.

--*/
{
    NET_API_STATUS   status;
    LPWSTR  FullPath=NULL;
    ACCESS_MASK DesiredAccess = 0;

    UNREFERENCED_PARAMETER(ServerName);

    // Validate the parameters
    if( (pSecurityDescriptor->Buffer == NULL) &&
        (pSecurityDescriptor->Length > 0) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Figure out accesses needed to perform the indicated operation(s).
    // This code is taken from ntos\se\semethod.c
    //
    if ((SecurityInfo & OWNER_SECURITY_INFORMATION) ||
        (SecurityInfo & GROUP_SECURITY_INFORMATION)   ) {
        DesiredAccess |= WRITE_OWNER;
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION) {
        DesiredAccess |= WRITE_DAC;
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    //
    // Check perms and create a full path string by getting the path
    // for the share name, and adding the FileName string to it.
    //
    status = AdtCheckShareAccessAndGetFullPath(
            ShareName,
            FileName,
            &FullPath,
            DesiredAccess
        );

    if ( status == NO_ERROR ) {
        if( (status = RpcImpersonateClient(NULL)) == NO_ERROR ) {
            if (RtlValidRelativeSecurityDescriptor(
                    pSecurityDescriptor->Buffer,
                    pSecurityDescriptor->Length,
                    SecurityInfo)) {
                //
                // Call SetFileSecurity
                //
                status = PrivateSetFileSecurity(
                    FullPath,
                    SecurityInfo,
                    pSecurityDescriptor->Buffer);
            } else {
                status = ERROR_INVALID_SECURITY_DESCR;
            }

            (VOID)RpcRevertToSelf();
        }
        MIDL_user_free(FullPath);
    }

    return(status);
}

NET_API_STATUS
AdtCheckShareAccessAndGetFullPath(
    LPWSTR      pShare,
    LPWSTR      pFileName,
    LPWSTR      *pPath,
    ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This function ensures the DesiredAccess is allowed and finds the
    path associated with the share name, combines this with the
    file name, and creates a fully qualified path name.

    NOTE:  This function allocates storage for the pPath string.

Arguments:

    pShare - This is a pointer to the share name string.

    pFileName - This is a pointer to the file name (or path) string.

    pPath - This is a pointer to a location where the pointer to the
        complete file path string can be stored.  This pointer needs to
        be free'd with MIDL_user_free when the caller is finished with it.

    DesiredAccess - what we'd like to do through the share

Return Value:

    NO_ERROR - if The operation was completely successful.

    Other - Errors returned from ShareEnumCommon, and MIDL_user_allocate may be
        returned from this routine.

Comments:
    The share access checking is complicated by the fact that the share ACL has
        had the owner and group SIDs stripped out.  We need to put them back
        in, or the SsCheckAccess() call will fail.

--*/
{
    NET_API_STATUS        status;
    PSHARE_INFO_502        pshi502 = NULL;
    DWORD            bufSize;
    DWORD            fileNameSize;
    LPWSTR            pLastChar;
    DWORD            entriesRead;
    DWORD            totalEntries;
    PSECURITY_DESCRIPTOR    NewDescriptor = NULL;
    SECURITY_DESCRIPTOR    ModificationDescriptor;
    GENERIC_MAPPING        Mapping;
    SRVSVC_SECURITY_OBJECT    SecurityObject;
    HANDLE            token;

    status = ShareEnumCommon(
            502,
            (LPBYTE *)&pshi502,
            (DWORD)-1,
            &entriesRead,
            &totalEntries,
            NULL,
            pShare
            );

    if( status != NO_ERROR ) {
        goto getout;

    } else if( entriesRead == 0 || pshi502 == NULL ) {
        status =  NERR_NetNameNotFound;

    } else if( pshi502->shi502_path == NULL ) {
        status = ERROR_BAD_DEV_TYPE;

    } else if( pshi502->shi502_security_descriptor != NULL ) {

        status = RtlCopySecurityDescriptor( pshi502->shi502_security_descriptor, &NewDescriptor );
        if( status != STATUS_SUCCESS )
            goto getout;

        RtlCreateSecurityDescriptor( &ModificationDescriptor, SECURITY_DESCRIPTOR_REVISION );

        RtlSetOwnerSecurityDescriptor( &ModificationDescriptor, SsData.SsLmsvcsGlobalData->LocalSystemSid, FALSE );

        RtlSetGroupSecurityDescriptor( &ModificationDescriptor, SsData.SsLmsvcsGlobalData->LocalSystemSid, FALSE );

        Mapping.GenericRead = FILE_GENERIC_READ;
        Mapping.GenericWrite = FILE_GENERIC_WRITE;
        Mapping.GenericExecute = FILE_GENERIC_EXECUTE;
        Mapping.GenericAll = FILE_ALL_ACCESS;

        if( ImpersonateSelf( SecurityImpersonation ) == FALSE ) {
            status = GetLastError();
            goto getout;
        }

        status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY, TRUE, &token );

        RevertToSelf();

        if( status != STATUS_SUCCESS )
            goto getout;

        status = RtlSetSecurityObject (
                 GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                &ModificationDescriptor,
                &NewDescriptor,
                &Mapping,
                token
                );

        NtClose( token );

        if( status == STATUS_SUCCESS ) {

            SecurityObject.ObjectName = pShare;
            SecurityObject.Mapping = &Mapping;
            SecurityObject.SecurityDescriptor = NewDescriptor;

            //
            // SsCheckAccess does an RpcImpersonateClient()...
            //
            status = SsCheckAccess( &SecurityObject, DesiredAccess );
        }
    }

    if( status == STATUS_SUCCESS ) {

        //
        // If the last character is a '\', then we must remove it.
        //
        pLastChar = pshi502->shi502_path + wcslen(pshi502->shi502_path);
        pLastChar--;
        if (*pLastChar == L'\\') {
            *pLastChar = L'\0';
        }

        bufSize = STRSIZE(pshi502->shi502_path);
        fileNameSize = STRSIZE(pFileName);

        *pPath = MIDL_user_allocate( bufSize + fileNameSize );

        if (*pPath != NULL) {
            wcscpy (*pPath, pshi502->shi502_path);
            wcscat (*pPath, pFileName);
        } else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

getout:
    if( NewDescriptor != NULL )
        RtlDeleteSecurityObject( &NewDescriptor );

    if( pshi502 != NULL )
        MIDL_user_free( pshi502 );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\canon.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    canon.c

Abstract:

    Stubs for server side of internal canonicalization RPC. These routines
    just call the local versions of the routines which live in NetLib.LIB

    Moved from cansvc

Author:

    Richard Firth (rfirth) 20-May-1991

Revision History:


--*/

#include <windows.h>
#include <lmcons.h>
#include <netcan.h>

NET_API_STATUS
NetprPathType(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    IN  LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Stub function for NetpPathType - calls local version

Arguments:

    ServerName  - identifies this server
    PathName    - path name to check
    PathType    - assumed type of PathName
    Flags       - controlling flags for NetpPathType

Return Value:

    NET_API_STATUS
        Success = 0
        Failure = (return code from NetpPathType)

--*/

{
    UNREFERENCED_PARAMETER(ServerName);

    return NetpwPathType(PathName, PathType, Flags);
}

NET_API_STATUS
NetprPathCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Stub function for NetpPathCanonicalize - calls local version

Arguments:

    ServerName  - identifies this server
    PathName    - path name to canonicalize
    Outbuf      - where to place canonicalized path
    OutbufLen   - size of Outbuf
    Prefix      - (historical) prefix for path
    PathType    - type of PathName
    Flags       - controlling flags for NetpPathCanonicalize

Return Value:

    NET_API_STATUS
        Success = 0
        Failure = (return code from NetpPathCanonicalize)

--*/

{
    UNREFERENCED_PARAMETER(ServerName);

    return NetpwPathCanonicalize(PathName,
                                    Outbuf,
                                    OutbufLen,
                                    Prefix,
                                    PathType,
                                    Flags
                                    );
}

LONG
NetprPathCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Stub function for NetpPathCompare - calls local version

Arguments:

    ServerName  - identifies this server
    PathName1   - path name to compare
    PathName2   - path name to compare
    PathType    - type of PathName1, PathName2
    Flags       - controlling flags for NetpPathCompare

Return Value:

    LONG
        -1  - Name1 < Name2
        0   - Name1 = Name2
        +1  - Name1 > Name2

--*/

{
    UNREFERENCED_PARAMETER(ServerName);

    return NetpwPathCompare(PathName1, PathName2, PathType, Flags);
}

NET_API_STATUS
NetprNameValidate(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Stub function for NetpNameValidate - calls local version

Arguments:

    ServerName  - identifies this server
    Name        - to validate
    NameType    - type of Name
    Flags       - controlling flags for NetpNameValidate

Return Value:

    NET_API_STATUS
        Success = 0
        Failure = (return code from NetpNameValidate)

--*/

{
    UNREFERENCED_PARAMETER(ServerName);

    return NetpwNameValidate(Name, NameType, Flags);
}

NET_API_STATUS
NetprNameCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Stub function for NetpNameCanonicalize - calls local version

Arguments:

    ServerName  - identifies this server
    Name        - to canonicalize
    Outbuf      - where to place canonicalized name
    OutbufLen   - size of Outbuf
    NameType    - type of Name
    Flags       - controlling flags for NetpNameCanonicalize

Return Value:

    NET_API_STATUS
        Success = 0
        Failure = (return code from NetpNameCanonicalize)

--*/

{
    UNREFERENCED_PARAMETER(ServerName);

    return NetpwNameCanonicalize(Name, Outbuf, OutbufLen, NameType, Flags);
}

LONG
NetprNameCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Stub function for NetpNameCompare - calls local version

Arguments:

    ServerName  - identifies this server
    Name1       - name to compare
    Name2       - "
    NameType    - type of names
    Flags       - controlling flags for NetpNameCompare

Return Value:

    LONG
        -1  - Name1 < Name2
        0   - Name1 = Name2
        +1  - Name1 > Name2

--*/

{
    UNREFERENCED_PARAMETER(ServerName);

    return NetpwNameCompare(Name1, Name2, NameType, Flags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\cmdline.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    CmdLine.c

Abstract:

    This module contains support routines for processing server service
    command-line arguments.

Author:

    David Treadwell (davidtr)    10-Mar-1991

Revision History:

--*/

#include "srvsvcp.h"

#include <netlibnt.h>
#include <tstr.h>


//
// Forward declarations.
//

PFIELD_DESCRIPTOR
FindSwitchMatch (
    IN LPWCH Argument,
    IN BOOLEAN Starting
    );

NET_API_STATUS
SetField (
    IN PFIELD_DESCRIPTOR SwitchDesc,
    IN LPWCH Argument
    );


NET_API_STATUS
SsParseCommandLine (
    IN DWORD argc,
    IN LPWSTR argv[],
    IN BOOLEAN Starting
    )

/*++

Routine Description:

    This routine sets server parameters using a command line.  It parses
    the command line, changing one parameter at a time as it comes up.

Arguments:

    argc - the number of command-line arguments.

    argv - an arrray of pointers to the arguments.

    Starting - TRUE if the command line is from server startup, i.e.
        net start server.  This is needed because some fields may only
        be set at startup.

Return Value:

    NET_API_STATUS - 0 or reason for failure.

--*/

{
    NET_API_STATUS error;
    DWORD i;
    PFIELD_DESCRIPTOR switchDesc;
    PSERVER_SERVICE_DATA saveSsData;

    //
    // Save the service data in case there is an invalid param and we have
    // to back out.
    //

    saveSsData = MIDL_user_allocate( sizeof(SERVER_SERVICE_DATA) );
    if ( saveSsData == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlCopyMemory( saveSsData, &SsData, sizeof(SERVER_SERVICE_DATA) );

    //
    // Loop through the command-line arguments, setting as we go.
    //

    for ( i = 0; i < argc; i++ ) {

        LPWCH arg;

        arg = argv[i];

        //
        // A hack to aid debugging.
        //

        if ( _wcsnicmp( L"/debug", arg, 6 ) == 0 ) {
            continue;
        }

        //
        // Try to match the switch against the legal switches.
        //

        switchDesc = FindSwitchMatch( arg, Starting );
        if ( switchDesc == NULL ) {
            error = ERROR_INVALID_PARAMETER;
            goto err_exit;
        }

        //
        // Set the value in the field.
        //

        error = SetField( switchDesc, arg );
        if ( error != NO_ERROR ) {
            IF_DEBUG(INITIALIZATION_ERRORS) {
                SS_PRINT(( "SsParseCommandLine: SetField failed for switch "
                          "\"%ws\": %ld\n", arg, error ));
            }
            goto err_exit;
        }
    }

    error = NO_ERROR;
    goto normal_exit;

err_exit:

    //
    // Restore the original server settings.
    //

    RtlCopyMemory( &SsData, saveSsData, sizeof(SERVER_SERVICE_DATA) );

normal_exit:

    MIDL_user_free( saveSsData );

    return error;

} // SsParseCommandLine


PFIELD_DESCRIPTOR
FindSwitchMatch (
    IN LPWCH Argument,
    IN BOOLEAN Starting
    )

/*++

Routine Description:

    This routine tries to match a given switch against the possible
    switch values.

Arguments:

    Argument - a pointer to the text argument.

    Starting - TRUE if the command line is from server startup, i.e.
        net start server.  This is needed because some fields may only
        be set at startup.

Return Value:

    A pointer to a FIELD_DESCRIPTOR field from SsServerInfoFields[], or NULL if
    no valid match could be found.

--*/

{
    SHORT i;
    PFIELD_DESCRIPTOR foundSwitch = NULL;
    ULONG switchLength;
    LPWCH s;

    //
    // Ignore the leading /.
    //

    if ( *Argument != '/' ) {
        SS_PRINT(( "Invalid switch: %ws\n", Argument ));
        return NULL;
    }

    Argument++;

    //
    // Find out how long the passed-in switch is.
    //

    for ( s = Argument, switchLength = 0;
          *s != ':' && *s != '\0';
          s++, switchLength++ );

    //
    // Compare at most that many bytes.  We allow a minimal matching--
    // as long as the specified switch uniquely identifies a switch, then
    // is is usable.
    //

    for ( i = 0; SsServerInfoFields[i].FieldName != NULL; i++ ) {

        if ( _wcsnicmp( Argument, SsServerInfoFields[i].FieldName, switchLength ) == 0 ) {

            if ( SsServerInfoFields[i].Settable == NOT_SETTABLE ||
                 ( !Starting && SsServerInfoFields[i].Settable == SET_ON_STARTUP ) ) {

                SS_PRINT(( "Cannot set field %ws at this time.\n",
                            SsServerInfoFields[i].FieldName ));

                return NULL;
            }

            if ( foundSwitch != NULL ) {
                SS_PRINT(( "Ambiguous switch name: %ws (matches %ws and %ws)\n",
                            Argument-1, foundSwitch->FieldName,
                            SsServerInfoFields[i].FieldName ));
                return NULL;
            }

            foundSwitch = &SsServerInfoFields[i];
        }
    }

    if ( foundSwitch == NULL ) {
        SS_PRINT(( "Unknown argument: %ws\n", Argument-1 ));
    }

    return foundSwitch;

} // FindSwitchMatch


NET_API_STATUS
SetField (
    IN PFIELD_DESCRIPTOR Field,
    IN LPWCH Argument
    )

/*++

Routine Description:

    This routine sets the value of a server info parameter.

Arguments:

    Field - a pointer to the appropriate FIELD_DESCRIPTOR field
        from SsServerInfoFields[].

    Argument - a pointer to the text argument.  It should be of the form
        "/switch:value".

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    LPWCH valueStart;
    DWORD_PTR value;

    //
    // Find out where the ':' is in the argument.
    //

    valueStart = wcschr( Argument, L':' );

    if ( valueStart == NULL && Field->FieldType != BOOLEAN_FIELD ) {
        SS_PRINT(( "Invalid argument: %s\n", Argument ));
    }

    switch ( Field->FieldType ) {

    case BOOLEAN_FIELD:

        //
        // If the first character of the value is Y or there is no
        // value specified, set the field to TRUE, otherwise set it
        // to FALSE.
        //

        if ( valueStart == NULL || *(valueStart+1) == L'y' ||
                 *(valueStart+1) == L'Y' ) {
            value = TRUE;
        } else if ( *(valueStart+1) == L'n' || *(valueStart+1) == L'N' ) {
            value = FALSE;
        } else {
            return ERROR_INVALID_PARAMETER;
        }

        break;

    case DWORD_FIELD:
    {
        NTSTATUS status;
        UNICODE_STRING unicodeString;
        DWORD intValue;

        RtlInitUnicodeString( &unicodeString, valueStart + 1 );
        status = RtlUnicodeStringToInteger( &unicodeString, 0, &intValue );
        if ( !NT_SUCCESS(status) ) {
            return ERROR_INVALID_PARAMETER;
        }
        value = intValue;

        break;
    }
    case LPSTR_FIELD:

        value = (DWORD_PTR)( valueStart + 1 );
        break;
    }

    //
    // Call SsSetField to actually set the field.
    //

    return SsSetField( Field, &value, TRUE, NULL );

} // SetField
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\conn.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    Conn.c

Abstract:

    This module contains support for the Connection catagory of APIs for
    the NT server service.

Author:

    David Treadwell (davidtr)    23-Feb-1991

Revision History:

--*/

#include "srvsvcp.h"


NET_API_STATUS NET_API_FUNCTION
NetrConnectionEnum (
    IN LPTSTR ServerName,
    IN LPTSTR Qualifier,
    IN LPCONNECT_ENUM_STRUCT InfoStruct,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetConnectionEnum function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;

    ServerName;

    //
    // Make sure that the level is valid.  Since it is an unsigned
    // value, it can never be less than 0.
    //

    if ( InfoStruct->Level > 1 ) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // The qualifier cannot be null or can it be a null string
    //

    if ( Qualifier == NULL || *Qualifier == L'\0' ||
         InfoStruct->ConnectInfo.Level1 == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure that the caller is allowed to get connection
    // information in the server.
    //

    error = SsCheckAccess(
                &SsConnectionSecurityObject,
                SRVSVC_CONNECTION_INFO_GET
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Set up the input parameters in the request buffer.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    srp->Level = InfoStruct->Level;

#ifdef UNICODE
    RtlInitUnicodeString( &srp->Name1, Qualifier );
#else
    {
        OEM_STRING ansiString;
        NTSTATUS status;
        NetpInitOemString( &ansiString, Qualifier );
        status = RtlOemStringToUnicodeString( &srp->Name1, &ansiString, TRUE );
        SS_ASSERT( NT_SUCCESS(status) );
    }
#endif

    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        srp->Parameters.Get.ResumeHandle = *ResumeHandle;
    } else {
        srp->Parameters.Get.ResumeHandle = 0;
    }

    //
    // Get the data from the server.  This routine will allocate the
    // return buffer and handle the case where PreferredMaximumLength ==
    // -1.
    //

    error = SsServerFsControlGetInfo(
                FSCTL_SRV_NET_CONNECTION_ENUM,
                srp,
                (PVOID *)&InfoStruct->ConnectInfo.Level1->Buffer,
                PreferredMaximumLength
                );

    //
    // Set up return information.
    //

    InfoStruct->ConnectInfo.Level1->EntriesRead =
        srp->Parameters.Get.EntriesRead;
    *TotalEntries = srp->Parameters.Get.TotalEntries;

    if ( srp->Parameters.Get.EntriesRead > 0 &&
             ARGUMENT_PRESENT( ResumeHandle ) ) {
        *ResumeHandle = srp->Parameters.Get.ResumeHandle;
    }

#ifndef UNICODE
    RtlFreeUnicodeString( &srp->Name1 );
#endif

    SsFreeSrp( srp );

    return error;

} // NetrConnectionEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\dfs.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    Share.c

Abstract:

    This module contains support for the DFS catagory of APIs for the
    NT server service.

Revision History:

--*/

#include "srvsvcp.h"
#include "lmerr.h"
#include <dfsfsctl.h>
#include <dsgetdc.h>
#include <lmapibuf.h>           // NetApiBufferFree().

#define CAPTURE_STRING( Name ) \
    if( Name != NULL ) {                                \
        ULONG _size = SIZE_WSTR( Name );                \
        capture->Name = (LPWSTR)variableData;           \
        RtlCopyMemory( capture->Name, Name, _size );    \
        variableData += _size;                          \
        POINTER_TO_OFFSET( capture->Name, capture );    \
    }

#define RELATION_INFO_SIZE( RelInfo )                   \
    (sizeof( NET_DFS_ENTRY_ID_CONTAINER ) +             \
     (RelInfo->Count * sizeof(NET_DFS_ENTRY_ID)))

BOOLEAN
ValidateDfsEntryIdContainer(
    LPNET_DFS_ENTRY_ID_CONTAINER pRelationInfo);

NET_API_STATUS
DfsFsctl(
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN  ULONG OutputBufferLength
)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    HANDLE dfsHandle;
    UNICODE_STRING deviceName;

    deviceName.Buffer = DFS_SERVER_NAME;
    deviceName.MaximumLength = sizeof( DFS_SERVER_NAME );
    deviceName.Length = deviceName.MaximumLength  - sizeof(UNICODE_NULL);

    InitializeObjectAttributes(
        &objectAttributes,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    if( SsData.SsInitialized &&
      (status = RpcImpersonateClient(NULL)) != NO_ERROR ) {
        return (NET_API_STATUS) status;
    }

    status = NtCreateFile(
        &dfsHandle,
        SYNCHRONIZE | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if ( SsData.SsInitialized ) {
        (VOID)RpcRevertToSelf( );
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatus.Status;
    }

    if( !NT_SUCCESS( status ) ) {
        return (NET_API_STATUS)status;
    }

    status = NtFsControlFile(
                dfsHandle,
                NULL,       // Event,
                NULL,       // ApcRoutine,
                NULL,       // ApcContext,
                &ioStatus,
                FsControlCode,
                InputBuffer,
                InputBufferLength,
                OutputBuffer,
                OutputBufferLength
            );

    if(NT_SUCCESS(status)) {
        status = ioStatus.Status;
    }

    NtClose( dfsHandle );

    return (NET_API_STATUS)status;
}

NET_API_STATUS NET_API_FUNCTION
NetrDfsGetVersion(
    IN SRVSVC_HANDLE                   ServerName,
    OUT LPDWORD                        Version)
{
    DFS_GET_VERSION_ARG arg;
    NET_API_STATUS  error;

    RtlZeroMemory( &arg, sizeof(arg) );

    error = DfsFsctl( FSCTL_DFS_GET_VERSION, &arg, sizeof( arg ), NULL, 0 );

    if (error == NERR_Success) {

        *Version = arg.Version;

    } else {

        error = ERROR_FILE_NOT_FOUND;

    }

    return( error );

}

NET_API_STATUS NET_API_FUNCTION
NetrDfsCreateLocalPartition (
    IN SRVSVC_HANDLE                   ServerName,      // Name of server for this API
    IN LPWSTR                          ShareName,       // Name of share to add to the DFS
    IN LPGUID                          EntryUid,        // unique id for this partition
    IN LPWSTR                          EntryPrefix,     // DFS entry path for this volume
    IN LPWSTR                          ShortName,       // 8.3 format of EntryPrefix
    IN LPNET_DFS_ENTRY_ID_CONTAINER    RelationInfo,
    IN BOOL                            Force            // Force knowledge into consistent state?
    )
{
    NET_API_STATUS  error;
    PDFS_CREATE_LOCAL_PARTITION_ARG capture;
    ULONG           size = sizeof( *capture );
    ULONG           i;
    PCHAR           variableData;
    PSERVER_REQUEST_PACKET  srp;
    LPSHARE_INFO_2  shareInfo2 = NULL;
    UNICODE_STRING  ntSharePath;

    if( ShareName == NULL || EntryUid == NULL ||
        EntryPrefix == NULL || RelationInfo == NULL ||
            ValidateDfsEntryIdContainer(RelationInfo) == FALSE) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make a call to the SMB server to find the pathname for the share.
    //
    srp = SsAllocateSrp();
    if( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    };
    srp->Level = 2;
    srp->Flags = SRP_RETURN_SINGLE_ENTRY;
    srp->Parameters.Get.ResumeHandle = 0;
    RtlInitUnicodeString( &srp->Name1, ShareName );
    error = SsServerFsControlGetInfo(
                FSCTL_SRV_NET_SHARE_ENUM,
                srp,
                &shareInfo2,
                10000
            );
    if( error != NO_ERROR ) {
        SsFreeSrp( srp );
        return error;
    }

    if( srp->Parameters.Get.EntriesRead == 0 ||
        shareInfo2 == NULL ||
        shareInfo2->shi2_path == NULL ) {

        SsFreeSrp( srp );
        if( shareInfo2 != NULL ) {
            MIDL_user_free( shareInfo2 );
        }
        return ERROR_BAD_NET_NAME;
    }

    if( (shareInfo2->shi2_type & ~STYPE_SPECIAL) != STYPE_DISKTREE ) {
        SsFreeSrp( srp );
        MIDL_user_free( shareInfo2 );
        return ERROR_BAD_DEV_TYPE;
    }

    //
    // Now we need to convert the share's Win32 style pathname to an
    //  NT pathname
    //
    ntSharePath.Buffer = NULL;

    if( !RtlDosPathNameToNtPathName_U(
        shareInfo2->shi2_path,
        &ntSharePath,
        NULL,
        NULL ) ) {

        SsFreeSrp( srp );
        MIDL_user_free( shareInfo2 );
        return ERROR_INVALID_PARAMETER;
    }
    MIDL_user_free( shareInfo2 );

    //
    // Pack the data into an fsctl that can be sent to the local Dfs driver:
    //
    // First find the size...
    //
    size += SIZE_WSTR( ShareName );
    size += ntSharePath.Length + sizeof( WCHAR );
    size += SIZE_WSTR( EntryPrefix );
    size += SIZE_WSTR( ShortName );

    if( ARGUMENT_PRESENT( RelationInfo ) ) {
        size += RELATION_INFO_SIZE(RelationInfo);
        for( i = 0; i < RelationInfo->Count; i++ ) {
            size += SIZE_WSTR( RelationInfo->Buffer[i].Prefix );
        }
    }

    //
    // Now allocate the memory
    //
    capture = MIDL_user_allocate( size );
    if( capture == NULL ) {
        SsFreeSrp( srp );
        RtlFreeUnicodeString( &ntSharePath );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( capture, size );

    //
    // Put the fixed parameters in the capture buffer
    //
    capture->EntryUid = *EntryUid;
    capture->Force = (Force != FALSE);

    //
    // Put the variable data in the capture buffer.
    //

    variableData = (PCHAR)(capture + 1);

    if( ARGUMENT_PRESENT( RelationInfo ) ) {
        capture->RelationInfo = (LPNET_DFS_ENTRY_ID_CONTAINER)variableData;
        capture->RelationInfo->Buffer = (LPNET_DFS_ENTRY_ID)
                                            (capture->RelationInfo + 1);
        variableData += RELATION_INFO_SIZE( RelationInfo );
        for( i=0; i < RelationInfo->Count; i++ ) {
            CAPTURE_STRING( RelationInfo->Buffer[i].Prefix );
            capture->RelationInfo->Buffer[i].Uid = RelationInfo->Buffer[i].Uid;
        }

        POINTER_TO_OFFSET( capture->RelationInfo->Buffer, capture );
        POINTER_TO_OFFSET( capture->RelationInfo, capture );

    }

    CAPTURE_STRING( ShareName );
    CAPTURE_STRING( EntryPrefix );
    CAPTURE_STRING( ShortName );

    //
    // Capture the nt version of the share path
    //
    capture->SharePath = (LPWSTR)variableData;
    RtlCopyMemory( capture->SharePath, ntSharePath.Buffer, ntSharePath.Length );
    variableData += ntSharePath.Length;
    POINTER_TO_OFFSET( capture->SharePath, capture );

    *((WCHAR *)variableData) = 0;          // Null terminate the name
    variableData += sizeof( WCHAR );

    RtlFreeUnicodeString( &ntSharePath );

    //
    // First, tell the server to mark this share as being in Dfs. Note that
    //  the share name is already in srp->Name1. If we later run into an
    //  error, we'll undo the state change.
    //

    srp->Flags = SRP_SET_SHARE_IN_DFS;
    error = SsServerFsControl(
                FSCTL_SRV_SHARE_STATE_CHANGE,
                srp,
                NULL,
                0
            );
    if( error != NO_ERROR ) {
        SsFreeSrp( srp );
        MIDL_user_free( capture );
        return error;
    }

    //
    // Tell the Dfs driver!
    //
    error = DfsFsctl(
                FSCTL_DFS_CREATE_LOCAL_PARTITION,
                capture,
                size,
                NULL,
                0
            );

    MIDL_user_free( capture );

    if (error != NO_ERROR) {

        //
        // An error occured changing the Dfs state. So, try to undo the
        // server share state change.
        //

        NET_API_STATUS error2;

        srp->Flags = SRP_CLEAR_SHARE_IN_DFS;
        error2 = SsServerFsControl(
                    FSCTL_SRV_SHARE_STATE_CHANGE,
                    srp,
                    NULL,
                    0);

    }

    SsFreeSrp( srp );

    return error;
}

NET_API_STATUS NET_API_FUNCTION
NetrDfsDeleteLocalPartition (
    IN  SRVSVC_HANDLE               ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix
    )
{
    NET_API_STATUS error;
    PDFS_DELETE_LOCAL_PARTITION_ARG capture;
    ULONG   size = sizeof( *capture );
    PCHAR   variableData;

    //
    // Pack the args into a single buffer that can be sent to
    // the dfs driver:
    //

    //
    // First find the size...
    //
    size += SIZE_WSTR( Prefix );

    //
    // Now allocate the memory
    //
    capture = MIDL_user_allocate( size );
    if( capture == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( capture, size );

    //
    // Put the fixed parameters into the capture buffer
    //
    capture->Uid = *Uid;

    //
    // Put the variable data in the capture buffer
    //
    variableData = (PCHAR)(capture + 1 );

    CAPTURE_STRING( Prefix );

    //
    // Tell the driver!
    //
    error = DfsFsctl(
                FSCTL_DFS_DELETE_LOCAL_PARTITION,
                capture,
                size,
                NULL,
                0
            );

    MIDL_user_free( capture );

    //
    // If there was no error, tell the server that this share
    //   is no longer in the Dfs
    //


    return error;
}

NET_API_STATUS NET_API_FUNCTION
NetrDfsSetLocalVolumeState (
    IN  SRVSVC_HANDLE               ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       State
    )
{
    NET_API_STATUS error;
    PDFS_SET_LOCAL_VOLUME_STATE_ARG capture;
    ULONG   size = sizeof( *capture );
    PCHAR   variableData;

    //
    // Pack the args into a single buffer that can be sent to
    // the dfs driver:
    //

    //
    // First find the size...
    //
    size += SIZE_WSTR( Prefix );

    //
    // Now allocate the memory
    //
    capture = MIDL_user_allocate( size );
    if( capture == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( capture, size );

    //
    // Put the fixed parameters into the capture buffer
    //
    capture->Uid = *Uid;
    capture->State = State;

    //
    // Put the variable data in the capture buffer
    //
    variableData = (PCHAR)(capture + 1 );

    CAPTURE_STRING( Prefix );

    //
    // Tell the driver!
    //
    error = DfsFsctl(
                FSCTL_DFS_SET_LOCAL_VOLUME_STATE,
                capture,
                size,
                NULL,
                0
            );

    MIDL_user_free( capture );

    return error;
}

NET_API_STATUS NET_API_FUNCTION
NetrDfsSetServerInfo (
    IN  SRVSVC_HANDLE               ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix
    )
{
    NET_API_STATUS error;
    PDFS_SET_SERVER_INFO_ARG capture;
    ULONG   size = sizeof( *capture );
    PCHAR   variableData;

    //
    // Pack the args into a single buffer that can be sent to
    // the dfs driver:
    //

    //
    // First find the size...
    //
    size += SIZE_WSTR( Prefix );

    //
    // Now allocate the memory
    //
    capture = MIDL_user_allocate( size );
    if( capture == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( capture, size );

    //
    // Put the fixed parameters into the capture buffer
    //
    capture->Uid = *Uid;

    //
    // Put the variable data in the capture buffer
    //
    variableData = (PCHAR)(capture + 1 );

    CAPTURE_STRING( Prefix );

    //
    // Tell the driver!
    //
    error = DfsFsctl(
                FSCTL_DFS_SET_SERVER_INFO,
                capture,
                size,
                NULL,
                0
            );

    MIDL_user_free( capture );

    return error;
}

NET_API_STATUS NET_API_FUNCTION
NetrDfsCreateExitPoint (
    IN  SRVSVC_HANDLE               ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type,
    IN  ULONG                       ShortPrefixLen,
    OUT LPWSTR                      ShortPrefix
    )
{
    NET_API_STATUS error;
    PDFS_CREATE_EXIT_POINT_ARG capture;
    ULONG   size = sizeof( *capture );
    PCHAR   variableData;

    //
    // Pack the args into a single buffer that can be sent to
    // the dfs driver:
    //

    //
    // First find the size...
    //
    size += SIZE_WSTR( Prefix );

    //
    // Now allocate the memory
    //
    capture = MIDL_user_allocate( size );
    if( capture == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( capture, size );

    //
    // Put the fixed parameters into the capture buffer
    //
    capture->Uid = *Uid;
    capture->Type = Type;

    //
    // Put the variable data in the capture buffer
    //
    variableData = (PCHAR)(capture + 1 );

    CAPTURE_STRING( Prefix );

    //
    // Tell the driver!
    //
    error = DfsFsctl(
                FSCTL_DFS_CREATE_EXIT_POINT,
                capture,
                size,
                ShortPrefix,
                ShortPrefixLen * sizeof(WCHAR)
            );

    MIDL_user_free( capture );

    return error;
}

NET_API_STATUS NET_API_FUNCTION
NetrDfsDeleteExitPoint (
    IN  SRVSVC_HANDLE               ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type
    )
{
    NET_API_STATUS error;
    PDFS_DELETE_EXIT_POINT_ARG capture;
    ULONG   size = sizeof( *capture );
    PCHAR   variableData;

    //
    // Pack the args into a single buffer that can be sent to
    // the dfs driver:
    //

    //
    // First find the size...
    //
    size += SIZE_WSTR( Prefix );

    //
    // Now allocate the memory
    //
    capture = MIDL_user_allocate( size );
    if( capture == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( capture, size );

    //
    // Put the fixed parameters into the capture buffer
    //
    capture->Uid = *Uid;
    capture->Type = Type;

    //
    // Put the variable data in the capture buffer
    //
    variableData = (PCHAR)(capture + 1 );

    CAPTURE_STRING( Prefix );

    //
    // Tell the driver!
    //
    error = DfsFsctl(
                FSCTL_DFS_DELETE_EXIT_POINT,
                capture,
                size,
                NULL,
                0
            );

    MIDL_user_free( capture );

    return error;
}

NET_API_STATUS NET_API_FUNCTION
NetrDfsModifyPrefix (
    IN  SRVSVC_HANDLE               ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix
    )
{
    NET_API_STATUS error;
    PDFS_DELETE_LOCAL_PARTITION_ARG capture;
    ULONG   size = sizeof( *capture );
    PCHAR   variableData;

    //
    // Pack the args into a single buffer that can be sent to
    // the dfs driver:
    //

    //
    // First find the size...
    //
    size += SIZE_WSTR( Prefix );

    //
    // Now allocate the memory
    //
    capture = MIDL_user_allocate( size );
    if( capture == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( capture, size );

    //
    // Put the fixed parameters into the capture buffer
    //
    capture->Uid = *Uid;

    //
    // Put the variable data in the capture buffer
    //
    variableData = (PCHAR)(capture + 1 );

    CAPTURE_STRING( Prefix );

    //
    // Tell the driver!
    //
    error = DfsFsctl(
                FSCTL_DFS_MODIFY_PREFIX,
                capture,
                size,
                NULL,
                0
            );

    MIDL_user_free( capture );

    return error;
}

NET_API_STATUS NET_API_FUNCTION
NetrDfsFixLocalVolume (
    IN  SRVSVC_HANDLE                   ServerName,
    IN  LPWSTR                          VolumeName,
    IN  ULONG                           EntryType,
    IN  ULONG                           ServiceType,
    IN  LPWSTR                          StgId,
    IN  LPGUID                          EntryUid,       // unique id for this partition
    IN  LPWSTR                          EntryPrefix,    // path prefix for this partition
    IN  LPNET_DFS_ENTRY_ID_CONTAINER    RelationInfo,
    IN  ULONG                           CreateDisposition
    )
{
    NET_API_STATUS  error;
    PDFS_FIX_LOCAL_VOLUME_ARG capture;
    ULONG           size = sizeof( *capture );
    ULONG           i;
    PCHAR           variableData;

    if (ARGUMENT_PRESENT(RelationInfo) && ValidateDfsEntryIdContainer(RelationInfo) == FALSE)
        return ERROR_INVALID_PARAMETER;

    //
    // Pack the args into a single buffer that can be sent to the
    //  dfs driver:
    //

    //
    // First find the size...
    //
    size += SIZE_WSTR( VolumeName );
    size += SIZE_WSTR( StgId );
    size += SIZE_WSTR( EntryPrefix );

    if( ARGUMENT_PRESENT( RelationInfo ) ) {
        size += RELATION_INFO_SIZE( RelationInfo );
        for( i = 0; i < RelationInfo->Count; i++ ) {
            size += SIZE_WSTR( RelationInfo->Buffer[i].Prefix );
        }
    }

    //
    // Now allocate the memory
    //
    capture = MIDL_user_allocate( size );
    if( capture == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( capture, size );

    //
    // Put the fixed parameters in the capture buffer
    //
    capture->EntryType = EntryType;
    capture->ServiceType = ServiceType;
    capture->EntryUid = *EntryUid;
    capture->CreateDisposition = CreateDisposition;

    //
    // Put the variable data in the capture buffer.
    //

    variableData = (PCHAR)(capture + 1);

    if( ARGUMENT_PRESENT( RelationInfo ) ) {
        capture->RelationInfo = (LPNET_DFS_ENTRY_ID_CONTAINER)variableData;
        capture->RelationInfo->Buffer = (LPNET_DFS_ENTRY_ID)
                                            (capture->RelationInfo + 1);
        variableData += RELATION_INFO_SIZE( RelationInfo );
        for( i=0; i < RelationInfo->Count; i++ ) {
            CAPTURE_STRING( RelationInfo->Buffer[i].Prefix );
            capture->RelationInfo->Buffer[i].Uid = RelationInfo->Buffer[i].Uid;
        }

        POINTER_TO_OFFSET( capture->RelationInfo->Buffer, capture );
        POINTER_TO_OFFSET( capture->RelationInfo, capture );
    }

    CAPTURE_STRING( VolumeName );
    CAPTURE_STRING( StgId );
    CAPTURE_STRING( EntryPrefix );

    //
    // Tell the driver!
    //
    error = DfsFsctl(
                FSCTL_DFS_FIX_LOCAL_VOLUME,
                capture,
                size,
                NULL,
                0
            );

    MIDL_user_free( capture );

    return error;
}

//+----------------------------------------------------------------------------
//
//  NetrDfsManagerReportSiteInfo
//
//  Sends back the site(s) this server covers.
//
//  For debugging and other purposes, we first check a registry value with
//  the servername passed in.  If we get a match, we use the list of sites
//  in that value, and don't put our site in the list.  Otherwise we always
//  return our site (if available) and the sites in the default list.
//
//+----------------------------------------------------------------------------

NET_API_STATUS NET_API_FUNCTION
NetrDfsManagerReportSiteInfo (
    IN  SRVSVC_HANDLE               ServerName,
    OUT LPDFS_SITELIST_INFO         *ppSiteInfo
    )
{

    DWORD status;
    LPWSTR ThisSite = NULL;
    LPWSTR CoveredSites = NULL;
    LPDFS_SITELIST_INFO pSiteInfo = NULL;
    ULONG Size;
    ULONG cSites;
    LPWSTR pSiteName;
    LPWSTR pNames;
    ULONG iSite;
    ULONG j;
    DWORD dwType;
    DWORD dwUnused;
    ULONG cbBuffer;
    HKEY hkey;
    BOOLEAN fUsingDefault = TRUE;

    if (ppSiteInfo == NULL || ServerName == NULL) {

        return ERROR_INVALID_PARAMETER;

    }

    status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_KEY_COVERED_SITES,
                0,
                KEY_QUERY_VALUE,
                &hkey);

    if( status == ERROR_SUCCESS ) {

        status = RegQueryInfoKey(
                    hkey,                            // Key
                    NULL,                            // Class string
                    NULL,                            // Size of class string
                    NULL,                            // Reserved
                    &dwUnused,                       // # of subkeys
                    &dwUnused,                       // max size of subkey name
                    &dwUnused,                       // max size of class name
                    &dwUnused,                       // # of values
                    &dwUnused,                       // max size of value name
                    &cbBuffer,                       // max size of value data,
                    NULL,                            // security descriptor
                    NULL);                           // Last write time

        //
        // Check if there's a value the same name as the servername passed in,
        // if so, use it.  Else default to value REG_VALUE_COVERED_SITES.
        //

        if (status == ERROR_SUCCESS) {

            CoveredSites = MIDL_user_allocate(cbBuffer);

            if (CoveredSites != NULL) {

                status = RegQueryValueEx(
                                hkey,
                                ServerName,
                                NULL,
                                &dwType,
                                (PCHAR)CoveredSites,
                                &cbBuffer);

                if (status == ERROR_SUCCESS && dwType == REG_MULTI_SZ) {

                    fUsingDefault = FALSE;

                } else { 

                    status = RegQueryValueEx(
                                    hkey,
                                    REG_VALUE_COVERED_SITES,
                                    NULL,
                                    &dwType,
                                    (PCHAR)CoveredSites,
                                    &cbBuffer);

                    if ( status != ERROR_SUCCESS || dwType != REG_MULTI_SZ) {

                        MIDL_user_free(CoveredSites);

                        CoveredSites = NULL;

                    }

                }

            }

        }

        RegCloseKey( hkey );
    }

    //
    // Size the return buffer
    //

    Size = 0;

    for (cSites = 0, pNames = CoveredSites; pNames && *pNames; cSites++) {

        Size += (wcslen(pNames) + 1) * sizeof(WCHAR);

        pNames += wcslen(pNames) + 1;

    }

    //
    // Get site we belong to, if we're using the defaults
    //

    ThisSite = NULL;

    if (fUsingDefault == TRUE) {

        status = DsGetSiteName(NULL, &ThisSite);

        if (status == NO_ERROR && ThisSite != NULL) {

            Size += (wcslen(ThisSite) + 1) * sizeof(WCHAR);

            cSites++;

        }

    }

    //
    // If no sites are configured, and we couldn't determine our site,
    // then we fail.
    //

    if (cSites == 0) {

        status = ERROR_NO_SITENAME;

        goto ErrorReturn;

    }

    Size += FIELD_OFFSET(DFS_SITELIST_INFO,Site[cSites]);

    pSiteInfo = MIDL_user_allocate(Size);

    if (pSiteInfo == NULL) {

        status =  ERROR_NOT_ENOUGH_MEMORY;

        goto ErrorReturn;

    }

    RtlZeroMemory(pSiteInfo, Size);

    pSiteInfo->cSites = cSites;

    pSiteName = (LPWSTR) ((PCHAR)pSiteInfo +
                            sizeof(DFS_SITELIST_INFO) +
                                sizeof(DFS_SITENAME_INFO) * (cSites - 1));

    //
    // Marshall the site strings into the buffer
    //

    iSite = 0;

    if (ThisSite != NULL) {

        wcscpy(pSiteName, ThisSite);

        pSiteInfo->Site[iSite].SiteFlags = DFS_SITE_PRIMARY;

        pSiteInfo->Site[iSite++].SiteName = pSiteName;

        pSiteName += wcslen(ThisSite) + 1;

    }

    for (pNames = CoveredSites; pNames && *pNames; pNames += wcslen(pNames) + 1) {

        wcscpy(pSiteName, pNames);

        pSiteInfo->Site[iSite++].SiteName = pSiteName;

        pSiteName += wcslen(pSiteName) + 1;

    }

    *ppSiteInfo = pSiteInfo;

    if (CoveredSites != NULL) {

        MIDL_user_free(CoveredSites);

    }

    if (ThisSite != NULL) {

        NetApiBufferFree(ThisSite);

    }

    return status;

ErrorReturn:

    if (pSiteInfo != NULL) {

        MIDL_user_free(pSiteInfo);

    }
    
    if (CoveredSites != NULL) {

        MIDL_user_free(CoveredSites);

    }

    if (ThisSite != NULL) {

        NetApiBufferFree(ThisSite);

    }

    return status;

}


//
// This routine returns TRUE if this machine is the root of a DFS, FALSE otherwise
//
VOID
SsSetDfsRoot()
{
    NET_API_STATUS  error;

    error = DfsFsctl( FSCTL_DFS_IS_ROOT, NULL, 0, NULL, 0 );

    SsData.IsDfsRoot = (error == NO_ERROR);
}

//
// This routine checks the LPNET_DFS_ENTRY_ID_CONTAINER container
// for correctness.
//

BOOLEAN
ValidateDfsEntryIdContainer(
    LPNET_DFS_ENTRY_ID_CONTAINER pRelationInfo)
{
    ULONG iCount;

    if (pRelationInfo->Count > 0 && pRelationInfo->Buffer == NULL)
        return FALSE;

    for (iCount = 0; iCount < pRelationInfo->Count; iCount++) {
        if (pRelationInfo->Buffer[iCount].Prefix == NULL)
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\registry.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module contains registry _access routines for the NT server
    service.

Author:

    Chuck Lenzmeier (chuckl) 19-Mar-1992

Revision History:

--*/

#include "srvsvcp.h"
#include "ssreg.h"
#include "srvconfg.h"

#include <tstr.h>

#include <netevent.h>

//
// Simple MIN and MAX macros.  Watch out for side effects!
//

#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
#define MAX(a,b) ( ((a) < (b)) ? (b) : (a) )

#define MAX_INTEGER_STRING 32

#define MB * 1024 * 1024
#define INF 0xffffffff

//
// ( u, n )
// u is units to allocate for every n megabytes on a medium server.
//

#define CONFIG_TUPLE_SIZE 2
typedef struct {
    DWORD initworkitems[CONFIG_TUPLE_SIZE];
    DWORD maxworkitems[CONFIG_TUPLE_SIZE];
    DWORD rawworkitems[CONFIG_TUPLE_SIZE];
    DWORD maxrawworkitems[CONFIG_TUPLE_SIZE];
    DWORD maxpagedmemoryusage[CONFIG_TUPLE_SIZE];
    DWORD maxnonpagedmemoryusage[CONFIG_TUPLE_SIZE];
} CONFIG_SERVER_TABLE;

CONFIG_SERVER_TABLE MedSrvCfgTbl = {

//
// ** NOTE ** : If the second column is greater than 4, then
// you will need to add a check to make sure the statistic
// did not drop to zero.
//
//                          Units / MB
// Parameter
// ---------
//
/* initworkitems          */ { 1    , 4  },
/* maxworkitems           */ { 4    , 1  },
/* rawworkitems           */ { 1    , 4  },
/* maxrawworkitems        */ { 4    , 1  },
/* maxpagedmemoryusage    */ { 1    , 1  },
/* maxnonpagedmemoryusage */ { 1    , 8  },

};

//
// Minimum configuration system size is 8MB.  Anything lower treated
// as if 8 MB.
//

#define MIN_SYSTEM_SIZE                 8

//
// A medium server reaches its max at 32M.  A small server at 16M.
//

#define MAX_SMALL_SIZE                  16
#define MAX_MEDIUM_SIZE                 32

//
// Note that the user limit is always -1 (unlimited).  Autodisconnect
// always defaults to 15 minutes.
//

//
// Forward declarations
//

NTSTATUS
EnumerateStickyShare (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NET_API_STATUS
FillStickyShareInfo(
        IN PSRVSVC_SHARE_ENUM_INFO ShareEnumInfo,
        IN PSHARE_INFO_502 Shi502
        );

NTSTATUS
GetSdFromRegistry(
        IN PWSTR ValueName,
        IN ULONG ValueType,
        IN PVOID ValueData,
        IN ULONG ValueLength,
        IN PVOID Context,
        IN PVOID EntryContext
        );

BOOLEAN
GetStickyShareInfo (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    OUT PUNICODE_STRING RemarkString,
    OUT PUNICODE_STRING PathString,
    OUT PSHARE_INFO_502 shi502,
    OUT PDWORD CacheState
    );

LONG
LoadParameters (
    PWCH Path
    );

LONG
LoadSizeParameter (
    VOID
    );

NTSTATUS
RecreateStickyShare (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SaveSdToRegistry(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PWSTR ShareName
    );

NTSTATUS
SetSizeParameters (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SetStickyParameter (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

#define IsPersonal() IsSuiteVersion(VER_SUITE_PERSONAL)
#define IsWebBlade() IsSuiteVersion(VER_SUITE_BLADE)
#define IsEmbedded() IsSuiteVersion(VER_SUITE_EMBEDDEDNT)

BOOL
IsSuiteVersion(USHORT SuiteMask)
{
    OSVERSIONINFOEX Osvi;
    DWORD TypeMask;
    DWORDLONG ConditionMask;

    memset(&Osvi, 0, sizeof(OSVERSIONINFOEX));
    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    Osvi.wSuiteMask = SuiteMask;
    TypeMask = VER_SUITENAME;
    ConditionMask = 0;
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);
    return(VerifyVersionInfo(&Osvi, TypeMask, ConditionMask));
}




ULONG
SsRtlQueryEnvironmentLength (
    IN PVOID Environment
    )
{
    PWCH p;
    ULONG length;

    p = Environment;
    ASSERT( p != NULL );

    //
    // The environment variable block consists of zero or more null
    // terminated ASCII strings.  Each string is of the form:
    //
    //      name=value
    //
    // where the null termination is after the value.
    //

    while ( *p ) {
        while ( *p ) {
            p++;
        }
        p++;
    }
    p++;
    length = (ULONG)((PCHAR)p - (PCHAR)Environment);

    //
    // Return accumulated length.
    //

    return length;
}


VOID
SsAddParameterToRegistry (
    PFIELD_DESCRIPTOR Field,
    PVOID Value
    )
{
    NTSTATUS status;
    PWCH valueName;
    DWORD valueType;
    LPBYTE valuePtr;
    DWORD valueDataLength;

    //
    // The value name is the parameter name and the value data is the
    // parameter value.
    //

    valueName = Field->FieldName;

    switch ( Field->FieldType ) {

    case BOOLEAN_FIELD:
    case DWORD_FIELD:
        valueType = REG_DWORD;
        valuePtr = Value;
        valueDataLength = sizeof(DWORD);
        break;

    case LPSTR_FIELD:
        valueType = REG_SZ;
        valuePtr = *(LPBYTE *)Value;
        if ( valuePtr != NULL ) {
            valueDataLength = SIZE_WSTR( (PWCH)valuePtr );
        } else {
            valueDataLength = 0;
        }
        break;

    }

    //
    // Set the value into the Parameters key.
    //

    status = RtlWriteRegistryValue(
                RTL_REGISTRY_SERVICES,
                PARAMETERS_REGISTRY_PATH,
                valueName,
                valueType,
                valuePtr,
                valueDataLength
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddParameterToRegistry: SetValue failed: %lx; "
                        "parameter %ws won't stick\n", status, valueName ));
        }
    }

    return;

} // SsAddParameterToRegistry


VOID
SsAddShareToRegistry (
    IN PSHARE_INFO_2 ShareInfo2,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN DWORD CacheState
    )
{
    NTSTATUS status;
    PWCH valueName;
    PVOID environment;
    UNICODE_STRING nameString;
    UNICODE_STRING valueString;
    WCHAR integerString[MAX_INTEGER_STRING + 1];
    ULONG environmentLength;

    //
    // Build the value name and data strings.  The value name is the
    // share name (netname), while the value data is share information
    // in REG_MULTI_SZ format.  To build the value data, we use the
    // RTL environment routines.
    //

    valueName = ShareInfo2->shi2_netname;

    status = RtlCreateEnvironment( FALSE, &environment );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: CreateEnvironment failed: %lx; "
                        "share %ws won't stick\n", status, valueName ));
        }
        goto exit1;
    }

    RtlInitUnicodeString( &nameString, PATH_VARIABLE_NAME );
    RtlInitUnicodeString( &valueString, ShareInfo2->shi2_path );

    status = RtlSetEnvironmentVariable(
                &environment,
                &nameString,
                &valueString
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: SetEnvironment failed: %lx; "
                        "share %s won't stick\n", status, valueName ));
        }
        goto exit2;
    }

    if ( ShareInfo2->shi2_remark != NULL ) {

        RtlInitUnicodeString( &nameString, REMARK_VARIABLE_NAME );
        RtlInitUnicodeString( &valueString, ShareInfo2->shi2_remark );

        status = RtlSetEnvironmentVariable(
                    &environment,
                    &nameString,
                    &valueString
                    );
        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "SsAddShareToRegistry: SetEnvironment failed: %lx; "
                            "share %s won't stick\n", status, valueName ));
            }
            goto exit2;
        }

    }

    RtlInitUnicodeString( &nameString, TYPE_VARIABLE_NAME );
    valueString.Buffer = integerString;
    valueString.MaximumLength = (MAX_INTEGER_STRING + 1) * sizeof(WCHAR);
    status = RtlIntegerToUnicodeString(
                ShareInfo2->shi2_type,
                10,
                &valueString
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: IntegerToUnicode failed: %lx; "
                        "share %ws won't stick\n", status, valueName ));
        }
        goto exit2;
    }
    status = RtlSetEnvironmentVariable(
                &environment,
                &nameString,
                &valueString
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: SetEnvironment failed: %lx; "
                        "share %s won't stick\n", status, valueName ));
        }
        goto exit2;
    }

    RtlInitUnicodeString( &nameString, PERMISSIONS_VARIABLE_NAME );
    valueString.Buffer = integerString;
    valueString.MaximumLength = (MAX_INTEGER_STRING + 1) * sizeof(WCHAR);
    status = RtlIntegerToUnicodeString(
                ShareInfo2->shi2_permissions,
                10,
                &valueString
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: IntegerToUnicode failed: %lx; "
                        "share %ws won't stick\n", status, valueName ));
        }
        goto exit2;
    }
    status = RtlSetEnvironmentVariable(
                &environment,
                &nameString,
                &valueString
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: SetEnvironment failed: %lx; "
                        "share %s won't stick\n", status, valueName ));
        }
        goto exit2;
    }

    RtlInitUnicodeString( &nameString, MAXUSES_VARIABLE_NAME );
    valueString.Buffer = integerString;
    valueString.MaximumLength = (MAX_INTEGER_STRING + 1) * sizeof(WCHAR);
    status = RtlIntegerToUnicodeString(
                ShareInfo2->shi2_max_uses,
                10,
                &valueString
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: IntegerToUnicode failed: %lx; "
                        "share %ws won't stick\n", status, valueName ));
        }
        goto exit2;
    }
    status = RtlSetEnvironmentVariable(
                &environment,
                &nameString,
                &valueString
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: SetEnvironment failed: %lx; "
                        "share %s won't stick\n", status, valueName ));
        }
        goto exit2;
    }

    //
    // Set the CacheState
    //
    RtlInitUnicodeString( &nameString, CSC_VARIABLE_NAME );
    valueString.Buffer = integerString;
    valueString.MaximumLength = (MAX_INTEGER_STRING + 1) * sizeof(WCHAR);
    status = RtlIntegerToUnicodeString(
                    CacheState,
                    10,
                    &valueString
                    );
    if( !NT_SUCCESS( status ) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: IntegerToUnicode failed: %lx; "
                        "share %ws won't stick\n", status, valueName ));
        }
        goto exit2;
    }
    status = RtlSetEnvironmentVariable(
                &environment,
                &nameString,
                &valueString
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: SetEnvironment failed: %lx; "
                        "share %s won't stick\n", status, valueName ));
        }
        goto exit2;
    }

    //
    // Set the value into the Shares key.
    //

    environmentLength = SsRtlQueryEnvironmentLength( environment );
    status = RtlWriteRegistryValue(
                RTL_REGISTRY_SERVICES,
                SHARES_REGISTRY_PATH,
                valueName,
                REG_MULTI_SZ,
                (LPBYTE)environment,
                environmentLength
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsAddShareToRegistry: SetValue failed: %lx; share %ws "
                        "won't stick\n", status, valueName ));
        }
    }

    //
    // Save the file security descriptor
    //

    if ( ARGUMENT_PRESENT( SecurityDescriptor ) ) {

        status = SaveSdToRegistry(
                        SecurityDescriptor,
                        valueName
                        );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "SsAddShareToRegistry: SaveSd failed: %lx; share %ws\n"
                            , status, valueName ));
            }
        }
    }

exit2:
    RtlDestroyEnvironment( environment );

exit1:

    return;

} // SsAddShareToRegistry


NET_API_STATUS
SsCheckRegistry (
    VOID
    )

/*++

Routine Description:

    This function verifies that the keys used by the server exist.

Arguments:

    None.

Return Value:

    NET_API_STATUS - success/failure of the operation.

--*/

{
    NTSTATUS status;
    LPWSTR subStrings[1];

    //
    // Verify the existence of the main server service key.  If this
    // fails, the server service fails to start.
    //

    status = RtlCheckRegistryKey(
                RTL_REGISTRY_SERVICES,
                SERVER_REGISTRY_PATH
                );

    if ( !NT_SUCCESS(status) ) {

        subStrings[0] = SERVER_REGISTRY_PATH;
        SsLogEvent(
            EVENT_SRV_KEY_NOT_FOUND,
            1,
            subStrings,
            RtlNtStatusToDosError( status )
            );

        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "SsCheckRegistry: main key doesn't exist\n" ));
        }
        return ERROR_INVALID_PARAMETER; // !!! Need better error

    }

    //
    // Verify the existence of the Linkage subkey.  If this fails, the
    // server service fails to start.
    //

    status = RtlCheckRegistryKey(
                RTL_REGISTRY_SERVICES,
                LINKAGE_REGISTRY_PATH
                );

    if ( !NT_SUCCESS(status) ) {

        subStrings[0] = LINKAGE_REGISTRY_PATH;
        SsLogEvent(
            EVENT_SRV_KEY_NOT_FOUND,
            1,
            subStrings,
            RtlNtStatusToDosError( status )
            );

        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "SsCheckRegistry: Linkage subkey doesn't exist\n" ));
        }
        return ERROR_INVALID_PARAMETER; // !!! Need better error

    }

    //
    // If the Parameters subkey doesn't exist, create it.  If it can't
    // be created, fail to start the server.
    //

    status = RtlCheckRegistryKey(
                RTL_REGISTRY_SERVICES,
                PARAMETERS_REGISTRY_PATH
                );

    if ( !NT_SUCCESS(status) ) {

        status = RtlCreateRegistryKey(
                    RTL_REGISTRY_SERVICES,
                    PARAMETERS_REGISTRY_PATH
                    );

        if ( !NT_SUCCESS(status) ) {

            subStrings[0] = PARAMETERS_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_KEY_NOT_CREATED,
                1,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            IF_DEBUG(INITIALIZATION) {
                SS_PRINT(( "SsCheckRegistry: Can't create Parameters subkey: "
                            "%lx\n", status ));
            }
            return RtlNtStatusToDosError( status );

        }

    }

    //
    // Create the key holding the default security descriptors governing server APIs.
    //  Since we have compiled-in versions for these APIs, it is a non-fatal error
    //   if we cannot create this key.  But we log it anyway.
    //
    status = RtlCheckRegistryKey(
                RTL_REGISTRY_SERVICES,
                SHARES_DEFAULT_SECURITY_REGISTRY_PATH
                );

    if ( !NT_SUCCESS(status) ) {

        status = RtlCreateRegistryKey(
                    RTL_REGISTRY_SERVICES,
                    SHARES_DEFAULT_SECURITY_REGISTRY_PATH
                    );

        if ( !NT_SUCCESS(status) ) {

            subStrings[0] = SHARES_DEFAULT_SECURITY_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_KEY_NOT_CREATED,
                1,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            IF_DEBUG(INITIALIZATION) {
                SS_PRINT(( "SsCheckRegistry: Can't create DefaultSecurityRegistry subkey: "
                            "%lx\n", status ));
            }
        }
    }

    {

    LONG error;
    HKEY handle;
    GUID Guid;

    //
    // Make sure the GUID_VARIABLE_NAME value is there and contains a valid GUID.
    //

    error = RegOpenKeyEx(   HKEY_LOCAL_MACHINE,
                            FULL_PARAMETERS_REGISTRY_PATH,
                            0,
                            KEY_ALL_ACCESS,
                            &handle
                        );

    if( error == ERROR_SUCCESS ) {

        DWORD type;
        DWORD size = sizeof( Guid );

        error = RegQueryValueEx( handle,
                       GUID_VARIABLE_NAME,
                       NULL,
                       &type,
                       (LPBYTE)&Guid,
                       &size
                      );

        if( error != ERROR_SUCCESS ||
            type != REG_BINARY ||
            size != sizeof( Guid ) ) {

            RPC_STATUS RpcStatus;

            //
            // We could not read it, or it's not a valid UUID.
            //   Blow it away and reset
            //

            RegDeleteValue( handle, GUID_VARIABLE_NAME );

            RpcStatus = UuidCreate( &Guid );
            if( RpcStatus == RPC_S_OK || RpcStatus == RPC_S_UUID_LOCAL_ONLY ) {

                error = RegSetValueEx( handle,
                               GUID_VARIABLE_NAME,
                               0,
                               REG_BINARY,
                               (LPBYTE)&Guid,
                               sizeof( Guid )
                              );
            }

            SsNotifyRdrOfGuid( &Guid );
        }

        RegCloseKey( handle );
    } else {
        RtlZeroMemory( &Guid, sizeof( Guid ) );
    }

    SsData.ServerInfo598.sv598_serverguid = Guid;
    }

    //
    // If the AutotunedParameters subkey doesn't exist, create it.  If
    // it can't be created, fail to start the server.
    //

    status = RtlCheckRegistryKey(
                RTL_REGISTRY_SERVICES,
                AUTOTUNED_REGISTRY_PATH
                );

    if ( !NT_SUCCESS(status) ) {

        status = RtlCreateRegistryKey(
                    RTL_REGISTRY_SERVICES,
                    AUTOTUNED_REGISTRY_PATH
                    );

        if ( !NT_SUCCESS(status) ) {

            subStrings[0] = AUTOTUNED_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_KEY_NOT_CREATED,
                1,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            IF_DEBUG(INITIALIZATION) {
                SS_PRINT(( "SsCheckRegistry: Can't create AutotunedParameters "
                            "subkey: %lx\n", status ));
            }
            return RtlNtStatusToDosError( status );

        }

    }

    //
    // If the Shares subkey doesn't exist, create it.  If it can't be
    // created, fail to start the server.
    //

    status = RtlCheckRegistryKey(
                RTL_REGISTRY_SERVICES,
                SHARES_REGISTRY_PATH
                );

    if ( !NT_SUCCESS(status) ) {

        status = RtlCreateRegistryKey(
                    RTL_REGISTRY_SERVICES,
                    SHARES_REGISTRY_PATH
                    );

        if ( !NT_SUCCESS(status) ) {

            subStrings[0] = SHARES_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_KEY_NOT_CREATED,
                1,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            IF_DEBUG(INITIALIZATION) {
                SS_PRINT(( "SsCheckRegistry: Can't create Shares subkey: "
                            "%lx\n", status ));
            }
            return RtlNtStatusToDosError( status );

        }

    }

    //
    // If the Shares Security  subkey doesn't exist, create it.  If it
    // can't be created, fail to start the server.
    //

    status = RtlCheckRegistryKey(
                RTL_REGISTRY_SERVICES,
                SHARES_SECURITY_REGISTRY_PATH
                );

    if ( !NT_SUCCESS(status) ) {

        status = RtlCreateRegistryKey(
                    RTL_REGISTRY_SERVICES,
                    SHARES_SECURITY_REGISTRY_PATH
                    );

        if ( !NT_SUCCESS(status) ) {

            subStrings[0] = SHARES_SECURITY_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_KEY_NOT_CREATED,
                1,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            IF_DEBUG(INITIALIZATION) {
                SS_PRINT(( "SsCheckRegistry: Can't create Shares Security subkey: "
                            "%lx\n", status ));
            }
            return RtlNtStatusToDosError( status );

        }

    }


    //
    // All keys successfully checked.
    //

    return NO_ERROR;

} // SsCheckRegistry


NET_API_STATUS
SsEnumerateStickyShares (
    IN OUT PSRVSVC_SHARE_ENUM_INFO ShareEnumInfo
    )

/*++

Routine Description:

    Reads the registry to find and return sticky shares.

Arguments:

    ShareEnumInfo - points to a structure that contains the parameters
        to the NetShareEnumSticky call.

Return Value:

    NET_API_STATUS - success/failure of the operation.

--*/

{
    NTSTATUS status;
    PRTL_QUERY_REGISTRY_TABLE queryTable;

    ShareEnumInfo->TotalBytesNeeded = 0;
    ShareEnumInfo->TotalEntries = 0;
    ShareEnumInfo->EntriesRead = 0;

    //
    // Initialize the reserve fields.  This tells the callback routine,
    // how many times it has been called.
    //

    ShareEnumInfo->ShareEnumIndex = 0;
    ShareEnumInfo->StartOfFixedData = (PCHAR)ShareEnumInfo->OutputBuffer;
    ShareEnumInfo->EndOfVariableData = (PCHAR)ShareEnumInfo->OutputBuffer +
                            ShareEnumInfo->OutputBufferLength;

    //
    // We need to align it since we deal with unicode strings.
    //

    ShareEnumInfo->EndOfVariableData =
                    (PCHAR)((ULONG_PTR)ShareEnumInfo->EndOfVariableData & ~1);

    //
    // Ask the RTL to call us back for each value in the Shares key.
    //

    queryTable = MIDL_user_allocate( sizeof(RTL_QUERY_REGISTRY_TABLE) * 2 );

    if ( queryTable != NULL ) {

        queryTable[0].QueryRoutine = EnumerateStickyShare;
        queryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
        queryTable[0].Name = NULL;
        queryTable[0].EntryContext = NULL;
        queryTable[0].DefaultType = REG_NONE;
        queryTable[0].DefaultData = NULL;
        queryTable[0].DefaultLength = 0;

        queryTable[1].QueryRoutine = NULL;
        queryTable[1].Flags = 0;
        queryTable[1].Name = NULL;

        status = RtlQueryRegistryValues(
                    RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                    SHARES_REGISTRY_PATH,
                    queryTable,
                    ShareEnumInfo,
                    NULL
                    );

        MIDL_user_free( queryTable );

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "SsEnumerateStickyShares: RtlQueryRegistryValues "
                        "failed: %lx\n", status ));
        }
        return RtlNtStatusToDosError( status );
    }

    return NO_ERROR;

} // SsEnumerateStickyShares


NET_API_STATUS
SsLoadConfigurationParameters (
    VOID
    )

/*++

Routine Description:

    Reads the registry to get server configuration parameters.  These
    server parameters must be set before the server FSP has been
    started.

Arguments:

    None.

Return Value:

    NET_API_STATUS - success/failure of the operation.

--*/

{
    LONG error;

    //
    // Get the basic Size parameter, then load autotuned parameters,
    // then load manually set parameters.  This ordering allows manual
    // settings to override autotuning.
    //

    error = LoadSizeParameter( );

    if ( error == NO_ERROR ) {

        error = LoadParameters( AUTOTUNED_REGISTRY_PATH );

        if ( error == NO_ERROR ) {

            error = LoadParameters( PARAMETERS_REGISTRY_PATH );

        }

    }

    //
    // The copy read to MDL read switchover must occur at or below the
    // SMB buffer size.
    //

    SsData.ServerInfo598.sv598_mdlreadswitchover =
        MIN(
            SsData.ServerInfo598.sv598_mdlreadswitchover,
            SsData.ServerInfo599.sv599_sizreqbuf);

    //
    // If they want to require security signatures, it implies enabling them
    //
    if( SsData.ServerInfo598.sv598_requiresecuritysignature )
    {
        SsData.ServerInfo598.sv598_enablesecuritysignature = TRUE;
    }

    //
    // Override parameters that cannot be set on WinNT (vs. NTAS).
    //
    // The server itself also performs most of these overrides, in case
    // somebody figures out the FSCTL that changes parameters.  We also
    // override in the service in order to keep the service's view
    // consistent with the server's.  If you make any changes here, also
    // make them in srv\svcsrv.c.
    //

    // Embedded does its own parameter validation, so skip it here
    if( !IsEmbedded() )
    {
        if ( SsData.ServerInfo598.sv598_producttype == NtProductWinNt ) {

            //
            // On WinNT, the maximum value of certain parameters is fixed at
            // build time.  These include: concurrent users, SMB buffers,
            // and threads.
            //

    #define MINIMIZE(_param,_max) _param = MIN( _param, _max );

            MINIMIZE( SsData.ServerInfo102.sv102_users, MAX_USERS_WKSTA );
            MINIMIZE( SsData.ServerInfo599.sv599_maxworkitems, MAX_MAXWORKITEMS_WKSTA );
            MINIMIZE( SsData.ServerInfo598.sv598_maxthreadsperqueue, MAX_THREADS_WKSTA );
            SsData.ServerInfo599.sv599_maxmpxct = DEF_MAXMPXCT_WKSTA;

            if( IsPersonal() )
            {
                MINIMIZE( SsData.ServerInfo102.sv102_users, MAX_USERS_PERSONAL );
            }

            //
            // On WinNT, we do not cache closed RFCBs.
            //

            SsData.ServerInfo598.sv598_cachedopenlimit = 0;

            //
            // Sharing of redirected drives is not allowed on WinNT.
            //

            SsData.ServerInfo599.sv599_enablesharednetdrives = FALSE;

        }

        if( IsWebBlade() )
        {
            MINIMIZE( SsData.ServerInfo102.sv102_users, MAX_USERS_WEB_BLADE );
            MINIMIZE( SsData.ServerInfo599.sv599_maxworkitems, MAX_MAXWORKITEMS_WKSTA );
            MINIMIZE( SsData.ServerInfo598.sv598_maxthreadsperqueue, MAX_THREADS_WKSTA );
        }
    }
    else
    {
        // If this is a Class 1 basic embedded device, keep our memory consumption lower too
        if( SsData.ServerInfo102.sv102_users == MAX_USERS_EMBEDDED )
        {
            MINIMIZE( SsData.ServerInfo599.sv599_maxworkitems, MAX_MAXWORKITEMS_EMBEDDED );
            MINIMIZE( SsData.ServerInfo598.sv598_maxthreadsperqueue, MAX_THREADS_EMBEDDED );
            SsData.ServerInfo599.sv599_maxmpxct = DEF_MAXMPXCT_EMBEDDED;
        }
    }

    return error;

} // SsLoadConfigurationParameters


NET_API_STATUS
SsRecreateStickyShares (
    VOID
    )

/*++

Routine Description:

    Reads the registry to find and create sticky shares.

Arguments:

    None.

Return Value:

    NET_API_STATUS - success/failure of the operation.

--*/

{
    NTSTATUS status;
    PRTL_QUERY_REGISTRY_TABLE queryTable;
    ULONG IterationCount = 0;

    //
    // Ask the RTL to call us back for each value in the Shares key.
    //

    queryTable = MIDL_user_allocate( sizeof(RTL_QUERY_REGISTRY_TABLE) * 2 );

    if ( queryTable != NULL ) {

        queryTable[0].QueryRoutine = RecreateStickyShare;
        queryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
        queryTable[0].Name = NULL;
        queryTable[0].EntryContext = NULL;
        queryTable[0].DefaultType = REG_NONE;
        queryTable[0].DefaultData = NULL;
        queryTable[0].DefaultLength = 0;

        queryTable[1].QueryRoutine = NULL;
        queryTable[1].Flags = 0;
        queryTable[1].Name = NULL;

        status = RtlQueryRegistryValues(
                    RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                    SHARES_REGISTRY_PATH,
                    queryTable,
                    &IterationCount,
                    NULL
                    );

        MIDL_user_free( queryTable );

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "SsRecreateStickyShares: RtlQueryRegistryValues "
                        "failed: %lx\n", status ));
        }
        return RtlNtStatusToDosError( status );
    }

    return NO_ERROR;

} // SsRecreateStickyShares


NET_API_STATUS
SsRemoveShareFromRegistry (
    LPWSTR NetName
    )
{
    NET_API_STATUS error = NO_ERROR;
    NTSTATUS status;
    PWCH valueName;

    //
    // The value name is the share name.  Remove that value from the
    // Shares key.
    //

    valueName = NetName;

    //
    // Delete the share security
    //

    status = RtlDeleteRegistryValue(
                RTL_REGISTRY_SERVICES,
                SHARES_SECURITY_REGISTRY_PATH,
                valueName
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsRemoveShareFromRegistry: Delete Security value failed: %lx; "
                        "share %ws will return\n", status, valueName ));
        }
    }

    //
    // Delete the share
    //

    status = RtlDeleteRegistryValue(
                RTL_REGISTRY_SERVICES,
                SHARES_REGISTRY_PATH,
                valueName
                );
    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SsRemoveShareFromRegistry: DeleteValue failed: %lx; "
                        "share %ws will return\n", status, valueName ));
        }

        error = RtlNtStatusToDosError( status );
    }

    return error;

} // SsRemoveShareFromRegistry


VOID
BindToTransport (
    IN LPWSTR TransportName
    )
{
    NET_API_STATUS error;
    SERVER_TRANSPORT_INFO_0 svti0;

    RtlZeroMemory( &svti0, sizeof( svti0 ) );
    svti0.svti0_transportname = TransportName;
    svti0.svti0_transportaddress = SsData.SsServerTransportAddress;

    svti0.svti0_transportaddresslength =
        ComputeTransportAddressClippedLength(
            SsData.SsServerTransportAddress,
            SsData.SsServerTransportAddressLength );

    //
    // Bind to the transport.
    //

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "BindToTransport: binding to transport %ws\n", TransportName ));
    }


    error = I_NetrServerTransportAddEx( 0, (LPTRANSPORT_INFO)&svti0 );

    if ( error != NO_ERROR ) {

        DWORD eventId;
        LPWSTR subStrings[2];

        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SsBindToTransports: failed to bind to %ws: "
                        "%ld\n", TransportName, error ));
        }

        eventId = (error == ERROR_DUP_NAME || error == ERROR_INVALID_NETNAME ) ?
                            EVENT_SRV_CANT_BIND_DUP_NAME :
                            EVENT_SRV_CANT_BIND_TO_TRANSPORT;

        subStrings[0] = TransportName;
        SsLogEvent(
            eventId,
            1,
            subStrings,
            error
            );

    }

} // BindToTransport

NTSTATUS
BindOptionalNameToTransport (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    SERVER_TRANSPORT_INFO_0 sti;
    UCHAR serverName[ MAX_PATH ];
    UNICODE_STRING UnicodeName;
    NET_API_STATUS error;
    LPWSTR subStrings[2];
    ULONG namelen;

    subStrings[0] = (LPWSTR)ValueData;
    subStrings[1] = OPTIONAL_NAMES_VALUE_NAME;

    if( ValueType != REG_SZ ) {

        //
        // Not a string!
        //

        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            NO_ERROR
            );

        return STATUS_SUCCESS;
    }

    UnicodeName.Length = wcslen( (LPWSTR)ValueData ) * sizeof( WCHAR );
    UnicodeName.MaximumLength = UnicodeName.Length + sizeof( WCHAR );
    UnicodeName.Buffer = (LPWSTR)ValueData;

    error = ConvertStringToTransportAddress( &UnicodeName, serverName, &namelen );

    if( error != NO_ERROR ) {

        //
        // Invalid server name!
        //

        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            error
            );

        return STATUS_SUCCESS;
    }

    RtlZeroMemory( &sti, sizeof(sti) );
    sti.svti0_transportname = (LPWSTR)Context;
    sti.svti0_transportaddress = serverName;
    sti.svti0_transportaddresslength = namelen;

    error = I_NetrServerTransportAddEx( 0, (LPTRANSPORT_INFO)&sti );

    if ( error != NO_ERROR ) {

        //
        // Could not register the name!
        //

        subStrings[0] = (LPWSTR)ValueData;
        subStrings[1] = OPTIONAL_NAMES_VALUE_NAME;

        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            error
            );
    }

    return STATUS_SUCCESS;
}

VOID
BindOptionalNames (
    IN PWSTR TransportName
    )
{
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    NTSTATUS status;

    //
    //  We need to iterate over the optional names and bind them to this
    //  transport.
    //

    //
    // Now see if there any optional bindings we should perform
    //
    queryTable[0].QueryRoutine = BindOptionalNameToTransport;
    queryTable[0].Flags = 0;
    queryTable[0].Name = OPTIONAL_NAMES_VALUE_NAME;
    queryTable[0].EntryContext = NULL;
    queryTable[0].DefaultType = REG_NONE;
    queryTable[0].DefaultData = NULL;
    queryTable[0].DefaultLength = 0;

    queryTable[1].QueryRoutine = NULL;
    queryTable[1].Flags = 0;
    queryTable[1].Name = NULL;


    (void)RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                PARAMETERS_REGISTRY_PATH,
                queryTable,
                TransportName,
                NULL
                );

} // BindOptionalNames


NTSTATUS
EnumerateStickyShare (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    Callback routine for SsEnumerateStickyShare.  Routine will get information
    on share and fill in the output buffer.

Arguments:

    ValueName - Name of the share
    ValueType - Value type of the share name.
    ValueData - Data associated with the ValueName.
    Context - Pointer to our enum information structure.

Return Value:

    NET_API_STATUS - success/failure of the operation.

--*/
{

    NET_API_STATUS error;
    SHARE_INFO_502 shi502;
    UNICODE_STRING pathString;
    UNICODE_STRING remarkString;
    PSRVSVC_SHARE_ENUM_INFO enumInfo = (PSRVSVC_SHARE_ENUM_INFO) Context;
    DWORD cacheState;

    ValueLength, EntryContext;

    remarkString.Buffer = NULL;
    pathString.Buffer = NULL;

    if ( GetStickyShareInfo(
                        ValueName,
                        ValueType,
                        ValueData,
                        &remarkString,
                        &pathString,
                        &shi502,
                        &cacheState
                        ) ) {

        //
        // Do the actual add of the share.
        //

        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "EnumerateStickyShares: adding share %ws\n", ValueName ));
        }

        shi502.shi502_remark = remarkString.Buffer;
        shi502.shi502_path = pathString.Buffer;

        //
        // Skip until we have the right share to resume from
        //

        if ( (enumInfo->TotalEntries == 0) &&
             (enumInfo->ShareEnumIndex < enumInfo->ResumeHandle) ) {

            enumInfo->ShareEnumIndex++;

        } else {

            enumInfo->TotalEntries++;
            error = FillStickyShareInfo( enumInfo, &shi502 );

            if ( error != NO_ERROR ) {

                IF_DEBUG(REGISTRY) {
                    SS_PRINT(( "EnumerateStickyShares: failed to add share "
                                "%ws = %wZ: %ld\n", ValueName, &pathString, error ));
                }
            } else {
                enumInfo->EntriesRead++;
                enumInfo->ResumeHandle++;
            }
        }

        //
        // free buffers allocated by GetStickyShareInfo
        //

        if ( remarkString.Buffer != NULL ) {
            RtlFreeUnicodeString( &remarkString );
        }

        if ( pathString.Buffer != NULL ) {
            RtlFreeUnicodeString( &pathString );
        }

        if ( shi502.shi502_security_descriptor != NULL ) {
            MIDL_user_free( shi502.shi502_security_descriptor );
        }
    }

    return STATUS_SUCCESS;

} // EnumerateStickyShare


NTSTATUS
GetSdFromRegistry(
        IN PWSTR ValueName,
        IN ULONG ValueType,
        IN PVOID ValueData,
        IN ULONG ValueLength,
        IN PVOID Context,
        IN PVOID EntryContext
        )

{
    NTSTATUS status = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR fileSD = NULL;
    PSHARE_INFO_502 shi502 = (PSHARE_INFO_502) Context;
    LPWSTR subStrings[1];

    EntryContext, ValueName, ValueType;

    if ( ValueLength > 0 ) {

        fileSD = MIDL_user_allocate( ValueLength );

        if ( fileSD == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            RtlCopyMemory(
                    fileSD,
                    ValueData,
                    ValueLength
                    );

            if ( !RtlValidSecurityDescriptor( fileSD ) ) {

                subStrings[0] = ValueName;
                SsLogEvent(
                    EVENT_SRV_INVALID_SD,
                    1,
                    subStrings,
                    RtlNtStatusToDosError( status )
                    );

                MIDL_user_free( fileSD );
                fileSD = NULL;
                status = STATUS_INVALID_SECURITY_DESCR;
            }
        }
    }

    shi502->shi502_security_descriptor = fileSD;
    return(status);

} // GetSdFromRegistry


BOOLEAN
GetStickyShareInfo (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    OUT PUNICODE_STRING RemarkString,
    OUT PUNICODE_STRING PathString,
    OUT PSHARE_INFO_502 shi502,
    OUT PDWORD CacheState
    )

/*++

Routine Description:

    Gets share information from the registry.

Arguments:

    ValueName - Name of the share
    ValueType - Value type of the share name.
    ValueData - Data associated with the ValueName.
    RemarkString - Upon return, points to a unicode string containing the
        user remark for this share.
    PathString - Upon return, points to a unicode string containing the
        path for this share.
    shi502 - Upon return, points to a unicode string containing a
        SHARE_INFO_502 structure.

Return Value:

    TRUE, if share information successfully retrieved.
    FALSE, otherwise.

--*/

{

    NTSTATUS status;
    UNICODE_STRING variableNameString;
    WCHAR integerStringBuffer[35];
    UNICODE_STRING unicodeString;
    LPWSTR subStrings[2];

    PathString->Buffer = NULL;
    RemarkString->Buffer = NULL;

    shi502->shi502_security_descriptor = NULL;
    shi502->shi502_path = NULL;
    shi502->shi502_remark = NULL;
    shi502->shi502_reserved = 0;

    //
    // Because the NT server doesn't support share-level security, the
    // password is always NULL.
    //

    shi502->shi502_passwd = NULL;

    //
    // The value type must be REG_MULTI_SZ, and the value name must not
    // be null.
    //

    if ( (ValueType != REG_MULTI_SZ) ||
         (wcslen(ValueName) == 0) ) {

        subStrings[0] = ValueName;
        subStrings[1] = SHARES_REGISTRY_PATH;
        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            NO_ERROR
            );

        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "GetStickyShareInfo: skipping invalid value %ws\n",
                        ValueName ));
        }
        goto errorexit;

    }

    //
    // The share name is the value name.  The value data describes the
    // rest of the information about the share.
    //

    shi502->shi502_netname = ValueName;

    //
    // The REG_MULTI_SZ format is the same as that used for storing
    // environment variables.  Find known share parameters in the data.
    //
    // Get the share path.  It must be present.
    //

    RtlInitUnicodeString( &variableNameString, PATH_VARIABLE_NAME );

    PathString->MaximumLength = 0;
    status = RtlQueryEnvironmentVariable_U(
                ValueData,
                &variableNameString,
                PathString
                );
    if ( status != STATUS_BUFFER_TOO_SMALL ) {

        //
        // The path is not specified.  Ignore this share.
        //

        subStrings[0] = ValueName;
        subStrings[1] = SHARES_REGISTRY_PATH;
        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            RtlNtStatusToDosError( status )
            );

        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "GetStickyShareInfo: No path; ignoring share.\n" ));
        }
        goto errorexit;

    }

    PathString->MaximumLength = (USHORT)(PathString->Length + sizeof(WCHAR));
    PathString->Buffer = MIDL_user_allocate( PathString->MaximumLength );

    if ( PathString->Buffer == NULL ) {

        //
        // No space for path.  Ignore this share.
        //

        subStrings[0] = ValueName;
        subStrings[1] = SHARES_REGISTRY_PATH;
        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            ERROR_NOT_ENOUGH_MEMORY
            );

        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "GetStickyShareInfo: MIDL_user_allocate failed; ignoring "
                        "share.\n" ));
        }
        goto errorexit;

    }

    status = RtlQueryEnvironmentVariable_U(
                ValueData,
                &variableNameString,
                PathString
                );
    if ( !NT_SUCCESS(status) ) {

        //
        // Huh?  The second attempt failed.  Ignore this share.
        //

        subStrings[0] = ValueName;
        subStrings[1] = SHARES_REGISTRY_PATH;
        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            RtlNtStatusToDosError( status )
            );

        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "GetStickyShareInfo: Second query failed!  Ignoring "
                        "share.\n" ));
        }
        goto errorexit;

    }

    //
    // Get the remark.  It may be omitted.
    //

    RtlInitUnicodeString( &variableNameString, REMARK_VARIABLE_NAME );

    RemarkString->MaximumLength = 0;
    status = RtlQueryEnvironmentVariable_U(
                ValueData,
                &variableNameString,
                RemarkString
                );
    if ( status == STATUS_BUFFER_TOO_SMALL ) {

        RemarkString->MaximumLength =
                    (USHORT)(RemarkString->Length + sizeof(WCHAR));
        RemarkString->Buffer =
                    MIDL_user_allocate( RemarkString->MaximumLength );
        if ( RemarkString->Buffer == NULL ) {

            //
            // No space for remark.  Ignore this share.
            //

            subStrings[0] = ValueName;
            subStrings[1] = SHARES_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                ERROR_NOT_ENOUGH_MEMORY
                );

            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "GetStickyShareInfo: MIDL_user_allocate failed; ignoring "
                            "share.\n" ));
            }
            goto errorexit;

        }

        status = RtlQueryEnvironmentVariable_U(
                    ValueData,
                    &variableNameString,
                    RemarkString
                    );
        if ( !NT_SUCCESS(status) ) {

            //
            // Huh?  The second attempt failed.  Ignore this share.
            //

            subStrings[0] = ValueName;
            subStrings[1] = SHARES_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "GetStickyShareInfo: Second query failed!  "
                            "Ignoring share.\n" ));
            }
            goto errorexit;

        }

    }

    //
    // Get the share type.  It may be omitted.
    //

    RtlInitUnicodeString( &variableNameString, TYPE_VARIABLE_NAME );

    unicodeString.Buffer = integerStringBuffer;
    unicodeString.MaximumLength = 35;
    status = RtlQueryEnvironmentVariable_U(
                ValueData,
                &variableNameString,
                &unicodeString
                );
    if ( !NT_SUCCESS(status) ) {

        shi502->shi502_type = STYPE_DISKTREE;

    } else {

        status = RtlUnicodeStringToInteger(
                    &unicodeString,
                    0,
                    &shi502->shi502_type
                    );
        if ( !NT_SUCCESS(status) ) {

            subStrings[0] = ValueName;
            subStrings[1] = SHARES_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "GetStickyShareInfo: UnicodeToInteger failed: "
                            "%lx\n", status ));
            }
            goto errorexit;

        }

    }

    //
    // Get the share permissions.  It may be omitted.
    //

    RtlInitUnicodeString( &variableNameString, PERMISSIONS_VARIABLE_NAME );

    status = RtlQueryEnvironmentVariable_U(
                ValueData,
                &variableNameString,
                &unicodeString
                );
    if ( !NT_SUCCESS(status) ) {

        shi502->shi502_permissions = 0;

    } else {

        DWORD permissions;

        status = RtlUnicodeStringToInteger(
                    &unicodeString,
                    0,
                    &permissions
                    );

        if ( !NT_SUCCESS(status) ) {

            subStrings[0] = ValueName;
            subStrings[1] = SHARES_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "GetStickyShareInfo: UnicodeToInteger failed: "
                            "%lx\n", status ));
            }
            goto errorexit;

        }

        shi502->shi502_permissions = permissions;

    }

    //
    // Get the maximum number of uses allowed.  It may be omitted.
    //

    RtlInitUnicodeString( &variableNameString, MAXUSES_VARIABLE_NAME );

    status = RtlQueryEnvironmentVariable_U(
                ValueData,
                &variableNameString,
                &unicodeString
                );
    if ( !NT_SUCCESS(status) ) {

        shi502->shi502_max_uses = (DWORD)SHI_USES_UNLIMITED;

    } else {

        status = RtlUnicodeStringToInteger(
                    &unicodeString,
                    0,
                    &shi502->shi502_max_uses
                    );
        if ( !NT_SUCCESS(status) ) {

            subStrings[0] = ValueName;
            subStrings[1] = SHARES_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                RtlNtStatusToDosError( status )
                );

            goto errorexit;

        }

    }

    //
    // Get the Cacheing flags.  It may be omitted.
    //

    RtlInitUnicodeString( &variableNameString, CSC_VARIABLE_NAME );
    *CacheState = 0;

    status = RtlQueryEnvironmentVariable_U(
                ValueData,
                &variableNameString,
                &unicodeString
                );

    if( NT_SUCCESS( status ) ) {
        ULONG value;
        status = RtlUnicodeStringToInteger(
                    &unicodeString,
                    0,
                    &value
                    );
        if( NT_SUCCESS( status ) ) {

            *CacheState = (value & CSC_MASK);

        } else {

            subStrings[0] = ValueName;
            subStrings[1] = SHARES_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                RtlNtStatusToDosError( status )
                );
        }
    }

    {
        //
        // Get the Share file security descriptor
        //

        RTL_QUERY_REGISTRY_TABLE shareQueryTable[2];

        //
        // Fill up the query table
        //

        shareQueryTable[0].QueryRoutine = GetSdFromRegistry;
        shareQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
        shareQueryTable[0].Name = shi502->shi502_netname;
        shareQueryTable[0].EntryContext = NULL;
        shareQueryTable[0].DefaultType = REG_NONE;

        shareQueryTable[1].QueryRoutine = NULL;
        shareQueryTable[1].Flags = 0;
        shareQueryTable[1].Name = NULL;


        status = RtlQueryRegistryValues(
                                RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                SHARES_SECURITY_REGISTRY_PATH,
                                shareQueryTable,
                                shi502,
                                NULL
                                );

        if ( !NT_SUCCESS( status) &&
             ( status != STATUS_OBJECT_NAME_NOT_FOUND ) ) {
            ASSERT(0);
            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "GetStickyShareInfo: Get file SD: "
                            "%lx\n", status ));
            }
            goto errorexit;
        }
    }

    return TRUE;

errorexit:

    if ( RemarkString->Buffer != NULL ) {
        RtlFreeUnicodeString( RemarkString );
    }

    if ( PathString->Buffer != NULL ) {
        RtlFreeUnicodeString( PathString );
    }

    if ( shi502->shi502_security_descriptor != NULL ) {
        MIDL_user_free( shi502->shi502_security_descriptor );
    }

    return FALSE;

} // GetStickyShareInfo

BOOLEAN
SsGetDefaultSdFromRegistry (
    IN PWCH ValueName,
    OUT PSECURITY_DESCRIPTOR *FileSD
)
/*++

Routine Description:

    Reads 'ValueName' from the registry and gets the security descriptor
     stored there.

Arguments:

    ValueName - The name of the registry value in the Parameters section holding the descriptor
    FileSD - points to the allocated SD if one was obtained

Return Value:

    NTSTATUS - success/failure of the operation.

--*/
{
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    SHARE_INFO_502 shi502 = {0};
    NTSTATUS status;

    *FileSD = NULL;

    queryTable[0].QueryRoutine = GetSdFromRegistry;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = ValueName;
    queryTable[0].EntryContext = NULL;
    queryTable[0].DefaultType = REG_NONE;

    queryTable[1].QueryRoutine = NULL;
    queryTable[1].Flags = 0;
    queryTable[1].Name = NULL;

    status = RtlQueryRegistryValues(
                            RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                            SHARES_DEFAULT_SECURITY_REGISTRY_PATH,
                            queryTable,
                            &shi502,
                            NULL
                            );

    if ( NT_SUCCESS( status) ) {

        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "SsGetDefaultSdFromRegistry: using %ws SD from registry.\n",
                ValueName ));
        }

        *FileSD = shi502.shi502_security_descriptor;
        return TRUE;
    }

    return FALSE;
}

VOID
SsWriteDefaultSdToRegistry (
    IN PWCH ValueName,
    IN PSECURITY_DESCRIPTOR FileSD
)
/*++

Routine Description:

    Stores FileSD to 'ValueName' in the registry

Arguments:

    ValueName - The name of the registry value in the Parameters section holding the descriptor
    FileSD - points to the SD to write
--*/
{
    ULONG fileSDLength;

    if ( RtlValidSecurityDescriptor( FileSD ) ) {

        fileSDLength = RtlLengthSecurityDescriptor( FileSD );

        RtlWriteRegistryValue(
                    RTL_REGISTRY_SERVICES,
                    SHARES_DEFAULT_SECURITY_REGISTRY_PATH,
                    ValueName,
                    REG_BINARY,
                    (LPBYTE)FileSD,
                    fileSDLength
                    );
    }
}


LONG
LoadParameters (
    PWCH Path
    )

/*++

Routine Description:

    Reads the registry to get server parameters.

Arguments:

    Path - PARAMETERS_REGISTRY_PATH or AUTOTUNED_REGISTRY_PATH

Return Value:

    LONG - success/failure of the operation.

--*/

{
    NTSTATUS status;
    PRTL_QUERY_REGISTRY_TABLE queryTable;
    ULONG numberOfBindings = 0;

    //
    // Ask the RTL to call us back for each value in the appropriate
    // key.
    //

    queryTable = MIDL_user_allocate( sizeof(RTL_QUERY_REGISTRY_TABLE) * 2 );

    if ( queryTable != NULL ) {

        queryTable[0].QueryRoutine = SetStickyParameter;
        queryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
        queryTable[0].Name = NULL;
        queryTable[0].EntryContext = NULL;
        queryTable[0].DefaultType = REG_NONE;
        queryTable[0].DefaultData = NULL;
        queryTable[0].DefaultLength = 0;

        queryTable[1].QueryRoutine = NULL;
        queryTable[1].Flags = 0;
        queryTable[1].Name = NULL;

        status = RtlQueryRegistryValues(
                    RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                    Path,
                    queryTable,
                    Path,               // Context for SetStickyParameter
                    NULL
                    );

        MIDL_user_free( queryTable );

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "LoadParameters: RtlQueryRegistryValues failed: "
                        "%lx\n", status ));
        }
        return RtlNtStatusToDosError( status );
    }

    return NO_ERROR;

} // LoadParameters


LONG
LoadSizeParameter (
    VOID
    )

/*++

Routine Description:

    Reads the registry to get the basic server Size parameter.

Arguments:

    None.

Return Value:

    LONG - success/failure of the operation.

--*/

{
    NTSTATUS status;
    PRTL_QUERY_REGISTRY_TABLE queryTable;
    ULONG numberOfBindings = 0;

    //
    // Ask the RTL to call us back if the Size parameter exists.
    //

    queryTable = MIDL_user_allocate( sizeof(RTL_QUERY_REGISTRY_TABLE) * 2 );

    if ( queryTable != NULL ) {

        queryTable[0].QueryRoutine = SetSizeParameters;
        queryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
        queryTable[0].Name = SIZE_VALUE_NAME;
        queryTable[0].EntryContext = NULL;
        queryTable[0].DefaultType = REG_NONE;
        queryTable[0].DefaultData = NULL;
        queryTable[0].DefaultLength = 0;

        queryTable[1].QueryRoutine = NULL;
        queryTable[1].Flags = 0;
        queryTable[1].Name = NULL;

        status = RtlQueryRegistryValues(
                    RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                    PARAMETERS_REGISTRY_PATH,
                    queryTable,
                    NULL,
                    NULL
                    );

        MIDL_user_free( queryTable );

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "LoadSizeParameter: RtlQueryRegistryValues failed: "
                        "%lx\n", status ));
        }
        return RtlNtStatusToDosError( status );
    }

    return NO_ERROR;

} // LoadSizeParameter

VOID
PrintShareAnnounce (
    LPVOID event
    )
{
    ULONG i;

    //
    // Announce ourselves and then wait for awhile.
    // If the event gets signaled, terminate the loop and this thread.
    // But don't do this forever, since the print subsystem may actually
    //  get stuck
    //

    //
    // Do it for 15 minutes
    //
    for( i=0; i < 60; i++ ) {

        AnnounceServiceStatus( 1 );

        if( WaitForSingleObject( (HANDLE)event, 15*1000 ) != WAIT_TIMEOUT ) {
            break;
        }
    }
}


NTSTATUS
RecreateStickyShare (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PULONG IterationCount,
    IN PVOID EntryContext
    )
{

    NET_API_STATUS error;
    SHARE_INFO_502 shi502;
    SHARE_INFO shareInfo;
    UNICODE_STRING pathString;
    UNICODE_STRING remarkString;
    HANDLE threadHandle = NULL;
    HANDLE event = NULL;
    DWORD CacheState;
    SHARE_INFO shareInfoBuffer;
    SHARE_INFO_1005 si1005;

    ValueLength, EntryContext;

    remarkString.Buffer = NULL;
    pathString.Buffer = NULL;


    if ( GetStickyShareInfo(
                        ValueName,
                        ValueType,
                        ValueData,
                        &remarkString,
                        &pathString,
                        &shi502,
                        &CacheState
                        ) ) {

        //
        // Do the actual add of the share.
        //

        IF_DEBUG(INITIALIZATION) {
            SS_PRINT(( "RecreateStickyShares: adding share %ws\n", ValueName ));
        }

        shi502.shi502_remark = remarkString.Buffer;
        shi502.shi502_path = pathString.Buffer;

        shareInfo.ShareInfo502 = (LPSHARE_INFO_502_I)&shi502;

        if( shi502.shi502_type == STYPE_PRINTQ ) {
            //
            // A really big problem is that FAX printers can take aribitrarily long to
            //   complete the eventual OpenPrinter() call which the server will make back
            //   up to srvsvc.  And if we don't announce ourselves in the interval, the
            //   service controller will presume that we got stuck on startup.  Since
            //   NetrShareAdd() is synchronous, we need to get a different thread to
            //   announce our service status until NetrShareAdd returns.  So, start it
            //   now.  This is most unfortunate.

            event = CreateEvent( NULL, TRUE, FALSE, NULL );

            if( event != NULL ) {
                DWORD threadId;

                threadHandle = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)PrintShareAnnounce,
                                (LPVOID)event,
                                0,
                                &threadId
                                );
                if( threadHandle == NULL ) {
                    CloseHandle( event );
                    event = NULL;
                }
            }
        }

        //
        // RecreateStickyShare is called during server initialization.  The service
        //   controller will presume that we're stuck if we don't update our status
        //   with it often enough.  So every 64 recreated shares we call back to it.
        //   There's nothing magic about the 64 -- easy to check for, and not too often.
        //
        if( (shi502.shi502_type == STYPE_PRINTQ && threadHandle == NULL) ||
            (++(*IterationCount) & 63 ) == 0 ) {

            AnnounceServiceStatus( 1 );
        }

        error = NetrShareAdd( NULL, 502, &shareInfo, NULL );

        if( event != NULL ) {
            //
            // We created an announcement thread, set the event telling it to terminate
            //
            SetEvent( event );

            //
            // Wait for the thread to terminate
            //
            if( WaitForSingleObject( threadHandle, INFINITE ) == WAIT_FAILED ) {
                error = GetLastError();
            }

            //
            // Close the handles
            //
            CloseHandle( event );
            CloseHandle( threadHandle );
        }

        if ( error != NO_ERROR ) {

            IF_DEBUG(INITIALIZATION_ERRORS) {
                SS_PRINT(( "RecreateStickyShares: failed to add share "
                            "%ws = %wZ: %ld\n", ValueName, &pathString, error ));
            }
        }

        //
        // If this is a share which can be cached, set the caching flag in the server
        //
        si1005.shi1005_flags = CacheState;

        if( si1005.shi1005_flags ) {
            shareInfoBuffer.ShareInfo1005 = &si1005;
            NetrShareSetInfo( NULL, ValueName, 1005, &shareInfoBuffer, NULL );
        }

        //
        // free buffers allocated by GetStickyShareInfo
        //

        if ( remarkString.Buffer != NULL ) {
            RtlFreeUnicodeString( &remarkString );
        }

        if ( pathString.Buffer != NULL ) {
            RtlFreeUnicodeString( &pathString );
        }

        if ( shi502.shi502_security_descriptor != NULL ) {
            MIDL_user_free( shi502.shi502_security_descriptor );
        }
    }

    return NO_ERROR;

} // RecreateStickyShare


NTSTATUS
SaveSdToRegistry(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PWSTR ShareName
    )
/*++

Routine Description:

    Stores the share file security descriptor in the registry.

Arguments:

    SecurityDescriptor - Points to a self-relative security descriptor
        describing the access rights for files under this share.

    ShareName - Points to a string containing the share name under
        which the SD is to be stored.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS status;

    //
    // Store the security descriptor
    //

    ULONG fileSDLength;

    if ( !RtlValidSecurityDescriptor( SecurityDescriptor ) ) {

        status = STATUS_INVALID_SECURITY_DESCR;

    } else {

        fileSDLength = RtlLengthSecurityDescriptor( SecurityDescriptor );

        status = RtlWriteRegistryValue(
                    RTL_REGISTRY_SERVICES,
                    SHARES_SECURITY_REGISTRY_PATH,
                    ShareName,
                    REG_BINARY,
                    (LPBYTE)SecurityDescriptor,
                    fileSDLength
                    );

    }

    return status;

} // SaveSdToRegistry


NTSTATUS
SetSizeParameters (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NT_PRODUCT_TYPE productType;
    DWORD size;

    LPWSTR subStrings[2];

    ValueLength, Context, EntryContext;

    //
    // Get the product type.
    //

    if ( !RtlGetNtProductType( &productType ) ) {
        productType = NtProductWinNt;
    }

    SsData.ServerInfo598.sv598_producttype = productType;

    //
    // Make sure that we got called for the right value.
    //

    ASSERT( _wcsicmp( ValueName, SIZE_VALUE_NAME ) == 0 );

    //
    // The Size value must be a DWORD, and must be in the following
    // range:
    //
    //      0 -> use defaults
    //      1 -> small server (minimize memory usage)
    //      2 -> medium server (balance)
    //      3 -> large server (maximize connections)
    //

    if ( ValueType == REG_DWORD ) {
        ASSERT( ValueLength == sizeof(DWORD) );
        size = *(LPDWORD)ValueData;
    }

    if ( (ValueType != REG_DWORD) || (size > 3) ) {

        subStrings[0] = ValueName;
        subStrings[1] = PARAMETERS_REGISTRY_PATH;
        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            NO_ERROR
            );

        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SetSizeParameters: skipping invalid value "
                        "%ws\n", ValueName ));
        }
        return STATUS_SUCCESS;

    }

    SsData.ServerInfo598.sv598_serversize = size;

    //
    // Set appropriate fields based on the product type (Windows NT or
    // Advanced Server) and the selected Size.  Note that a Size of 0
    // doesn't change any of the defaults.
    //
    // Note that the user limit is always -1 (unlimited).  Autodisconnect
    // always defaults to 15 minutes.
    //

    if ( size != 0 ) {

        SYSTEM_BASIC_INFORMATION basicInfo;
        NTSTATUS status;
        ULONG noOfMb;
        ULONG factor;
        ULONG asFactor;

        //
        // Get system memory size.
        //

        status = NtQuerySystemInformation(
                                    SystemBasicInformation,
                                    &basicInfo,
                                    sizeof( SYSTEM_BASIC_INFORMATION ),
                                    NULL
                                    );


        if ( status != STATUS_SUCCESS ) {

            subStrings[0] = ValueName;
            subStrings[1] = PARAMETERS_REGISTRY_PATH;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                NO_ERROR
                );

            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "SetSizeParameters: NtQuerySystemInfo failed %x\n",
                            status ));
            }
            return STATUS_SUCCESS;

        }

        //
        // Note that we first divide the page size by 512 in order to
        // allow for physical memory sizes above 2^32-1.  With this
        // calculation, we can handle up to two terabytes of physical
        // memory.  The calculation assumes that the page size is at
        // least 512, and is not very accurate if the page size is not
        // a power of 2 (very unlikely).
        //

        ASSERT( basicInfo.PageSize >= 512 );

        noOfMb = (((basicInfo.PageSize / 512) *
                  basicInfo.NumberOfPhysicalPages) +
                  (1 MB / 512 - 1)) / (1 MB / 512);

        //
        // Minimum is 8 MB
        //

        noOfMb = MAX( MIN_SYSTEM_SIZE, noOfMb );

        //
        // If we have NTAS, and we're set to maximize performance or we have
        //  lots of memory -- then set the default work item buffer size to
        //  a larger value.  This value has been chosen to work well with our
        //  implementation of TCP/IP, and shows itself to advantage when doing
        //  directory emumerations with directories having lots of entries in them.
        //
        if( productType != NtProductWinNt && ((noOfMb >= 512) && (size == 3)) ) {

            SsData.ServerInfo599.sv599_sizreqbuf = DEF_LARGE_SIZREQBUF;
        }

        //
        // Set the maximum for the different sizes
        //

        if ( size == 1 ) {
            noOfMb = MIN( noOfMb, MAX_SMALL_SIZE );
        } else if ( size == 2 ) {
            noOfMb = MIN( noOfMb, MAX_MEDIUM_SIZE );
        }

        //
        // If small, assume the system size is half of the real one.
        // This should give us half the paramater values of a medium server.
        // If large, double it.  Also set the free connection count.
        //

        if ( size == 1 ) {

            //
            // Small
            //

            factor = (noOfMb + 1) / 2;

            SsData.ServerInfo599.sv599_minfreeconnections = 2;
            SsData.ServerInfo599.sv599_maxfreeconnections = 2;

        } else if ( size == 2 ) {

            //
            // Balanced
            //

            factor = noOfMb;

            SsData.ServerInfo599.sv599_minfreeconnections = 2;
            SsData.ServerInfo599.sv599_maxfreeconnections = 4;

        } else {

            //
            // Large
            //

            factor = noOfMb * 2;

            // Scale up our big servers, this uses the NEW version of small/med/large we picked
            // for the server service (< 1 GB, 1-16 GB, >16 GB)
            if( noOfMb < 1024  )
            {
                SsData.ServerInfo599.sv599_minfreeconnections = SRV_MIN_CONNECTIONS_SMALL;
                SsData.ServerInfo599.sv599_maxfreeconnections = SRV_MAX_CONNECTIONS_SMALL;
            }
            else if( noOfMb < 16*1024  )
            {
                // >= 1 GB memory
                SsData.ServerInfo599.sv599_minfreeconnections = SRV_MIN_CONNECTIONS_MEDIUM;
                SsData.ServerInfo599.sv599_maxfreeconnections = SRV_MAX_CONNECTIONS_MEDIUM;
            }
            else {
                // >= 16 GB memory
                SsData.ServerInfo599.sv599_minfreeconnections = SRV_MIN_CONNECTIONS_LARGE;
                SsData.ServerInfo599.sv599_maxfreeconnections = SRV_MAX_CONNECTIONS_LARGE;
            }
        }

        //
        // If this is an Advanced Server with at least 24M, some
        // parameter will need to be even bigger.
        //

        asFactor = 1;
        if ( (productType != NtProductWinNt) && (noOfMb >= 24) ) asFactor = 2;

        //
        // Now set the values for a medium server with this much memory.
        //

        SsData.ServerInfo599.sv599_maxworkitems =
                        MedSrvCfgTbl.maxworkitems[0] * factor * asFactor /
                        MedSrvCfgTbl.maxworkitems[1];

        SsData.ServerInfo599.sv599_initworkitems =
                        MedSrvCfgTbl.initworkitems[0] * factor * asFactor /
                        MedSrvCfgTbl.initworkitems[1];

        SsData.ServerInfo599.sv599_rawworkitems =
                        MedSrvCfgTbl.rawworkitems[0] * factor /
                        MedSrvCfgTbl.rawworkitems[1];

        SsData.ServerInfo598.sv598_maxrawworkitems =
                        MedSrvCfgTbl.maxrawworkitems[0] * factor * asFactor /
                        MedSrvCfgTbl.maxrawworkitems[1];

        SsData.ServerInfo599.sv599_maxworkitems =
            MIN( SsData.ServerInfo599.sv599_maxworkitems, MAX_MAXWORKITEMS );
        SsData.ServerInfo599.sv599_initworkitems =
            MIN( SsData.ServerInfo599.sv599_initworkitems, MAX_INITWORKITEMS/4 );
        SsData.ServerInfo599.sv599_rawworkitems =
            MIN( SsData.ServerInfo599.sv599_rawworkitems, MAX_RAWWORKITEMS/4 );
        SsData.ServerInfo598.sv598_maxrawworkitems =
            MIN( SsData.ServerInfo598.sv598_maxrawworkitems, MAX_MAXRAWWORKITEMS );

        if ( (productType != NtProductWinNt) || (size == 3) ) {
            SsData.ServerInfo599.sv599_maxpagedmemoryusage = INF;
            SsData.ServerInfo599.sv599_maxnonpagedmemoryusage = INF;
        } else {
            SsData.ServerInfo599.sv599_maxpagedmemoryusage =
                            MedSrvCfgTbl.maxpagedmemoryusage[0] * factor /
                            MedSrvCfgTbl.maxpagedmemoryusage[1] MB;

            SsData.ServerInfo599.sv599_maxpagedmemoryusage =
                MAX( SsData.ServerInfo599.sv599_maxpagedmemoryusage,
                     MIN_MAXPAGEDMEMORYUSAGE);

            SsData.ServerInfo599.sv599_maxnonpagedmemoryusage =
                            MedSrvCfgTbl.maxnonpagedmemoryusage[0] * factor /
                            MedSrvCfgTbl.maxnonpagedmemoryusage[1] MB;

            SsData.ServerInfo599.sv599_maxnonpagedmemoryusage =
                MAX( SsData.ServerInfo599.sv599_maxnonpagedmemoryusage,
                     MIN_MAXNONPAGEDMEMORYUSAGE);
        }
    }

    return STATUS_SUCCESS;

} // SetSizeParameters


NTSTATUS
SetStickyParameter (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NET_API_STATUS error;
    DWORD_PTR i;
    PFIELD_DESCRIPTOR foundField = NULL;
    LPWSTR subStrings[2];

    ValueLength, EntryContext;

    //
    // Ignore several parameters, since they are handled elsewhere
    //
    if(  (_wcsicmp( ValueName, SIZE_VALUE_NAME ) == 0)                ||
         (_wcsicmp( ValueName, NULL_SESSION_SHARES_VALUE_NAME ) == 0) ||
         (_wcsicmp( ValueName, NULL_SESSION_PIPES_VALUE_NAME ) == 0)  ||
         (_wcsicmp( ValueName, PIPES_NEED_LICENSE_VALUE_NAME ) == 0)  ||
         (_wcsicmp( ValueName, ERROR_LOG_IGNORE_VALUE_NAME ) == 0)    ||
         (_wcsicmp( ValueName, GUID_VARIABLE_NAME ) == 0)             ||
         (_wcsicmp( ValueName, OPTIONAL_NAMES_VALUE_NAME ) == 0)      ||
         (_wcsicmp( ValueName, NO_REMAP_PIPES_VALUE_NAME ) == 0)      ||
         (_wcsicmp( ValueName, SERVICE_DLL_VALUE_NAME ) == 0) ) {

        return STATUS_SUCCESS;
    }

    //
    // Determine which field we need to set, based on the value
    // name.
    //
    // NOTE: For Daytona, disc and comment are now invalid registry names.
    //      We use their more famous aliases autodisconnect and srvcomment
    //      instead.  If we get more of these cases, we should consider adding
    //      a field to the FIELD_DESCRIPTOR structure that indicates whether
    //      the names are should appear on the registry or not.  Any change
    //      here should also be made to SsSetField().
    //

    if ( (_wcsicmp( ValueName, DISC_VALUE_NAME ) != 0) &&
         (_wcsicmp( ValueName, COMMENT_VALUE_NAME ) != 0) ) {

        for ( i = 0;
              SsServerInfoFields[i].FieldName != NULL;
              i++ ) {

            if ( _wcsicmp( ValueName, SsServerInfoFields[i].FieldName ) == 0 ) {
                foundField = &SsServerInfoFields[i];
                break;
            }
        }
    }

    if ( foundField == NULL || foundField->Settable == NOT_SETTABLE ) {
#ifdef DBG
        subStrings[0] = ValueName;
        subStrings[1] = Context;
        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            NO_ERROR
            );

        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SetStickyParameter: ignoring %s \"%ws\"\n",
                        (foundField == NULL ? "unknown value name" :
                        "unsettable value"), ValueName ));
        }
#endif

        return STATUS_SUCCESS;

    }

    switch ( foundField->FieldType ) {

    case BOOLEAN_FIELD:
    case DWORD_FIELD:

        if ( ValueType != REG_DWORD ) {

            subStrings[0] = ValueName;
            subStrings[1] = Context;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                NO_ERROR
                );

            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "SetStickyParameter: skipping invalid value "
                            "%ws\n", ValueName ));
            }
            return STATUS_SUCCESS;

        }

        i = *(LPDWORD)ValueData;
        break;

    case LPSTR_FIELD:

        if ( ValueType != REG_SZ ) {

            subStrings[0] = ValueName;
            subStrings[1] = Context;
            SsLogEvent(
                EVENT_SRV_INVALID_REGISTRY_VALUE,
                2,
                subStrings,
                NO_ERROR
                );

            IF_DEBUG(REGISTRY) {
                SS_PRINT(( "SetStickyParameter: skipping invalid value "
                            "%ws\n", ValueName ));
            }
            return STATUS_SUCCESS;

        }

        if (ValueLength != 0) {
            i = (DWORD_PTR)ValueData;
        } else {
            i = (DWORD_PTR)NULL;
        }

        break;

    }

    //
    // Set the field.
    //

    error = SsSetField( foundField, &i, FALSE, NULL );

#ifdef DBG
    if ( error != NO_ERROR ) {
        subStrings[0] = ValueName;
        subStrings[1] = Context;
        SsLogEvent(
            EVENT_SRV_INVALID_REGISTRY_VALUE,
            2,
            subStrings,
            error
            );

        IF_DEBUG(REGISTRY) {
            SS_PRINT(( "SetStickyParameter: error %ld ignored in setting "
                        "parameter \"%ws\"n", error, ValueName ));
        }
    }
#endif

    return STATUS_SUCCESS;

} // SetStickyParameter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\internal.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    Internal.c

Abstract:

    This module contains "internal" APIs exported by the server service.

--*/

#include "srvsvcp.h"

#include <debugfmt.h>
#include <tstr.h>
#include <lmerr.h>


NET_API_STATUS NET_API_FUNCTION
I_NetrServerSetServiceBitsEx (
    IN LPTSTR ServerName,
    IN LPTSTR EmulatedServerName OPTIONAL,
    IN LPTSTR TransportName OPTIONAL,
    IN DWORD  ServiceBitsOfInterest,
    IN DWORD  ServiceBits,
    IN DWORD  UpdateImmediately
    )

/*++

Routine Description:

    This routine sets the value of the Server Type as sent in server
    announcement messages.  It is an internal API used only by the
    service controller.

Arguments:

    ServerName - Used by RPC to direct the call.  This API may only be
        issued locally.  This is enforced by the client stub.

    EmulatedServerName - server name being emulated on this computer

    TransportName - parameter optionally giving specific transport for which
        to set the bits

    ServiceBitsOfInterest - bit mask indicating significant 'ServiceBits'

    ServiceBits - Bits (preassigned to various components by Microsoft)
        indicating which services are active.  This field is not
        interpreted by the server service.

Return Value:

    NET_API_STATUS - NO_ERROR or ERROR_NOT_SUPPORTED.

--*/

{
    BOOL changed = FALSE;
    PNAME_LIST_ENTRY Service;
    PTRANSPORT_LIST_ENTRY transport;
    DWORD newBits;
    NET_API_STATUS error;
    CHAR serverNameBuf[ MAX_PATH ];
    PCHAR emulatedName;
    ULONG namelen;

    ServerName;     // avoid compiler warnings

    if( SsData.SsInitialized ) {
        error = SsCheckAccess(
                    &SsConfigInfoSecurityObject,
                    SRVSVC_CONFIG_INFO_SET
                    );

        if ( error != NO_ERROR ) {
            return ERROR_ACCESS_DENIED;
        }
    }

    if( ARGUMENT_PRESENT( EmulatedServerName ) ) {
        UNICODE_STRING name;

        RtlInitUnicodeString( &name, EmulatedServerName );

        error = ConvertStringToTransportAddress( &name, serverNameBuf, &namelen );
        if( error != NERR_Success ) {
            return error;
        }

        emulatedName = serverNameBuf;

    } else {

        emulatedName = SsData.SsServerTransportAddress;
        namelen = SsData.SsServerTransportAddressLength;
    }

    //
    // Don't let bits that are controlled by the server be set.
    //

    ServiceBitsOfInterest &= ~SERVER_TYPE_INTERNAL_BITS;
    ServiceBits &= ServiceBitsOfInterest;

    //
    // Make the modifications under control of the service resource.
    //

    (VOID)RtlAcquireResourceExclusive( &SsData.SsServerInfoResource, TRUE );

    if( SsData.SsServerNameList == NULL && !ARGUMENT_PRESENT( TransportName ) ) {

        //
        // We have not bound to any transports yet.
        // Remember the setting which is being asked for so we can use it later
        //

        SsData.ServiceBits &= ~ServiceBitsOfInterest;
        SsData.ServiceBits |= ServiceBits;
        RtlReleaseResource( &SsData.SsServerInfoResource );
        return NO_ERROR;
    }

    //
    // Find the entry for the server name of interest
    //
    for( Service = SsData.SsServerNameList; Service != NULL; Service = Service->Next ) {

        if( Service->TransportAddressLength != namelen ) {
            continue;
        }

        if( RtlEqualMemory( emulatedName, Service->TransportAddress, namelen ) ) {
            break;
         }
    }

    if( Service == NULL ) {
        RtlReleaseResource( &SsData.SsServerInfoResource );
        return NERR_NetNameNotFound;
    }

    //
    // Apply any saved ServiceBits
    //
    if( SsData.ServiceBits != 0 && Service->PrimaryName ) {
        Service->ServiceBits = SsData.ServiceBits;
        SsData.ServiceBits = 0;
    }

    if( ARGUMENT_PRESENT( TransportName ) ) {
        //
        // Transport name specified.  Set the bits for that transport only.
        //

        for( transport = Service->Transports; transport != NULL; transport = transport->Next ) {
            if( !STRCMPI( TransportName, transport->TransportName ) ) {
                //
                // This is the transport of interest!
                //
                if( (transport->ServiceBits & ServiceBitsOfInterest) != ServiceBits ) {
                    transport->ServiceBits &= ~ServiceBitsOfInterest;
                    transport->ServiceBits |= ServiceBits;
                    changed = TRUE;
                }
                break;
            }
        }
        if( transport == NULL ) {
            //
            // The requested transport was not found.
            //
            RtlReleaseResource( &SsData.SsServerInfoResource );
            return ERROR_PATH_NOT_FOUND;
        }

    } else {
        //
        // No transport name specified.  Change the bits for the whole server
        //

        if( ( Service->ServiceBits & ServiceBitsOfInterest ) != ServiceBits ) {
            Service->ServiceBits &= ~ServiceBitsOfInterest;
            Service->ServiceBits |= ServiceBits;
            changed = TRUE;

        }
    }

    RtlReleaseResource( &SsData.SsServerInfoResource );

    if ( changed ) {
        SsSetExportedServerType( NULL, TRUE, (BOOL)UpdateImmediately );
    }

    return NO_ERROR;

} // I_NetrServerSetServiceBits

NET_API_STATUS NET_API_FUNCTION
I_NetrServerSetServiceBits (
    IN LPTSTR ServerName,
    IN LPTSTR TransportName OPTIONAL,
    IN DWORD ServiceBits,
    IN DWORD UpdateImmediately
    )
{
    return I_NetrServerSetServiceBitsEx (
        ServerName,
        NULL,
        TransportName,
        0xFFFFFFFF, // All bits are of interest (just overlay the old bits)
        ServiceBits,
        UpdateImmediately
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\file.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    File.c

Abstract:

    This module contains support for the File catagory of APIs for the
    NT server service.

Author:

    David Treadwell (davidtr)    13-Feb-1991

Revision History:

--*/

#include "srvsvcp.h"

//
// Forward declarations.
//

NET_API_STATUS
FileEnumCommon (
    IN LPTSTR BasePath,
    IN LPTSTR UserName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL,
    IN BOOLEAN IsGetInfo
    );


NET_API_STATUS NET_API_FUNCTION
NetrFileClose (
    IN LPTSTR ServerName,
    IN DWORD FileId
    )

/*++

Routine Description:

    This routine communicates with the server FSD and FSP to implement the
    NetFileClose function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;

    ServerName;

    //
    // Make sure that the caller is allowed to close files in the server.
    //

    error = SsCheckAccess( &SsFileSecurityObject, SRVSVC_FILE_CLOSE );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Set up the request packet.  We use the name buffer pointer to
    // hold the file ID of the file to close.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    srp->Parameters.Get.ResumeHandle = FileId;

    //
    // Simply send the request on to the server.
    //

    error = SsServerFsControl( FSCTL_SRV_NET_FILE_CLOSE, srp, NULL, 0 );

    SsFreeSrp( srp );

    return error;

} // NetrFileClose


NET_API_STATUS NET_API_FUNCTION
NetrFileEnum (
    IN LPTSTR ServerName,
    IN LPTSTR BasePath,
    IN LPTSTR UserName,
    OUT PFILE_ENUM_STRUCT InfoStruct,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetFileEnum function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;

    ServerName;

    //
    // Make sure that the caller is allowed to set share information in the
    // server.
    //

    error = SsCheckAccess(
                &SsFileSecurityObject,
                SRVSVC_FILE_INFO_GET
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    if( InfoStruct->FileInfo.Level3 == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    return FileEnumCommon(
              BasePath,
              UserName,
              InfoStruct->Level,
              (LPBYTE *)&InfoStruct->FileInfo.Level3->Buffer,
              PreferredMaximumLength,
              &InfoStruct->FileInfo.Level3->EntriesRead,
              TotalEntries,
              ResumeHandle,
              FALSE
              );

} // NetrFileEnum


NET_API_STATUS NET_API_FUNCTION
NetrFileGetInfo (
    IN  LPTSTR ServerName,
    IN  DWORD FileId,
    IN  DWORD Level,
    OUT LPFILE_INFO InfoStruct
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetFileGetInfo function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    ULONG entriesRead;
    ULONG totalEntries;
    ULONG resumeHandle = FileId;

    ServerName;

    //
    // Make sure that the caller is allowed to get file information in the
    // server.
    //

    error = SsCheckAccess(
                &SsFileSecurityObject,
                SRVSVC_FILE_INFO_GET
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    error = FileEnumCommon(
                NULL,
                NULL,
                Level,
                (LPBYTE *)InfoStruct,
                (DWORD)-1,
                &entriesRead,
                &totalEntries,
                &resumeHandle,
                TRUE
                );

    if ( (error == NO_ERROR) && (entriesRead == 0) ) {
        return ERROR_FILE_NOT_FOUND;
    }

    SS_ASSERT( error != NO_ERROR || entriesRead == 1 );

    return error;

} // NetrFileGetInfo


NET_API_STATUS
FileEnumCommon (
    IN LPTSTR BasePath,
    IN LPTSTR UserName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL,
    IN BOOLEAN IsGetInfo
    )

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;

    //
    // Make sure that the level is valid.
    //

    if ( Level != 2 && Level != 3 ) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // Set up the input parameters in the request buffer.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#ifdef UNICODE
    RtlInitUnicodeString( &srp->Name1, BasePath );
    RtlInitUnicodeString( &srp->Name2, UserName );
#else
    {
        NTSTATUS status;
        OEM_STRING ansiString;
        RtlInitString( &ansiString, BasePath );
        status = RtlOemStringToUnicodeString( &srp->Name1, &ansiString, TRUE );
        RtlInitString( &ansiString, UserName );
        status = RtlOemStringToUnicodeString( &srp->Name2, &ansiString, TRUE );
    }
#endif

    srp->Level = Level;
    if ( IsGetInfo ) {
        srp->Flags = SRP_RETURN_SINGLE_ENTRY;
    }

    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        srp->Parameters.Get.ResumeHandle = *ResumeHandle;
    } else {
        srp->Parameters.Get.ResumeHandle = 0;
    }

    //
    // Get the data from the server.  This routine will allocate the
    // return buffer and handle the case where PreferredMaximumLength ==
    // -1.
    //

    error = SsServerFsControlGetInfo(
                FSCTL_SRV_NET_FILE_ENUM,
                srp,
                (PVOID *)Buffer,
                PreferredMaximumLength
                );

    //
    // Set up return information.  Only change the resume handle if at
    // least one entry was returned.
    //

    *EntriesRead = srp->Parameters.Get.EntriesRead;
    *TotalEntries = srp->Parameters.Get.TotalEntries;
    if ( *EntriesRead > 0 && ARGUMENT_PRESENT( ResumeHandle ) ) {
        *ResumeHandle = srp->Parameters.Get.ResumeHandle;
    }

#ifndef UNICODE
    RtlFreeUnicodeString( &srp->Name1 );
    RtlFreeUnicodeString( &srp->Name2 );
#endif

    SsFreeSrp( srp );

    return error;

} // FileEnumCommon
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\disk.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    disk.c

Abstract:

    This module contains support for the NetServerDiskEnum API for the NT
    OS/2 server service.

Author:

    Johnson Apacible (johnsona) 19-March-1992

Revision History:

--*/

#include "srvsvcp.h"

#include "nturtl.h"

#include "winbase.h"


NET_API_STATUS NET_API_FUNCTION
NetrServerDiskEnum(
    IN      LPTSTR                ServerName,
    IN      DWORD                 Level,
    IN OUT  DISK_ENUM_CONTAINER   *DiskInfoStruct,
    IN      DWORD                 PrefMaxLen,
    OUT     LPDWORD               TotalEntries,
    IN OUT  LPDWORD               ResumeHandle
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    server half of the NetServerDiskEnum function.

Arguments:

    ServerName - optional name of server.
    Level - must be 0
    DiskInfoStruct - the output buffer.
    PrefMaxLen - the preferred maximum length of the output buffer.
    TotalEntries - total number of drive entries in the output buffer.
    ResumeHandle - ignored.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    TCHAR diskName[4];
    UINT i;
    UINT driveType;
    UINT totalBytes = 0;
    LPTSTR tempBuffer;
    LPTSTR currentDiskInfo;

    ServerName, PrefMaxLen, ResumeHandle;

    //
    // The only valid level is 0.
    //

    if ( Level != 0 ) {
        return ERROR_INVALID_LEVEL;
    }

    if (DiskInfoStruct->Buffer != NULL) {
        // The InfoStruct is defined as a parameter. However the Buffer
        // parameter is only used as out. In these cases we need to free
        // the buffer allocated by RPC if the client had specified a non
        // NULL value for it.
        MIDL_user_free(DiskInfoStruct->Buffer);
        DiskInfoStruct->Buffer = NULL;
    }

    //
    // Make sure that the caller is allowed to get disk information from
    // the server.
    //

    error = SsCheckAccess(
                &SsDiskSecurityObject,
                SRVSVC_DISK_ENUM
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Go through all the driver letters, get those that does not return
    // an error.
    //

    tempBuffer = MIDL_user_allocate(
                    (SRVSVC_MAX_NUMBER_OF_DISKS * (3 * sizeof(TCHAR))) +
                    sizeof(TCHAR)
                    );

    if ( tempBuffer == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    currentDiskInfo = tempBuffer;

    diskName[0] = 'A';
    diskName[1] = ':';
    diskName[2] = '\\';
    diskName[3] = '\0';

    *TotalEntries = 0;

    for ( i = 0; i < SRVSVC_MAX_NUMBER_OF_DISKS; i++ ) {

        driveType = SsGetDriveType( diskName );

        if ( driveType == DRIVE_FIXED ||
             driveType == DRIVE_CDROM ||
             driveType == DRIVE_REMOVABLE ||
             driveType == DRIVE_RAMDISK ) {

            //
            // This is a valid disk
            //

            (*TotalEntries)++;
            *(currentDiskInfo++) = diskName[0];
            *(currentDiskInfo++) = ':';
            *(currentDiskInfo++) = '\0';

        }

        diskName[0]++;

    }

#ifdef UNICODE
    *currentDiskInfo = UNICODE_NULL;
#else
    *currentDiskInfo = '\0';
#endif

    //
    // EntriesRead must be one greater than TotalEntries so RPC can
    // marshal the output strings back to the client correctly.
    //

    totalBytes = ((*TotalEntries) * (3 * sizeof(TCHAR))) + sizeof(TCHAR);

    DiskInfoStruct->EntriesRead = (*TotalEntries) + 1;
    DiskInfoStruct->Buffer = MIDL_user_allocate( totalBytes );

    if ( DiskInfoStruct->Buffer != NULL ) {
        RtlCopyMemory(
            DiskInfoStruct->Buffer,
            tempBuffer,
            totalBytes
            );
    } else {
        MIDL_user_free(tempBuffer);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    MIDL_user_free( tempBuffer );

    return NO_ERROR;

} // NetrServerDiskEnum


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\security.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Data and routines for managing API security in the server service.

Author:

    David Treadwell (davidtr)   28-Aug-1991

Revision History:

    05/00 (dkruse) - Added code to handle upgrading SD's and RestrictAnonymous changes

--*/

#include "srvsvcp.h"
#include "ssreg.h"

#include <lmsname.h>
#include <netlibnt.h>

#include <debugfmt.h>

#include <seopaque.h>
#include <sertlp.h>
#include <sddl.h>

//
// Global security objects.
//
//     ConfigInfo - NetServerGetInfo, NetServerSetInfo
//     Connection - NetConnectionEnum
//     Disk       - NetServerDiskEnum
//     File       - NetFile APIs
//     Session    - NetSession APIs
//     Share      - NetShare APIs (file, print, and admin types)
//     Statistics - NetStatisticsGet, NetStatisticsClear
//

SRVSVC_SECURITY_OBJECT SsConfigInfoSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsConnectionSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsDiskSecurityObject;
SRVSVC_SECURITY_OBJECT SsFileSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsSessionSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsShareFileSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsSharePrintSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsShareAdminSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsShareConnectSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsShareAdmConnectSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsStatisticsSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsDefaultShareSecurityObject = {0};
SRVSVC_SECURITY_OBJECT SsTransportEnumSecurityObject = {0};
BOOLEAN SsRestrictNullSessions = FALSE;
BOOLEAN SsUpgradeSecurityDescriptors = FALSE;
BOOLEAN SsRegenerateSecurityDescriptors = FALSE;

GENERIC_MAPPING SsConfigInfoMapping = {
    STANDARD_RIGHTS_READ |                 // Generic read
        SRVSVC_CONFIG_USER_INFO_GET  |
        SRVSVC_CONFIG_ADMIN_INFO_GET,
    STANDARD_RIGHTS_WRITE |                // Generic write
        SRVSVC_CONFIG_INFO_SET,
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    SRVSVC_CONFIG_ALL_ACCESS               // Generic all
    };

GENERIC_MAPPING SsConnectionMapping = {
    STANDARD_RIGHTS_READ |                 // Generic read
        SRVSVC_CONNECTION_INFO_GET,
    STANDARD_RIGHTS_WRITE |                // Generic write
        0,
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    SRVSVC_CONNECTION_ALL_ACCESS           // Generic all
    };

GENERIC_MAPPING SsDiskMapping = {
    STANDARD_RIGHTS_READ |                 // Generic read
        SRVSVC_DISK_ENUM,
    STANDARD_RIGHTS_WRITE |                // Generic write
        0,
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    SRVSVC_DISK_ALL_ACCESS                 // Generic all
    };

GENERIC_MAPPING SsFileMapping = {
    STANDARD_RIGHTS_READ |                 // Generic read
        SRVSVC_FILE_INFO_GET,
    STANDARD_RIGHTS_WRITE |                // Generic write
        SRVSVC_FILE_CLOSE,
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    SRVSVC_FILE_ALL_ACCESS                 // Generic all
    };

GENERIC_MAPPING SsSessionMapping = {
    STANDARD_RIGHTS_READ |                 // Generic read
        SRVSVC_SESSION_USER_INFO_GET |
        SRVSVC_SESSION_ADMIN_INFO_GET,
    STANDARD_RIGHTS_WRITE |                // Generic write
        SRVSVC_SESSION_DELETE,
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    SRVSVC_SESSION_ALL_ACCESS              // Generic all
    };

GENERIC_MAPPING SsShareMapping = {
    STANDARD_RIGHTS_READ |                 // Generic read
        SRVSVC_SHARE_USER_INFO_GET |
        SRVSVC_SHARE_ADMIN_INFO_GET,
    STANDARD_RIGHTS_WRITE |                // Generic write
        SRVSVC_SHARE_INFO_SET,
    STANDARD_RIGHTS_EXECUTE |              // Generic execute
        SRVSVC_SHARE_CONNECT,
    SRVSVC_SHARE_ALL_ACCESS                // Generic all
    };

GENERIC_MAPPING SsShareConnectMapping = GENERIC_SHARE_CONNECT_MAPPING;

GENERIC_MAPPING SsStatisticsMapping = {
    STANDARD_RIGHTS_READ |                 // Generic read
        SRVSVC_STATISTICS_GET,
    STANDARD_RIGHTS_WRITE,                 // Generic write
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    SRVSVC_STATISTICS_ALL_ACCESS           // Generic all
    };

//
// Forward declarations.
//

NET_API_STATUS
CreateSecurityObject (
    PSRVSVC_SECURITY_OBJECT SecurityObject,
    LPTSTR ObjectName,
    PGENERIC_MAPPING Mapping,
    PACE_DATA AceData,
    ULONG AceDataLength,
    BOOLEAN bUpgradeSD
    );

NET_API_STATUS
CreateConfigInfoSecurityObject (
    VOID
    );

NET_API_STATUS
CreateConnectionSecurityObject (
    VOID
    );

NET_API_STATUS
CreateDiskSecurityObject (
    VOID
    );

NET_API_STATUS
CreateFileSecurityObject (
    VOID
    );

NET_API_STATUS
CreateSessionSecurityObject (
    VOID
    );

NET_API_STATUS
CreateShareSecurityObjects (
    VOID
    );

NET_API_STATUS
CreateStatisticsSecurityObject (
    VOID
    );

VOID
DeleteSecurityObject (
    PSRVSVC_SECURITY_OBJECT SecurityObject
    );

NET_API_STATUS
CheckNullSessionAccess(
    VOID
    );

BOOLEAN
AppendAllowedAceToSelfRelativeSD(
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pNewSid,
    PISECURITY_DESCRIPTOR pOldSD,
    PSECURITY_DESCRIPTOR* ppNewSD
    );

BOOLEAN
DoesAclContainSid(
    PACL pAcl,
    PSID pSid,
    OPTIONAL ACCESS_MASK* pMask
    );

NTSTATUS
QueryRegDWord(
    PCWSTR Path,
    PCWSTR ValueName,
    LPDWORD lpResult
    );

NTSTATUS
SetRegDWord(
    ULONG RelativeTo,
    PCWSTR Path,
    PCWSTR ValueName,
    DWORD Value
    );


NET_API_STATUS
SsCreateSecurityObjects (
    VOID
    )

/*++

Routine Description:

    Sets up the objects that will be used for security in the server
    service APIs.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS status;
    NTSTATUS NtStatus;
    DWORD dwUpgrade;
    DWORD dwOldRestrictAnonymous;
    BOOLEAN bUpdateRestrictAnonymous = FALSE;

    // Check whether we need to upgrade security descriptors
    // If the key exists, the upgrade has been done
    NtStatus = QueryRegDWord( FULL_SECURITY_REGISTRY_PATH, ANONYMOUS_UPGRADE_NAME, &dwUpgrade );
    if( !NT_SUCCESS(NtStatus) )
    {
        SsUpgradeSecurityDescriptors = TRUE;
    }

    //
    // Check whether or not to restrict null session access.
    //
    status = CheckNullSessionAccess();
    if (status != NO_ERROR) {
        return(status);
    }

    //
    // Check whether we need to regenerate the SD's because our RestrictAnonymous value changed
    //
    NtStatus = QueryRegDWord( FULL_SECURITY_REGISTRY_PATH, SAVED_ANONYMOUS_RESTRICTION_NAME, &dwOldRestrictAnonymous );
    if( NT_SUCCESS(NtStatus) )
    {
        if( dwOldRestrictAnonymous != (DWORD)SsRestrictNullSessions )
        {
            SsRegenerateSecurityDescriptors = TRUE;
            bUpdateRestrictAnonymous = TRUE;
        }
    }
    else
    {
        bUpdateRestrictAnonymous = TRUE;
        if( !SsUpgradeSecurityDescriptors )
        {
            SsRegenerateSecurityDescriptors = TRUE;
        }
    }

    //
    // Create ConfigInfo security object.
    //

    status = CreateConfigInfoSecurityObject( );
    if ( status != NO_ERROR ) {
        return status;
    }

    //
    // Create Connection security object.
    //

    status = CreateConnectionSecurityObject( );
    if ( status != NO_ERROR ) {
        return status;
    }

    //
    // Create Disk security object.
    //

    status = CreateDiskSecurityObject( );
    if ( status != NO_ERROR ) {
        return status;
    }

    //
    // Create File security object.
    //

    status = CreateFileSecurityObject( );
    if ( status != NO_ERROR ) {
        return status;
    }

    //
    // Create Session security object.
    //

    status = CreateSessionSecurityObject( );
    if ( status != NO_ERROR ) {
        return status;
    }

    //
    // Create Share security object.
    //

    status = CreateShareSecurityObjects( );
    if ( status != NO_ERROR ) {
        return status;
    }

    //
    // Create Statistics security object.
    //

    status = CreateStatisticsSecurityObject( );
    if ( status != NO_ERROR ) {
        return status;
    }

    // We upgraded them, so we don't need to do it anymore
    // Mark that in the registry
    if( SsUpgradeSecurityDescriptors )
    {
        NtStatus = SetRegDWord( RTL_REGISTRY_SERVICES, ABBREVIATED_SECURITY_REGISTRY_PATH, ANONYMOUS_UPGRADE_NAME, (DWORD)1 );
        if( !NT_SUCCESS(NtStatus) )
        {
            return NetpNtStatusToApiStatus(NtStatus);
        }
    }

    // Update the database value to the new one if necessary, or add it the first time
    if( bUpdateRestrictAnonymous )
    {
        NtStatus = SetRegDWord( RTL_REGISTRY_SERVICES, ABBREVIATED_SECURITY_REGISTRY_PATH, SAVED_ANONYMOUS_RESTRICTION_NAME, (DWORD)SsRestrictNullSessions );
        if( !NT_SUCCESS(NtStatus) )
        {
            return NetpNtStatusToApiStatus(NtStatus);
        }
    }

    return NO_ERROR;

} // SsCreateSecurityObjects


VOID
SsDeleteSecurityObjects (
    VOID
    )

/*++

Routine Description:

    Deletes server service security objects.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Delete ConfigInfo security objects.
    //

    DeleteSecurityObject( &SsConfigInfoSecurityObject );
    DeleteSecurityObject( &SsTransportEnumSecurityObject );

    //
    // Delete Connection security object.
    //

    DeleteSecurityObject( &SsConnectionSecurityObject );

    //
    // Delete File security object.
    //

    DeleteSecurityObject( &SsFileSecurityObject );

    //
    // Delete Session security object.
    //

    DeleteSecurityObject( &SsSessionSecurityObject );

    //
    // Delete Share security objects.
    //

    DeleteSecurityObject( &SsShareFileSecurityObject );
    DeleteSecurityObject( &SsSharePrintSecurityObject );
    DeleteSecurityObject( &SsShareAdminSecurityObject );
    DeleteSecurityObject( &SsShareConnectSecurityObject );
    DeleteSecurityObject( &SsShareAdmConnectSecurityObject );
    DeleteSecurityObject( &SsDefaultShareSecurityObject );


    //
    // Delete Statistics security object.
    //

    DeleteSecurityObject( &SsStatisticsSecurityObject );

    return;

} // SsDeleteSecurityObjects


NET_API_STATUS
SsCheckAccess (
    IN PSRVSVC_SECURITY_OBJECT SecurityObject,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    Calls NetpAccessCheckAndAudit to verify that the caller of an API
    has the necessary access to perform the requested operation.

Arguments:

    SecurityObject - a pointer to the server service security object
        that describes the security on the relevant object.

    DesiredAccess - the access needed to perform the requested operation.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;

    IF_DEBUG(SECURITY) {
        SS_PRINT(( "SsCheckAccess: validating object " FORMAT_LPTSTR ", "
                    "access %lx\n",
                    SecurityObject->ObjectName, DesiredAccess ));
    }

    error = NetpAccessCheckAndAudit(
                SERVER_DISPLAY_NAME,
                SecurityObject->ObjectName,
                SecurityObject->SecurityDescriptor,
                DesiredAccess,
                SecurityObject->Mapping
                );

    if ( error != NO_ERROR ) {
        IF_DEBUG(ACCESS_DENIED) {
            SS_PRINT(( "SsCheckAccess: NetpAccessCheckAndAudit failed for "
                        "object " FORMAT_LPTSTR ", access %lx: %ld\n",
                        SecurityObject->ObjectName, DesiredAccess, error ));
        }
    } else {
        IF_DEBUG(SECURITY) {
            SS_PRINT(( "SsCheckAccess: allowed access for " FORMAT_LPTSTR ", "
                        "access %lx\n",
                        SecurityObject->ObjectName, DesiredAccess ));
        }
    }

    return error;

} // SsCheckAccess


NET_API_STATUS
CreateSecurityObject (
    PSRVSVC_SECURITY_OBJECT SecurityObject,
    LPTSTR ObjectName,
    PGENERIC_MAPPING Mapping,
    PACE_DATA AceData,
    ULONG AceDataLength,
    BOOLEAN bUpgradeSD
    )
{
    NTSTATUS status;

    //
    // Set up security object.
    //

    SecurityObject->ObjectName = ObjectName;
    SecurityObject->Mapping = Mapping;

    //
    // Create security descriptor. If we can load it from the registry, then use it.
    //  Else use the compiled-in value
    //

    // Get the existing SD from the registry, unless we are supposed to regenerate them due to RestrictAnonymous changing
    if( SsRegenerateSecurityDescriptors || !SsGetDefaultSdFromRegistry( ObjectName, &SecurityObject->SecurityDescriptor ) ) {

        status = NetpCreateSecurityObject(
                     AceData,
                     AceDataLength,
                     SsData.SsLmsvcsGlobalData->LocalSystemSid,
                     SsData.SsLmsvcsGlobalData->LocalSystemSid,
                     Mapping,
                     &SecurityObject->SecurityDescriptor
                     );

        if( NT_SUCCESS( status ) ) {
            //
            // Write the value to the registry, since it wasn't there already.
            // Ignore any errors.
            //
            SsWriteDefaultSdToRegistry( ObjectName, SecurityObject->SecurityDescriptor );

        } else {

            IF_DEBUG(INITIALIZATION_ERRORS) {
                SS_PRINT(( "CreateSecurityObject: failed to create " FORMAT_LPTSTR
                            " object: %lx\n", ObjectName, status ));
            }

            return NetpNtStatusToApiStatus( status );
        }
    }
    else
    {
        if( bUpgradeSD )
        {
            // We need to check if the security descriptor needs to be updated
            PACL pAcl;
            BOOL bDaclPresent, bDaclDefault;
            ACCESS_MASK AccessMask;

            if( !GetSecurityDescriptorDacl( SecurityObject->SecurityDescriptor, &bDaclPresent, &pAcl, &bDaclDefault ) )
            {
                return ERROR_INVALID_ACL;
            }

            if( bDaclPresent )
            {
                // If they have authenticated users set, but they're not restricting NULL sessions, add in the World and the Anonymous token.
                // If they have the World set but not Anonymous and we're not restricting NULL sessions, add Anonymous
                // Note that DoesAclContainSid does NOT alter AccessMask if the Sid is not contained, so we can rest assured that if the condition
                //   is satisfied, AccessMask will contain a valid value.
                if( ( DoesAclContainSid( pAcl, SsData.SsLmsvcsGlobalData->AuthenticatedUserSid, &AccessMask ) ||
                      DoesAclContainSid( pAcl, SsData.SsLmsvcsGlobalData->WorldSid, &AccessMask ) ) &&
                    !SsRestrictNullSessions )
                {
                    PSECURITY_DESCRIPTOR pNewSD;


                    if( !DoesAclContainSid( pAcl, SsData.SsLmsvcsGlobalData->WorldSid, NULL ) )
                    {
                        if( !AppendAllowedAceToSelfRelativeSD( 0, AccessMask, SsData.SsLmsvcsGlobalData->WorldSid, SecurityObject->SecurityDescriptor, &pNewSD ) )
                        {
                            return NetpNtStatusToApiStatus( STATUS_INVALID_SECURITY_DESCR );
                        }

                        MIDL_user_free( SecurityObject->SecurityDescriptor );
                        SecurityObject->SecurityDescriptor = pNewSD;

                        if( !GetSecurityDescriptorDacl( SecurityObject->SecurityDescriptor, &bDaclPresent, &pAcl, &bDaclDefault ) )
                        {
                            return ERROR_INVALID_ACL;
                        }
                    }

                    if( !DoesAclContainSid( pAcl, SsData.SsLmsvcsGlobalData->AnonymousLogonSid, NULL ) )
                    {
                        if( !AppendAllowedAceToSelfRelativeSD( 0, AccessMask, SsData.SsLmsvcsGlobalData->AnonymousLogonSid, SecurityObject->SecurityDescriptor, &pNewSD ) )
                        {
                            return NetpNtStatusToApiStatus( STATUS_INVALID_SECURITY_DESCR );
                        }

                        MIDL_user_free( SecurityObject->SecurityDescriptor );
                        SecurityObject->SecurityDescriptor = pNewSD;
                    }

                    // Write the updated SID to the registry
                    SsWriteDefaultSdToRegistry( ObjectName, SecurityObject->SecurityDescriptor );
                }
            }
        }
    }

    IF_DEBUG(INITIALIZATION) {
        SS_PRINT(( "CreateSecurityObject: created " FORMAT_LPTSTR " object.\n",
                    ObjectName ));
    }

    return NO_ERROR;

} // CreateSecurityObject


NET_API_STATUS
CreateConfigInfoSecurityObject (
    VOID
    )
{
    PACE_DATA pAceData;
    ULONG AceSize;
    NET_API_STATUS netStatus;

    //
    // Required access for getting and setting server information.
    //

    ACE_DATA ConfigInfoAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->LocalSystemSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONFIG_USER_INFO_GET | SRVSVC_CONFIG_POWER_INFO_GET,
                            &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONFIG_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONFIG_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AnonymousLogonSid}
    };

    ACE_DATA ConfigInfoAceDataRestricted[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->LocalSystemSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONFIG_USER_INFO_GET | SRVSVC_CONFIG_POWER_INFO_GET,
                            &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONFIG_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AuthenticatedUserSid}
    };

    ACE_DATA TransportEnumAceData[] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->LocalSystemSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONFIG_USER_INFO_GET | SRVSVC_CONFIG_POWER_INFO_GET,
                            &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONFIG_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AuthenticatedUserSid}
    };

    if( SsRestrictNullSessions )
    {
        pAceData = ConfigInfoAceDataRestricted;
        AceSize = sizeof(ConfigInfoAceDataRestricted)/sizeof(ACE_DATA);
    }
    else
    {
        pAceData = ConfigInfoAceData;
        AceSize = sizeof(ConfigInfoAceData)/sizeof(ACE_DATA);
    }

    //
    // Create ConfigInfo security object.
    //

    netStatus = CreateSecurityObject(
                &SsConfigInfoSecurityObject,
                SRVSVC_CONFIG_INFO_OBJECT,
                &SsConfigInfoMapping,
                pAceData,
                AceSize,
                SsUpgradeSecurityDescriptors
                );

    if( netStatus != NO_ERROR )
    {
        return netStatus;
    }

    pAceData = TransportEnumAceData;
    AceSize = sizeof(TransportEnumAceData)/sizeof(ACE_DATA);

    return CreateSecurityObject(
                &SsTransportEnumSecurityObject,
                SRVSVC_TRANSPORT_INFO_OBJECT,
                &SsConfigInfoMapping,
                pAceData,
                AceSize,
                SsUpgradeSecurityDescriptors
                );
} // CreateConfigInfoSecurityObject


NET_API_STATUS
CreateConnectionSecurityObject (
    VOID
    )
{
    //
    // Required access for getting and setting Connection information.
    //

    ACE_DATA ConnectionAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONNECTION_INFO_GET, &SsData.SsLmsvcsGlobalData->AliasPrintOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_CONNECTION_INFO_GET, &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid}
    };

    //
    // Create Connection security object.
    //

    return CreateSecurityObject(
                &SsConnectionSecurityObject,
                SRVSVC_CONNECTION_OBJECT,
                &SsConnectionMapping,
                ConnectionAceData,
                sizeof(ConnectionAceData) / sizeof(ACE_DATA),
                SsUpgradeSecurityDescriptors
                );

    return NO_ERROR;

} // CreateConnectionSecurityObject


NET_API_STATUS
CreateDiskSecurityObject (
    VOID
    )
{
    //
    // Required access for doing Disk enums
    //

    ACE_DATA DiskAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid}
    };

    //
    // Create Disk security object.
    //

    return CreateSecurityObject(
                &SsDiskSecurityObject,
                SRVSVC_DISK_OBJECT,
                &SsDiskMapping,
                DiskAceData,
                sizeof(DiskAceData) / sizeof(ACE_DATA),
                SsUpgradeSecurityDescriptors
                );

} // CreateDiskSecurityObject


NET_API_STATUS
CreateFileSecurityObject (
    VOID
    )
{
    //
    // Required access for getting and setting File information.
    //

    ACE_DATA FileAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid}
    };

    //
    // Create File security object.
    //

    return CreateSecurityObject(
                &SsFileSecurityObject,
                SRVSVC_FILE_OBJECT,
                &SsFileMapping,
                FileAceData,
                sizeof(FileAceData) / sizeof(ACE_DATA),
                SsUpgradeSecurityDescriptors
                );

} // CreateFileSecurityObject


NET_API_STATUS
CreateSessionSecurityObject (
    VOID
    )
{
    PACE_DATA pAceData;
    ULONG AceSize;

    //
    // Required access for getting and setting session information.
    //

    ACE_DATA SessionAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SESSION_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SESSION_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AnonymousLogonSid}
    };

    ACE_DATA SessionAceDataRestricted[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SESSION_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AuthenticatedUserSid}
    };

    if( SsRestrictNullSessions )
    {
        pAceData = SessionAceDataRestricted;
        AceSize = sizeof(SessionAceDataRestricted)/sizeof(ACE_DATA);
    }
    else
    {
        pAceData = SessionAceData;
        AceSize = sizeof(SessionAceData)/sizeof(ACE_DATA);
    }

    //
    // Create Session security object.
    //

    return CreateSecurityObject(
                &SsSessionSecurityObject,
                SRVSVC_SESSION_OBJECT,
                &SsSessionMapping,
                SessionAceData,
                sizeof(SessionAceData) / sizeof(ACE_DATA),
                SsUpgradeSecurityDescriptors
                );

} // CreateSessionSecurityObject


NET_API_STATUS
CreateShareSecurityObjects (
    VOID
    )
{
    NET_API_STATUS status;
    PACE_DATA pAceData;
    ULONG AceSize;

    //
    // Required access for getting and setting share information.
    //


    ACE_DATA ShareFileAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AnonymousLogonSid}
    };
    ACE_DATA ShareFileAceDataRestricted[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AuthenticatedUserSid}
    };

    ACE_DATA SharePrintAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPrintOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AnonymousLogonSid}
    };
    ACE_DATA SharePrintAceDataRestricted[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPrintOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AuthenticatedUserSid}
    };

    ACE_DATA ShareAdminAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_ADMIN_INFO_GET,
               &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_ADMIN_INFO_GET,
               &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AnonymousLogonSid}
    };
    ACE_DATA ShareAdminAceDataRestricted[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_ADMIN_INFO_GET,
               &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_ADMIN_INFO_GET,
               &SsData.SsLmsvcsGlobalData->AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_USER_INFO_GET, &SsData.SsLmsvcsGlobalData->AuthenticatedUserSid}
    };

    //
    // note for connect we always use WorldSid for backwards compat.
    //

    ACE_DATA ShareConnectAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasBackupOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_CONNECT, &SsData.SsLmsvcsGlobalData->WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_SHARE_CONNECT, &SsData.SsLmsvcsGlobalData->AnonymousLogonSid}
    };

    ACE_DATA ShareAdmConnectAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasBackupOpsSid}
    };

    //
    // Create Share security objects.
    //

    if (!SsGetDefaultSdFromRegistry(
            SRVSVC_DEFAULT_SHARE_OBJECT,
            &SsDefaultShareSecurityObject.SecurityDescriptor)) {

        SsDefaultShareSecurityObject.SecurityDescriptor = NULL;
    }

    if( SsRestrictNullSessions )
    {
        pAceData = ShareFileAceDataRestricted;
        AceSize = sizeof(ShareFileAceDataRestricted)/sizeof(ACE_DATA);
    }
    else
    {
        pAceData = ShareFileAceData;
        AceSize = sizeof(ShareFileAceData)/sizeof(ACE_DATA);
    }
    status = CreateSecurityObject(
                &SsShareFileSecurityObject,
                SRVSVC_SHARE_FILE_OBJECT,
                &SsShareMapping,
                pAceData,
                AceSize,
                SsUpgradeSecurityDescriptors
                );
    if ( status != NO_ERROR ) {
        return status;
    }


    if( SsRestrictNullSessions )
    {
        pAceData = SharePrintAceDataRestricted;
        AceSize = sizeof(SharePrintAceDataRestricted)/sizeof(ACE_DATA);
    }
    else
    {
        pAceData = SharePrintAceData;
        AceSize = sizeof(SharePrintAceData)/sizeof(ACE_DATA);
    }
    status = CreateSecurityObject(
                &SsSharePrintSecurityObject,
                SRVSVC_SHARE_PRINT_OBJECT,
                &SsShareMapping,
                pAceData,
                AceSize,
                SsUpgradeSecurityDescriptors
                );

    if ( status != NO_ERROR ) {
        return status;
    }

    if( SsRestrictNullSessions )
    {
        pAceData = ShareAdminAceDataRestricted;
        AceSize = sizeof(ShareAdminAceDataRestricted)/sizeof(ACE_DATA);
    }
    else
    {
        pAceData = ShareAdminAceData;
        AceSize = sizeof(ShareAdminAceData)/sizeof(ACE_DATA);
    }
    status = CreateSecurityObject(
                &SsShareAdminSecurityObject,
                SRVSVC_SHARE_ADMIN_OBJECT,
                &SsShareMapping,
                pAceData,
                AceSize,
                SsUpgradeSecurityDescriptors
                );
    if ( status != NO_ERROR ) {
        return status;
    }

    pAceData = ShareConnectAceData;
    AceSize = sizeof(ShareConnectAceData)/sizeof(ACE_DATA);

    // Make sure the upgrade happens for this one.  The upgrade
    // will not happen if RA != 0.  We force RA=0 for this one case.
    {
        BOOLEAN restrictNullSession = SsRestrictNullSessions;
        SsRestrictNullSessions = FALSE;

        status = CreateSecurityObject(
                    &SsShareConnectSecurityObject,
                    SRVSVC_SHARE_CONNECT_OBJECT,
                    &SsShareConnectMapping,
                    pAceData,
                    AceSize,
                    SsUpgradeSecurityDescriptors
                    );
        if ( status != NO_ERROR ) {
            return status;
        }

        SsRestrictNullSessions = restrictNullSession;
    }

    return CreateSecurityObject(
                &SsShareAdmConnectSecurityObject,
                SRVSVC_SHARE_ADM_CONNECT_OBJECT,
                &SsShareConnectMapping,
                ShareAdmConnectAceData,
                sizeof(ShareAdmConnectAceData) / sizeof(ACE_DATA),
                SsUpgradeSecurityDescriptors
                );

} // CreateShareSecurityObjects


NET_API_STATUS
CreateStatisticsSecurityObject (
    VOID
    )
{
    //
    // Required access for getting and setting Statistics information.
    //

    ACE_DATA StatisticsAceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL, &SsData.SsLmsvcsGlobalData->AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SRVSVC_STATISTICS_GET, &SsData.SsLmsvcsGlobalData->LocalSid}
    };

    //
    // Create Statistics security object.
    //

    return CreateSecurityObject(
                &SsStatisticsSecurityObject,
                SRVSVC_STATISTICS_OBJECT,
                &SsStatisticsMapping,
                StatisticsAceData,
                sizeof(StatisticsAceData) / sizeof(ACE_DATA),
                SsUpgradeSecurityDescriptors
                );

} // CreateStatisticsSecurityObject


VOID
DeleteSecurityObject (
    PSRVSVC_SECURITY_OBJECT SecurityObject
    )
{
    NTSTATUS status;

    if ( SecurityObject->SecurityDescriptor != NULL ) {

        status = NetpDeleteSecurityObject(
                    &SecurityObject->SecurityDescriptor
                    );
        SecurityObject->SecurityDescriptor = NULL;

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(TERMINATION_ERRORS) {
                SS_PRINT(( "DeleteSecurityObject: failed to delete "
                            FORMAT_LPTSTR " object: %X\n",
                            SecurityObject->ObjectName,
                            status ));
            }
        } else {
            IF_DEBUG(TERMINATION) {
                SS_PRINT(( "DeleteSecurityObject: deleted " FORMAT_LPTSTR
                            " object.\n",
                            SecurityObject->ObjectName ));
            }
        }

    }

    return;

} // DeleteSecurityObject


NET_API_STATUS
CheckNullSessionAccess(
    VOID
    )
/*++

Routine Description:

    This routine checks to see if we should restict null session access.
    in the registry under system\currentcontrolset\Control\Lsa\
    RestrictAnonymous indicating whether or not to restrict access.
    If access is restricted then you need to be an authenticated user to
    get DOMAIN_LIST_ACCOUNTS or GROUP_LIST_MEMBERS or ALIAS_LIST_MEMBERS
    access.

Arguments:

    none.

Return Value:

    NO_ERROR - the routine completed sucesfully.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UCHAR Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG KeyValueLength = 100;
    ULONG ResultLength;
    PULONG Flag;

    SsRestrictNullSessions = FALSE;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }


    RtlInitUnicodeString(
        &KeyName,
        L"RestrictAnonymous"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            Flag = (PULONG) KeyValueInformation->Data;

            if (*Flag >= 1) {
                SsRestrictNullSessions = TRUE;
            }
        }

    }
    else
    {
        if( NtStatus == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            // No key means RestrictAnonymous = 0
            NtStatus = STATUS_SUCCESS;
        }
    }
    NtClose(KeyHandle);

Cleanup:

    if( !NT_SUCCESS(NtStatus) )
    {
        return NetpNtStatusToApiStatus(NtStatus);
    }

    return NO_ERROR;
}

BOOLEAN
DoesAclContainSid(
    PACL pAcl,
    PSID pSid,
    OPTIONAL ACCESS_MASK* pMask
    )
/*++

Routine Description:

    This walks the given Acl to see if it contains the desired SID.  If it does,
    we optionally also return the AccessMask associated with that SID.

    NOTE: If the value is not found, this routine should NOT touch the pMask variable.

Arguments:

    pAcl - A pointer to the ACL we're checking
    pSid - The SID we're looking for
    pMask [optional] - Where we fill in the Access Mask if they want to know it.

Return Value:

    TRUE - the routine completed sucesfully.
    FALSE - the routine encountered an error

--*/
{
    ACE_HEADER* pAceHeader;
    ACL_SIZE_INFORMATION AclSize;
    PSID pAceSid;
    WORD wCount;

    if( !GetAclInformation( pAcl, &AclSize, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation ) )
        return FALSE;

    for( wCount=0; wCount < AclSize.AceCount; wCount++ )
    {
        if( !GetAce( pAcl, wCount, &pAceHeader ) )
            return FALSE;

        switch( pAceHeader->AceType )
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            {
                ACCESS_ALLOWED_ACE* pAce = (ACCESS_ALLOWED_ACE*)pAceHeader;
                pAceSid = &(pAce->SidStart);

                if( EqualSid( pAceSid, pSid ) )
                {
                    if( pMask )
                    {
                        *pMask = pAce->Mask;
                    }
                    return TRUE;
                }

            }
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            {
                ACCESS_ALLOWED_OBJECT_ACE* pAce = (ACCESS_ALLOWED_OBJECT_ACE*)pAceHeader;
                pAceSid = &(pAce->SidStart);

                if( EqualSid( pAceSid, pSid ) )
                {
                    if( pMask )
                    {
                        *pMask = pAce->Mask;
                    }
                    return TRUE;
                }
            }
            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            {
                continue;
            }
        }
    }

    return FALSE;
}

BOOLEAN
AppendAllowedAceToSelfRelativeSD(
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pNewSid,
    PISECURITY_DESCRIPTOR pOldSD,
    PSECURITY_DESCRIPTOR* ppNewSD
    )
/*++

Routine Description:

    This routine creates a new Security Descriptor that contains the original SD plus
    appends the new SID (with the given Access).  The final SD is in Self-Relative form.

Arguments:

    AceFlags - The flags associated with this ACE in the SD
    AccessMask - The AccessMask for this ACE
    pNewSid - The SID for this ACE
    pOldSD - The original Security Descriptor
    ppNewSid - OUT pointer to the newly allocated Security Descriptor

Return Value:

    TRUE - the routine completed sucesfully.
    FALSE - the routine encountered an error

--*/
{
    BOOLEAN bSelfRelative;
    SECURITY_DESCRIPTOR NewSDBuffer;
    PISECURITY_DESCRIPTOR pNewSD, pSelfRelativeSD;
    NTSTATUS Status;
    BOOLEAN bResult = FALSE;
    PACL pAcl, pNewAcl;
    DWORD dwNewAclSize;
    DWORD dwRelativeSDLength;
    PSID pSid;

    pNewAcl = NULL;
    pSelfRelativeSD = NULL;

    // Make sure it is self relative
    if( !RtlpAreControlBitsSet( pOldSD, SE_SELF_RELATIVE ) )
        return FALSE;

    // Convert it to absolute
    pNewSD = &NewSDBuffer;
    Status = RtlCreateSecurityDescriptor( pNewSD, SECURITY_DESCRIPTOR_REVISION );
    if( !NT_SUCCESS(Status) )
        goto Cleanup;

    // Copy in the new information
    pNewSD->Control = pOldSD->Control;
    RtlpClearControlBits( pNewSD, SE_SELF_RELATIVE );

    pSid = RtlpOwnerAddrSecurityDescriptor( pOldSD );
    if( pSid )
    {
        pNewSD->Owner = pSid;
    }

    pSid = RtlpGroupAddrSecurityDescriptor( pOldSD );
    if( pSid )
    {
        pNewSD->Group = pSid;
    }

    pAcl = RtlpSaclAddrSecurityDescriptor( pOldSD );
    if( pAcl )
    {
        pNewSD->Sacl = pAcl;
    }

    // Assemble the new ACL
    pAcl = RtlpDaclAddrSecurityDescriptor( pOldSD );
    if( !pAcl )
    {
        goto Cleanup;
    }
    dwNewAclSize = pAcl->AclSize + sizeof(KNOWN_ACE) + GetLengthSid( pNewSid );
    pNewAcl = MIDL_user_allocate( dwNewAclSize );
    if( !pNewAcl )
    {
        goto Cleanup;
    }

    // Copy the old information in
    RtlCopyMemory( pNewAcl, pAcl, pAcl->AclSize );
    pNewAcl->AclSize = (USHORT)dwNewAclSize;

    // Add in the new ACE
    if( !AddAccessAllowedAceEx( pNewAcl, ACL_REVISION, AceFlags, AccessMask, pNewSid ) )
    {
        goto Cleanup;
    }

    // Set the new DACL in the SD
    Status = RtlSetDaclSecurityDescriptor( pNewSD, TRUE, pNewAcl, FALSE );
    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }

    dwRelativeSDLength = 0;

    // Get the size of the self relative SD
    Status = RtlMakeSelfRelativeSD( pNewSD, NULL, &dwRelativeSDLength );
    if( NT_SUCCESS(Status) )
    {
        // No way we can succeed here
        ASSERT(FALSE);
        goto Cleanup;
    }

    pSelfRelativeSD = MIDL_user_allocate( dwRelativeSDLength );
    if( !pSelfRelativeSD )
    {
        goto Cleanup;
    }
    Status = RtlMakeSelfRelativeSD( pNewSD, pSelfRelativeSD, &dwRelativeSDLength );
    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }

    // All set.  Let it be set and go.
    *ppNewSD = pSelfRelativeSD;
    bResult = TRUE;

Cleanup:

    if( pNewAcl )
    {
        MIDL_user_free( pNewAcl );
        pNewAcl = NULL;
    }
    if( !bResult )
    {
        if( pSelfRelativeSD )
        {
            MIDL_user_free( pSelfRelativeSD );
        }
    }

    return bResult;
}


NTSTATUS
QueryRegDWord(
    PCWSTR Path,
    PCWSTR ValueName,
    LPDWORD lpResult
    )
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UCHAR Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG KeyValueLength = 100;
    ULONG ResultLength;
    PULONG pValue;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        Path
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }


    RtlInitUnicodeString(
        &KeyName,
        ValueName
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            pValue = (PULONG) KeyValueInformation->Data;
            *lpResult = (*pValue);
        }

    }
    NtClose(KeyHandle);

Cleanup:

    return NtStatus;
}

NTSTATUS
SetRegDWord(
    ULONG RelativeTo,
    PCWSTR Path,
    PCWSTR ValueName,
    DWORD Value
    )
{
    return RtlWriteRegistryValue( RelativeTo, Path, ValueName, REG_DWORD, (PVOID)(&Value), sizeof(DWORD) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\scavengr.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    Scavengr.c

Abstract:

    This module contains the code for the server service scavenger
    thread.  This thread handles announcements and configuration
    changes.  (Although originally written to run in a separate thread,
    this code now runs in the initial thread of the server service.

Author:

    David Treadwell (davidtr)    17-Apr-1991

Revision History:

--*/

#include "srvsvcp.h"
#include "ssreg.h"

#include <netlibnt.h>
#include <tstr.h>

#define INCLUDE_SMB_TRANSACTION
#undef NT_PIPE_PREFIX
#include <smbtypes.h>
#include <smb.h>
#include <smbtrans.h>
#include <smbgtpt.h>

#include <hostannc.h>
#include <ntddbrow.h>
#include <lmerr.h>

#define TERMINATION_SIGNALED 0
#define ANNOUNCE_SIGNALED 1
#define STATUS_CHANGED 2
#define DOMAIN_CHANGED 3
#define REGISTRY_CHANGED 4      // Must be the last one

#define NUMBER_OF_EVENTS 5


//
// Bias request announcements by SERVER_REQUEST_ANNOUNCE_DELTA SECONDS
//

#define SERVER_REQUEST_ANNOUNCE_DELTA   30

//
// Forward declarations.
//

VOID
Announce (
    IN BOOL DoNtAnnouncement,
    IN DWORD NtInterval,
    IN BOOL DoLmAnnouncement,
    IN BOOL TerminationAnnouncement
    );

NET_API_STATUS
SendSecondClassMailslot (
    IN LPTSTR Transport OPTIONAL,
    IN PVOID Message,
    IN DWORD MessageLength,
    IN LPTSTR Domain,
    IN LPSTR MailslotNameText,
    IN UCHAR SignatureByte
    );

NET_API_STATUS
SsBrowserIoControl (
    IN DWORD IoControlCode,
    IN PVOID Buffer,
    IN DWORD BufferLength,
    IN PLMDR_REQUEST_PACKET Packet,
    IN DWORD PacketLength
    );


DWORD
ComputeAnnounceTime (
    IN DWORD LastAnnouncementTime,
    IN DWORD Interval
    )

/*++

Routine Description:

    Compute the time to wait (in milliseconds) until the next announcement should
    be made.

Arguments:

    LastAnnouncementTime - Time (in milliseconds since reboot) when the last
        announcement was made.

    Interval - Interval (in seconds) between announcements

Return Value:

    Timeout period (in milliseconds)

--*/

{
    DWORD AnnounceDelta;
    DWORD Timeout;
    DWORD CurrentTime;

    //
    // Get the current time.
    //

    CurrentTime = GetTickCount();

    //
    // If the clock has gone backward,
    //  send an announcement now.
    //

    if ( LastAnnouncementTime > CurrentTime ) {
        return 0;
    }

    //
    // Convert the announcement period from seconds to milliseconds.
    //

    Timeout = Interval * 1000;

    //
    // Add in the random announce delta which helps prevent lots of
    // servers from announcing at the same time.
    //

    AnnounceDelta = SsData.ServerInfo102.sv102_anndelta;

    Timeout += ((rand( ) * AnnounceDelta * 2) / RAND_MAX) -
                   AnnounceDelta;

    //
    // If our time has expired,
    //  send an announcement now.
    //

    if ( (CurrentTime - LastAnnouncementTime) >= Timeout ) {
        return 0;
    }

    //
    // Adjust our timeout period for time already elapsed.
    //

    return Timeout - (CurrentTime - LastAnnouncementTime);

}


DWORD
SsScavengerThread (
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This routine implements the server service scavenger thread.

Arguments:

    lpThreadParameter - ignored.

Return Value:

    NET_API_STATUS - thread termination result.

--*/

{
    HANDLE events[ NUMBER_OF_EVENTS ];
    ULONG numEvents = NUMBER_OF_EVENTS-1;
    UNICODE_STRING unicodeEventName;
    OBJECT_ATTRIBUTES obja;
    DWORD waitStatus;
    DWORD timeout;

    DWORD LmTimeout;
    BOOL DoLmAnnouncement;
    DWORD LmLastAnnouncementTime;

    DWORD NtTimeout;
    BOOL DoNtAnnouncement;
    DWORD NtLastAnnouncementTime;
    DWORD NtInterval;

    NTSTATUS status;
    BOOL hidden = TRUE;
    HKEY hParameters = INVALID_HANDLE_VALUE;

    lpThreadParameter;

    //
    // Use the scavenger termination event to know when we're supposed
    // to wake up and kill ourselves.
    //

    events[TERMINATION_SIGNALED] = SsData.SsTerminationEvent;

    //
    // Initialize the NT announcement interval to the LM announcement interval
    //

    NtInterval = SsData.ServerInfo102.sv102_announce;
    DoLmAnnouncement = TRUE;
    DoNtAnnouncement = TRUE;

    //
    // Create the announce event.  When this gets signaled, we wake up
    // and do an announcement.  We use a synchronization event rather
    // than a notification event so that we don't have to worry about
    // resetting the event after we wake up.
    //

    //
    // Please note that we create this event with OBJ_OPENIF.  We do this
    // to allow the browser to signal the server to force an announcement.
    //
    // The bowser will create this event as a part of the bowser
    // initialization, and will set it to the signalled state when it needs
    // to have the server announce.
    //


    RtlInitUnicodeString( &unicodeEventName, SERVER_ANNOUNCE_EVENT_W );
    InitializeObjectAttributes( &obja, &unicodeEventName, OBJ_OPENIF, NULL, NULL );

    status = NtCreateEvent(
                 &SsData.SsAnnouncementEvent,
                 SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                 &obja,
                 SynchronizationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS(status) ) {
        SS_PRINT(( "SsScavengerThread: NtCreateEvent failed: %X\n",
                    status ));
        return NetpNtStatusToApiStatus( status );
    }

    events[ANNOUNCE_SIGNALED] = SsData.SsAnnouncementEvent;

    //
    // Create an unnamed event to be set to the signalled state when the
    // service status changes (or a local application requests an
    // announcement)
    //

    InitializeObjectAttributes( &obja, NULL, OBJ_OPENIF, NULL, NULL );

    status = NtCreateEvent(
                 &SsData.SsStatusChangedEvent,
                 SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                 &obja,
                 SynchronizationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS(status) ) {
        SS_PRINT(( "SsScavengerThread: NtCreateEvent failed: %X\n",
                    status ));

        NtClose( SsData.SsAnnouncementEvent );
        SsData.SsAnnouncementEvent = NULL;

        return NetpNtStatusToApiStatus( status );
    }

    events[STATUS_CHANGED] = SsData.SsStatusChangedEvent;

    events[ DOMAIN_CHANGED ] = SsData.SsDomainNameChangeEvent ?
                                SsData.SsDomainNameChangeEvent : INVALID_HANDLE_VALUE;

    //
    // Put a watch on the registry for any changes that happen in the
    //   null session share or pipe list.  Don't bail out if this fails,
    //   because we've done this as a convenience in adding new null
    //   session-reliant servers.  It doesn't really affect the normal
    //   operation of the server if this doesn't work.
    //
    events[ REGISTRY_CHANGED ] = INVALID_HANDLE_VALUE;
    status = NtCreateEvent(
                            &events[ REGISTRY_CHANGED ],
                            SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                            NULL,
                            SynchronizationEvent,
                            FALSE
                          );

    if ( NT_SUCCESS(status) ) {
        status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               FULL_PARAMETERS_REGISTRY_PATH,
                               0,
                               KEY_NOTIFY,
                               &hParameters
                             );

        if( status == ERROR_SUCCESS ) {
            (void)RegNotifyChangeKeyValue( hParameters,
                                           TRUE,
                                           REG_NOTIFY_CHANGE_LAST_SET,
                                           events[ REGISTRY_CHANGED ],
                                           TRUE
                                         );
            //
            // Add this event to the list of events we're waiting for
            //
            ++numEvents;
        }
    }

    //
    // Seed the random number generator.  We use it to generate random
    // announce deltas.
    //

    srand( PtrToUlong(SsData.SsAnnouncementEvent) );

    //
    // Do an announcement immediately for startup, then loop announcing
    // based on the announce interval.
    //

    waitStatus = WAIT_TIMEOUT;

    do {

        //
        // Act according to whether the termination event, the announce
        // event, or the timeout caused us to wake up.
        //
        // !!! Or the configuration event indicating a configuration
        //     change notification.
        if ( waitStatus == WAIT_FAILED ) {

            //
            // Don't consume all the CPU just because an error happened
            //
            Sleep(1000);


        } else if ( waitStatus == WAIT_OBJECT_0 + TERMINATION_SIGNALED ) {

            SS_PRINT(( "Scavenger: termination event signaled\n" ));

            //
            // The scavenger termination event was signaled, so we have
            // to gracefully kill this thread.  If this is not a hidden
            // server, announce the fact that we're going down.
            //

            if ( !hidden ) {
                Announce( TRUE, NtInterval, TRUE, TRUE );
            }

            //
            // Close the announcement event.
            //

            NtClose( SsData.SsAnnouncementEvent );

            SsData.SsAnnouncementEvent = NULL;

            //
            // Close the Registry watch event.
            //
            if( events[ REGISTRY_CHANGED ] != INVALID_HANDLE_VALUE )
                NtClose( events[ REGISTRY_CHANGED ] );

            //
            // Close the Registry handle
            //
            if( hParameters != INVALID_HANDLE_VALUE )
                RegCloseKey( hParameters );

            //
            // Return to caller.
            //

            return NO_ERROR;

        } else if( waitStatus == WAIT_OBJECT_0 + REGISTRY_CHANGED ) {
            //
            // Somebody changed some server parameters.  Tell the driver
            //
            SS_PRINT(( "SsScavengerThread: Server parameters changed\n" ));

            //
            // Tell the server FSD to look for a change in the registry
            //
            (void)SsServerFsControl( FSCTL_SRV_REGISTRY_CHANGE, NULL, NULL, 0 );

            //
            // Turn it back on so we get future changes, too
            //
            (void)RegNotifyChangeKeyValue( hParameters,
                                           TRUE,
                                           REG_NOTIFY_CHANGE_LAST_SET,
                                           events[ REGISTRY_CHANGED ],
                                           TRUE
                                         );

        } else if( waitStatus == WAIT_OBJECT_0 + DOMAIN_CHANGED ) {

            SsSetDomainName();

        } else {

            SS_ASSERT( waitStatus == WAIT_TIMEOUT ||
                    waitStatus == WAIT_OBJECT_0 + ANNOUNCE_SIGNALED ||
                    waitStatus == WAIT_OBJECT_0 + STATUS_CHANGED );

            //
            // If we've timed out,
            //  we've already set the flags indicating whether to announce
            //  on to lanman to NT browsers
            //

            if ( waitStatus != WAIT_TIMEOUT ) {
                DoLmAnnouncement = TRUE;
                DoNtAnnouncement = TRUE;
            }

            //
            // If we're not a hidden server, announce ourselves.
            //

            // Hold the database resource while we do the announcement so
            // that we get a consistent view of the database.
            //

            (VOID)RtlAcquireResourceShared( &SsData.SsServerInfoResource, TRUE );

            if ( !SsData.ServerInfo102.sv102_hidden ) {

                hidden = FALSE;

                Announce( DoNtAnnouncement, NtInterval, DoLmAnnouncement, FALSE );



            //
            // If we were not hidden last time through the loop but
            // we're hidden now, we've changed to hidden, so announce
            // that we're going down.  This causes clients in the domain
            // to take us out of their server enumerations.
            //

            } else if ( !hidden ) {

                hidden = TRUE;
                Announce( TRUE, NtInterval, TRUE, TRUE );

            }

            //
            // If the server is hidden, the wait timeout is infinite.  We'll
            // be woken up by the announce event if the server becomes
            // unhidden.
            //

            if ( SsData.ServerInfo102.sv102_hidden ) {

                timeout = 0xffffffff;

            } else {

                //
                // Remember when the last announcement was.
                //

                if ( DoNtAnnouncement ) {
                    NtLastAnnouncementTime = GetTickCount();
                }

                if ( DoLmAnnouncement ) {
                    LmLastAnnouncementTime = GetTickCount();
                }

                //
                // Compute the time delta to the next announcement
                //
                // For NtInterval,
                //  use a local copy of the interval since we compute the correct
                //  value.
                //
                // For the Lanman interval,
                //  use the global copy to allow the interval to be changed.
                //

                NtTimeout = ComputeAnnounceTime(
                                NtLastAnnouncementTime,
                                NtInterval );

                if (SsData.ServerInfo599.sv599_lmannounce) {
                    LmTimeout = ComputeAnnounceTime(
                                    LmLastAnnouncementTime,
                                    SsData.ServerInfo102.sv102_announce );
                } else {
                    // Don't awaken this thread to do nothing.
                    LmTimeout = 0xffffffff;
                }


                //
                // If our NT announcement frequency is less than 12 minutes,
                // increase our announcement frequency by 4 minutes.
                //

                if ( NtInterval < 12 * 60 ) {

                    NtInterval += 4 * 60;

                    if ( NtInterval > 12 * 60) {
                        NtInterval = 12 * 60;
                    }
                }

                //
                // Determine which timeout we're actually going to use.
                //

                if ( NtTimeout == LmTimeout ) {
                    timeout = NtTimeout;
                    DoLmAnnouncement = TRUE;
                    DoNtAnnouncement = TRUE;
                } else if ( NtTimeout < LmTimeout ) {
                    timeout = NtTimeout;
                    DoLmAnnouncement = FALSE;
                    DoNtAnnouncement = TRUE;
                } else {
                    timeout = LmTimeout;
                    DoLmAnnouncement = TRUE;
                    DoNtAnnouncement = FALSE;
                }

            }

            RtlReleaseResource( &SsData.SsServerInfoResource );
        }


        //
        // Wait for one of the events to be signaled or for the timeout
        // to elapse.
        //

        waitStatus = WaitForMultipleObjects(  numEvents , events, FALSE, timeout );

        if ( waitStatus == WAIT_OBJECT_0 + ANNOUNCE_SIGNALED ) {

            //
            // We were awakened because an announce was signalled.
            // Unless we are a master browser on at least one transport,
            // delay for a random delta to stagger announcements a bit
            // to prevent lots of servers from announcing
            // simultaneously.
            //

            BOOL isMasterBrowser = FALSE;
            PNAME_LIST_ENTRY service;
            PTRANSPORT_LIST_ENTRY transport;

            RtlAcquireResourceShared( &SsData.SsServerInfoResource, TRUE );

            for( service = SsData.SsServerNameList;
                 isMasterBrowser == FALSE && service != NULL;
                 service = service->Next ) {

                if( service->ServiceBits & SV_TYPE_MASTER_BROWSER ) {
                    isMasterBrowser = TRUE;
                    break;
                }

                for( transport=service->Transports; transport != NULL; transport=transport->Next ) {
                    if( transport->ServiceBits & SV_TYPE_MASTER_BROWSER ) {
                        isMasterBrowser = TRUE;
                        break;
                    }
                }
            }

            RtlReleaseResource( &SsData.SsServerInfoResource );

            if ( !isMasterBrowser ) {
                Sleep( ((rand( ) * (SERVER_REQUEST_ANNOUNCE_DELTA * 1000)) / RAND_MAX) );
            }

        }

    } while ( TRUE );

    return NO_ERROR;

} // SsScavengerThread


VOID
SsAnnounce (
    IN POEM_STRING OemAnnounceName,
    IN LPWSTR EmulatedDomainName OPTIONAL,
    IN BOOL DoNtAnnouncement,
    IN DWORD NtInterval,
    IN BOOL DoLmAnnouncement,
    IN BOOL TerminationAnnouncement,
    IN BOOL IsPrimaryDomain,
    IN LPTSTR Transport,
    IN DWORD serviceType
    )

/*++

Routine Description:

    This routine sends a broadcast datagram as a second-class mailslot
    that announces the presence of this server on the network.

Arguments:

    OemAnnounceName - The name we're announcing to the network

    EmulatedDomainName - The name of the domain this announcement is happening for.
        NULL is specified for the primary domain.

    DoNtAnnouncement - Do an Nt-style announcement.

    NtInterval - NT announcement interval (in seconds)

    DoLmAnnouncement - Do an Lm-style announcement.

    TerminationAnnouncement - if TRUE, send the announcement that
        indicates that this server is going away.  Otherwise, send
        the normal message that tells clients that we're here.

    Transport - Ssupplies the transport to issue the announcement
        on.

    serviceType - Service bits being announced

Return Value:

    None.

--*/

{
    DWORD messageSize;
    PHOST_ANNOUNCE_PACKET packet;
    PBROWSE_ANNOUNCE_PACKET browsePacket;

    LPSTR serverName;
    DWORD oemServerNameLength;      // includes the null terminator

    LPSTR serverComment;
    DWORD serverCommentLength;      // includes the null terminator
    OEM_STRING oemCommentString;

    UNICODE_STRING unicodeCommentString;

    NET_API_STATUS status;

    //
    // Fill in the necessary information.
    //

    if( TerminationAnnouncement ) {
        serviceType &= ~SV_TYPE_SERVER;         // since the server is going away!
    }

    SS_PRINT(( "SsScavengerThread: Announcing for transport %ws, Bits: %lx\n",
               Transport, serviceType ));

    //
    //  Get the length of the oem equivalent of the server name
    //

    oemServerNameLength = OemAnnounceName->Length + 1;

    //
    // Convert server comment to a unicode string
    //

    if ( *SsData.ServerCommentBuffer == '\0' ) {
        serverCommentLength = 1;
    } else {
        unicodeCommentString.Length =
            (USHORT)(STRLEN( SsData.ServerCommentBuffer ) * sizeof(WCHAR));
        unicodeCommentString.MaximumLength =
                    (USHORT)(unicodeCommentString.Length + sizeof(WCHAR));
        unicodeCommentString.Buffer = SsData.ServerCommentBuffer;
        serverCommentLength =
                    RtlUnicodeStringToOemSize( &unicodeCommentString );
    }

    oemCommentString.MaximumLength = (USHORT)serverCommentLength;

    messageSize = max(sizeof(HOST_ANNOUNCE_PACKET) + oemServerNameLength +
                            serverCommentLength,
                      sizeof(BROWSE_ANNOUNCE_PACKET) + serverCommentLength);

    //
    // Get memory to hold the message.  If we can't allocate enough
    // memory, don't send an announcement.
    //

    packet = MIDL_user_allocate( messageSize );
    if ( packet == NULL ) {
        return;
    }

    //
    //  If we are announcing as a Lan Manager server, broadcast the
    //  announcement.
    //

    if (SsData.ServerInfo599.sv599_lmannounce && DoLmAnnouncement ) {

        packet->AnnounceType = HostAnnouncement ;

        SmbPutUlong( &packet->HostAnnouncement.Type, serviceType );

        packet->HostAnnouncement.CompatibilityPad = 0;

        packet->HostAnnouncement.VersionMajor =
            (BYTE)SsData.ServerInfo102.sv102_version_major;
        packet->HostAnnouncement.VersionMinor =
            (BYTE)SsData.ServerInfo102.sv102_version_minor;

        SmbPutUshort(
            &packet->HostAnnouncement.Periodicity,
            (WORD)SsData.ServerInfo102.sv102_announce
            );

        //
        // Convert the server name from unicode to oem
        //

        serverName = (LPSTR)( &packet->HostAnnouncement.NameComment );

        RtlCopyMemory( serverName, OemAnnounceName->Buffer, OemAnnounceName->Length );
        serverName[OemAnnounceName->Length] = '\0';

        serverComment = serverName + oemServerNameLength;

        if ( serverCommentLength == 1 ) {
            *serverComment = '\0';
        } else {

            oemCommentString.Buffer = serverComment;
            (VOID) RtlUnicodeStringToOemString(
                        &oemCommentString,
                        &unicodeCommentString,
                        FALSE
                        );
        }

        SendSecondClassMailslot(
            Transport,
            packet,
            FIELD_OFFSET(HOST_ANNOUNCE_PACKET, HostAnnouncement.NameComment) +
                oemServerNameLength + serverCommentLength,
            EmulatedDomainName,
            "\\MAILSLOT\\LANMAN",
            0x00
            );
    }

    //
    //  Now announce the server as a Winball server.
    //

    if ( DoNtAnnouncement ) {
        browsePacket = (PBROWSE_ANNOUNCE_PACKET)packet;

        browsePacket->BrowseType = ( serviceType & SV_TYPE_MASTER_BROWSER ?
                                        LocalMasterAnnouncement :
                                        HostAnnouncement );

        browsePacket->BrowseAnnouncement.UpdateCount = 0;

        SmbPutUlong( &browsePacket->BrowseAnnouncement.CommentPointer, (ULONG)((0xaa55 << 16) + (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR));

        SmbPutUlong( &browsePacket->BrowseAnnouncement.Periodicity, NtInterval * 1000 );

        SmbPutUlong( &browsePacket->BrowseAnnouncement.Type, serviceType );

        browsePacket->BrowseAnnouncement.VersionMajor =
                (BYTE)SsData.ServerInfo102.sv102_version_major;
        browsePacket->BrowseAnnouncement.VersionMinor =
                (BYTE)SsData.ServerInfo102.sv102_version_minor;

        RtlCopyMemory( &browsePacket->BrowseAnnouncement.ServerName,
                       OemAnnounceName->Buffer,
                       OemAnnounceName->Length );
        browsePacket->BrowseAnnouncement.ServerName[OemAnnounceName->Length] = '\0';

        serverComment = (LPSTR)&browsePacket->BrowseAnnouncement.Comment;

        if ( serverCommentLength == 1 ) {
            *serverComment = '\0';
        } else {

            oemCommentString.Buffer = serverComment;
            (VOID) RtlUnicodeStringToOemString(
                                &oemCommentString,
                                &unicodeCommentString,
                                FALSE
                                );
        }

        //
        // We need to determine the correct mechanism for sending the mailslot.
        //
        //  1) Wolfpack (the cluster folks) needs to send the mailslot using
        //      the SMB server driver.  It registers a "fake" transport with
        //      the SMB server.  They only register their cluster name on this
        //      fake transport.  Luckily, they only support the primary domain.
        //      Wolfpack doesn't currently register its name to the browser
        //      since the browser doesn't support name registration on a
        //      subset of the transports.
        //  2) Announcements on other than the primary domain need to go via
        //      the bowser.  The bowser not only sends the mailslot to a name
        //      that's a function of the emulated domain name, but also properly
        //      crofts up the correct source name.
        //  3) Announcement to direct host IPX need to go via the bowser.  The
        //      SMB server driver returns an error if you try to go that way.
        //
        // If these requirements ever conflict, one of the mechanisms below
        //  will need to be fixed to support the conflicting needs.
        //
        if ( IsPrimaryDomain ) {
            status = SendSecondClassMailslot(
                Transport,
                packet,
                FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET, BrowseAnnouncement.Comment) +
                        serverCommentLength,
                EmulatedDomainName,
                "\\MAILSLOT\\BROWSE",
                (UCHAR)(serviceType & SV_TYPE_MASTER_BROWSER ?
                        BROWSER_ELECTION_SIGNATURE :
                        MASTER_BROWSER_SIGNATURE)
                );
        } else {
            status = ERROR_NOT_SUPPORTED;
        }

        if ( status != NERR_Success ) {
            UCHAR packetBuffer[sizeof(LMDR_REQUEST_PACKET)+(MAX_PATH)*sizeof(WCHAR)];
            PLMDR_REQUEST_PACKET requestPacket = (PLMDR_REQUEST_PACKET)packetBuffer;
            UNICODE_STRING TransportString;

            RtlInitUnicodeString(&TransportString, Transport);

            requestPacket->Version = LMDR_REQUEST_PACKET_VERSION;

            requestPacket->TransportName = TransportString;
            RtlInitUnicodeString( &requestPacket->EmulatedDomainName, EmulatedDomainName );

            requestPacket->Type = Datagram;

            requestPacket->Parameters.SendDatagram.DestinationNameType = (serviceType & SV_TYPE_MASTER_BROWSER ? BrowserElection : MasterBrowser);

            requestPacket->Parameters.SendDatagram.MailslotNameLength = 0;

            //
            //  The domain announcement name is special, so we don't have to specify
            //  a destination name for it.
            //

            requestPacket->Parameters.SendDatagram.NameLength = STRLEN(EmulatedDomainName)*sizeof(TCHAR);

            STRCPY(requestPacket->Parameters.SendDatagram.Name, EmulatedDomainName);

            //
            //  This is a simple IoControl - It just sends the datagram.
            //

            status = SsBrowserIoControl(IOCTL_LMDR_WRITE_MAILSLOT,
                                        packet,
                                        FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET, BrowseAnnouncement.Comment) +
                                            serverCommentLength,
                                        requestPacket,
                                        FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.SendDatagram.Name)+
                                            requestPacket->Parameters.SendDatagram.NameLength);
        }
    }

    MIDL_user_free( packet );

} // SsAnnounce


ULONG
ComputeTransportAddressClippedLength(
    IN PCHAR TransportAddress,
    IN ULONG TransportAddressLength
    )

/*++

Routine Description:

    This routine returns the length of the transport address with the trailing
    blanks removed.

Arguments:

    TransportAddress - Transport address with potentially trailing blanks

    TransportAddressLength - Length of the Transport Address including trailing
        blanks

Return Value:

    Length of the Transport Address excluding trailing blanks.

--*/

{
    PCHAR p;

    //
    // Cut off any trailing spaces
    //
    p = &TransportAddress[ TransportAddressLength ];
    for( ; p > TransportAddress && *(p-1) == ' '; p-- )
        ;

    return (ULONG)(p - TransportAddress);
}



VOID
Announce (
    IN BOOL DoNtAnnouncement,
    IN DWORD NtInterval,
    IN BOOL DoLmAnnouncement,
    IN BOOL TerminationAnnouncement
    )

/*++

Routine Description:

    This routine sends a broadcast datagram as a second-class mailslot
    that announces the presence of this server using all
    of the configured server names and all networks.

Arguments:

    DoNtAnnouncement - Do an Nt-style announcement.

    NtInterval - NT announcement interval (in seconds)

    DoLmAnnouncement - Do an Lm-style announcement.

    TerminationAnnouncement - if TRUE, send the announcement that
        indicates that this server is going away.  Otherwise, send
        the normal message that tells clients that we're here.


Return Value:

    None.

--*/

{
    PNAME_LIST_ENTRY Service;
    PTRANSPORT_LIST_ENTRY Transport;
    NTSTATUS status;
    OEM_STRING OemAnnounceName;

    (VOID)RtlAcquireResourceShared( &SsData.SsServerInfoResource, TRUE );

    //
    // Loop through each emulated server name announcing on each.
    //

    for( Service = SsData.SsServerNameList; Service != NULL; Service = Service->Next ) {

        //
        // Save the AnnounceName without trailing blanks.
        //

        OemAnnounceName.Length = (USHORT) ComputeTransportAddressClippedLength(
                                    Service->TransportAddress,
                                    Service->TransportAddressLength );

        OemAnnounceName.MaximumLength = OemAnnounceName.Length;
        OemAnnounceName.Buffer = Service->TransportAddress;

        if( OemAnnounceName.Length == 0 ) {
            //
            // A blank name???
            //
            continue;
        }


        //
        // Loop through each transport announcing on each.
        //

        for( Transport = Service->Transports; Transport != NULL; Transport = Transport->Next ) {


            //
            // Do the actual announcement
            // NTBUG 125806 : We pass TRUE for isPrimaryDomain but for DCs w/ multiple hosted
            // domains (future plan-- NT6) we will have to figure out how to set this
            // flag appropriately. For Win2K (NT5) this is not an issue. See bug 286735
            // addressing a problem to the cluster service).
            //

            SsAnnounce( &OemAnnounceName,
                         Service->DomainName,
                         DoNtAnnouncement,
                         NtInterval,
                         DoLmAnnouncement,
                         TerminationAnnouncement,
                         TRUE,
                         Transport->TransportName,
                         Service->ServiceBits | Transport->ServiceBits );

        }
    }

    RtlReleaseResource( &SsData.SsServerInfoResource );
}



NET_API_STATUS
SendSecondClassMailslot (
    IN LPTSTR Transport OPTIONAL,
    IN PVOID Message,
    IN DWORD MessageLength,
    IN LPTSTR Domain,
    IN LPSTR MailslotNameText,
    IN UCHAR SignatureByte
    )
{
    NET_API_STATUS status;
    DWORD dataSize;
    DWORD smbSize;
    PSMB_HEADER header;
    PSMB_TRANSACT_MAILSLOT parameters;
    LPSTR mailslotName;
    DWORD mailslotNameLength;
    PVOID message;
    DWORD domainLength;
    CHAR domainName[NETBIOS_NAME_LEN];
    PCHAR domainNamePointer;
    PSERVER_REQUEST_PACKET srp;

    UNICODE_STRING domainString;
    OEM_STRING oemDomainString;

    srp = SsAllocateSrp();

    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlInitUnicodeString(&domainString, Domain);

    oemDomainString.Buffer = domainName;
    oemDomainString.MaximumLength = sizeof(domainName);

    status = RtlUpcaseUnicodeStringToOemString(
                                    &oemDomainString,
                                    &domainString,
                                    FALSE
                                    );

    if (!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }

    domainLength = oemDomainString.Length;

    domainNamePointer = &domainName[domainLength];

    for ( ; domainLength < NETBIOS_NAME_LEN - 1 ; domainLength++ ) {
        *domainNamePointer++ = ' ';
    }

    //
    // Append the signature byte to the end of the name.
    //

    *domainNamePointer = SignatureByte;

    domainLength += 1;

    srp->Name1.Buffer = (PWSTR)domainName;
    srp->Name1.Length = (USHORT)domainLength;
    srp->Name1.MaximumLength = (USHORT)domainLength;

    if ( ARGUMENT_PRESENT ( Transport ) ) {
        RtlInitUnicodeString( &srp->Name2, Transport );

    } else {

        srp->Name2.Buffer = NULL;
        srp->Name2.Length = 0;
        srp->Name2.MaximumLength = 0;
    }

    //
    // Determine the sizes of various fields that will go in the SMB
    // and the total size of the SMB.
    //

    mailslotNameLength = strlen( MailslotNameText );

    dataSize = mailslotNameLength + 1 + MessageLength;
    smbSize = sizeof(SMB_HEADER) + sizeof(SMB_TRANSACT_MAILSLOT) - 1 + dataSize;

    //
    // Allocate enough memory to hold the SMB.  If we can't allocate the
    // memory, don't do an announcement.
    //

    header = MIDL_user_allocate( smbSize );
    if ( header == NULL ) {

        SsFreeSrp( srp );

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Fill in the header.  Most of the fields don't matter and are
    // zeroed.
    //

    RtlZeroMemory( header, smbSize );

    header->Protocol[0] = 0xFF;
    header->Protocol[1] = 'S';
    header->Protocol[2] = 'M';
    header->Protocol[3] = 'B';
    header->Command = SMB_COM_TRANSACTION;

    //
    // Get the pointer to the params and fill them in.
    //

    parameters = (PSMB_TRANSACT_MAILSLOT)( header + 1 );
    mailslotName = (LPSTR)( parameters + 1 ) - 1;
    message = mailslotName + mailslotNameLength + 1;

    parameters->WordCount = 0x11;
    SmbPutUshort( &parameters->TotalDataCount, (WORD)MessageLength );
    SmbPutUlong( &parameters->Timeout, 0x3E8 );                // !!! fix
    SmbPutUshort( &parameters->DataCount, (WORD)MessageLength );
    SmbPutUshort(
        &parameters->DataOffset,
        (WORD)( (DWORD_PTR)message - (DWORD_PTR)header )
        );
    parameters->SetupWordCount = 3;
    SmbPutUshort( &parameters->Opcode, MS_WRITE_OPCODE );
    SmbPutUshort( &parameters->Class, 2 );
    SmbPutUshort( &parameters->ByteCount, (WORD)dataSize );

    RtlCopyMemory( mailslotName, MailslotNameText, mailslotNameLength + 1 );

    RtlCopyMemory( message, Message, MessageLength );

    status = SsServerFsControl(
                 FSCTL_SRV_SEND_DATAGRAM,
                 srp,
                 header,
                 smbSize
                 );

    if ( status != NERR_Success ) {
        SS_PRINT(( "SendSecondClassMailslot: NtFsControlFile failed: %X\n",
                    status ));
    }

    MIDL_user_free( header );

    SsFreeSrp( srp );

    return status;

} // SendSecondClassMailslot

NTSTATUS
OpenBrowser(
    OUT PHANDLE BrowserHandle
    )
/*++

Routine Description:

    This function opens a handle to the bowser device driver.

Arguments:

    OUT PHANDLE BrowserHandle - Returns the handle to the browser.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;

    UNICODE_STRING deviceName;

    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;


    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&deviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &objectAttributes,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   BrowserHandle,
                   SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                   &objectAttributes,
                   &ioStatusBlock,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = ioStatusBlock.Status;
    }

    return ntstatus;

}

NET_API_STATUS
SsBrowserIoControl (
    IN DWORD IoControlCode,
    IN PVOID Buffer,
    IN DWORD BufferLength,
    IN PLMDR_REQUEST_PACKET Packet,
    IN DWORD PacketLength
    )
{
    HANDLE browserHandle;
    NTSTATUS status;
    PLMDR_REQUEST_PACKET realPacket;
    DWORD RealPacketSize;
    DWORD bytesReturned;
    LPBYTE Where;

    //
    //  Open the browser device driver.
    //

    if ( !NT_SUCCESS(status = OpenBrowser(&browserHandle)) ) {
        return RtlNtStatusToDosError(status);
    }

    //
    //  Now copy the request packet to a new buffer to allow us to pack the
    //  transport name to the end of the buffer we pass to the driver.
    //

    RealPacketSize = PacketLength+Packet->TransportName.MaximumLength;
    RealPacketSize += Packet->EmulatedDomainName.MaximumLength;
    realPacket = MIDL_user_allocate( RealPacketSize );
    if (realPacket == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlCopyMemory(realPacket, Packet, PacketLength);
    Where = ((LPBYTE)realPacket)+PacketLength;

    if (Packet->TransportName.Length != 0) {

        realPacket->TransportName.Buffer = (LPWSTR) Where;

        realPacket->TransportName.MaximumLength = Packet->TransportName.MaximumLength;

        RtlCopyUnicodeString(&realPacket->TransportName, &Packet->TransportName);

        Where += Packet->TransportName.MaximumLength;
    }

    if (Packet->EmulatedDomainName.Length != 0) {

        realPacket->EmulatedDomainName.Buffer = (LPWSTR) Where;

        realPacket->EmulatedDomainName.MaximumLength = Packet->EmulatedDomainName.MaximumLength;

        RtlCopyUnicodeString(&realPacket->EmulatedDomainName, &Packet->EmulatedDomainName);

        Where += Packet->EmulatedDomainName.MaximumLength;
    }

    //
    // Send the request to the Datagram Receiver DD.
    //

    if (!DeviceIoControl(
                   browserHandle,
                   IoControlCode,
                   realPacket,
                   RealPacketSize,
                   Buffer,
                   BufferLength,
                   &bytesReturned,
                   NULL
                   )) {
        status = GetLastError();
    }

    MIDL_user_free(realPacket);

    CloseHandle(browserHandle);

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\sess.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    Sess.c

Abstract:

    This module contains support for the Session catagory of APIs for the
    NT server service.

Author:

    David Treadwell (davidtr)    30-Jan-1991

Revision History:

--*/

#include "srvsvcp.h"
#include <lmerr.h>


NET_API_STATUS NET_API_FUNCTION
NetrSessionDel (
    IN LPTSTR ServerName,
    IN LPTSTR ClientName OPTIONAL,
    IN LPTSTR UserName OPTIONAL
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetSessionDel function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;

    ServerName;

    //
    // Make sure that the caller has the access necessary for this
    // operation.
    //

    error = SsCheckAccess(
                &SsSessionSecurityObject,
                SRVSVC_SESSION_DELETE
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Translate zero-length strings to NULL pointers.
    //

    if ( (ClientName != NULL) && (*ClientName == L'\0') ) {
        ClientName = NULL;
    }

    if ( (UserName != NULL) && (*UserName == L'\0') ) {
        UserName = NULL;
    }

    //
    // Either the client name or the user name must be specified.  It
    // is not legal to leave both NULL, as this would imply "log out all
    // users."  If that's what you want, stop the server.
    //

    if ( ClientName == NULL && UserName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set up the request packet.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlInitUnicodeString( &srp->Name1, ClientName );
    RtlInitUnicodeString( &srp->Name2, UserName );

    //
    // Simply send the request on to the server.
    //

    error = SsServerFsControl( FSCTL_SRV_NET_SESSION_DEL, srp, NULL, 0 );

    SsFreeSrp( srp );

    return error;

} // NetrSessionDel


NET_API_STATUS NET_API_FUNCTION
NetrSessionEnum (
    IN LPTSTR ServerName,
    IN LPTSTR ClientName OPTIONAL,
    IN LPTSTR UserName OPTIONAL,
    OUT PSESSION_ENUM_STRUCT InfoStruct,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    This routine communicates with the server FSD to implement the
    NetSessionEnum function.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    NET_API_STATUS error;
    PSERVER_REQUEST_PACKET srp;
    ACCESS_MASK desiredAccess;

    ServerName;

    //
    // Make sure we have basic sanity on our input parameters
    //
    if( !ARGUMENT_PRESENT( InfoStruct ) ||
        InfoStruct->SessionInfo.Level2 == NULL ||
        InfoStruct->SessionInfo.Level2->Buffer != NULL ) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure that the level is valid and determine the access
    // necessary for the level.
    //

    switch ( InfoStruct->Level ) {

    case 0:
    case 10:
        desiredAccess = SRVSVC_SESSION_USER_INFO_GET;
        break;

    case 1:
    case 2:
    case 502:
        desiredAccess = SRVSVC_SESSION_ADMIN_INFO_GET;
        break;

    default:

        return ERROR_INVALID_LEVEL;
    }

    //
    // Make sure that the caller has the access necessary for this
    // operation.
    //

    error = SsCheckAccess(
                &SsSessionSecurityObject,
                desiredAccess
                );

    if ( error != NO_ERROR ) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Translate zero-length strings to NULL pointers.
    //

    if ( (ClientName != NULL) && (*ClientName == L'\0') ) {
        ClientName = NULL;
    }

    if ( (UserName != NULL) && (*UserName == L'\0') ) {
        UserName = NULL;
    }

    //
    // Is a client name was specified, make sure client name starts with "\\"
    //

    if ( ARGUMENT_PRESENT( ClientName ) &&
         (ClientName[0] != L'\\' || ClientName[1] != L'\\' ) ) {

        return(NERR_InvalidComputer);
    }

    //
    // Set up the input parameters in the request buffer.
    //

    srp = SsAllocateSrp( );
    if ( srp == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    srp->Level = InfoStruct->Level;

    RtlInitUnicodeString( &srp->Name1, ClientName );
    RtlInitUnicodeString( &srp->Name2, UserName );

    if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
        srp->Parameters.Get.ResumeHandle = *ResumeHandle;
    } else {
        srp->Parameters.Get.ResumeHandle = 0;
    }

    //
    // Get the data from the server.  This routine will allocate the
    // return buffer and handle the case where PreferredMaximumLength ==
    // -1.
    //

    error = SsServerFsControlGetInfo(
                FSCTL_SRV_NET_SESSION_ENUM,
                srp,
                (PVOID *)&InfoStruct->SessionInfo.Level2->Buffer,
                PreferredMaximumLength
                );

    //
    // Set up return information.
    //

    InfoStruct->SessionInfo.Level2->EntriesRead =
        srp->Parameters.Get.EntriesRead;

    if ( ARGUMENT_PRESENT( TotalEntries ) ) {
        *TotalEntries = srp->Parameters.Get.TotalEntries;
    }

    if ( srp->Parameters.Get.EntriesRead > 0 ) {

        if ( ARGUMENT_PRESENT( ResumeHandle ) ) {
            *ResumeHandle = srp->Parameters.Get.ResumeHandle;
        }

    } else if ( *TotalEntries == 0 ) {

        //
        // Entries read and total entries is 0.  If a client name or
        // username was specified, return the appropriate error.
        //

        if ( ARGUMENT_PRESENT( UserName ) ) {

            error = NERR_UserNotFound;

        } else if ( ARGUMENT_PRESENT( ClientName ) ) {

            error = NERR_ClientNameNotFound;
        }
    }

    SsFreeSrp( srp );

    return error;

} // NetrSessionEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\srvsvc\server\share.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    Share.c

Abstract:

    This module contains support for the Share catagory of APIs for the
    NT server service.

Author:

    David Treadwell (davidtr)    10-Jan-1991

Revision History:

--*/

#include "srvsvcp.h"
#include "ssreg.h"

#include <lmaccess.h>
#include <lmerr.h>
#include <ntddnfs.h>
#include <tstr.h>
#include <netevent.h>
#include <icanon.h>

#include <seopaque.h>
#include <sertlp.h>
#include <sddl.h>

#define SET_ERROR_PARAMETER(a) \
    if ( ARGUMENT_PRESENT( ErrorParameter ) ) { *ErrorParameter = a; }

//
// Use the same directory separator as the object system uses.
//

#define IS_SLASH_SLASH_NAME( _x )   \
    ( IS_PATH_SEPARATOR( _x[0] ) && \
      IS_PATH_SEPARATOR( _x[1] ) && \
      _x[2] == L'.'              && \
      IS_PATH_SEPARATOR( _x[3] ) )

#define IS_NTPATH_NAME( _x )   \
    ( _x && \
      IS_PATH_SEPARATOR( _x[0] ) && \
      IS_PATH_SEPARATOR( _x[1] ) && \
      _x[2] == L'?'              && \
      IS_PATH_SEPARATOR( _x[3] ) )


//
// Local types.
//

PSHARE_DEL_CONTEXT SrvShareDelContextHead = N