ta.Header.SectionId == Contrib->m_SectionId);
        ASSERT(InitData.Header.ContributorContext == NULL);
        ASSERT(InitData.Header.Flags == 0);

        Contrib->m_DllHandle = DllHandle.Detach();
        Contrib->m_CallbackFunction = CallbackFunction;
        Contrib->m_ContributorContext = InitData.Header.ContributorContext;
    }
    fSuccess = TRUE;
Exit:
    return fSuccess;
#else
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\assemblyreference.h ===
#if !defined(_FUSION_SXS_ASSEMBLYREFERENCE_H_INCLUDED_)
#define _FUSION_SXS_ASSEMBLYREFERENCE_H_INCLUDED_

#pragma once

#include "sxsp.h"
#include "fusionhash.h"

class CAssemblyReference
{
public:
    CAssemblyReference();
    ~CAssemblyReference();

    BOOL TakeValue(const CAssemblyReference &r);

public:
    BOOL Initialize();
//  BOOL Initialize(PCWSTR AssemblyName, SIZE_T AssemblyNameCch, const ASSEMBLY_VERSION &rav, LANGID LangId, USHORT ProcessorArchitecture);
    BOOL Initialize(const CAssemblyReference &r); // "copy initializer"
    BOOL Initialize(PCASSEMBLY_IDENTITY Identity);

    bool IsInitialized() const { return m_pAssemblyIdentity != NULL; }

    BOOL Hash(ULONG &rulPseudoKey) const;

    PCASSEMBLY_IDENTITY GetAssemblyIdentity() const { return m_pAssemblyIdentity; }
    BOOL SetAssemblyIdentity(PCASSEMBLY_IDENTITY pAssemblySource); //dupilicate the input parameter
    BOOL SetAssemblyName(PCWSTR AssemblyName, SIZE_T AssemblyNameCch);
    BOOL ClearAssemblyName() ;
    BOOL GetAssemblyName(PCWSTR *Buffer, SIZE_T *Cch) const;

    BOOL SetLanguage(const CBaseStringBuffer &rbuff);
    BOOL ClearLanguage();
    BOOL IsLangIdSpecified(bool &rfSpecified) const;
    BOOL IsLanguageWildcarded(bool &rfWildcarded) const;
    BOOL IsProcessorArchitectureWildcarded(bool &rfWildcarded) const;
    BOOL IsProcessorArchitectureX86(bool &rfIsX86) const;
    BOOL SetProcessorArchitecture(PCWSTR String, SIZE_T Cch);
    BOOL GetPublicKeyToken(OUT CBaseStringBuffer *pbuffPublicKeyToken, OUT BOOL &rfHasPublicKeyToken) const;
    BOOL SetPublicKeyToken(IN const CBaseStringBuffer &rbuffPublicKeyToken);
    BOOL SetPublicKeyToken(IN PCWSTR pszPublicKeyToken, IN SIZE_T cchPublicKeyToken);

    BOOL Assign(const CAssemblyReference &r) ;

protected:
    PASSEMBLY_IDENTITY m_pAssemblyIdentity;

private:
    CAssemblyReference(const CAssemblyReference &r); // intentionally unimplemented
    void operator =(const CAssemblyReference &r); // intentionally unimplemented

};

template <> inline BOOL HashTableHashKey<const CAssemblyReference &>(
    const CAssemblyReference &r,
    ULONG &rulPK
    )
{
    return r.Hash(rulPK);
}

template <> inline BOOL HashTableInitializeKey<const CAssemblyReference &, CAssemblyReference>(
    const CAssemblyReference &keyin,
    CAssemblyReference &keystored
    )
{
    return keystored.Initialize(keyin);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\asmmetadata.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    asmmetadata.cpp

Abstract:

    Activation context section contributor for the assembly metadata section.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    xiaoyuw         09/2000     revise with Assembly Identity
    xiaoyuw         10/2000     get rid of initialize-code because constructer has done it
--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

typedef struct _ASSEMBLY_METADATA_ENTRY *PASSEMBLY_METADATA_ENTRY;
typedef struct _ASSEMBLY_METADATA_CONTEXT *PASSEMBLY_METADATA_CONTEXT;

typedef struct _ASSEMBLY_METADATA_CONTEXT
{
    _ASSEMBLY_METADATA_CONTEXT() { }

    ULONG ApplicationDirectoryPathType;
    PCWSTR ApplicationDirectory;
    SIZE_T ApplicationDirectoryCch;
    PASSEMBLY_METADATA_ENTRY pLastMetaDataEntry;
} ASSEMBLY_METADATA_CONTEXT;

typedef struct _ASSEMBLY_METADATA_ENTRY
{
    _ASSEMBLY_METADATA_ENTRY() :
        AssemblyIdentity(NULL),
        ManifestVersionMajor(0),
        ManifestVersionMinor(0),
        ManifestPathType(ACTIVATION_CONTEXT_PATH_TYPE_NONE),
        PolicyPathType(ACTIVATION_CONTEXT_PATH_TYPE_NONE),
        AssemblyPolicyApplied(FALSE),
        RootPolicyApplied(FALSE),
        IsRootAssembly(FALSE),
        IsPrivateAssembly(FALSE),
        MetadataSatelliteRosterIndex(0),
        AssemblyRosterIndex(0)
        {
            ManifestLastWriteTime.dwLowDateTime = 0;
            ManifestLastWriteTime.dwHighDateTime = 0;
            PolicyLastWriteTime.dwLowDateTime = 0;
            PolicyLastWriteTime.dwHighDateTime = 0;
        }

    ~_ASSEMBLY_METADATA_ENTRY()
    {
        CSxsPreserveLastError ple;
        ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(AssemblyIdentity));
        ple.Restore();
    }

    PCASSEMBLY_IDENTITY AssemblyIdentity; // intermediate data

    ULONG ManifestPathType;
    FILETIME ManifestLastWriteTime;
    ULONG PolicyPathType;
    FILETIME PolicyLastWriteTime;
    BOOL AssemblyPolicyApplied;
    BOOL RootPolicyApplied;
    BOOL IsRootAssembly;
    BOOL IsPrivateAssembly;
    ULONG ManifestVersionMajor;
    ULONG ManifestVersionMinor;
    CSmallStringBuffer AssemblyDirectoryNameBuffer;
    ULONG MetadataSatelliteRosterIndex;
    ULONG AssemblyRosterIndex;
    ULONG FileNum;
    CSmallStringBuffer LanguageBuffer;
    CSmallStringBuffer ManifestPathBuffer;
    CTinyStringBuffer PolicyPathBuffer;

private:
    _ASSEMBLY_METADATA_ENTRY(const _ASSEMBLY_METADATA_ENTRY &);
    void operator =(const _ASSEMBLY_METADATA_ENTRY &);

} ASSEMBLY_METADATA_ENTRY;

VOID
WINAPI
SxspAssemblyMetadataContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PSTRING_SECTION_GENERATION_CONTEXT SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    PASSEMBLY_METADATA_ENTRY Entry = NULL;
    PASSEMBLY_METADATA_CONTEXT AssemblyMetadataContext = NULL;
    BOOL Found = FALSE;
    PASSEMBLY_IDENTITY TempAssemblyIdentity = NULL;

    if (SSGenContext != NULL)
        AssemblyMetadataContext = (PASSEMBLY_METADATA_CONTEXT) ::SxsGetStringSectionGenerationContextCallbackContext(SSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        {
            PACTCTXCTB_CBACTCTXGENBEGINNING CBData = (PACTCTXCTB_CBACTCTXGENBEGINNING) Data;
            PASSEMBLY_METADATA_CONTEXT AssemblyMetadataContext = NULL;

            CBData->Success = FALSE;

            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                IFALLOCFAILED_EXIT(AssemblyMetadataContext = new ASSEMBLY_METADATA_CONTEXT);

                AssemblyMetadataContext->ApplicationDirectory = CBData->ApplicationDirectory;
                AssemblyMetadataContext->ApplicationDirectoryCch = CBData->ApplicationDirectoryCch;
                AssemblyMetadataContext->ApplicationDirectoryPathType = CBData->ApplicationDirectoryPathType;
                AssemblyMetadataContext->pLastMetaDataEntry = NULL;

                IFW32FALSE_EXIT(::SxsInitStringSectionGenerationContext(
                        &SSGenContext,
                        ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_FORMAT_WHISTLER,
                        TRUE,
                        SxspAssemblyMetadataStringSectionGenerationCallback,
                        AssemblyMetadataContext));

            }

            CBData->Success = TRUE;
            CBData->Header.ActCtxGenContext = SSGenContext;
            break;
        }

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (SSGenContext != NULL)
            ::SxsDestroyStringSectionGenerationContext(SSGenContext);
        FUSION_DELETE_SINGLETON(AssemblyMetadataContext);
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        {
            PACTCTXCTB_CBACTCTXGENENDED CBData = (PACTCTXCTB_CBACTCTXGENENDED) Data;
            CBData->Success = FALSE;
            if (SSGenContext != NULL)
                IFW32FALSE_EXIT(::SxsDoneModifyingStringSectionGenerationContext(SSGenContext));
            CBData->Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_IDENTITYDETERMINED:
        {
            PACTCTXCTB_CBIDENTITYDETERMINED CBData = (PACTCTXCTB_CBIDENTITYDETERMINED)Data;
            SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT)CBData->Header.ActCtxGenContext;
            SIZE_T cbEncoding = 0;
            BOOL Found = FALSE;
            CStringBufferAccessor acc;
            CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> pAsmIdentTemp;

            //
            // If we're not generating an actctx, then we don't have to do anything for it.
            //
            if (Data->Header.ManifestOperation != MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                CBData->Success = TRUE;
                FN_SUCCESSFUL_EXIT();
            }

            INTERNAL_ERROR_CHECK(SSGenContext != NULL);

            //
            // Find the last one that was added, and stamp the new assembly identity into it
            //
            if (AssemblyMetadataContext->pLastMetaDataEntry != NULL)
            {
                Entry = AssemblyMetadataContext->pLastMetaDataEntry;
                if (Entry->AssemblyIdentity != NULL)
                {
                    SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(Entry->AssemblyIdentity));
                    Entry->AssemblyIdentity = NULL;
                }

                IFW32FALSE_EXIT(SxsDuplicateAssemblyIdentity(0, CBData->AssemblyIdentity, &pAsmIdentTemp));
                Entry->AssemblyIdentity = pAsmIdentTemp.Detach();
                AssemblyMetadataContext->pLastMetaDataEntry = NULL;
            }
            
            CBData->Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        {
            PACTCTXCTB_CBGETSECTIONSIZE CBData = (PACTCTXCTB_CBGETSECTIONSIZE) Data;
            SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) CBData->Header.ActCtxGenContext;
            INTERNAL_ERROR_CHECK(SSGenContext != NULL);
            IFW32FALSE_EXIT(::SxsGetStringSectionGenerationContextSectionSize(SSGenContext, &CBData->SectionSize));
            break;
        }

    case ACTCTXCTB_CBREASON_PARSEBEGINNING:
        {
            Data->ParseBeginning.Success = FALSE;

            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                PCWSTR pszAssemblyName = NULL;
                SIZE_T CchAssemblyName = 0;
                PCASSEMBLY_IDENTITY AssemblyIdentity = Data->ParseBeginning.AssemblyContext->AssemblyIdentity;

                if (AssemblyIdentity != NULL)
                {
                    IFW32FALSE_EXIT(
                        ::SxspGetAssemblyIdentityAttributeValue(
                            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                            AssemblyIdentity,
                            &s_IdentityAttribute_name,
                            &pszAssemblyName,
                            &CchAssemblyName));
                }

                switch (Data->ParseBeginning.ParseType)
                {
                case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
                    if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                    {
                        // If there is a policy file, it will be hit first.
                        IFALLOCFAILED_EXIT(Entry = new ASSEMBLY_METADATA_ENTRY);
                        Entry->AssemblyIdentity = NULL;

                        Entry->PolicyPathType = Data->ParseBeginning.FilePathType;
                        IFW32FALSE_EXIT(Entry->PolicyPathBuffer.Win32Assign(Data->ParseBeginning.FilePath, Data->ParseBeginning.FilePathCch));
                        Entry->PolicyLastWriteTime = Data->ParseBeginning.FileLastWriteTime;

                        Entry->AssemblyRosterIndex = Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex;

                        IFW32FALSE_EXIT(
                            ::SxsAddStringToStringSectionGenerationContext(
                                (PSTRING_SECTION_GENERATION_CONTEXT) Data->ParseBeginning.Header.ActCtxGenContext,
                                pszAssemblyName,
                                CchAssemblyName,
                                Entry,
                                Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex,
                                ERROR_SXS_DUPLICATE_ASSEMBLY_NAME));
                    }

                    break;

                case XML_FILE_TYPE_MANIFEST:
                    IFW32FALSE_EXIT(
                        ::SxsFindStringInStringSectionGenerationContext(
                            (PSTRING_SECTION_GENERATION_CONTEXT) Data->ParseBeginning.Header.ActCtxGenContext,
                            pszAssemblyName,
                            CchAssemblyName,
                            (PVOID *) &Entry,
                            &Found));

                    if (!Found)
                    {
                        // Haven't seen it before; allocate it!
                        IFALLOCFAILED_EXIT(Entry = new ASSEMBLY_METADATA_ENTRY);

                        IFW32FALSE_EXIT(
                            ::SxsAddStringToStringSectionGenerationContext(
                                (PSTRING_SECTION_GENERATION_CONTEXT) Data->ParseBeginning.Header.ActCtxGenContext,
                                pszAssemblyName,
                                CchAssemblyName,
                                Entry,
                                Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex,
                                ERROR_SXS_DUPLICATE_ASSEMBLY_NAME));

                        Entry->AssemblyRosterIndex = Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex;
                    }
                    else
                    {
                        // The linkage between the root manifest's policy entry and the actual entry for it
                        // is tenuous since the root policy is parsed before we've started keeping track of
                        // the actual contents of the assembly.  So, we would have previously added it
                        // under XML_FILE_TYPE_APPLICATION_CONFIGURATION, but the code that sets the
                        // AssemblyRosterIndex (way up the call stack) is making a somewhat random assumption
                        // that the root is at roster index 1.  It's a good assumption but conceptually
                        // fragile; thus this assert/internal error report if it fails.
                        INTERNAL_ERROR_CHECK(Entry->AssemblyRosterIndex == Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex);
                    }

                    INTERNAL_ERROR_CHECK(Entry->AssemblyIdentity == NULL);

                    IFW32FALSE_EXIT(
                        ::SxsDuplicateAssemblyIdentity(
                            0,
                            Data->ParseBeginning.AssemblyContext->AssemblyIdentity,      // PCASSEMBLY_IDENTITY Source,
                            &TempAssemblyIdentity));

                    Entry->AssemblyIdentity = TempAssemblyIdentity;
                    TempAssemblyIdentity = NULL;

                    IFW32FALSE_EXIT(Entry->ManifestPathBuffer.Win32Assign(Data->ParseBeginning.FilePath, Data->ParseBeginning.FilePathCch));
                    Entry->ManifestPathType = Data->ParseBeginning.FilePathType;

                    // If the assembly has a name, record its directory
                    if (CchAssemblyName != 0)
                    {
                        IFW32FALSE_EXIT(
                            ::SxspGenerateSxsPath(
                                SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
                                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                                NULL,
                                0,
                                Data->ParseBeginning.AssemblyContext->AssemblyIdentity,
                                Entry->AssemblyDirectoryNameBuffer));
                    }

                    Entry->ManifestLastWriteTime = Data->ParseBeginning.FileLastWriteTime;

                    //Entry->Version = Data->ParseBeginning.AssemblyContext->Version;
                    Entry->ManifestVersionMajor = Data->ParseBeginning.FileFormatVersionMajor;
                    Entry->ManifestVersionMinor = Data->ParseBeginning.FileFormatVersionMinor;

                    Entry->MetadataSatelliteRosterIndex = Data->ParseBeginning.MetadataSatelliteRosterIndex;

                    {
                        PCWSTR pszLangID = NULL;
                        SIZE_T CchLangID = 0;

                        // get pointers to LANGID string in AssemblyIdentity
                        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
                                        SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                                        Data->ElementParsed.AssemblyContext->AssemblyIdentity,
                                        &s_IdentityAttribute_language,
                                        &pszLangID, &CchLangID));

                        IFW32FALSE_EXIT(Entry->LanguageBuffer.Win32Assign(pszLangID, CchLangID));
                    }

                    if (Data->ParseBeginning.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_ASSEMBLY_POLICY_APPLIED)
                        Entry->AssemblyPolicyApplied = TRUE;

                    if (Data->ParseBeginning.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_ROOT_POLICY_APPLIED)
                        Entry->RootPolicyApplied = TRUE;

                    if (Data->ParseBeginning.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY)
                        Entry->IsRootAssembly = TRUE;

                    if (Data->ParseBeginning.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_PRIVATE_ASSEMBLY)
                        Entry->IsPrivateAssembly = TRUE;

                    Entry->FileNum = 0;

                    AssemblyMetadataContext->pLastMetaDataEntry = Entry;

                    break;
                }
            }

            Data->ParseBeginning.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        {
            Data->GetSectionData.Success = FALSE;
            INTERNAL_ERROR_CHECK(SSGenContext != NULL);
            IFW32FALSE_EXIT(
                ::SxsGetStringSectionGenerationContextSectionData(
                    SSGenContext,
                    Data->GetSectionData.SectionSize,
                    Data->GetSectionData.SectionDataStart,
                    NULL));
            Data->GetSectionData.Success = TRUE;
            break;
        }
    }

Exit:
    if (TempAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(TempAssemblyIdentity);
}

BOOL
SxspAssemblyMetadataStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PASSEMBLY_METADATA_CONTEXT GlobalContext = reinterpret_cast<PASSEMBLY_METADATA_CONTEXT>(Context);

    INTERNAL_ERROR_CHECK(GlobalContext != NULL);

    switch (Reason)
    {
    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE) CallbackData;
            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION);

            if (GlobalContext->ApplicationDirectoryCch != 0)
                CBData->DataSize += ((GlobalContext->ApplicationDirectoryCch + 1) * sizeof(WCHAR));

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA) CallbackData;
            PACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION GlobalInfo;
            ULONG BytesLeft = static_cast<ULONG>(CBData->BufferSize);
            ULONG BytesWritten = 0;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION);

            GlobalInfo = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION) CBData->Buffer;
            GlobalInfo->Size = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION);
            GlobalInfo->Flags = 0;
            GlobalInfo->PolicyCoherencyGuid = GUID_NULL;
            GlobalInfo->PolicyOverrideGuid = GUID_NULL;

            GlobalInfo->ApplicationDirectoryLength = 0;
            GlobalInfo->ApplicationDirectoryOffset = 0;

            if (GlobalContext->ApplicationDirectoryCch != 0)
            {
                ULONG BytesNeeded = static_cast<ULONG>((GlobalContext->ApplicationDirectoryCch + 1) * sizeof(WCHAR));

                if (BytesLeft < BytesNeeded)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                memcpy(
                    (GlobalInfo + 1),
                    GlobalContext->ApplicationDirectory,
                    BytesNeeded);

                GlobalInfo->ApplicationDirectoryPathType = GlobalContext->ApplicationDirectoryPathType;
                GlobalInfo->ApplicationDirectoryLength = BytesNeeded - sizeof(WCHAR);
                GlobalInfo->ApplicationDirectoryOffset = sizeof(*GlobalInfo);

                GlobalInfo->Size += BytesNeeded;

                BytesWritten += BytesNeeded;
                BytesLeft -= BytesNeeded;
            }

            CBData->BytesWritten = BytesWritten;

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PASSEMBLY_METADATA_ENTRY Entry = (PASSEMBLY_METADATA_ENTRY) CBData->DataContext;
            FUSION_DELETE_SINGLETON(Entry);
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PASSEMBLY_METADATA_ENTRY Entry = (PASSEMBLY_METADATA_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION);

            if (Entry->AssemblyIdentity != NULL)
            {
                SIZE_T cbEncodedSize = 0;
                IFW32FALSE_EXIT(SxsComputeAssemblyIdentityEncodedSize(
                    0, 
                    Entry->AssemblyIdentity, 
                    NULL, 
                    SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                    &cbEncodedSize));
                CBData->DataSize += cbEncodedSize;
            }

            SIZE_T Cch;
#define GET_BUFFER_SIZE(Buffer) (((Cch = (Buffer).Cch()) != 0) ? ((Cch + 1) * sizeof(WCHAR)) : 0)
            CBData->DataSize += GET_BUFFER_SIZE(Entry->ManifestPathBuffer);
            CBData->DataSize += GET_BUFFER_SIZE(Entry->PolicyPathBuffer);
            CBData->DataSize += GET_BUFFER_SIZE(Entry->AssemblyDirectoryNameBuffer);
            CBData->DataSize += GET_BUFFER_SIZE(Entry->LanguageBuffer);
#undef GET_BUFFER_SIZE

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PASSEMBLY_METADATA_ENTRY Entry = (PASSEMBLY_METADATA_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Info;

            SIZE_T BytesLeft = (ULONG)(CBData->BufferSize);
            SIZE_T BytesWritten = 0;
            PWSTR StringCursor;
            SIZE_T EncodedIdentityBytesWritten = 0;

            Info = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) CBData->Buffer;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION);

            StringCursor = reinterpret_cast<PWSTR>(Info + 1);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION);
            Info->Flags =
                (Entry->IsRootAssembly ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY : 0) |
                (Entry->IsPrivateAssembly ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_PRIVATE_ASSEMBLY : 0) |
                ((Entry->AssemblyPolicyApplied ||
                  Entry->RootPolicyApplied) ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED : 0) |
                (Entry->AssemblyPolicyApplied ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED : 0) |
                (Entry->RootPolicyApplied ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED : 0);

            if (Entry->AssemblyIdentity != NULL)
            {
                SIZE_T cbWritten = 0;
                
                IFW32FALSE_EXIT(
                    SxsEncodeAssemblyIdentity(
                        0,
                        Entry->AssemblyIdentity,
                        NULL,
                        SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                        BytesLeft,
                        StringCursor,
                        &cbWritten));

		INTERNAL_ERROR_CHECK(cbWritten <= MAXULONG);
		INTERNAL_ERROR_CHECK(((PBYTE)StringCursor - (PBYTE)CBData->SectionHeader) <= MAXULONG);

                Info->EncodedAssemblyIdentityOffset = (ULONG)((PBYTE)StringCursor - (PBYTE)CBData->SectionHeader);
                Info->EncodedAssemblyIdentityLength = (ULONG)cbWritten;

                BytesLeft -= cbWritten;
                BytesWritten += cbWritten;
                StringCursor = (PWSTR)(((PBYTE)StringCursor) + cbWritten);
            }
            else
            {
                Info->EncodedAssemblyIdentityOffset = 0;
                Info->EncodedAssemblyIdentityLength = 0;
            }

            IFW32FALSE_EXIT(Entry->ManifestPathBuffer.Win32CopyIntoBuffer(
                &StringCursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->ManifestPathOffset,
                &Info->ManifestPathLength));

            Info->ManifestPathType = Entry->ManifestPathType;
            Info->PolicyPathType = Entry->PolicyPathType;
            Info->ManifestLastWriteTime.LowPart = Entry->ManifestLastWriteTime.dwLowDateTime;
            Info->ManifestLastWriteTime.HighPart = Entry->ManifestLastWriteTime.dwHighDateTime;
            Info->PolicyLastWriteTime.LowPart = Entry->PolicyLastWriteTime.dwLowDateTime;
            Info->PolicyLastWriteTime.HighPart = Entry->PolicyLastWriteTime.dwHighDateTime;

            IFW32FALSE_EXIT(Entry->PolicyPathBuffer.Win32CopyIntoBuffer(
                &StringCursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->PolicyPathOffset,
                &Info->PolicyPathLength));

            IFW32FALSE_EXIT(Entry->AssemblyDirectoryNameBuffer.Win32CopyIntoBuffer(
                &StringCursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->AssemblyDirectoryNameOffset,
                &Info->AssemblyDirectoryNameLength));

            Info->ManifestVersionMajor = Entry->ManifestVersionMajor;
            Info->ManifestVersionMinor = Entry->ManifestVersionMinor;

            Info->MetadataSatelliteRosterIndex = Entry->MetadataSatelliteRosterIndex;
            Info->NumOfFilesInAssembly = Entry->FileNum;

            IFW32FALSE_EXIT(Entry->LanguageBuffer.Win32CopyIntoBuffer(
                &StringCursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->LanguageOffset,
                &Info->LanguageLength));

            CBData->BytesWritten = BytesWritten;
        }

    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\actctxgenctxctb.cpp ===
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "actctxgenctxctb.h"
#include "sxsexceptionhandling.h"
#include "actctxgenctx.h"

#define ENSURE_LAST_ERROR_SET() \
do \
    { \
    ASSERT(::FusionpGetLastWin32Error() != ERROR_SUCCESS); \
    if (::FusionpGetLastWin32Error() == ERROR_SUCCESS) \
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR); \
    } while (0)

/*-----------------------------------------------------------------------------
ACTivation ConTeXt GENneration ConTeXt ConTriButor
-----------------------------------------------------------------------------*/

int
CActivationContextGenerationContextContributor::Compare(
    const void *pelem1,
    const void *pelem2
    )
{
    const CActivationContextGenerationContextContributor *Ctb1 = reinterpret_cast<const CActivationContextGenerationContextContributor *>(pelem1);
    const CActivationContextGenerationContextContributor *Ctb2 = reinterpret_cast<const CActivationContextGenerationContextContributor *>(pelem2);

    if (Ctb1->IsExtendedSection())
    {
        if (!Ctb2->IsExtendedSection())
            return -1;

        // otherwise they're both extended...
        int i = memcmp(Ctb1->m_ActCtxCtb->GetExtensionGuidPtr(), Ctb2->m_ActCtxCtb->GetExtensionGuidPtr(), sizeof(GUID));
        if (i != 0)
            return i;
    }
    else
    {
        if (Ctb2->IsExtendedSection())
            return +1;
    }

    // comparison of unsigned numbers by subtraction does not work,
    // you can cast them to signed first, but this seems cleaner
    const ULONG sectionId1 = Ctb1->m_ActCtxCtb->m_SectionId;
    const ULONG sectionId2 = Ctb2->m_ActCtxCtb->m_SectionId;
    if (sectionId1 < sectionId2)
        return -1;
    if (sectionId1 > sectionId2)
        return +1;

    return 0;
}

CActivationContextGenerationContextContributor::~CActivationContextGenerationContextContributor()
{
    FN_TRACE();
    if (m_ActCtxCtb != NULL)
    {
        CSxsPreserveLastError ple;
        m_ActCtxCtb->Release();
        ple.Restore();
    }
}

VOID
CActivationContextGenerationContextContributor::PopulateCallbackHeader(
    ACTCTXCTB_CBHEADER &Header,
    ULONG Reason,
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    FN_TRACE();

    Header.Reason = Reason;
    Header.Flags = pActCtxGenCtx->m_Flags;
    Header.ManifestOperation = pActCtxGenCtx->m_ManifestOperation;
    Header.ManifestOperationFlags = pActCtxGenCtx->m_ManifestOperationFlags;
    Header.InstallationContext = &pActCtxGenCtx->m_InstallationContext;
    Header.ClsidMappingContext = &pActCtxGenCtx->m_ClsidMappingContext;
    Header.ExtensionGuid = m_ActCtxCtb->GetExtensionGuidPtr();
    Header.SectionId = m_ActCtxCtb->m_SectionId;
    Header.ContributorContext = m_ActCtxCtb->m_ContributorContext;
    Header.pOriginalActCtxGenCtx = pActCtxGenCtx;
    if (m_ManifestParseContextValid)
        Header.ManifestParseContext = m_ManifestParseContext;
    else
        Header.ManifestParseContext = NULL;
    Header.ActCtxGenContext = m_ActCtxGenContext;
}

BOOL
CActivationContextGenerationContextContributor::Initialize(
    PACTCTXCTB ActCtxCtb,
    PVOID ActCtxGenContext
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_ActCtxCtb == NULL);
    INTERNAL_ERROR_CHECK(m_ActCtxGenContext == NULL);

    PARAMETER_CHECK(ActCtxCtb != NULL);

    ActCtxCtb->AddRef();
    m_ActCtxCtb = ActCtxCtb;

    m_ActCtxGenContext = ActCtxGenContext;
    m_IsExtendedSection = ActCtxCtb->m_IsExtendedSection;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

PCWSTR
CActivationContextGenerationContextContributor::Name() const
{
    return m_ActCtxCtb->m_ContributorNameBuffer;
}

const GUID &
CActivationContextGenerationContextContributor::ExtensionGuid() const
{
    return m_ActCtxCtb->m_ExtensionGuid;
}

ULONG
CActivationContextGenerationContextContributor::SectionId() const
{
    return m_ActCtxCtb->m_SectionId;
}

ULONG
CActivationContextGenerationContextContributor::SectionFormat() const
{
    return m_ActCtxCtb->m_Format;
}

BOOL
CActivationContextGenerationContextContributor::Fire_AllParsingDone(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ACTCTXCTB_CBALLPARSINGDONE CBData;

    this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ALLPARSINGDONE, pActCtxGenCtx);

    CBData.Success = TRUE;
    ::FusionpSetLastWin32Error(ERROR_SUCCESS);

    (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

    if (!CBData.Success)
    {
        ENSURE_LAST_ERROR_SET();
        pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CActivationContextGenerationContextContributor::Fire_GetSectionSize(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ACTCTXCTB_CBGETSECTIONSIZE CBData;

    this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_GETSECTIONSIZE, pActCtxGenCtx);

    CBData.SectionSize = 0;
    CBData.Success = TRUE;
    ::FusionpSetLastWin32Error(ERROR_SUCCESS);

    (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

    if (!CBData.Success)
    {
        ENSURE_LAST_ERROR_SET();
        pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        goto Exit;
    }

    m_SectionSize = CBData.SectionSize;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
CActivationContextGenerationContextContributor::Fire_GetSectionData(
    PACTCTXGENCTX pActCtxGenCtx,
    PVOID Buffer
    )
{
    BOOL fSuccess = TRUE;
    FN_TRACE_WIN32(fSuccess);

    ACTCTXCTB_CBGETSECTIONDATA CBData;

    this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_GETSECTIONDATA, pActCtxGenCtx);
    CBData.SectionSize = m_SectionSize;
    CBData.SectionDataStart = Buffer;
    CBData.Success = TRUE;
    ::FusionpSetLastWin32Error(ERROR_SUCCESS);

    (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

    if (!CBData.Success)
    {
        ENSURE_LAST_ERROR_SET();
        pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CActivationContextGenerationContextContributor::Fire_ParseEnding(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if ((m_ActCtxCtb != NULL) &&
        (m_ManifestParseContextValid) &&
        (!m_NoMoreCallbacksThisFile))
    {
        if (m_ManifestParseContextValid)
        {
            ACTCTXCTB_CBPARSEENDING CBData;

            this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_PARSEENDING, pActCtxGenCtx);
            CBData.AssemblyContext = AssemblyContext;
            CBData.Success = TRUE;
            ::FusionpSetLastWin32Error(ERROR_SUCCESS);

            (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

            if (!CBData.Success)
            {
                ENSURE_LAST_ERROR_SET();
                pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
                goto Exit;
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID
CActivationContextGenerationContextContributor::Fire_ParseEnded(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    FN_TRACE();
    if ((m_ActCtxCtb != NULL) &&
        (m_ManifestParseContextValid) &&
        (!m_NoMoreCallbacksThisFile))
    {
        if (m_ManifestParseContextValid)
        {
            CSxsPreserveLastError ple;
            ACTCTXCTB_CBPARSEENDED CBData;

            this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_PARSEENDED, pActCtxGenCtx);
            CBData.AssemblyContext = AssemblyContext;

            (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

            m_ManifestParseContextValid = FALSE;
            m_ManifestParseContext = NULL;

            ple.Restore();
        }
    }
}

BOOL
CActivationContextGenerationContextContributor::Fire_ActCtxGenEnding(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (m_ActCtxCtb != NULL)
    {
        ACTCTXCTB_CBACTCTXGENENDING CBData;
        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ACTCTXGENENDING, pActCtxGenCtx);
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);
        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);
        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

VOID
CActivationContextGenerationContextContributor::Fire_ActCtxGenEnded(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    FN_TRACE();
    if (m_ActCtxCtb != NULL)
    {
        CSxsPreserveLastError ple;
        ACTCTXCTB_CBACTCTXGENENDED CBData;
        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ACTCTXGENENDED, pActCtxGenCtx);
        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);
        m_ActCtxGenContext = NULL;
        ple.Restore();
    }
}

BOOL
CActivationContextGenerationContextContributor::Fire_BeginChildren(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    PCSXS_NODE_INFO NodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBBEGINCHILDREN CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_BEGINCHILDREN, pActCtxGenCtx);
        CBData.AssemblyContext = AssemblyContext;
        CBData.ParseContext = ParseContext;
        CBData.NodeInfo = NodeInfo;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CActivationContextGenerationContextContributor::Fire_EndChildren(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    BOOL Empty,
    PCSXS_NODE_INFO NodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBENDCHILDREN CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ENDCHILDREN, pActCtxGenCtx);
        CBData.Empty = Empty;
        CBData.NodeInfo = NodeInfo;
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CActivationContextGenerationContextContributor::Fire_ElementParsed(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    USHORT NodeCount,
    PCSXS_NODE_INFO NodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBELEMENTPARSED CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ELEMENTPARSED, pActCtxGenCtx);
        CBData.NodeCount = NodeCount;
        CBData.NodeInfo = NodeInfo;
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:

    return fSuccess;
}

BOOL
CActivationContextGenerationContextContributor::Fire_PCDATAParsed(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    const WCHAR *String,
    ULONG Cch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBPCDATAPARSED CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_PCDATAPARSED, pActCtxGenCtx);
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Text = String;
        CBData.TextCch = Cch;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:

    return fSuccess;
}

BOOL
CActivationContextGenerationContextContributor::Fire_CDATAParsed(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    const WCHAR *String,
    ULONG Cch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBCDATAPARSED CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_CDATAPARSED, pActCtxGenCtx);
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Text = String;
        CBData.TextCch = Cch;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:

    return fSuccess;
}

BOOL
CActivationContextGenerationContextContributor::Fire_IdentityDetermined(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBIDENTITYDETERMINED CBData;
        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_IDENTITYDETERMINED, pActCtxGenCtx);
        CBData.AssemblyIdentity = AssemblyIdentity;
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:

    return fSuccess;
}


BOOL
CActivationContextGenerationContextContributor::Fire_ParseBeginning(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    DWORD FileFlags,
    ULONG ParseType,
    ULONG FilePathType,
    PCWSTR FilePath,
    SIZE_T FilePathCch,
    const FILETIME &FileLastWriteTime,
    ULONG FileFormatVersionMajor,
    ULONG FileFormatVersionMinor,
    ULONG MetadataSatelliteRosterIndex
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ACTCTXCTB_CBPARSEBEGINNING CBData;

    PARAMETER_CHECK(FilePathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);

    INTERNAL_ERROR_CHECK(!m_ManifestParseContextValid);

    this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_PARSEBEGINNING, pActCtxGenCtx);

    CBData.FileFlags = FileFlags;
    CBData.ParseType = ParseType;
    CBData.AssemblyContext = AssemblyContext;
    CBData.FilePath = FilePath;
    CBData.FilePathCch = FilePathCch;
    CBData.FilePathType = FilePathType;
    CBData.FileLastWriteTime = FileLastWriteTime;
    CBData.FileFormatVersionMajor = FileFormatVersionMajor;
    CBData.FileFormatVersionMinor = FileFormatVersionMinor;
    CBData.MetadataSatelliteRosterIndex = MetadataSatelliteRosterIndex;
    CBData.NoMoreCallbacksThisFile = FALSE;
    CBData.Success = TRUE;

    (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

    if (!CBData.Success)
    {
        ENSURE_LAST_ERROR_SET();
        pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        goto Exit;
    }

    m_NoMoreCallbacksThisFile = CBData.NoMoreCallbacksThisFile;
    if (!m_NoMoreCallbacksThisFile)
    {
        // If they set the no more callbacks flag, we don't track the parse context.
        m_ManifestParseContext = CBData.Header.ManifestParseContext;
        m_ManifestParseContextValid = TRUE;
    }
    else
    {
        m_ManifestParseContext = NULL;
        m_ManifestParseContextValid = FALSE;
        // You can't pass back a per-file parsing context if you don't want any more callbacks for this
        // file.
        ASSERT(CBData.Header.ManifestParseContext == NULL);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\actctxgenctxctb.h ===
#if !defined(_FUSION_SXS_ACTCTXGENCTXCTB_H_INCLUDED_)
#define _FUSION_SXS_ACTCTXGENCTXCTB_H_INCLUDED_

#pragma once

/*-----------------------------------------------------------------------------
ACTivation ConTeXt GENneration ConTeXt ConTriButor
-----------------------------------------------------------------------------*/

#include "sxsp.h"
#include "ForwardDeclarations.h"

class CActivationContextGenerationContextContributor
{
public:
    CActivationContextGenerationContextContributor() :
        m_ActCtxCtb(NULL),
        m_ActCtxGenContext(NULL),
        m_ManifestParseContext(NULL),
        m_ManifestParseContextValid(FALSE),
        m_NoMoreCallbacksThisFile(FALSE),
        m_SectionSize(0) { }
    ~CActivationContextGenerationContextContributor();

    BOOL Initialize(PACTCTXCTB ActCtxCtb, PVOID ActCtxGenContext);

    VOID PopulateCallbackHeader(ACTCTXCTB_CBHEADER &Header, ULONG Reason, PACTCTXGENCTX pActCtxGenCtx);

    // comparison function for qsort()
    static int __cdecl Compare(const void *pelem1, const void *pelem2);

    bool IsExtendedSection() const { return m_IsExtendedSection; }
    PCWSTR Name() const;
    const GUID &ExtensionGuid() const;
    ULONG SectionId() const;
    ULONG SectionFormat() const;

    BOOL Fire_ParseBeginning(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        DWORD FileFlags,
        ULONG ParseType,
        ULONG FilePathType,
        PCWSTR FilePath,
        SIZE_T FilePathCch,
        const FILETIME &FileLastWriteTime,
        ULONG FileFormatVersionMajor,
        ULONG FileFormatVersionMinor,
        ULONG MetadataSatelliteRosterIndex
        );
    BOOL Fire_IdentityDetermined(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        PCASSEMBLY_IDENTITY AssemblyIdentity
        );
    BOOL Fire_BeginChildren(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        PCSXS_NODE_INFO NodeInfo
        );
    BOOL Fire_EndChildren(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        BOOL Empty,
        PCSXS_NODE_INFO NodeInfo
        );
    BOOL Fire_ElementParsed(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        USHORT NodeCount,
        PCSXS_NODE_INFO NodeInfo
        );
    BOOL Fire_PCDATAParsed(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        const WCHAR *Text,
        ULONG TextCch
        );
    BOOL Fire_CDATAParsed(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        const WCHAR *Text,
        ULONG TextCch
        );
    BOOL Fire_ParseEnding(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );
    VOID Fire_ParseEnded(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );
    BOOL Fire_AllParsingDone(
        PACTCTXGENCTX pActCtxGenCtx
        );
    BOOL Fire_GetSectionSize(
        PACTCTXGENCTX pActCtxGenCtx
        );
    BOOL Fire_GetSectionData(
        PACTCTXGENCTX pActCtxGenCtx,
        PVOID Buffer
        );

    BOOL Fire_ActCtxGenEnding(
        PACTCTXGENCTX pActCtxGenCtx
        );

    VOID Fire_ActCtxGenEnded(
        PACTCTXGENCTX pActCtxGenCtx
        );

    SIZE_T SectionSize() const { return m_SectionSize; }
    PVOID ActCtxGenContext() const { return m_ActCtxGenContext; }

// protected:
    PVOID m_ManifestParseContext;
    BOOL m_ManifestParseContextValid;
    BOOL m_NoMoreCallbacksThisFile;

protected:
    PACTCTXCTB m_ActCtxCtb;
    PVOID m_ActCtxGenContext;
    SIZE_T m_SectionSize;
    bool m_IsExtendedSection;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cassemblycacheitemstream.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CAssemblyCacheItemStream.h

Abstract:
    Like a CFileStream (its base) but also implements Commit over
      associated CAssemblyCacheItem. This functionality was
      moved out of CFileStream.

Author:

    Jay Krell (a-JayK) June 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_CASSEMBLYCACHEITEMSTREAM_H_INCLUDED_)
#define _FUSION_SXS_CASSEMBLYCACHEITEMSTREAM_H_INCLUDED_
#pragma once

#include "objidl.h"
#include "SxsAsmItem.h"
#include "FileStream.h"
#include "SmartRef.h"

class CAssemblyCacheItem;

class CAssemblyCacheItemStream : public CReferenceCountedFileStream
{
private:
    typedef CReferenceCountedFileStream Base;

public:
    CAssemblyCacheItemStream() : Base()
    {
    }

    ~CAssemblyCacheItemStream()
    {
    }

    STDMETHODIMP Commit(
        DWORD grfCommitFlags
        )
    {
        HRESULT hr = NOERROR;
        FN_TRACE_HR(hr);

        PARAMETER_CHECK(grfCommitFlags == 0);
        IFCOMFAILED_EXIT(Base::Commit(grfCommitFlags));

        hr = NOERROR;
    Exit:
        return hr;
    }

private: // intentionally not implemented
    CAssemblyCacheItemStream(const CAssemblyCacheItemStream&);
    void operator=(const CAssemblyCacheItemStream&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cmemorystream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CMemoryStream.cpp

Abstract:

    Minimal implementation of IStream over an array of bytes.

Author:

    Jay Krell (a-JayK) May 2000

Revision History:

--*/
#include "stdinc.h"
#include "CMemoryStream.h"
#include "SxsExceptionHandling.h"

/* aka doesn't make sense aka access denied */
#define NOTIMPL ASSERT_NTC(FALSE) ; return E_NOTIMPL

CMemoryStream::~CMemoryStream()
{
    ASSERT_NTC(m_cRef == 0);
}

ULONG __stdcall CMemoryStream::AddRef()
{
    FN_TRACE_ADDREF(CMemoryStream, m_cRef);
    return ::InterlockedIncrement(&m_cRef);
}

ULONG __stdcall CMemoryStream::Release()
{
    LONG cRef;
    FN_TRACE_RELEASE(CMemoryStream, cRef);

    if ((cRef = ::InterlockedDecrement(&m_cRef)) == 0)
    {
        /*delete this*/;
    }
    return cRef;
}

HRESULT __stdcall
CMemoryStream::QueryInterface(
    REFIID  iid,
    void **ppvObj
    )
{
    HRESULT hr = NOERROR;

    FN_TRACE_HR(hr);

    IUnknown *punk = NULL;
    IUnknown **ppunk = reinterpret_cast<IUnknown **>(ppvObj);
    *ppunk = NULL;
    if (false) { }
#define QI(i) else if (iid == __uuidof(i)) punk = static_cast<i *>(this);
    QI(IUnknown)
    QI(ISequentialStream)
    QI(IStream)
#undef QI
    else
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    AddRef();
    *ppunk = punk;
    hr = NOERROR;

Exit:
    return hr;
}

HRESULT __stdcall CMemoryStream::Read(void *pv, ULONG cb32, ULONG* pcbRead)
{
    const BYTE * const pbCurrent = m_pbCurrent; // read this once for near thread safety..
    __int64 cb = cb32;
    __int64 cbBytesRemaining = (m_pbEnd - pbCurrent);

    if (cb > cbBytesRemaining)
        cb = cbBytesRemaining;

    memcpy(pv, pbCurrent, static_cast<SIZE_T>(cb));

    m_pbCurrent = pbCurrent + cb; // write this once for near thread safety..

    *pcbRead = static_cast<ULONG>(cb);

    return NOERROR;
}

HRESULT __stdcall CMemoryStream::Write(void const *pv, ULONG cb, ULONG* pcbWritten)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::SetSize(ULARGE_INTEGER libNewSize)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::Commit(DWORD grfCommitFlags)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::Revert()
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
#if 1
    NOTIMPL;
#else
    we can return size, we can return access==read only
#endif
}

HRESULT __stdcall CMemoryStream::Clone(IStream **ppIStream)
{
#if 1
    NOTIMPL;
#else
    CMemoryStream *p;

    if ((p = NEW(CMemoryStream)) == NULL)
    {
        *ppIStream = NULL;
        return E_NOMEMORY;
    }
    p->m_pbCurrent = m_pbCurrent;
    p->m_pbBegin = m_pbBegin;
    p->m_pbEnd = m_pbEnd;
    p->m_cRef = 1;
    *ppIStream = p;
    return S_OK;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cassemblyrecoveryinfo.cpp ===
#include "stdinc.h"
#include "fusionheap.h"
#include "fusionbuffer.h"
#include "fusionparser.h"
#include "parsing.h"
#include "strongname.h"
#include "CAssemblyRecoveryInfo.h"
#include "hashfile.h"
#include "FusionHandle.h"
#include "Util.h"
#include "Sxsp.h"
#include "recover.h"


SMARTTYPE(CAssemblyRecoveryInfo);

static
BOOL
pMapShortNameToAssembly(
    IN OUT CBaseStringBuffer &rbuffAssemblyName,
    IN const CRegKey &hkInstallInfoKey,
    OUT CRegKey &hRequestedAsm,
    IN REGSAM rsReadRights = KEY_READ
    )
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffManifestName;
    CSmallStringBuffer buffCatalogName;

    DWORD dwIndex = 0;
    PCWSTR pszValueName = NULL;

    hRequestedAsm = CRegKey::GetInvalidValue();

    IFW32FALSE_EXIT(buffManifestName.Win32Assign(rbuffAssemblyName));
    IFW32FALSE_EXIT(buffManifestName.Win32Append(L".man", 4));

    IFW32FALSE_EXIT(buffCatalogName.Win32Assign(rbuffAssemblyName));
    IFW32FALSE_EXIT(buffCatalogName.Win32Append(L".cat", 4));

    //
    // Look for this under the CSMD_TOPLEVEL_SHORTNAME first
    //
    for (;;)
    {
        CStringBuffer buffKeyName;
        CSmallStringBuffer buffAcquiredShortName;
        BOOL fTempBoolean;
        CRegKey hAsm;

        IFW32FALSE_EXIT(hkInstallInfoKey.EnumKey(
            dwIndex++,
            buffKeyName,
            NULL,
            &fTempBoolean));

        if (fTempBoolean)
            break;

        IFW32FALSE_EXIT(hkInstallInfoKey.OpenSubKey(hAsm, buffKeyName, rsReadRights));

        //
        // Get the value of the key
        //
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hAsm,
                CSMD_TOPLEVEL_SHORTNAME,
                buffAcquiredShortName));

        //
        // If the key was there to be read:
        //
        if (buffAcquiredShortName.Cch() != 0)
        {
            if (::FusionpCompareStrings(
                    buffAcquiredShortName,
                    buffAcquiredShortName.Cch(),
                    rbuffAssemblyName,
                    rbuffAssemblyName.Cch(),
                    true) == 0)
            {
                IFW32FALSE_EXIT(rbuffAssemblyName.Win32Assign(buffKeyName));
                IFW32FALSE_EXIT(hkInstallInfoKey.OpenSubKey( hRequestedAsm, buffKeyName, rsReadRights ) );
                break;
            }
        }

        //
        // Get the value of the key
        //
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hAsm,
                CSMD_TOPLEVEL_SHORTMANIFEST,
                buffAcquiredShortName));

        //
        // If the key was there to be read:
        //
        if (buffAcquiredShortName.Cch() != 0)
        {
            if (::FusionpCompareStrings(
                    buffAcquiredShortName,
                    buffAcquiredShortName.Cch(),
                    buffManifestName,
                    buffManifestName.Cch(),
                    true) == 0)
            {
                IFW32FALSE_EXIT(rbuffAssemblyName.Win32Assign(buffKeyName));
                IFW32FALSE_EXIT(hkInstallInfoKey.OpenSubKey(hRequestedAsm, buffKeyName, rsReadRights));
                break;
            }
        }

        //
        // Get the value of the key
        //
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hAsm,
                CSMD_TOPLEVEL_SHORTCATALOG,
                buffAcquiredShortName));

        //
        // If the key was there to be read:
        //
        if (buffAcquiredShortName.Cch() != 0)
        {
            if (::FusionpCompareStrings(
                    buffAcquiredShortName,
                    buffAcquiredShortName.Cch(),
                    buffCatalogName,
                    buffCatalogName.Cch(),
                    true) == 0)
            {
                IFW32FALSE_EXIT(rbuffAssemblyName.Win32Assign(buffKeyName));
                IFW32FALSE_EXIT(hkInstallInfoKey.OpenSubKey(hRequestedAsm, buffKeyName, rsReadRights));
                break;
            }
        }
    }

    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::ResolveCDRomURL(
    PCWSTR pszSource,
    CBaseStringBuffer &rsbDestination
) const
{
    BOOL                fSuccess = TRUE, fFoundMedia = FALSE;
    CStringBuffer       sbIdentKind, sbIdentData1, sbIdentData2;
    CSmallStringBuffer  buffDriveStrings;
    CStringBufferAccessor acc;
    SIZE_T              HeadLength;
    PCWSTR              wcsCursor;
    ULONG               ulSerialNumber = 0;
    WCHAR               rgchVolumeName[MAX_PATH];
    CDRomSearchType     SearchType;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(pszSource != NULL);

    if (!_wcsnicmp(pszSource, URLHEAD_CDROM_TYPE_TAG, URLHEAD_LENGTH_CDROM_TYPE_TAG))
    {
        HeadLength = URLHEAD_LENGTH_CDROM_TYPE_TAG;
        SearchType = CDRST_Tagfile;
    }
    else if (!_wcsnicmp(
                    pszSource,
                    URLHEAD_CDROM_TYPE_SERIALNUMBER,
                    URLHEAD_LENGTH_CDROM_TYPE_SERIALNUMBER))
    {
        HeadLength = URLHEAD_LENGTH_CDROM_TYPE_SERIALNUMBER;
        SearchType = CDRST_SerialNumber;
    }
    else if (!_wcsnicmp(
                    pszSource,
                    URLHEAD_CDROM_TYPE_VOLUMENAME,
                    URLHEAD_LENGTH_CDROM_TYPE_VOLUMENAME))
    {
        HeadLength = URLHEAD_LENGTH_CDROM_TYPE_VOLUMENAME;
        SearchType = CDRST_VolumeName;
    }
    else
    {
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    // Get the type of identifier here, and then move the cursor past them and
    // the slashes in the url.
    //
    IFW32FALSE_EXIT(sbIdentKind.Win32Assign(pszSource, HeadLength));
    pszSource += HeadLength;
    pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());

    //
    // Spin past slashes, assign chunklets
    //
    IFW32FALSE_EXIT(sbIdentData1.Win32Assign(pszSource, wcscspn(pszSource, CUnicodeCharTraits::PathSeparators())));
    pszSource += sbIdentData1.Cch();
    pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());

    //
    // If this is a tagfile, also get another blobbet of data off the string
    //
    if (SearchType == CDRST_Tagfile)
    {
        IFW32FALSE_EXIT(sbIdentData2.Win32Assign(pszSource, wcscspn(pszSource, CUnicodeCharTraits::PathSeparators())));
        pszSource += sbIdentData2.Cch();
        pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());
    }
    else if (SearchType == CDRST_SerialNumber)
    {
        IFW32FALSE_EXIT(CFusionParser::ParseULONG(
            ulSerialNumber,
            sbIdentData1,
            sbIdentData1.Cch(),
            16));
    }

    //
    // Now let's do ... interesting ... things to the CD-roms.
    //
    IFW32FALSE_EXIT(buffDriveStrings.Win32ResizeBuffer(GetLogicalDriveStringsW(0, NULL) + 1, eDoNotPreserveBufferContents));
    acc.Attach(&buffDriveStrings);
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::GetLogicalDriveStringsW(
            static_cast<DWORD>(acc.GetBufferCch()),
            acc));
    acc.Detach();

    wcsCursor = buffDriveStrings;

    //
    // Look at all the found drive letters
    //
    while (wcsCursor && *wcsCursor && !fFoundMedia)
    {
        DWORD dwSerialNumber;
        const DWORD dwDriveType = ::GetDriveTypeW(wcsCursor);

        if (dwDriveType == DRIVE_CDROM)
        {
            //
            // I argue that a failure in GetVolumeInformationW isn't "bad enough"
            // to kill the call to this function.  Instead, it should just skip
            // the check of the failed drive letter, as it does here.
            //
            if(!::GetVolumeInformationW(
                wcsCursor,
                rgchVolumeName,
                NUMBER_OF(rgchVolumeName),
                &dwSerialNumber,
                NULL,
                NULL,
                NULL,
                0))
            {
#if DBG
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS.DLL: %s() - Failed getting volume information for drive letter %ls (Win32 Error = %ld), skipping\n",
                    __FUNCTION__,
                    wcsCursor,
                    ::FusionpGetLastWin32Error());
#endif
                continue;
            }


            switch (SearchType)
            {
            case CDRST_Tagfile:
                {
                    CFusionFile     FileHandle;
                    CHAR            chBuffer[MAX_PATH];
                    CStringBuffer   sbContents;
                    DWORD           dwTextLength;

                    if (FileHandle.Win32CreateFile(sbIdentData1, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING))
                    {
                        IFW32FALSE_ORIGINATE_AND_EXIT(
                            ::ReadFile(
                                FileHandle,
                                chBuffer, NUMBER_OF(chBuffer),
                                &dwTextLength, NULL));

                        IFW32FALSE_EXIT(sbContents.Win32Assign(chBuffer, dwTextLength));
                        fFoundMedia = !_wcsnicmp(sbContents, sbIdentData2, sbIdentData2.Cch());
                    }
                }
                break;
            case CDRST_SerialNumber:
                fFoundMedia = (dwSerialNumber == ulSerialNumber);
                break;

            case CDRST_VolumeName:
                fFoundMedia = (::FusionpStrCmpI(rgchVolumeName, sbIdentData1) == 0);
                break;
            default:
                break;
            }

        }

        if (!fFoundMedia)
            wcsCursor += ::wcslen(wcsCursor) + 1;
    }

    if (fFoundMedia)
    {
        IFW32FALSE_EXIT(rsbDestination.Win32Assign(wcsCursor, ::wcslen(wcsCursor)));
        IFW32FALSE_EXIT(rsbDestination.Win32AppendPathElement(pszSource, ::wcslen(pszSource)));
    }

    fSuccess = TRUE;
Exit:

    //
    // Failure indicated by an empty destination.
    //
    if (!fSuccess)
    {
        rsbDestination.Clear();
    }

    return fSuccess;
}






BOOL
CAssemblyRecoveryInfo::ResolveWinSourceMediaURL(
    PCWSTR  wcsUrlTrailer,
    CBaseStringBuffer &rsbDestination
) const
{
    CStringBuffer   buffWindowsInstallSource;

    const static PCWSTR AssemblySourceStrings[] = {
        WINSXS_INSTALL_SVCPACK_REGKEY,
        WINSXS_INSTALL_SOURCEPATH_REGKEY
    };

    SIZE_T          iWhichSource = 0;
    BOOL            fSuccess = TRUE, fFoundCodebase = FALSE;
    CFusionRegKey   hkSetupInfo;
    DWORD           dwWasFromCDRom = 0;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(wcsUrlTrailer != NULL);

    IFREGFAILED_ORIGINATE_AND_EXIT(
        ::RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            WINSXS_INSTALL_SOURCE_BASEDIR,
            0,
            KEY_READ | FUSIONP_KEY_WOW64_64KEY,
            &hkSetupInfo));

    if (!::FusionpRegQueryDwordValueEx(
            0,
            hkSetupInfo,
            WINSXS_INSTALL_SOURCE_IS_CDROM,
            &dwWasFromCDRom))
    {
        dwWasFromCDRom = 0;
    }

    while (iWhichSource < NUMBER_OF(AssemblySourceStrings))
    {
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hkSetupInfo,
                AssemblySourceStrings[iWhichSource],
                buffWindowsInstallSource));

        //
        // This really _really_ should not be empty.  If it is, then someone
        // went and fiddled with the registry on us.
        //
        ASSERT(buffWindowsInstallSource.Cch() != 0);
        if (buffWindowsInstallSource.Cch() == 0)
        {
            iWhichSource++;
            continue;
        }

        //
        // If this was from a CD, then spin through the list of CD's in the system
        // and see if we can match the codebase against the root dir of the CD
        //
        if (dwWasFromCDRom)
        {
            CSmallStringBuffer          buffDriveStrings;
            CStringBufferAccessor  acc;
            PCWSTR                      pszCursor;
            DWORD                       dwSize;

            IFW32FALSE_EXIT(
                buffDriveStrings.Win32ResizeBuffer(
                    dwSize = (::GetLogicalDriveStringsW(0, NULL) + 1),
                    eDoNotPreserveBufferContents));

            acc.Attach(&buffDriveStrings);
            ::GetLogicalDriveStringsW(
                static_cast<DWORD>(acc.GetBufferCch()),
                acc);
            acc.Detach();
            pszCursor = buffDriveStrings;
            while (*pszCursor)
            {
                if (::GetDriveTypeW(pszCursor) == DRIVE_CDROM)
                {
                    DWORD dwAttributes;
                    DWORD dwWin32Error;

                    IFW32FALSE_EXIT(rsbDestination.Win32Assign(pszCursor, ::wcslen(pszCursor)));
                    IFW32FALSE_EXIT(rsbDestination.Win32AppendPathElement(wcsUrlTrailer, ::wcslen(wcsUrlTrailer)));

                    IFW32FALSE_EXIT(
                        ::SxspGetFileAttributesW(
                            rsbDestination,
                            dwAttributes,
                            dwWin32Error,
                            3,
                            ERROR_FILE_NOT_FOUND,
                            ERROR_PATH_NOT_FOUND,
                            ERROR_NOT_READY,
                            ERROR_ACCESS_DENIED));

                    if (dwWin32Error == ERROR_SUCCESS)
                    {
                        fFoundCodebase = TRUE;
                        FN_SUCCESSFUL_EXIT();
                    }
                }

                pszCursor += ::wcslen(pszCursor) + 1;
            }
        }
        //
        // This wasn't a CD-rom installation, so prepend the install source path to
        // the string that was passed in.
        //
        else
        {
            IFW32FALSE_EXIT(rsbDestination.Win32Assign(buffWindowsInstallSource, buffWindowsInstallSource.Cch()));
            IFW32FALSE_EXIT(rsbDestination.Win32AppendPathElement(wcsUrlTrailer, ::wcslen(wcsUrlTrailer)));

            if (::GetFileAttributesW(rsbDestination) != -1)
            {
                fFoundCodebase = TRUE;
                fSuccess = TRUE;
                goto Exit;
            }
        }

        iWhichSource++;
    }

    fSuccess = TRUE;
Exit:
    if (!fFoundCodebase)
    {
        rsbDestination.Clear();
    }
    return fSuccess;
}

BOOL
CAssemblyRecoveryInfo::AssociateWithAssembly(
    IN OUT CBaseStringBuffer &rsbSourceAssemblyName,
    bool &rfNoAssembly
    )
{
    //
    // First check the manifest that the assembly came out of.  If it still exists,
    // then nifty, go and load the info from it.  Otherwise, we should look in the
    // registry for information instead.
    //
    FN_PROLOG_WIN32

    CFusionRegKey   hInstallInfoKey;
    CFusionRegKey   hRequestedAsm;

    rfNoAssembly = true;

    //
    // First attempt - try to load it directly off the root installation key.
    //
    if (!m_fLoadedAndReady)
    {
        IFW32FALSE_EXIT(this->Initialize());
        IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0, KEY_READ, hInstallInfoKey));
        IFW32FALSE_EXIT(
            hInstallInfoKey.OpenSubKey(
                hRequestedAsm,
                rsbSourceAssemblyName,
                KEY_READ));

        //
        // This direct entry wasn't found, so let's go see if we can map it back to some
        // other assembly name using the shortname stuff.
        //
        if (hRequestedAsm == CRegKey::GetInvalidValue())
        {
            IFW32FALSE_EXIT(
                ::pMapShortNameToAssembly(
                    rsbSourceAssemblyName,      // if this is a short name of an assembly, this function would set this to be real assembly name if match is found
                    hInstallInfoKey,
                    hRequestedAsm));

            //
            // Still not found? Darn.
            //
            if (hRequestedAsm == CRegKey::GetInvalidValue())
                FN_SUCCESSFUL_EXIT();
        }

        IFW32FALSE_EXIT(this->m_sbAssemblyDirectoryName.Win32Assign(rsbSourceAssemblyName));
        IFW32FALSE_EXIT(this->m_SecurityMetaData.LoadFromRegistryKey(hRequestedAsm));

        this->m_fLoadedAndReady = TRUE;
    }

    //
    // Only set the "no assembly" if we were able to associate (before or
    // above.)
    //
    if ( this->m_fLoadedAndReady )
        rfNoAssembly = false;

    FN_EPILOG
}

BOOL
SxspDetermineCodebaseType(
    IN const CBaseStringBuffer &rcbuffUrlString,
    OUT SxsWFPResolveCodebase &rcbaseType,
    OUT CBaseStringBuffer *pbuffRemainder
    )
{
    FN_PROLOG_WIN32

    PCWSTR pcwszStringTop = rcbuffUrlString;
    SIZE_T cch = rcbuffUrlString.Cch();
    SIZE_T i;
    CSmallStringBuffer buffTemp; // may be used if we mangle the URL text more

    rcbaseType = CODEBASE_RESOLVED_URLHEAD_UNKNOWN;

    if (pbuffRemainder != NULL)
        pbuffRemainder->Clear();

#define ENTRY(_x) { URLHEAD_ ## _x, NUMBER_OF(URLHEAD_ ## _x) - 1, NUMBER_OF(URLHEAD_ ## _x) - 1, CODEBASE_RESOLVED_URLHEAD_ ## _x },

    static const struct
    {
        PCWSTR pszPrefix;
        SIZE_T cchPrefix;
        SIZE_T cchAdvance;
        SxsWFPResolveCodebase cbaseType;
    } s_rgMap[] =
    {
        ENTRY(FILE)
        ENTRY(WINSOURCE)
        ENTRY(CDROM)
        ENTRY(HTTP)
    };

#undef ENTRY

    for (i=0; i<NUMBER_OF(s_rgMap); i++)
    {
        if (_wcsnicmp(pcwszStringTop, s_rgMap[i].pszPrefix, s_rgMap[i].cchPrefix) == 0)
        {
            pcwszStringTop += s_rgMap[i].cchAdvance;
            cch -= s_rgMap[i].cchAdvance;
            rcbaseType = s_rgMap[i].cbaseType;
            break;
        }
    }

    // If there wasn't an entry, we'll assume it's a simple file path.
    if (i == NUMBER_OF(s_rgMap))
    {
        rcbaseType = CODEBASE_RESOLVED_URLHEAD_FILE;
    }
    else
    {
        // If it was a real file: codebase, there's ambiguity about whether there is supposed
        // to be 0, 1, 2 or 3 slashes, so we'll just absorb up to 3 slashes to get to what hopefully
        // is then a local path.  e.g.
        //
        //      file:c:\foo\bar.manifest
        //      file://c:\foo\bar.manifest
        //      file:///c:\foo\bar.manifest
        //
        // all turn into c:\foo\bar.manifest.  The URL standard seems clear that non-absolute
        // URLs are interpreted in the context of their containing document.  In the case
        // of a free-standing codebase, that would seem to mean that the hostname field is
        // required, where the general form is (by my reading):
        //
        //      file:[//[hostname]]/path
        //
        // it kind of makes sense to imagine that file:/c:\foo.manifest is reasonable; the only
        // useful context to get the hostname from is the local machine.  file:///c:\foo.manifest
        // meets the standards for URLs not contained in a web document.  file:c:\foo.manifest
        // also makes sense if you believe the point of the slash is separate the hostname specification
        // from the host-specific part of the URL, since if you're happy omitting the hostname
        // part, there's nothing to separate.  (Note that really file:c:\foo.manifest should
        // be considered relative to the current document since it doesn't have the slash at the
        // front of the name, but even less than we have a current hostname, we certainly
        // don't have a point in the filesystem hierarchy that it makes sense to consider "current".)
        //
        // file://c:\foo\bar.manifest seems to have become popular even though it doesn't
        // have any useful definition in any way shape or form.  The two slashes should indicate
        // that the next thing should be hostname; instead we see c:\
        //
        // That's all just a long-winded justifcation for absorbing up to 3 slashes at the
        // beginning of the remainder of the string.  If there are four or more, we'll let it fail
        // as a bad path later on.
        //
        //  mgrier 6/27/2001

        if (rcbaseType == CODEBASE_RESOLVED_URLHEAD_FILE)
        {
            if ((cch > 0) && (pcwszStringTop[0] == L'/'))
            {
                cch--;
                pcwszStringTop++;
            }
            if ((cch > 0) && (pcwszStringTop[0] == L'/'))
            {
                cch--;
                pcwszStringTop++;
            }
            if ((cch > 0) && (pcwszStringTop[0] == L'/'))
            {
                cch--;
                pcwszStringTop++;
            }
        }
        else if (rcbaseType == CODEBASE_RESOLVED_URLHEAD_HTTP)
        {
            // Hey, on Whistler, we have the WebDAV redirector, so
            // we can turn this URL into a UNC path!
            bool fGeneratedUNCPath = false;

            IFW32FALSE_EXIT(buffTemp.Win32Assign(L"\\\\", 2));

            if (pcwszStringTop[0] == L'/')
            {
                if (pcwszStringTop[1] == L'/')
                {
                    // http:// so far; the next thing must be a hostname!
                    PCWSTR pszSlash = wcschr(pcwszStringTop + 2, L'/');

                    if (pszSlash != NULL)
                    {
                        // //foo/bar  (http: removed earlier...)
                        // pcwszStringTop == [0]
                        // pszSlash == [5]
                        // cch == 9

                        IFW32FALSE_EXIT(buffTemp.Win32Append(pcwszStringTop + 2, (pszSlash - pcwszStringTop) - 3));
                        IFW32FALSE_EXIT(buffTemp.Win32Append(L"\\", 1));
                        IFW32FALSE_EXIT(buffTemp.Win32Append(pszSlash + 1, cch - (pszSlash - pcwszStringTop) - 1));

                        fGeneratedUNCPath = true;
                    }
                }
            }

            if (fGeneratedUNCPath)
            {
                // poof, it's a file path
                pcwszStringTop = buffTemp;
                cch = buffTemp.Cch();
                rcbaseType = CODEBASE_RESOLVED_URLHEAD_FILE;
            }
        }
    }

    if (pbuffRemainder != NULL)
    {
        IFW32FALSE_EXIT(
            pbuffRemainder->Win32Assign(pcwszStringTop, cch));
    }
#if DBG
    {
        CUnicodeString a(rcbuffUrlString, rcbuffUrlString.Cch());
        CUnicodeString b(rcbuffUrlString, (cch <= rcbuffUrlString.Cch()) ? (rcbuffUrlString.Cch() - cch) : 0);
        CUnicodeString c(pcwszStringTop, (cch <= ::wcslen(pcwszStringTop)) ? cch : 0);

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS: %s - split \"%wZ\" into \"%wZ\" and \"%wZ\"\n",
            __FUNCTION__, &a, &b, &c);
    }
#endif

    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::CopyValue(const CAssemblyRecoveryInfo& other)
{
    BOOL bSuccess = FALSE;

    FN_TRACE_WIN32(bSuccess);

    if (&other != this)
    {
        IFW32FALSE_EXIT(m_sbAssemblyDirectoryName.Win32Assign(other.m_sbAssemblyDirectoryName));
        IFW32FALSE_EXIT(m_SecurityMetaData.Initialize(other.m_SecurityMetaData));
        m_fLoadedAndReady = other.m_fLoadedAndReady;
    }

    bSuccess = TRUE;
Exit:
    if ( !bSuccess )
    {
        this->m_fLoadedAndReady = FALSE;
    }

    return bSuccess;
}


BOOL
CAssemblyRecoveryInfo::SetAssemblyIdentity(
    IN PCASSEMBLY_IDENTITY pcidAssembly
    )
{
    FN_PROLOG_WIN32

    SIZE_T cbEncodedTextSize;
    SIZE_T cbActualSize;
    CStringBuffer sbTextualEncoding;

    IFW32FALSE_EXIT( ::SxsComputeAssemblyIdentityEncodedSize(
        0,
        pcidAssembly,
        NULL,
        SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
        &cbEncodedTextSize ) );
    INTERNAL_ERROR_CHECK( ( cbEncodedTextSize % sizeof(WCHAR) ) == 0 );
    IFW32FALSE_EXIT( sbTextualEncoding.Win32ResizeBuffer(
        ( cbEncodedTextSize / sizeof(WCHAR) ) + 1,
        eDoNotPreserveBufferContents ) );

    {
        CStringBufferAccessor sba;
        sba.Attach( &sbTextualEncoding );

        IFW32FALSE_EXIT( ::SxsEncodeAssemblyIdentity(
            0,
            pcidAssembly,
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            sba.GetBufferCb(),
            sba.GetBufferPtr(),
            &cbActualSize ) );

        INTERNAL_ERROR_CHECK( cbActualSize == cbEncodedTextSize );
        sba.GetBufferPtr()[cbActualSize / sizeof(WCHAR)] = L'\0';
    }

    IFW32FALSE_EXIT( this->SetAssemblyIdentity( sbTextualEncoding ) );


    FN_EPILOG
}


BOOL
CAssemblyRecoveryInfo::PrepareForWriting()
{
    FN_PROLOG_WIN32

    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> pIdentity;
    CSmallStringBuffer buffAsmRoot;
    CStringBuffer buffTemp1;
    CStringBuffer buffTemp2;
    const CBaseStringBuffer& OurTextualIdentity = m_SecurityMetaData.GetTextualIdentity();
    BOOL fIsPolicy;
    DWORD dwWin32Error;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS.DLL: %s - handling assembly \"%ls\"\n",
        __FUNCTION__,
        static_cast<PCWSTR>(OurTextualIdentity));

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffAsmRoot));
    IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(OurTextualIdentity, &pIdentity));
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(pIdentity, fIsPolicy));

    //
    // It's likely that this short name hasn't been generated yet, mostly because the files
    // may not have been copied around just yet.
    //
    if (this->m_SecurityMetaData.GetInstalledDirShortName().Cch() == 0)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY | ( fIsPolicy ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : 0 ),
                buffAsmRoot,
                buffAsmRoot.Cch(),
                pIdentity,
                buffTemp2));

        IFW32FALSE_EXIT(
            ::SxspGetShortPathName(
                buffTemp2,
                buffTemp1,
                dwWin32Error,
                4,
                ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND, ERROR_BAD_NET_NAME, ERROR_BAD_NETPATH));

        if (dwWin32Error == ERROR_SUCCESS)
        {
            buffTemp1.RemoveTrailingPathSeparators();
            IFW32FALSE_EXIT(buffTemp1.Win32GetLastPathElement(buffTemp2));
            IFW32FALSE_EXIT(m_SecurityMetaData.SetInstalledDirShortName(buffTemp2));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - decided that the short dir name is \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffTemp2));
        }
        else
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - unable to determine short name for \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffTemp2));
        }
    }

    //
    // Get the public key token string
    //
    {
        PCWSTR wchString;
        SIZE_T cchString;
        CFusionByteArray baStrongNameBits;

        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pIdentity,
            &s_IdentityAttribute_publicKeyToken,
            &wchString,
            &cchString));

        if (cchString != 0)
        {
            IFW32FALSE_EXIT(::SxspHashStringToBytes(wchString, cchString, baStrongNameBits));
            IFW32FALSE_EXIT(m_SecurityMetaData.SetSignerPublicKeyTokenBits(baStrongNameBits));
        }
    }

    //
    // And now the short name of the manifest and catalog
    //
    {
        CStringBuffer buffManifestPath;

        IFW32FALSE_EXIT(
            ::SxspCreateManifestFileNameFromTextualString(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST | ( fIsPolicy ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : 0 ),
                buffAsmRoot,
                OurTextualIdentity,
                buffManifestPath));

        // Get the manifest short path first
        IFW32FALSE_EXIT(::SxspGetShortPathName(buffManifestPath, buffTemp1));
        IFW32FALSE_EXIT(buffTemp1.Win32GetLastPathElement(buffTemp2));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS: %s - manifest short path name determined to be \"%ls\"\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffTemp2));

        IFW32FALSE_EXIT(m_SecurityMetaData.SetShortManifestPath(buffTemp2));

        // Then swap extensions, get the catalog short path
        IFW32FALSE_EXIT(
            buffManifestPath.Win32ChangePathExtension(
                FILE_EXTENSION_CATALOG,
                FILE_EXTENSION_CATALOG_CCH,
                eAddIfNoExtension));

        IFW32FALSE_EXIT(::SxspGetShortPathName(buffManifestPath, buffTemp1));
        IFW32FALSE_EXIT(buffTemp1.Win32GetLastPathElement(buffTemp2));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS: %s - catalog short path name determined to be \"%ls\"\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffTemp2));

        IFW32FALSE_EXIT(m_SecurityMetaData.SetShortCatalogPath(buffTemp2));
    }

    FN_EPILOG

}

BOOL
CAssemblyRecoveryInfo::WriteSecondaryAssemblyInfoIntoRegistryKey(
    CRegKey & rhkRegistryNode
    ) const
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(m_SecurityMetaData.WriteSecondaryAssemblyInfoIntoRegistryKey(rhkRegistryNode));

    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::WritePrimaryAssemblyInfoToRegistryKey(
    ULONG Flags,
    CRegKey & rhkRegistryNode
    ) const
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK((Flags & ~(SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_TO_REGISTRY_KEY_FLAG_REFRESH)) == 0);
    ULONG Flags2 = 0;

    if (Flags & SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_TO_REGISTRY_KEY_FLAG_REFRESH)
    {
        Flags2 |= SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_INTO_REGISTRY_KEY_FLAG_REFRESH;
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - propping recovery flag to WritePrimaryAssemblyInfoIntoRegistryKey\n",
            __FUNCTION__);
#endif
    }

    IFW32FALSE_EXIT(m_SecurityMetaData.WritePrimaryAssemblyInfoIntoRegistryKey(Flags2, rhkRegistryNode));

    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::OpenInstallationSubKey(
    CFusionRegKey& hkSingleAssemblyInfo,
    DWORD OpenOrCreate,
    DWORD Access)
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffRegKeyName;
    CFusionRegKey   hkAllInstallationInfo;
    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> pAssemblyIdentity;

    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(
        0, 
        OpenOrCreate, 
        hkAllInstallationInfo));

    IFW32FALSE_EXIT( SxspCreateAssemblyIdentityFromTextualString(
        this->m_SecurityMetaData.GetTextualIdentity(),
        &pAssemblyIdentity ) );

    IFW32FALSE_EXIT( ::SxspGenerateSxsPath(
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
        SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
        NULL, 0,
        pAssemblyIdentity,
        buffRegKeyName ) );

    IFW32FALSE_EXIT( hkAllInstallationInfo.OpenSubKey(
        hkSingleAssemblyInfo,
        buffRegKeyName,
        Access,
        0));

    FN_EPILOG
}

VOID
CAssemblyRecoveryInfo::RestorePreviouslyExistingRegistryData()
{
    FN_PROLOG_VOID
    if (m_fHadCatalog)
    {
        CFusionRegKey hkSingleAssemblyInfo;

#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s() - restoring registry data for %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(this->m_SecurityMetaData.GetTextualIdentity()));
#endif

        IFW32FALSE_EXIT(
            this->OpenInstallationSubKey(
                hkSingleAssemblyInfo,
                KEY_CREATE_SUB_KEY, KEY_WRITE | KEY_READ | FUSIONP_KEY_WOW64_64KEY));

        IFW32FALSE_EXIT(
            hkSingleAssemblyInfo.SetValue(
                CSMD_TOPLEVEL_CATALOG,
                static_cast<DWORD>(1)));
    }
    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::ClearExistingRegistryData()
{
    //
    // Do not be so eager to delete registry metadata, so that
    // an assembly for which refresh failed might succeed if another
    // file change comes in, or sfc /scannow.
    //
    // As well, if a replace-existing install fails, don't destroy
    // the metadata for previously successfully installed instances
    // of the same assembly.
    //
    const static struct
    {
        PCWSTR Data;
        SIZE_T Length;
    }
    DeletableValues[] =
    {
#define ENTRY(x) { x, NUMBER_OF(x) - 1 }
        ENTRY(CSMD_TOPLEVEL_CATALOG),
#if 0
        ENTRY(CSMD_TOPLEVEL_SHORTNAME),
        ENTRY(CSMD_TOPLEVEL_SHORTCATALOG),
        ENTRY(CSMD_TOPLEVEL_SHORTMANIFEST),
        ENTRY(CSMD_TOPLEVEL_MANIFESTHASH),
        ENTRY(CSMD_TOPLEVEL_PUBLIC_KEY_TOKEN),
        ENTRY(CSMD_TOPLEVEL_IDENTITY),
        ENTRY(CSMD_TOPLEVEL_CODEBASE) // legacy, delete (actually not legacy anymore)
#endif
    };
#undef ENTRY

    static const PCWSTR DeletableKeys[] =
    {
        NULL,
#if 0
        CSMD_TOPLEVEL_FILES,            
#endif
    };

    FN_PROLOG_WIN32


    CFusionRegKey   hkSingleAssemblyInfo;
    IFW32FALSE_EXIT(this->OpenInstallationSubKey(hkSingleAssemblyInfo, KEY_CREATE_SUB_KEY, KEY_WRITE | KEY_READ | FUSIONP_KEY_WOW64_64KEY));

    //
    // We need to delete the installation information for a single assembly - everything
    // this class owns.
    //
    if ( hkSingleAssemblyInfo != CFusionRegKey::GetInvalidValue() )
    {
        ULONG ul = 0;
        //
        // Clear values
        //
        for ( ul = 0; ul < NUMBER_OF(DeletableValues); ul++ )
        {
            DWORD dwWin32Error = NO_ERROR;

            IFW32FALSE_EXIT(
                hkSingleAssemblyInfo.DeleteValue(
                    DeletableValues[ul].Data,
                    dwWin32Error,
                    2,
                    ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND));

            if (dwWin32Error == NO_ERROR
                && !m_fHadCatalog
                && ::FusionpEqualStrings(
                        DeletableValues[ul].Data,
                        DeletableValues[ul].Length,
                        CSMD_TOPLEVEL_CATALOG,
                        NUMBER_OF(CSMD_TOPLEVEL_CATALOG) - 1,
                        FALSE
                        ))
            {
                m_fHadCatalog = true;
            }
        }

        // 
        // Delete eligible keys
        //
        for ( ul = 0; ul < NUMBER_OF(DeletableKeys); ul++ )
        {
            if (DeletableKeys[ul] != NULL && DeletableKeys[ul][0] != L'\0')
            {
                CFusionRegKey hkTempKey;
                IFW32FALSE_EXIT(hkSingleAssemblyInfo.OpenSubKey(hkTempKey, DeletableKeys[ul], KEY_ALL_ACCESS, 0));
                if ( hkTempKey != CFusionRegKey::GetInvalidValue() )
                {
                    IFW32FALSE_EXIT(hkTempKey.DestroyKeyTree());
                    IFW32FALSE_EXIT(hkSingleAssemblyInfo.DeleteKey(DeletableKeys[ul]));
                }
            }
        }
    }

    FN_EPILOG
}



BOOL
SxspLooksLikeAssemblyDirectoryName(
    const CBaseStringBuffer &rsbSupposedAsmDirectoryName,
    BOOL &rfLooksLikeAssemblyName
    )
/*++
    Most of this was copied directly from SxspParseAssemblyReference, which
    is no longer valid, because it can't know how to turn the string back
    into the actual assembly reference just based on the hash value and
    public key of a string.
--*/
{
    BOOL            fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PCWSTR          pszCursor = NULL;
    PCWSTR          wsNextBlock = NULL;
    SIZE_T          cchSegment;
    ASSEMBLY_VERSION Version;
    static const WCHAR UNDERSCORE = L'_';
    bool fSyntaxValid = false;
    bool fAttributeValid = false;

    rfLooksLikeAssemblyName = FALSE;

    pszCursor = rsbSupposedAsmDirectoryName;

    //
    // Processor architecture
    //

    if ((wsNextBlock = ::StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = (wsNextBlock - pszCursor)) == 0)
        FN_SUCCESSFUL_EXIT();

    IFW32FALSE_EXIT(::FusionpParseProcessorArchitecture(pszCursor, cchSegment, NULL, fAttributeValid));
    if (!fAttributeValid)
        FN_SUCCESSFUL_EXIT();

    pszCursor = wsNextBlock + 1;

    //
    // Name
    //
    if ((wsNextBlock = StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = wsNextBlock - pszCursor) == 0)
        FN_SUCCESSFUL_EXIT();

    pszCursor = wsNextBlock + 1;

    //
    // Public key string
    //

    if ((wsNextBlock = StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = wsNextBlock - pszCursor) == 0)
        FN_SUCCESSFUL_EXIT();

    if ((::FusionpCompareStrings(
            pszCursor,
            cchSegment,
            SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE,
            NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1,
            true) == 0) ||
        !::SxspIsFullHexString(pszCursor, cchSegment))
        FN_SUCCESSFUL_EXIT();

    pszCursor = wsNextBlock + 1;

    //
    // Version string
    //
    if ((wsNextBlock = StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = wsNextBlock - pszCursor) == 0)
        FN_SUCCESSFUL_EXIT();

    IFW32FALSE_EXIT(CFusionParser::ParseVersion(Version, pszCursor, cchSegment, fSyntaxValid));
    if (!fSyntaxValid)
        FN_SUCCESSFUL_EXIT();

    pszCursor = wsNextBlock + 1;

    //
    // Language ID
    //
    if ((wsNextBlock = ::StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = wsNextBlock - pszCursor) == 0)
        FN_SUCCESSFUL_EXIT();

    //
    // BUGBUG (jonwis) - It seems that langids are no longer four-character hex
    // string representations of shorts anymore.  All we're checking at the moment
    // is to see that the string isn't blank.  Is this the Right Thing?
    //
    pszCursor = wsNextBlock + 1;

    //
    // Last block should just be the hash
    //
    if (!::SxspIsFullHexString(pszCursor, ::wcslen(pszCursor)))
        FN_SUCCESSFUL_EXIT();

    // We ran the gauntlet; all the segments of the path look good, let's use it.
    rfLooksLikeAssemblyName = TRUE;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\comclass.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    comclass.cpp

Abstract:

    Activation context section contributor for COM servers.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(iid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(progid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(proxyStubClsid32);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(runtimeVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(threadingModel);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(tlbid);

#define ALLOCATE_BUFFER_SPACE(_bytesNeeded, _bufferCursor, _bytesLeft, _bytesWritten, _typeName, _ptr) \
do { \
    if ((_bytesLeft) < (_bytesNeeded)) \
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER); \
    (_bytesLeft) -= (_bytesNeeded); \
    (_bytesWritten) += (_bytesNeeded); \
    (_ptr) = (_typeName)(_bufferCursor); \
    (_bufferCursor) = (PVOID) (((ULONG_PTR) (_bufferCursor)) + (_bytesNeeded)); \
} while (0)

#define ALLOCATE_BUFFER_SPACE_TYPE(_typeName, _bufferCursor, _bytesLeft, _bytesWritten, _ptr) \
    ALLOCATE_BUFFER_SPACE(sizeof(_typeName), _bufferCursor, _bytesLeft, _bytesWritten, _typeName *, _ptr)


typedef struct _COM_GLOBAL_CONTEXT *PCOM_GLOBAL_CONTEXT;
typedef struct _COM_FILE_CONTEXT *PCOM_FILE_CONTEXT;
typedef struct _COM_SERVER_ENTRY *PCOM_SERVER_ENTRY;

typedef struct _COM_GLOBAL_CONTEXT
{
    _COM_GLOBAL_CONTEXT() { }

    // Temporary holding buffer for the filename until the first COM server entry is
    // found, at which time a COM_FILE_CONTEXT is allocated and the filename moved to it.
    CSmallStringBuffer m_FileNameBuffer;
    PCOM_FILE_CONTEXT m_FileContextListHead;
    ULONG m_FileContextListCount;
    CTinyStringBuffer m_FirstShimNameBuffer;
    ULONG m_FirstShimNameOffset;
    ULONG m_FirstShimNameLength;

    // When the first clrClass entry is created, its file context is written here for
    // easy access in the future.  It will exist in the normal list of files as well,
    // however, and will get cleaned up when the file list goes away.
    PCOM_FILE_CONTEXT m_MscoreeFileContext;

private:
    _COM_GLOBAL_CONTEXT(const _COM_GLOBAL_CONTEXT &);
    void operator =(const _COM_GLOBAL_CONTEXT &);
} COM_GLOBAL_CONTEXT;

typedef struct _COM_FILE_CONTEXT
{
public:
    _COM_FILE_CONTEXT() { }

    PCOM_FILE_CONTEXT m_Next;
    CSmallStringBuffer m_FileNameBuffer;
    PCOM_SERVER_ENTRY m_ServerListHead;
    ULONG m_ServerListCount;
    ULONG m_Offset; // populated during section generation
    PCOM_GLOBAL_CONTEXT m_GlobalContext;

private:
    _COM_FILE_CONTEXT(const _COM_FILE_CONTEXT &);
    void operator =(const _COM_FILE_CONTEXT &);
} COM_FILE_CONTEXT;

typedef struct _COM_SERVER_ENTRY
{
public:
    _COM_SERVER_ENTRY() { }

    PCOM_SERVER_ENTRY m_Next;
    PCOM_FILE_CONTEXT m_FileContext;
    GUID m_ReferenceClsid;
    GUID m_ConfiguredClsid;
    GUID m_ImplementedClsid;
    GUID m_TypeLibraryId;
    ULONG m_ThreadingModel;
    CSmallStringBuffer m_ProgIdBuffer;
    CTinyStringBuffer m_TypeNameBuffer;
    CTinyStringBuffer m_ShimNameBuffer;
    CTinyStringBuffer m_RuntimeVersionBuffer;
    ULONG m_ShimType;
    bool m_IsFirstShim;
private:
    _COM_SERVER_ENTRY(const _COM_SERVER_ENTRY &);
    void operator =(const _COM_SERVER_ENTRY &);
} COM_SERVER_ENTRY;

VOID
WINAPI
SxspComClassRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PGUID_SECTION_GENERATION_CONTEXT GSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    PCOM_GLOBAL_CONTEXT ComGlobalContext = NULL;

    if (GSGenContext != NULL)
        ComGlobalContext = (PCOM_GLOBAL_CONTEXT) ::SxsGetGuidSectionGenerationContextCallbackContext(GSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(ComGlobalContext == NULL);
        INTERNAL_ERROR_CHECK(GSGenContext == NULL);

        IFALLOCFAILED_EXIT(ComGlobalContext = new COM_GLOBAL_CONTEXT);

        ComGlobalContext->m_FileContextListHead = NULL;
        ComGlobalContext->m_FileContextListCount = 0;
        ComGlobalContext->m_FirstShimNameOffset = 0;
        ComGlobalContext->m_FirstShimNameLength = 0;
        ComGlobalContext->m_MscoreeFileContext = NULL;

        if (!::SxsInitGuidSectionGenerationContext(
                &GSGenContext,
                ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER,
                &::SxspComClassRedirectionGuidSectionGenerationCallback,
                ComGlobalContext))
        {
            FUSION_DELETE_SINGLETON(ComGlobalContext);
            goto Exit;
        }

        Data->Header.ActCtxGenContext = GSGenContext;
        Data->GenBeginning.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (GSGenContext != NULL)
            ::SxsDestroyGuidSectionGenerationContext(GSGenContext);

        FUSION_DELETE_SINGLETON(ComGlobalContext);
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;

#if 0 // guid section optimiziation not yet implemented
        if ((GSGenContext != NULL) && !::SxsDoneModifyingGuidSectionGenerationContext(GSGenContext))
            goto Exit;
#endif

        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        // Someone shouldn't be asking for the section size if this is a parse-only
        // run.  These two asserts should be equivalent...
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionSize(GSGenContext, &Data->GetSectionSize.SectionSize));
        Data->GetSectionSize.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        Data->ElementParsed.Success = FALSE;

        if ((Data->ElementParsed.ParseContext->XMLElementDepth == 2) &&
            (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file") - 1,
                    false) == 0))
        {
            CStringBuffer FileNameBuffer;
            bool fFound = false;
            SIZE_T cbBytesWritten = 0;

            // capture the name of the file
            IFW32FALSE_EXIT(::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_name,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(FileNameBuffer),
                    &FileNameBuffer,
                    cbBytesWritten,
                    NULL,
                    NULL));

            // If there's no NAME attribute, someone else will puke; we'll handle it
            // gracefully.
            if (fFound || (FileNameBuffer.Cch() == 0))
            {
                INTERNAL_ERROR_CHECK2(
                    ComGlobalContext != NULL,
                    "Window class context NULL while processing file element's name attribute.");

                IFW32FALSE_EXIT(ComGlobalContext->m_FileNameBuffer.Win32Assign(FileNameBuffer));
            }
        }
        else if (
            (Data->ElementParsed.ParseContext->XMLElementDepth == 3) &&
            (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comClass",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comClass") - 1,
                    false) == 0))
        {
            bool fFound = false;
            SIZE_T cb;
            CSmallStringBuffer VersionIndependentComClassIdBuffer;
            PCOM_SERVER_ENTRY Entry = NULL;
            PCOM_FILE_CONTEXT FileContext = NULL;
            CStringBuffer TempBuffer;
            CSmallStringBuffer ProgIdBuffer;
            ULONG ThreadingModel;
            GUID ReferenceClsid, ConfiguredClsid, ImplementedClsid;
            GUID TypeLibraryId;

            TypeLibraryId = GUID_NULL;

            INTERNAL_ERROR_CHECK2(
                ComGlobalContext != NULL,
                "COM global context NULL while processing comClass tag");

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                    &s_AttributeName_clsid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(VersionIndependentComClassIdBuffer),
                    &VersionIndependentComClassIdBuffer,
                    cb,
                    NULL,
                    0));

            INTERNAL_ERROR_CHECK(fFound);

            IFW32FALSE_EXIT(::SxspParseGUID(VersionIndependentComClassIdBuffer,
                                            VersionIndependentComClassIdBuffer.Cch(),
                                            ReferenceClsid));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_threadingModel,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseThreadingModel(TempBuffer, TempBuffer.Cch(), &ThreadingModel));
            else
                ThreadingModel = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE;

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_progid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(ProgIdBuffer),
                    &ProgIdBuffer,
                    cb,
                    NULL,
                    0));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_tlbid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseGUID(TempBuffer, TempBuffer.Cch(), TypeLibraryId));
            else
                TypeLibraryId = GUID_NULL;

            // That was sufficient if we are generating a context.
            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                BOOL fNewAllocate = FALSE;
                IFW32FALSE_EXIT(Data->Header.ClsidMappingContext->Map->MapReferenceClsidToConfiguredClsid(
                            &ReferenceClsid,
                            Data->ElementParsed.AssemblyContext,
                            &ConfiguredClsid,
                            &ImplementedClsid));

                // See if we already have a file context; if we do not, allocate one.
                if (ComGlobalContext->m_FileNameBuffer.Cch() != 0)
                {
                    IFALLOCFAILED_EXIT(FileContext = new COM_FILE_CONTEXT);
                    fNewAllocate = TRUE;

                    IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign(ComGlobalContext->m_FileNameBuffer));

                    FileContext->m_Next = ComGlobalContext->m_FileContextListHead;
                    ComGlobalContext->m_FileContextListHead = FileContext;
                    ComGlobalContext->m_FileContextListCount++;
                    FileContext->m_ServerListHead = NULL;
                    FileContext->m_ServerListCount = 0;
                    FileContext->m_GlobalContext = ComGlobalContext;
                }
                else
                    FileContext = ComGlobalContext->m_FileContextListHead;

                ASSERT(FileContext != NULL);

                IFALLOCFAILED_EXIT(Entry = new COM_SERVER_ENTRY);

                Entry->m_ShimType = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER;
                Entry->m_Next = FileContext->m_ServerListHead;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = TypeLibraryId;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32Assign(ProgIdBuffer));

                if (!::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ReferenceClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID))
                {
                    if (fNewAllocate)
                        FUSION_DELETE_SINGLETON(FileContext);
                    FUSION_DELETE_SINGLETON(Entry);
                    goto Exit;
                }

                FileContext->m_ServerListHead = Entry;
                FileContext->m_ServerListCount++;

                // And we add another, indexed by the configured clsid
                IFALLOCFAILED_EXIT(Entry = new COM_SERVER_ENTRY);

                Entry->m_Next = FileContext->m_ServerListHead;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = TypeLibraryId;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32Assign(ProgIdBuffer));

                if (!::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ConfiguredClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID))
                {
                    //if (fNewAllocate)  // should not deleted here.
                    //    FUSION_DELETE_SINGLETON(FileContext);

                    FUSION_DELETE_SINGLETON(Entry);
                    goto Exit;
                }

                FileContext->m_ServerListHead = Entry;
                FileContext->m_ServerListCount++;
            }
        }
        else if (
            (Data->ElementParsed.ParseContext->XMLElementDepth == 3) &&
            (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comInterfaceProxyStub",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comInterfaceProxyStub") - 1,
                    false) == 0))
        {
            bool fFound = false;
            SIZE_T cb;
            PCOM_SERVER_ENTRY Entry = NULL;
            PCOM_FILE_CONTEXT FileContext = NULL;
            CStringBuffer TempBuffer;
            ULONG ThreadingModel;
            GUID ReferenceClsid, ConfiguredClsid, ImplementedClsid;
            GUID TypeLibraryId, iid;

            TypeLibraryId = GUID_NULL;

            INTERNAL_ERROR_CHECK2(
                ComGlobalContext != NULL,
                "COM global context NULL while processing comInterfaceProxyStub tag");

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                    &s_AttributeName_iid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(iid),
                    &iid,
                    cb,
                    &::SxspValidateGuidAttribute,
                    0));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_proxyStubClsid32,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(ReferenceClsid),
                    &ReferenceClsid,
                    cb,
                    &::SxspValidateGuidAttribute,
                    0));

            if (!fFound)
                ReferenceClsid = iid;

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_threadingModel,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseThreadingModel(TempBuffer, TempBuffer.Cch(), &ThreadingModel));
            else
                ThreadingModel = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE;


            // That was sufficient if we are generating a context.
            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                BOOL fNewAllocate = FALSE;
                IFW32FALSE_EXIT(Data->Header.ClsidMappingContext->Map->MapReferenceClsidToConfiguredClsid(
                            &ReferenceClsid,
                            Data->ElementParsed.AssemblyContext,
                            &ConfiguredClsid,
                            &ImplementedClsid));

                // See if we already have a file context; if we do not, allocate one.
                if (ComGlobalContext->m_FileNameBuffer.Cch() != 0)
                {
                    IFALLOCFAILED_EXIT(FileContext = new COM_FILE_CONTEXT);
                    fNewAllocate = TRUE;

                    IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign(ComGlobalContext->m_FileNameBuffer));
                    FileContext->m_Next = ComGlobalContext->m_FileContextListHead;
                    ComGlobalContext->m_FileContextListHead = FileContext;
                    ComGlobalContext->m_FileContextListCount++;
                    FileContext->m_ServerListHead = NULL;
                    FileContext->m_ServerListCount = 0;
                    FileContext->m_GlobalContext = ComGlobalContext;
                }
                else
                    FileContext = ComGlobalContext->m_FileContextListHead;

                ASSERT(FileContext != NULL);

                IFALLOCFAILED_EXIT(Entry = new COM_SERVER_ENTRY);


                INTERNAL_ERROR_CHECK(FileContext != NULL);

                Entry->m_ShimType = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER;
                Entry->m_Next = FileContext->m_ServerListHead;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = GUID_NULL;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                Entry->m_ProgIdBuffer.Clear();

                if (!::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ReferenceClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID))
                {
                    if (fNewAllocate)
                        FUSION_DELETE_SINGLETON(FileContext);
                    FUSION_DELETE_SINGLETON(Entry);
                    goto Exit;
                }

                FileContext->m_ServerListHead = Entry;
                FileContext->m_ServerListCount++;

                // And we add another, indexed by the configured clsid
                IFALLOCFAILED_EXIT(Entry = new COM_SERVER_ENTRY);

                Entry->m_Next = FileContext->m_ServerListHead;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = GUID_NULL;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                Entry->m_ProgIdBuffer.Clear();

                if (!::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ConfiguredClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID))
                {
                    //if (fNewAllocate)  // should not deleted here.
                    //    FUSION_DELETE_SINGLETON(FileContext);

                    FUSION_DELETE_SINGLETON(Entry);
                    goto Exit;
                }

                FileContext->m_ServerListHead = Entry;
                FileContext->m_ServerListCount++;
            }
        }
        else if (
            (Data->ElementParsed.ParseContext->XMLElementDepth == 2) &&
            (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrClass",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrClass") - 1,
                    false) == 0))
        {
            bool fFound = false;
            SIZE_T cb;
            CSmallStringBuffer VersionIndependentComClassIdBuffer;
            PCOM_SERVER_ENTRY  Entry;
            PCOM_FILE_CONTEXT  FileContext;
            CSmallStringBuffer TempBuffer;
            CSmallStringBuffer ProgIdBuffer;
            CSmallStringBuffer RuntimeVersionBuffer;
            CSmallStringBuffer NameBuffer;
            ULONG ThreadingModel;
            GUID ReferenceClsid, ConfiguredClsid, ImplementedClsid;
            GUID TypeLibraryId;
            bool fIsFirstShim = false;

            TypeLibraryId = GUID_NULL;

            INTERNAL_ERROR_CHECK2(
                ComGlobalContext != NULL,
                "COM global context NULL while processing ndpClass tag");

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                    &s_AttributeName_name,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(NameBuffer),
                    &NameBuffer,
                    cb,
                    NULL,
                    0));

            INTERNAL_ERROR_CHECK(fFound);

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                    &s_AttributeName_clsid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(VersionIndependentComClassIdBuffer),
                    &VersionIndependentComClassIdBuffer,
                    cb,
                    NULL,
                    0));

            INTERNAL_ERROR_CHECK(fFound);

            IFW32FALSE_EXIT(
                ::SxspParseGUID(
                    VersionIndependentComClassIdBuffer,
                    VersionIndependentComClassIdBuffer.Cch(),
                    ReferenceClsid));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_threadingModel,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseThreadingModel(TempBuffer, TempBuffer.Cch(), &ThreadingModel));
            else
                ThreadingModel = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH;

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_progid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(ProgIdBuffer),
                    &ProgIdBuffer,
                    cb,
                    NULL,
                    0));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_tlbid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseGUID(TempBuffer, TempBuffer.Cch(), TypeLibraryId));
            else
                TypeLibraryId = GUID_NULL;

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_runtimeVersion,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(RuntimeVersionBuffer),
                    &RuntimeVersionBuffer,
                    cb,
                    NULL,
                    0));

            // That was sufficient if we are generating a context.
            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                if (ComGlobalContext->m_FirstShimNameBuffer.Cch() == 0)
                {
                    fIsFirstShim = true;
                    IFW32FALSE_EXIT(ComGlobalContext->m_FirstShimNameBuffer.Win32Assign(L"MSCOREE.DLL", 11));
                }
                else
                {
                    IFW32FALSE_EXIT(
                        ComGlobalContext->m_FirstShimNameBuffer.Win32Equals(
                            L"MSCOREE.DLL", 11,
                            fIsFirstShim,
                            true));
                }

                IFW32FALSE_EXIT(
                    Data->Header.ClsidMappingContext->Map->MapReferenceClsidToConfiguredClsid(
                        &ReferenceClsid,
                        Data->ElementParsed.AssemblyContext,
                        &ConfiguredClsid,
                        &ImplementedClsid));



                // If we don't already have a file context for mscoree, then we have to create a new one.
                if (ComGlobalContext->m_MscoreeFileContext == NULL)
                {
                    IFALLOCFAILED_EXIT(FileContext = FUSION_NEW_SINGLETON(COM_FILE_CONTEXT));
                    IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign("mscoree.dll", 11));

                    FileContext->m_Next = ComGlobalContext->m_FileContextListHead;
                    ComGlobalContext->m_FileContextListHead = FileContext;
                    ComGlobalContext->m_FileContextListCount++;
                    ComGlobalContext->m_MscoreeFileContext = FileContext;
                    FileContext->m_ServerListHead = NULL;
                    FileContext->m_ServerListCount = 0;
                    FileContext->m_GlobalContext = ComGlobalContext;
                }
                else
                    FileContext = ComGlobalContext->m_MscoreeFileContext;


#if 0
                // See if we already have a file context; if we do not, allocate one.
                if (ComGlobalContext->m_FileNameBuffer.Cch() != 0)
                {
                    IFALLOCFAILED_EXIT(FileContext = FUSION_NEW_SINGLETON(COM_FILE_CONTEXT));
                    IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign(ComGlobalContext->m_FileNameBuffer));

                    FileContext->m_Next = ComGlobalContext->m_FileContextListHead;
                    ComGlobalContext->m_FileContextListHead = FileContext;
                    ComGlobalContext->m_FileContextListCount++;
                    FileContext->m_ServerListHead = NULL;
                    FileContext->m_ServerListCount = 0;
                    FileContext->m_GlobalContext = ComGlobalContext;
                }
                else
                    FileContext = ComGlobalContext->m_FileContextListHead;
#endif
                INTERNAL_ERROR_CHECK(FileContext != NULL);

                IFALLOCFAILED_EXIT(Entry = FUSION_NEW_SINGLETON(COM_SERVER_ENTRY));

                Entry->m_ShimType = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_CLR_CLASS;
                Entry->m_Next = FileContext->m_ServerListHead;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = TypeLibraryId;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32Assign(ProgIdBuffer));
                IFW32FALSE_EXIT(Entry->m_ShimNameBuffer.Win32Assign(L"MSCOREE.DLL", 11));
                IFW32FALSE_EXIT(Entry->m_RuntimeVersionBuffer.Win32Assign(RuntimeVersionBuffer));
                IFW32FALSE_EXIT(Entry->m_TypeNameBuffer.Win32Assign(NameBuffer));
                Entry->m_IsFirstShim = fIsFirstShim;

                IFW32FALSE_EXIT(
                    ::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ReferenceClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID));

                FileContext->m_ServerListHead = Entry;
                FileContext->m_ServerListCount++;

                // And we add another, indexed by the configured clsid
                IFALLOCFAILED_EXIT(Entry = FUSION_NEW_SINGLETON(COM_SERVER_ENTRY));

                Entry->m_ShimType = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_CLR_CLASS;
                Entry->m_Next = FileContext->m_ServerListHead;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = TypeLibraryId;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32Assign(ProgIdBuffer));
                IFW32FALSE_EXIT(Entry->m_ShimNameBuffer.Win32Assign(L"MSCOREE.DLL", 11));
                IFW32FALSE_EXIT(Entry->m_TypeNameBuffer.Win32Assign(NameBuffer));
                IFW32FALSE_EXIT(Entry->m_RuntimeVersionBuffer.Win32Assign(RuntimeVersionBuffer));
                Entry->m_IsFirstShim = fIsFirstShim;

                IFW32FALSE_EXIT(
                    ::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ConfiguredClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID));

                FileContext->m_ServerListHead = Entry;
                FileContext->m_ServerListCount++;
            }
        }

        // Everything's groovy!
        Data->ElementParsed.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionData(GSGenContext, Data->GetSectionData.SectionSize, Data->GetSectionData.SectionDataStart, NULL));
        Data->GetSectionData.Success = TRUE;
        break;
    }
Exit:
    ;
}

BOOL
SxspComClassRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PCOM_GLOBAL_CONTEXT ComGlobalContext = (PCOM_GLOBAL_CONTEXT) Context;

    INTERNAL_ERROR_CHECK(CallbackData != NULL);

    switch (Reason)
    {
    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
        {
            INTERNAL_ERROR_CHECK(ComGlobalContext != NULL);

            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE) CallbackData;
            PCOM_FILE_CONTEXT FileContext = ComGlobalContext->m_FileContextListHead;

            CBData->DataSize = 0;

            // If we have a mscoree shim, add its size to the user data buffer area.
            if (ComGlobalContext->m_FirstShimNameBuffer.Cch() != 0)
                CBData->DataSize += ((ComGlobalContext->m_FirstShimNameBuffer.Cch() + 1) * sizeof(WCHAR));

            while (FileContext != NULL)
            {
                CBData->DataSize += ((FileContext->m_FileNameBuffer.Cch() + 1) * sizeof(WCHAR));
                FileContext = FileContext->m_Next;
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        {
            INTERNAL_ERROR_CHECK( ComGlobalContext != NULL );

            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA) CallbackData;
            SIZE_T BytesWritten = 0;
            SIZE_T BytesLeft = CBData->BufferSize;
            PWSTR Cursor = (PWSTR) CBData->Buffer;
            PCOM_FILE_CONTEXT FileContext = ComGlobalContext->m_FileContextListHead;

            if (ComGlobalContext->m_FirstShimNameBuffer.Cch() != 0)
            {
                IFW32FALSE_EXIT(
                    ComGlobalContext->m_FirstShimNameBuffer.Win32CopyIntoBuffer(
                        &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        CBData->SectionHeader,
                        &ComGlobalContext->m_FirstShimNameOffset,
                        &ComGlobalContext->m_FirstShimNameLength));
            }

            while (FileContext != NULL)
            {
                IFW32FALSE_EXIT(
                    FileContext->m_FileNameBuffer.Win32CopyIntoBuffer(
                        &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        CBData->SectionHeader,
                        &FileContext->m_Offset,
                        NULL));                     // the length is tracked elsewhere

                FileContext = FileContext->m_Next;
            }

            CBData->BytesWritten = BytesWritten;

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            INTERNAL_ERROR_CHECK( ComGlobalContext != NULL );

            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PCOM_SERVER_ENTRY Entry = (PCOM_SERVER_ENTRY) CBData->DataContext;

            if (Entry != NULL)
            {
                if (Entry->m_FileContext != NULL)
                {
                    Entry->m_FileContext->m_ServerListCount--;

                    if (Entry->m_FileContext->m_ServerListCount == 0)
                        FUSION_DELETE_SINGLETON(Entry->m_FileContext);
                }

                FUSION_DELETE_SINGLETON(Entry);
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PCOM_SERVER_ENTRY Entry = (PCOM_SERVER_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION);

            if (Entry->m_ProgIdBuffer.Cch() != 0)
                CBData->DataSize += ((Entry->m_ProgIdBuffer.Cch() + 1) * sizeof(WCHAR));

            if (Entry->m_ShimNameBuffer.Cch() != 0)
            {
                CBData->DataSize += sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM);

                if (Entry->m_RuntimeVersionBuffer.Cch() != 0)
                    CBData->DataSize += ((Entry->m_RuntimeVersionBuffer.Cch() + 1) * sizeof(WCHAR));

                if (!Entry->m_IsFirstShim)
                    CBData->DataSize += ((Entry->m_ShimNameBuffer.Cch() + 1) * sizeof(WCHAR));

                if (Entry->m_TypeNameBuffer.Cch() != 0)
                    CBData->DataSize += ((Entry->m_TypeNameBuffer.Cch() + 1) * sizeof(WCHAR));
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PCOM_SERVER_ENTRY Entry = (PCOM_SERVER_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Info;
            PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM ShimInfo = NULL;
            PVOID Cursor = CBData->Buffer;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            ALLOCATE_BUFFER_SPACE_TYPE(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION, Cursor, BytesLeft, BytesWritten, Info);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION);
            Info->Flags = 0;
            Info->ThreadingModel = Entry->m_ThreadingModel;
            Info->ReferenceClsid = Entry->m_ReferenceClsid;
            Info->ConfiguredClsid = Entry->m_ConfiguredClsid;
            Info->ImplementedClsid = Entry->m_ImplementedClsid;
            Info->TypeLibraryId = Entry->m_TypeLibraryId;

            if (Entry->m_ShimNameBuffer.Cch() != 0)
            {
                PWSTR ShimName = NULL;
                SIZE_T OldBytesWritten = BytesWritten;
                SIZE_T ShimDataSize = 0;

                ALLOCATE_BUFFER_SPACE_TYPE(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM, Cursor, BytesLeft, BytesWritten, ShimInfo);

                IFW32FALSE_EXIT(
                    Entry->m_TypeNameBuffer.Win32CopyIntoBuffer(
                        (PWSTR *) &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        ShimInfo,
                        &ShimInfo->TypeOffset,
                        &ShimInfo->TypeLength));

                ShimInfo->ModuleLength = static_cast<ULONG>(Entry->m_FileContext->m_FileNameBuffer.Cch() * sizeof(WCHAR));
                ShimInfo->ModuleOffset = Entry->m_FileContext->m_Offset;

                IFW32FALSE_EXIT(
                    Entry->m_RuntimeVersionBuffer.Win32CopyIntoBuffer(
                        (PWSTR *) &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        ShimInfo,
                        &ShimInfo->ShimVersionOffset,
                        &ShimInfo->ShimVersionLength));

                ShimDataSize = BytesWritten - OldBytesWritten;

                if (Entry->m_IsFirstShim)
                {
                    Info->ModuleOffset = Entry->m_FileContext->m_GlobalContext->m_FirstShimNameOffset;
                    Info->ModuleLength = Entry->m_FileContext->m_GlobalContext->m_FirstShimNameLength;
                }
                else
                {
                    IFW32FALSE_EXIT(
                        Entry->m_ShimNameBuffer.Win32CopyIntoBuffer(
                            (PWSTR *) &Cursor,
                            &BytesLeft,
                            &BytesWritten,
                            CBData->SectionHeader,
                            &Info->ModuleOffset,
                            &Info->ModuleLength));
                }

                ShimInfo->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM);
                ShimInfo->Flags = 0;
                ShimInfo->Type = Entry->m_ShimType;

                ShimInfo->DataLength = 0;
                ShimInfo->DataOffset = 0;

                Info->ShimDataLength = static_cast<ULONG>(ShimDataSize);
                Info->ShimDataOffset = static_cast<ULONG>(((ULONG_PTR) ShimInfo) - ((ULONG_PTR) Info));
            }
            else
            {
                Info->ModuleLength = static_cast<ULONG>(Entry->m_FileContext->m_FileNameBuffer.Cch() * sizeof(WCHAR));
                Info->ModuleOffset = Entry->m_FileContext->m_Offset;
                Info->ShimDataLength = 0;
                Info->ShimDataOffset = 0;
            }

            IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32CopyIntoBuffer(
                (PWSTR *) &Cursor,
                &BytesLeft,
                &BytesWritten,
                Info,
                &Info->ProgIdOffset,
                &Info->ProgIdLength));

            CBData->BytesWritten = BytesWritten;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\comclsidmap.cpp ===
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "comclsidmap.h"
#include "SxsExceptionHandling.h"

#define CLASS_ID_MAPPINGS_SUBKEY_NAME L"ClassIdMappings\\"

CClsidMap::CClsidMap() :
    m_cLocalMappings(0),
    m_pLocalMappingListHead(NULL)
{
}

CClsidMap::~CClsidMap()
{
}

BOOL
CClsidMap::Initialize()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    fSuccess = TRUE;
// Exit:
    return fSuccess;
}

BOOL
CClsidMap::Uninitialize()
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    LocalMapping *pMapping = m_pLocalMappingListHead;

    while (pMapping != NULL)
    {
        LocalMapping *pNext = pMapping->m_pNext;
        FUSION_DELETE_SINGLETON(pMapping);
        pMapping = pNext;
    }

    fSuccess = TRUE;
//Exit:
    return fSuccess;
}

BOOL
CClsidMap::MapReferenceClsidToConfiguredClsid(
    const GUID *ReferenceClsid,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    GUID *ConfiguredClsid,
    GUID *ImplementedClsid
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    LocalMapping *pMapping = NULL;

    // We're in the unnamed assembly - there can be at most one unnamed assembly, so this
    // must be the root assembly.  We'll look for it in our local map.  If it's not there,
    // we'll just generate a GUID and store it in the map.

    for (pMapping = m_pLocalMappingListHead; pMapping != NULL; pMapping = pMapping->m_pNext)
    {
        if (pMapping->m_ReferenceClsid == *ReferenceClsid)
            break;
    }

    // Not found; create one.
    if (pMapping == NULL)
    {
        IFALLOCFAILED_EXIT(pMapping = new LocalMapping);

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INFO, "SXS.DLL: Adding clsid local mapping %p\n", pMapping);
#endif

        pMapping->m_pNext = m_pLocalMappingListHead;
        pMapping->m_ReferenceClsid = *ReferenceClsid;
        pMapping->m_ImplementedClsid = *ReferenceClsid;

        // No ConfiguredClsid... we'll make one up.
        RPC_STATUS st = ::UuidCreate(&pMapping->m_ConfiguredClsid);
        RETAIL_UNUSED(st);
        SOFT_ASSERT((st == RPC_S_OK) ||
                    (st == RPC_S_UUID_LOCAL_ONLY) ||
                    (st == RPC_S_UUID_NO_ADDRESS));

        m_pLocalMappingListHead = pMapping;
        m_cLocalMappings++;
    }

    ASSERT(pMapping != NULL);

    *ConfiguredClsid = pMapping->m_ConfiguredClsid;
    *ImplementedClsid = pMapping->m_ImplementedClsid;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cassemblyrecoveryinfo.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CAssemblyRecoveryInfo.h

Abstract:

Author:

Environment:

Revision History:

--*/
#pragma once

class CAssemblyRecoveryInfo;

#include "fusionbuffer.h"
#include "csecuritymetadata.h"

#define WINSXS_INSTALL_SOURCE_BASEDIR    (L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup")
#define WINSXS_INSTALL_SVCPACK_REGKEY    (L"ServicePackSourcePath")
#define WINSXS_INSTALL_SOURCEPATH_REGKEY (L"SourcePath")
#define WINSXS_INSTALL_SOURCE_IS_CDROM   (L"CDInstall")

class CAssemblyRecoveryInfo
{
private:
    CStringBuffer          m_sbAssemblyDirectoryName;
    CSecurityMetaData      m_SecurityMetaData;
    BOOL                   m_fLoadedAndReady;
    bool                   m_fHadCatalog;
    
    BOOL ResolveWinSourceMediaURL(PCWSTR wszSource, CBaseStringBuffer &rsbDestination) const;
    BOOL ResolveCDRomURL(PCWSTR wszSource, CBaseStringBuffer &rsbDestination) const;

    enum CDRomSearchType
    {
        CDRST_Tagfile,
        CDRST_SerialNumber,
        CDRST_VolumeName
    };

public:
    CAssemblyRecoveryInfo()
        : 
          m_fLoadedAndReady(FALSE),
          m_fHadCatalog(false)
    { }

    BOOL Initialize()
    {
        FN_PROLOG_WIN32
        
        m_sbAssemblyDirectoryName.Clear();
        m_fLoadedAndReady = FALSE;
        IFW32FALSE_EXIT( m_SecurityMetaData.Initialize() );

        FN_EPILOG
    }

    BOOL OpenInstallationSubKey(DWORD OpenOrCreate, DWORD Access);

    const CSecurityMetaData &GetSecurityInformation() const { return m_SecurityMetaData; }
    CSecurityMetaData& GetSecurityInformation() { return m_SecurityMetaData; }

    const CCodebaseInformationList& GetCodeBaseList() const { return m_SecurityMetaData.GetCodeBaseList(); }
//protected:
    CCodebaseInformationList& GetCodeBaseList() { return m_SecurityMetaData.GetCodeBaseList(); }
public:

    //
    // Fill out this object from a registry key
    //
    BOOL AssociateWithAssembly(CBaseStringBuffer &rcbuffLoadFromKeyName, bool &rfNoAssembly);

    //
    // Take an existing value - sort of like "initialize"
    //
    BOOL CopyValue(const CAssemblyRecoveryInfo &rsrc);

    //
    // Cheap, but effective.
    //
    const CBaseStringBuffer &GetAssemblyDirectoryName() const { return m_sbAssemblyDirectoryName; }
    BOOL GetHasCatalog() const                         { return TRUE; }
    BOOL GetInfoPrepared() const                       { return m_fLoadedAndReady; }

    //
    // Setters - useful for registration
    //
    BOOL SetAssemblyIdentity(IN const CBaseStringBuffer &rsb)  { return m_SecurityMetaData.SetTextualIdentity(rsb); }
    BOOL SetAssemblyIdentity( IN PCASSEMBLY_IDENTITY pcidAssembly );

    VOID SetHasCatalog(IN BOOL fHasCatalog)  { }

    //
    // Call this to try and resolve the internally listed codebase against
    // the system and return it into sbFinalCodebase.  Returns TRUE if the
    // operation is successful, not based on whether the codebase is valid.
    //
    BOOL ResolveCodebase(CBaseStringBuffer &rsbFinalCodebase, SxsWFPResolveCodebase &rCodebaseType) const;

    //
    // Last bit of bookkeeping necessary before writing the assembly to disk
    //
    BOOL PrepareForWriting();
    BOOL WriteSecondaryAssemblyInfoIntoRegistryKey(CRegKey & rhkRegistryNode) const;
#define SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_TO_REGISTRY_KEY_FLAG_REFRESH (0x00000001)
    BOOL WritePrimaryAssemblyInfoToRegistryKey(ULONG Flags, CRegKey & rhkRegistryNode) const;
    BOOL ClearExistingRegistryData();
    VOID RestorePreviouslyExistingRegistryData();
    BOOL OpenInstallationSubKey(CFusionRegKey& hkSingleAssemblyInfo, DWORD OpenOrCreate, DWORD Access);

    SMARTTYPEDEF(CAssemblyRecoveryInfo);

private:
    CAssemblyRecoveryInfo(const CAssemblyRecoveryInfo &);
    void operator =(const CAssemblyRecoveryInfo &);
};

MAKE_CFUSIONARRAY_READY(CAssemblyRecoveryInfo, CopyValue);

#define URLTAGINFO( namevalue, str ) \
    __declspec(selectany) extern const WCHAR URLHEAD_ ##namevalue [] = ( str ); \
    static const SIZE_T URLHEAD_LENGTH_ ##namevalue = \
        ( sizeof( URLHEAD_ ##namevalue ) / sizeof( WCHAR ) ) - 1;

//
// Move these to a .cpp file.
//

URLTAGINFO(FILE, L"file:")
URLTAGINFO(CDROM, L"cdrom:")
URLTAGINFO(WINSOURCE, L"x-ms-windows-source:")
//URLTAGINFO(DARWINSOURCE, L"x-ms-darwin-source:")
URLTAGINFO(HTTP, L"http:")

// These things are not URL heads but nonetheless still use the same macro
URLTAGINFO(CDROM_TYPE_TAG, L"tagfile")
URLTAGINFO(CDROM_TYPE_SERIALNUMBER, L"serialnumber")
URLTAGINFO(CDROM_TYPE_VOLUMENAME, L"volumename")

BOOL
SxspLooksLikeAssemblyDirectoryName(
    const CBaseStringBuffer &rsbDoesLookLikeName,
    BOOL &rbLooksLikeAssemblyName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cmemorystream.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CMemoryStream.h

Abstract:

    Minimal implementation of IStream over an array of bytes.

Author:

    Jay Krell (a-JayK) May 2000

Revision History:

--*/
#pragma once
#include "objidl.h"
#include "fusiontrace.h"

class CMemoryStream : public IStream
{
public:
    CMemoryStream();
    BOOL Initialize(const BYTE*, const BYTE*);
    virtual ~CMemoryStream();

    // IUnknown methods:
    ULONG __stdcall AddRef();
    ULONG __stdcall Release();
    HRESULT __stdcall QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    HRESULT __stdcall Read(void *pv, ULONG cb, ULONG *pcbRead);
    HRESULT __stdcall Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    HRESULT __stdcall Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    HRESULT __stdcall SetSize(ULARGE_INTEGER libNewSize);
    HRESULT __stdcall CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    HRESULT __stdcall Commit(DWORD grfCommitFlags);
    HRESULT __stdcall Revert();
    HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    HRESULT __stdcall Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    HRESULT __stdcall Clone(IStream **ppIStream);

protected:
    LONG        m_cRef;
    const BYTE *m_pbCurrent;
    const BYTE *m_pbBegin;
    const BYTE *m_pbEnd;

private: // intentionally not implemented
    CMemoryStream(const CMemoryStream &r);
    CMemoryStream &operator =(const CMemoryStream &r);
};

inline CMemoryStream::CMemoryStream(
    )
:
    m_cRef(0),
    m_pbCurrent(NULL),
    m_pbBegin(NULL),
    m_pbEnd(NULL)
{
}

inline BOOL
CMemoryStream::Initialize(
    const BYTE *pbBegin,
    const BYTE *pbEnd
    )
{
    m_pbBegin = pbBegin;
    m_pbEnd = pbEnd;
    m_pbCurrent = pbBegin;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\comclsidmap.h ===
#if !defined(_FUSION_COMCLSIDMAP_H_INCLUDED_)
#define _FUSION_COMCLSIDMAP_H_INCLUDED_

#pragma once

typedef const struct _ACTCTXCTB_ASSEMBLY_CONTEXT *PCACTCTXCTB_ASSEMBLY_CONTEXT;

class CClsidMap
{
public:
    CClsidMap();
    ~CClsidMap();

    BOOL Initialize();
    BOOL Uninitialize();

    BOOL MapReferenceClsidToConfiguredClsid(const GUID *ReferenceClsid, PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext, GUID *ConfiguredClsid, GUID *ImplementedClsid);

private:
    struct LocalMapping
    {
        struct LocalMapping *m_pNext;
        GUID m_ReferenceClsid;
        GUID m_ConfiguredClsid;
        GUID m_ImplementedClsid;
    };

    ULONG m_cLocalMappings;
    LocalMapping *m_pLocalMappingListHead;
};

#endif // !defined(_FUSION_COMCLSIDMAP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\comgoop.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    comgoop.cpp

Abstract:

    Wrapper to create the XML parser that emulates COM activation of the inproc server.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include <sxsp.h>
#include <ole2.h>
#include "xmlparser.hxx"

BOOL
SxspGetXMLParser(
    REFIID riid,
    PVOID *ppvObj
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    XMLParser * pXMLParser = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    PARAMETER_CHECK(ppvObj != NULL);

    IFALLOCFAILED_EXIT(pXMLParser = new XMLParser);
    IFCOMFAILED_EXIT(pXMLParser->QueryInterface(riid, ppvObj));

    pXMLParser = NULL;

    fSuccess = TRUE;

Exit:
    FUSION_DELETE_SINGLETON(pXMLParser);

    return fSuccess;

/*
    BOOL fSuccess = TRUE;
    HINSTANCE hMSXML = NULL;
    typedef HRESULT (__stdcall *PFNGETCLASSOBJECT)(const CLSID &rclsid, const IID &riid, void **ppv);
    PFNGETCLASSOBJECT pfnGetClassObject = NULL;
    IClassFactory *pIClassFactory = NULL;
    HRESULT hr;

    *ppvObj = NULL;

    hMSXML = LoadLibraryExW(L"MSXML.DLL", NULL, 0);
    if (hMSXML == NULL)
    {
        fSuccess = FALSE;
        goto Exit;
    }

    pfnGetClassObject = reinterpret_cast<PFNGETCLASSOBJECT>(::GetProcAddress(hMSXML, "DllGetClassObject"));
    if (pfnGetClassObject == NULL)
    {
        fSuccess = FALSE;
        goto Exit;
    }

    hr = (*pfnGetClassObject)(CLSID_XMLParser, IID_IClassFactory, (LPVOID *) &pIClassFactory);
    if (FAILED(hr))
    {
        ::FusionpSetLastErrorFromHRESULT(hr);
        fSuccess = FALSE;
        goto Exit;
    }

    hr = pIClassFactory->CreateInstance(NULL, riid, ppvObj);
    if (FAILED(hr))
        goto Exit;

    fSuccess = TRUE;

Exit:
    if (pIClassFactory != NULL)
        pIClassFactory->Release();

    return fSuccess;
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\comprogid.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    comprogid.cpp

Abstract:

    Activation context section contributor for COM progid mapping.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(progid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(id);

#define STRING_AND_LENGTH(x) x, NUMBER_OF(x)-1

BOOL
SxspComProgIdRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

typedef struct _COM_PROGID_GLOBAL_CONTEXT *PCOM_PROGID_GLOBAL_CONTEXT;
typedef struct _COM_PROGID_SERVER_CONTEXT *PCOM_PROGID_SERVER_CONTEXT;

typedef struct _COM_PROGID_GLOBAL_CONTEXT
{
    // Temporary holding buffer for the configured CLSID until the first COM progid entry is
    // found, at which time a COM_PROGID_SERVER_CONTEXT is allocated and the filename moved to it.
    GUID m_ConfiguredClsid;
    PCOM_PROGID_SERVER_CONTEXT m_ServerContextListHead;
    ULONG m_ServerContextListCount;
} COM_PROGID_GLOBAL_CONTEXT;

typedef struct _COM_PROGID_SERVER_CONTEXT
{
    PCOM_PROGID_SERVER_CONTEXT m_Next;
    GUID m_ConfiguredClsid;
    LONG m_Offset; // populated during section generation
} COM_PROGID_SERVER_CONTEXT;

VOID
SxspComProgIdRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PSTRING_SECTION_GENERATION_CONTEXT SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    PCOM_PROGID_GLOBAL_CONTEXT ComGlobalContext = NULL;

    if (SSGenContext != NULL)
        ComGlobalContext = (PCOM_PROGID_GLOBAL_CONTEXT) ::SxsGetStringSectionGenerationContextCallbackContext(SSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(ComGlobalContext == NULL);
        INTERNAL_ERROR_CHECK(SSGenContext == NULL);

        IFALLOCFAILED_EXIT(ComGlobalContext = new COM_PROGID_GLOBAL_CONTEXT);

        ComGlobalContext->m_ConfiguredClsid = GUID_NULL;
        ComGlobalContext->m_ServerContextListHead = NULL;
        ComGlobalContext->m_ServerContextListCount = 0;

        if (!::SxsInitStringSectionGenerationContext(
                &SSGenContext,
                ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION_FORMAT_WHISTLER,
                TRUE,
                &::SxspComProgIdRedirectionStringSectionGenerationCallback,
                ComGlobalContext))
        {
            FUSION_DELETE_SINGLETON(ComGlobalContext);
            goto Exit;
        }

        Data->Header.ActCtxGenContext = SSGenContext;

        Data->GenBeginning.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        {
            PCOM_PROGID_SERVER_CONTEXT ServerContext;
            ULONG ContextCount;

            if (ComGlobalContext != NULL)
            {
                if (SSGenContext != NULL)
                    ::SxsDestroyStringSectionGenerationContext(SSGenContext);

                ServerContext = ComGlobalContext->m_ServerContextListHead;

                ContextCount = 0;

                while (ServerContext != NULL)
                {
                    PCOM_PROGID_SERVER_CONTEXT NextServerContext = ServerContext->m_Next;

                    FUSION_DELETE_SINGLETON(ServerContext);
                    ServerContext = NextServerContext;

                    if (ContextCount++ > ComGlobalContext->m_ServerContextListCount)
                        break;
                }

                // If this assert fires, we ran out of entries in the list before we hit as many
                // server contexts as the list thinks there are.
                ASSERT(ContextCount == ComGlobalContext->m_ServerContextListCount);

                // If this assert fires, we seem to have more entries in the list than the
                // list count indicates.
                ASSERT(ServerContext == NULL);

                FUSION_DELETE_SINGLETON(ComGlobalContext);
            }

            break;
        }

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;
        if (SSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingStringSectionGenerationContext(SSGenContext));
        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_PCDATAPARSED:
        {
            Data->PCDATAParsed.Success = FALSE;

            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssemblyFileComclassProgid = 1
            };

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                { 4, STRING_AND_LENGTH(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comClass!urn:schemas-microsoft-com:asm.v1^progid"), eAssemblyFileComclassProgid },
                { 3, STRING_AND_LENGTH(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrClass!urn:schemas-microsoft-com:asm.v1^progid"), eAssemblyFileComclassProgid }
            };

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->PCDATAParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));;

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR2_ACTION(MappedValue, "Invalid mapped value returned from SxspProcessElementPathMap()");

                case eAssemblyFileComclassProgid:
                    {
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            PCOM_PROGID_SERVER_CONTEXT ServerContext = NULL;
                            INTERNAL_ERROR_CHECK(ComGlobalContext != NULL);
                            ServerContext = ComGlobalContext->m_ServerContextListHead;
                            INTERNAL_ERROR_CHECK(ServerContext != NULL);
                            IFW32FALSE_EXIT(
                                ::SxsAddStringToStringSectionGenerationContext(
                                    (PSTRING_SECTION_GENERATION_CONTEXT) Data->PCDATAParsed.Header.ActCtxGenContext,
                                    Data->PCDATAParsed.Text,
                                    Data->PCDATAParsed.TextCch,
                                    ServerContext,
                                    Data->PCDATAParsed.AssemblyContext->AssemblyRosterIndex,
                                    ERROR_SXS_DUPLICATE_PROGID));
                        }

                        break;
                    }
                }
            }

            Data->PCDATAParsed.Success = TRUE;

            break;
        }

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        {
            Data->ElementParsed.Success = FALSE;

            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssemblyFileComclass = 1
            };

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                { 3, STRING_AND_LENGTH(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comClass"), eAssemblyFileComclass },
                { 2, STRING_AND_LENGTH(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrClass"), eAssemblyFileComclass }
            };

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->ElementParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR2_ACTION(MappedValue, "Invalid mapped value returned from SxspProcessElementPathMap()");

                case eAssemblyFileComclass:
                    {
                        bool fProgIdFound = false;
                        bool fFound = false;
                        SIZE_T cb;
                        CSmallStringBuffer VersionIndependentComClassIdBuffer;
                        PCOM_PROGID_SERVER_CONTEXT ServerContext = NULL;
                        CSmallStringBuffer ProgIdBuffer;
                        GUID ReferenceClsid, ConfiguredClsid, ImplementedClsid;

                        INTERNAL_ERROR_CHECK2(
                            ComGlobalContext != NULL,
                            "COM progid global context NULL while processing comClass tag");

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_clsid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(VersionIndependentComClassIdBuffer),
                                &VersionIndependentComClassIdBuffer,
                                cb,
                                NULL,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(
                            ::SxspParseGUID(
                                VersionIndependentComClassIdBuffer,
                                VersionIndependentComClassIdBuffer.Cch(),
                                ReferenceClsid));

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_progid,
                                &Data->ElementParsed,
                                fProgIdFound,
                                sizeof(ProgIdBuffer),
                                &ProgIdBuffer,
                                cb,
                                NULL,
                                0));

                        // That was sufficient we are not generating an activation context,
                        // or if there's no progid= attribute on the element.
                        if (fProgIdFound && (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT))
                        {
                            IFW32FALSE_EXIT(Data->Header.ClsidMappingContext->Map->MapReferenceClsidToConfiguredClsid(
                                        &ReferenceClsid,
                                        Data->ElementParsed.AssemblyContext,
                                        &ConfiguredClsid,
                                        &ImplementedClsid));

                            IFALLOCFAILED_EXIT(ServerContext = new COM_PROGID_SERVER_CONTEXT);

                            ServerContext->m_ConfiguredClsid = ConfiguredClsid;
                            ServerContext->m_Offset = 0;
                            ServerContext->m_Next = ComGlobalContext->m_ServerContextListHead;
                            ComGlobalContext->m_ServerContextListHead = ServerContext;
                            ComGlobalContext->m_ServerContextListCount++;

                            IFW32FALSE_EXIT(::SxsAddStringToStringSectionGenerationContext(
                                        (PSTRING_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                                        ProgIdBuffer,
                                        ProgIdBuffer.Cch(),
                                        ServerContext,
                                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                        ERROR_SXS_DUPLICATE_PROGID));
                        }

                        break;
                    }

                }
            }

            Data->ElementParsed.Success = TRUE;

            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;

        // Someone shouldn't be asking for the section size if we
        // are generating an activation context.
        // These two asserts should be equivalent...
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(SSGenContext != NULL);

        IFW32FALSE_EXIT(
            ::SxsGetStringSectionGenerationContextSectionSize(
                SSGenContext,
                &Data->GetSectionSize.SectionSize));

        Data->GetSectionSize.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;

        INTERNAL_ERROR_CHECK(SSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);

        IFW32FALSE_EXIT(
            ::SxsGetStringSectionGenerationContextSectionData(
                SSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));

        Data->GetSectionData.Success = TRUE;
        break;
    }
Exit:
    ;
}

BOOL
SxspComProgIdRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PCOM_PROGID_GLOBAL_CONTEXT GlobalContext = (PCOM_PROGID_GLOBAL_CONTEXT) Context;

    switch (Reason)
    {
    default:
        INTERNAL_ERROR_CHECK(FALSE);
        goto Exit; // never hit this line, INTERNAL_ERROR_CHECK would "goto Exit"

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        // do nothing;
        break;

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE) CallbackData;
            CBData->DataSize = sizeof(GUID) * GlobalContext->m_ServerContextListCount;

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA) CallbackData;
            SIZE_T BytesWritten = 0;
            SIZE_T BytesLeft = CBData->BufferSize;
            GUID *Cursor = (GUID *) CBData->Buffer;
            PCOM_PROGID_SERVER_CONTEXT ServerContext = GlobalContext->m_ServerContextListHead;

            INTERNAL_ERROR_CHECK2(
                BytesLeft >= (sizeof(GUID) * GlobalContext->m_ServerContextListCount),
                "progid section generation ran out of buffer storing configured clsids");

            BytesWritten += (sizeof(GUID) * GlobalContext->m_ServerContextListCount);
            BytesLeft -= (sizeof(GUID) * GlobalContext->m_ServerContextListCount);

            while (ServerContext != NULL)
            {
                ServerContext->m_Offset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) CBData->SectionHeader));
                *Cursor++ = ServerContext->m_ConfiguredClsid;
                ServerContext = ServerContext->m_Next;
            }

            CBData->BytesWritten = BytesWritten;

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION);
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Info;
            PCOM_PROGID_SERVER_CONTEXT ServerContext = (PCOM_PROGID_SERVER_CONTEXT) CBData->DataContext;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            Info = (PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION) CBData->Buffer;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION);
            Info->Flags = 0;
            Info->ConfiguredClsidOffset = ServerContext->m_Offset;

            CBData->BytesWritten = BytesWritten;

            break;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\comtypelib.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    comtypelib.cpp

Abstract:

    Activation context section contributor for COM typelib mapping.

Author:

    Michael J. Grier (MGrier) 28-Mar-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include <stdio.h>
#include "sxsp.h"
#include "sxsidp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(tlbid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(version);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(resourceid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(flags);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(helpdir);

/*

<file name="foo.dll">
   <typelib tlbid="{tlbid}" resourceid="5" version="2.5" flags="control,hidden" helpdir="HelpFiles\"/>
   <typelib tlbid="{tlbid}" resourceid="6" version="2.6" flags="control,hidden" helpdir="HelpFiles\"/>
   <comClass .../>
</file>

*/

#define MAP_ENTRY(_x) { L#_x, NUMBER_OF(#_x) - 1, LIBFLAG_F ## _x }
static const struct
{
    PCWSTR Flag;
    SIZE_T FlagCch;
    USHORT FlagValue;
} gs_rgMapLibFlags[] =
{
    // Values taken from the LIBFLAGS enumeration in oaidl.h
    MAP_ENTRY(RESTRICTED),
    MAP_ENTRY(CONTROL),
    MAP_ENTRY(HIDDEN),
    MAP_ENTRY(HASDISKIMAGE),
};

typedef struct _TLB_GLOBAL_CONTEXT *PTLB_GLOBAL_CONTEXT;
typedef struct _TLB_FILE_CONTEXT *PTLB_FILE_CONTEXT;
typedef struct _TLB_ENTRY *PTLB_ENTRY;
typedef  _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION _TLB_VERSION;
typedef   ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION TLB_VERSION;
typedef  PACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION PTLB_VERSION;
typedef PCACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION PCTLB_VERSION;

typedef struct _TLB_GLOBAL_CONTEXT
{
    _TLB_GLOBAL_CONTEXT() { }

    PTLB_FILE_CONTEXT m_FileContextListHead;
    ULONG m_FileContextListCount;
    CStringBuffer m_FileNameBuffer;

private:
    _TLB_GLOBAL_CONTEXT(const _TLB_GLOBAL_CONTEXT &);
    void operator =(const _TLB_GLOBAL_CONTEXT &);
} TLB_GLOBAL_CONTEXT;

typedef struct _TLB_FILE_CONTEXT
{
    _TLB_FILE_CONTEXT() { }

    PTLB_FILE_CONTEXT m_Next;
    PTLB_ENTRY m_TlbListHead;
    SIZE_T m_TlbListCount;
    CStringBuffer m_FileNameBuffer;
    ULONG m_Offset; // populated during section generation

private:
    _TLB_FILE_CONTEXT(const _TLB_FILE_CONTEXT &);
    void operator =(const _TLB_FILE_CONTEXT &);
} TLB_FILE_CONTEXT;

typedef struct _TLB_ENTRY
{
    _TLB_ENTRY() { }

    struct _TLB_ENTRY *m_Next;
    PTLB_FILE_CONTEXT m_FileContext;
    GUID            m_TypeLibId;
    CStringBuffer   m_HelpDirBuffer;
    TLB_VERSION     m_Version;
    USHORT          m_ResourceId;
    USHORT          m_LibraryFlags;

private:
    _TLB_ENTRY(const _TLB_ENTRY &);
    void operator =(const _TLB_ENTRY &);
} TLB_ENTRY, *PTLB_ENTRY;

BOOL
SxspComTypeLibRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

BOOL
SxspParseTlbVersion(
    PCWSTR String,
    SIZE_T Cch,
    PTLB_VERSION Version
    );

BOOL
SxspFormatTlbVersion(
    const TLB_VERSION *Version,
    CBaseStringBuffer &Buffer
    );

BOOL
SxspParseLibraryFlags(
    PCWSTR String,
    SIZE_T Cch,
    USHORT *LibraryFlags
    );

VOID
WINAPI
SxspComTypeLibRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PGUID_SECTION_GENERATION_CONTEXT SSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    PTLB_GLOBAL_CONTEXT TlbGlobalContext = NULL;

    if (SSGenContext != NULL)
        TlbGlobalContext = (PTLB_GLOBAL_CONTEXT) ::SxsGetGuidSectionGenerationContextCallbackContext(SSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(TlbGlobalContext == NULL);
        INTERNAL_ERROR_CHECK(SSGenContext == NULL);

        // do everything if we are generating an activation context.
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        {
            IFALLOCFAILED_EXIT(TlbGlobalContext = new TLB_GLOBAL_CONTEXT);

            TlbGlobalContext->m_FileContextListHead = NULL;
            TlbGlobalContext->m_FileContextListCount = 0;

            if (!::SxsInitGuidSectionGenerationContext(
                    &SSGenContext,
                    ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_FORMAT_WHISTLER,
                    &::SxspComTypeLibRedirectionGuidSectionGenerationCallback,
                    TlbGlobalContext))
            {
                FUSION_DELETE_SINGLETON(TlbGlobalContext);
                goto Exit;
            }

            Data->Header.ActCtxGenContext = SSGenContext;
        }

        Data->GenBeginning.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (SSGenContext != NULL)
            ::SxsDestroyGuidSectionGenerationContext(SSGenContext);
        FUSION_DELETE_SINGLETON(TlbGlobalContext);
        TlbGlobalContext = NULL;
        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        Data->ElementParsed.Success = FALSE;

        if ((Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT) || 
            (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)) // in installcase, the following code would verify the syntax of the manifest file
        {
            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssemblyFile = 1,
                eAssemblyFileTypelib = 2,
            };

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                { 2, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file", NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file") - 1, eAssemblyFile },
                { 3, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^typelib", NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^typelib") - 1, eAssemblyFileTypelib },
            };

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->ElementParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR_CHECK2(
                        FALSE,
                        "Invalid mapped value returned from SxspProcessElementPathMap");

                case eAssemblyFile:
                    {
                        SIZE_T cb;
                        CStringBuffer FileNameBuffer;

                        fFound = false;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_name,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(FileNameBuffer),
                                &FileNameBuffer,
                                cb,
                                NULL,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);
                        
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            INTERNAL_ERROR_CHECK2(
                                TlbGlobalContext != NULL,
                                "COM tlb global context NULL while processing file tag");

                            IFW32FALSE_EXIT(TlbGlobalContext->m_FileNameBuffer.Win32Assign(FileNameBuffer));
                        }

                        break;
                    }

                case eAssemblyFileTypelib:
                    {
                        GUID TypeLibId;
                        CStringBuffer HelpDirBuffer;
                        CStringBuffer TempBuffer;
                        SIZE_T cb;
                        TLB_VERSION Version;
                        USHORT LibraryFlags;
                        USHORT ResourceId;

                        fFound = false;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_tlbid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(TempBuffer),
                                &TempBuffer,
                                cb,
                                NULL,
                                0));
                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(::SxspParseGUID(TempBuffer, TempBuffer.Cch(), TypeLibId));
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_version,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(TempBuffer),
                                &TempBuffer,
                                cb,
                                NULL,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(::SxspParseTlbVersion(TempBuffer, TempBuffer.Cch(), &Version));
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_resourceid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(TempBuffer),
                                &TempBuffer,
                                cb,
                                NULL,
                                0));

                        if (fFound)
                            IFW32FALSE_EXIT(::SxspParseUSHORT(TempBuffer, TempBuffer.Cch(), &ResourceId));
                        else
                            ResourceId = 1;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_flags,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(TempBuffer),
                                &TempBuffer,
                                cb,
                                NULL,
                                NULL));

                        if (fFound)
                            IFW32FALSE_EXIT(::SxspParseLibraryFlags(TempBuffer, TempBuffer.Cch(), &LibraryFlags));
                        else
                            LibraryFlags = 0;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_helpdir,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(HelpDirBuffer),
                                &HelpDirBuffer,
                                cb,
                                NULL,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        // Do more work if generating an activation context.
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            PTLB_FILE_CONTEXT FileContext = NULL;
                            PTLB_ENTRY Entry = NULL;

                            INTERNAL_ERROR_CHECK2(TlbGlobalContext != NULL, "COM tlb global context NULL while processing comClass tag");

                            // If this is the first <typelib> for the file, create the file context object
                            if (TlbGlobalContext->m_FileNameBuffer.Cch() != 0)
                            {
                                IFALLOCFAILED_EXIT(FileContext = new TLB_FILE_CONTEXT);

                                IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign(TlbGlobalContext->m_FileNameBuffer));
                                FileContext->m_TlbListHead = NULL;
                                FileContext->m_TlbListCount = 0;

                                FileContext->m_Next = TlbGlobalContext->m_FileContextListHead;
                                TlbGlobalContext->m_FileContextListHead = FileContext;
                                TlbGlobalContext->m_FileContextListCount++;
                            }

                            FileContext = TlbGlobalContext->m_FileContextListHead;

                            INTERNAL_ERROR_CHECK2(
                                FileContext != NULL,
                                "COM tlb file context NULL while processing typelib tag; we should have failed before getting to the typelib element.");

                            IFALLOCFAILED_EXIT(Entry = new TLB_ENTRY);

                            Entry->m_FileContext = FileContext;
                            Entry->m_TypeLibId = TypeLibId;
                            Entry->m_Version = Version;
                            Entry->m_ResourceId = ResourceId;
                            Entry->m_LibraryFlags = LibraryFlags;

                            IFW32FALSE_EXIT(Entry->m_HelpDirBuffer.Win32Assign(HelpDirBuffer));

                            IFW32FALSE_EXIT(
                                ::SxsAddGuidToGuidSectionGenerationContext(
                                    (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                                    &TypeLibId,
                                    Entry,
                                    Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                    ERROR_SXS_DUPLICATE_TLBID));

                            Entry->m_Next = FileContext->m_TlbListHead;
                            FileContext->m_TlbListHead = Entry;
                            FileContext->m_TlbListCount++;
                        }

                        break;
                    }
                }
            }
        }

        Data->ElementParsed.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;
#if 0
        if (SSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingGuidSectionGenerationContext(SSGenContext));
#endif        
        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        // Someone shouldn't be asking for the section size if we
        // are not generating an activation context.
        // These two asserts should be equivalent...
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(SSGenContext != NULL);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionSize(SSGenContext, &Data->GetSectionSize.SectionSize));
        Data->GetSectionSize.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;

        INTERNAL_ERROR_CHECK(SSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);

        IFW32FALSE_EXIT(
            ::SxsGetGuidSectionGenerationContextSectionData(
                SSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));

        Data->GetSectionData.Success = TRUE;
        break;
    }
Exit:
    ;
}

BOOL
SxspComTypeLibRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PTLB_GLOBAL_CONTEXT GlobalContext = (PTLB_GLOBAL_CONTEXT) Context;

    switch (Reason)
    {
    default:
        FN_SUCCESSFUL_EXIT();

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE) CallbackData;
            PTLB_FILE_CONTEXT FileContext = GlobalContext->m_FileContextListHead;
#if DBG
            ULONG count = 0;
#endif // DBG

            while (FileContext != NULL)
            {
#if DBG
                ASSERT(count < GlobalContext->m_FileContextListCount);
#endif // DBG
                CBData->DataSize += ((FileContext->m_FileNameBuffer.Cch() + 1) * sizeof(WCHAR));
                FileContext = FileContext->m_Next;
#if DBG
                count++;
#endif // DBG
            }

#if DBG
            ASSERT(count == GlobalContext->m_FileContextListCount);
#endif // DBG

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA) CallbackData;
            SIZE_T BytesWritten = 0;
            SIZE_T BytesLeft = CBData->BufferSize;
            PWSTR Cursor = (PWSTR) CBData->Buffer;
            PTLB_FILE_CONTEXT FileContext = GlobalContext->m_FileContextListHead;

            while (FileContext != NULL)
            {
                IFW32FALSE_EXIT(
                    FileContext->m_FileNameBuffer.Win32CopyIntoBuffer(
                        &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        CBData->SectionHeader,
                        &FileContext->m_Offset,
                        NULL));

                FileContext = FileContext->m_Next;
            }

            CBData->BytesWritten = BytesWritten;

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PTLB_ENTRY Entry = (PTLB_ENTRY) CBData->DataContext;

            if (Entry != NULL)
            {
                if (Entry->m_FileContext != NULL)
                {
                    Entry->m_FileContext->m_TlbListCount--;

                    if (Entry->m_FileContext->m_TlbListCount == 0)
                        FUSION_DELETE_SINGLETON(Entry->m_FileContext);
                }

                FUSION_DELETE_SINGLETON(Entry);
            }

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PTLB_ENTRY Entry = (PTLB_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION);

            if (Entry != NULL)
            {
                SIZE_T Cch;
#define GET_BUFFER_SIZE(Buffer) (((Cch = (Buffer).Cch()) != 0) ? ((Cch + 1) * sizeof(WCHAR)) : 0)
                CBData->DataSize += GET_BUFFER_SIZE(Entry->m_HelpDirBuffer);
#undef GET_BUFFER_SIZE
            }
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION Info;
            PTLB_ENTRY Entry = (PTLB_ENTRY) CBData->DataContext;
            PTLB_FILE_CONTEXT FileContext = Entry->m_FileContext;
            PWSTR StringCursor;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            Info = (PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION) CBData->Buffer;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION);

            StringCursor = (PWSTR) (Info + 1);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION);
            Info->Flags = 0;
            Info->NameLength = static_cast<ULONG>((FileContext->m_FileNameBuffer.Cch() + 1) * sizeof(WCHAR));
            Info->NameOffset = FileContext->m_Offset;
            Info->ResourceId = Entry->m_ResourceId;
            Info->LibraryFlags = Entry->m_LibraryFlags;
            Info->Version = Entry->m_Version;

            IFW32FALSE_EXIT(
                Entry->m_HelpDirBuffer.Win32CopyIntoBuffer(
                    &StringCursor,
                    &BytesLeft,
                    &BytesWritten,
                    Info,
                    &Info->HelpDirOffset,
                    &Info->HelpDirLength));

            CBData->BytesWritten = BytesWritten;
        }
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspParseTlbVersion(
    PCWSTR String,
    SIZE_T Cch,
    PTLB_VERSION Version
    )
{
    BOOL fSuccess = FALSE;
    PCWSTR psz = String;
    ULONG cDots = 0;
    PCWSTR pszTemp;
    SIZE_T cchLeft;
    USHORT usTemp;
    TLB_VERSION TempVersion;
    LPCWSTR pszLast;

    TempVersion.Major = 0;
    TempVersion.Minor = 0;

    while ((Cch != 0) && (psz[Cch - 1] == L'\0'))
        Cch--;

    // Unfortunately there isn't a StrChrN(), so we'll look for the dots ourselves...
    pszTemp = psz;
    cchLeft = Cch;

    while (cchLeft-- != 0)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'.')
        {
            cDots++;

            if (cDots >= 2)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: Found two or more dots in a TLB version number.\n");

                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
        }
        else if ((wch < L'0') || (wch > L'9'))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Found characters other than . and 0-9 in a TLB version number.\n");
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
    }

    if (cDots < 1)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: No dots found in a TLB version number.\n");
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    pszTemp = psz;
    pszLast = psz + Cch;

    usTemp = 0;
    for (;;)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'.')
            break;

        usTemp = (usTemp * 10) + (wch - L'0');
    }
    TempVersion.Major = usTemp;

    // Now the tricky bit.  We aren't necessarily null-terminated, so we
    // have to just look for hitting the end.
    usTemp = 0;
    while (pszTemp < pszLast)
    {
        WCHAR wch = *pszTemp++;
        usTemp = (usTemp * 10) + (wch - L'0');
    }
    TempVersion.Minor = usTemp;

    *Version = TempVersion;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspFormatTlbVersion(
    const TLB_VERSION *Version,
    CBaseStringBuffer &Buffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    WCHAR rgwchBuffer[sizeof("65535.65535\0")];

    SIZE_T CchFound = swprintf(rgwchBuffer, L"%u.%u", Version->Major, Version->Minor);
    IFW32FALSE_EXIT(Buffer.Win32Assign(rgwchBuffer, CchFound));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspParseLibraryFlags(
    PCWSTR String,
    SIZE_T Cch,
    USHORT *LibraryFlags
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SIZE_T CchThisSegment;
    SIZE_T i;
    USHORT TempFlags = 0;

    if (LibraryFlags != NULL)
        *LibraryFlags = 0;

    while (Cch != 0)
    {
        PCWSTR Comma = wcschr(String, L',');
        if (Comma != NULL)
            CchThisSegment = Comma - String;
        else
            CchThisSegment = Cch;

/* This chunk of code was wrong up till about build 3600, including XP RTM 2600 */
        for (i=0; i<NUMBER_OF(gs_rgMapLibFlags); i++)
        {
            if (::FusionpCompareStrings(
                        gs_rgMapLibFlags[i].Flag,
                        gs_rgMapLibFlags[i].FlagCch,
                        String,
                        CchThisSegment,
                        true) == 0)
            {
                if ((TempFlags & gs_rgMapLibFlags[i].FlagValue) != 0)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: Redundant type library flags\n");
                    ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                    goto Exit;
                }
                TempFlags |= gs_rgMapLibFlags[i].FlagValue;
                break;
            }
        }
        if (i == NUMBER_OF(gs_rgMapLibFlags))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Invalid type library flags\n");
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        Cch -= CchThisSegment;
        String += CchThisSegment;

        if (Cch != 0)
        {
            // there must have been a comma there...
            Cch--;
            String++;

            // However, if that was all there was, we have a parse error.
            if (Cch == 0)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: Trailing comma in type library flag string\n");
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
        }
    }

    if (LibraryFlags != NULL)
        *LibraryFlags = TempFlags;

    fSuccess = TRUE;

Exit:
    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\componentpolicytable.cpp ===
#include "stdinc.h"
#include "componentpolicytable.h"

BOOL
CComponentPolicyTableHelper::HashKey(
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG &rulPseudoKey
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(AssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxsHashAssemblyIdentity(0, AssemblyIdentity, &rulPseudoKey));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CComponentPolicyTableHelper::CompareKey(
    PCASSEMBLY_IDENTITY keyin,
    const PCASSEMBLY_IDENTITY &rkeystored,
    bool &rfMatch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL fEqual = FALSE;

    rfMatch = false;

    PARAMETER_CHECK(keyin != NULL);
    PARAMETER_CHECK(rkeystored != NULL);

    IFW32FALSE_EXIT(::SxsAreAssemblyIdentitiesEqual(0, keyin, rkeystored, &fEqual));

    if (fEqual)
        rfMatch = true;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CComponentPolicyTableHelper::InitializeKey(
    PCASSEMBLY_IDENTITY keyin,
    PCASSEMBLY_IDENTITY &rkeystored
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;

    rkeystored = NULL;

    PARAMETER_CHECK(keyin != NULL);

    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE,
            keyin,
            &AssemblyIdentity));

    rkeystored = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;
Exit:
    if (AssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(AssemblyIdentity);

    return fSuccess;
}

BOOL
CComponentPolicyTableHelper::InitializeValue(
    CPolicyStatement *vin,
    CPolicyStatement *&rvstored
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(vin != NULL);
    INTERNAL_ERROR_CHECK(rvstored == NULL);

    rvstored = vin;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CComponentPolicyTableHelper::UpdateValue(
    CPolicyStatement *vin,
    CPolicyStatement *&rvstored
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (rvstored != NULL)
        FUSION_DELETE_SINGLETON(rvstored);

    rvstored = vin;

    fSuccess = TRUE;
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\componentpolicytable.h ===
#if !defined(_FUSION_DLL_WHISTLER_COMPONENTPOLICYTABLE_H_INCLUDED_
#define _FUSION_DLL_WHISTLER_COMPONENTPOLICYTABLE_H_INCLUDED_

#pragma once

#include "fusionhash.h"
#include "policystatement.h"

class CComponentPolicyTableHelper
{
public:
    static BOOL HashKey(PCASSEMBLY_IDENTITY AssemblyIdentity, ULONG &rulPseudoKey);
    static BOOL CompareKey(PCASSEMBLY_IDENTITY keyin, const PCASSEMBLY_IDENTITY &rtkeystored, bool &rfMatch);
    static VOID PreInitializeKey(PCASSEMBLY_IDENTITY &rkey) { rkey = NULL; }
    static VOID PreInitializeValue(CPolicyStatement *&rp) { rp = NULL; }
    static BOOL InitializeKey(PCASSEMBLY_IDENTITY keyin, PCASSEMBLY_IDENTITY &rtkeystored);
    static BOOL InitializeValue(CPolicyStatement * vin, CPolicyStatement * &rvstored);
    static BOOL UpdateValue(CPolicyStatement * vin, CPolicyStatement * &rvstored);
    static VOID FinalizeKey(PCASSEMBLY_IDENTITY &rkeystored) { if (rkeystored != NULL) { ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(rkeystored)); rkeystored = NULL; } }
    static VOID FinalizeValue(CPolicyStatement *&rvstored) { if (rvstored != NULL) { FUSION_DELETE_SINGLETON(rvstored); rvstored = NULL; } }
};

typedef CHashTable<PCASSEMBLY_IDENTITY, PCASSEMBLY_IDENTITY, CPolicyStatement *, CPolicyStatement *, CComponentPolicyTableHelper> CComponentPolicyTable;

#endif // !defined(_FUSION_DLL_WHISTLER_COMPONENTPOLICYTABLE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cominterface.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cominterface.cpp

Abstract:

    Activation context section contributor for COM interface proxy mapping.

Author:

    Michael J. Grier (MGrier) 28-Mar-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include <stdio.h>
#include "sxsp.h"
#include "sxsidp.h"
#include "fusionparser.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(baseInterface);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(iid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(numMethods);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(proxyStubClsid32);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(tlbid);

/*

<file name="foo.dll">
   <comInterfaceProxyStub iid="{iid}" tlbid="{tlbid}" numMethods="3" baseInterface="{iid}" name="IFoo"/>
</file>

*/

typedef struct _IID_ENTRY
{
    _IID_ENTRY() { }
    GUID m_clsid;
    GUID m_iid;
    ULONG m_nMethods;
    GUID m_tlbid;
    GUID m_iidBase;
    CStringBuffer m_buffName;
    bool m_fNumMethodsValid;
    bool m_fBaseInterfaceValid;

private:
    _IID_ENTRY(const _IID_ENTRY &);
    void operator =(const _IID_ENTRY &);
} IID_ENTRY, *PIID_ENTRY;

BOOL
SxspComInterfaceRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

VOID
SxspComInterfaceRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PGUID_SECTION_GENERATION_CONTEXT GSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(GSGenContext == NULL);

        // do everything if we are generating an activation context.
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        {
            IFW32FALSE_EXIT(
                ::SxsInitGuidSectionGenerationContext(
                    &GSGenContext,
                    ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FORMAT_WHISTLER,
                    &::SxspComInterfaceRedirectionGuidSectionGenerationCallback,
                    NULL));

            Data->Header.ActCtxGenContext = GSGenContext;
        }

        Data->GenBeginning.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (GSGenContext != NULL)
            ::SxsDestroyGuidSectionGenerationContext(GSGenContext);
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;
#if 0
        // this call isn't implemented for guid sections ... yet
        if (GSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingGuidSectionGenerationContext(GSGenContext));
#endif
        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        // Someone shouldn't be asking for the section size if we
        // are not generating an activation context.
        // These two asserts should be equivalent...
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);

        IFW32FALSE_EXIT(
            ::SxsGetGuidSectionGenerationContextSectionSize(
                GSGenContext,
                &Data->GetSectionSize.SectionSize));

        Data->GetSectionSize.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        Data->ElementParsed.Success = FALSE;
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        {
            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssemblyInterface = 1,
                eAssemblyFileComClassInterface = 2,
            };

#define PATH_MAP_ENTRY(_depth, _string, _mv) { (_depth), _string, NUMBER_OF(_string) - 1, (_mv) },

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                PATH_MAP_ENTRY(2, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^comInterfaceExternalProxyStub", eAssemblyInterface)
                PATH_MAP_ENTRY(3, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comInterfaceProxyStub", eAssemblyFileComClassInterface)
            };

#undef PATH_MAP_ENTRY

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->ElementParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR_CHECK2(
                        FALSE,
                        "Invalid mapped value returned from SxspProcessElementPathMap");

                case eAssemblyInterface:
                    {
                        bool fFound = false;
                        CStringBuffer TempBuffer;
                        GUID iid, tlbid, iidBase, clsid;
                        ULONG nMethods = 0;
                        SIZE_T cb;
                        bool fNumMethodsValid = false;
                        bool fBaseInterfaceValid = false;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_iid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(iid),
                                &iid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_proxyStubClsid32,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(clsid),
                                &clsid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        if (!fFound)
                            clsid = iid;

                        IFW32FALSE_EXIT(::SxspGetAttributeValue(0, &s_AttributeName_numMethods, &Data->ElementParsed, fFound, sizeof(TempBuffer), &TempBuffer, cb, NULL, 0));
                        if (fFound)
                        {
                            IFW32FALSE_EXIT(CFusionParser::ParseULONG(nMethods, TempBuffer, TempBuffer.Cch()));
                            fNumMethodsValid = true;
                        }

                        tlbid = GUID_NULL;
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_tlbid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(tlbid),
                                &tlbid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_baseInterface,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(iidBase),
                                &iidBase,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));
                        if (fFound)
                            fBaseInterfaceValid = true;

                        TempBuffer.Clear();
                        IFW32FALSE_EXIT(::SxspGetAttributeValue(0, &s_AttributeName_name, &Data->ElementParsed, fFound, sizeof(TempBuffer), &TempBuffer, cb, NULL, 0));

                        // Do more work if generating an activation context.
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            PIID_ENTRY Entry = NULL;

                            IFALLOCFAILED_EXIT(Entry = new IID_ENTRY);

                            Entry->m_clsid = clsid;
                            Entry->m_tlbid = tlbid;
                            Entry->m_iid = iid;
                            Entry->m_iidBase = iidBase;
                            Entry->m_nMethods = nMethods;
                            Entry->m_fNumMethodsValid = fNumMethodsValid;
                            Entry->m_fBaseInterfaceValid = fBaseInterfaceValid;
                            IFW32FALSE_EXIT(Entry->m_buffName.Win32Assign(TempBuffer));

                            IFW32FALSE_EXIT(
                                ::SxsAddGuidToGuidSectionGenerationContext(
                                    (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                                    &iid,
                                    Entry,
                                    Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                    ERROR_SXS_DUPLICATE_IID));
                        }

                        break;
                    }

                case eAssemblyFileComClassInterface:
                    {
                        bool fFound = false;
                        CStringBuffer TempBuffer;
                        GUID iid, tlbid, iidBase;
                        ULONG nMethods = 0;
                        SIZE_T cb;
                        bool fNumMethodsValid = false;
                        bool fBaseInterfaceValid = false;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_iid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(iid),
                                &iid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(::SxspGetAttributeValue(0, &s_AttributeName_numMethods, &Data->ElementParsed, fFound, sizeof(TempBuffer), &TempBuffer, cb, NULL, 0));
                        if (fFound)
                        {
                            IFW32FALSE_EXIT(CFusionParser::ParseULONG(nMethods, TempBuffer, TempBuffer.Cch()));
                            fNumMethodsValid = true;
                        }

                        tlbid = GUID_NULL;
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_tlbid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(tlbid),
                                &tlbid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_baseInterface,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(iidBase),
                                &iidBase,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));
                        if (fFound)
                            fBaseInterfaceValid = true;


                        TempBuffer.Clear();
                        IFW32FALSE_EXIT(::SxspGetAttributeValue(0, &s_AttributeName_name, &Data->ElementParsed, fFound, sizeof(TempBuffer), &TempBuffer, cb, NULL, 0));

                        // Do more work if generating an activation context.
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            PIID_ENTRY Entry = NULL;

                            IFALLOCFAILED_EXIT(Entry = new IID_ENTRY);

                            Entry->m_clsid = iid;
                            Entry->m_tlbid = tlbid;
                            Entry->m_iid = iid;
                            Entry->m_iidBase = iidBase;
                            Entry->m_nMethods = nMethods;
                            Entry->m_fNumMethodsValid = fNumMethodsValid;
                            Entry->m_fBaseInterfaceValid = fBaseInterfaceValid;
                            IFW32FALSE_EXIT(Entry->m_buffName.Win32Assign(TempBuffer));

                            IFW32FALSE_EXIT(
                                ::SxsAddGuidToGuidSectionGenerationContext(
                                    (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                                    &iid,
                                    Entry,
                                    Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                    ERROR_SXS_DUPLICATE_IID));
                        }

                        break;
                    }
                }
            }
        }

        Data->ElementParsed.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;

        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);

        IFW32FALSE_EXIT(
            ::SxsGetGuidSectionGenerationContextSectionData(
                GSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));

        Data->GetSectionData.Success = TRUE;
        break;
    }
Exit:
    ;
}

BOOL
SxspComInterfaceRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    switch (Reason)
    {
    default:
        break;

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData = (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PIID_ENTRY Entry = (PIID_ENTRY) CBData->DataContext;

            if (Entry != NULL)
                FUSION_DELETE_SINGLETON(Entry);

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData = (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PIID_ENTRY Entry = (PIID_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION);

            if (Entry != NULL)
            {
                if (Entry->m_buffName.Cch() != 0)
                {
                    CBData->DataSize += ((Entry->m_buffName.Cch() + 1) * sizeof(WCHAR));
                }
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData = (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Info;
            PIID_ENTRY Entry = (PIID_ENTRY) CBData->DataContext;
            PWSTR Cursor;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            Info = (PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION) CBData->Buffer;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION);

            Cursor = (PWSTR) (Info + 1);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION);
            Info->Flags = 0;
            Info->ProxyStubClsid32 = Entry->m_clsid;

            if (Entry->m_fNumMethodsValid)
            {
                Info->Flags |= ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID;
                Info->NumMethods = Entry->m_nMethods;
            }
            else
                Info->NumMethods = 0;

            Info->TypeLibraryId = Entry->m_tlbid;

            if (Entry->m_fBaseInterfaceValid)
            {
                Info->Flags |= ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID;
                Info->BaseInterface = Entry->m_iidBase;
            }
            else
                Info->BaseInterface = GUID_NULL;

            IFW32FALSE_EXIT(
                Entry->m_buffName.Win32CopyIntoBuffer(
                    &Cursor,
                    &BytesLeft,
                    &BytesWritten,
                    Info,
                    &Info->NameOffset,
                    &Info->NameLength));

            CBData->BytesWritten = BytesWritten;
        }
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cresourcestream.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Minimal implementation of IStream over a Windows PE/COFF resource.

Author:

    Jay Krell (a-JayK) May 2000

Revision History:

--*/
#pragma once
#include "CMemoryStream.h"
#include "FusionHandle.h"
#include "sxsp.h"

class CResourceStream :  public CMemoryStream
{
    typedef CMemoryStream Base;
public:
    SMARTTYPEDEF(CResourceStream);
    CResourceStream() { }

    // NOTE the order of type/name is 1) as you might expect 2) consistent with
    // FindResourceEx, 3) INconsistent with FindResource
    // RT_* are actually of type PCWSTR
    BOOL Initialize(PCWSTR file, PCWSTR type, PCWSTR name, WORD language = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    BOOL Initialize(PCWSTR file, PCWSTR type);
    /*
    feel free to add more overloads that take, say
        HMODULE, HRSRC, HGLOBAL
    */

    // Override so that we can get times from the open file...
    HRESULT __stdcall Stat(STATSTG *pstatstg, DWORD grfStatFlag);

    virtual ~CResourceStream() { }

private: // intentionally not implemented
    CResourceStream(const CResourceStream&);
    void operator=(const CResourceStream&);

    BOOL InitializeAlreadyOpen(
        PCWSTR type,
        PCWSTR name,
        WORD   language = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
        );

    CDynamicLinkLibrary m_dll;
    CStringBuffer m_buffFilePath;
};

SMARTTYPE(CResourceStream);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cresourcestream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Minimal implementation of IStream over a Windows PE/COFF resource.

Author:

    Jay Krell (a-JayK) May 2000

Revision History:

--*/
#include "stdinc.h"
#include "CResourceStream.h"

static BOOL CALLBACK
EnumResourcesCallback(
    HMODULE    hModule,  // module handle
    PCWSTR     lpszType, // resource type
    PWSTR      lpszName, // resource name
    LONG_PTR   lParam    // application-defined parameter
    )
{
    PWSTR *pname = reinterpret_cast<PWSTR *>(lParam);
    *pname = lpszName;

    // we would return FALSE here to stop enumerating, but
    // that causes an overall FALSE from the API (undocumented)
    return TRUE;
}

BOOL
CResourceStream::Initialize(
    PCWSTR file,
    PCWSTR type
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PWSTR name = NULL;
    IFW32FALSE_EXIT(m_buffFilePath.Win32Assign(file, (file != NULL) ? ::wcslen(file) : 0));
    IFW32FALSE_EXIT(m_dll.Win32LoadLibrary(file, LOAD_LIBRARY_AS_DATAFILE));
    IFW32FALSE_ORIGINATE_AND_EXIT(::EnumResourceNamesW(m_dll, type, EnumResourcesCallback, reinterpret_cast<LONG_PTR>(&name)));
    IFW32FALSE_EXIT(this->InitializeAlreadyOpen(type, name));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CResourceStream::Initialize(
    PCWSTR file,
    PCWSTR type,
    PCWSTR name,
    WORD   language
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    IFW32FALSE_EXIT(m_buffFilePath.Win32Assign(file, (file != NULL) ? ::wcslen(file) : 0));
    IFW32FALSE_EXIT(m_dll.Win32LoadLibrary(file, LOAD_LIBRARY_AS_DATAFILE));
    IFW32FALSE_EXIT(this->InitializeAlreadyOpen(type, name, language));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CResourceStream::InitializeAlreadyOpen(
    PCWSTR type,
    PCWSTR name,
    WORD   language
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    HRSRC resource;
    HGLOBAL global;
    const BYTE *pointer;
    DWORD size;

    IFW32NULL_EXIT(resource = ::FindResourceExW(m_dll, type, name, language));
    IFW32NULL_EXIT(global = ::LoadResource(m_dll, resource));
    IFW32NULL_EXIT(pointer = reinterpret_cast<const BYTE *>(::LockResource(global)));
    IFW32ZERO_EXIT(size = ::SizeofResource(m_dll, resource));
    IFW32FALSE_EXIT(Base::Initialize(pointer, pointer + size));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

HRESULT
CResourceStream::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);
    WIN32_FILE_ATTRIBUTE_DATA wfad;

    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(*pstatstg));

    PARAMETER_CHECK(((grfStatFlag & ~(STATFLAG_NONAME)) == 0));
    PARAMETER_CHECK(pstatstg != NULL);

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s() does not handle STATFLAG_NONE; returning E_NOTIMPL.\n", __FUNCTION__);
        hr = E_NOTIMPL;
        goto Exit;
    }

    IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileAttributesExW(m_buffFilePath, GetFileExInfoStandard, &wfad));

    pstatstg->pwcsName = NULL;
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = wfad.nFileSizeLow;
    pstatstg->cbSize.HighPart = wfad.nFileSizeHigh;
    pstatstg->mtime = wfad.ftLastWriteTime;
    pstatstg->ctime = wfad.ftCreationTime;
    pstatstg->atime = wfad.ftLastAccessTime;
    pstatstg->grfMode = STGM_READ | STGM_SHARE_DENY_WRITE;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = GUID_NULL;
    pstatstg->grfStateBits = 0;
    pstatstg->reserved = 0;

    hr = NOERROR;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\csecuritymetadata.cpp ===
#include "stdinc.h"

#include "fusionbuffer.h"
#include "fusionhash.h"
#include "csecuritymetadata.h"
#include "strongname.h"
#include "hashfile.h"

typedef CCaseInsensitiveSimpleUnicodeStringTableIter<CFusionByteArray, CFileHashTableHelper> CFileHashTableIter;



CMetaDataFileElement::CMetaDataFileElement()
{
}



BOOL
CMetaDataFileElement::WriteToRegistry( CRegKey & hkThisFileNode ) const
{
    FN_PROLOG_WIN32

    const CFileHashTable &rfileHashTable = *this;
    CFileHashTableIter TableIterator( const_cast<CFileHashTable&>(rfileHashTable) );

    for ( TableIterator.Reset(); TableIterator.More(); TableIterator.Next() )
    {
        const PCWSTR &rcbuffAlgName = TableIterator.GetKey();
        const CFusionByteArray &rbbuffHashData = TableIterator.GetValue();

        IFW32FALSE_EXIT( hkThisFileNode.SetValue(
            rcbuffAlgName,
            REG_BINARY,
            rbbuffHashData.GetArrayPtr(),
            rbbuffHashData.GetSize() ) );
    }

    FN_EPILOG
}




BOOL
CMetaDataFileElement::ReadFromRegistry( CRegKey& hkThisFileNode )
{
    /*
        Here we take a few shortcuts.  We know there is a list of "valid" hash
        alg name strings, so we only query for them in the registry.  If anything
        else is in there, then too bad for them.
    */

    FN_PROLOG_WIN32

    DWORD dwIndex = 0;
    DWORD dwLastError;
	CFusionByteArray baHashValue;

	IFW32FALSE_EXIT(baHashValue.Win32Initialize());	

    while ( true )
    {
        CSmallStringBuffer buffHashAlgName;
        BOOL fNoMoreItems;
        
        IFW32FALSE_EXIT( ::SxspEnumKnownHashTypes( dwIndex++, buffHashAlgName, fNoMoreItems ) );

        //
        // There's no more hash types to be enumerated...
        //
        if (fNoMoreItems)
            break;

        //
        // Get the hash data out of the registry
        //
        IFW32FALSE_EXIT(
            ::FusionpRegQueryBinaryValueEx( 
                FUSIONP_REG_QUERY_BINARY_NO_FAIL_IF_NON_BINARY,
                hkThisFileNode,
                buffHashAlgName,
                baHashValue,
                dwLastError,
                2,
                ERROR_PATH_NOT_FOUND,
                ERROR_FILE_NOT_FOUND));

        if (dwLastError == ERROR_SUCCESS)
            IFW32FALSE_EXIT(this->PutHashData(buffHashAlgName, baHashValue));
    }
    
    FN_EPILOG
}


BOOL
CMetaDataFileElement::Initialize()
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT( CFileHashTable::Initialize() );
    FN_EPILOG
}

BOOL
CMetaDataFileElement::GetHashDataForKind( 
    IN const ALG_ID aid, 
    OUT CFusionByteArray& arrHashData, 
    OUT BOOL &bHadSuchData 
) const
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffAlgName;
    
    IFW32FALSE_EXIT( ::SxspHashStringFromAlg(aid, buffAlgName) );
    IFW32FALSE_EXIT( this->GetHashDataForKind( buffAlgName, arrHashData, bHadSuchData ) );

    FN_EPILOG
}


BOOL
CMetaDataFileElement::GetHashDataForKind( 
    IN const CBaseStringBuffer& buffId, 
    OUT CFusionByteArray& arrHashData, 
    OUT BOOL &bHadSuchData 
) const
{
    FN_PROLOG_WIN32

    CFusionByteArray *pFoundData = NULL;

    IFW32FALSE_EXIT( arrHashData.Win32Reset() );

    IFW32FALSE_EXIT( this->Find( buffId, pFoundData ) );

    if ( pFoundData != NULL )
    {
        IFW32FALSE_EXIT(pFoundData->Win32Clone(arrHashData));
        bHadSuchData = TRUE;
    }

    FN_EPILOG
}


BOOL
CMetaDataFileElement::PutHashData( 
    IN const ALG_ID aid, 
    IN const CFusionByteArray& arrHashData 
)
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffTempAlgId;

    IFW32FALSE_EXIT( ::SxspHashStringFromAlg( aid, buffTempAlgId ) );
    IFW32FALSE_EXIT( this->PutHashData( buffTempAlgId, arrHashData ) );
    
    FN_EPILOG
}

BOOL
CMetaDataFileElement::PutHashData( 
    IN const CBaseStringBuffer& buffId, 
    IN const CFusionByteArray& arrHashData
)
{
    FN_PROLOG_WIN32

    CFusionByteArray *pStoredValue = NULL;
    BOOL bFound = FALSE;

    IFW32FALSE_EXIT( this->FindOrInsertIfNotPresent( 
        buffId, 
        arrHashData, 
        &pStoredValue,
        &bFound ) );

    if ( bFound )
    {
        ASSERT( pStoredValue != NULL );
        IFW32FALSE_EXIT(arrHashData.Win32Clone(*pStoredValue));
    }

    FN_EPILOG
}




BOOL
CSecurityMetaData::GetFileMetaData( 
    const CBaseStringBuffer& buffFileName, 
    const CMetaDataFileElement* &pElementData 
) const 
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT( m_fitFileDataTable.Find(buffFileName, pElementData) );
    FN_EPILOG
}



BOOL
CSecurityMetaData::Initialize()
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(m_cilCodebases.Win32Initialize());
    IFW32FALSE_EXIT(m_baSignerPublicKeyToken.Win32Initialize());
    IFW32FALSE_EXIT(m_baManifestSha1Hash.Win32Initialize());
    IFW32FALSE_EXIT(m_fitFileDataTable.Initialize());
    m_buffShortNameOnDisk.Clear();
    m_buffShortCatalogName.Clear();
    m_buffShortManifestName.Clear();

    FN_EPILOG
}


BOOL
CSecurityMetaData::Initialize(
    const CSecurityMetaData &other
)
{
    FN_PROLOG_WIN32

#define CLONEFUSIONARRAY( src, dst )  IFW32FALSE_EXIT( (src).Win32Clone(  dst ) )
#define CLONESTRING( dst, src ) IFW32FALSE_EXIT( (dst).Win32Assign( (src), (src).Cch() ) )

    IFW32FALSE_EXIT( this->Initialize() );

    CLONEFUSIONARRAY(other.m_cilCodebases, this->m_cilCodebases);
    CLONEFUSIONARRAY(other.m_baSignerPublicKeyToken, this->m_baSignerPublicKeyToken);
    CLONEFUSIONARRAY(other.m_baManifestSha1Hash, this->m_baManifestSha1Hash);

    CLONESTRING(this->m_buffShortNameOnDisk, other.m_buffShortNameOnDisk);
    CLONESTRING(this->m_buffTextualAssemblyIdentity, other.m_buffTextualAssemblyIdentity);
    CLONESTRING(this->m_buffShortManifestName, other.m_buffShortManifestName);
    CLONESTRING(this->m_buffShortCatalogName, other.m_buffShortCatalogName);

    //
    // Copy file information table over
    //
    {
        CFileInformationTableIter Iter(const_cast<CFileInformationTable&>(other.m_fitFileDataTable));

        for (Iter.Reset(); Iter.More(); Iter.Next())
            IFW32FALSE_EXIT( this->m_fitFileDataTable.Insert( Iter.GetKey(), Iter.GetValue() ) );
    }

    FN_EPILOG
}




BOOL 
CSecurityMetaData::AddFileMetaData( 
    const CBaseStringBuffer &rbuffFileName,
    CMetaDataFileElement &rElementData,
    CSecurityMetaData::FileAdditionDisposition dispHowToAdd
)
{
    FN_PROLOG_WIN32

    if (dispHowToAdd == CSecurityMetaData::eFailIfAlreadyExists)
    {
        IFW32FALSE_EXIT(m_fitFileDataTable.Insert(rbuffFileName, rElementData));
    }
    else if (dispHowToAdd == CSecurityMetaData::eReplaceIfAlreadyExists)
    {
        bool fAlreadyExists;
        IFW32FALSE_EXIT_UNLESS(
            m_fitFileDataTable.Insert(rbuffFileName, rElementData),
            (::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS),
            fAlreadyExists);

        if (fAlreadyExists)
        {
            IFW32FALSE_EXIT(m_fitFileDataTable.Remove(rbuffFileName));
            IFW32FALSE_EXIT(m_fitFileDataTable.Insert(rbuffFileName, rElementData));
        }
    }
    else if (dispHowToAdd == CSecurityMetaData::eMergeIfAlreadyExists)
    {
        IFW32FALSE_EXIT(
            m_fitFileDataTable.InsertOrUpdateIf<CSecurityMetaData>(
                rbuffFileName,
                rElementData,
                this,
                &CSecurityMetaData::MergeFileDataElement));
    }

    FN_EPILOG
}

BOOL
CSecurityMetaData::SetSignerPublicKeyTokenBits(
    const CFusionByteArray & rcbuffSignerPublicKeyBits
    )
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT(rcbuffSignerPublicKeyBits.Win32Clone(this->m_baSignerPublicKeyToken));
    FN_EPILOG
}


BOOL
CSecurityMetaData::QuickAddFileHash(
    const CBaseStringBuffer &rcbuffFileName,
    ALG_ID aidHashAlg, 
    const CBaseStringBuffer &rcbuffHashValue
    )
{
    FN_PROLOG_WIN32

    CMetaDataFileElement Element;
    CFusionByteArray baHashBytes;

    //
    // Build the element
    //
    IFW32FALSE_EXIT(Element.Initialize());
    IFW32FALSE_EXIT(::SxspHashStringToBytes(rcbuffHashValue, rcbuffHashValue.Cch(), baHashBytes));
    IFW32FALSE_EXIT(Element.PutHashData(aidHashAlg, baHashBytes));

    //
    // And merge it in
    //

    IFW32FALSE_EXIT(
        this->AddFileMetaData( 
            rcbuffFileName,
            Element,
            eMergeIfAlreadyExists));
    
    FN_EPILOG
}

BOOL
CSecurityMetaData::WritePrimaryAssemblyInfoIntoRegistryKey(
    ULONG         Flags,
    const CRegKey &rhkRegistryNode
    ) const
{
    FN_PROLOG_WIN32

    CRegKey hkFilesKey;
    CRegKey hkCodebases;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS: %s - starting\n",
        __FUNCTION__);

    PARAMETER_CHECK((Flags & ~(SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_INTO_REGISTRY_KEY_FLAG_REFRESH)) == 0);

    IFW32FALSE_EXIT(
        rhkRegistryNode.SetValue(
            CSMD_TOPLEVEL_IDENTITY,
            this->GetTextualIdentity()));

    IFW32FALSE_EXIT( rhkRegistryNode.SetValue(
        CSMD_TOPLEVEL_CATALOG,
        static_cast<DWORD>(1)));

    IFW32FALSE_EXIT( rhkRegistryNode.SetValue(
        CSMD_TOPLEVEL_MANIFESTHASH,
        REG_BINARY,
        this->m_baManifestSha1Hash.GetArrayPtr(),
        this->m_baManifestSha1Hash.GetSize() ) );

    IFW32FALSE_EXIT(
		rhkRegistryNode.OpenOrCreateSubKey(
			hkFilesKey,
			CSMD_TOPLEVEL_FILES,
			KEY_WRITE));

    IFW32FALSE_EXIT(this->WriteFilesIntoKey(hkFilesKey));


    //
    // Write keys into this codebase node
    //
    if ((Flags & SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_INTO_REGISTRY_KEY_FLAG_REFRESH) == 0)
    {
        IFW32FALSE_EXIT(
            rhkRegistryNode.OpenOrCreateSubKey(
                hkCodebases,
                CSMD_TOPLEVEL_CODEBASES,
                KEY_WRITE));

        for (ULONG ulI = 0; ulI < this->m_cilCodebases.GetSize(); ulI++)
        {
            CRegKey hkSingleCodebaseKey;
            const CCodebaseInformation &rcCodebase = m_cilCodebases[ulI];

            // Don't attempt to write blank (Darwin) referenced codebases to the
            // registry.
            if ( rcCodebase.GetReference().Cch() == 0 )
                continue;
                
            IFW32FALSE_EXIT(
                hkCodebases.OpenOrCreateSubKey(
                    hkSingleCodebaseKey,
                    rcCodebase.GetReference(),
                    KEY_WRITE));

            IFW32FALSE_EXIT(rcCodebase.WriteToRegistryKey(hkSingleCodebaseKey));
        }
    }
#if DBG
    else
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - recovery, not writing codebase and codebase prompt\n",
            __FUNCTION__);
    }
#endif
    
    FN_EPILOG
}

BOOL
CSecurityMetaData::WriteSecondaryAssemblyInfoIntoRegistryKey(
    const CRegKey &rhkRegistryNode
    ) const
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(rhkRegistryNode.SetValue(CSMD_TOPLEVEL_SHORTNAME, this->GetInstalledDirShortName()));
    IFW32FALSE_EXIT(rhkRegistryNode.SetValue(CSMD_TOPLEVEL_SHORTCATALOG, this->GetShortCatalogPath()));
    IFW32FALSE_EXIT(rhkRegistryNode.SetValue(CSMD_TOPLEVEL_SHORTMANIFEST, this->GetShortManifestPath()));
    IFW32FALSE_EXIT(
		rhkRegistryNode.SetValue(
			CSMD_TOPLEVEL_PUBLIC_KEY_TOKEN,
			REG_BINARY,
			this->m_baSignerPublicKeyToken.GetArrayPtr(),
			this->m_baSignerPublicKeyToken.GetSize()));

    FN_EPILOG
}

BOOL
CSecurityMetaData::WriteFilesIntoKey(
    CRegKey & rhkFilesKey
    ) const
{
    FN_PROLOG_WIN32

    CFileInformationTableIter FilesIterator( const_cast<CFileInformationTable&>(m_fitFileDataTable) );
    ULONG uliIndex = 0;

    for ( FilesIterator.Reset(); FilesIterator.More(); FilesIterator.Next() )
    {
        const PCWSTR pcwszFileName = FilesIterator.GetKey();
        const CMetaDataFileElement& rcmdfeFileData = FilesIterator.GetValue();
        CRegKey hkFileSubKey;
        CSmallStringBuffer buffKeySubname;

        //
        // The trick here is that you can't simply create the subkey off this node,
        // as it might be "foo\bar\bas\zip.ding".
        //
        IFW32FALSE_EXIT( buffKeySubname.Win32Format( L"%ld", uliIndex++ ) );
        IFW32FALSE_EXIT( rhkFilesKey.OpenOrCreateSubKey(
            hkFileSubKey,
            buffKeySubname,
            KEY_ALL_ACCESS ) );

        //
        // So instead, we set the default value of the key to be the name of the file.
        //
        IFW32FALSE_EXIT( buffKeySubname.Win32Assign( pcwszFileName, lstrlenW(pcwszFileName) ) );
        IFW32FALSE_EXIT( hkFileSubKey.SetValue(
            NULL,
            buffKeySubname ) );
            
        IFW32FALSE_EXIT( rcmdfeFileData.WriteToRegistry( hkFileSubKey ) );
    }

    FN_EPILOG
}



/*
[name of full assembly]
    v : Codebase = [meta-url] <string>
    v : Catalog = 1 <dword>
    v : Shortname = [shortname generated during installation] <string>
    v : ManifestHash = [...] <binary>
    v : PublicKeyToken = [...] <binary>
    k : Files
            k : [Filename]
                    v : SHA1 = [...] <binary>
                    v : MD5 = [...] <binary>
            k : [Filename]
            ...
    k : Codebases
            k : [reference-string]
                    v : PromptString = [...] <string>
                    v : Url = [meta-url] <string>
*/

BOOL
CSecurityMetaData::LoadFromRegistryKey(
    const CRegKey &rhkRegistryNode 
)
{
    FN_PROLOG_WIN32

    CRegKey hkTempStuff;
    DWORD dwHasCatalog;

    IFW32FALSE_EXIT(
        ::FusionpRegQueryDwordValueEx(
            0,
            rhkRegistryNode,
            CSMD_TOPLEVEL_CATALOG,
            &dwHasCatalog,
            0));

    ASSERT(dwHasCatalog != 0);

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkRegistryNode,
            CSMD_TOPLEVEL_IDENTITY,
            this->m_buffTextualAssemblyIdentity));

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkRegistryNode,
            CSMD_TOPLEVEL_SHORTNAME,
            this->m_buffShortNameOnDisk));

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkRegistryNode,
            CSMD_TOPLEVEL_SHORTCATALOG,
            this->m_buffShortCatalogName));

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkRegistryNode,
            CSMD_TOPLEVEL_SHORTMANIFEST,
            this->m_buffShortManifestName));

    IFW32FALSE_EXIT(
        ::FusionpRegQueryBinaryValueEx(
            0,
            rhkRegistryNode,
            CSMD_TOPLEVEL_MANIFESTHASH,
            this->m_baManifestSha1Hash));

    IFW32FALSE_EXIT(
        ::FusionpRegQueryBinaryValueEx(
            0, 
            rhkRegistryNode,
            CSMD_TOPLEVEL_PUBLIC_KEY_TOKEN,
            this->m_baSignerPublicKeyToken));

    IFW32FALSE_EXIT(rhkRegistryNode.OpenSubKey(hkTempStuff, CSMD_TOPLEVEL_CODEBASES, KEY_READ));

    if (hkTempStuff != CRegKey::GetInvalidValue())
    {
        IFW32FALSE_EXIT(this->LoadCodebasesFromKey(hkTempStuff));
        IFW32FALSE_EXIT(hkTempStuff.Win32Close());
    }

    IFW32FALSE_EXIT( rhkRegistryNode.OpenSubKey(hkTempStuff, CSMD_TOPLEVEL_FILES, KEY_READ));

    if (hkTempStuff != CRegKey::GetInvalidValue())
    {
        IFW32FALSE_EXIT(this->LoadFilesFromKey(hkTempStuff));
        IFW32FALSE_EXIT(hkTempStuff.Win32Close());
    }

    FN_EPILOG
}



BOOL
CSecurityMetaData::LoadFilesFromKey(
    CRegKey &hkTopLevelFileKey
    )
{
    FN_PROLOG_WIN32

    DWORD dwIndex = 0;

    while ( true )
    {
        CSmallStringBuffer buffNextKeyName;
        BOOL fNoMoreItems;
        CRegKey hkIterator;
    
        IFW32FALSE_EXIT(hkTopLevelFileKey.EnumKey(
            dwIndex++,
            buffNextKeyName,
            NULL,
            &fNoMoreItems ) );
        
        if ( fNoMoreItems )
        {
            break;
        }

        IFW32FALSE_EXIT( hkTopLevelFileKey.OpenSubKey(
            hkIterator,
            buffNextKeyName,
            KEY_READ ) );

        if ( hkIterator != CRegKey::GetInvalidValue() )
        {
            CMetaDataFileElement SingleFileElement;
            IFW32FALSE_EXIT( SingleFileElement.Initialize() );
            IFW32FALSE_EXIT( SingleFileElement.ReadFromRegistry( hkIterator ) );

            //
            // Now read the name of the file from the default
            //
            IFW32FALSE_EXIT(
                ::FusionpRegQuerySzValueEx(
                    0,
                    hkIterator,
                    NULL, 
                    buffNextKeyName));

            IFW32FALSE_EXIT(this->AddFileMetaData( buffNextKeyName, SingleFileElement));
        }
            
    }

    FN_EPILOG
}

BOOL
CSecurityMetaData::LoadCodebasesFromKey(
    IN CRegKey& hkCodebaseSubkey
    )
{
    FN_PROLOG_WIN32

    DWORD dwMaxKeyLength;
    CStringBuffer buffKeyNameTemp;
    DWORD dwNextIndex = 0;

    //
    // Find out how big the largest subkey string is, then reset our iterator temp
    // to be that big.
    //
    IFW32FALSE_EXIT(hkCodebaseSubkey.LargestSubItemLengths(&dwMaxKeyLength, NULL));
    IFW32FALSE_EXIT(buffKeyNameTemp.Win32ResizeBuffer(dwMaxKeyLength + 1, eDoNotPreserveBufferContents));

    //
    // Codebases are stored as subkeys and then values under them.
    //
    for (;;)
    {
        BOOL fNoMoreItems = FALSE;

        IFW32FALSE_EXIT(
            hkCodebaseSubkey.EnumKey(
                dwNextIndex++,
                buffKeyNameTemp,
                NULL,
                &fNoMoreItems));

        if (fNoMoreItems)
            break;

        CRegKey hkSingleCodebaseKey;

        IFW32FALSE_EXIT(
            hkCodebaseSubkey.OpenSubKey(
                hkSingleCodebaseKey,
                buffKeyNameTemp,
                KEY_READ));

        if (hkSingleCodebaseKey == CRegKey::GetInvalidValue())
            continue;

        CCodebaseInformation Codebase;

        IFW32FALSE_EXIT(Codebase.Initialize());
        IFW32FALSE_EXIT(Codebase.SetReference(buffKeyNameTemp));
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s - read codebase %ls %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffKeyNameTemp),
            static_cast<PCWSTR>(Codebase.GetCodebase())
            );
#endif
        IFW32FALSE_EXIT(Codebase.ReadFromRegistryKey(hkSingleCodebaseKey));
        IFW32FALSE_EXIT(this->m_cilCodebases.Win32Append(Codebase));
    }

    FN_EPILOG
}


BOOL
CMetaDataFileElement::Initialize( 
    const CMetaDataFileElement &other
    )
{
    FN_PROLOG_WIN32

    // The lack of a const iterator here is disturbing, so I have to const_cast
    // the metadatafileelement
    CFileHashTableIter InputTableIter( const_cast<CMetaDataFileElement&>(other) );

    //
    // Why is this not a bool??
    //
    this->ClearNoCallback();
    
    for(InputTableIter.Reset(); InputTableIter.More(); InputTableIter.Next())
    {
        IFW32FALSE_EXIT( this->Insert( InputTableIter.GetKey(), InputTableIter.GetValue() ) );
    }
    
    FN_EPILOG
}


BOOL
CFileInformationTableHelper::UpdateValue(
    const CMetaDataFileElement &vin, 
    CMetaDataFileElement &stored
)
{
    FN_PROLOG_WIN32
    ASSERT( FALSE );
    FN_EPILOG
}


BOOL
CCodebaseInformation::Initialize()
{
    m_Codebase.Clear();
    m_PromptText.Clear();
    m_Reference.Clear();
    return TRUE;
}

BOOL
CCodebaseInformation::Initialize(
    const CCodebaseInformation &other
    )
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(this->SetCodebase(other.GetCodebase()));
    IFW32FALSE_EXIT(this->SetPromptText(other.GetPromptText()));
    IFW32FALSE_EXIT(this->SetReference(other.GetReference()));
    this->m_Type = other.m_Type;

    FN_EPILOG
}

BOOL
CCodebaseInformation::WriteToRegistryKey(
    const CRegKey &rhkCodebaseKey
    ) const
{
    FN_PROLOG_WIN32

    if (m_PromptText.Cch() != 0)
    {
        IFW32FALSE_EXIT(
            rhkCodebaseKey.SetValue(
                CSMD_CODEBASES_PROMPTSTRING,
                this->m_PromptText));
    }

    IFW32FALSE_EXIT(
        rhkCodebaseKey.SetValue(
            CSMD_CODEBASES_URL,
            this->m_Codebase));
    
    FN_EPILOG
}


BOOL
CCodebaseInformation::ReadFromRegistryKey(
    const CRegKey &rhkSingleCodebaseKey
    )
{
    FN_PROLOG_WIN32

    //
    // Missing prompt is OK
    //
    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkSingleCodebaseKey,
            CSMD_CODEBASES_PROMPTSTRING,
            m_PromptText));

    //
    // We don't want to fail just because someone messed up the registry...
    //
    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkSingleCodebaseKey,
            CSMD_CODEBASES_URL,
            m_Codebase));

    FN_EPILOG
}

BOOL
CCodebaseInformationList::FindCodebase(
    const CBaseStringBuffer &rbuffReference,
    CCodebaseInformation *&rpCodebaseInformation
    )
{
    FN_PROLOG_WIN32
    bool fMatches = false;

    SIZE_T i;

    rpCodebaseInformation = NULL;

    for (i=0; i < m_cElements; i++)
    {
        IFW32FALSE_EXIT(m_prgtElements[i].GetReference().Win32Equals(rbuffReference, fMatches, true));
        if (fMatches)
            break;
    }

    if (fMatches)
    {
        INTERNAL_ERROR_CHECK(i < m_cElements);
        rpCodebaseInformation = &m_prgtElements[i];
    }

    FN_EPILOG
}

BOOL
CCodebaseInformationList::RemoveCodebase(
    const CBaseStringBuffer &rbuffReference,
    bool &rfRemoved
    )
{
    FN_PROLOG_WIN32
    bool fMatches = false;
    SIZE_T i;

    rfRemoved = false;

    for (i=0; i < m_cElements; i++)
    {
        IFW32FALSE_EXIT(m_prgtElements[i].GetReference().Win32Equals(rbuffReference, fMatches, true));
        if (fMatches)
        {
            IFW32FALSE_EXIT(this->Win32Remove(i));
            rfRemoved = true;
            break;
        }
    }

    FN_EPILOG
}

BOOL
CSecurityMetaData::Initialize(
    const CBaseStringBuffer &rcbuffTextualIdentity
    )
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT( this->Initialize() );
    ASSERT( FALSE );

    FN_EPILOG
}

BOOL
SxspValidateAllFileHashes(
    IN const CMetaDataFileElement &rmdfeElement,
    IN const CBaseStringBuffer &rbuffFileName,
    OUT HashValidateResult &rResult
    )
{
    FN_PROLOG_WIN32

    DWORD dwIndex = 0;
    CSmallStringBuffer buffHashName;
    BOOL fAllHashesMatch = TRUE;
    HashValidateResult Results;
    CFusionByteArray baFileHashData;
    ALG_ID aid;

    rResult = HashValidate_OtherProblems;

    while ( true && fAllHashesMatch )
    {
        BOOL fTemp;

        IFW32FALSE_EXIT(
            ::SxspEnumKnownHashTypes(
                dwIndex++,
                buffHashName,
                fTemp));

        if (fTemp)
            break;

        IFW32FALSE_EXIT( SxspHashAlgFromString( buffHashName, aid ) );

        //
        // Did the file element have this type of hash data in it?
        //
        IFW32FALSE_EXIT( rmdfeElement.GetHashDataForKind(
            buffHashName,
            baFileHashData,
            fTemp ));

        if ( !fTemp )
        {
            continue;
        }
        
        IFW32FALSE_EXIT( ::SxspVerifyFileHash(
            SVFH_RETRY_LOGIC_SIMPLE,
            rbuffFileName,
            baFileHashData,
            aid,
            Results ) );

        if ( Results != HashValidate_Matches )
        {
            fAllHashesMatch = FALSE;
        }

    }

    if ( fAllHashesMatch )
    {
        rResult = HashValidate_Matches;
    }

    FN_EPILOG
}

BOOL
CSecurityMetaData::RemoveCodebase(
    const CBaseStringBuffer &rbuffReference,
    bool &rfRemoved
    )
{
    return m_cilCodebases.RemoveCodebase(rbuffReference, rfRemoved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cstreamtap.h ===
#pragma once

#include "fusionsha1.h"

class CTeeStreamWithHash : public CTeeStream
{
    CFusionHash m_hCryptHash;
    
    PRIVATIZE_COPY_CONSTRUCTORS(CTeeStreamWithHash);

public:
    SMARTTYPEDEF(CTeeStreamWithHash);

    CTeeStreamWithHash() { }
    virtual ~CTeeStreamWithHash() { }

    //
    // Actual things that do work
    //
    CFusionHash &GetCryptHash() { return m_hCryptHash; }
    BOOL InitCryptHash( ALG_ID aid ) { return m_hCryptHash.Win32Initialize(aid);}

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * pulMove );
    
};

SMARTTYPE(CTeeStreamWithHash);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cstreamtap.cpp ===
#include "stdinc.h"
#include "cstreamtap.h"

STDMETHODIMP
CTeeStreamWithHash::Read(
    void* pv,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = E_FAIL;
    FN_TRACE_HR(hr);

    IFCOMFAILED_EXIT( CTeeStream::Read( pv, cb, pcbRead ) );
    IFW32FALSE_EXIT(this->m_hCryptHash.Win32HashData((PBYTE)pv, *pcbRead));

    hr = S_OK;
Exit:
    return hr;
}

STDMETHODIMP
CTeeStreamWithHash::Seek(
    LARGE_INTEGER,
    DWORD,
    ULARGE_INTEGER*
    )
{
    FN_PROLOG_WIN32
    INTERNAL_ERROR_CHECK2(FALSE, "Don't call Seek on a crypto hash input stream");
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cteestream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CTeeStream.cpp

Abstract:

    See CTeeStream.h.

Author:

    Jay Krell (a-JayK) May 2000

Revision History:

--*/
#include "stdinc.h"
#include "CTeeStream.h"
#include "Sxsp.h"
#include "SxsExceptionHandling.h"

CTeeStream::~CTeeStream()
{
    FN_TRACE();
    CSxsPreserveLastError ple;

    ASSERT(m_cRef == 0);
    m_streamSource.Release();

    if (!m_fileSink.Win32Close())
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(): m_fileSink.Close(%ls) failed: %ld\n",
            __FUNCTION__,
            static_cast<PCWSTR>(m_bufferSinkPath),
            ::FusionpGetLastWin32Error());
    }

    if (FAILED(m_hresult))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SXS.DLL: %s():deleting %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(m_bufferSinkPath));

        if (!::DeleteFileW(m_bufferSinkPath))
        {
            FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s():DeleteFileW(%ls) failed:%ld\n",
                __FUNCTION__,
                static_cast<PCWSTR>(m_bufferSinkPath),
                ::FusionpGetLastWin32Error());
        }
    }

    ple.Restore();
}

VOID
CTeeStream::SetSource(IStream *streamSource)
{
    FN_TRACE();

    m_streamSource = streamSource;
}

BOOL
CTeeStream::SetSink(
    const CImpersonationData &ImpersonationData,
    const CBaseStringBuffer &rbuff,
    DWORD openOrCreate
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD dwBytesWritten = 0;
    DWORD dwBufferSize = 0;
    BOOL fFailForCreateFile = FALSE;

    IFCOMFAILED_EXIT(m_hresult);

    IFW32FALSE_EXIT(m_bufferSinkPath.Win32Assign(rbuff));

    m_ImpersonationData = ImpersonationData;

    {
        CImpersonate impersonate(ImpersonationData);
        IFW32FALSE_EXIT(impersonate.Impersonate());
        IFW32FALSE_EXIT_UNLESS(m_fileSink.Win32CreateFile(m_bufferSinkPath, GENERIC_WRITE, 0/*share*/, openOrCreate),
            ::FusionpGetLastWin32Error() == ERROR_FILE_EXISTS,
            fFailForCreateFile);
        if (fFailForCreateFile)  // the file has existed, have to reopen in order do not break
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SOFT_VERIFY FAILURE : An Existing manifest is tried to be opened for write again, file a BUG!\n");

            IFW32FALSE_EXIT(m_fileSink.Win32CreateFile(m_bufferSinkPath, GENERIC_WRITE, 0/*share*/, CREATE_ALWAYS));
        }


        IFW32FALSE_EXIT(impersonate.Unimpersonate());
    }

    dwBufferSize = static_cast<DWORD>(m_buffer.GetCurrentCb());
    fSuccess = TRUE;
    if (dwBufferSize > 0)
    {
        fSuccess = WriteFile(m_fileSink, m_buffer, dwBufferSize, &dwBytesWritten, NULL/*overlapped*/);
        DWORD dwLastError = fSuccess ? ERROR_SUCCESS : ::FusionpGetLastWin32Error();
        // I'm not entirely sure why we mask the lasterror of the write
        // if it "succeeded" in writing the wrong number of bytes, but
        // such as it is, this is a write fault (The system cannot write
        // to the specified device.)
        if (fSuccess && dwBytesWritten != dwBufferSize)
        {
            dwLastError = ERROR_WRITE_FAULT;
            fSuccess = FALSE;
        }

		m_fBuffer = FALSE;

		if (dwLastError != ERROR_SUCCESS)
			ORIGINATE_WIN32_FAILURE_AND_EXIT(WriteFile, dwLastError);
    }
    m_fBuffer = FALSE;
Exit:
    if (!fSuccess)
    {
        DWORD dwLastError = ::FusionpGetLastWin32Error();
        m_hresult = FusionpHresultFromLastError();
        m_buffer.Clear(true);
        ::FusionpSetLastWin32Error(dwLastError);
    }
    else
        m_buffer.Clear(true);
    return fSuccess;
}

BOOL
CTeeStream::Close()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFCOMFAILED_EXIT(m_hresult);

    IFW32FALSE_EXIT(m_fileSink.Win32Close());

    // ? m_streamSource.Release();

    fSuccess = TRUE;
Exit:
    if (!fSuccess)
        m_hresult = FusionpHresultFromLastError();

    return fSuccess;
}

ULONG __stdcall
CTeeStream::AddRef()
{
    FN_TRACE();
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall
CTeeStream::Release()
{
    FN_TRACE();

    LONG cRef;
    if ((cRef = InterlockedDecrement(&m_cRef)) == 0)
    {
        /*delete this*/;
    }
    return cRef;
}

HRESULT __stdcall
CTeeStream::QueryInterface(
    REFIID  iid,
    PVOID *ppvObj
    )
{
    IUnknown *punk = NULL;
    IUnknown **ppunk = reinterpret_cast<IUnknown **>(ppvObj);
    *ppunk = NULL;
    if (false) { }
#define QI(i) else if (iid == __uuidof(i)) punk = static_cast<i*>(this);
    QI(IUnknown)
    QI(ISequentialStream)
    QI(IStream)
#undef QI
    else return E_NOINTERFACE;
    AddRef();
    *ppunk = punk;
    return NOERROR;
}

HRESULT __stdcall
CTeeStream::Read(PVOID pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;

    FN_TRACE_HR(hr);

    ULONG cbRead;

    if (pcbRead != NULL)
        *pcbRead = 0;

    IFCOMFAILED_ORIGINATE_AND_EXIT(m_hresult);
    IFCOMFAILED_EXIT(m_streamSource->Read(pv, cb, &cbRead));

    if (m_fBuffer)
    {
        IFCOMFAILED_EXIT(m_buffer.Append(reinterpret_cast<const BYTE*>(pv), cbRead));
    }
    else
    {
        DWORD dwBytesWritten = 0;
        BOOL fSuccess = (cbRead == 0) || ::WriteFile(m_fileSink, pv, cbRead, &dwBytesWritten, NULL/*overlapped*/);

        if (!fSuccess)
        {
			TRACE_WIN32_FAILURE_ORIGINATION(WriteFile);

            hr = ::FusionpHresultFromLastError();
            goto Exit;
        }
        else if (dwBytesWritten != cbRead)
        {
            hr = E_FAIL;
            goto Exit;
        }
    }

    if (pcbRead != NULL)
        *pcbRead = cbRead;

    hr = NOERROR;

Exit:
    if (FAILED(hr))
        m_hresult = hr;

    return hr;
}

HRESULT __stdcall
CTeeStream::Write(
    const VOID *pv,
    ULONG cb,
    ULONG *pcbWritten
    )
{
    /*
    since this stream is really only for reading..
    */
    if (pcbWritten != NULL)
        *pcbWritten = 0;

    return E_NOTIMPL;
}

// IStream methods:
HRESULT __stdcall
CTeeStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    /*
    this messes up our ability to easily copy the stream, I think..
    */
    plibNewPosition->QuadPart = 0;
    return E_NOTIMPL;
}

HRESULT __stdcall
CTeeStream::SetSize(ULARGE_INTEGER libNewSize)
{
    /*
    this messes up our ability to easily copy the stream, I think..
    besides that, this is really a read only stream
    */
    return E_NOTIMPL;
}

HRESULT __stdcall
CTeeStream::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
    /*
    Implementing this requires getting the current seek pointer,
    call CopyTo
    seek back
    Read/Write
    seek forward
    because there is no buffer
    */
    pcbRead->QuadPart = 0;
    pcbWritten->QuadPart = 0;
    return E_NOTIMPL;
}

HRESULT __stdcall
CTeeStream::Commit(DWORD grfCommitFlags)
{
    /*
    since this stream is really only for reading..
    */
    return S_OK;
}

HRESULT __stdcall
CTeeStream::Revert()
{
    /*
    since this stream is really only for reading..
    */
    return S_OK;
}

HRESULT __stdcall
CTeeStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    /*
    since this stream is really only for reading..
    */
    return S_OK;
}

HRESULT __stdcall
CTeeStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    /*
    since this stream is really only for reading..
    */
    return S_OK;
}

HRESULT __stdcall
CTeeStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    HRESULT hr = m_streamSource->Stat(pstatstg, grfStatFlag);
    return hr;
}

HRESULT __stdcall
CTeeStream::Clone(IStream **ppIStream)
{
    *ppIStream = NULL;
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\cteestream.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CTeeStream.h

Abstract:

This implementation of IStream is intended for when you want to copy the
stream you are reading to a file.

We read from a stream you specify.
We write to a file you specify.
You can delay specifying the file; we buffer anything read until you specify
a file; we actually needed this delay feature in the first client of
CTeeStream.

The Unix utility tee writes it standard input to its standard output, and
to the specified file (or files?); "tee" as in a fork in a road, or a juncture
in pipes (the input/output kind, analogous to the kind that water flows through..
ascii text is computer water..)

A simple working tee can be found at \\scratch\scratch\a-JayK\t.c

Author:

    Jay Krell (a-JayK) May 2000

Revision History:

--*/
#pragma once

#include "FusionHandle.h"
#include "FusionByteBuffer.h"
#include "SmartRef.h"
#include "Sxsp.h"

class CTeeStream : public IStream
{
public:
    SMARTTYPEDEF(CTeeStream);
    inline CTeeStream() : m_cRef(0), m_fBuffer(TRUE), m_hresult(NOERROR) { }
    virtual ~CTeeStream();

    VOID SetSource(IStream*);

    BOOL SetSink(
        const CImpersonationData &ImpersonationData,
        const CBaseStringBuffer &rbuff,
        DWORD openOrCreate = CREATE_NEW
        );

    BOOL SetSink(const CBaseStringBuffer &rbuff, DWORD openOrCreate = CREATE_NEW)
    {
        return this->SetSink(CImpersonationData(), rbuff, openOrCreate);
    }

    BOOL Close();

    // IUnknown methods:
    virtual ULONG __stdcall AddRef();
    virtual ULONG __stdcall Release();
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    virtual HRESULT __stdcall Read(PVOID pv, ULONG cb, ULONG *pcbRead);
    virtual HRESULT __stdcall Write(const VOID *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    virtual HRESULT __stdcall Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    virtual HRESULT __stdcall SetSize(ULARGE_INTEGER libNewSize);
    virtual HRESULT __stdcall CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    virtual HRESULT __stdcall Commit(DWORD grfCommitFlags);
    virtual HRESULT __stdcall Revert();
    virtual HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual HRESULT __stdcall Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    virtual HRESULT __stdcall Clone(IStream **ppIStream);

protected:
    LONG                m_cRef;
    CFusionFile         m_fileSink;
    CByteBuffer         m_buffer;
    CSmartRef<IStream>  m_streamSource;
    BOOL                m_fBuffer;
    HRESULT             m_hresult;
    CStringBuffer       m_bufferSinkPath;
    CImpersonationData  m_ImpersonationData;

private: // intentionally not implemented
    CTeeStream(const CTeeStream&);
    void operator=(const CTeeStream&);
};

SMARTTYPE(CTeeStream);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\dllredir.h ===
#pragma once

/*-----------------------------------------------------------------------------
Dynamic Link Library Redirection (contributor)

The dllredir contributor is unique in that it does most of the work
for installation.
-----------------------------------------------------------------------------*/

#include "FusionArray.h"
#include "FusionHandle.h"

class CDllRedir
{
public:

    CDllRedir();
    ~CDllRedir();

    VOID ContributorCallback(PACTCTXCTB_CALLBACK_DATA Data);

    BOOL
    BeginInstall(
        PACTCTXCTB_CALLBACK_DATA Data
        );

    BOOL
    InstallManifest(
        DWORD dwManifestOperationFlags,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );

    BOOL
    InstallCatalog(
        DWORD dwManifestOperationFlags,
        const CBaseStringBuffer &SourceManifest,
        const CBaseStringBuffer &DestinationManifest,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );

    BOOL
    InstallFile(
        PACTCTXCTB_CALLBACK_DATA Data,
        const CBaseStringBuffer &FileNameBuffer
        );

    BOOL
    AttemptInstallPolicies(
        const CBaseStringBuffer &m_strTempRootSlash,
        const CBaseStringBuffer &moveDestination,
        const BOOL fReplaceExisting,
        OUT BOOL &fFoundPolicesToInstall        
        );

    BOOL
    EndInstall(
        PACTCTXCTB_CALLBACK_DATA Data
        );

    PSTRING_SECTION_GENERATION_CONTEXT m_SSGenContext;

    // these are files the callback said it would copy itself,
    // we check that this happens before EndAssemblyInstall does the
    // rest of its work
    typedef CFusionArray<CFusionFilePathAndSize> CQueuedFileCopies;
    CQueuedFileCopies m_queuedFileCopies;

    // For partial atomicity, we install everything here, which is
    // like \Winnt\SideBySide\{Guid} and then to commit we enumerate
    // it and move all the directories in it up one level, and delete it
    CStringBuffer m_strTempRootSlash;

    // This must be seperately heap allocated.
    // It should delete itself in Close or Cancel.
    CRunOnceDeleteDirectory *m_pRunOnce;

private:
    CDllRedir(const CDllRedir &);
    void operator =(const CDllRedir &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\csecuritymetadata.h ===
#pragma once

#include "stdinc.h"
#include "fusionbuffer.h"

class CAssemblyRecoveryInfo;

enum SxsWFPResolveCodebase
{
    CODEBASE_RESOLVED_URLHEAD_UNKNOWN,
    CODEBASE_RESOLVED_URLHEAD_FILE,
    CODEBASE_RESOLVED_URLHEAD_HTTP,
    CODEBASE_RESOLVED_URLHEAD_WINSOURCE,
    CODEBASE_RESOLVED_URLHEAD_CDROM
};

BOOL
SxspDetermineCodebaseType(
    IN const CBaseStringBuffer &rcbuffUrlString,
    OUT SxsWFPResolveCodebase &rcbaseType,
    OUT CBaseStringBuffer *pbuffRemainder = NULL
    );

#define CSMD_TOPLEVEL_CODEBASE              (L"Codebase")
#define CSMD_TOPLEVEL_CATALOG               (L"Catalog")
#define CSMD_TOPLEVEL_SHORTNAME             (L"ShortName")
#define CSMD_TOPLEVEL_SHORTCATALOG          (L"ShortCatalogName")
#define CSMD_TOPLEVEL_SHORTMANIFEST         (L"ShortManifestName")
#define CSMD_TOPLEVEL_MANIFESTHASH          (L"ManifestSHA1Hash")
#define CSMD_TOPLEVEL_FILES                 (L"Files")
#define CSMD_TOPLEVEL_CODEBASES             (L"Codebases")
#define CSMD_TOPLEVEL_PUBLIC_KEY_TOKEN      (L"PublicKeyToken")
#define CSMD_CODEBASES_PROMPTSTRING         (L"Prompt")
#define CSMD_CODEBASES_URL                  (L"URL")
#define CSMD_TOPLEVEL_IDENTITY              (L"Identity")

typedef CFusionArray<BYTE> CFusionByteArray;
typedef CFusionArray<CStringBuffer> CFusionStringArray;

class CFileInformationTableHelper;
class CFileHashTableHelper;
class CSecurityMetaData;

class CFileHashTableHelper:
    public CCaseInsensitiveSimpleUnicodeStringTableHelper<CFusionByteArray>
{
public:
    static BOOL InitializeValue(const CFusionByteArray &vin, CFusionByteArray &rvstored) 
    { 
        FN_PROLOG_WIN32
        IFW32FALSE_EXIT(vin.Win32Clone(rvstored));
        FN_EPILOG
    }
    
    static BOOL UpdateValue(const CFusionByteArray &vin, CFusionByteArray &rvstored) { return InitializeValue( vin, rvstored ); }
};

typedef CCaseInsensitiveSimpleUnicodeStringTable<CFusionByteArray, CFileHashTableHelper> CFileHashTable;
typedef CCaseInsensitiveSimpleUnicodeStringTableIter<CFusionByteArray, CFileHashTableHelper> CFileHashTableIter;

//
// Contains metadata about a file element.  This is a collection with the name of
// the file and a list (table) of the SHA1 hash elements.
//
class CMetaDataFileElement : CFileHashTable
{
    CMetaDataFileElement( const CMetaDataFileElement& );
    CMetaDataFileElement& operator=( const CMetaDataFileElement& );

    friend CFileInformationTableHelper;
    friend CSecurityMetaData;

    BOOL ReadFromRegistry( CRegKey& hkThisFileNode );
    BOOL WriteToRegistry( CRegKey& hkThisFileNode ) const;
    
public:
    CMetaDataFileElement();

    BOOL Initialize();
    BOOL Initialize( const CMetaDataFileElement& other );

    BOOL GetHashDataForKind( IN const ALG_ID aid, OUT CFusionByteArray& arrHashData, BOOL &bHadSuchData ) const;
    BOOL GetHashDataForKind( IN const CBaseStringBuffer& buffId, OUT CFusionByteArray& arrHashData, BOOL &bHadSuchData ) const;
    BOOL PutHashData( IN const ALG_ID aid, IN const CFusionByteArray& arrHashData );
    BOOL PutHashData( IN const CBaseStringBuffer& buffId, IN const CFusionByteArray& arrHashData );
};


//
// Now another table, this time of file to metadata mappings
//
class CFileInformationTableHelper : 
    public CCaseInsensitiveSimpleUnicodeStringTableHelper<CMetaDataFileElement>
{
public:
    static BOOL InitializeValue( const CMetaDataFileElement &vin, CMetaDataFileElement &stored ) { return stored.Initialize( vin ); }
    static BOOL UpdateValue( const CMetaDataFileElement &vin, CMetaDataFileElement &stored );
};

typedef CCaseInsensitiveSimpleUnicodeStringTable<CMetaDataFileElement, CFileInformationTableHelper> CFileInformationTable;
typedef CCaseInsensitiveSimpleUnicodeStringTableIter<CMetaDataFileElement, CFileInformationTableHelper> CFileInformationTableIter;

class CCodebaseInformation
{
    friend CSecurityMetaData;

public:
    CCodebaseInformation() : m_Type(CODEBASE_RESOLVED_URLHEAD_UNKNOWN) { }

    BOOL Initialize();
    BOOL Initialize(const CCodebaseInformation &other);

    const CBaseStringBuffer& GetCodebase() const { return m_Codebase; }
    BOOL SetCodebase(PCWSTR psz, SIZE_T cch) { return m_Codebase.Win32Assign(psz, cch); }
    BOOL SetCodebase(const CBaseStringBuffer & rsb) { return m_Codebase.Win32Assign(rsb); }

    const CBaseStringBuffer& GetPromptText() const { return m_PromptText; }
    BOOL SetPromptText(PCWSTR psz, SIZE_T cch) { return m_PromptText.Win32Assign(psz, cch); }
    BOOL SetPromptText(const CBaseStringBuffer & rsb) { return m_PromptText.Win32Assign(rsb); }

    const CBaseStringBuffer &GetReference() const { return m_Reference; }
    BOOL SetReference(const CBaseStringBuffer &r) { return m_Reference.Win32Assign(r); }

    BOOL Win32GetType(SxsWFPResolveCodebase& Type) const
    {
        FN_PROLOG_WIN32
        if (m_Type == CODEBASE_RESOLVED_URLHEAD_UNKNOWN)
        {
            IFW32FALSE_EXIT(::SxspDetermineCodebaseType(this->m_Codebase, this->m_Type));
        }
        Type = m_Type ;
        FN_EPILOG
    }

    BOOL SetType( SxsWFPResolveCodebase Type )
    {
        FN_PROLOG_WIN32
        INTERNAL_ERROR_CHECK(m_Type == CODEBASE_RESOLVED_URLHEAD_UNKNOWN);
        this->m_Type = Type;
        FN_EPILOG
    }

protected:
    BOOL WriteToRegistryKey(const CRegKey &rhkCodebaseKey) const;
    BOOL ReadFromRegistryKey(const CRegKey &rhkCodebaseKey);

    CMediumStringBuffer m_Reference;
    CMediumStringBuffer m_Codebase;
    CMediumStringBuffer m_PromptText;
    mutable SxsWFPResolveCodebase m_Type;

private:
    CCodebaseInformation( const CCodebaseInformation& );
    CCodebaseInformation& operator=( const CCodebaseInformation& );

};

MAKE_CFUSIONARRAY_READY(CCodebaseInformation, Initialize);

class CCodebaseInformationList : public CFusionArray<CCodebaseInformation>
{
public:
    BOOL FindCodebase(const CBaseStringBuffer &rbuffReference, CCodebaseInformation *&rpCodebaseInformation);
    BOOL RemoveCodebase(const CBaseStringBuffer &rbuffReference, bool &rfRemoved);
};


class CSecurityMetaData
{
    CCodebaseInformationList m_cilCodebases;
    CFusionByteArray m_baSignerPublicKeyToken;
    CFileInformationTable m_fitFileDataTable;
    CSmallStringBuffer m_buffShortNameOnDisk;
    CFusionByteArray m_baManifestSha1Hash;
    CStringBuffer m_buffTextualAssemblyIdentity;
    CStringBuffer m_buffShortCatalogName;
    CStringBuffer m_buffShortManifestName;

    CSecurityMetaData( const CSecurityMetaData& );
    CSecurityMetaData& operator=( const CSecurityMetaData& );

    //
    // Cheesy, but we always want to merge the two elements if one already exists.
    //
    BOOL MergeFileDataElement( 
        const CMetaDataFileElement &pNewFileDataElement, 
        const CMetaDataFileElement &rpOldFileDataElement, 
        InsertOrUpdateIfDisposition &Disposition ) { Disposition = eUpdateValue; return TRUE; }

    BOOL LoadCodebasesFromKey( CRegKey& hkCodebasesSubkey );
    BOOL LoadFilesFromKey( CRegKey& hkCodebasesSubkey );

    BOOL WriteFilesIntoKey( CRegKey &rhkFilesKey ) const;

public:

    //
    // Get information about a single item
    //
    enum FileAdditionDisposition {
        eFailIfAlreadyExists,
        eReplaceIfAlreadyExists,
        eMergeIfAlreadyExists
    };
    
    BOOL AddFileMetaData( const CBaseStringBuffer& rcbuffFileName, CMetaDataFileElement &rElementData, FileAdditionDisposition dispHowToAdd = eFailIfAlreadyExists );
    BOOL GetFileMetaData( const CBaseStringBuffer& rcbuffFileName, CMetaDataFileElement const* &rpElementData ) const;

    //
    // Full table that we can iterate over
    //
    const CFileInformationTable& GetFileDataTable() const { return m_fitFileDataTable; }

    //
    // Simplify the addition of a hash value
    //
    BOOL QuickAddFileHash( const CBaseStringBuffer& rcbuffFileName, ALG_ID aidHashAlg, const CBaseStringBuffer& rcbuffHashValue );

    //
    // All your codebases are belong to us.
    //
    const CCodebaseInformationList& GetCodeBaseList() const { return m_cilCodebases; }
protected:
    friend CAssemblyRecoveryInfo;
    CCodebaseInformationList& GetCodeBaseList() { return m_cilCodebases; }
public:

    //
    // Short path data
    //
    BOOL SetShortManifestPath(IN const CBaseStringBuffer &rcbuffShortManifestPath) { return m_buffShortManifestName.Win32Assign(rcbuffShortManifestPath); }
    const CBaseStringBuffer &GetShortManifestPath() const { return m_buffShortManifestName; }

    BOOL SetShortCatalogPath(IN const CBaseStringBuffer &rcbuffShortCatalogPath) { return m_buffShortCatalogName.Win32Assign(rcbuffShortCatalogPath); }
    const CBaseStringBuffer &GetShortCatalogPath() const { return this->m_buffShortCatalogName; };

    BOOL AddCodebase(
        const CBaseStringBuffer &rbuffReference, 
        const CBaseStringBuffer &rbuffCodebase,
        const CBaseStringBuffer &rbuffPrompt );
        
    BOOL RemoveCodebase(const CBaseStringBuffer &rbuffReference, bool &rfRemoved);

    //
    // On-disk shortname?
    //
    BOOL SetInstalledDirShortName(const CBaseStringBuffer &rcbuffShortName) { return this->m_buffShortNameOnDisk.Win32Assign(rcbuffShortName); }
    const CBaseStringBuffer &GetInstalledDirShortName() const { return this->m_buffShortNameOnDisk; }

    //
    // Manifest hash?
    //
    BOOL SetManifestHash( const CFusionByteArray &rcbaManifestHash ) { return rcbaManifestHash.Win32Clone(this->m_baManifestSha1Hash); }
    const CFusionByteArray &GetManifestHash() const { return this->m_baManifestSha1Hash; }

    //
    // Identity
    //
    BOOL SetTextualIdentity( const CBaseStringBuffer &rcbuffIdentity ) { return m_buffTextualAssemblyIdentity.Win32Assign(rcbuffIdentity); }
    const CBaseStringBuffer &GetTextualIdentity() const { return this->m_buffTextualAssemblyIdentity; }

    //
    // Signer public key token
    //
    BOOL SetSignerPublicKeyTokenBits( const CFusionByteArray& rcbuffSignerPublicKeyBits );
    const CFusionByteArray& GetSignerPublicKeyTokenBits() const { return m_baSignerPublicKeyToken; }

    //
    // Dummy - Initialize() is what you -really- want.
    //
    CSecurityMetaData() { }

    BOOL Initialize();
    BOOL Initialize(const CSecurityMetaData &other);
    BOOL Initialize(const CBaseStringBuffer &rcbuffTextualIdentity);
    BOOL LoadFromRegistryKey(const CRegKey &rhkRegistryNode);

#define SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_INTO_REGISTRY_KEY_FLAG_REFRESH (0x00000001)

    BOOL WritePrimaryAssemblyInfoIntoRegistryKey(ULONG Flags, const CRegKey &rhkRegistryNode) const;

    BOOL WriteSecondaryAssemblyInfoIntoRegistryKey(const CRegKey &rhkRegistryNode) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\dllredir.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dllredir.cpp

Abstract:

    Activation context section contributor for the DLL Redirection section.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    Jay Krell (a-JayK) April 2000        install support
--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "FusionEventLog.h"
#include "SxsInstall.h"
#include "DllRedir.h"
#include "CTeeStream.h"
#include "SxsPath.h"
#include "hashfile.h"
#if FUSION_PRECOMPILED_MANIFEST
#define PRECOMPILED_MANIFEST_EXTENSION L".precompiled"
#include "pcmWriterStream.h"
#endif
#include "SxsExceptionHandling.h"
#include "strongname.h"
#include "CSecurityMetaData.h"
#include "cstreamtap.h"

//
// We need to hook this up to the setuplog file functionality.
//
#define SxspInstallPrint FusionpDbgPrint

#define POST_WHISTLER_BETA1 0

//
// This is the default hash algorithm for manifests.  If no algorithm
// is specified with hashalg="foo", then it's SHA1.
//
#define FUSION_DEFAULT_HASH_ALGORITHM (CALG_SHA1)


/*-----------------------------------------------------------------------------*/
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(sourceName);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(loadFrom);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(hash);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(hashalg);

typedef struct _DLL_REDIRECTION_CONTEXT
{
    _DLL_REDIRECTION_CONTEXT() { }
} DLL_REDIRECTION_CONTEXT, *PDLL_REDIRECTION_CONTEXT;

typedef struct _DLL_REDIRECTION_ENTRY
{
    _DLL_REDIRECTION_ENTRY() :
        AssemblyPathIsLoadFrom(false),
        PathIncludesBaseName(false)
        { }
    CStringBuffer AssemblyPathBuffer;
    bool AssemblyPathIsLoadFrom;        // Set to true when a <file name="x" loadfrom="%windir%\system32\"/> is found
    bool PathIncludesBaseName;          // Set to true when a <file name="x" loadfrom="%windir%\x.dll"/> is found
    CStringBuffer FileNameBuffer;
private:
    _DLL_REDIRECTION_ENTRY(const _DLL_REDIRECTION_ENTRY &);
    void operator =(const _DLL_REDIRECTION_ENTRY &);
} DLL_REDIRECTION_ENTRY, *PDLL_REDIRECTION_ENTRY;

/*-----------------------------------------------------------------------------*/

CDllRedir::CDllRedir()
: m_SSGenContext(NULL),
  m_pRunOnce(NULL)
{
}

/*-----------------------------------------------------------------------------*/

CDllRedir::~CDllRedir()
{
}

/*-----------------------------------------------------------------------------*/

VOID
SxspDllRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();
    CDllRedir* pThis = NULL;

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;
        if (Data->Header.ActCtxGenContext == NULL)
        {
            IFALLOCFAILED_EXIT(pThis = new CDllRedir);
            Data->Header.ActCtxGenContext = pThis;
        }

        // fall through
    default:
        pThis = reinterpret_cast<CDllRedir*>(Data->Header.ActCtxGenContext);
        pThis->ContributorCallback(Data);
        if (Data->Header.Reason == ACTCTXCTB_CBREASON_ACTCTXGENENDED)
            FUSION_DELETE_SINGLETON(pThis);
        break;
    }
Exit:
    ;
}

/*-----------------------------------------------------------------------------
This function is called on Win9x if we crash during an install, on the
next login. It deletes temporary files/directories.
-----------------------------------------------------------------------------*/

VOID CALLBACK
SxspRunDllDeleteDirectory(HWND hwnd, HINSTANCE hinst, PSTR lpszCmdLine, int nCmdShow)
{
    FN_TRACE_SMART_TLS();
    CStringBuffer buffer;
    if (buffer.Win32Assign(lpszCmdLine, ::strlen(lpszCmdLine)))
    {
        SxspDeleteDirectory(buffer);
    }
}

/*-----------------------------------------------------------------------------
This function is called on Nt if we crash during an install, on the
next login. It deletes temporary files/directories.
-----------------------------------------------------------------------------*/

VOID CALLBACK
SxspRunDllDeleteDirectoryW(HWND hwnd, HINSTANCE hinst, PWSTR lpszCmdLine, int nCmdShow)
{
    FN_TRACE_SMART_TLS();
    CStringBuffer buffer;
    if (buffer.Win32Assign(lpszCmdLine, ::wcslen(lpszCmdLine)))
    {
        SxspDeleteDirectory(buffer);
    }
}


/*-----------------------------------------------------------------------------
This function sets up state for an upcoming series of installs, installs
of assemblies/files.
-----------------------------------------------------------------------------*/

BOOL
CDllRedir::BeginInstall(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    const DWORD dwManifestOperationFlags = Data->Header.ManifestOperationFlags;
    const bool fTransactional  = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL) == 0;
    CStringBuffer ManifestDirectory;

    if (!fTransactional)
    {
        //
        // m_strTempRootSlash is now actually the real root
        //
        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(m_strTempRootSlash));
        m_strTempRootSlash.RemoveTrailingPathSeparators(); // CreateDirectory doesn't like them

        // create \winnt\WinSxs, must not delete even on failure
        if (::CreateDirectoryW(m_strTempRootSlash, NULL))
        {
            // We don't care if this fails.
            ::SetFileAttributesW(m_strTempRootSlash, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
        }
        else if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
        {
            goto Exit;
        }
    }
    else
    {
        CSmallStringBuffer uidBuffer;

        // Create the directory first, not the RunOnce value, in case the directory
        // already exists; we don't want to put it in the registry, then crash,
        // then end up deleting someone else's stuff.
        //
        // If we crash between creating the directory and setting the RunOnce value,
        // we do leak the directory. Darn. (You should be able to create/open
        // with delete on close/exit, then turn that off once you get far enough,
        // or in our case, never, and it should be applicable recursively..Win32
        // is not yet sufficient.)

        IFW32FALSE_EXIT(::SxspCreateWinSxsTempDirectory(m_strTempRootSlash, NULL, &uidBuffer, NULL));

        // ok, we created the directory, now make a note in the registry to delete it
        // upon login, if we crash

        IFALLOCFAILED_EXIT(m_pRunOnce = new CRunOnceDeleteDirectory);
        IFW32FALSE_EXIT(m_pRunOnce->Initialize(m_strTempRootSlash, &uidBuffer));
    }

    // create winnt\winsxs\manifests
    IFW32FALSE_EXIT(ManifestDirectory.Win32Assign(m_strTempRootSlash, m_strTempRootSlash.Cch()));
    IFW32FALSE_EXIT(ManifestDirectory.Win32AppendPathElement(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));

    if (CreateDirectoryW(ManifestDirectory, NULL))
    {
        // We don't care if this fails.
        SetFileAttributesW(ManifestDirectory, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
    }
    else if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
    {
        goto Exit;
    }

    IFW32FALSE_EXIT(m_strTempRootSlash.Win32Append(L"\\", 1));

    // fix it up..not sure this accomplishes anything..
    // if (!ActCtxGenCtx->m_AssemblyRootDirectoryBuffer.Win32Assign(m_strTempRootSlash))
    // {
    //     goto Exit;
    // }
    fSuccess = TRUE;
Exit:

    if (!fSuccess && fTransactional)
    {
        // rollback, which is not coincidentally identical to EndInstall aborting,
        // except that
        //   here RemoveDirectoryW would be sufficient, there SxspDeleteDirectory is needed
        //   here, we already know there is an error, and cleanup can't produce another
        //     there, they have extra logic to progagage errors
        //     we mask that by preserve LastError since we preserve it ourselves
        //       and ignore the return value
        const DWORD dwLastError = ::FusionpGetLastWin32Error();
        const DWORD dwManifestOperationFlags = Data->Header.ManifestOperationFlags;
        Data->Header.ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        this->EndInstall(Data);
        Data->Header.ManifestOperationFlags = dwManifestOperationFlags; // our caller doesn't like us changing this
        ::FusionpSetLastWin32Error(dwLastError);
    }

    return fSuccess;
}

BOOL
CDllRedir::AttemptInstallPolicies(
    const CBaseStringBuffer &m_strTempRootSlash,
    const CBaseStringBuffer &moveDestination,
    const BOOL fReplaceExisting,
    OUT BOOL &fFoundPolicesToInstall
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CFindFile FindPolicies;
    CStringBuffer sbSearcher;
    CStringBuffer PoliciesRootPath, PoliciesDestinationPath;
    DWORD dwAttributes;
    WIN32_FIND_DATAW FindPolicyData;

    fFoundPolicesToInstall = FALSE;

    // This is %installpath%\policies, turn it into %installpath%\policies\*
    IFW32FALSE_EXIT(PoliciesRootPath.Win32Assign(m_strTempRootSlash));
    IFW32FALSE_EXIT(PoliciesRootPath.Win32AppendPathElement(POLICY_ROOT_DIRECTORY_NAME, NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1));
    IFW32FALSE_EXIT(PoliciesDestinationPath.Win32Assign(moveDestination));
    IFW32FALSE_EXIT(PoliciesDestinationPath.Win32AppendPathElement(POLICY_ROOT_DIRECTORY_NAME, NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1));

    dwAttributes = GetFileAttributesW(PoliciesRootPath);
    if ((dwAttributes == 0xFFFFFFFF) || ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
    {
#if DBG
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_INFO,
            "SXS: %s() - No policies found (%ls not there), not attempting to install\n",
            __FUNCTION__,
            static_cast<PCWSTR>(PoliciesRootPath));
#endif
        fSuccess = TRUE;
        goto Exit;
    }

    fFoundPolicesToInstall = TRUE;

    // Ensure that policies root always exists!
    PoliciesDestinationPath.RemoveTrailingPathSeparators();
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::CreateDirectoryW(PoliciesDestinationPath, NULL) ||
        (::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS));

    IFW32FALSE_EXIT(sbSearcher.Win32Assign(PoliciesRootPath));
    IFW32FALSE_EXIT(sbSearcher.Win32AppendPathElement(L"*", 1));
    IFW32FALSE_EXIT(FindPolicies.Win32FindFirstFile(sbSearcher, &FindPolicyData));

    do
    {
        CStringBuffer sbSourcePolicyPath;
        CStringBuffer sbDestinationPolicyPath;

        if (FusionpIsDotOrDotDot(FindPolicyData.cFileName))
            continue;

        if ((FindPolicyData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            continue;

        // Generate %installtemp%\policies\{thisfoundpolicy}
        IFW32FALSE_EXIT(sbSourcePolicyPath.Win32Assign(PoliciesRootPath));
        IFW32FALSE_EXIT(sbSourcePolicyPath.Win32AppendPathElement(FindPolicyData.cFileName, ::wcslen(FindPolicyData.cFileName)));
        IFW32FALSE_EXIT(sbDestinationPolicyPath.Win32Append(PoliciesDestinationPath));
        IFW32FALSE_EXIT(sbDestinationPolicyPath.Win32AppendPathElement(FindPolicyData.cFileName, ::wcslen(FindPolicyData.cFileName)));

        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INFO,
            "SXS: %s():Found policy in staging area %ls\n\tMoving to %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(sbSourcePolicyPath),
            static_cast<PCWSTR>(sbDestinationPolicyPath));
        
        //
        // Ensure that the target path exists
        //
        IFW32FALSE_ORIGINATE_AND_EXIT(
            ::FusionpCreateDirectories(sbDestinationPolicyPath, sbDestinationPolicyPath.Cch()) ||
            (::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS));

        //
        // Go copy files from the source path that we've consed up to the
        // target path that we've also consed up.  Unfortunately, SxspMoveFilesUnderDir
        // does not actually return the buffers to the state they were in before
        // the call (they leave a trailing slash), so we have to manually use the size
        // thingy above (Left(originalsize)) to avoid this.
        //
        IFW32FALSE_EXIT(SxspMoveFilesUnderDir(
            0,
            sbSourcePolicyPath,
            sbDestinationPolicyPath,
            fReplaceExisting ? MOVEFILE_REPLACE_EXISTING : 0));

    }
    while(::FindNextFileW(FindPolicies, &FindPolicyData));
    
    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(FindNextFileW);
        goto Exit;
    }
    
    ::SetLastError(ERROR_SUCCESS); // clear LastError
    IFW32FALSE_EXIT(FindPolicies.Win32Close());

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CDllRedir::EndInstall(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    /*
    1) Make sure all the queued copies have actually been done.
    2) Enumerate \winnt\winsxs\guid
        renaming each to be in \winnt\winsxs
        upon rename conflicts
            compare all the files in each (by size)
                output debug string if mismatch
                just leave temp if mismatch (will be cleaned up in common path)
                success either way
    3) delete temp; delete runonce value
    */
    // make sure all the queued copies have actually been done    
    const DWORD dwManifestOperationFlags = Data->Header.ManifestOperationFlags;
    const BOOL  fVerify          = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY) == 0;
    const BOOL  fTransactional   = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL) == 0;
    const BOOL  fReplaceExisting = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) != 0;
    const BOOL  fAbort           = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT) != 0;
    BOOL        fPoliciesExist   = FALSE;
    HashValidateResult HashCorrect = HashValidate_OtherProblems;
    CFileStream * pLogFileStream = NULL;

    if (fAbort)
    {
        fSuccess = TRUE;
        goto Exit;
    }


    if (fVerify)
    {

        CQueuedFileCopies::ConstIterator i;
        for (i = m_queuedFileCopies.Begin() ; i != m_queuedFileCopies.End() ; ++i)
        {
            //
            // Only bother to check this if we're not in OS-setup mode.
            //
            if (i->m_bHasHashInfo)
            {
                IFW32FALSE_EXIT(::SxspCheckHashDuringInstall(i->m_bHasHashInfo, i->m_path, i->m_HashString, i->m_HashAlgorithm, HashCorrect));

                if (HashCorrect != HashValidate_Matches)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(FileHashDidNotMatchManifest, ERROR_SXS_FILE_HASH_MISMATCH);
            }
            //
            // Otherwise, let's do the simple thing and just make sure the file made it
            //
            else
            {
                DWORD dwAttributes = ::GetFileAttributesW(i->m_path);
                if (dwAttributes == -1)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS: %s() GetFileAttributesW(%ls)\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(i->m_path));
                    TRACE_WIN32_FAILURE_ORIGINATION(GetFileAttributesW);
                    goto Exit;
                }
            }

        }
    }

    if (fTransactional)
    {
        CFusionDirectoryDifference directoryDifference;
        CFindFile findFile;
        CStringBuffer tempStar; // also used for \winnt\winsxs\guid\foo
        WIN32_FIND_DATAW findData;
        SIZE_T realRootSlashLength = 0; // length of "\winnt\winsxs\"
        SIZE_T tempRootSlashLength = 0; // length of "\winnt\winxsx\guid\"
        CStringBuffer moveDestination; // \winnt\winsxs\foo

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(moveDestination));
        IFW32FALSE_EXIT(moveDestination.Win32EnsureTrailingPathSeparator());
        realRootSlashLength = moveDestination.Cch();

        // move dirs from "\winnt\winsxs\InstallTemp\123456\" to \winnt\winsxs\x86_bar_1000_0409\"
        IFW32FALSE_EXIT(tempStar.Win32Assign(m_strTempRootSlash, m_strTempRootSlash.Cch()));
        tempRootSlashLength = tempStar.Cch();
        IFW32FALSE_EXIT(tempStar.Win32Append(L"*", 1));
        IFW32FALSE_EXIT(findFile.Win32FindFirstFile(tempStar, &findData));

        do
        {
            // skip . and ..
            if (::FusionpIsDotOrDotDot(findData.cFileName))
                continue;

            // there shouldn't be any files, skip them
            if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
                continue;
            // skip manifests dir, do it at the second pass
            if (_wcsicmp(findData.cFileName, MANIFEST_ROOT_DIRECTORY_NAME) == 0) // in-casesensitive compare
                continue;
            if (_wcsicmp(findData.cFileName, POLICY_ROOT_DIRECTORY_NAME) == 0)
                continue;

            moveDestination.Left(realRootSlashLength);
            tempStar.Left(tempRootSlashLength);
            IFW32FALSE_EXIT(moveDestination.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
            IFW32FALSE_EXIT(tempStar.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
            //
            // replace existing doesn't work on directories, but we'll give it a shot anyway,
            // maybe it'll work in some future better version of Windows..
            // and of course, the error when you try this is "access denied" which is
            // somewhat unexpected, you have appro access to delete the directory maybe,
            // but not replace it.. the ReplaceFile api is also explicitly described
            // as for files only
            //
            IFW32FALSE_EXIT(::SxspInstallMoveFileExW(tempStar, moveDestination, fReplaceExisting? MOVEFILE_REPLACE_EXISTING : 0, TRUE));

        } while (::FindNextFileW(findFile, &findData));
        
        if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): FindNextFile() failed:%ld\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }
        
        if (!findFile.Win32Close())
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): FindClose() failed:%ld\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }

        // Honk off and install polices - fFoundPolicesToInstall will be true if we really found any.
        moveDestination.Left(realRootSlashLength);
        IFW32FALSE_EXIT(this->AttemptInstallPolicies(m_strTempRootSlash, moveDestination, fReplaceExisting, fPoliciesExist));

        // move manifest file from "\winnt\winsxs\InstallTemp\123456\manifests\x86_cards.2000_0409.manifest" to
        // \winnt\winsxs\manifests\x86_bar_1000_0406.manifst"
        moveDestination.Left(realRootSlashLength);
        IFW32FALSE_EXIT(moveDestination.Win32Append(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));
        IFW32FALSE_EXIT(moveDestination.Win32EnsureTrailingPathSeparator()); //"winnt\winsxs\manifests\"
        realRootSlashLength = moveDestination.Cch();

        tempStar.Left(tempRootSlashLength);
        IFW32FALSE_EXIT(tempStar.Win32Append(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));
        IFW32FALSE_EXIT(tempStar.Win32EnsureTrailingPathSeparator()); //"winnt\winsxs\InstallTemp\123456\manifests\"
        tempRootSlashLength = tempStar.Cch();

        IFW32FALSE_EXIT(tempStar.Win32Append(L"*", 1));
        IFW32FALSE_EXIT(findFile.Win32FindFirstFile(tempStar, &findData));
        do
        {
            // skip . and ..
            if (FusionpIsDotOrDotDot(findData.cFileName))
                continue;
            // there shouldn't be any directories, skip them
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                continue;

            moveDestination.Left(realRootSlashLength);
            tempStar.Left(tempRootSlashLength);

            IFW32FALSE_EXIT(moveDestination.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
            IFW32FALSE_EXIT(tempStar.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
            IFW32FALSE_EXIT(::SxspInstallMoveFileExW(tempStar, moveDestination, fReplaceExisting ? MOVEFILE_REPLACE_EXISTING : 0, TRUE));
        } while (::FindNextFileW(findFile, &findData));
        
        if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): FindNextFile() failed:%ld\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }
        
        if (!findFile.Win32Close())
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): FindClose() failed:%ld\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:

    if (pLogFileStream)
    {
        pLogFileStream->Close(); // ignore the error
        FUSION_DELETE_SINGLETON(pLogFileStream);
    }

    if (fTransactional)
    {
        DWORD dwLastError = ERROR_SUCCESS;
        ASSERT(m_pRunOnce != NULL);
        if (!fSuccess)
            dwLastError = ::FusionpGetLastWin32Error();

        if (!m_strTempRootSlash.IsEmpty())
        {
            if (!SxspDeleteDirectory(m_strTempRootSlash))
            {
                FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %s(): SxspDeleteDirectory(%ls) failed:%ld\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(m_strTempRootSlash),
                    ::FusionpGetLastWin32Error());
                if (fSuccess)
                {
                    fSuccess = FALSE;
                    dwLastError = ::FusionpGetLastWin32Error();
                }
                // Close instead of Cancel so the delete wil be tried again upon reboot
                if (m_pRunOnce != NULL && !m_pRunOnce->Close() && fSuccess)
                {
                    dwLastError = ::FusionpGetLastWin32Error();
                    fSuccess = FALSE;
                }
            }
        }
        if (m_pRunOnce != NULL && !m_pRunOnce->Cancel() && fSuccess)
        {
            dwLastError = ::FusionpGetLastWin32Error();
            fSuccess = FALSE;
        }

        if (!fSuccess)
            ::FusionpSetLastWin32Error(dwLastError);
    }
    m_pRunOnce = NULL;
    return fSuccess;
}

//
// we have to do this in three places, so it is worth the reuse
//
class CMungeFileReadOnlynessAroundReplacement
{
public:
#if POST_WHISTLER_BETA1
    CMungeFileReadOnlynessAroundReplacement()
        : m_ReplaceExisting(false), m_FileAttributes(SXSP_INVALID_FILE_ATTRIBUTES)
    {
    }

    BOOL Initialize(
        const CBaseStringBuffer &rbuff,
        BOOL   ReplaceExisting
        )
    {
        BOOL Success = FALSE;
        FN_TRACE_WIN32(Success);
        IFW32FALSE_EXIT(m_FileName.Win32Assign(rbuff));
        m_ReplaceExisting = ReplaceExisting;
        // deliberately ignore failure from GetFileAttributes
        // 1) It's ok if the file doesn't exist
        // 2) If there's a more serious problem, we'll hit it again immediately, but
        //    that does lead to nested retry.
        m_FileAttributes = (ReplaceExisting ? ::GetFileAttributesW(FileName) : SXSP_INVALID_FILE_ATTRIBUTES);
        if (m_FileAttributes != SXSP_INVALID_FILE_ATTRIBUTES)
            ::SetFileAttributesW(FileName, 0);

        Success = TRUE;
    Exit:
        return Success;
    }

    ~CMungeFileReadOnlynessAroundReplacement()
    {
        if (m_ReplaceExisting && m_FileAttributes != SXSP_INVALID_FILE_ATTRIBUTES)
        {
            // error deliberately ignored
            SXSP_PRESERVE_LAST_ERROR(::SetFileAttributesW(m_FileName, m_FileAttributes));
        }
    }

    BOOL                 m_ReplaceExisting;
    CUnicodeStringBuffer m_FileName;
    DWORD                m_FileAttributes;
#else // POST_WHISTLER_BETA1
    // simpler code for beta1
    BOOL Initialize(
        PCWSTR FileName,
        BOOL   /*ReplaceExisting*/
        )
    {
        // error deliberately ignored
        ::SetFileAttributesW(FileName, 0);
        return TRUE;
    }
#endif // POST_WHISTLER_BETA1
};


BOOL
CDllRedir::InstallCatalog(
    DWORD dwManifestOperationFlags,
    const CBaseStringBuffer &ManifestSourceBuffer,
    const CBaseStringBuffer &ManifestDestinationBuffer,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    BOOL                                    fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    bool fHasCatalog = false;
    CMungeFileReadOnlynessAroundReplacement MungeCatalogAttributes;
    CStringBuffer                           CatalogSourceBuffer;
    CStringBuffer                           CatalogDestinationBuffer;
    ManifestValidationResult                ManifestStatus = ManifestValidate_Unknown;
    BOOL                                    fAreWeInOSSetupMode = FALSE;

    //
    // Determine the possible source and destination of the catalog file. This
    // needs to be done, even if we're not explicitly looking for a catalog, since
    // our heuristic still needs to check to see if there is one available.
    //
    IFW32FALSE_EXIT(CatalogDestinationBuffer.Win32Assign(ManifestDestinationBuffer));
    IFW32FALSE_EXIT(CatalogDestinationBuffer.Win32ChangePathExtension(FILE_EXTENSION_CATALOG, FILE_EXTENSION_CATALOG_CCH, eAddIfNoExtension));

    IFW32FALSE_EXIT(CatalogSourceBuffer.Win32Assign(ManifestSourceBuffer));
    IFW32FALSE_EXIT(CatalogSourceBuffer.Win32ChangePathExtension(FILE_EXTENSION_CATALOG, FILE_EXTENSION_CATALOG_CCH, eAddIfNoExtension));

    //
    // Note: We only attempt to deal with catalogs when there is installation info.
    // Even if there was no install data, we don't bother looking to see if there's
    // a catalog.  Catalogs imply signatures and public key information, and require
    // a codebase to be reinstalled from.  If you didn't provide such to the installer,
    // shame on you.
    //
    if (AssemblyContext->InstallationInfo != NULL)
    {
        PSXS_INSTALL_SOURCE_INFO pInfo = static_cast<PSXS_INSTALL_SOURCE_INFO>(AssemblyContext->InstallationInfo);

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s() found installation info at %p\n"
            "   pInfo->dwFlags = 0x%08lx\n",
            __FUNCTION__, pInfo, (pInfo != NULL) ? pInfo->dwFlags : 0);

        //
        // Do we explicitly have a catalog?
        //
        fHasCatalog = ((pInfo->dwFlags & SXSINSTALLSOURCE_HAS_CATALOG) != 0);
        if (fHasCatalog)
        {
            FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INSTALLATION,
                "SXS.DLL: Using catalog because install source says that they're supposed to be there.\n");
        }

        //
        // Well, if we didn't, then we still should look.. maybe they forgot the flag.
        // But, only look if they don't mind us checking.
        //
        if (!(pInfo->dwFlags & SXSINSTALLSOURCE_DONT_DETECT_CATALOG) && !fHasCatalog)
            IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE, CatalogSourceBuffer, fHasCatalog));

        pInfo->dwFlags |= (fHasCatalog ? SXSINSTALLSOURCE_HAS_CATALOG : 0);

    }


    //
    // We officially no longer allow assemblies without catalogs in them.
    //
//
// BUGBUG NTRAID#273193
//
// This must be turned back on for beta2 or beta3!
// - Updated 1/15/2001 (jonwis) : Turning on in winfuse private branch

    if (!fHasCatalog)
    {
        ::FusionpLogError(
            MSG_SXS_PUBLIC_ASSEMBLY_REQUIRES_CATALOG_AND_SIGNATURE,
            CEventLogString(ManifestSourceBuffer));
        ::FusionpSetLastWin32Error(ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING);
        goto Exit;
    }

    //
    // If there's a catalog next to the manifest file, we should copy it over as well.
    // If the flag is set, and there's no catalog present, then something bad happened
    // at some point along the way - fail the installation!
    //
    if (fHasCatalog)
    {
        BOOL bInstallCatalogSuccess = FALSE;

        //
        // Copyfile it over.  We do this rather than streaming because we don't
        // care about the contents of the catalog, it's binary.
        //
        IFW32FALSE_EXIT(MungeCatalogAttributes.Initialize(CatalogDestinationBuffer, TRUE));
        if (dwManifestOperationFlags &  MANIFEST_OPERATION_INSTALL_FLAG_MOVE)
        {
            bInstallCatalogSuccess = ::SxspInstallDecompressAndMoveFileExW(
                    CatalogSourceBuffer,
                    CatalogDestinationBuffer, 
                    (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) ? MOVEFILE_REPLACE_EXISTING : 0);
        }
        else
        {
            bInstallCatalogSuccess =
                ::SxspInstallDecompressOrCopyFileW(                
                    CatalogSourceBuffer,
                    CatalogDestinationBuffer, 
                    (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) ? FALSE : TRUE);     // bFailIfExist == FALSE
        }
        if (!bInstallCatalogSuccess)
        {
#if DBG
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL:%s Failed copying catalog file from [%ls] to [%ls] - Error was 0x%08x\n",
                __FUNCTION__,
                static_cast<PCWSTR>(CatalogSourceBuffer),
                static_cast<PCWSTR>(CatalogDestinationBuffer),
                ::FusionpGetLastWin32Error());
#endif
            TRACE_WIN32_FAILURE_ORIGINATION(SxspInstallDecompressOrCopyFileW);
            goto Exit;
        }
    }

    //
    // If we're in OS-setup mode, then we don't bother to validate this manifest against
    // its catalog, instead assuming that the catalogs coming off the CD/installpoint
    // are golden.  This does not protect us against malicious IT managers, warezer groups
    // putting bad bits in their distros, etc.  But who cares, right?
    //
    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode));
    if (!fAreWeInOSSetupMode && fHasCatalog)
    {
        ULONG ulCatalogKeyLength;
        CPublicKeyInformation CatalogSignerInfo;
        CSmallStringBuffer sbStrongNameString;
        CSmallStringBuffer sbReferencePublicKeyToken;
        BOOL bHasPublicKeyToken = FALSE;
        BOOL bStrongNameMatches = FALSE;
        CAssemblyReference OurReference;

        IFW32FALSE_EXIT(OurReference.Initialize(AssemblyContext->AssemblyIdentity));
        IFW32FALSE_EXIT(OurReference.GetPublicKeyToken(&sbReferencePublicKeyToken, bHasPublicKeyToken));

        //
        // Validate the catalog and manifest, but don't check the strong name
        // yet - the file name isn't valid at this point.
        //
        IFW32FALSE_EXIT(::SxspValidateManifestAgainstCatalog(
            ManifestSourceBuffer,
            CatalogDestinationBuffer,
            ManifestStatus,
            MANIFESTVALIDATE_MODE_NO_STRONGNAME));

        //
        // If there's no catalog, or there is a catalog but it's broken, then
        // we need to complain and exit.
        //
        if (ManifestStatus != ManifestValidate_IsIntact)
        {
#if DBG
            DWORD dwFileAttributes;

            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                    "SXS: ManifestStatus: %s (%lu)\n",
                    SxspManifestValidationResultToString(ManifestStatus),
                    static_cast<ULONG>(ManifestStatus));

            dwFileAttributes = GetFileAttributesW(ManifestSourceBuffer);
            if (dwFileAttributes == INVALID_FILE_ATTRIBUTES)
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                        "SXS: GetFileAttributes(%ls):0x%lx, error:%lu\n",
                        static_cast<PCWSTR>(ManifestSourceBuffer),
                        dwFileAttributes,
                        FusionpGetLastWin32Error());

            dwFileAttributes = GetFileAttributesW(CatalogDestinationBuffer);
            if (dwFileAttributes == INVALID_FILE_ATTRIBUTES)
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                        "SXS: GetFileAttribtes(%ls):0x%lx, error:%lu\n",
                        static_cast<PCWSTR>(CatalogDestinationBuffer),
                        dwFileAttributes,
                        FusionpGetLastWin32Error());
#endif
            ::FusionpLogError(
                MSG_SXS_MANIFEST_CATALOG_VERIFY_FAILURE,
                CEventLogString(ManifestDestinationBuffer));

            ::FusionpSetLastWin32Error(ERROR_SXS_PROTECTION_CATALOG_NOT_VALID);
            goto Exit;
        }

        //
        // Get some useful information about the catalog's signer - opens the catalog
        // on the installation source.
        //
        IFW32FALSE_EXIT(CatalogSignerInfo.Initialize(CatalogDestinationBuffer));
        IFW32FALSE_EXIT(CatalogSignerInfo.GetPublicKeyBitLength(ulCatalogKeyLength));

        //
        // Minimally, we need some number of bits in the signing catalog's public key
        //
        if ((ulCatalogKeyLength < SXS_MINIMAL_SIGNING_KEY_LENGTH) || !bHasPublicKeyToken)
        {
            CSmallStringBuffer sbSignerName;

            IFW32FALSE_EXIT(CatalogSignerInfo.GetSignerNiceName(sbSignerName));

            ::FusionpLogError(
                MSG_SXS_CATALOG_SIGNER_KEY_TOO_SHORT,
                CEventLogString(sbSignerName),
                CEventLogString(CatalogSourceBuffer));

            goto Exit;
        }

        // Now compare the public key tokens
        IFW32FALSE_EXIT(CatalogSignerInfo.DoesStrongNameMatchSigner(sbReferencePublicKeyToken, bStrongNameMatches));

        if (!bStrongNameMatches)
        {
            CSmallStringBuffer sbSignerName;
            IFW32FALSE_EXIT(CatalogSignerInfo.GetSignerNiceName(sbSignerName));

            ::FusionpLogError(
                MSG_SXS_PUBLIC_KEY_TOKEN_AND_CATALOG_MISMATCH,
                CEventLogString(CatalogSourceBuffer),
                CEventLogString(sbSignerName),
                CEventLogString(sbReferencePublicKeyToken));

            goto Exit;
        }
    }


    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
CDllRedir::InstallManifest(
    DWORD dwManifestOperationFlags,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    BOOL  fVerify;
    BOOL  fTransactional;
    BOOL  fReplaceExisting;
    DWORD OpenOrCreateManifestDestination;
    CTeeStream* TeeStreamForManifestInstall = NULL;
    CFullPathSplitPointers SplitManifestSource;
    CMungeFileReadOnlynessAroundReplacement MungeManifestAttributes;
    CAssemblyReference TempAssemblyReference;

    //
    // Windows Setup is restartable, so we must be too when it calls us.
    //   ReplaceExisting is probably enough to use CREATE_ALWAYS, but lets be safer for
    //   now and check both weakenings.
    //
    CStringBuffer ManifestSourceBuffer;
    CStringBuffer ManifestDestinationBuffer;
    CStringBuffer ManifestFileNameBuffer;
    CStringBuffer CatalogSourceBuffer;
    CStringBuffer CatalogDestinationBuffer;
    fVerify          = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY) == 0;
    fTransactional   = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL) == 0;
    fReplaceExisting = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) != 0;
    OpenOrCreateManifestDestination = (fReplaceExisting && !fTransactional) ? CREATE_ALWAYS : CREATE_NEW;

    TeeStreamForManifestInstall = reinterpret_cast<CTeeStream*>(AssemblyContext->TeeStreamForManifestInstall);

#if FUSION_PRECOMPILED_MANIFEST
    CMungeFileReadOnlynessAroundReplacement MungePrecompiledManifestAttributes;
    CPrecompiledManifestWriterStream * pcmWriterStream = reinterpret_cast<CPrecompiledManifestWriterStream *>(AssemblyContext->pcmWriterStream);
#endif

    PARAMETER_CHECK(AssemblyContext != NULL);
    INTERNAL_ERROR_CHECK(AssemblyContext->TeeStreamForManifestInstall != NULL);

    // Get "\windir\winsxs\install\guid\manifests" or Get "\windir\winsxs\install\guid\policies".
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH, // Flags
            (AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_SYSTEM_POLICY_INSTALLATION)? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
            m_strTempRootSlash,
            m_strTempRootSlash.Cch(),
            AssemblyContext->AssemblyIdentity,
            ManifestDestinationBuffer));

    // remove the trailing slash because CreateDirectory maybe sometimes doesn't like it
    ManifestDestinationBuffer.RemoveTrailingPathSeparators();
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::CreateDirectoryW(ManifestDestinationBuffer, NULL)
        || ::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS);

    IFW32FALSE_EXIT(ManifestSourceBuffer.Win32Assign(AssemblyContext->ManifestPath, AssemblyContext->ManifestPathCch));

    // get "x86_bar_1000_0409"
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT
                | ((AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_SYSTEM_POLICY_INSTALLATION) ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0),
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            m_strTempRootSlash,
            m_strTempRootSlash.Cch(),
            AssemblyContext->AssemblyIdentity,
            ManifestFileNameBuffer));

    // create policies\x86_policy.6.0.Microsoft.windows.cards_pulicKeyToken_en-us_1223423423
    IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32AppendPathElement(ManifestFileNameBuffer));
    if (AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_SYSTEM_POLICY_INSTALLATION)
    {
        PCWSTR pszVersion = NULL;
        SIZE_T VersionCch = 0;
        // for policy installation, create a subdir under Policies
        IFW32FALSE_ORIGINATE_AND_EXIT(
            ::CreateDirectoryW(ManifestDestinationBuffer, NULL)
            || ::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS);

        //generate policy file name, like 1.0.0.0.policy
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                AssemblyContext->AssemblyIdentity,
                &s_IdentityAttribute_version,
                &pszVersion,
                &VersionCch));

        INTERNAL_ERROR_CHECK(VersionCch != 0);
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32Append(pszVersion, VersionCch));
        // .policy
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32Append(ASSEMBLY_POLICY_FILE_NAME_SUFFIX, NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX) - 1));
    }
    else
    {
        // .manifest
        ManifestDestinationBuffer.RemoveTrailingPathSeparators();
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32Append(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX, NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX) - 1));
    }
    IFW32FALSE_EXIT(MungeManifestAttributes.Initialize(ManifestDestinationBuffer, fReplaceExisting));

    //
    // Try installing the catalog that goes with this assembly
    //
    IFW32FALSE_EXIT(
        this->InstallCatalog(
            dwManifestOperationFlags,
            ManifestSourceBuffer,
            ManifestDestinationBuffer,
            AssemblyContext));

    FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS.DLL: Sinking manifest to \"%S\"\n", static_cast<PCWSTR>(ManifestDestinationBuffer));

    //
    // Set the manifest sink after trying to install the catalog, so that if there is no
    // catalog, we do not install the manifest (we don't always have InstallTemp to rely on).
    //
    IFW32FALSE_EXIT(TeeStreamForManifestInstall->SetSink(ManifestDestinationBuffer, OpenOrCreateManifestDestination));

#if FUSION_PRECOMPILED_MANIFEST
    IFW32FALSE_EXIT(
        ManifestDestinationBuffer.Win32ChangePathExtension(
            PRECOMPILED_MANIFEST_EXTENSION,
            NUMBER_OF(PRECOMPILED_MANIFEST_EXTENSION) - 1,
            NULL,
            eErrorIfNoExtension));
    IFW32FALSE_EXIT(MungePrecompiledManifestAttributes.Initialize(ManifestDestinationBuffer, fReplaceExisting));
    IFW32FALSE_EXIT(pcmWriterStream->SetSink(ManifestDestinationBuffer, OpenOrCreateManifestDestination));
#endif

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CDllRedir::InstallFile(
    PACTCTXCTB_CALLBACK_DATA Data,
    const CBaseStringBuffer &FileNameBuffer
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    CStringBuffer SourceBuffer;
    CStringBuffer DestinationBuffer;
    SIZE_T DirectoryLength = 0;
    CStringBuffer SourceFileNameBuffer;
    ULONGLONG SourceFileSize = 0;
    bool fFound = false;
    SIZE_T cb;
    ULONG Disposition = (Data->Header.ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_MOVE) ? SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_MOVE : SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_COPY;
    const DWORD dwManifestOperationFlags = Data->Header.ManifestOperationFlags;
    const BOOL  fVerify          = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY) == 0;
    const BOOL  fTransactional   = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL) == 0;
    const BOOL  fReplaceExisting = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) != 0;

    ALG_ID              HashAlgId = FUSION_DEFAULT_HASH_ALGORITHM;
    bool                fHasHashData = false;
    bool                fHasHashAlgName = false;
    HashValidateResult  HashCorrect = HashValidate_OtherProblems;
    CStringBuffer       HashDataString;
    CSmallStringBuffer  HashAlgNiceName;

    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            0, // Flags
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            m_strTempRootSlash,
            m_strTempRootSlash.Cch(),
            Data->ElementParsed.AssemblyContext->AssemblyIdentity,
            DestinationBuffer));

    IFW32FALSE_EXIT(DestinationBuffer.Win32Append(static_cast<PCWSTR>(FileNameBuffer), FileNameBuffer.Cch()));

    DirectoryLength = 1 + DestinationBuffer.CchWithoutLastPathElement();

    // Take the manifest path, trim back to the directory name and add the file...
    IFW32FALSE_EXIT(SourceBuffer.Win32Assign(Data->ElementParsed.AssemblyContext->ManifestPath, Data->ElementParsed.AssemblyContext->ManifestPathCch));

    SourceBuffer.RemoveLastPathElement();

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_sourceName,
            &Data->ElementParsed,
            fFound,
            sizeof(SourceFileNameBuffer),
            &SourceFileNameBuffer,
            cb,
            NULL,
            0));

    PCWSTR SourceFileName;

    if (fFound)
        SourceFileName = SourceFileNameBuffer;
    else
        SourceFileName = FileNameBuffer;

    // Extract information about the hashing stuff that's included on this node
    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_hash,
            &Data->ElementParsed,
            fHasHashData,
            sizeof(HashDataString),
            &HashDataString,
            cb,
            NULL,
            0));

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_hashalg,
            &Data->ElementParsed,
            fHasHashAlgName,
            sizeof(HashAlgNiceName),
            &HashAlgNiceName,
            cb,
            NULL,
            0));

    //
    // Neat.  Find out what the hash algorithm was.
    //
    if (fHasHashAlgName)
    {
        if (!::SxspHashAlgFromString(HashAlgNiceName, HashAlgId))
        {
            ::FusionpLogError(
                MSG_SXS_INVALID_FILE_HASH_FROM_COPY_CALLBACK,
                CEventLogString(HashAlgNiceName));
            goto Exit;
        }
    }
    else
    {
        HashAlgId = FUSION_DEFAULT_HASH_ALGORITHM;
    }

    IFW32FALSE_EXIT(SourceBuffer.Win32AppendPathElement(SourceFileName, (SourceFileName != NULL) ? ::wcslen(SourceFileName) : 0));
    IFW32FALSE_EXIT(::SxspGetFileSize(SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE, SourceBuffer, SourceFileSize));

    //
    // And add the file's metadata to the currently running metadata blob
    //
    {
        CSecurityMetaData *pMetaDataObject = reinterpret_cast<CSecurityMetaData*>(Data->Header.InstallationContext->SecurityMetaData);

        if ( pMetaDataObject != NULL )
        {
            CSmallStringBuffer sbuffFileShortName;
            IFW32FALSE_EXIT(sbuffFileShortName.Win32Assign(SourceFileName, ::wcslen(SourceFileName)));
            IFW32FALSE_EXIT(pMetaDataObject->QuickAddFileHash( 
                sbuffFileShortName, 
                HashAlgId, 
                HashDataString));
        }
    }

    if ((Data->Header.InstallationContext != NULL) &&
        (Data->Header.InstallationContext->Callback != NULL))
    {
        Disposition = 0;
        SXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters = {sizeof(parameters)};
        parameters.pvContext = Data->Header.InstallationContext->Context;
        parameters.dwFileFlags = 0;
        parameters.pAlternateSource = NULL; // future IStream
        parameters.pSourceFile = SourceBuffer;
        parameters.pDestinationFile = DestinationBuffer;
        parameters.nFileSize = SourceFileSize;
        parameters.nDisposition = 0;
        IFW32FALSE_EXIT((*Data->Header.InstallationContext->Callback)(&parameters));
        Disposition = parameters.nDisposition;
    }

    switch (Disposition)
    {
    default:
        ::FusionpLogError(
            MSG_SXS_INVALID_DISPOSITION_FROM_FILE_COPY_CALLBACK,
            CEventLogString(SxspInstallDispositionToStringW(Disposition)));
        goto Exit;

    case SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_COPIED:
        {
            if (fVerify)
            {
                ULONGLONG DestinationFileSize = 0;
                IFW32FALSE_EXIT(::SxspGetFileSize(0, DestinationBuffer, DestinationFileSize));
                INTERNAL_ERROR_CHECK(SourceFileSize == DestinationFileSize);

                //
                // (jonwis) Add a verification check to make sure that the file copied
                // is really the one that they wanted from the file hash information.
                // Do this only if we're not in OS-setup mode.
                //
                IFW32FALSE_EXIT(::SxspCheckHashDuringInstall(fHasHashData, DestinationBuffer, HashDataString, HashAlgId, HashCorrect));
                if (HashCorrect != HashValidate_Matches)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(FileHashMismatch, ERROR_SXS_FILE_HASH_MISMATCH);
            }
        }
        break;

    case SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_QUEUED:
        {
            if (fVerify)
            {
                CFusionFilePathAndSize verifyQueuedFileCopy;

                // Copy our hashing info over.  Yes, I really do mean =, not ==.
                if (verifyQueuedFileCopy.m_bHasHashInfo = fHasHashData)
                {
                    IFW32FALSE_EXIT(verifyQueuedFileCopy.m_HashString.Win32Assign(HashDataString));
                    verifyQueuedFileCopy.m_HashAlgorithm = HashAlgId;
                }

                IFW32FALSE_EXIT(verifyQueuedFileCopy.m_path.Win32Assign(DestinationBuffer));
                verifyQueuedFileCopy.m_size = SourceFileSize;
                IFW32FALSE_EXIT(m_queuedFileCopies.Win32Append(verifyQueuedFileCopy));
            }
        }
        break;

    case SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_MOVE:
    case SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_COPY:
        {
            CStringBuffer DestinationDirectory;
            CMungeFileReadOnlynessAroundReplacement MungeFileAttributes;

            IFW32FALSE_EXIT(DestinationDirectory.Win32Assign(DestinationBuffer));
            DestinationDirectory.RemoveLastPathElement();
            IFW32FALSE_EXIT(::FusionpCreateDirectories(DestinationDirectory, DestinationDirectory.Cch()));

            if (Disposition == SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_COPY)
            {
                DWORD dwLastError;
                IFW32FALSE_EXIT(MungeFileAttributes.Initialize(DestinationBuffer, fReplaceExisting));
                fSuccess = ::SxspInstallDecompressOrCopyFileW(                    
                    SourceBuffer,
                    DestinationBuffer, 
                    !fReplaceExisting); //bFailIfExist
                dwLastError = ::FusionpGetLastWin32Error();
                if ((!fSuccess) && (dwLastError == ERROR_FILE_EXISTS))
                {
                    ULONGLONG cbSource, cbDestination;

                    if ((!::SxspGetFileSize(SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE, SourceBuffer, cbSource)) ||
                        (!::SxspGetFileSize(0, DestinationBuffer, cbDestination)))
                    {
                        ::FusionpSetLastWin32Error(dwLastError);
                    }
                    else if (cbSource == cbDestination)
                    {
                        fSuccess = TRUE;
                    }
                }
            }
            else
            {
                fSuccess = ::SxspInstallMoveFileExW(
                    SourceBuffer,
                    DestinationBuffer,
                    MOVEFILE_COPY_ALLOWED | (fReplaceExisting ? MOVEFILE_REPLACE_EXISTING : 0));
                // move fails on from resource, so general idea: try copy upon move failure
                if (!fSuccess)
                {
                    DWORD dwLastError = ::FusionpGetLastWin32Error();
                    if ((dwLastError == ERROR_ACCESS_DENIED) ||
                        (dwLastError == ERROR_USER_MAPPED_FILE) ||
                        (dwLastError == ERROR_SHARING_VIOLATION))
                    {
                        fSuccess = ::SxspInstallDecompressOrCopyFileW(
                                                SourceBuffer, 
                                                DestinationBuffer, 
                                                !fReplaceExisting); // bFailIfExist
                    }
                }
            }


            if (fSuccess)
            {
                IFW32FALSE_EXIT(::SxspCheckHashDuringInstall(fHasHashData, DestinationBuffer, HashDataString, HashAlgId, HashCorrect));
                if (HashCorrect != HashValidate_Matches)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(FileHashMismatch, ERROR_SXS_FILE_HASH_MISMATCH);
                else
                    fSuccess = TRUE;
                goto Exit;
            }
            else
            {
                ULONGLONG iDupFileSize = 0;
                DWORD dwLastError = ::FusionpGetLastWin32Error();
                CStringBuffer          renameExistingAway;
                CSmallStringBuffer     uidBuffer;
                CFullPathSplitPointers splitExisting;

                bool fFatal =
                    (
                           dwLastError != ERROR_FILE_EXISTS         // !fReplaceExisting
                        && dwLastError != ERROR_ALREADY_EXISTS      // !fReplaceExisting
                        && dwLastError != ERROR_ACCESS_DENIED
                        && dwLastError != ERROR_USER_MAPPED_FILE    //  fReplaceExisting
                        && dwLastError != ERROR_SHARING_VIOLATION); //  fReplaceExisting
                if (fFatal)
                {
                    ::SxspInstallPrint(
                        "SxsInstall: Copy/MoveFileW(%ls,%ls) failed %d, %s.\n",
                        static_cast<PCWSTR>(SourceBuffer),
                        static_cast<PCWSTR>(DestinationBuffer),
                        ::FusionpGetLastWin32Error(),
                        fFatal ? "fatal" : "not fatal");

                    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                            "SXS.dll: Copy/MoveFileW(%ls,%ls) failed %d, %s.\n",
                            static_cast<PCWSTR>(SourceBuffer),
                            static_cast<PCWSTR>(DestinationBuffer),
                            ::FusionpGetLastWin32Error(),
                            fFatal ? "fatal" : "not fatal");

                    goto Exit;
                }

                //
                // This could be winlogon (or setup) holding open comctl, so
                // try harder. Move the file away and then copy.
                // Consider ReplaceFile here for atomicity, but ReplaceFile
                // is kind of big and scary and unknown.
                //
                if (fTransactional)
                {
                    ::SxspInstallPrint("SxsInstall: Failure to copy file into temp, someone's opening temp?\n");
                }

                if (!splitExisting.Initialize(SourceBuffer))
                {
                    goto CheckSizes;
                }
                if (!::SxspCreateWinSxsTempDirectory(renameExistingAway, NULL, &uidBuffer, NULL))
                {
                    goto CheckSizes;
                }
                if (!renameExistingAway.Win32AppendPathElement(splitExisting.m_name, (splitExisting.m_name != NULL) ? ::wcslen(splitExisting.m_name) : 0))
                {
                    goto CheckSizes;
                }

                if (!::MoveFileExW(DestinationBuffer, renameExistingAway, 0))
                {
                    ::SxspInstallPrint(
                        "SxsInstall: MoveFileExW(%ls,%ls,0) failed %d.\n",
                        static_cast<PCWSTR>(DestinationBuffer),
                        static_cast<PCWSTR>(renameExistingAway),
                        ::FusionpGetLastWin32Error());
                    goto CheckSizes;
                }
                if (!::SxspInstallDecompressOrCopyFileW(
                            SourceBuffer,
                            DestinationBuffer,
                            FALSE))
                {
                    ::SxspInstallPrint(
                        "SxsInstall: CopyFile(%ls, %ls, TRUE) failed %d.\n",
                        static_cast<PCWSTR>(SourceBuffer),
                        static_cast<PCWSTR>(DestinationBuffer),
                        ::FusionpGetLastWin32Error());
                    //roll back
                    if (!::MoveFileExW(renameExistingAway, DestinationBuffer, 0))
                    {
                        ::SxspInstallPrint(
                            "SxsInstall: Rollback MoveFileExW(%ls, %ls, 0) failed %d; this is very bad.\n",
                            static_cast<PCWSTR>(renameExistingAway),
                            static_cast<PCWSTR>(DestinationBuffer),
                            ::FusionpGetLastWin32Error()
                          );
                    }
                    goto CheckSizes;
                }
                fSuccess = TRUE;
                goto Exit;
CheckSizes:
                IFW32FALSE_EXIT(::SxspGetFileSize(0, DestinationBuffer, iDupFileSize));

                if (iDupFileSize != SourceFileSize)
                {
                    ::SxspInstallPrint("SxsInstall: " __FUNCTION__ " Error %d encountered, file sizes not the same, assumed equal, propagating error.\n", dwLastError);
                    ::FusionpSetLastWin32Error(dwLastError);
                    goto Exit;
                }
                ::SxspInstallPrint("SxsInstall: " __FUNCTION__ " Error %d encountered, file sizes the same, assumed equal, claiming success.\n", dwLastError);
            }
            break;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID
CDllRedir::ContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();
    CDllRedir *pDllRedir = reinterpret_cast<CDllRedir*>(Data->Header.ActCtxGenContext);
    PSTRING_SECTION_GENERATION_CONTEXT SSGenContext = NULL;
    PDLL_REDIRECTION_CONTEXT DllRedirectionContext = NULL;
    PDLL_REDIRECTION_ENTRY Entry = NULL;

    if (pDllRedir != NULL)
        SSGenContext = pDllRedir->m_SSGenContext;

    if (SSGenContext != NULL)
        DllRedirectionContext = (PDLL_REDIRECTION_CONTEXT) ::SxsGetStringSectionGenerationContextCallbackContext(SSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_PARSEENDING:
        Data->ParseEnding.Success = FALSE;

        /*
        at this point we have enough information to form the install path,
        so get the TeeStream to start writing the manifest to disk
        */
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)
            IFW32FALSE_EXIT(InstallManifest(Data->Header.ManifestOperationFlags, Data->ParseEnding.AssemblyContext));

        Data->ParseEnding.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_PARSEENDED:
        if ( Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL )
        {
            PACTCTXCTB_CBPARSEENDED pParseEnded = reinterpret_cast<PACTCTXCTB_CBPARSEENDED>(Data);
            CSecurityMetaData *psmdSecurity =
                reinterpret_cast<CSecurityMetaData*>(pParseEnded->AssemblyContext->SecurityMetaData);
            CTeeStreamWithHash *pTeeStreamWithHash =
                reinterpret_cast<CTeeStreamWithHash*>(pParseEnded->AssemblyContext->TeeStreamForManifestInstall);
            CFusionArray<BYTE> baManifestHashBytes;

        
            if ( ( psmdSecurity != NULL ) && ( pTeeStreamWithHash != NULL ) )
            {
                IFW32FALSE_EXIT(baManifestHashBytes.Win32Initialize());
                IFW32FALSE_EXIT(pTeeStreamWithHash->GetCryptHash().Win32GetValue(baManifestHashBytes));
                IFW32FALSE_EXIT(psmdSecurity->SetManifestHash( baManifestHashBytes ));
            }
        }
        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        {
            IFALLOCFAILED_EXIT(DllRedirectionContext = new DLL_REDIRECTION_CONTEXT);
            IFW32FALSE_EXIT(::SxsInitStringSectionGenerationContext(
                    &m_SSGenContext,
                    ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_FORMAT_WHISTLER,
                    TRUE,
                    &::SxspDllRedirectionStringSectionGenerationCallback,
                    DllRedirectionContext));
            DllRedirectionContext = NULL;
        }
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)
        {
            IFW32FALSE_EXIT(this->BeginInstall(Data));
        }

        Data->GenBeginning.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDING:
        Data->GenEnding.Success = FALSE;

        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)
            IFW32FALSE_EXIT(this->EndInstall(Data));

        Data->GenEnding.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (m_SSGenContext != NULL)
            ::SxsDestroyStringSectionGenerationContext(m_SSGenContext);

        if (DllRedirectionContext != NULL)
            FUSION_DELETE_SINGLETON(DllRedirectionContext);

        m_SSGenContext = NULL;
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;

        if (SSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingStringSectionGenerationContext(SSGenContext));

        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        INTERNAL_ERROR_CHECK(SSGenContext);
        IFW32FALSE_EXIT(::SxsGetStringSectionGenerationContextSectionSize(SSGenContext, &Data->GetSectionSize.SectionSize));
        Data->GetSectionSize.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        {
            Data->ElementParsed.Success = FALSE;

            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssembly,
                eAssemblyFile,
            };

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                { 1, L"urn:schemas-microsoft-com:asm.v1^assembly",      NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly")      - 1, eAssembly },
                { 2, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file", NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file") - 1, eAssemblyFile },
            };

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->ElementParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR_CHECK2(
                        FALSE,
                        "Invalid mapped value returned from SxspProcessElementPathMap()");

                case eAssembly:
                    break;

                case eAssemblyFile:
                    {
                        bool fFound;
                        CSmallStringBuffer FileNameBuffer;
                        CSmallStringBuffer LoadFromBuffer;
                        CSmallStringBuffer HashValueBuffer;
                        SIZE_T cb;

                        // We look for required attributes etc first so that if we're only parsing, it's
                        // common code.

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_name,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(FileNameBuffer),
                                &FileNameBuffer,
                                cb,
                                NULL,
                                0));
                        INTERNAL_ERROR_CHECK(fFound);

                        //
                        // Ensure that the hash string is valid
                        //
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_hash,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(HashValueBuffer),
                                &HashValueBuffer,
                                cb,
                                NULL,
                                0));

                        //
                        // Odd numbers of characters in the hash string will be bad later.
                        //
                        if (fFound && (HashValueBuffer.Cch() % 2))
                        {
                            (*Data->ElementParsed.ParseContext->ErrorCallbacks.InvalidAttributeValue)(
                                Data->ElementParsed.ParseContext,
                                &s_AttributeName_hash);

                            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                            goto Exit;
                        }

                        //
                        // And that the hash-alg string is valid too
                        //
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_hashalg,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(HashValueBuffer),
                                &HashValueBuffer,
                                cb,
                                NULL,
                                0));

                        if (fFound)
                        {
                            ALG_ID aid;
                            if (!::SxspHashAlgFromString(HashValueBuffer, aid))
                            {
                                (*Data->ElementParsed.ParseContext->ErrorCallbacks.InvalidAttributeValue)(
                                    Data->ElementParsed.ParseContext,
                                    &s_AttributeName_hashalg);

                                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                                goto Exit;
                            }
                        }

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_loadFrom,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(LoadFromBuffer),
                                &LoadFromBuffer,
                                cb,
                                NULL,
                                0));

                        if (fFound)
                        {
                            // We're not allowed to install assemblies that have a loadFrom= and the only
                            // manifests with them that we can activate are ones that don't live in the assembly store.
                            if ((Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL) ||
                                ((Data->ElementParsed.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY) == 0))
                            {
                                // You can't install an assembly with a loadfrom=foo file; it's only provided for
                                // app compat...
                                (*Data->ElementParsed.ParseContext->ErrorCallbacks.AttributeNotAllowed)(
                                    Data->ElementParsed.ParseContext,
                                    &s_AttributeName_loadFrom);

                                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                                goto Exit;
                            }
                        }

                        //
                        // Always update the file count.
                        //
                        ASSERT(Data->Header.ActCtxGenContext != NULL);
                        if (Data->Header.ActCtxGenContext)
                        {
                            Data->Header.pOriginalActCtxGenCtx->m_ulFileCount++;
                        }

                        // If we're installing, call back to the copy function
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)
                            IFW32FALSE_EXIT(this->InstallFile(Data, FileNameBuffer));

                        // If we are generating an activation context, add it to the context.
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            IFALLOCFAILED_EXIT(Entry = new DLL_REDIRECTION_ENTRY);

                            IFW32FALSE_EXIT(Entry->FileNameBuffer.Win32Assign(FileNameBuffer, FileNameBuffer.Cch()));

                            if (LoadFromBuffer.Cch() != 0)
                            {
                                Entry->AssemblyPathBuffer.Win32Assign(LoadFromBuffer, LoadFromBuffer.Cch());
                                Entry->AssemblyPathIsLoadFrom = true;

                                // If the value does not end in a slash, we assume it directly refers to
                                // a file.
                                if (!LoadFromBuffer.HasTrailingPathSeparator())
                                    Entry->PathIncludesBaseName = true;
                            }

                            if (!::SxsAddStringToStringSectionGenerationContext(
                                        (PSTRING_SECTION_GENERATION_CONTEXT) m_SSGenContext,
                                        Entry->FileNameBuffer,
                                        Entry->FileNameBuffer.Cch(),
                                        Entry,
                                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                        ERROR_SXS_DUPLICATE_DLL_NAME))
                            {
                                ::FusionpLogError(
                                    MSG_SXS_DLLREDIR_CONTRIB_ADD_FILE_MAP_ENTRY,
                                    CUnicodeString(Entry->FileNameBuffer, Entry->FileNameBuffer.Cch()),
                                    CEventLogLastError());
                                goto Exit;
                            }
                            Entry = NULL;
                        }
                    }
                    break;
                }
            }

        }
        // Everything's groovy!
        Data->ElementParsed.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;
        IFW32FALSE_EXIT(::SxsGetStringSectionGenerationContextSectionData(
                m_SSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));
        Data->GetSectionData.Success = TRUE;
        break;
    }

Exit:
    FUSION_DELETE_SINGLETON(Entry);
}

BOOL
SxspDllRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;

    switch (Reason)
    {
    default:
        goto Exit;

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        // will use the user data area later to store common paths
        break;

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PDLL_REDIRECTION_ENTRY Entry = (PDLL_REDIRECTION_ENTRY) CBData->DataContext;
            FUSION_DELETE_SINGLETON(Entry);
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PDLL_REDIRECTION_ENTRY Entry = (PDLL_REDIRECTION_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION);

            if (Entry->AssemblyPathBuffer.Cch() != 0)
            {
                CBData->DataSize += sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT);
                CBData->DataSize += (Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));
            }

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PDLL_REDIRECTION_ENTRY Entry = (PDLL_REDIRECTION_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Info;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;
            PVOID Cursor;

            Info = (PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION) CBData->Buffer;
            Cursor = (PVOID) (Info + 1);

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION);
            Info->Flags = 0;
            Info->TotalPathLength = static_cast<ULONG>(Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));

            if (Entry->PathIncludesBaseName)
                Info->Flags |= ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME;

            if (Entry->AssemblyPathBuffer.Cch() == 0)
            {
                // If there's no path, there's no segments!
                Info->PathSegmentCount = 0;
                Info->PathSegmentOffset = 0;
                Info->Flags |= ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT;
            }
            else
            {
                PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT Segment;

                Info->PathSegmentCount = 1;
                Info->PathSegmentOffset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) CBData->SectionHeader));

                // If this is a loadfrom="foo" file and the string contains a %, set the expand flag...
                if ((Entry->AssemblyPathIsLoadFrom) && (Entry->AssemblyPathBuffer.ContainsCharacter(L'%')))
                    Info->Flags |= ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND;

                Segment = (PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT) Cursor;
                Cursor = (PVOID) (Segment + 1);

                if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT))
                {
                    ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT);
                BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT);

                Segment->Length = Info->TotalPathLength;
                Segment->Offset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) CBData->SectionHeader));

                if (BytesLeft < (Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR)))
                {
                    ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                BytesWritten += (Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));
                BytesLeft -= (Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));

                memcpy(Cursor, static_cast<PCWSTR>(Entry->AssemblyPathBuffer), Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));
            }

            CBData->BytesWritten = BytesWritten;
        }

    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\fileoper.h ===
#if !defined(_FUSION_SXS_FILEOPER_H_INCLUDED_)
#define _FUSION_SXS_FILEOPER_H_INCLUDED_

#pragma once

#define SXSP_COPY_FILE_FLAG_REPLACE_EXISTING (0x00000001)
#define SXSP_COPY_FILE_FLAG_COMPRESSION_AWARE (0x00000002)

BOOL
SxspCopyFile(
    DWORD dwFlags,
    PCWSTR pszSource,
    PCWSTR pszDestination
    );

#endif // !defined(_FUSION_SXS_FILEOPER_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\fileoper.cpp ===
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include <stdio.h>
#include <setupapi.h>
#include "fusionhandle.h"
#include "sxspath.h"
#include "sxsapi.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "strongname.h"
#include "fusiontrace.h"

BOOL
SxspCopyFile(
    DWORD dwFlags,
    PCWSTR pszSource,
    PCWSTR pszDestination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL fFileWasInUse = FALSE;
    DWORD dwCopyStyle = 0;

    PARAMETER_CHECK((dwFlags & ~(SXSP_COPY_FILE_FLAG_REPLACE_EXISTING | SXSP_COPY_FILE_FLAG_COMPRESSION_AWARE)) == 0);
    PARAMETER_CHECK(pszSource != NULL);
    PARAMETER_CHECK(pszDestination != NULL);

#if 0
    if (dwFlags & SXSP_COPY_FILE_FLAG_COMPRESSION_AWARE)
    {
        CSmallStringBuffer buffTempFile;
        BOOL fTemp;

        IFW32FALSE_EXIT(buffTempFile.Win32Assign(pszDestination, wcslen(pszDestination)));
        IFW32FALSE_EXIT(buffTempFile.Win32Append(L".$$$", 4));

        dwCopyStyle |= SP_COPY_SOURCE_ABSOLUTE | SP_COPY_NOSKIP;

        if ((dwFlags & SXSP_COPY_FILE_FLAG_REPLACE_EXISTING) == 0)
            dwCopyStyle |= SP_COPY_FORCE_NOOVERWRITE;

        IFW32FALSE_ORIGINATE_AND_EXIT(
            ::SetupInstallFileExW(
                    NULL,                       // optional HINF InfHandle
                    NULL,                       // optional PINFCONTEXT InfContext
                    pszSource,                  // source file
                    NULL,                       // source path
                    buffTempFile,               // optional filename after copy
                    dwCopyStyle,
                    NULL,                       // optional copy msg handler
                    NULL,                       // optional copy msg handler context
                    &fFileWasInUse));

        fTemp = ::MoveFileExW(
            buffTempFile,
            pszDestination,
            (dwFlags & SXSP_COPY_FILE_FLAG_REPLACE_EXISTING) ?
                MOVEFILE_REPLACE_EXISTING : 0);
        if (!fTemp)
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();

            fTemp = ::DeleteFileW(buffTempFile);
            if (!fTemp)
            {
                // Oh boy, cleaning up the temporary file didn't work.  Queue the deletion...
                fTemp = ::MoveFileExW(buffTempFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                // The worst case scenario here is that we have an extra file left around... forget it.
            }

            ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
        }
    }
    else
#endif
    {
        IFW32FALSE_ORIGINATE_AND_EXIT(
            ::CopyFileW(
                pszSource,
                pszDestination,
                (dwFlags & SXSP_COPY_FILE_FLAG_REPLACE_EXISTING) == 0));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGetFileSize(
    DWORD dwFlags,
    PCWSTR   file,
    ULONGLONG &fileSize
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PWSTR pszActualSource = NULL;

    fileSize = 0;

    PARAMETER_CHECK(file != NULL);
    PARAMETER_CHECK((dwFlags & ~(SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE | SXSP_GET_FILE_SIZE_FLAG_GET_COMPRESSED_SOURCE_SIZE)) == 0);
    PARAMETER_CHECK((dwFlags & SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE) || !(dwFlags & SXSP_GET_FILE_SIZE_FLAG_GET_COMPRESSED_SOURCE_SIZE));

    if (dwFlags & SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE)
    {
        DWORD dwTemp;
        DWORD dwSourceFileSize, dwTargetFileSize;
        UINT uiCompressionType;

        dwTemp = ::SetupGetFileCompressionInfoW(
            file,
            &pszActualSource,
            &dwSourceFileSize,
            &dwTargetFileSize,
            &uiCompressionType);
        if (dwTemp != ERROR_SUCCESS)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(SetupGetFileCompressionInfoW, dwTemp);

        if (pszActualSource != NULL)
            ::LocalFree((HLOCAL) pszActualSource);
        pszActualSource = NULL;
        if (dwFlags & SXSP_GET_FILE_SIZE_FLAG_GET_COMPRESSED_SOURCE_SIZE)
            fileSize = dwSourceFileSize;
        else
            fileSize = dwTargetFileSize;
    }
    else
    {
        LARGE_INTEGER liFileSize = {0};
        WIN32_FILE_ATTRIBUTE_DATA wfad;

        wfad.nFileSizeLow = 0;
        wfad.nFileSizeHigh = 0;

        IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileAttributesExW(file, GetFileExInfoStandard, &wfad));

        liFileSize.LowPart = wfad.nFileSizeLow;
        liFileSize.HighPart = wfad.nFileSizeHigh;
        fileSize = liFileSize.QuadPart;
    }

    fSuccess = TRUE;
Exit:
    if (pszActualSource != NULL)
    {
        CSxsPreserveLastError ple;
        ::LocalFree((HLOCAL) pszActualSource);
        ple.Restore();
    }

    return fSuccess;
}

BOOL
SxspDoesFileExist(
    DWORD dwFlags,
    PCWSTR pszFileName,
    bool &rfExists
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PWSTR pszActualSource = NULL;

    rfExists = false;

    PARAMETER_CHECK(pszFileName != NULL);
    PARAMETER_CHECK((dwFlags & ~(SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE)) == 0);

    if (dwFlags & SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE)
    {
        DWORD dwTemp;
        DWORD dwSourceFileSize, dwTargetFileSize;
        UINT uiCompressionType;

        dwTemp = ::SetupGetFileCompressionInfoW(
            pszFileName,
            &pszActualSource,
            &dwSourceFileSize,
            &dwTargetFileSize,
            &uiCompressionType);

        if (pszActualSource != NULL)
            ::LocalFree((HLOCAL) pszActualSource);

        if (dwTemp == ERROR_FILE_NOT_FOUND)
        {
            // This case is OK.  No error to return...
        }
        else if (dwTemp != ERROR_SUCCESS)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(SetupGetFileCompressionInfoW, dwTemp);
        else
        {
            rfExists = true;
        }

        pszActualSource = NULL;
    }
    else
    {
        if (::GetFileAttributesW(pszFileName) == ((DWORD) -1))
        {
            const DWORD dwLastError = ::GetLastError();

            if (dwLastError != ERROR_FILE_NOT_FOUND)
                ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributesW, dwLastError);
        }
        else
            rfExists = true;
    }

    fSuccess = TRUE;
Exit:
    if (pszActualSource != NULL)
    {
        CSxsPreserveLastError ple;
        ::LocalFree((HLOCAL) pszActualSource);
        ple.Restore();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\dumpers.cpp ===
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include <stdio.h>
#include "FusionHandle.h"
#include "sxsapi.h"
#include <limits.h>
typedef const void * PCVOID;

/*
Declaration of dumpers are moved from the relatively public sxsp.h
to here to contain their use.

These functions should be preceded by FusionpDbgWouldPrintAtFilterLevel calls
and surrounded by __try/__except(EXCEPTION_EXECUTE_HANDLER)

These function can consume a lot of stack, and time, when their output
ultimately doesn't go anywhere, and they overflow the small commited stack
in csrss under stress.
*/

VOID
SxspDbgPrintInstallSourceInfo(
    ULONG Level,
    PSXS_INSTALL_SOURCE_INFO Info,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataTocEntry(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataTocSections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    const GUID *ExtensionGuid,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataTocSection(
    ULONG Level,
    bool fFull,
    PVOID Section,
    SIZE_T Length,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataExtendedTocHeader(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataExtendedTocEntry(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataExtendedTocSections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataExtendedTocEntrySections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextStringSection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextGuidSection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextBinarySection(
    ULONG Level,
    bool fFull,
    PVOID Data,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintAssemblyInformation(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintDllRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintWindowClassRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintClrSurrogateTable(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintComServerRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintComProgIdRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintTypeLibraryRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintComInterfaceRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintActivationContextDataAssemblyRoster(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataTocHeader(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxsppDbgPrintActivationContextData(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SActivation Context Data %p\n"
            "%S   Magic = 0x%08lx (%lu)\n"
            "%S   HeaderSize = %d (0x%lx)\n"
            "%S   FormatVersion = %d\n",
            PLP, Data,
            PLP, Data->Magic, Data->Magic,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->FormatVersion);

        ::FusionpDbgPrintEx(
            Level,
            "%S   TotalSize = %d (0x%lx)\n"
            "%S   DefaultTocOffset = %d (0x%lx) (-> %p)\n"
            "%S   ExtendedTocOffset = %d (0x%lx) (-> %p)\n",
            PLP, Data->TotalSize, Data->TotalSize,
            PLP, Data->DefaultTocOffset, Data->DefaultTocOffset, (Data->DefaultTocOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            PLP, Data->ExtendedTocOffset, Data->ExtendedTocOffset, (Data->ExtendedTocOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->ExtendedTocOffset));

        ::FusionpDbgPrintEx(
            Level,
            "%S   AssemblyRosterOffset = %d (0x%lx) (-> %p)\n",
            PLP, Data->AssemblyRosterOffset, Data->AssemblyRosterOffset, (Data->AssemblyRosterOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset));
    }
    else
    {
        // !fFull
        ::FusionpDbgPrintEx(
            Level,
            "%SActivation Context Data %p (brief output)\n",
            PLP, Data);
    }

    rbuffPLP.Win32Append(L"   ", 3);

    if (Data->AssemblyRosterOffset != 0)
        ::SxspDbgPrintActivationContextDataAssemblyRoster(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset),
            rbuffPLP);

    if (Data->DefaultTocOffset != 0)
        ::SxspDbgPrintActivationContextDataTocHeader(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            rbuffPLP);

    if (Data->ExtendedTocOffset != 0)
        ::SxspDbgPrintActivationContextDataExtendedTocHeader(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((ULONG_PTR) Data) + Data->ExtendedTocOffset),
            rbuffPLP);

    // That's it for the header information.  Now start dumping the sections...
    if (Data->DefaultTocOffset != 0)
        ::SxspDbgPrintActivationContextDataTocSections(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            NULL,
            rbuffPLP);

    if (Data->ExtendedTocOffset != 0)
        ::SxspDbgPrintActivationContextDataExtendedTocSections(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((ULONG_PTR) Data) + Data->ExtendedTocOffset),
            rbuffPLP);
}

VOID
SxspDbgPrintActivationContextData(
    ULONG Level,
    PCACTIVATION_CONTEXT_DATA Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    __try
    {
        if (::FusionpDbgWouldPrintAtFilterLevel(Level))
        {
            ::SxsppDbgPrintActivationContextData(Level, ::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_FULLACTCTX), Data, rbuffPLP);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        /* Just eat it, we are seeing failures now in DbgPrint even
        with relatively shallow callstacks
        */
    }
}

VOID
SxspDbgPrintActivationContextDataAssemblyRoster(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY Entry;
    CSmallStringBuffer buffFlags;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemblyInformation = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgAssemblyRosterEntryFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID, "Invalid")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT, "Root")
    };

    PCWSTR PLP = rbuffPLP;

    if (fFull)
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER %p\n"
            "%S   HeaderSize = %lu (0x%lx)\n"
            "%S   EntryCount = %lu (0x%lx)\n"
            "%S   FirstEntryOffset = %ld (0x%lx)\n",
            PLP, Data,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->EntryCount, Data->EntryCount,
            PLP, Data->FirstEntryOffset, Data->FirstEntryOffset);
    else
        ::FusionpDbgPrintEx(
            Level,
            "%SAssembly Roster (%lu assemblies)\n"
            "%SIndex | Assembly Name (Flags)\n",
            PLP, Data->EntryCount - 1,
            PLP);

    for (i=0; i<Data->EntryCount; i++)
    {
        Entry = ((PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset)) + i;

        UNICODE_STRING s;

        if (Entry->AssemblyNameOffset != 0)
        {
            s.Length = (USHORT) Entry->AssemblyNameLength;
            s.MaximumLength = s.Length;
            s.Buffer = (PWSTR) (((ULONG_PTR) Base) + Entry->AssemblyNameOffset);
        }
        else
        {
            s.Length = 0;
            s.MaximumLength = 0;
            s.Buffer = NULL;
        }

        ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgAssemblyRosterEntryFlags), s_rgAssemblyRosterEntryFlags, buffFlags);

        if (Entry->AssemblyInformationOffset != NULL)
            AssemblyInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) (((ULONG_PTR) Base) + Entry->AssemblyInformationOffset);
        else
            AssemblyInformation = NULL;

        if (fFull)
        {
            ::FusionpDbgPrintEx(
                Level,
                "%S   ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY %p [#%d]\n"
                "%S      Flags = 0x%08lx (%S)\n"
                "%S      PseudoKey = %lu\n",
                PLP, Entry, i,
                PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags),
                PLP, Entry->PseudoKey);

            ::FusionpDbgPrintEx(
                Level,
                "%S      AssemblyNameOffset = %lu (0x%lx) \"%wZ\"\n"
                "%S      AssemblyNameLength = %lu (0x%lx) \n"
                "%S      AssemblyInformationOffset = %lu (0x%lx) (-> %p)\n"
                "%S      AssemblyInformationLength = %lu (0x%lx)\n",
                PLP, Entry->AssemblyNameOffset, Entry->AssemblyNameOffset, &s,
                PLP, Entry->AssemblyNameLength, Entry->AssemblyNameLength,
                PLP, Entry->AssemblyInformationOffset, Entry->AssemblyInformationOffset, AssemblyInformation,
                PLP, Entry->AssemblyInformationLength, Entry->AssemblyInformationLength);
        }
        else
        {
            if (i != 0)
                ::FusionpDbgPrintEx(
                    Level,
                    "%S%5lu | %wZ (%S)\n",
                    PLP, i, &s, static_cast<PCWSTR>(buffFlags));
        }
    }
}

VOID
SxspDbgPrintActivationContextDataTocHeader(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffFlags;
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY FirstEntry = NULL;

    if (PLP == NULL)
        PLP = L"";

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE, "Dense")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER, "Inorder")
    };

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgFlags), s_rgFlags, buffFlags);

    if (Data->FirstEntryOffset != 0)
        FirstEntry = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_TOC_HEADER %p\n"
            "%S   HeaderSize = %d (0x%lx)\n"
            "%S   EntryCount = %d\n"
            "%S   FirstEntryOffset = %d (0x%lx) (-> %p)\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Data,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->EntryCount,
            PLP, Data->FirstEntryOffset, Data->FirstEntryOffset, FirstEntry,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));
    }

    if (FirstEntry != NULL)
    {
        SIZE_T cchSave = rbuffPLP.Cch();

        // Abuse the buffFlags buffer for the new per-line prefix.
        rbuffPLP.Win32Append(L"   ", 3);

        for (i=0; i<Data->EntryCount; i++)
            ::SxspDbgPrintActivationContextDataTocEntry(Level, fFull, Base, &FirstEntry[i], rbuffPLP);

        rbuffPLP.Left(cchSave);
        PLP = rbuffPLP;
    }

}

VOID
SxspDbgPrintActivationContextDataTocSections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    const GUID *ExtensionGuid,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    SIZE_T cchPLP = rbuffPLP.Cch();

    if (Data->FirstEntryOffset != 0)
    {
        PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entries = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
        ULONG i;

        for (i=0; i<Data->EntryCount; i++)
        {
            if (Entries[i].Offset != 0)
            {
                PVOID Section = (PVOID) (((ULONG_PTR) Base) + Entries[i].Offset);
                CSmallStringBuffer buffSectionId;
                PCSTR pszSectionName = "<untranslatable>";

                if (ExtensionGuid != NULL)
                {
                    WCHAR rgchBuff[sizeof(LONG)*CHAR_BIT];

                    ::SxspFormatGUID(*ExtensionGuid, buffSectionId);
                    buffSectionId.Win32Append(L".", 1);
                    swprintf(rgchBuff, L"%u", Entries[i].Id);
                    buffSectionId.Win32Append(rgchBuff, ::wcslen(rgchBuff));
                }
                else
                {
                    WCHAR rgchBuff[255];

#define MAP_ENTRY(_x, _y) case _x: if (fFull) pszSectionName = #_x; else pszSectionName = _y; break;

                    switch (Entries[i].Id)
                    {
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "Assembly Information")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "DLL Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "Window Class Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION, "COM Server Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION, "COM Interface Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION, "COM Type Library Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, "COM ProgId Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE, "Win32 Global Object Name Redirection")
                    }

                    if (pszSectionName != NULL)
                        swprintf(rgchBuff, L"%u (%S)", Entries[i].Id, pszSectionName);
                    else
                        swprintf(rgchBuff, L"%u", Entries[i].Id);

                    buffSectionId.Win32Append(rgchBuff, ::wcslen(rgchBuff));
                }

#if 0 // redundant at least in non-full prints
                if (fFull)
                    ::FusionpDbgPrintEx(
                        Level,
                        "%SSection Id %S at %p\n",
                        PLP, static_cast<PCWSTR>(buffSectionId), Section);
                else
                    ::FusionpDbgPrintEx(
                        Level,
                        "%S%s Data\n",
                        PLP, pszSectionName);
#endif //

                ::SxspDbgPrintActivationContextDataTocSection(
                    Level,
                    fFull,
                    Section,
                    Entries[i].Length,
                    ExtensionGuid,
                    Entries[i].Id,
                    pszSectionName,
                    rbuffPLP);
            }
        }
    }
}

VOID
SxspDbgPrintActivationContextDataTocSection(
    ULONG Level,
    bool fFull,
    PVOID Section,
    SIZE_T Length,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    )
{
    if (Length > sizeof(ULONG))
    {
        switch (*(ULONG *) Section)
        {
        case ACTIVATION_CONTEXT_STRING_SECTION_MAGIC:
            ::SxspDbgPrintActivationContextStringSection(
                Level,
                fFull,
                (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) Section,
                ExtensionGuid,
                SectionId,
                SectionName,
                rbuffPLP);
            break;
        case ACTIVATION_CONTEXT_GUID_SECTION_MAGIC:
            ::SxspDbgPrintActivationContextGuidSection(
                Level,
                fFull,
                (PCACTIVATION_CONTEXT_GUID_SECTION_HEADER) Section,
                ExtensionGuid,
                SectionId,
                SectionName,
                rbuffPLP);
            break;
        default:
            break;
        }
    }
    else if ( SectionId != 0 )
    {
        ::SxspDbgPrintActivationContextBinarySection(
            Level,
            fFull,
            Section,
            Length,
            rbuffPLP);
    }
}

const STRING *
SxspDbgSectionIdToNtString(
    ULONG Id
    )
{
    switch (Id)
    {
#define ENTRY(id, s) id : { const static STRING t = RTL_CONSTANT_STRING(s); return &t; }
    ENTRY(default, "<No name associated with id>");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "Assembly Information");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "Dll Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "Window Class Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION, "COM Server Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION, "COM Interface Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION, "COM Type Library Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, "COM ProgId Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE, "Win32 Global Object Name Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES, "NDP Surrogate Type Table");
#undef ENTRY
    }
}

PCSTR
SxspDbgSectionIdToString(
    ULONG Id
    )
{
    return SxspDbgSectionIdToNtString(Id)->Buffer;
}

VOID
SxspDbgPrintActivationContextDataTocEntry(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    )
{
    PVOID SectionData = NULL;
    PCSTR pszFormat = "<untranslated format>";
    PCWSTR PLP = rbuffPLP;

    if (!fFull)
        return;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->Offset != 0)
        SectionData = (PVOID) (((ULONG_PTR) Base) + Entry->Offset);

#define MAP_FORMAT(_x, _sn) \
case _x: \
    if (fFull) \
        pszFormat = #_x; \
    else \
        pszFormat = _sn; \
    break;

    switch (Entry->Format)
    {
    default: break;
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN, "user defined");
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE, "string table");
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE, "guid table");
    }
#undef MAP_FORMAT

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_TOC_ENTRY %p\n"
            "%S   Id = %Z (%u)\n"
            "%S   Offset = %lu (0x%lx) (-> %p)\n"
            "%S   Length = %lu (0x%lx)\n"
            "%S   Format = %lu (%s)\n",
            PLP, Entry,
            PLP, SxspDbgSectionIdToNtString(Entry->Id), Entry->Id,
            PLP, Entry->Offset, Entry->Offset, SectionData,
            PLP, Entry->Length, Entry->Length,
            PLP, Entry->Format, pszFormat);
    }
    else
    {
        ::FusionpDbgPrintEx(
            Level,
            "%S%7lu | %Z (%s)\n",
            PLP, Entry->Id, SxspDbgSectionIdToNtString(Entry->Id), pszFormat);
    }
}

VOID
SxspDbgPrintActivationContextDataExtendedTocHeader(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffNewPrefix;
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry = NULL;
    ULONG i;

    if (PLP == NULL)
        PLP = L"";

    if (Data->FirstEntryOffset != NULL)
    {
        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        Entry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
    }

    ::FusionpDbgPrintEx(
        Level,
        "%SACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER %p\n"
        "%S   HeaderSize = %d\n"
        "%S   EntryCount = %d\n"
        "%S   FirstEntryOffset = %d (->%p)\n"
        "%S   Flags = 0x%08lx\n",
        PLP, Data,
        PLP, Data->HeaderSize,
        PLP, Data->EntryCount,
        PLP, Data->FirstEntryOffset, Entry,
        PLP, Data->Flags);


    if (Entry != NULL)
    {
        for (i=0; i<Data->EntryCount; i++)
            ::SxspDbgPrintActivationContextDataExtendedTocEntry(
                Level,
                fFull,
                Base,
                &Entry[i],
                buffNewPrefix);
    }
}

VOID
SxspDbgPrintActivationContextDataExtendedTocEntry(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffNewPrefix;
    CSmallStringBuffer buffFormattedGUID;
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = NULL;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->TocOffset != 0)
    {
        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        Toc = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Base) + Entry->TocOffset);
    }

    ::SxspFormatGUID(Entry->ExtensionGuid, buffFormattedGUID);

    ::FusionpDbgPrintEx(
        Level,
        "%SACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY %p\n"
        "%S   ExtensionGuid = %S\n"
        "%S   TocOffset = %d (-> %p)\n"
        "%S   Length = %d\n",
        PLP, Entry,
        PLP, static_cast<PCWSTR>(buffFormattedGUID),
        PLP, Entry->Length);

    if (Toc != NULL)
        ::SxspDbgPrintActivationContextDataTocHeader(Level, fFull, Base, Toc, buffNewPrefix);
}

VOID
SxspDbgPrintActivationContextDataExtendedTocSections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffNewPrefix;
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry = NULL;
    ULONG i;

    if (PLP == NULL)
        PLP = L"";

    if (Data->FirstEntryOffset != NULL)
    {
        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        Entry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
    }

    if (Entry != NULL)
    {
        for (i=0; i<Data->EntryCount; i++)
            ::SxspDbgPrintActivationContextDataExtendedTocEntrySections(
                Level,
                fFull,
                Base,
                &Entry[i],
                buffNewPrefix);
    }
}

VOID
SxspDbgPrintActivationContextDataExtendedTocEntrySections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffNewPrefix;
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = NULL;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->TocOffset != 0)
    {
        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        Toc = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Base) + Entry->TocOffset);
    }

    if (Toc != NULL)
    {
        CSmallStringBuffer buffFormattedGUID;

        ::SxspFormatGUID(Entry->ExtensionGuid, buffFormattedGUID);
        ::FusionpDbgPrintEx(
            Level,
            "%SSections for extension GUID %S (Extended TOC entry %p)\n",
            PLP, static_cast<PCWSTR>(buffFormattedGUID), Entry);

        ::SxspDbgPrintActivationContextDataTocSections(Level, fFull, Base, Toc, &Entry->ExtensionGuid, buffNewPrefix);
    }
}

VOID
SxspDbgPrintActivationContextBinarySection(
    ULONG Level,
    bool fFull,
    PVOID Data,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    if (PLP == NULL)
        PLP = L"";

    ::FusionpDbgPrintEx(
        Level,
        "%SBinary section %p (%d bytes)\n",
        PLP, Data, Length);

    if (Length != 0)
    {
        CSmallStringBuffer buffNewPrefix;

        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        ::FusionpDbgPrintBlob(Level, Data, Length, buffNewPrefix);
    }
}

VOID
SxspDbgPrintActivationContextStringSection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    SIZE_T cchPLP = rbuffPLP.Cch();
    CSmallStringBuffer buffBriefOutput;
    CSmallStringBuffer buffFlags;
    SIZE_T cchBriefOutputKey = 3;

    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE SearchStructure = NULL;
    PVOID UserData = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgStringSectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE, "Case Insensitive")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER, "In PseudoKey Order")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Data->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY) (((ULONG_PTR) Data) + Data->ElementListOffset);

    if (Data->SearchStructureOffset != 0)
        SearchStructure = (PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE) (((ULONG_PTR) Data) + Data->SearchStructureOffset);

    if (Data->UserDataOffset != 0)
        UserData = (PVOID) (((ULONG_PTR) Data) + Data->UserDataOffset);

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgStringSectionFlags), s_rgStringSectionFlags, buffFlags);

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_STRING_SECTION_HEADER %p\n"
            "%S   Magic = 0x%08lx\n"
            "%S   HeaderSize = %lu (0x%lx)\n"
            "%S   FormatVersion = %lu\n"
            "%S   DataFormatVersion = %u\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Data,
            PLP, Data->Magic,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->FormatVersion,
            PLP, Data->DataFormatVersion,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));

        ::FusionpDbgPrintEx(
            Level,
            "%S   ElementCount = %lu\n"
            "%S   ElementListOffset = %lu (0x%lx) (-> %p)\n"
            "%S   HashAlgorithm = %lu\n"
            "%S   SearchStructureOffset = %lu (0x%lx) (-> %p)\n"
            "%S   UserDataOffset = %lu (0x%lx) (-> %p)\n"
            "%S   UserDataSize = %lu (0x%lx)\n",
            PLP, Data->ElementCount,
            PLP, Data->ElementListOffset, Data->ElementListOffset, ElementList,
            PLP, Data->HashAlgorithm,
            PLP, Data->SearchStructureOffset, Data->SearchStructureOffset, SearchStructure,
            PLP, Data->UserDataOffset, Data->UserDataOffset, UserData,
            PLP, Data->UserDataSize, Data->UserDataSize);

        if (UserData != NULL)
        {
            ::FusionpDbgPrintEx(
                Level,
                "%S   User data at %p (%d bytes)\n",
                PLP, UserData, Data->UserDataSize);

            rbuffPLP.Win32Append(L"   ", 3);
            FusionpDbgPrintBlob(Level, UserData, Data->UserDataSize, rbuffPLP);
            rbuffPLP.Left(cchPLP);
            PLP = rbuffPLP;
        }
    }
    else
    {
        // let's figure out the brief output key size
        cchBriefOutputKey = 3;

        if (ElementList != NULL)
        {
            ULONG i;

            for (i=0; i<Data->ElementCount; i++)
            {
                SIZE_T cch = ElementList[i].KeyLength / sizeof(WCHAR);

                if (cch > cchBriefOutputKey)
                    cchBriefOutputKey = cch;
            }
        }

        if (cchBriefOutputKey > 64)
            cchBriefOutputKey = 64;

        // Abuse the brief output buffer temporarily...
        buffBriefOutput.Win32Assign(L"Key................................................................", // 64 dots
            cchBriefOutputKey);

        ::FusionpDbgPrintEx(
            Level,
            "%S%s string section (%lu entr%s; Flags: %S)\n"
            "%S   %S | Value\n",
            PLP, SectionName, Data->ElementCount, Data->ElementCount == 1 ? "y" : "ies", static_cast<PCWSTR>(buffFlags),
            PLP, static_cast<PCWSTR>(buffBriefOutput));
    }

    if (fFull && (SearchStructure != NULL))
    {
        PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET BucketTable = NULL;

        if (SearchStructure->BucketTableOffset != 0)
            BucketTable = (PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET) (((ULONG_PTR) Data) + SearchStructure->BucketTableOffset);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE %p\n"
            "%S      BucketTableEntryCount = %u\n"
            "%S      BucketTableOffset = %d (-> %p)\n",
            PLP, SearchStructure,
            PLP, SearchStructure->BucketTableEntryCount,
            PLP, SearchStructure->BucketTableOffset, BucketTable);

        if (BucketTable != NULL)
        {
            ULONG i;

            for (i=0; i<SearchStructure->BucketTableEntryCount; i++)
            {
                PLONG Entries = NULL;

                if (BucketTable[i].ChainOffset != 0)
                    Entries = (PLONG) (((ULONG_PTR) Data) + BucketTable[i].ChainOffset);

                ::FusionpDbgPrintEx(
                    Level,
                    "%S      ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET %p\n"
                    "%S         ChainCount = %u\n"
                    "%S         ChainOffset = %d (-> %p)\n",
                    PLP, &BucketTable[i],
                    PLP, BucketTable[i].ChainCount,
                    PLP, BucketTable[i].ChainOffset, Entries);

                if (Entries != NULL)
                {
                    ULONG j;

                    for (j=0; j<BucketTable[i].ChainCount; j++)
                    {
                        PVOID Entry = NULL;

                        if (Entries[j] != 0)
                            Entry = (PVOID) (((ULONG_PTR) Data) + Entries[j]);

                        ::FusionpDbgPrintEx(
                            Level,
                            "%S         Chain[%d] = %d (-> %p)\n",
                            PLP, j, Entries[j], Entry);
                    }
                }
            }
        }
    }

    if (ElementList != NULL)
    {
        ULONG i;

        for (i=0; i<Data->ElementCount; i++)
        {
            UNICODE_STRING s;
            PVOID EntryData = NULL;

            s.Length = static_cast<USHORT>(ElementList[i].KeyLength);
            s.MaximumLength = s.Length;
            s.Buffer = (PWSTR) (((ULONG_PTR) Data) + ElementList[i].KeyOffset);

            if (ElementList[i].Offset != 0)
                EntryData = (PVOID) (((ULONG_PTR) Data) + ElementList[i].Offset);

            if (fFull)
            {
                ::FusionpDbgPrintEx(
                    Level,
                    "%S   ACTIVATION_CONTEXT_STRING_SECTION_ENTRY #%d - %p\n"
                    "%S      AssemblyRosterIndex = %u\n"
                    "%S      PseudoKey = %u\n",
                    PLP, i, &ElementList[i],
                    PLP, ElementList[i].AssemblyRosterIndex,
                    PLP, ElementList[i].PseudoKey);

                ::FusionpDbgPrintEx(
                    Level,
                    "%S      String = \"%wZ\"\n"
                    "%S      Offset = %d (-> %p)\n"
                    "%S      Length = %u\n",
                    PLP, &s,
                    PLP, ElementList[i].Offset, EntryData,
                    PLP, ElementList[i].Length);
            }
            else
            {
                // Abuse the flags buffer so we can truncate the name as necessary...
                SIZE_T cchKey = s.Length / sizeof(WCHAR);
                PCWSTR pszKey = s.Buffer;

                if (cchKey > cchBriefOutputKey)
                {
                    pszKey += (cchKey - cchBriefOutputKey);
                    cchKey = cchBriefOutputKey;
                }

                buffFlags.Win32AssignFill(L' ', (cchBriefOutputKey - cchKey));
                buffFlags.Win32Append(pszKey, cchKey);

                buffBriefOutput.Win32ResizeBuffer(cchPLP + 3 + cchBriefOutputKey + 4, eDoNotPreserveBufferContents);

                buffBriefOutput.Win32Format(
                    L"%s   %s | ",
                    PLP, static_cast<PCWSTR>(buffFlags));
            }

            if (EntryData != NULL)
            {

                if (ExtensionGuid == NULL)
                {
                    rbuffPLP.Win32Append(L"      ", 6);

                    switch (SectionId)
                    {
                    default:
                        if (fFull)
                            ::FusionpDbgPrintBlob(Level, EntryData, ElementList[i].Length, rbuffPLP);
                        else
                            buffBriefOutput.Win32Append(
                                L"<untranslatable value>",
                                22);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION:
                        ::SxspDbgPrintAssemblyInformation(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION:
                        ::SxspDbgPrintDllRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION:
                        ::SxspDbgPrintWindowClassRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION:
                        ::SxspDbgPrintComProgIdRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;
                    }

                    rbuffPLP.Left(cchPLP);
                    PLP = rbuffPLP;
                }
            }

            if (!fFull)
                ::FusionpDbgPrintEx(Level, "%S\n", static_cast<PCWSTR>(buffBriefOutput));
        }
    }
}

VOID
SxspDbgPrintActivationContextGuidSection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    SIZE_T cchPLP = rbuffPLP.Cch();
    CSmallStringBuffer buffFlags;
    CSmallStringBuffer buffBriefOutput;

    PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE SearchStructure = NULL;
    PVOID UserData = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgGuidSectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER, "Inorder")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Data->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY) (((ULONG_PTR) Data) + Data->ElementListOffset);

    if (Data->SearchStructureOffset != 0)
        SearchStructure = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE) (((ULONG_PTR) Data) + Data->SearchStructureOffset);

    if (Data->UserDataOffset != 0)
        UserData = (PVOID) (((ULONG_PTR) Data) + Data->UserDataOffset);

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgGuidSectionFlags), s_rgGuidSectionFlags, buffFlags);

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_GUID_SECTION_HEADER %p\n"
            "%S   Magic = 0x%08lx\n"
            "%S   HeaderSize = %u\n"
            "%S   FormatVersion = %u\n"
            "%S   DataFormatVersion = %u\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Data,
            PLP, Data->Magic,
            PLP, Data->HeaderSize,
            PLP, Data->FormatVersion,
            PLP, Data->DataFormatVersion,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));

        ::FusionpDbgPrintEx(
            Level,
            "%S   ElementCount = %u\n"
            "%S   ElementListOffset = %d (-> %p)\n"
            "%S   SearchStructureOffset = %d (-> %p)\n"
            "%S   UserDataOffset = %d (-> %p)\n"
            "%S   UserDataSize = %u\n",
            PLP, Data->ElementCount,
            PLP, Data->ElementListOffset, ElementList,
            PLP, Data->SearchStructureOffset, SearchStructure,
            PLP, Data->UserDataOffset, UserData,
            PLP, Data->UserDataSize);

        if (UserData != NULL)
        {
            ::FusionpDbgPrintEx(
                Level,
                "%S   User data at %p (%d bytes)\n",
                PLP, UserData, Data->UserDataSize);

            rbuffPLP.Win32Append(L"   ", 3);
            FusionpDbgPrintBlob(Level, UserData, Data->UserDataSize, rbuffPLP);
            rbuffPLP.Left(cchPLP);
            PLP = rbuffPLP;
        }
    }
    else
    {
        ::FusionpDbgPrintEx(
            Level,
            "%S%s guid section (%lu entr%s; Flags: %S)\n"
            "%S   Key................................... | Value\n",
            PLP, SectionName, Data->ElementCount, Data->ElementCount == 1 ? "y" : "ies", static_cast<PCWSTR>(buffFlags),
            PLP);
    }

    if (fFull && (SearchStructure != NULL))
    {
        PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET BucketTable = NULL;

        if (SearchStructure->BucketTableOffset != 0)
            BucketTable = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET) (((ULONG_PTR) Data) + SearchStructure->BucketTableOffset);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE %p\n"
            "%S      BucketTableEntryCount = %u\n"
            "%S      BucketTableOffset = %d (-> %p)\n",
            PLP, SearchStructure,
            PLP, SearchStructure->BucketTableEntryCount,
            PLP, SearchStructure->BucketTableOffset, BucketTable);

        if (BucketTable != NULL)
        {
            ULONG i;

            for (i=0; i<SearchStructure->BucketTableEntryCount; i++)
            {
                PLONG Entries = NULL;

                if (BucketTable[i].ChainOffset != 0)
                    Entries = (PLONG) (((ULONG_PTR) Data) + BucketTable[i].ChainOffset);

                ::FusionpDbgPrintEx(
                    Level,
                    "%S      ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET %p\n"
                    "%S         ChainCount = %u\n"
                    "%S         ChainOffset = %d (-> %p)\n",
                    PLP, &BucketTable[i],
                    PLP, BucketTable[i].ChainCount,
                    PLP, BucketTable[i].ChainOffset, Entries);

                if (Entries != NULL)
                {
                    ULONG j;

                    for (j=0; j<BucketTable[i].ChainCount; j++)
                    {
                        PVOID Entry = NULL;

                        if (Entries[j] != 0)
                            Entry = (PVOID) (((ULONG_PTR) Data) + Entries[j]);

                        ::FusionpDbgPrintEx(
                            Level,
                            "%S         Chain[%d] = %d (-> %p)\n",
                            PLP, j, Entries[j], Entry);
                    }
                }
            }
        }
    }

    if (ElementList != NULL)
    {
        ULONG i;
        CSmallStringBuffer buffFormattedGuid;

        for (i=0; i<Data->ElementCount; i++)
        {
            PVOID EntryData = NULL;

            ::SxspFormatGUID(ElementList[i].Guid, buffFormattedGuid);

            if (ElementList[i].Offset != 0)
                EntryData = (PVOID) (((ULONG_PTR) Data) + ElementList[i].Offset);

            if (fFull)
            {
                ::FusionpDbgPrintEx(
                    Level,
                    "%S   ACTIVATION_CONTEXT_GUID_SECTION_ENTRY #%d - %p\n"
                    "%S      Guid = %S\n"
                    "%S      AssemblyRosterIndex = %u\n",
                    PLP, i, &ElementList[i],
                    PLP, static_cast<PCWSTR>(buffFormattedGuid),
                    PLP, ElementList[i].AssemblyRosterIndex);

                ::FusionpDbgPrintEx(
                    Level,
                    "%S      Offset = %d (-> %p)\n"
                    "%S      Length = %u\n",
                    PLP, ElementList[i].Offset, EntryData,
                    PLP, ElementList[i].Length);
            }
            else
            {
                buffBriefOutput.Win32ResizeBuffer(cchPLP + 3 + 38 + 4, eDoNotPreserveBufferContents);
                buffBriefOutput.Win32Format(L"%s   %38s | ", PLP, static_cast<PCWSTR>(buffFormattedGuid));
            }

            if (EntryData != NULL)
            {
                if (ExtensionGuid == NULL)
                {
                    rbuffPLP.Win32Append(L"      ", 6);

                    switch (SectionId)
                    {
                    default:
                        ::FusionpDbgPrintBlob(Level, EntryData, ElementList[i].Length, rbuffPLP);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION:
                        ::SxspDbgPrintComServerRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION:
                        ::SxspDbgPrintComInterfaceRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION:
                        ::SxspDbgPrintTypeLibraryRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES:
                        ::SxspDbgPrintClrSurrogateTable(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE)EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;
                    }

                    rbuffPLP.Left(cchPLP);
                    PLP = rbuffPLP;
                }
            }

            if (!fFull)
                ::FusionpDbgPrintEx(Level, "%S\n", static_cast<PCWSTR>(buffBriefOutput));
        }
    }
}

VOID
SxspDbgPrintAssemblyInformation(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    UNICODE_STRING s2, s3, s5, strIdentity;
    CSmallStringBuffer buffManifestLastWriteTime;
    CSmallStringBuffer buffPolicyLastWriteTime;
    CSmallStringBuffer buffFlags;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgAssemblyInformationFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY, "Root Assembly")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED, "Policy Applied")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED, "Assembly Policy Applied")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED, "Root Policy Applied")
    };

    if (PLP == NULL)
        PLP = L"";

#define GET_STRING(_var, _elem) \
    if (Entry-> _elem ## Length != 0) \
    { \
        (_var).Length = (_var).MaximumLength = static_cast<USHORT>(Entry-> _elem ## Length); \
        (_var).Buffer = reinterpret_cast<PWSTR>(((LONG_PTR) Header) + Entry-> _elem ## Offset); \
    } \
    else \
    { \
        (_var).Length = (_var).MaximumLength = 0; \
        (_var).Buffer = NULL; \
        }

    GET_STRING(s2, ManifestPath);
    GET_STRING(s3, PolicyPath);
    GET_STRING(s5, AssemblyDirectoryName);

#undef GET_STRING

    // prepare data for print

    ::SxspFormatFileTime(Entry->ManifestLastWriteTime, buffManifestLastWriteTime);
    ::SxspFormatFileTime(Entry->PolicyLastWriteTime, buffPolicyLastWriteTime);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgAssemblyInformationFlags), s_rgAssemblyInformationFlags, buffFlags);

    if (Entry->EncodedAssemblyIdentityOffset != 0)
    {
        strIdentity.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->EncodedAssemblyIdentityOffset);
        strIdentity.Length = static_cast<USHORT>(Entry->EncodedAssemblyIdentityLength);
        strIdentity.MaximumLength = static_cast<USHORT>(Entry->EncodedAssemblyIdentityLength);
    }
    else
    {
        strIdentity.Buffer = NULL;
        strIdentity.Length = 0;
        strIdentity.MaximumLength = 0;
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION %p\n"
            "%S   Size = %lu\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags));

        ::FusionpDbgPrintEx(
            Level,
            "%S   EncodedIdentity = %wZ\n",
            PLP, &strIdentity);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ManifestPathType = %lu\n"
            "%S   ManifestPath = \"%wZ\"\n",
            PLP, Entry->ManifestPathType,
            PLP, &s2);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ManifestLastWriteTime = %S\n",
            PLP, static_cast<PCWSTR>(buffManifestLastWriteTime));

        ::FusionpDbgPrintEx(
            Level,
            "%S   PolicyPathType = %lu\n"
            "%S   PolicyPath = \"%wZ\"\n"
            "%S   PolicyLastWriteTime = %S\n",
            PLP, Entry->PolicyPathType,
            PLP, &s3,
            PLP, static_cast<PCWSTR>(buffPolicyLastWriteTime));

        ::FusionpDbgPrintEx(
            Level,
            "%S   MetadataSatelliteRosterIndex = %lu\n"
            "%S   ManifestVersionMajor = %u\n"
            "%S   ManifestVersionMinor = %u\n",
            PLP, Entry->MetadataSatelliteRosterIndex,
            PLP, Entry->ManifestVersionMajor,
            PLP, Entry->ManifestVersionMinor);

        ::FusionpDbgPrintEx(
            Level,
            "%S   AssemblyDirectoryName = \"%wZ\"\n",
            PLP, &s5);
    }
    else
    {
        // abuse buffManifestLastWriteTime
        buffManifestLastWriteTime.Win32ResizeBuffer(((strIdentity.Length + s2.Length) / sizeof(WCHAR)) + 4, eDoNotPreserveBufferContents);
        buffManifestLastWriteTime.Win32Format(L"%wZ \"%wZ\"", &strIdentity, &s2);
        rbuffBriefOutput.Win32Append(buffManifestLastWriteTime);
    }
}

VOID
SxspDbgPrintDllRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT PathSegments = NULL;
    CSmallStringBuffer buffFlags;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgDllRedirectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME, "Includes Base Name")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT, "Omits Assembly Root")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND, "Req. EnvVar Expansion")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Entry->PathSegmentOffset != 0)
        PathSegments = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT) (((ULONG_PTR) Header) + Entry->PathSegmentOffset);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgDllRedirectionFlags), s_rgDllRedirectionFlags, buffFlags);

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_DLL_REDIRECTION %p\n"
            "%S   Size = %u\n"
            "%S   Flags = 0x%08lx (%S)\n"
            "%S   TotalPathLength = %u (%u chars)\n"
            "%S   PathSegmentCount = %u\n"
            "%S   PathSegmentOffset = %d (-> %p)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags),
            PLP, Entry->TotalPathLength, Entry->TotalPathLength / sizeof(WCHAR),
            PLP, Entry->PathSegmentCount,
            PLP, Entry->PathSegmentOffset, PathSegments);
    }
    else
        rbuffBriefOutput.Win32Append(L"\"", 1);

    if (PathSegments != NULL)
    {
        ULONG i;

        for (i=0; i<Entry->PathSegmentCount; i++)
        {
            PCWSTR pwch = NULL;
            UNICODE_STRING s;

            if (PathSegments[i].Offset != 0)
            {
                pwch = (PCWSTR) (((ULONG_PTR) Header) + PathSegments[i].Offset);

                s.MaximumLength = static_cast<USHORT>(PathSegments[i].Length);
                s.Length = static_cast<USHORT>(PathSegments[i].Length);
                s.Buffer = (PWSTR) pwch;
            }
            else
            {
                s.MaximumLength = 0;
                s.Length = 0;
                s.Buffer = NULL;
            }

            if (fFull)
            {
                ::FusionpDbgPrintEx(
                    Level,
                    "%S   ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT #%d - %p\n"
                    "%S      Length = %u (%u chars)\n"
                    "%S      Offset = %d (-> %p)\n"
                    "%S         \"%wZ\"\n",
                    PLP, i, &PathSegments[i],
                    PLP, PathSegments[i].Length, PathSegments[i].Length / sizeof(WCHAR),
                    PLP, PathSegments[i].Offset, pwch,
                    PLP, &s);
            }
            else
            {
                rbuffBriefOutput.Win32Append(s.Buffer, s.Length / sizeof(WCHAR));
            }
        }
    }

    if (!fFull)
    {
        rbuffBriefOutput.Win32Append(L"\" (Flags: ", 10);
        rbuffBriefOutput.Win32Append(buffFlags);
        rbuffBriefOutput.Win32Append(L")", 1);
    }
}

VOID
SxspDbgPrintWindowClassRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    UNICODE_STRING s1, s2;
    CSmallStringBuffer buffFlags;

#if 0 // replace when the list of flags is non-empty
    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgWCRedirectionFlags[] =
    {
    };
#endif // 0

    if (PLP == NULL)
        PLP = L"";

    memset(&s1, 0, sizeof(s1));
    memset(&s2, 0, sizeof(s2));

    ::FusionpFormatFlags(
        Entry->Flags,
        fFull,
#if 0 // replace when the list of flags is nonempty
        NUMBER_OF(s_rgWCRedirectionFlags), s_rgWCRedirectionFlags,
#else
        0, NULL,
#endif
        buffFlags);

    if (Entry->VersionSpecificClassNameOffset != 0)
    {
        s1.Length = static_cast<USHORT>(Entry->VersionSpecificClassNameLength);
        s1.MaximumLength = s1.Length;
        s1.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->VersionSpecificClassNameOffset);
    }

    if (Entry->DllNameOffset != 0)
    {
        s2.Length = static_cast<USHORT>(Entry->DllNameLength);
        s2.MaximumLength = s2.Length;
        s2.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->DllNameOffset);
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION %p\n"
            "%S   Size = %u\n"
            "%S   Flags = 0x%08lx\n"
            "%S   VersionSpecificClassNameLength = %u (%u chars)\n"
            "%S   VersionSpecificClassNameOffset = %d (-> %p)\n"
            "%S      \"%wZ\"\n"
            "%S   DllNameLength = %u (%u chars)\n"
            "%S   DllNameOffset = %d (-> %p)\n"
            "%S      \"%wZ\"\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->VersionSpecificClassNameLength, Entry->VersionSpecificClassNameLength / sizeof(WCHAR),
            PLP, Entry->VersionSpecificClassNameOffset, s1.Buffer,
            PLP, &s1,
            PLP, Entry->DllNameLength, Entry->DllNameLength / sizeof(WCHAR),
            PLP, Entry->DllNameOffset, s2.Buffer,
            PLP, &s2);
    }
    else
    {
        rbuffBriefOutput.Win32Append(s1.Buffer, s1.Length / sizeof(WCHAR));
        rbuffBriefOutput.Win32Append(L" in ", 4);
        rbuffBriefOutput.Win32Append(s2.Buffer, s2.Length / sizeof(WCHAR));
        rbuffBriefOutput.Win32Append(L" (Flags: ", 9);
        rbuffBriefOutput.Win32Append(buffFlags);
        rbuffBriefOutput.Win32Append(L")", 1);
    }
}


VOID
SxspDbgPrintClrSurrogateTable(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffGuid;
    UNICODE_STRING RuntimeVersion = RTL_CONSTANT_STRING(L"<No runtime version>");
    UNICODE_STRING TypeName = RTL_CONSTANT_STRING(L"<No type name>");

    if (PLP == NULL)
        PLP = L"";

    ::SxspFormatGUID(Entry->SurrogateIdent, buffGuid);

    if (Entry->VersionOffset != 0)
    {
        RuntimeVersion.MaximumLength = RuntimeVersion.Length = static_cast<USHORT>(Entry->VersionLength);
        RuntimeVersion.Buffer = (PWSTR)(((ULONG_PTR)Entry) + Entry->VersionOffset);
    }

    if (Entry->TypeNameOffset != 0)
    {
        TypeName.MaximumLength = TypeName.Length = static_cast<USHORT>(Entry->TypeNameLength);
        TypeName.Buffer = (PWSTR)(((ULONG_PTR)Entry) + Entry->TypeNameOffset);
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_NDP_INTEROP %p\n"
            "%S   Size = %u\n"
            "%S   Flags = 0x%08lx\n"
            "%S   SurrogateIdent = %S\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, static_cast<PCWSTR>(buffGuid));

        ::FusionpDbgPrintEx(
            Level,
            "%S   AssemblyName [Offset %u (-> %p), Length %u] = \"%wZ\"\n"
            "%S   RuntimeVersion [Offset %u (-> %p), Length %u] = \"%wZ\"\n",
            PLP, Entry->TypeNameOffset, TypeName.Buffer, Entry->TypeNameLength, &TypeName,
            PLP, Entry->VersionOffset, RuntimeVersion.Buffer, Entry->VersionLength, &RuntimeVersion
            );
    }
    else
    {
        rbuffBriefOutput.Win32Append(buffGuid);
        rbuffBriefOutput.Win32Append(L" runtime: '", NUMBER_OF(L" runtime: '")-1);
        rbuffBriefOutput.Win32Append(&RuntimeVersion);
        rbuffBriefOutput.Win32Append(L"' typename: '", NUMBER_OF(L"' typename: '")-1);
        rbuffBriefOutput.Win32Append(&TypeName);
        rbuffBriefOutput.Win32Append(L"'", 1);
    }
    
}


VOID
SxspDbgPrintComServerRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffConfiguredClsid;
    CSmallStringBuffer buffImplementedClsid;
    CSmallStringBuffer buffReferenceClsid;
    CSmallStringBuffer buffTypeLibraryId;
    CSmallStringBuffer buffThreadingModel;
    UNICODE_STRING s;
    UNICODE_STRING progid;

    if (PLP == NULL)
        PLP = L"";

    memset(&s, 0, sizeof(s));

    ::SxspFormatGUID(Entry->ReferenceClsid, buffReferenceClsid);
    ::SxspFormatGUID(Entry->ConfiguredClsid, buffConfiguredClsid);
    ::SxspFormatGUID(Entry->ImplementedClsid, buffImplementedClsid);

    if (Entry->TypeLibraryId == GUID_NULL)
        buffTypeLibraryId.Win32Assign(L"<none>", 6);
    else
        ::SxspFormatGUID(Entry->TypeLibraryId, buffTypeLibraryId);

    ::SxspFormatThreadingModel(Entry->ThreadingModel, buffThreadingModel);

    if (Entry->ModuleOffset != 0)
    {
        s.Length = static_cast<USHORT>(Entry->ModuleLength);
        s.MaximumLength = s.Length;
        s.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->ModuleOffset);
    }

    if (Entry->ProgIdOffset != 0)
    {
        progid.Length = static_cast<USHORT>(Entry->ProgIdLength);
        progid.MaximumLength = progid.Length;
        progid.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->ProgIdOffset);
    }
    else
    {
        progid.Length = 0;
        progid.MaximumLength = 0;
        progid.Buffer = NULL;
    }

    if (fFull)
    {
        PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM ShimData = NULL;

        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION %p\n"
            "%S   Size = %u\n"
            "%S   Flags = 0x%08lx\n"
            "%S   ThreadingModel = %u (%S)\n"
            "%S   ReferenceClsid = %S\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->ThreadingModel, static_cast<PCWSTR>(buffThreadingModel),
            PLP, static_cast<PCWSTR>(buffReferenceClsid));

        ::FusionpDbgPrintEx(
            Level,
            "%S   ConfiguredClsid = %S\n"
            "%S   ImplementedClsid = %S\n"
            "%S   TypeLibraryId = %S\n"
            "%S   ModuleLength = %u (%u chars)\n"
            "%S   ModuleOffset = %d (-> %p)\n"
            "%S      \"%wZ\"\n",
            PLP, static_cast<PCWSTR>(buffConfiguredClsid),
            PLP, static_cast<PCWSTR>(buffImplementedClsid),
            PLP, static_cast<PCWSTR>(buffTypeLibraryId),
            PLP, Entry->ModuleLength, Entry->ModuleLength / sizeof(WCHAR),
            PLP, Entry->ModuleOffset, s.Buffer,
            PLP, &s);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ProgIdLength = %lu\n"
            "%S   ProgIdOffset = %ld (-> %p)\n"
            "%S      \"%wZ\"\n",
            PLP, Entry->ProgIdLength,
            PLP, Entry->ProgIdOffset, progid.Buffer,
            PLP, &progid);

        if (Entry->ShimDataOffset != 0)
            ShimData = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM) (((ULONG_PTR) Entry) + Entry->ShimDataOffset);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ShimDataLength = %lu\n"
            "%S   ShimDataOffset = %ld (-> %p)\n",
            PLP, Entry->ShimDataLength,
            PLP, Entry->ShimDataOffset, ShimData);

        if (ShimData != NULL)
        {
            ::FusionpDbgPrintEx(
                Level,
                "%S      Size = %lu\n"
                "%S      Flags = 0x%08lx\n"
                "%S      Type = %lu\n",
                PLP, ShimData->Size,
                PLP, ShimData->Flags,
                PLP, ShimData->Type);

            if (ShimData->ModuleOffset != 0)
            {
                s.Buffer = (PWSTR) (((ULONG_PTR) Header) + ShimData->ModuleOffset);
                s.Length = (USHORT) ShimData->ModuleLength;
                s.MaximumLength = (USHORT) ShimData->ModuleLength;
            }
            else
            {
                s.Buffer = NULL;
                s.Length = 0;
                s.MaximumLength = 0;
            }

            ::FusionpDbgPrintEx(
                Level,
                "%S      ModuleLength = %lu\n"
                "%S      ModuleOffset = %lu (-> %p)\n"
                "%S         \"%wZ\"\n",
                PLP, ShimData->ModuleLength,
                PLP, ShimData->ModuleOffset, s.Buffer,
                PLP, &s);

            if (ShimData->TypeOffset != 0)
            {
                s.Buffer = (PWSTR) (((ULONG_PTR) ShimData) + ShimData->TypeOffset);
                s.Length = (USHORT) ShimData->TypeLength;
                s.MaximumLength = (USHORT) ShimData->TypeLength;
            }
            else
            {
                s.Buffer = NULL;
                s.Length = 0;
                s.MaximumLength = 0;
            }

            ::FusionpDbgPrintEx(
                Level,
                "%S      TypeLength = %lu\n"
                "%S      TypeOffset = %lu (-> %p)\n"
                "%S         \"%wZ\"\n",
                PLP, ShimData->TypeLength,
                PLP, ShimData->TypeOffset, s.Buffer,
                PLP, &s);

            if (ShimData->ShimVersionOffset != 0)
            {
                s.Buffer = (PWSTR) (((ULONG_PTR) ShimData) + ShimData->ShimVersionOffset);
                s.Length = (USHORT) ShimData->ShimVersionLength;
                s.MaximumLength = (USHORT) ShimData->ShimVersionLength;
            }
            else
            {
                s.Buffer = NULL;
                s.Length = 0;
                s.MaximumLength = 0;
            }

            ::FusionpDbgPrintEx(
                Level,
                "%S      ShimVersionLength = %lu\n"
                "%S      ShimVersionOffset = %lu (-> %p)\n"
                "%S         \"%wZ\"\n",
                PLP, ShimData->ShimVersionLength,
                PLP, ShimData->ShimVersionOffset, s.Buffer,
                PLP, &s);
        }
    }
    else
    {
        rbuffBriefOutput.Win32Append(buffConfiguredClsid);

        rbuffBriefOutput.Win32Append(L" ", 1);
        rbuffBriefOutput.Win32Append(s.Buffer, s.Length / sizeof(WCHAR));
        if (progid.Length != 0)
        {
            rbuffBriefOutput.Win32Append(L" progid: ", 9);
            rbuffBriefOutput.Win32Append(progid.Buffer, progid.Length / sizeof(WCHAR));
        }
    }

}

VOID
FusionpDbgPrintStringInUntruncatedChunks(
    ULONG   Level,
    PCWSTR  String,
    SIZE_T  Length
    )
//
// in pieces so it does not get truncated by DbgPrint (or we could use OutputDebugString, which
// does this same work)
//
{
    if (!::FusionpDbgWouldPrintAtFilterLevel(Level))
        return;
    while (Length != 0)
    {
        SIZE_T ShortLength = ((Length > 128) ? 128 : Length);

        CUnicodeString UnicodeString(String, ShortLength);
        ::FusionpDbgPrintEx(Level, "%wZ", &UnicodeString);

        Length -= ShortLength;
        String += ShortLength;
    }
}

VOID
FusionpDbgPrintStringInUntruncatedChunks(
    ULONG Level,
    const CBaseStringBuffer &rbuff
    )
{
    if (!::FusionpDbgWouldPrintAtFilterLevel(Level))
        return;

    FusionpDbgPrintStringInUntruncatedChunks(Level, rbuff, rbuff.Cch());
}

VOID
SxspDbgPrintTypeLibraryRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    if (!::FusionpDbgWouldPrintAtFilterLevel(Level))
        return;

    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buff;

    UNICODE_STRING Name = RTL_CONSTANT_STRING(L"");
    UNICODE_STRING HelpDir = RTL_CONSTANT_STRING(L"");
    ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION Version = { 0 };

    if (!buff.Win32ResizeBuffer(4096, eDoNotPreserveBufferContents))
        return;

#if 1
#define GET_STRING(ntstr, struc, struc_size, offset_field, length_field, base) \
    do { if (RTL_CONTAINS_FIELD((struc), (struc_size), offset_field) \
          && RTL_CONTAINS_FIELD((struc), (struc_size), length_field) \
          && (struc)->offset_field != 0  \
          && (struc)->length_field != 0) \
    { \
        (ntstr).Length = static_cast<USHORT>(struc->length_field - sizeof((ntstr).Buffer[0])); \
        (ntstr).Buffer = const_cast<PWSTR>(reinterpret_cast<PCWSTR>(struc->offset_field + reinterpret_cast<PCBYTE>(base))); \
    } } while(0)

    GET_STRING(Name, Entry, Entry->Size, NameOffset, NameLength, Header);
    GET_STRING(HelpDir, Entry, Entry->Size, HelpDirOffset, HelpDirLength, Entry);

#undef GET_STRING

#else

    if (RTL_CONTAINS_FIELD(Entry, Entry->Size, NameLength)
        && RTL_CONTAINS_FIELD(Entry, Entry->Size, NameOffset)
        && Entry->NameOffset != 0
        )
    {
        Name.Length = static_cast<USHORT>(Entry->NameLength);
        Name.Buffer = const_cast<PWSTR>(reinterpret_cast<PCWSTR>(Entry->NameOffset + reinterpret_cast<PCBYTE>(Header)));
    }

    if (RTL_CONTAINS_FIELD(Entry, Entry->Size, HelpDirLength)
        && RTL_CONTAINS_FIELD(Entry, Entry->Size, HelpDirOffset)
        && Entry->HelpDirOffset != 0
        )
    {
        HelpDir.Length = static_cast<USHORT>(Entry->HelpDirLength);
        HelpDir.Buffer = const_cast<PWSTR>(reinterpret_cast<PCWSTR>(Entry->HelpDirOffset + reinterpret_cast<PCBYTE>(Entry)));
    }

#endif

    if (RTL_CONTAINS_FIELD(Entry, Entry->Size, Version))
        Version = Entry->Version;

    if (!buff.Win32Format(
        L"%SACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION %p\n"
        L"%S   Size = 0x%lx\n"
        L"%S   Flags = 0x%lx\n"
        L"%S   Name = %wZ (offset 0x%lx + %p = %p)\n"
        L"%S   HelpDir = %wZ (offset 0x%lx + %p = %p)\n"
        L"%S   Version = 0x%lx.%lx\n",
        PLP, Entry,
        PLP, static_cast<ULONG>(Entry->Size),
        PLP, static_cast<ULONG>(Entry->Flags),
        PLP, &Name, static_cast<ULONG>(Entry->NameOffset), static_cast<PCVOID>(Header), static_cast<PCVOID>(Name.Buffer),
        PLP, &HelpDir, static_cast<ULONG>(Entry->HelpDirOffset), static_cast<PCVOID>(Entry), static_cast<PCVOID>(HelpDir.Buffer),
        PLP, static_cast<ULONG>(Version.Major), static_cast<ULONG>(Version.Minor)
        ))
        return;

    ::FusionpDbgPrintStringInUntruncatedChunks(Level, buff);
}

VOID
SxspDbgPrintComProgIdRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
//    CSmallStringBuffer buffFlags;
    CSmallStringBuffer buffClsid;
    const GUID *pcguid = NULL;

    if (Entry->ConfiguredClsidOffset != 0)
    {
        pcguid = (const GUID *) (((ULONG_PTR) Header) + Entry->ConfiguredClsidOffset);
        ::SxspFormatGUID(*pcguid, buffClsid);
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION %p\n"
            "%S   Size = %lu (0x%lx)\n"
            "%S   Flags = 0x%08lx\n"
            "%S   ConfiguredClsidOffset = %lu (-> %p)\n"
            "%S      %S\n",
            PLP, Entry,
            PLP, Entry->Size, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->ConfiguredClsidOffset, pcguid,
            PLP, static_cast<PCWSTR>(buffClsid));
    }
    else
    {
        rbuffBriefOutput.Win32Append(buffClsid);
    }
}

VOID
SxspDbgPrintComInterfaceRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffProxyStubClsid32;
    CSmallStringBuffer buffBaseInterface;
    CSmallStringBuffer buffFlags;
    CSmallStringBuffer buffTypeLibraryId;
    UNICODE_STRING s;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgComInterfaceFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID, "NumMethods Valid")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID, "BaseInterface Valid")
    };

    if (PLP == NULL)
        PLP = L"";

    memset(&s, 0, sizeof(s));

    ::SxspFormatGUID(Entry->ProxyStubClsid32, buffProxyStubClsid32);
    ::SxspFormatGUID(Entry->BaseInterface, buffBaseInterface);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgComInterfaceFlags), s_rgComInterfaceFlags, buffFlags);

    if (Entry->TypeLibraryId == GUID_NULL)
        buffTypeLibraryId.Win32Assign(L"<none>", 6);
    else
        ::SxspFormatGUID(Entry->TypeLibraryId, buffTypeLibraryId);

    if (Entry->NameOffset != 0)
    {
        s.Length = static_cast<USHORT>(Entry->NameLength);
        s.MaximumLength = s.Length;
        s.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->NameOffset);
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION %p\n"
            "%S   Size = %lu\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags));

        ::FusionpDbgPrintEx(
            Level,
            "%S   ProxyStubClsid32 = %S\n"
            "%S   NumMethods = %lu\n"
            "%S   TypeLibraryId = %S\n",
            PLP, static_cast<PCWSTR>(buffProxyStubClsid32),
            PLP, Entry->NumMethods,
            PLP, static_cast<PCWSTR>(buffTypeLibraryId));

        ::FusionpDbgPrintEx(
            Level,
            "%S   BaseInterface = %S\n"
            "%S   NameLength = %lu (%u chars)\n"
            "%S   NameOffset = %lu (-> %p)\n",
            PLP, static_cast<PCWSTR>(buffBaseInterface),
            PLP, Entry->NameLength, (Entry->NameLength / sizeof(WCHAR)),
            PLP, Entry->NameOffset, s.Buffer);

        ::FusionpDbgPrintEx(
            Level,
            "%S      \"%wZ\"\n",
            PLP, &s);
    }
    else
    {
        rbuffBriefOutput.Win32Append(buffProxyStubClsid32);
        rbuffBriefOutput.Win32Append(L" ", 1);
        rbuffBriefOutput.Win32Append(s.Buffer, s.Length / sizeof(WCHAR));
    }
}

VOID
SxspDbgPrintInstallSourceInfo(
    ULONG Level,
    bool fFull,
    PSXS_INSTALL_SOURCE_INFO Info,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    if ( !PLP ) PLP = L"SXS.DLL:";
    if ( !Info )
    {
        ::FusionpDbgPrintEx( Level, "%S InstallationInfo is null!\n", PLP );
    }
    else
    {
        DWORD dwFlags = Info->dwFlags;

        ::FusionpDbgPrintEx(
            Level,
            "%S InstallationInfo at 0x%08x - size = %d\n",
            "%S   Flag set: %s catalog, %s codebase, %s prompt, %s in setup mode\n"
            "%S   Codebase Name: %ls\n"
            "%S   Prompt: %ls\n",
            PLP, Info, Info->cbSize,
            PLP,
                dwFlags & SXSINSTALLSOURCE_HAS_CATALOG ? "has" : "no",
                dwFlags & SXSINSTALLSOURCE_HAS_CODEBASE ? "has" : "no",
                dwFlags & SXSINSTALLSOURCE_HAS_PROMPT ? "has" : "no",
                dwFlags & SXSINSTALLSOURCE_INSTALLING_SETUP ? "is" : "not",
            PLP, Info->pcwszCodebaseName,
            PLP, Info->pcwszPromptOnRefresh);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\filestream.h ===
#if !defined(_FUSION_SXS_FILESTREAM_H_INCLUDED_)
#define _FUSION_SXS_FILESTREAM_H_INCLUDED_

#pragma once

#include <objidl.h>
#include "fusionbytebuffer.h"
#include "impersonationdata.h"
#include "smartptr.h"

class CFileStreamBase : public IStream
{
public:
    SMARTTYPEDEF(CFileStreamBase);
    CFileStreamBase();
    virtual ~CFileStreamBase();

    virtual VOID OnRefCountZero() { /* default does nothing */ }

    BOOL OpenForRead(
        PCWSTR pszPath,
        const CImpersonationData &ImpersonationData,
        DWORD dwShareMode,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes
        );

    BOOL OpenForRead(
        PCWSTR pszPath,
        const CImpersonationData &ImpersonationData,
        DWORD dwShareMode,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        DWORD &rdwLastError,
        SIZE_T cExceptionalLastErrors,
        ...
        );

    BOOL OpenForWrite(
        PCWSTR pszPath,
        DWORD dwShareMode,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes
        );

    BOOL Close();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);

protected:
    ULONG               m_cRef;
    HANDLE              m_hFile;
    DWORD               m_grfMode;
private:
    CFileStreamBase(const CFileStreamBase &r); // intentionally not implemented
    CFileStreamBase &operator =(const CFileStreamBase &r); // intentionally not implemented
};

SMARTTYPE(CFileStreamBase);

enum FileStreamZeroRefCountBehavior
{
    eDeleteFileStreamOnZeroRefCount,
    eDoNotDeleteFileStreamOnZeroRefCount,
};

template <FileStreamZeroRefCountBehavior ezrcb> class CFileStreamTemplate : public CFileStreamBase
{
    typedef CFileStreamBase Base;
public:
    CFileStreamTemplate() : Base() { }

    virtual VOID OnRefCountZero() {
        if (ezrcb == eDeleteFileStreamOnZeroRefCount)
            FUSION_DELETE_SINGLETON(this);
    }

private:
    CFileStreamTemplate(const CFileStreamTemplate&); // intentionally not implemented
    void operator=(const CFileStreamTemplate&); // intentionally not implemented
};

typedef CFileStreamBase CFileStream;
typedef CFileStreamTemplate<eDeleteFileStreamOnZeroRefCount> CReferenceCountedFileStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\forwarddeclarations.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ForwardDeclarations.h

Abstract:

    Forward declare lots of struct, class, and union types,
	and pointer typedefs thereof.

Author:

    Jay Krell (a-JayK) December 2000

Environment:


Revision History:

--*/
#pragma once

#include "Preprocessor.h"

/*-----------------------------------------------------------------------------
This forward declares NT style structs, so you can declare uses of pointers
to them in headers without including the header that defines them, and without
referring to them as "struct _FOO*" but "PFOO" or "FOO*" instead.

The header that defines them should not use this macro, but stick to the
consistent style
typedef struct _FOO
{
    ..
} FOO, *PFOO;
typedef const FOO* PCFOO;
-----------------------------------------------------------------------------*/
#define FORWARD_NT_STRUCT(x) \
    struct PASTE(_,x); \
    typedef struct PASTE(_,x) x; \
    typedef x* PASTE(P,x); \
    typedef const x* PASTE(PC,x)

#define FORWARD_NT_UNION(x) \
    union PASTE(_,x); \
    typedef union PASTE(_,x) x; \
    typedef x* PASTE(P,x); \
    typedef const x* PASTE(PC,x)

#define FORWARD_CLASS(x) \
    class x; \
    typedef x* PASTE(P,x); \
    typedef const x* PASTE(PC,x)

FORWARD_NT_UNION(ACTCTXCTB_CALLBACK_DATA);
FORWARD_NT_STRUCT(ACTCTXCTB);
FORWARD_CLASS(ACTCTXCTB_INSTALLATION_CONTEXT);
FORWARD_NT_STRUCT(ACTCTXCTB_CLSIDMAPPING_CONTEXT);
FORWARD_NT_STRUCT(ACTCTXCTB_ASSEMBLY_CONTEXT);
FORWARD_NT_STRUCT(ACTCTXCTB_PARSE_CONTEXT);
FORWARD_NT_STRUCT(SXS_NODE_INFO);
FORWARD_NT_STRUCT(ACTCTXCTB_CBHEADER);
FORWARD_NT_STRUCT(ACTCTXCTB_CBPARSEENDING);
FORWARD_NT_STRUCT(ACTCTXCTB_CBPARSEBEGINNING);
FORWARD_NT_STRUCT(ASSEMBLY_IDENTITY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\filestream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Implementation of IStream over a win32 file.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "filestream.h"
#include "SxsExceptionHandling.h"

CFileStreamBase::CFileStreamBase() : m_cRef(0), m_hFile(INVALID_HANDLE_VALUE), m_grfMode(0)
{
}

CFileStreamBase::~CFileStreamBase()
{
    ASSERT_NTC(m_cRef == 0);

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        if ((m_grfMode & STGM_WRITE) == STGM_WRITE)
            ::FlushFileBuffers(m_hFile);
        ::CloseHandle(m_hFile);
        ple.Restore();
    }
}

BOOL
CFileStreamBase::OpenForWrite(
    PCWSTR pszPath,
    DWORD dwShareMode,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(pszPath != NULL);

    INTERNAL_ERROR_CHECK(m_hFile == INVALID_HANDLE_VALUE);

    IFW32INVALIDHANDLE_ORIGINATE_AND_EXIT(
		m_hFile = ::CreateFileW(
			pszPath,
			GENERIC_WRITE,
			dwShareMode,
			NULL,
			dwCreationDisposition, // default value is CREATE_ALWAYS
			dwFlagsAndAttributes,
			NULL));

    m_grfMode = STGM_WRITE | STGM_CREATE;

	FN_EPILOG
}

BOOL
CFileStreamBase::OpenForRead(
    PCWSTR pszPath,
    const CImpersonationData &ImpersonationData,
    DWORD dwShareMode,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes
    )
{
    DWORD dwWin32Error;

    return 
        this->OpenForRead(
            pszPath, 
            ImpersonationData, 
            dwShareMode, 
            dwCreationDisposition, 
            dwFlagsAndAttributes,
            dwWin32Error,
            0);
}

BOOL
CFileStreamBase::OpenForRead(
    PCWSTR pszPath,
    const CImpersonationData &ImpersonationData,
    DWORD dwShareMode,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    DWORD &rdwLastError,
    SIZE_T cExceptionalLastErrors,
    ...
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD dwLastError = ERROR_INTERNAL_ERROR;
    CImpersonate impersonate(ImpersonationData);

    rdwLastError = ERROR_SUCCESS;

    PARAMETER_CHECK(pszPath != NULL);
    INTERNAL_ERROR_CHECK(m_hFile == INVALID_HANDLE_VALUE);

    IFW32FALSE_EXIT(impersonate.Impersonate());

	::FusionpSetLastWin32Error(ERROR_SUCCESS);

    m_hFile = ::CreateFileW(
        pszPath,
        GENERIC_READ,
        dwShareMode,
        NULL,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        NULL);

    dwLastError = ::FusionpGetLastWin32Error();

    IFW32FALSE_EXIT(impersonate.Unimpersonate());
    m_grfMode = STGM_READ;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        va_list ap;
        SIZE_T i = 0;

        if (dwLastError == ERROR_SUCCESS) 
        {
            //
            // CreateFile always set lasterror to be 0 for an unexisted file even OPEN_EXISTING 
            // for GENERIC_READ, Fusion expect ERROR_FILE_NOT_FOUND in this case for some reason
            //
            ::FusionpSetLastWin32Error(ERROR_FILE_NOT_FOUND);
            dwLastError = ERROR_FILE_NOT_FOUND; // reset lLastError
        }

        va_start(ap, cExceptionalLastErrors);       
        for (i=0; i<cExceptionalLastErrors; i++)
        {
            if (dwLastError == va_arg(ap, DWORD))
            {
                rdwLastError = dwLastError;
                break;
            }
        }
        va_end(ap);
        if (i == cExceptionalLastErrors) // This gets the cExceptionalLastErrors == 0 case too.
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(%ls) gave error %ld\n",
                __FUNCTION__,
                pszPath,
				dwLastError);
            ORIGINATE_WIN32_FAILURE_AND_EXIT(CreateFileW, dwLastError);
        }
    }

	FN_EPILOG
}

BOOL
CFileStreamBase::Close()
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        if ((m_grfMode & STGM_WRITE) == STGM_WRITE)
        {
            if (!::FlushFileBuffers(m_hFile))
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %s - Error flushing file handle %p; win32 error = %ld\n", __FUNCTION__, m_hFile, ::FusionpGetLastWin32Error());
                CSxsPreserveLastError ple;
                ::CloseHandle(m_hFile);
                ple.Restore();
                m_hFile = INVALID_HANDLE_VALUE;
                goto Exit;
            }
        }

        if (!::CloseHandle(m_hFile))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Error closing file handle %p; ::FusionpGetLastWin32Error() = %d\n", m_hFile, ::FusionpGetLastWin32Error());
            m_hFile = INVALID_HANDLE_VALUE;
            goto Exit;
        }
        m_hFile = INVALID_HANDLE_VALUE;
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

ULONG
CFileStreamBase::AddRef()
{
    ULONG ulResult = 0;
    FN_TRACE_ADDREF(CFileStreamBase, ulResult);
    ulResult = ::InterlockedIncrement((LONG *) &m_cRef);
    return ulResult;
}

ULONG
CFileStreamBase::Release()
{
    ULONG ulRefCount = 0;
    FN_TRACE_RELEASE(CFileStreamBase, ulRefCount);
    ulRefCount = ::InterlockedDecrement((LONG *) &m_cRef);
    if (ulRefCount == 0)
        this->OnRefCountZero();
    return ulRefCount;
}

HRESULT
CFileStreamBase::QueryInterface(
    REFIID riid,
    PVOID *ppvObj
    )
{
    HRESULT hr = NOERROR;

    FN_TRACE_HR(hr);

    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        pIUnknown = static_cast<IStream *>(this);

    if (pIUnknown == NULL)
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    pIUnknown->AddRef();
    *ppvObj = pIUnknown;

    hr = NOERROR;

Exit:
    return hr;
}


HRESULT
CFileStreamBase::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ULONG cbRead = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    IFW32FALSE_ORIGINATE_AND_EXIT(::ReadFile(m_hFile, pv, cb, &cbRead, NULL));

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_VERBOSE,
        "SXS.DLL: CFileStreamBase::Read() got %d bytes from file.\n", cbRead);

    if (cbRead == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbRead != NULL)
        *pcbRead = cbRead;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Write(
    void const *pv,
    ULONG cb,
    ULONG *pcbWritten
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ULONG cbWritten = 0;

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    if (!::WriteFile(m_hFile, pv, cb, &cbWritten, NULL))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: CFileStreamBase::Write() calling ::WriteFile() failed; ::FusionpGetLastWin32Error() = %d\n", ::FusionpGetLastWin32Error());


        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_VERBOSE,
        "SXS.DLL: CFileStreamBase::Write() got %d bytes from file.\n", cbWritten);

    if (cbWritten == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    DWORD dwWin32Origin = 0;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    switch (dwOrigin)
    {
    default:
        hr = E_INVALIDARG;
        goto Exit;

    case STREAM_SEEK_SET:
        dwWin32Origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        dwWin32Origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        dwWin32Origin = FILE_END;
        break;
    }

    if (!::SetFilePointerEx(
                m_hFile,
                dlibMove,
                (LARGE_INTEGER *) plibNewPosition,
                dwWin32Origin))
    {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CFileStreamBase::SetSize(
    ULARGE_INTEGER libNewSize
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::SetSize() !!! NOT IMPLEMENTED !!!\n");

    UNUSED(libNewSize);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::CopyTo() !!! NOT IMPLEMENTED !!!\n");

    if (pcbRead != NULL)
        pcbRead->QuadPart = 0;

    if (pcbWritten != NULL)
        pcbWritten->QuadPart = 0;

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Commit(
    DWORD grfCommitFlags
    )
{
    HRESULT hr = NOERROR;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: Entered CFileStreamBase::Commit()\n");

    if (grfCommitFlags != 0)
        return E_INVALIDARG;

    if ( !Close())
        hr = HRESULT_FROM_WIN32 (::FusionpGetLastWin32Error());

    if (!SUCCEEDED(hr))
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s() failed; ::FusionpGetLastWin32Error() = %d\n", __FUNCTION__, ::FusionpGetLastWin32Error());
    else
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SXS.DLL: Leaving %s()\n", __FUNCTION__);

    return hr ;
}

HRESULT
CFileStreamBase::Revert()
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::Revert() !!! NOT IMPLEMENTED !!!\n");

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::LockRegion() !!! NOT IMPLEMENTED !!!\n");

    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::UnlockRegion() !!! NOT IMPLEMENTED !!!\n");

    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag
    )
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    FN_TRACE_HR(hr);
    BY_HANDLE_FILE_INFORMATION bhfi;

    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(*pstatstg));

    PARAMETER_CHECK(((grfStatFlag & ~(STATFLAG_NONAME)) == 0));
    PARAMETER_CHECK(pstatstg != NULL);

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s() does not handle STATFLAG_NONE; returning E_NOTIMPL.\n", __FUNCTION__);
        hr = E_NOTIMPL;
        goto Exit;
    }

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);
    IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileInformationByHandle(m_hFile, &bhfi));

    pstatstg->pwcsName = NULL;
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = bhfi.nFileSizeLow;
    pstatstg->cbSize.HighPart = bhfi.nFileSizeHigh;
    pstatstg->mtime = bhfi.ftLastWriteTime;
    pstatstg->ctime = bhfi.ftCreationTime;
    pstatstg->atime = bhfi.ftLastAccessTime;
    pstatstg->grfMode = m_grfMode;
    pstatstg->grfLocksSupported = LOCK_WRITE;
    pstatstg->clsid = GUID_NULL;
    pstatstg->grfStateBits = 0;
    pstatstg->reserved = 0;

    hr = NOERROR;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Clone(
    IStream **ppIStream
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::Clone() !!! NOT IMPLEMENTED !!!\n");

    if (ppIStream != NULL)
        *ppIStream = NULL;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\impersonationdata.h ===
#if !defined(_FUSION_SXS_IMPERSONATIONDATA_H_INCLUDED_)
#define _FUSION_SXS_IMPERSONATIONDATA_H_INCLUDED_

#pragma once

#include <sxsapi.h>

class CImpersonationData
{
public:
    CImpersonationData() : m_Callback(NULL), m_Context(NULL) { }
    CImpersonationData(PSXS_IMPERSONATION_CALLBACK Callback, PVOID Context) : m_Callback(Callback), m_Context(Context) { }
    CImpersonationData(const CImpersonationData &r) : m_Callback(r.m_Callback), m_Context(r.m_Context) { }
    void operator =(const CImpersonationData &r) { m_Callback = r.m_Callback; m_Context = r.m_Context; }
    ~CImpersonationData() { }

    enum CallType
    {
        eCallTypeImpersonate,
        eCallTypeUnimpersonate
    };

    BOOL Call(CallType ct) const { BOOL fSuccess = TRUE; if (m_Callback != NULL) { fSuccess = (*m_Callback)(m_Context, (ct == eCallTypeImpersonate) ? TRUE : FALSE); } return fSuccess; }

protected:
    PSXS_IMPERSONATION_CALLBACK m_Callback;
    PVOID m_Context;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\hashfile.h ===
#pragma once
#include "FusionBuffer.h"
#include "FusionArray.h"
//#include "wincrypt.h"
#include "fusionsha1.h"

/*++

Hashfile.h - Inclusions for file-hashing and verification testing functionality.

--*/


#define SHA1_HASH_SIZE_BYTES    ( 160 / 8 )
#define HASHFLAG_AUTODETECT        ( 0x00000001 )
#define HASHFLAG_STRAIGHT_HASH     ( 0x00000002 )
#define HASHFLAG_PROCESS_IMAGE    ( 0x00000004 )
#define HASHFLAG_VALID_PARAMS   ( HASHFLAG_AUTODETECT | HASHFLAG_STRAIGHT_HASH | \
                                  HASHFLAG_PROCESS_IMAGE )

//
// If someone invents a hash with more than 512 bytes, I'll eat my socks.
//
#define MAX_HASH_BYTES              ( 512 )

BOOL
SxspEnumKnownHashTypes( 
    DWORD dwIndex, 
    OUT CBaseStringBuffer &rbuffHashTypeName,
    OUT BOOL &rbNoMoreItems
    );

BOOL
SxspCreateFileHash(
    DWORD dwFlags,
    ALG_ID PreferredAlgorithm,
    const CBaseStringBuffer &pwsFileName,
    CFusionArray<BYTE> &bHashDestination
    );

BOOL
SxspIsFullHexString(
    PCWSTR wsString,
    SIZE_T Cch
    );

typedef enum {
    HashValidate_Matches,               // Hashes are identical
    HashValidate_InvalidPassedHash,     // The hash passed in was somehow invalid
    HashValidate_InvalidAlgorithm,      // The hash algorithm is invalid
    HashValidate_HashesCantBeMatched,   // No match for another reason
    HashValidate_HashNotMatched,        // Hashes are not identical (ie: not matched)
    HashValidate_OtherProblems          // There was some other problem along the way
} HashValidateResult;



//
// Do the normal validation process - single retry
//
#define SVFH_DEFAULT_ACTION     (0x00000000)

//
// Retry this file N times until either (a) the file was unable to be
// opened or (b) the file has other errors or (c) the file was checked
// and it was ok / bad / etc.
//
#define SVFH_RETRY_LOGIC_SIMPLE (0x00000001)

//
// Wait until the file was able to be verified - spin in a backoff loop
// until the file open didn't fail with ERROR_SHARING_VIOLATION
//
#define SVFH_RETRY_WAIT_UNTIL   (0x00000002)

BOOL
SxspVerifyFileHash(
    const DWORD dwFlags,
	const CBaseStringBuffer &rhsFullFilePath,
	const CFusionArray<BYTE> &baTheorheticalHash,
	ALG_ID whichAlg,
	HashValidateResult &rHashResult
    );

BOOL
SxspHashAlgFromString(
	const CBaseStringBuffer &strAlgName,
	ALG_ID &algId
    );

BOOL
SxspHashStringFromAlg(
	ALG_ID algId,
	CBaseStringBuffer &rstrAlgName
    );

typedef enum
{
    ManifestValidate_Unknown            = 0,
    ManifestValidate_IsIntact           = 1,
    ManifestValidate_CatalogMissing     = 2,
    ManifestValidate_ManifestMissing    = 3,
    ManifestValidate_InvalidHash        = 4,
    ManifestValidate_NotCertified       = 5,
    ManifestValidate_StrongNameMismatch = 6,
    ManifestValidate_OtherProblems      = 7
} ManifestValidationResult;

class CMetaDataFileElement;

BOOL
SxspValidateAllFileHashes(
    IN const CMetaDataFileElement &rmdfeElement,
    IN const CBaseStringBuffer &rbuffFileName,
    OUT HashValidateResult &rResult
    );


#define ENUM_TO_STRING( x ) case x: return (L#x)

#if DBG
inline PCWSTR SxspManifestValidationResultToString( ManifestValidationResult r )
{
    switch ( r )
    {
        ENUM_TO_STRING( ManifestValidate_Unknown );
        ENUM_TO_STRING( ManifestValidate_IsIntact );
        ENUM_TO_STRING( ManifestValidate_CatalogMissing );
        ENUM_TO_STRING( ManifestValidate_ManifestMissing );
        ENUM_TO_STRING( ManifestValidate_InvalidHash );
        ENUM_TO_STRING( ManifestValidate_NotCertified );
        ENUM_TO_STRING( ManifestValidate_OtherProblems );
    }

    return L"Bad manifest validation value";
}

inline PCWSTR SxspHashValidateResultToString( HashValidateResult r )
{
    switch ( r )
    {
        ENUM_TO_STRING( HashValidate_Matches );
        ENUM_TO_STRING( HashValidate_InvalidPassedHash );
        ENUM_TO_STRING( HashValidate_InvalidAlgorithm );
        ENUM_TO_STRING( HashValidate_HashesCantBeMatched );
        ENUM_TO_STRING( HashValidate_HashNotMatched );
        ENUM_TO_STRING( HashValidate_OtherProblems );
    }

    return L"Bad hash validation value";
}

#endif

// Default mode
#define MANIFESTVALIDATE_OPTION_MASK                ( 0x000000FF )
#define MANIFESTVALIDATE_MODE_MASK                  ( 0x0000FF00 )

#define MANIFESTVALIDATE_MODE_COMPLETE              ( 0x00000100 )
#define MANIFESTVALIDATE_MODE_NO_STRONGNAME         ( 0x00000200 )

// The manifest has to validate against a trusted root CA to be valid.
#define MANIFESTVALIDATE_OPTION_NEEDS_ROOT_CA       ( 0x00000001 )

// The catalog gets validated first before the manifest is checked.
#define MANIFESTVALIDATE_OPTION_VALIDATE_CATALOG    ( 0x00000002 )

// If the manifest or catalog are invalid, attempt to retrieve it
#define MANIFESTVALIDATE_OPTION_ATTEMPT_RETRIEVAL   ( 0x00000004 )

#define MANIFESTVALIDATE_MOST_COMMON    ( MANIFESTVALIDATE_MODE_COMPLETE +  \
                                          ( MANIFESTVALIDATE_OPTION_NEEDS_ROOT_CA |  \
                                            MANIFESTVALIDATE_OPTION_VALIDATE_CATALOG ) )

BOOL
SxspValidateManifestAgainstCatalog(
    const CBaseStringBuffer &rbuffManifestPath,
    ManifestValidationResult &rResult,
    DWORD dwOptionsFlags
    );

BOOL
SxspValidateManifestAgainstCatalog(
    const CBaseStringBuffer &rbuffManifestPath,
    const CBaseStringBuffer &rbuffCatalogPath,
    ManifestValidationResult &rResult,
    DWORD dwOptionsFlags
    );

BOOL
SxspCheckHashDuringInstall(
    BOOL bHasHashData,
    const CBaseStringBuffer &rbuffFile,
    const CBaseStringBuffer &rbuffHashDataString,
    ALG_ID HashAlgId,
    HashValidateResult &hvr
    );



static inline BOOL IsSlash( WCHAR w ) { return ( ( w == L'\\' ) || ( w == L'/' ) ); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\gsgenctx.cpp ===
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "gsgenctx.h"
#include "SxsExceptionHandling.h"

typedef struct _CALLBACKDATA
{
    union
    {
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE GetDataSize;
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA GetData;
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED EntryDeleted;
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE GetUserDataSize;
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA GetUserData;
    } u;
} CALLBACKDATA, *PCALLBACKDATA;

BOOL CGSGenCtx::Create(
    PGUID_SECTION_GENERATION_CONTEXT *GSGenContext,
    ULONG DataFormatVersion,
    GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    PVOID CallbackContext
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CGSGenCtx *pGSGenCtx;

    IFALLOCFAILED_EXIT(pGSGenCtx = new CGSGenCtx);
    pGSGenCtx->m_CallbackFunction = CallbackFunction;
    pGSGenCtx->m_CallbackContext = CallbackContext;
    pGSGenCtx->m_DataFormatVersion = DataFormatVersion;

    *GSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) pGSGenCtx;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

CGSGenCtx::CGSGenCtx()
{
    m_FirstEntry = NULL;
    m_LastEntry = NULL;
    m_EntryCount = 0;
    m_HashTableSize = 0;
}

CGSGenCtx::~CGSGenCtx()
{
    CSxsPreserveLastError ple;
    CALLBACKDATA CBData;

    Entry *pEntry = m_FirstEntry;

    while (pEntry != NULL)
    {
        Entry *pNext = pEntry->m_Next;

        CBData.u.EntryDeleted.DataContext = pEntry->m_DataContext;
        (*m_CallbackFunction)(
            m_CallbackContext,
            GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED,
            &CBData);

        FUSION_DELETE_SINGLETON(pEntry);
        pEntry = pNext;
    }

    ple.Restore();
}

BOOL
CGSGenCtx::Add(
    const GUID &rGuid,
    PVOID DataContext,
    ULONG AssemblyRosterIndex,
    DWORD DuplicateErrorCode
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    Entry *pEntry = NULL;

    PARAMETER_CHECK(DuplicateErrorCode != ERROR_SUCCESS);

#if DBG_SXS
    CSmallStringBuffer buffGuid;

    ::SxspFormatGUID(rGuid, buffGuid);

#endif // DBG_SXS

    for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
    {
        if (pEntry->m_Guid == rGuid)
        {
            ::FusionpSetLastWin32Error(DuplicateErrorCode);
            pEntry = NULL;
            goto Exit;
        }
    }

    IFALLOCFAILED_EXIT(pEntry = new Entry);
    IFW32FALSE_EXIT(pEntry->Initialize(rGuid, DataContext, AssemblyRosterIndex));

    if (m_LastEntry == NULL)
        m_FirstEntry = pEntry;
    else
        m_LastEntry->m_Next = pEntry;

    m_LastEntry = pEntry;

    pEntry = NULL;

    m_EntryCount++;

    fSuccess = TRUE;
Exit:
    FUSION_DELETE_SINGLETON(pEntry);
    return fSuccess;
}

BOOL
CGSGenCtx::Find(
    const GUID &rGuid,
    PVOID *DataContext
    )
{
    BOOL fSuccess = FALSE;
    Entry *pEntry = NULL;

    if (DataContext != NULL)
        *DataContext = NULL;

    for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
    {
        if (pEntry->m_Guid == rGuid)
            break;
    }

    if (pEntry == NULL)
    {
        ::FusionpSetLastWin32Error(ERROR_SXS_KEY_NOT_FOUND);
        goto Exit;
    }

    if (DataContext != NULL)
        *DataContext = pEntry->m_DataContext;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CGSGenCtx::GetSectionSize(
    PSIZE_T SizeOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T UserDataSize = 0;
    SIZE_T HeaderSize = 0;
    SIZE_T EntryListSize = 0;
    SIZE_T EntryDataSize = 0;
    CALLBACKDATA CBData;
    Entry *pEntry = NULL;

    if (SizeOut != NULL)
        *SizeOut = 0;

    PARAMETER_CHECK(SizeOut != NULL);

    HeaderSize = sizeof(ACTIVATION_CONTEXT_GUID_SECTION_HEADER);

    CBData.u.GetUserDataSize.DataSize = 0;
    (*m_CallbackFunction)(m_CallbackContext, GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE, &CBData);
    UserDataSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserDataSize.DataSize);

    if ((m_EntryCount != 0) || (UserDataSize != 0))
    {
        EntryListSize = m_EntryCount * sizeof(ACTIVATION_CONTEXT_GUID_SECTION_ENTRY);

        for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
        {
            CBData.u.GetDataSize.DataContext = pEntry->m_DataContext;
            CBData.u.GetDataSize.DataSize = 0;
            (*m_CallbackFunction)(m_CallbackContext, GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE, &CBData);
            EntryDataSize += ROUND_ACTCTXDATA_SIZE(CBData.u.GetDataSize.DataSize);
        }

        *SizeOut = HeaderSize + UserDataSize + EntryListSize + EntryDataSize;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CGSGenCtx::GetSectionData(
    SIZE_T BufferSize,
    PVOID Buffer,
    PSIZE_T BytesWritten
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SIZE_T BytesSoFar = 0;
    SIZE_T BytesLeft = BufferSize;
    SIZE_T RoundedSize;
    PACTIVATION_CONTEXT_GUID_SECTION_HEADER Header;
    CALLBACKDATA CBData;
    PVOID Cursor = NULL;

    if (BytesWritten != NULL)
        *BytesWritten = 0;

    if (BytesLeft < sizeof(ACTIVATION_CONTEXT_GUID_SECTION_HEADER))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    Header = (PACTIVATION_CONTEXT_GUID_SECTION_HEADER) Buffer;

    Cursor = (PVOID) (Header + 1);

    Header->Magic = ACTIVATION_CONTEXT_GUID_SECTION_MAGIC;
    Header->HeaderSize = sizeof(ACTIVATION_CONTEXT_GUID_SECTION_HEADER);
    Header->FormatVersion = ACTIVATION_CONTEXT_GUID_SECTION_FORMAT_WHISTLER;
    Header->DataFormatVersion = m_DataFormatVersion;

    Header->Flags = 0;

    Header->ElementCount = m_EntryCount;
    Header->ElementListOffset = 0; // filled in after we figure out the user data area
    Header->SearchStructureOffset = 0;
    Header->UserDataOffset = 0; // filled in below
    Header->UserDataSize = 0;

    BytesLeft -= sizeof(*Header);
    BytesSoFar += sizeof(*Header);

    CBData.u.GetUserDataSize.DataSize = 0;
    (*m_CallbackFunction)(m_CallbackContext, GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE, &CBData);
    RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserDataSize.DataSize);

    if (RoundedSize != 0)
    {
        CBData.u.GetUserData.SectionHeader = Header;
        CBData.u.GetUserData.BufferSize = RoundedSize;
        CBData.u.GetUserData.Buffer = Cursor;
        CBData.u.GetUserData.BytesWritten = 0;

        (*m_CallbackFunction)(m_CallbackContext, GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA, &CBData);

        ASSERT(CBData.u.GetUserData.BytesWritten <= RoundedSize);

        if (CBData.u.GetUserData.BytesWritten != 0)
        {
            RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserData.BytesWritten);

            BytesLeft -= RoundedSize;
            BytesSoFar += RoundedSize;

            Header->UserDataSize = static_cast<ULONG>(CBData.u.GetUserData.BytesWritten);
            Header->UserDataOffset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) Header));

            Cursor = (PVOID) (((ULONG_PTR) Cursor) + RoundedSize);
        }
    }

    // Finally the array of entries...

    if (m_EntryCount != 0)
    {
        PVOID DataCursor;
        PACTIVATION_CONTEXT_GUID_SECTION_ENTRY DstEntry;
        PACTIVATION_CONTEXT_GUID_SECTION_ENTRY DstEntryArrayFirstElement;
        Entry *SrcEntry;

        if (BytesLeft < (m_EntryCount * sizeof(ACTIVATION_CONTEXT_GUID_SECTION_ENTRY)))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

        BytesLeft -= (m_EntryCount * sizeof(ACTIVATION_CONTEXT_GUID_SECTION_ENTRY));
        BytesSoFar += (m_EntryCount * sizeof(ACTIVATION_CONTEXT_GUID_SECTION_ENTRY));

        //
        // DstEntryArrayFirstElement actually points to the first thing that we'll
        // be writing out, as DstEntry is ++'d across each of the elements as we
        // zip through the output buffer.
        //
        DstEntryArrayFirstElement = (PACTIVATION_CONTEXT_GUID_SECTION_ENTRY) Cursor;
        DstEntry = DstEntryArrayFirstElement;
        Header->ElementListOffset = static_cast<LONG>(((LONG_PTR) DstEntry) - ((LONG_PTR) Header));
        DataCursor = (PVOID) (DstEntry + m_EntryCount);
        SrcEntry = m_FirstEntry;

        while (SrcEntry != NULL)
        {
            CBData.u.GetDataSize.DataContext = SrcEntry->m_DataContext;
            CBData.u.GetDataSize.DataSize = 0;

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INFO,
                "SXS.DLL: Calling guid section generation callback with reason GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE\n"
                "    .DataContext = %p\n",
                CBData.u.GetData.DataContext);

            (*m_CallbackFunction)(m_CallbackContext, GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE, &CBData);

            RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetDataSize.DataSize);

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INFO,
                "SXS.DLL: Guid section generation callback (_GETDATASIZE) returned data size of %d (rounded to %Id)\n", CBData.u.GetDataSize.DataSize, RoundedSize);

            if (RoundedSize != 0)
            {
                if (BytesLeft < RoundedSize)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                CBData.u.GetData.SectionHeader = Header;
                CBData.u.GetData.DataContext = SrcEntry->m_DataContext;
                CBData.u.GetData.BufferSize = RoundedSize;
                CBData.u.GetData.Buffer = DataCursor;
                CBData.u.GetData.BytesWritten = 0;

                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_INFO,
                    "SXS.DLL: Calling guid section generation callback with reason GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA\n"
                    "    .DataContext = %p\n"
                    "    .BufferSize = %d\n"
                    "    .Buffer = %p\n",
                    CBData.u.GetData.DataContext,
                    CBData.u.GetData.BufferSize,
                    CBData.u.GetData.Buffer);

                (*m_CallbackFunction)(m_CallbackContext, GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA, &CBData);

                if (CBData.u.GetData.BytesWritten != 0)
                {
                    ASSERT(CBData.u.GetData.BytesWritten <= RoundedSize);
                    RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetData.BytesWritten);
                    INTERNAL_ERROR_CHECK(CBData.u.GetData.BytesWritten <= RoundedSize);

                    BytesLeft -= RoundedSize;
                    BytesSoFar += RoundedSize;

                    DstEntry->Offset = static_cast<LONG>(((LONG_PTR) DataCursor) - ((LONG_PTR) Header));
                }
                else
                    DstEntry->Offset = 0;

                DstEntry->Length = static_cast<ULONG>(CBData.u.GetData.BytesWritten);
                DstEntry->AssemblyRosterIndex = SrcEntry->m_AssemblyRosterIndex;
                DataCursor = (PVOID) (((ULONG_PTR) DataCursor) + RoundedSize);
            }
            else
            {
                DstEntry->Offset = 0;
                DstEntry->Length = 0;
                DstEntry->AssemblyRosterIndex = 0;
            }

            DstEntry->Guid = SrcEntry->m_Guid;
            SrcEntry = SrcEntry->m_Next;
            DstEntry++;
        }

        //
        // We compare the blobs via memcmp
        //
        if ( m_HashTableSize == 0 )
        {
            qsort( DstEntryArrayFirstElement, m_EntryCount, sizeof(*DstEntry), &CGSGenCtx::SortGuidSectionEntries );
            Header->Flags |= ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER;
        }
    }

    if (BytesWritten != NULL)
        *BytesWritten = BytesSoFar;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

int __cdecl
CGSGenCtx::SortGuidSectionEntries(
    const void *elem1,
    const void *elem2
    )
{
    //
    // The first thing in the structure is actually the GUID itself, but
    // we'll save problems later by casting and following the Guid
    // member.
    //
    const PACTIVATION_CONTEXT_GUID_SECTION_ENTRY pLeft = (const PACTIVATION_CONTEXT_GUID_SECTION_ENTRY)elem1;
    const PACTIVATION_CONTEXT_GUID_SECTION_ENTRY pRight = (const PACTIVATION_CONTEXT_GUID_SECTION_ENTRY)elem2;

    return memcmp( (const void*)&pLeft->Guid, (const void*)&pRight->Guid, sizeof(GUID) );
}


BOOL
CGSGenCtx::Entry::Initialize(
    const GUID &rGuid,
    PVOID DataContext,
    ULONG AssemblyRosterIndex
    )
{
    m_Guid = rGuid;
    m_DataContext = DataContext;
    m_AssemblyRosterIndex = AssemblyRosterIndex;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\guidsectgen.cpp ===
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "gsgenctx.h"

BOOL
SxsInitGuidSectionGenerationContext(
    OUT PGUID_SECTION_GENERATION_CONTEXT *GSGenContext,
    IN ULONG DataFormatVersion,
    IN GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    IN LPVOID Context
    )
{
    return CGSGenCtx::Create(
            GSGenContext,
            DataFormatVersion,
            CallbackFunction,
            Context);
}

PVOID
WINAPI
SxsGetGuidSectionGenerationContextCallbackContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext
    )
{
    return ((CGSGenCtx *) GSGenContext)->GetCallbackContext();
}

VOID
WINAPI
SxsDestroyGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext
    )
{
    if (GSGenContext != NULL)
    {
        ((CGSGenCtx *) GSGenContext)->DeleteYourself();
    }
}

BOOL
WINAPI
SxsAddGuidToGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN const GUID *Guid,
    IN PVOID DataContext,
    IN ULONG AssemblyRosterIndex,
    IN DWORD DuplicateGuidErrorCode
    )
{
    return ((CGSGenCtx *) GSGenContext)->Add(*Guid, DataContext, AssemblyRosterIndex, DuplicateGuidErrorCode);
}

BOOL
WINAPI
SxsFindStringInGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN const GUID *Guid,
    OUT PVOID *DataContext
    )
{
    return ((CGSGenCtx *) GSGenContext)->Find(*Guid, DataContext);
}

BOOL
WINAPI
SxsGetGuidSectionGenerationContextSectionSize(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    OUT PSIZE_T DataSize
    )
{
    return ((CGSGenCtx *) GSGenContext)->GetSectionSize(DataSize);
}

BOOL
WINAPI
SxsGetGuidSectionGenerationContextSectionData(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT PSIZE_T BytesWritten OPTIONAL
    )
{
    return ((CGSGenCtx *) GSGenContext)->GetSectionData(BufferSize, Buffer, BytesWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\gsgenctx.h ===
#if !defined(_FUSION_GSGENCTX_H_INCLUDED_)
#define _FUSION_GSGENCTX_H_INCLUDED_

#pragma once

#include "fusionheap.h"

class CGSGenCtx
{
public:
    static BOOL Create(
                PGUID_SECTION_GENERATION_CONTEXT *GSGenContext,
                ULONG DataFormatVersion,
                GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
                PVOID CallbackContext
                );

    BOOL Add(const GUID &rGuid, PVOID DataContext, ULONG AssemblyRosterIndex, DWORD DuplicateErrorCode);
    BOOL Find(const GUID &rGuid, PVOID *DataContext);
    BOOL GetSectionSize(PSIZE_T SectionSize);
    BOOL GetSectionData(SIZE_T BufferSize, PVOID Buffer, SIZE_T *BytesWritten);
    PVOID GetCallbackContext() { return m_CallbackContext; }

    VOID DeleteYourself() { FUSION_DELETE_SINGLETON(this); }

    ~CGSGenCtx();
protected:
    CGSGenCtx();

    GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION m_CallbackFunction;
    PVOID m_CallbackContext;

    class Entry
    {
    public:
        Entry() : m_DataContext(NULL), m_Next(NULL) { }
        ~Entry() { }

        BOOL Initialize(const GUID &Guid, PVOID DataContext, ULONG AssemblyRosterIndex);
        BOOL GetEntryDataSize(CGSGenCtx *pSSGenCtx, SIZE_T &rSize);
        BOOL GetEntryData(CGSGenCtx *pSSGenCtx, SIZE_T BufferSize, PVOID Buffer, SIZE_T *BytesWritten);

        GUID m_Guid;
        PVOID m_DataContext;
        Entry *m_Next;
        ULONG m_AssemblyRosterIndex;
    };

    friend Entry;

    static int __cdecl SortGuidSectionEntries(const void *elem1, const void *elem2);

    ULONG m_EntryCount;
    ULONG m_HashTableSize;
    Entry *m_FirstEntry;
    Entry *m_LastEntry;
    ULONG m_DataFormatVersion;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\hashfile.cpp ===
#include "stdinc.h"
#include "Sxsp.h"
#include "imagehlp.h"
#include "windows.h"
#include "hashfile.h"
#include "wincrypt.h"
#include "winbase.h"
#include "softpub.h"
#include "strongname.h"
#include "FusionEventLog.h"
#include "Sxsp.h"

BOOL SxspImageDigesterFunc(   DIGEST_HANDLE hSomething, PBYTE pbDataBlock, DWORD dwLength);
BOOL SxspSimpleHashRoutine(CFusionHash &rhHash, HANDLE hFile);
BOOL SxspImageHashRoutine(CFusionHash &rhHash, HANDLE hFile, BOOL &bInvalidImage);

CRITICAL_SECTION g_csHashFile;

struct _HASH_ALG_NAME_MAP
{
    PWSTR wsName;
    ULONG cchName;
    ALG_ID cId;
} HashAlgNameMap[] =
{
    { L"SHA1", 4,   CALG_SHA1 },
    { L"SHA", 3,    CALG_SHA },
    { L"MD5", 3,    CALG_MD5 },
    { L"MD4", 3,    CALG_MD4 },
    { L"MD2", 3,    CALG_MD2 },
    { L"MAC", 3,    CALG_MAC },
    { L"HMAC", 4,   CALG_HMAC }
};

BOOL
SxspEnumKnownHashTypes( 
    DWORD dwIndex, 
    OUT CBaseStringBuffer &rbuffHashTypeName,
    BOOL &rbNoMoreItems
    )
{
    FN_PROLOG_WIN32

    rbNoMoreItems = FALSE;

    if ( dwIndex >= NUMBER_OF( HashAlgNameMap ) )
    {
        rbNoMoreItems = TRUE;
    }
    else
    {
        IFW32FALSE_EXIT( rbuffHashTypeName.Win32Assign( 
            HashAlgNameMap[dwIndex].wsName,
            HashAlgNameMap[dwIndex].cchName ) );
    }

    FN_EPILOG
}

BOOL
SxspHashAlgFromString(
    const CBaseStringBuffer &strAlgName,
    ALG_ID &algId
    )
{
    //
    // There's a disconnect that the Win32Equals function requires a real
    // C++ 'bool' value, while we want to return TRUE or FALSE, using Win32
    // constants and values.
    //
    bool bSuccessCpp = false;
    DWORD idx;

    for (idx = 0; (idx < NUMBER_OF(HashAlgNameMap)) && !bSuccessCpp; idx++)
    {
        if (::FusionpCompareStrings(
                strAlgName, strAlgName.Cch(),
                HashAlgNameMap[idx].wsName, HashAlgNameMap[idx].cchName,
                false) == 0)
        {
            algId = HashAlgNameMap[idx].cId;
            bSuccessCpp = TRUE;
        }
    }

    return bSuccessCpp ? TRUE : FALSE;
}

BOOL
SxspHashStringFromAlg(
    ALG_ID algId,
    CBaseStringBuffer &strAlgName
    )
{
    BOOL bSuccess = FALSE;
    DWORD idx;

    FN_TRACE_WIN32(bSuccess);

    strAlgName.Clear();

    for (idx = 0; (idx < NUMBER_OF(HashAlgNameMap)) && !bSuccess; idx++)
    {
        if (HashAlgNameMap[idx].cId == algId)
        {
            IFW32FALSE_EXIT(strAlgName.Win32Assign(HashAlgNameMap[idx].wsName, HashAlgNameMap[idx].cchName));
            break;
        }
    }

    bSuccess = TRUE;

Exit:
    return bSuccess;
}

BOOL
SxspCheckHashDuringInstall(
    BOOL bHasHashData,
    const CBaseStringBuffer &rbuffFile,
    const CBaseStringBuffer &rbuffHashDataString,
    ALG_ID HashAlgId,
    HashValidateResult &rHashValid
    )
{
    FN_PROLOG_WIN32

    rHashValid = HashValidate_OtherProblems;

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: %s - Validating install-time hash: File=%ls tHasHash=%s tAlgId=0x%08x\n\tHash=%ls\n",
        __FUNCTION__,
        static_cast<PCWSTR>(rbuffFile),
        bHasHashData ? "yes" : "no",
        HashAlgId,
        static_cast<PCWSTR>(rbuffHashDataString));
#endif

    if (bHasHashData)
    {
        CFusionArray<BYTE> rgbHashData;

        IFW32FALSE_EXIT(rgbHashData.Win32Initialize());
        
        if (!::SxspHashStringToBytes(
            rbuffHashDataString,
            rbuffHashDataString.Cch(),
            rgbHashData))
        {
            CSmallStringBuffer sb;
        
            rHashValid = HashValidate_InvalidPassedHash;
            ::SxspHashStringFromAlg(HashAlgId, sb);

            ::FusionpLogError(
                MSG_SXS_INVALID_FILE_HASH_FROM_COPY_CALLBACK,
                CEventLogString(sb),
                CEventLogString(rbuffFile));

            goto Exit;
        }

        IFW32FALSE_EXIT(::SxspVerifyFileHash(
            0,
            rbuffFile, 
            rgbHashData,
            HashAlgId, 
            rHashValid));

    }
    else
    {
        //
        // If there's no hash data, or we're in OS setup mode, then the hash of the
        // file is "implicitly" correct.
        //
        rHashValid = HashValidate_Matches;
    }

    FN_EPILOG
}


BOOL
SxspCreateFileHash(
    DWORD dwFlags,
    ALG_ID PreferredAlgorithm,
    const CBaseStringBuffer &pwsFileName,
    CFusionArray<BYTE> &bHashDestination
    )
/*++
Purpose:

Parameters:

Returns:

 --*/
{
    FN_PROLOG_WIN32

    CFusionFile     hFile;
    CFusionHash     hCurrentHash;

    // Initialization
    hFile = INVALID_HANDLE_VALUE;

    PARAMETER_CHECK((dwFlags & ~HASHFLAG_VALID_PARAMS) == 0);

    //
    // First try and open the file.  No sense in doing anything else if we
    // can't get to the data to start with.  Use a very friendly set of
    // rights to check the file.  Future users might want to be sure that
    // you're in the right security context before doing this - system
    // level to check system files, etc.
    //
    IFW32FALSE_EXIT(hFile.Win32CreateFile(pwsFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING));

    //
    // We'll be using SHA1 for the file hash
    //
    IFW32FALSE_EXIT(hCurrentHash.Win32Initialize(CALG_SHA1));

    //
    // So first try hashing it via the image, and if that fails, try the
    // normal file-reading hash routine instead.
    //
    if (dwFlags & HASHFLAG_AUTODETECT)
    {
        BOOL fInvalidImage;

        IFW32FALSE_EXIT(::SxspImageHashRoutine(hCurrentHash, hFile, fInvalidImage));
        if ( fInvalidImage )
        {
            IFW32FALSE_EXIT(::SxspSimpleHashRoutine(hCurrentHash, hFile));
        }
    }
    else if (dwFlags & HASHFLAG_STRAIGHT_HASH)
    {
        IFW32FALSE_EXIT(::SxspSimpleHashRoutine(hCurrentHash, hFile));
    }
    else if (dwFlags & HASHFLAG_PROCESS_IMAGE)
    {
        BOOL fInvalidImage;
        
        IFW32FALSE_EXIT(::SxspImageHashRoutine(hCurrentHash, hFile, fInvalidImage));
        if ( fInvalidImage )
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(SxspCreateFileHash, ERROR_INVALID_PARAMETER);
        }
    }


    //
    // We know the buffer is the right size, so we just call down to the hash parameter
    // getter, which will be smart and bop out (setting the pdwDestinationSize parameter)
    // if the user passed an incorrect parameter.
    //
    IFW32FALSE_EXIT(hCurrentHash.Win32GetValue(bHashDestination));

    FN_EPILOG
}

BOOL
SxspImageDigesterFunc(
    DIGEST_HANDLE hSomething,
    PBYTE pbDataBlock,
    DWORD dwLength
    )
{
    FN_PROLOG_WIN32

    CFusionHash* pHashObject = reinterpret_cast<CFusionHash*>(hSomething);

    if ( pHashObject != NULL )
    {
        IFW32FALSE_EXIT(pHashObject->Win32HashData(pbDataBlock, dwLength));
    }

    FN_EPILOG
}


BOOL
SxspSimpleHashRoutine(
    CFusionHash &rhHash,
    HANDLE hFile
    )
{
    FN_PROLOG_WIN32
    
    DWORD dwDataRead;
    BOOL fKeepReading = TRUE;
    BOOL b = FALSE;
    CFusionArray<BYTE> pbBuffer;

    IFW32FALSE_EXIT( pbBuffer.Win32SetSize( 64 * 1024 ) );

    while (fKeepReading)
    {
        b = ::ReadFile(hFile, pbBuffer.GetArrayPtr(), pbBuffer.GetSizeAsDWORD(), &dwDataRead, NULL);

        //
        // Returned OK, but we're out of data, so quit.
        //
        if (b && (dwDataRead == 0))
        {
            fKeepReading = FALSE;
            b = TRUE;
            continue;
        }
        //
        // something bad happened so we need to stop
        //
        else if (!b)
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            ORIGINATE_WIN32_FAILURE_AND_EXIT( ReadFile, dwLastError );
        }

        //
        // If we've gotten this far, we need to add the data found
        // to our existing hash
        //
        IFW32FALSE_EXIT(rhHash.Win32HashData(pbBuffer.GetArrayPtr(), dwDataRead));

    }

    FN_EPILOG;
}


BOOL
SxspImageHashRoutine(
    CFusionHash &rhHash,
    HANDLE hFile,
    BOOL &rfInvalidImage
    )
{
    FN_PROLOG_WIN32
    CSxsLockCriticalSection lock(g_csHashFile);

    rfInvalidImage = FALSE;

    PARAMETER_CHECK( ( hFile != NULL ) && ( hFile != INVALID_HANDLE_VALUE ) );

    // The ImageGetDigestStream() function is not thread safe, so we have to ensure that it's
    // not called by other threads while we're using it.
    IFW32FALSE_EXIT(lock.Lock());

    IFW32FALSE_EXIT_UNLESS( ::ImageGetDigestStream(
        hFile,
        CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO,
        &SxspImageDigesterFunc,
        (DIGEST_HANDLE)(&rhHash)),
        (::FusionpGetLastWin32Error() == ERROR_INVALID_PARAMETER),
        rfInvalidImage );

    FN_EPILOG

}



BOOL
SxspVerifyFileHash(
    const DWORD dwFlags,
    const CBaseStringBuffer &hsFullFilePath,
    const CFusionArray<BYTE> &baTheoreticalHash,
    ALG_ID whichAlg,
    HashValidateResult &HashValid
    )
{
    FN_PROLOG_WIN32

    CFusionArray<BYTE> bGotHash;
    HashValid = HashValidate_OtherProblems;
    BOOL fFileNotFoundError;
    LONG ulRetriesLeft = 0;
    LONG ulBackoffAmount = 1000;
    LONG ulBackoffAmountCap = 3000;
    float ulBackoffRate = 1.5f;

    PARAMETER_CHECK( (dwFlags == SVFH_DEFAULT_ACTION) || 
                     (dwFlags == SVFH_RETRY_LOGIC_SIMPLE) ||
                     (dwFlags == SVFH_RETRY_WAIT_UNTIL));

    if ( dwFlags == SVFH_RETRY_LOGIC_SIMPLE )
        ulRetriesLeft = 10;

TryAgain:

    IFW32FALSE_EXIT_UNLESS2(
        ::SxspCreateFileHash(
            HASHFLAG_AUTODETECT,
            whichAlg,
            hsFullFilePath,
            bGotHash),
            LIST_5( ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_BAD_NETPATH, ERROR_BAD_NET_NAME, ERROR_SHARING_VIOLATION),
            fFileNotFoundError);

    //
    // If this was a sharing violation and we've got retries left, then try again.
    //
    if ( fFileNotFoundError && (::FusionpGetLastWin32Error() == ERROR_SHARING_VIOLATION) && (ulRetriesLeft > 0))
    {
        ulRetriesLeft--;
        ::Sleep( ulBackoffAmount );
        if ( ulBackoffAmount < ulBackoffAmountCap )
        {
            ulBackoffAmount = (ULONG)((float)ulBackoffAmount * ulBackoffRate);
        }
        
        if ( dwFlags == SVFH_RETRY_WAIT_UNTIL )
            ulRetriesLeft = 1;
            
        goto TryAgain;
    }

    //
    // If the file was able to be hashed, and the return error isn't "file not found",
    // then compare the hashes
    //
    if (!fFileNotFoundError &&(baTheoreticalHash.GetSize() == bGotHash.GetSize()))
    {
        HashValid = 
            (::memcmp(
                bGotHash.GetArrayPtr(),
                baTheoreticalHash.GetArrayPtr(),
                bGotHash.GetSize()) == 0) ? HashValidate_Matches : HashValidate_HashNotMatched;
    }
    else
    {
        HashValid = HashValidate_HashesCantBeMatched;
    }

    FN_EPILOG
}



BOOL
SxspGetStrongNameFromManifestName(
    PCWSTR pszManifestName,
    CBaseStringBuffer &rbuffStrongName,
    BOOL &rfHasPublicKey
    )
{
    BOOL                fSuccess = TRUE;
    FN_TRACE_WIN32(fSuccess);

    PCWSTR wsCursor;
    SIZE_T cchJump, cchPubKey;

    rfHasPublicKey = FALSE;
    rbuffStrongName.Clear();

    wsCursor = pszManifestName;

    //
    // Tricky: Zips through the name of the manifest to find the strong name string.
    //
    for (int i = 0; i < 2; i++)
    {
        cchJump = wcscspn(wsCursor, L"_");
        PARAMETER_CHECK(cchJump != 0);
        wsCursor += (cchJump + 1);  // x86_foo_strongname -> foo_strongname
    }

    //
    // Are we mysteriously at the end of the string?
    //
    PARAMETER_CHECK(wsCursor[0] != L'\0');

    //
    // Find the length of the public key string
    //
    cchPubKey = wcscspn(wsCursor, L"_");
    PARAMETER_CHECK(cchPubKey != 0);

    IFW32FALSE_EXIT(rbuffStrongName.Win32Assign(wsCursor, cchPubKey));

    rfHasPublicKey = (::FusionpCompareStrings(
                            rbuffStrongName,
                            rbuffStrongName.Cch(),
                            SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE,
                            NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1,
                            false) != 0);

    FN_EPILOG
}


static GUID p_WintrustVerifyGenericV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;

BOOL
SxspValidateManifestAgainstCatalog(
    const CBaseStringBuffer &rbuffManifestName, // "c:\foo\x86_comctl32_6.0.0.0_0000.manifest"
    ManifestValidationResult &rResult,
    DWORD dwOptionsFlags
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer sbCatalogName;

    //
    // Take the manifest name (which should be c:\foo\bar\blort.manifest) and switch
    // it to contain the catalog name instead:
    //
    // c:\foo\bar\blort.cat
    //
    IFW32FALSE_EXIT(sbCatalogName.Win32Assign(rbuffManifestName));
    IFW32FALSE_EXIT(
        sbCatalogName.Win32ChangePathExtension(
            FILE_EXTENSION_CATALOG,
            FILE_EXTENSION_CATALOG_CCH,
            eAddIfNoExtension));

    IFW32FALSE_EXIT(::SxspValidateManifestAgainstCatalog(rbuffManifestName, sbCatalogName, rResult, dwOptionsFlags));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

void SxspCertFreeCtlContext( PCCTL_CONTEXT CtlContext )
{
    if (CtlContext != NULL)
        CertFreeCTLContext( CtlContext );
}

void SxspCertFreeCertContext( PCCERT_CONTEXT CertContext )
{
    if (CertContext != NULL )
        CertFreeCertificateContext(CertContext);
}



BOOL
SxspValidateCatalogAndFindManifestHash(
    IN HANDLE   hCatalogFile,
    IN PBYTE    prgbHash,
    IN SIZE_T   cbHash,
    OUT BOOL   &rfCatalogOk,
    OUT BOOL   &rfHashInCatalog
    )
{
    FN_PROLOG_WIN32

    CFileMapping            fmCatalogMapping;
    CMappedViewOfFile       mvCatalogView;
    LARGE_INTEGER           liCatalogFile;
    ULONGLONG               ullCatalogFile;
    PVOID                   pvCatalogData;
    CRYPT_VERIFY_MESSAGE_PARA vfmParameters;

    //
    // Default value
    //
    rfHashInCatalog = FALSE;
    rfCatalogOk = FALSE;

    //
    // Create a CTL context from the catalog file.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(GetFileSizeEx(hCatalogFile, &liCatalogFile));
    ullCatalogFile = liCatalogFile.QuadPart;
    IFW32FALSE_EXIT(fmCatalogMapping.Win32CreateFileMapping(hCatalogFile, PAGE_READONLY, ullCatalogFile, NULL));
    IFW32FALSE_EXIT(mvCatalogView.Win32MapViewOfFile(fmCatalogMapping, FILE_MAP_READ, 0, (SIZE_T)ullCatalogFile));

    pvCatalogData = mvCatalogView;

    //
    // First, validate that the message (catalog) is OK
    //
    ZeroMemory(&vfmParameters, sizeof(vfmParameters));
    vfmParameters.cbSize = sizeof(vfmParameters);
    vfmParameters.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;

    rfCatalogOk = CryptVerifyMessageSignature(
            &vfmParameters,
            0,
            static_cast<PBYTE>(pvCatalogData),
            static_cast<DWORD>(ullCatalogFile),
            NULL,
            NULL,
            NULL);
            
    if ( rfCatalogOk )
    {
        CSxsPointerWithNamedDestructor<const CERT_CONTEXT, SxspCertFreeCertContext> pCertContext;
        CSxsPointerWithNamedDestructor<const CTL_CONTEXT, SxspCertFreeCtlContext> pCtlContext;
        PCTL_ENTRY              pFoundCtlEntry;
        CSmallStringBuffer      buffStringizedHash;
        CTL_ANY_SUBJECT_INFO    ctlSubjectInfo;

        //
        // The search routine needs a string to find, says the crypto guys.
        //
        IFW32FALSE_EXIT(::SxspHashBytesToString( prgbHash, cbHash, buffStringizedHash));
        IFW32FALSE_EXIT(buffStringizedHash.Win32ConvertCase(eConvertToUpperCase));

        //
        // If this failed, something bad happened with the CTL - maybe the catalog
        // was invalid, maybe something else happened.  Whatever it was, let the
        // caller decide.
        //
        pCtlContext = CertCreateCTLContext(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            static_cast<PBYTE>(pvCatalogData),
            static_cast<DWORD>(ullCatalogFile));

        if ( pCtlContext != NULL )
        {
            //
            // Fill out this data with the string information.
            //
            CStringBufferAccessor sba;

            sba.Attach(&buffStringizedHash);

            ZeroMemory(&ctlSubjectInfo, sizeof(ctlSubjectInfo));
            ctlSubjectInfo.SubjectAlgorithm.pszObjId = NULL;
            ctlSubjectInfo.SubjectIdentifier.pbData = static_cast<PBYTE>(static_cast<PVOID>(sba.GetBufferPtr()));
            ctlSubjectInfo.SubjectIdentifier.cbData = static_cast<DWORD>((sba.Cch() + 1) * sizeof(WCHAR));
            sba.Detach();

            //
            // Look for it in the CTL
            //
            pFoundCtlEntry = CertFindSubjectInCTL(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                CTL_ANY_SUBJECT_TYPE,
                &ctlSubjectInfo,
                pCtlContext,
                0);

            rfHashInCatalog = ( pFoundCtlEntry != NULL );
            
        }
        
    }

    FN_EPILOG
}






BOOL
SxspValidateManifestAgainstCatalog(
    IN  const CBaseStringBuffer &rbuffManifestName,
    IN  const CBaseStringBuffer &rbuffCatalogName,
    OUT ManifestValidationResult &rResult,
    IN  DWORD dwOptionsFlags
    )
{
    FN_PROLOG_WIN32

    CFusionArray<BYTE>      ManifestHash;
    CSmallStringBuffer      rbuffStrongNameString;
    BOOL                    fTempFlag;
    BOOL                    fCatalogOk, fHashFound;
    CPublicKeyInformation   pkiCatalogInfo;
    CFusionFile             ffCatalogFile;

    //
    // Generate the hash of the manifest first
    //
    IFW32FALSE_EXIT_UNLESS2(::SxspCreateFileHash(
        HASHFLAG_STRAIGHT_HASH,
        CALG_SHA1,
        rbuffManifestName,
        ManifestHash),
        LIST_4(ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND, ERROR_BAD_NET_NAME, ERROR_BAD_NETPATH),
        fTempFlag);

    if ( fTempFlag )
    {
        rResult = ManifestValidate_ManifestMissing;
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Open the catalog file for now, we'll use it later.
    //
    IFW32FALSE_EXIT_UNLESS2(
		ffCatalogFile.Win32CreateFile(
			rbuffCatalogName,
			GENERIC_READ,
			FILE_SHARE_READ,
			OPEN_EXISTING),
		LIST_4(ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND, ERROR_BAD_NET_NAME, ERROR_BAD_NETPATH),
		fTempFlag);

    if ( fTempFlag )
    {
        rResult = ManifestValidate_CatalogMissing;
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Now look in the file to see if the catalog contains the hash of the manifest
    // in the CTL
    //
    IFW32FALSE_EXIT(SxspValidateCatalogAndFindManifestHash(
        ffCatalogFile,
        ManifestHash.GetArrayPtr(),
        ManifestHash.GetSize(),
        fCatalogOk,
        fHashFound));

    if ( !fCatalogOk )
    {
        rResult = ManifestValidate_OtherProblems;
        FN_SUCCESSFUL_EXIT();
    }
    else if ( !fHashFound )
    {
        rResult = ManifestValidate_NotCertified;
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Are we supposed to validate the strong name of this catalog?
    //
    if ( ( dwOptionsFlags & MANIFESTVALIDATE_MODE_NO_STRONGNAME ) == 0 )
    {
        IFW32FALSE_EXIT(::SxspGetStrongNameFromManifestName(
            rbuffManifestName,
            rbuffStrongNameString,
            fTempFlag));

        if ( !fTempFlag )
        {
            rResult = ManifestValidate_OtherProblems;
            FN_SUCCESSFUL_EXIT();
        }
        
        IFW32FALSE_EXIT(pkiCatalogInfo.Initialize(rbuffCatalogName));
    }

    //
    // Huzzah!
    //
    rResult = ManifestValidate_IsIntact;

    FN_EPILOG
        
}


BOOL
SxspIsFullHexString(PCWSTR wsString, SIZE_T Cch)
{
    for (SIZE_T i = 0; i < Cch; i++)
    {
        WCHAR ch = wsString[i];
        if (!SxspIsHexDigit(ch))
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\ndpclassinfo.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    clrclassinfo.cpp

Abstract:

    CLR 'surrogate' contributor for Win32-CLR interop assemblies

Author:

    Jon Wiswall (jonwis) March, 2002 (heavily borrowed from comclass.cpp)

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(runtimeVersion);

#define ALLOCATE_BUFFER_SPACE(_bytesNeeded, _bufferCursor, _bytesLeft, _bytesWritten, _typeName, _ptr) \
do { \
    if (_bytesLeft < (_bytesNeeded)) \
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER); \
    _bytesLeft -= (_bytesNeeded); \
    _bytesWritten += (_bytesNeeded); \
    _ptr = (_typeName) _bufferCursor; \
    _bufferCursor = (PVOID) (((ULONG_PTR) _bufferCursor) + (_bytesNeeded)); \
} while (0)

#define ALLOCATE_BUFFER_SPACE_TYPE(_typeName, _bufferCursor, _bytesLeft, _bytesWritten, _ptr) \
    ALLOCATE_BUFFER_SPACE(sizeof(_typeName), _bufferCursor, _bytesLeft, _bytesWritten, _typeName *, _ptr)

typedef struct _CLR_GLOBAL_CONTEXT *PCLR_GLOBAL_CONTEXT;
typedef struct _CLR_SURROGATE_ENTRY *PCLR_SURROGATE_ENTRY;

typedef struct _CLR_GLOBAL_CONTEXT
{
    _CLR_GLOBAL_CONTEXT() { }

    CSmallStringBuffer      m_FileNameBuffer;
    PCLR_SURROGATE_ENTRY    m_SurrogateList;
    ULONG                   m_SurrogateListCount;

private:
    _CLR_GLOBAL_CONTEXT(const _CLR_GLOBAL_CONTEXT &);
    void operator =(const _CLR_GLOBAL_CONTEXT &);
} CLR_GLOBAL_CONTEXT;

typedef struct _CLR_SURROGATE_ENTRY
{
public:
    _CLR_SURROGATE_ENTRY() { }

    PCLR_SURROGATE_ENTRY    m_Next;
    PCLR_GLOBAL_CONTEXT     m_GlobalContext;
    GUID                    m_ReferenceClsid;
    CSmallStringBuffer      m_TypeName;
    CSmallStringBuffer      m_RuntimeVersion;

private:
    _CLR_SURROGATE_ENTRY(const _CLR_SURROGATE_ENTRY &);
    void operator =(const _CLR_SURROGATE_ENTRY &);
} CLR_SURROGATE_ENTRY;


BOOL
SxspClrSurrogateAddSurrogate(
    PACTCTXCTB_CBELEMENTPARSED SurrogateParsed,
    PCLR_GLOBAL_CONTEXT pGlobalContext,
    PGUID_SECTION_GENERATION_CONTEXT pGsGenCtx
    );


VOID
WINAPI
SxspClrInteropContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PGUID_SECTION_GENERATION_CONTEXT GSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    PCLR_GLOBAL_CONTEXT ClrGlobalContext = NULL;

    if (GSGenContext != NULL)
        ClrGlobalContext = (PCLR_GLOBAL_CONTEXT)SxsGetGuidSectionGenerationContextCallbackContext(GSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionData(GSGenContext, Data->GetSectionData.SectionSize, Data->GetSectionData.SectionDataStart, NULL));
        Data->GetSectionData.Success = TRUE;
        break;
        
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(ClrGlobalContext == NULL);
        INTERNAL_ERROR_CHECK(GSGenContext == NULL);

        IFALLOCFAILED_EXIT(ClrGlobalContext = FUSION_NEW_SINGLETON(CLR_GLOBAL_CONTEXT));

        ClrGlobalContext->m_SurrogateList = NULL;
        ClrGlobalContext->m_SurrogateListCount = 0;

        IFW32FALSE_EXIT(
            ::SxsInitGuidSectionGenerationContext(
                &GSGenContext,
                ACTIVATION_CONTEXT_DATA_CLR_SURROGATE_FORMAT_WHISTLER,
                &::SxspClrInteropGuidSectionGenerationCallback,
                ClrGlobalContext));

        ClrGlobalContext = NULL;

        Data->Header.ActCtxGenContext = GSGenContext;
        Data->GenBeginning.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (GSGenContext != NULL)
            ::SxsDestroyGuidSectionGenerationContext(GSGenContext);

        FUSION_DELETE_SINGLETON(ClrGlobalContext);
        ClrGlobalContext = NULL;
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;

#if 0
        if (GSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingGuidSectionGenerationContext(GSGenContext));
#endif

        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionSize(GSGenContext, &Data->GetSectionSize.SectionSize));
        Data->GetSectionSize.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        {
            ULONG MappedValue = 0;
            bool fFound = false;
            
            enum MappedValues {
                eClrSurrogate,
            };

            static const WCHAR ELEMENT_PATH_BUILTIN_CLR_SURROGATE[] = L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrSurrogate";

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] = 
            {
                { 2, ELEMENT_PATH_BUILTIN_CLR_SURROGATE, NUMBER_OF(ELEMENT_PATH_BUILTIN_CLR_SURROGATE)-1, eClrSurrogate },
            };

            Data->ElementParsed.Success = FALSE;
            IFW32FALSE_EXIT(::SxspProcessElementPathMap(
                Data->ElementParsed.ParseContext,
                s_rgEntries,
                NUMBER_OF(s_rgEntries),
                MappedValue,
                fFound));

            if (!fFound)
            {
                Data->ElementParsed.Success = TRUE;
                break;
            }

            switch (MappedValue) {
            case eClrSurrogate:
                if (SxspClrSurrogateAddSurrogate(&Data->ElementParsed, ClrGlobalContext, GSGenContext))
                    Data->ElementParsed.Success = TRUE;
                break;
            }
        }
    }

    FN_EPILOG
}

BOOL
SxspClrSurrogateAddSurrogate(
    PACTCTXCTB_CBELEMENTPARSED SurrogateParsed,
    PCLR_GLOBAL_CONTEXT pGlobalContext,
    PGUID_SECTION_GENERATION_CONTEXT pGsGenCtx
    )
{
    FN_PROLOG_WIN32;
    CSmallStringBuffer RuntimeVersionBuffer;
    CSmallStringBuffer SurrogateClassNameBuffer;
    CSmallStringBuffer ClsidBuffer;
    GUID SurrogateIdent = GUID_NULL;
    bool fFound = false;
    SIZE_T cbWritten;
    PCLR_SURROGATE_ENTRY Entry;
    bool fFileContextSelfAllocated = false;

    INTERNAL_ERROR_CHECK(pGlobalContext);

    IFW32FALSE_EXIT(::SxspGetAttributeValue(
        0,
        &s_AttributeName_runtimeVersion,
        SurrogateParsed,
        fFound,
        sizeof(RuntimeVersionBuffer),
        &RuntimeVersionBuffer,
        cbWritten,
        NULL, 0));

    IFW32FALSE_EXIT(::SxspGetAttributeValue(
        SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
        &s_AttributeName_name,
        SurrogateParsed,
        fFound,
        sizeof(SurrogateClassNameBuffer),
        &SurrogateClassNameBuffer,
        cbWritten,
        NULL, 0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(::SxspGetAttributeValue(
        SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
        &s_AttributeName_clsid,
        SurrogateParsed,
        fFound,
        sizeof(ClsidBuffer),
        &ClsidBuffer,
        cbWritten,
        NULL, 0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(SxspParseGUID(ClsidBuffer, ClsidBuffer.Cch(), SurrogateIdent));

    //
    // If we were doing something other than generating an actctx, then we can leap out.
    //
    if (SurrogateParsed->Header.ManifestOperation != MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        FN_SUCCESSFUL_EXIT();

    IFALLOCFAILED_EXIT(Entry = FUSION_NEW_SINGLETON(CLR_SURROGATE_ENTRY));

    Entry->m_ReferenceClsid = SurrogateIdent;
    IFW32FALSE_EXIT(Entry->m_RuntimeVersion.Win32Assign(RuntimeVersionBuffer));
    IFW32FALSE_EXIT(Entry->m_TypeName.Win32Assign(SurrogateClassNameBuffer));

    IFW32FALSE_EXIT(::SxsAddGuidToGuidSectionGenerationContext(
        pGsGenCtx,
        &SurrogateIdent,
        Entry,
        SurrogateParsed->AssemblyContext->AssemblyRosterIndex,
        ERROR_SXS_DUPLICATE_CLSID));

    Entry->m_Next = pGlobalContext->m_SurrogateList;
    pGlobalContext->m_SurrogateList = Entry->m_Next;
    pGlobalContext->m_SurrogateListCount++;
    
    FN_EPILOG;        
}

BOOL WINAPI
SxspClrInteropGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    FN_PROLOG_WIN32

    PCLR_GLOBAL_CONTEXT ClrGlobalContext = (PCLR_GLOBAL_CONTEXT) Context;
    INTERNAL_ERROR_CHECK(CallbackData != NULL);

    switch (Reason)
    {
    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            INTERNAL_ERROR_CHECK( ClrGlobalContext != NULL );

            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PCLR_SURROGATE_ENTRY Entry = (PCLR_SURROGATE_ENTRY) CBData->DataContext;

            if (Entry != NULL)
            {
                FUSION_DELETE_SINGLETON(Entry);
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PCLR_SURROGATE_ENTRY Entry = (PCLR_SURROGATE_ENTRY) CBData->DataContext;

            INTERNAL_ERROR_CHECK(!Entry->m_TypeName.IsEmpty());

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_CLR_SURROGATE);
            CBData->DataSize += (Entry->m_RuntimeVersion.Cch() + 1) * sizeof(WCHAR);
            CBData->DataSize += (Entry->m_TypeName.Cch() + 1) * sizeof(WCHAR);
            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PCLR_SURROGATE_ENTRY Entry = (PCLR_SURROGATE_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_CLR_SURROGATE Info;
            PVOID Cursor = CBData->Buffer;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            ALLOCATE_BUFFER_SPACE_TYPE(ACTIVATION_CONTEXT_DATA_CLR_SURROGATE, Cursor, BytesLeft, BytesWritten, Info);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_CLR_SURROGATE);
            Info->Flags = 0;
            Info->SurrogateIdent = Entry->m_ReferenceClsid;

            IFW32FALSE_EXIT(Entry->m_RuntimeVersion.Win32CopyIntoBuffer(
                (PWSTR*)&Cursor,
                &BytesLeft,
                &BytesWritten,
                Info,
                &Info->VersionOffset,
                &Info->VersionLength));

            IFW32FALSE_EXIT(Entry->m_TypeName.Win32CopyIntoBuffer(
                (PWSTR*)&Cursor,
                &BytesLeft,
                &BytesWritten,
                Info,
                &Info->TypeNameOffset,
                &Info->TypeNameLength));

            CBData->BytesWritten = BytesWritten;

            break;
        }
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\nodefactory.cpp ===
#include "stdinc.h"
#include "actctxgenctx.h"

#define DEFINE_ATTRIBUTE(attributeName, attributeType, typePrefix) \
    { \
        L ## #attributeName, \
        offsetof(CNodeFactory, m_ ## typePrefix ## _ ## attributeName), \
        offsetof(CNodeFactory, m_f ## attributeName ## _ ## Present), \
        &CNodeFactory::XMLParser_Parse_ ## attributeType \
    },

const static ASSEMBLY_VERSION assemblyVersion0 = {0,0,0,0};

typedef enum _in_xml_tag_when_identity_generated_{
    SXS_IN_INVALID_XML_TAG_WHEN_ASSEMBLY_IDENTITY_GENERATED,
    SXS_IN_ASSEMBLY_TAG,
    SXS_IN_DEPENDENCY_TAG
}SXS_IN_XML_TAG_WHEN_IDENTITY_GENERATED;

static
VOID
SxspDbgPrintXmlNodeInfo(
    ULONG Level,
    XML_NODE_INFO *pNode
 );

static
PCSTR
SxspFormatXmlNodeType(
    DWORD dwType
 );

struct EventIdErrorPair
{
    DWORD   dwEventId;
    LONG    nError;
};

const static EventIdErrorPair eventIdToErrorMap[] =
{
    #include "Messages.hi" // generated from .x file, like .mc
};

// deliberately no extra paranetheses here
#define NODEFACTORY_STRING_AND_LENGTH(x) x, NUMBER_OF(x) - 1

const static SXS_NAME_LENGTH_PAIR IgnoredAttributesInDependencyTagForIdentity[]={
    //maybe more later
    { NODEFACTORY_STRING_AND_LENGTH(L"Description") }
};

const DWORD IGNORED_ATTRIBUTE_NUM_IN_DEPENDENCY_TAG = NUMBER_OF(IgnoredAttributesInDependencyTagForIdentity);

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(baseInterface);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(description);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(flags);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(hash);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(hashalg);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(helpdir);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(iid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(language);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(loadFrom);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(manifestVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(metadataSatellite);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(newVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(numMethods);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(oldVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(optional);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(processorArchitecture);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(progid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(proxyStubClsid32);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(publicKeyToken);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(publicKey);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(resourceid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(runtimeVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(size);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(threadingModel);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(tlbid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(type);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(version);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(versioned);

    // How to interpret the parser worker rules here:
    //
    //  First, the state of the parser must match m_xps for the rule to be considered.
    //      If the value eNotParsing is in the table, it matches any current parser
    //      state.  Use this to globally ignore some particular tag type when
    //      combined with a NULL m_pszTag and NULL m_pfn.
    //  Second, the type of the tag from the XML parser must match m_dwType.
    //  If m_pszTag is not NULL, a case-insensitive comparison is done between the
    //      string m_pszTag points to and the tag from the XML parser.  An m_pszTag
    //      value of NULL matches any tag.
    //  If the three criteria match, the worker function is called.  The worker function
    //  pointer may be NULL, in which case no action is taken.  (This is useful for
    //  callbacks from the parser about XML_WHITESPACE where we don't really have to do
    //  anything at all.)
    //

#define DEFINE_TAG_WORKER_IGNOREALLOFTYPE(dwType) { CNodeFactory::eNotParsing, (dwType), NULL, NULL, NULL, 0, 0, 0, NULL }

    //
    //  Notes on use of the DEFINE_TAG_WORKER_ELEMENT() macro:
    //
    //  The first parameter, sourceState, is part of the name of a XMLParseState
    //  enumeration value.  It is concatenated onto "eParsing" to form the name of
    //  the state which the rule will match.
    //
    //  The second parameter is both the text of the tag to match and is used to
    //  form the name of the function to invoke if the rule matches.  The tag is
    //  compared case-insensitively, and the name of the member function invoked
    //  is XMLParser_Element_ followed by the sourceState string followed by another
    //  underscore, followed by the tagName string.  So, for example, the following
    //  rule:
    //
    //  DEFINE_TAG_WORKER_ELEMENT(DepAssy, Version)
    //
    //  says that when the parser is in the eParsingDepAssy state and a "Version"
    //  tag is found, call the function CNodeFactory::XMLParser_Element_DepAssy_Version().
    //

#define DEFINE_TAG_WORKER_ELEMENT(sourceState, tagName) \
    { \
        CNodeFactory::eParsing_ ## sourceState, \
        XML_ELEMENT, \
        SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE, \
        L ## #tagName, \
        s_rg_ ## sourceState ## _ ## tagName ## _attributes, \
        NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE) - 1, \
        NUMBER_OF(L ## #tagName) - 1, \
        NUMBER_OF(s_rg_ ## sourceState ## _ ## tagName ## _attributes), \
        &CNodeFactory::XMLParser_Element_ ## sourceState ## _ ## tagName, \
        CNodeFactory::eParsing_ ## sourceState ## _ ## tagName \
    }

#define DEFINE_TAG_WORKER_ELEMENT_NOCB(sourceState, tagName) \
    { \
        CNodeFactory::eParsing_ ## sourceState, \
        XML_ELEMENT, \
        SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE, \
        L ## #tagName, \
        s_rg_ ## sourceState ## _ ## tagName ## _attributes, \
        NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE) - 1, \
        NUMBER_OF(L ## #tagName) - 1, \
        NUMBER_OF(s_rg_ ## sourceState ## _ ## tagName ## _attributes), \
        NULL, \
        CNodeFactory::eParsing_ ## sourceState ## _ ## tagName \
    }

#define DEFINE_TAG_WORKER_ELEMENT_NONS(sourceState, tagName) \
    { \
        CNodeFactory::eParsing_ ## sourceState, \
        XML_ELEMENT, \
        NULL, \
        L ## #tagName, \
        s_rg_ ## sourceState ## _ ## tagName ## _attributes, \
        0, \
        NUMBER_OF(L ## #tagName) - 1, \
        NUMBER_OF(s_rg_ ## sourceState ## _ ## tagName ## _attributes), \
        &CNodeFactory::XMLParser_Element_ ## sourceState ## _ ## tagName, \
        CNodeFactory::eParsing_ ## sourceState ## _ ## tagName \
    }

#define BEGIN_ELEMENT_LEGAL_ATTRIBUTES(_element) \
const static ELEMENT_LEGAL_ATTRIBUTE s_rg_ ## _element ## _attributes[] = { \
    { ELEMENT_LEGAL_ATTRIBUTE_FLAG_IGNORE, NULL, NULL },

#define DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(attributeName, validatorFlags, validator) { ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED, &s_AttributeName_ ## attributeName, validator, validatorFlags },
#define DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(attributeName, validatorFlags, validator) { 0, &s_AttributeName_ ## attributeName, validator, validatorFlags },

#define END_ELEMENT_LEGAL_ATTRIBUTES(_element) };

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(manifestVersion, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_description)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_description)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_noInherit)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_noInherit)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_noInheritable)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_noInheritable)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_assemblyIdentity)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(version, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(type, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(processorArchitecture, SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED, &::SxspValidateProcessorArchitectureAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKeyToken, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(language, 0, &::SxspValidateLanguageAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKey, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_assemblyIdentity)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(optional, 0, &::SxspValidateBoolAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly_assemblyIdentity)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(type, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(version, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(processorArchitecture, SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED, &::SxspValidateProcessorArchitectureAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKeyToken, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(language, SXSP_VALIDATE_LANGUAGE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED, &::SxspValidateLanguageAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly_assemblyIdentity)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly_bindingRedirect)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(oldVersion, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(newVersion, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly_bindingRedirect)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(hash, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(hashalg, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(loadFrom, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(size, 0, &::SxspValidateUnsigned64Attribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comClass)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(clsid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(threadingModel, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(progid, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(description, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comClass)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comClass_progid)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comClass_progid)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrClass)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(clsid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(progid, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(description, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(runtimeVersion, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(threadingModel, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrClass)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrSurrogate)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(clsid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(runtimeVersion, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_clrSurrogate)


BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrClass_progid)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrClass_progid)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comInterfaceProxyStub)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(iid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(numMethods, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(baseInterface, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(proxyStubClsid32, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(threadingModel, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comInterfaceProxyStub)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_typelib)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(version, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(helpdir, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(resourceid, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(flags, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_typelib)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_windowClass)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(versioned, 0, &::SxspValidateBoolAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_windowClass)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_comInterfaceExternalProxyStub)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(iid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(proxyStubClsid32, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(numMethods, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(baseInterface, 0, &::SxspValidateGuidAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_comInterfaceExternalProxyStub)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_assemblyIdentity)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(version, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(type, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(processorArchitecture,  0, &::SxspValidateProcessorArchitectureAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKeyToken, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(language, 0, &::SxspValidateLanguageAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_assemblyIdentity)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(processorArchitecture,  0, &::SxspValidateProcessorArchitectureAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(type, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKeyToken, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(language, 0, &::SxspValidateLanguageAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(oldVersion, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(newVersion, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect)

static const struct
{
    CNodeFactory::XMLParseState m_xpsOld;
    DWORD m_dwType;
    PCWSTR m_pszNamespace;
    PCWSTR m_pszName;
    PCELEMENT_LEGAL_ATTRIBUTE m_prgLegalAttributes;
    UCHAR m_cchNamespace;           // We use UCHAR here just for greater data density.  Changing this and rebuilding
    UCHAR m_cchName;                // this module should work fine if you really need namespaces or names longer than
                                    // 255 characters.
    UCHAR m_cLegalAttributes;
    CNodeFactory::XMLParserWorkerFunctionPtr m_pfn;
    CNodeFactory::XMLParseState m_xpsNew;
} s_rgWorkers[] =
{
    DEFINE_TAG_WORKER_IGNOREALLOFTYPE(XML_WHITESPACE),
    DEFINE_TAG_WORKER_IGNOREALLOFTYPE(XML_COMMENT),
    DEFINE_TAG_WORKER_ELEMENT(doc, assembly),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly, assemblyIdentity),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, description),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly, noInherit),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly, noInheritable),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly, dependency),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly_dependency, dependentAssembly),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly_dependency_dependentAssembly, assemblyIdentity),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly_dependency_dependentAssembly, bindingRedirect),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, file),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file, comClass),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file_comClass, progid),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, clrClass),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_clrClass, progid),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file, comInterfaceProxyStub),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file, typelib),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file, windowClass),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, clrSurrogate),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, comInterfaceExternalProxyStub),

    // All app config productions go here, just for neatness
    DEFINE_TAG_WORKER_ELEMENT_NONS(doc, configuration),
    DEFINE_TAG_WORKER_ELEMENT_NONS(doc_configuration, windows),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows, assemblyBinding),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding, assemblyIdentity),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding, dependentAssembly),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding_dependentAssembly, assemblyIdentity),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding_dependentAssembly, bindingRedirect),
};

BOOL
SxspIsNamespaceDeclaration(XML_NODE_INFO *pNodeInfo)
{
    FN_TRACE();

    ASSERT(pNodeInfo->dwType == XML_ATTRIBUTE);
    if (pNodeInfo->ulLen >= 5)
    { // "xmlns" : prefix for namespace declaration, default ns or non-default ns
        if ((pNodeInfo->pwcText[0] == L'x') &&
            (pNodeInfo->pwcText[1] == L'm') &&
            (pNodeInfo->pwcText[2] == L'l') &&
            (pNodeInfo->pwcText[3] == L'n') &&
            (pNodeInfo->pwcText[4] == L's'))
        {
            if (pNodeInfo->ulLen == 5) // like xmlns="", default ns declaration
                return TRUE;
            else
                if (pNodeInfo->pwcText[5] == L':')
                    return TRUE;
        }
    }

    return FALSE;
}
//In this function, two tasks:
// 1) verify PublicKey and StrongName
// 2) create AssemblyIdentity based on xmlnode array
// 3) for (name, processorArchitecure, version. langid) they would be unique with SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE
// 4) if there are dup triples {nsURL, name, value), only one is count, this is done with SxsCreateAssemblyIdentity
BOOL
SxspCreateAssemblyIdentityFromIdentityElement(
    DWORD Flags,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    DWORD cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    DWORD i;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    CStringBuffer buffValue;

    if (AssemblyIdentityOut != NULL)
         *AssemblyIdentityOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_CREATE_ASSEMBLY_IDENTITY_FROM_IDENTITY_TAG_FLAG_VERIFY_PUBLIC_KEY_IF_PRESENT)) == 0);
    PARAMETER_CHECK((Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) || (Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE));
    PARAMETER_CHECK(AssemblyIdentityOut != NULL);
    PARAMETER_CHECK(prgNodeInfo != NULL);
    PARAMETER_CHECK(prgNodeInfo[0].Type == XML_ELEMENT);

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, Type, &AssemblyIdentity, 0, NULL));

    i = 1;
    while (i<cNumRecs)
    {
        ULONG j;
        INTERNAL_ERROR_CHECK(prgNodeInfo[i].Type == XML_ATTRIBUTE);

        buffValue.Clear();

        j = i + 1;

        while ((j < cNumRecs) && (prgNodeInfo[j].Type == XML_PCDATA))
        {
            IFW32FALSE_EXIT(buffValue.Win32Append(prgNodeInfo[j].pszText, prgNodeInfo[j].cchText));

            j++;
        }

        // if this is a special attribute, we'll handle it ... specially.
        if ((prgNodeInfo[i].NamespaceStringBuf.Cch() == 0) &&
            (::FusionpCompareStrings(
                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY,
                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_CCH,
                prgNodeInfo[i].pszText,
                prgNodeInfo[i].cchText,
                false) == 0))
        {// ignore publicKey if it appears in assembly identity
        }
        else
        {
            ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;

            Attribute.Flags = 0;
            Attribute.NamespaceCch  = prgNodeInfo[i].NamespaceStringBuf.Cch();
            Attribute.Namespace     = prgNodeInfo[i].NamespaceStringBuf;
            Attribute.NameCch       = prgNodeInfo[i].cchText;
            Attribute.Name          = prgNodeInfo[i].pszText;
            Attribute.ValueCch      = buffValue.Cch();
            Attribute.Value         = buffValue;

            IFW32FALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(0, AssemblyIdentity, &Attribute));
        }

        i = j;
    }

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;
Exit:
    if (AssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(AssemblyIdentity);
    return fSuccess;
}

CNodeFactory::CNodeFactory()
        : m_ActCtxGenCtx(NULL),
          m_Assembly(NULL),
          m_fFirstCreateNodeCall(true),
          m_cUnknownChildDepth(0),
          m_xpsParseState(eParsing_doc),
          m_fAssemblyFound(false),
          m_fIdentityFound(false),
          m_AssemblyContext(NULL),
          m_CurrentPolicyDependentAssemblyIdentity(NULL),
          m_CurrentPolicyStatement(NULL),
          m_IntuitedParseType(eActualParseType_Undetermined),
          m_pApplicationPolicyTable(NULL),
          m_fNoInheritableFound(false)
{
    m_ParseContext.XMLElementDepth = 0;
    m_ParseContext.ElementPath = NULL;
    m_ParseContext.ElementPathCch = 0;
    m_ParseContext.ElementName = NULL;
    m_ParseContext.ElementPathCch = 0;
    m_ParseContext.ElementHash = 0;
}

CNodeFactory::~CNodeFactory()
{
    CSxsPreserveLastError ple;

    if ((m_CurrentPolicyStatement != NULL) &&
        (m_CurrentPolicyDependentAssemblyIdentity != NULL) &&
        (m_pApplicationPolicyTable != NULL))
    {
        if (m_pApplicationPolicyTable->Find(m_buffCurrentApplicationPolicyIdentityKey, m_CurrentPolicyStatement))
            m_CurrentPolicyStatement = NULL;
    }

    FUSION_DELETE_SINGLETON(m_CurrentPolicyStatement);

    if (m_CurrentPolicyDependentAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(m_CurrentPolicyDependentAssemblyIdentity);

    if (m_Assembly != NULL)
    {
        m_Assembly->Release();
        m_Assembly = NULL;
    }

    ple.Restore();
}

BOOL
CNodeFactory::Initialize(
    PACTCTXGENCTX ActCtxGenCtx,
    PASSEMBLY Assembly,
    PACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(Assembly != NULL);

#if FUSION_XML_TREE
    IFW32FALSE_EXIT(m_ParseTreeStringPool.Initialize());
#endif // FUSION_XML_TREE

    IFW32FALSE_EXIT(m_XMLNamespaceManager.Initialize());

    m_ActCtxGenCtx = ActCtxGenCtx;

    Assembly->AddRef();
    if (m_Assembly != NULL)
        m_Assembly->Release();
    m_Assembly = Assembly;

    m_AssemblyContext = AssemblyContext;
    m_ParseContext.AssemblyContext = AssemblyContext;
    m_ParseContext.ErrorCallbacks.MissingRequiredAttribute = &CNodeFactory::ParseErrorCallback_MissingRequiredAttribute;
    m_ParseContext.ErrorCallbacks.AttributeNotAllowed = &CNodeFactory::ParseErrorCallback_AttributeNotAllowed;
    m_ParseContext.ErrorCallbacks.InvalidAttributeValue = &CNodeFactory::ParseErrorCallback_InvalidAttributeValue;
    m_ParseContext.SourceFilePathType = AssemblyContext->ManifestPathType;
    m_ParseContext.SourceFile = AssemblyContext->ManifestPath;
    m_ParseContext.SourceFileCch = AssemblyContext->ManifestPathCch;
    m_ParseContext.LineNumber = 0;

#if FUSION_XML_TREE
    m_XmlDocument.Flags = 0;
    m_XmlDocument.StringCount = 0;
    m_XmlDocument.Strings = NULL;
    InitializeListHead(&m_XmlDocument.ElementListHead);
    m_CurrentNode = NULL;
    m_CurrentParent = NULL;
#endif // FUSION_XML_TREE

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID
CNodeFactory::ResetParseState()
{
    m_fFirstCreateNodeCall = true;
    m_fAssemblyFound = false;
    m_fIdentityFound = false;
    m_fNoInheritableFound = false;

    FUSION_DELETE_SINGLETON(m_CurrentPolicyStatement);
    m_CurrentPolicyStatement = NULL;

    ::SxsDestroyAssemblyIdentity(m_CurrentPolicyDependentAssemblyIdentity);
    m_CurrentPolicyDependentAssemblyIdentity = NULL;
}

HRESULT
CNodeFactory::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (riid == __uuidof(this))
        pIUnknown = this;
    else if ((riid == IID_IUnknown) ||
        (riid == IID_IXMLNodeFactory))
        pIUnknown = static_cast<IXMLNodeFactory *>(this);
    else
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Node factory asked for unknown interface\n");

        hr = E_NOINTERFACE;
        goto Exit;
    }

    pIUnknown->AddRef();
    *ppvObj = pIUnknown;
    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CNodeFactory::NotifyEvent(
    IXMLNodeSource *pSource,
    XML_NODEFACTORY_EVENT iEvt
    )
{
    return NOERROR;
}

HRESULT
CNodeFactory::ConvertXMLNodeInfoToSXSNodeInfo(
	const XML_NODE_INFO *pNodeInfo,
	SXS_NODE_INFO &rSXSNodeInfo
	)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    INTERNAL_ERROR_CHECK(pNodeInfo != NULL);

    rSXSNodeInfo.Size = pNodeInfo->dwSize;
    rSXSNodeInfo.Type = pNodeInfo->dwType;

    switch (pNodeInfo->dwType)
    {
    case XML_ELEMENT:
        {
            SIZE_T cchNamespacePrefix;
            IFCOMFAILED_EXIT(
                m_XMLNamespaceManager.Map(
                    0,
                    pNodeInfo,
                    &rSXSNodeInfo.NamespaceStringBuf,
                    &cchNamespacePrefix));

            // +1 to skip colon
            rSXSNodeInfo.pszText = pNodeInfo->pwcText + ((cchNamespacePrefix != 0) ? (cchNamespacePrefix + 1) : 0);
            rSXSNodeInfo.cchText = pNodeInfo->ulLen - ((cchNamespacePrefix != 0) ? (cchNamespacePrefix + 1) : 0);

            break;
        }

    case XML_ATTRIBUTE:
        {
            SIZE_T cchNamespacePrefix;
            // if this is a namespace definition, ignore
            const PCWSTR pwcText = pNodeInfo->pwcText;
            if ((pwcText[0] == L'x') &&
                (pwcText[1] == L'm') &&
                (pwcText[2] == L'l') &&
                (pwcText[3] == L'n') &&
                (pwcText[4] == L's') &&
                ((pwcText[5] == L':') ||
                 (pwcText[5] == L'=')))
            {
                rSXSNodeInfo.pszText = pNodeInfo->pwcText;
                rSXSNodeInfo.cchText = pNodeInfo->ulLen;
            }
            else
            {
                IFCOMFAILED_EXIT(
                    m_XMLNamespaceManager.Map(
                        CXMLNamespaceManager::eMapFlag_DoNotApplyDefaultNamespace,
                        pNodeInfo,
                        &rSXSNodeInfo.NamespaceStringBuf,
                        &cchNamespacePrefix));

                // +1 to skip colon
                rSXSNodeInfo.pszText = pNodeInfo->pwcText + ((cchNamespacePrefix != 0) ? (cchNamespacePrefix + 1) : 0);
                rSXSNodeInfo.cchText = pNodeInfo->ulLen - ((cchNamespacePrefix != 0) ? (cchNamespacePrefix + 1) : 0);
            }
            break;
        }

    default:
        // Otherwise we'll assume there's no namespace processing to do...
        rSXSNodeInfo.NamespaceStringBuf.Clear();
        rSXSNodeInfo.pszText = pNodeInfo->pwcText;
        rSXSNodeInfo.cchText = pNodeInfo->ulLen;
        break;
    }

	FN_EPILOG
}

HRESULT
CNodeFactory::BeginChildren(
    IXMLNodeSource *pSource,
    XML_NODE_INFO *pNodeInfo
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    ULONG i;
    SXS_NODE_INFO SXSNodeInfo;

    IFCOMFAILED_EXIT(m_XMLNamespaceManager.OnBeginChildren(pSource, pNodeInfo));

    IFCOMFAILED_EXIT(this->ConvertXMLNodeInfoToSXSNodeInfo(pNodeInfo, SXSNodeInfo));
    for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(
            m_ActCtxGenCtx->m_Contributors[i].Fire_BeginChildren(
                m_ActCtxGenCtx,
                m_AssemblyContext,
                &m_ParseContext,
                &SXSNodeInfo));
    }

    FN_EPILOG
}

HRESULT
CNodeFactory::EndChildren(
    IXMLNodeSource *pSource,
    BOOL Empty,
    XML_NODE_INFO *pNodeInfo
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ULONG i;
    PWSTR Bang;
    SXS_NODE_INFO SXSNodeInfo;

    // Short-circuit PIs, XML-decls, whitespace and comments
    if ((pNodeInfo->dwType == XML_PI) ||
        (pNodeInfo->dwType == XML_XMLDECL) ||
        (pNodeInfo->dwType == XML_COMMENT) ||
        (pNodeInfo->dwType == XML_WHITESPACE))
    {
        hr = NOERROR;
        goto Exit;
    }

    IFCOMFAILED_EXIT(m_XMLNamespaceManager.OnEndChildren(pSource, Empty, pNodeInfo));
    // We hit the end of something; if we're skipping stuff, we're one level back towards
    // paying attention.
    if (m_cUnknownChildDepth != 0)
    {
        m_cUnknownChildDepth--;
    }
    else
    {
        ULONG j;

        for (j=0; j<NUMBER_OF(s_rgWorkers); j++)
        {
            if (s_rgWorkers[j].m_xpsNew == m_xpsParseState)
            {
                m_xpsParseState = s_rgWorkers[j].m_xpsOld;
                break;
            }
        }

        if (j == NUMBER_OF(s_rgWorkers))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s() called when we were not expecting it.  m_xpsParseState = %d\n", __FUNCTION__, m_xpsParseState);

            INTERNAL_ERROR_CHECK(FALSE);
            // Hey, how the heck did we get here?
        }

        // One time end-of-manifest checks...
        if (m_xpsParseState == eParsing_doc)
        {
            switch (m_ParseType)
            {
            default:
                INTERNAL_ERROR_CHECK(false);
                break;

            case XML_FILE_TYPE_COMPONENT_CONFIGURATION:
            case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
                break;

            case XML_FILE_TYPE_MANIFEST:
                // If this is not the root assembly, this is not a noInherit actctx and the noInheritable
                // element was not found, issue an error.
                if (((m_AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY) == 0) &&
                    m_ActCtxGenCtx->m_NoInherit &&
                    !m_fNoInheritableFound)
                {
                    this->LogParseError(MSG_SXS_NOINHERIT_REQUIRES_NOINHERITABLE);
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(NoInheritRequiresNoInheritable, ERROR_SXS_MANIFEST_PARSE_ERROR);
                }
                break;
            }
        }
    }

#if FUSION_XML_TREE
    m_CurrentParent = const_cast<PSXS_XML_NODE>(m_CurrentParent->Parent);
#endif // FUSION_XML_TREE

    if (pNodeInfo->dwType != XML_XMLDECL)
    {
        IFCOMFAILED_EXIT(this->ConvertXMLNodeInfoToSXSNodeInfo(pNodeInfo, SXSNodeInfo));

        for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
        {
            IFW32FALSE_EXIT(
                m_ActCtxGenCtx->m_Contributors[i].Fire_EndChildren(
                    m_ActCtxGenCtx,
                    m_AssemblyContext,
                    &m_ParseContext,
                    Empty,
                    &SXSNodeInfo));
        }

        INTERNAL_ERROR_CHECK(m_ParseContext.XMLElementDepth != 0);

        m_ParseContext.XMLElementDepth--;
        Bang = wcsrchr(m_buffElementPath, L'!');

        INTERNAL_ERROR_CHECK(((Bang == NULL) == (m_ParseContext.XMLElementDepth == 0)));

        if (Bang != NULL)
        {
            m_buffElementPath.Left(Bang - m_buffElementPath);
            m_ParseContext.ElementPathCch = m_buffElementPath.Cch();
            m_ParseContext.ElementPath = m_buffElementPath;
            m_ParseContext.ElementName = wcsrchr(m_buffElementPath, L'!');
            if (m_ParseContext.ElementName == NULL)
            {
                m_ParseContext.ElementName = m_buffElementPath;
                m_ParseContext.ElementNameCch = m_buffElementPath.Cch();
            }
            else
            {
                m_ParseContext.ElementName++;
                m_ParseContext.ElementNameCch = m_buffElementPath.Cch() - (m_ParseContext.ElementName - m_buffElementPath);
            }

            IFW32FALSE_ORIGINATE_AND_EXIT(
                ::SxspHashString(
                    m_buffElementPath,
                    m_ParseContext.ElementPathCch,
                    &m_ParseContext.ElementHash,
                    false));
        }
        else
        {
            m_buffElementPath.Clear();
            m_ParseContext.ElementPath = NULL;
            m_ParseContext.ElementPathCch = 0;
            m_ParseContext.ElementName = NULL;
            m_ParseContext.ElementNameCch = 0;
            m_ParseContext.ElementHash = 0;
            m_ParseContext.XMLElementDepth = 0;
        }
    }

    hr = NOERROR;

Exit:
    return hr;
}

HRESULT
CNodeFactory::Error(
    IXMLNodeSource *pSource,
    HRESULT hrErrorCode,
    USHORT cNumRecs,
    XML_NODE_INFO **apNodeInfo
    )
{
    CSxsPreserveLastError ple;
    ::FusionpConvertCOMFailure(hrErrorCode);
    ::FusionpSetLastErrorFromHRESULT(hrErrorCode);
    this->LogParseError(MSG_SXS_WIN32_ERROR_MSG_WHEN_PARSING_MANIFEST, CEventLogLastError());
    ple.Restore();
    return NOERROR;
}

HRESULT
CNodeFactory::FirstCreateNodeCall(
    IXMLNodeSource *pSource,
    PVOID pNodeParent,
    USHORT NodeCount,
    const SXS_NODE_INFO *prgNodeInfo
    )
{
    HRESULT hr = S_OK;
    FN_TRACE_HR(hr);
    ULONG i;
    const static WCHAR rgch1_0[] = L"1.0";
    const static UNICODE_STRING ustr1_0 = CONSTANT_UNICODE_STRING(rgch1_0);
    bool fGotGoodManifestVersion = false;
    bool fGotAnyManifestVersion = false;

    // It's our first IXMLNodeFactory::CreateNode() call.  This had better
    // be an <ASSEMBLY MANIFESTVERSION="1.0" ...> deal.

    for (i=0; i<NodeCount; i++)
    {
        if (prgNodeInfo[i].Type == XML_ELEMENT)
        {
            INTERNAL_ERROR_CHECK(i == 0);

            switch (m_ParseType)
            {
            default:
                INTERNAL_ERROR_CHECK(false);
                break;

            case XML_FILE_TYPE_MANIFEST:
            case XML_FILE_TYPE_COMPONENT_CONFIGURATION:
                if ((prgNodeInfo[i].cchText != (NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY) - 1)) ||
                    (prgNodeInfo[i].NamespaceStringBuf.Cch() != (NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE) - 1)) ||
                    (memcmp(prgNodeInfo[i].pszText, SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY, prgNodeInfo[i].cchText * sizeof(WCHAR)) != 0) ||
                    (memcmp(prgNodeInfo[i].NamespaceStringBuf, SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE, prgNodeInfo[i].NamespaceStringBuf.Cch() * sizeof(WCHAR)) != 0))
                {
                    IFCOMFAILED_EXIT(this->LogParseError(MSG_SXS_MANIFEST_INCORRECT_ROOT_ELEMENT));
                }
                break;

            case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
                if ((prgNodeInfo[i].cchText != SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION_CCH) ||
                    (prgNodeInfo[i].NamespaceStringBuf.Cch() != 0) ||
                    (memcmp(prgNodeInfo[i].pszText, SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION,
                        SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION_CCH * sizeof(WCHAR)) != 0))
                {
                    IFCOMFAILED_EXIT(this->LogParseError(MSG_SXS_MANIFEST_INCORRECT_ROOT_ELEMENT));
                }
                break;
            }
        }
        else if (prgNodeInfo[i].Type == XML_ATTRIBUTE)
        {
            if ((prgNodeInfo[i].cchText == (NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION) - 1)) &&
                (prgNodeInfo[i].NamespaceStringBuf.Cch() == 0) &&
                (memcmp(prgNodeInfo[i].pszText, SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION, prgNodeInfo[i].cchText * sizeof(WCHAR)) == 0))
            {
                fGotAnyManifestVersion = true;

                ULONG j = i + 1;

                if (j < NodeCount)
                {
                    if (prgNodeInfo[j].Type == XML_PCDATA)
                    {
                        if (prgNodeInfo[j].cchText == 3)
                        {
                            if (memcmp(prgNodeInfo[j].pszText, L"1.0", prgNodeInfo[j].cchText * sizeof(WCHAR)) == 0)
                            {
                                fGotGoodManifestVersion = true;
                            }
                        }
                    }
                }
            }
        }
    }

    if ((m_ParseType == XML_FILE_TYPE_MANIFEST) ||
        (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION))
    {
        if (fGotAnyManifestVersion)
        {
            if (!fGotGoodManifestVersion)
                IFCOMFAILED_EXIT(this->LogParseError(MSG_SXS_MANIFEST_VERSION_ERROR));
        }
        else
            IFCOMFAILED_EXIT(this->LogParseError(MSG_SXS_MANIFEST_VERSION_MISSING));
    }

    m_Assembly->m_ManifestVersionMajor = 1;
    m_Assembly->m_ManifestVersionMinor = 0;

    hr = NOERROR;

Exit:
    return hr;
}

HRESULT
CNodeFactory::CreateNode(
    IXMLNodeSource *pSource,
    PVOID pNodeParent,
    USHORT NodeCount,
    XML_NODE_INFO **apNodeInfo
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    ULONG i;
    PSXS_XML_NODE pXmlNode = NULL;
    PSXS_NODE_INFO pSXSNodeInfo = NULL;
    SIZE_T cchTemp;

    m_ParseContext.LineNumber = pSource->GetLineNumber();

    INTERNAL_ERROR_CHECK(NodeCount != 0);

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_NODEFACTORY,
        "SXS.DLL: " __FUNCTION__ "() entered\n"
        "   m_ParseContext.XMLElementDepth = %lu\n",
        m_ParseContext.XMLElementDepth);

    for (i=0; i<NodeCount; i++)
        ::SxspDbgPrintXmlNodeInfo(FUSION_DBG_LEVEL_NODEFACTORY, apNodeInfo[i]);
#endif

    // Short-circuit PIs, XML-decls, whitespace and comments
    if ((apNodeInfo[0]->dwType == XML_PI) ||
        (apNodeInfo[0]->dwType == XML_XMLDECL) ||
        (apNodeInfo[0]->dwType == XML_COMMENT) ||
        (apNodeInfo[0]->dwType == XML_WHITESPACE))
    {
        hr = NOERROR;
        goto Exit;
    }
    
    IFCOMFAILED_EXIT(m_XMLNamespaceManager.OnCreateNode(pSource, pNodeParent, NodeCount, apNodeInfo));

    IFALLOCFAILED_EXIT(pSXSNodeInfo = new SXS_NODE_INFO[NodeCount]);
    for (i=0; i<NodeCount; i++)
        IFCOMFAILED_EXIT(this->ConvertXMLNodeInfoToSXSNodeInfo(apNodeInfo[i], pSXSNodeInfo[i]));

    if (m_fFirstCreateNodeCall)
    {
        if ((apNodeInfo[0]->dwType == XML_COMMENT) ||
             (apNodeInfo[0]->dwType == XML_XMLDECL) ||
             (apNodeInfo[0]->dwType == XML_WHITESPACE))
        {
            hr = S_OK;
            goto Cont;
        }

        m_fFirstCreateNodeCall = FALSE;
        IFCOMFAILED_EXIT(this->FirstCreateNodeCall(pSource, pNodeParent, NodeCount, pSXSNodeInfo));
    }

Cont:
    if (m_cUnknownChildDepth == 0)
    {
        for (i=0; i<NUMBER_OF(s_rgWorkers); i++)
        {
            bool fTemp = false;

            if ((s_rgWorkers[i].m_xpsOld == eNotParsing) ||
                (m_xpsParseState == s_rgWorkers[i].m_xpsOld))
                fTemp = true;

            const bool fParseStateMatches = fTemp;

            fTemp = false;

            if (fParseStateMatches)
            {
                if (s_rgWorkers[i].m_dwType == apNodeInfo[0]->dwType)
                    fTemp = true;
            }

            const bool fTypeMatches = fTemp;

            fTemp = false;

            if (fTypeMatches)
            {
                if (s_rgWorkers[i].m_cchName == 0)
                    fTemp = true;
                else
                {
                    if (s_rgWorkers[i].m_cchNamespace == pSXSNodeInfo[0].NamespaceStringBuf.Cch())
                    {
                        if (s_rgWorkers[i].m_cchName == pSXSNodeInfo[0].cchText)
                        {
                            if (::FusionpCompareStrings(
                                    s_rgWorkers[i].m_pszNamespace,
                                    s_rgWorkers[i].m_cchNamespace,
                                    pSXSNodeInfo[0].NamespaceStringBuf,
                                    pSXSNodeInfo[0].NamespaceStringBuf.Cch(),
                                    false) == 0)
                            {
                                if (::FusionpCompareStrings(
                                        s_rgWorkers[i].m_pszName,
                                        s_rgWorkers[i].m_cchName,
                                        pSXSNodeInfo[0].pszText,
                                        pSXSNodeInfo[0].cchText,
                                        false) == 0)
                                {
                                    fTemp = true;
                                }
                            }
                        }
                    }
                }
            }

            if (fTemp)
            {
                m_xpsParseState = s_rgWorkers[i].m_xpsNew;

                IFW32FALSE_EXIT(
                    this->ValidateElementAttributes(
                        pSXSNodeInfo,
                        NodeCount,
                        s_rgWorkers[i].m_prgLegalAttributes,
                        s_rgWorkers[i].m_cLegalAttributes));

                if (s_rgWorkers[i].m_pfn != NULL)
                    IFW32FALSE_EXIT((this->*s_rgWorkers[i].m_pfn)(NodeCount, pSXSNodeInfo));
                break;
            }
        }

        if (i == NUMBER_OF(s_rgWorkers))
        {
            bool fEquals;

            // If we hit an unrecognized element and its namespace is the one we own, error!
            IFW32FALSE_EXIT(
                pSXSNodeInfo[0].NamespaceStringBuf.Win32Equals(
                    SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE,
                    SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE_CCH,
                    fEquals,
                    false));

            if (fEquals)
            {
                this->LogParseError(
                    MSG_SXS_MANIFEST_ELEMENT_USED_IN_INVALID_CONTEXT,
                    CUnicodeString(apNodeInfo[0]->pwcText, apNodeInfo[0]->ulLen),
                    CUnicodeString(m_ParseContext.ElementName, m_ParseContext.ElementNameCch));

                ORIGINATE_WIN32_FAILURE_AND_EXIT(ElementInInvalidContext, ERROR_SXS_MANIFEST_PARSE_ERROR);
            }

            // For an unknown child element, the built-in XML parsing should start to ignore the subtree at this point.
            if (apNodeInfo[0]->dwType == XML_ELEMENT)
                m_cUnknownChildDepth = 1;
        }
    }
    else
    {
        if ((NodeCount != 0) &&
            (apNodeInfo[0]->dwType == XML_ELEMENT))
        {
            CUnicodeString s(apNodeInfo[0]->pwcText, apNodeInfo[0]->ulLen);

            // We're handling an unknown series of elements; increment the depth.
            m_cUnknownChildDepth++;
        }
    }

    // Fire the right callbacks for XML_ELEMENT, XML_PCDATA and XML_CDATA nodes:
    switch (apNodeInfo[0]->dwType)
    {
    case XML_ELEMENT:
#if defined(MSG_SXS_MANIFEST_PARSE_NO_INHERIT_CHILDREN_NOT_ALLOWED)
        if (m_cUnknownChildDepth != 0 && m_xpsParseState == eParsing_doc_assembly_noInherit)
        {
            hr = this->LogParseError(MSG_SXS_MANIFEST_PARSE_NO_INHERIT_CHILDREN_NOT_ALLOWED);
            goto Exit;
        }
#endif

        if (m_buffElementPath.Cch() != 0)
            IFW32FALSE_EXIT(m_buffElementPath.Win32Append(L"!", 1));

        cchTemp = m_buffElementPath.Cch();

        if (pSXSNodeInfo[0].NamespaceStringBuf.Cch() != 0)
        {
            IFW32FALSE_EXIT(m_buffElementPath.Win32Append(pSXSNodeInfo[0].NamespaceStringBuf));
            IFW32FALSE_EXIT(m_buffElementPath.Win32Append(L"^", 1));
        }

        IFW32FALSE_EXIT(m_buffElementPath.Win32Append(pSXSNodeInfo[0].pszText, pSXSNodeInfo[0].cchText));

        m_ParseContext.ElementPathCch = m_buffElementPath.Cch();
        m_ParseContext.ElementPath = m_buffElementPath;
        m_ParseContext.ElementName = static_cast<PCWSTR>(m_buffElementPath) + cchTemp;
        m_ParseContext.ElementNameCch = m_buffElementPath.Cch() - cchTemp;

        IFW32FALSE_EXIT(::SxspHashString(m_buffElementPath, m_buffElementPath.Cch(), &m_ParseContext.ElementHash, true));

        m_ParseContext.XMLElementDepth++;

        for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
        {
            IFW32FALSE_EXIT(
                m_ActCtxGenCtx->m_Contributors[i].Fire_ElementParsed(
                        m_ActCtxGenCtx,
                        m_AssemblyContext,
                        &m_ParseContext,
                        NodeCount,
                        pSXSNodeInfo));
        }

        break;

    case XML_PCDATA:
        for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
        {
            IFW32FALSE_EXIT(
                m_ActCtxGenCtx->m_Contributors[i].Fire_PCDATAParsed(
                        m_ActCtxGenCtx,
                        m_AssemblyContext,
                        &m_ParseContext,
                        apNodeInfo[0]->pwcText,
                        apNodeInfo[0]->ulLen));
        }

        break;

    case XML_CDATA:
        for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
        {
            IFW32FALSE_EXIT(
                m_ActCtxGenCtx->m_Contributors[i].Fire_CDATAParsed(
                        m_ActCtxGenCtx,
                        m_AssemblyContext,
                        &m_ParseContext,
                        apNodeInfo[0]->pwcText,
                        apNodeInfo[0]->ulLen));
        }

        break;


    }

#if FUSION_XML_TREE
    IFCOMFAILED_EXIT(this->CreateXmlNode(m_CurrentParent, NodeCount, apNodeInfo, pXmlNode));

    // If we don't get a node back, just ignore it...
    if (pXmlNode != NULL)
    {
        if (m_CurrentParent == NULL)
        {
            // Only XML Decls, PIs and the root document are at depth 0 or 1...
            ASSERT(m_ParseContext.XMLElementDepth <= 1);
            InsertTailList(&m_XmlDocument.ElementListHead, &pXmlNode->SiblingLink);
        }
        else
        {
            ASSERT(m_ParseContext.XMLElementDepth >= 1);
            InsertTailList(&m_CurrentParent->Element.ChildListHead, &pXmlNode->SiblingLink);
        }

        if ((pXmlNode->Type != SXS_XML_NODE_TYPE_CDATA) &&
            (pXmlNode->Type != SXS_XML_NODE_TYPE_PCDATA))
            m_CurrentParent = pXmlNode;

        pXmlNode = NULL;
    }
#endif

    hr = NOERROR;

Exit:
    if (pSXSNodeInfo != NULL)
        FUSION_DELETE_ARRAY(pSXSNodeInfo);

    if (pXmlNode != NULL)
        FUSION_DELETE_SINGLETON(pXmlNode);

    return hr;
}

#if FUSION_XML_TREE
HRESULT
CNodeFactory::CreateXmlNode(
    PSXS_XML_NODE pParent,
    ULONG cNodes,
    XML_NODE_INFO **prgpNodes,
    PSXS_XML_NODE &rpNewNode
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ULONG i;
    ULONG cAttributes = 0;
    ULONG iAttribute = 0;
    PSXS_XML_NODE pNewNode = NULL;
    PSXS_XML_ATTRIBUTE pAttribute = NULL;
    CStringBuffer buffAttributeValue;

    // Handle XML_ELEMENT vs. XML_CDATA vs. XML_PCDATA...
    switch (prgpNodes[0]->dwType)
    {
    case XML_XMLDECL:
        // <?xml version="1.0" ?> elements come through looking like normal XML_ELEMENT
        // nodes with things broken into the XML_ATTRIBUTE followed by their value...

        // First, let's count up the attributes...

        for (i=0; i<cNodes; i++)
        {
            if (prgpNodes[i]->dwType == XML_ATTRIBUTE)
                cAttributes++;
        }

        // Now let's allocate the SXS_XML_NODE plus the right number of SXS_XML_ATTRIBUTEs
        IFALLOCFAILED_EXIT(hr, pNewNode = reinterpret_cast<PSXS_XML_NODE>(FUSION_RAW_ALLOC(sizeof(SXS_XML_NODE) + (cAttributes * sizeof(SXS_XML_ATTRIBUTE)), SXS_XML_NODE)));
        pAttribute = reinterpret_cast<PSXS_XML_ATTRIBUTE>(pNewNode + 1);

        pNewNode->Flags = 0;
        pNewNode->Type = SXS_XML_NODE_TYPE_XML_DECL;
        pNewNode->Parent = pParent;
        pNewNode->XMLDecl.AttributeCount = cAttributes;
        pNewNode->XMLDecl.Attributes = pAttribute;

        for (i=0; i<cNodes; i++)
        {
            ULONG j;
            const WCHAR *prgwch1;
            const WCHAR *prgwch2;
            ULONG ulPK1, ulPK2;
            ULONG ulPos1, ulPos2;
            ULONG cch;

            switch (prgpNodes[i]->dwType)
            {
            case XML_XMLDECL:
                INTERNAL_ERROR_CHECK(i == 0);
                break;

            case XML_ATTRIBUTE:
                INTERNAL_ERROR_CHECK(iAttribute < cAttributes);

                ulPKl = ::FusionpHashUnicodeStringCaseSensitive(prgpNodes[i]->pwcText, prgpNodes[i]->ulLen);
                IFW32FALSE_EXIT(m_ParseTreeStringPool.Canonicalize(prgpNodes[i]->pwcText, prgpNodes[i]->ulLen, ulPK1, ulPos1, prgwch1));

                i++;
                buffAttributeValue.Clear();
                cch = 0;

                while ((i < cNodes) && (prgpNodes[i]->dwType == XML_PCDATA))
                {
                    IFCOMFAILED_EXIT(buffAttributeValue.Append(prgpNodes[i]->pwcText, prgpNodes[i]->ulLen));
                    cch += prgpNodes[i]->ulLen;
                    i++;
                }

                // Gets incremented on the next iteration of the outer loop, so back up one...
                i--;

                IFW32FALSE_EXIT(::FusionpHashUnicodeString(buffAttributeValue, cch, &ulPK2, false));
                IFW32FALSE_EXIT(m_ParseTreeStringPool.Canonicalize(buffAttributeValue, cch, ulPK2, ulPos2, prgwch2));

                pAttribute[iAttribute].Flags = 0;
                pAttribute[iAttribute].NamespaceString = 0;
                pAttribute[iAttribute].NameString = ulPos1;
                pAttribute[iAttribute].ValueString = ulPos2;
                iAttribute++;
                break;
            }
        }

        ASSERT(iAttribute == cAttributes);

        break;

    case XML_ELEMENT:
        // First, let's count up the attributes...

        for (i=0; i<cNodes; i++)
        {
            if (prgpNodes[i]->dwType == XML_ATTRIBUTE)
                cAttributes++;
        }

        // Now let's allocate the SXS_XML_NODE plus the right number of SXS_XML_ATTRIBUTEs
        IFALLOCFAILED_EXIT(hr, pNewNode = reinterpret_cast<PSXS_XML_NODE>(FUSION_RAW_ALLOC(sizeof(SXS_XML_NODE) + (cAttributes * sizeof(SXS_XML_ATTRIBUTE)), SXS_XML_NODE)));
        pAttribute = reinterpret_cast<PSXS_XML_ATTRIBUTE>(pNewNode + 1);

        pNewNode->Flags = 0;
        pNewNode->Type = SXS_XML_NODE_TYPE_ELEMENT;
        pNewNode->Element.NamespaceString = 0;
        pNewNode->Element.NameString = 0;
        pNewNode->Parent = pParent;
        pNewNode->Element.AttributeCount = cAttributes;
        pNewNode->Element.Attributes = pAttribute;
        InitializeListHead(&pNewNode->Element.ChildListHead);

        for (i=0; i<cNodes; i++)
        {
            ULONG j;
            const WCHAR *prgwch1;
            const WCHAR *prgwch2;
            ULONG ulPK1, ulPK2;
            ULONG ulPos1, ulPos2;
            ULONG cch;

            switch (prgpNodes[i]->dwType)
            {
            case XML_ELEMENT:
                INTERNAL_ERROR_CHECK(i == 0);
                IFW32FALSE_EXIT(::FusionpHashUnicodeString(prgpNodes[0]->pwcText, prgpNodes[0]->ulLen, &ulPK1, false));
                IFW32FALSE_EXIT(m_ParseTreeStringPool.Canonicalize(prgpNodes[0]->pwcText, prgpNodes[0]->ulLen, ulPK1, ulPos1, prgwch1));
                pNewNode->Element.NamespaceString = 0;
                pNewNode->Element.NameString = ulPos1;
                break;

            case XML_ATTRIBUTE:
                INTERNAL_ERROR_CHECK(iAttribute < cAttributes);

                IFW32FALSE_EXIT(::FusionpHashUnicodeString(prgpNodes[i]->pwcText, prgpNodes[i]->ulLen, &ulPK1, false));
                IFW32FALSE_EXIT(m_ParseTreeStringPool.Canonicalize(prgpNodes[i]->pwcText, prgpNodes[i]->ulLen, ulPK1, ulPos1, prgwch1));

                i++;
                buffAttributeValue.Clear();
                cch = 0;

                while ((i < cNodes) && (prgpNodes[i]->dwType == XML_PCDATA))
                {
                    IFCOMFAILED_EXIT(buffAttributeValue.Append(prgpNodes[i]->pwcText, prgpNodes[i]->ulLen));
                    cch += prgpNodes[i]->ulLen;
                    i++;
                }

                // Gets incremented on the next iteration of the outer loop, so back up one...
                i--;

                IFW32FALSE_EXIT(::FusionpHashUnicodeString(buffAttributeValue, cch, &ulPK2, false));
                IFW32FALSE_EXIT(m_ParseTreeStringPool.Canonicalize(buffAttributeValue, cch, ulPK2, ulPos2, prgwch2));

                pAttribute[iAttribute].Flags = 0;
                pAttribute[iAttribute].NamespaceString = 0;
                pAttribute[iAttribute].NameString = ulPos1;
                pAttribute[iAttribute].ValueString = ulPos2;
                iAttribute++;
                break;
            }
        }

        ASSERT(iAttribute == cAttributes);

        break;

    case XML_CDATA:
        {
            ULONG ulPK;
            ULONG ulPos;
            const WCHAR *prgwch;

            IFW32FALSE_EXIT(::FusionpHashUnicodeString(prgpNodes[0]->pwcText, prgpNodes[0]->ulLen, &ulPK, false));
            IFW32FALSE_EXIT(m_ParseTreeStringPool.Canonicalize(prgpNodes[0]->pwcText, prgpNodes[0]->ulLen, ulPK, ulPos, prgwch));

            // Now let's allocate the SXS_XML_NODE
            IFALLOCFAILED_EXIT(hr, pNewNode = reinterpret_cast<PSXS_XML_NODE>(FUSION_RAW_ALLOC(sizeof(SXS_XML_NODE), SXS_XML_NODE)));
            pNewNode->Flags = 0;
            pNewNode->Type = SXS_XML_NODE_TYPE_CDATA;
            pNewNode->Parent = pParent;
            pNewNode->CDataString = ulPos;
            break;
        }

    case XML_PCDATA:
        {
            ULONG ulPK;
            ULONG ulPos;
            const WCHAR *prgwch;

            IFW32FALSE_EXIT(::FusionpHashUnicodeString(prgpNodes[0]->pwcText, prgpNodes[0]->ulLen, &ulPK, false));
            IFW32FALSE_EXIT(m_ParseTreeStringPool.Canonicalize(prgpNodes[0]->pwcText, prgpNodes[0]->ulLen, ulPK, ulPos, prgwch));

            // Now let's allocate the SXS_XML_NODE
            IFALLOCFAILED_EXIT(hr, pNewNode = reinterpret_cast<PSXS_XML_NODE>(FUSION_RAW_ALLOC(sizeof(SXS_XML_NODE), SXS_XML_NODE)));
            pNewNode->Flags = 0;
            pNewNode->Type = SXS_XML_NODE_TYPE_PCDATA;
            pNewNode->Parent = pParent;
            pNewNode->PCDataString = ulPos;
            break;
        }
    }

    rpNewNode = pNewNode;
    pNewNode = NULL;

    hr = NOERROR;
Exit:
    FUSION_RAW_DEALLOC(pNewNode);

    return hr;
}
#endif // FUSION_XML_TREE

BOOL
CNodeFactory::SetParseType(
    ULONG ParseType,
    ULONG PathType,
    const CBaseStringBuffer &Path,
    const FILETIME &rftLastWriteTime
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(
        (ParseType == XML_FILE_TYPE_MANIFEST) ||
        (ParseType == XML_FILE_TYPE_APPLICATION_CONFIGURATION) ||
        (ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION));

    PARAMETER_CHECK(PathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);

    IFW32FALSE_EXIT(m_buffCurrentFileName.Win32Assign(Path));

    m_ParseContext.SourceFilePathType = PathType;
    m_ParseContext.SourceFile = m_buffCurrentFileName;
    m_ParseContext.SourceFileCch = m_buffCurrentFileName.Cch();
    m_ParseContext.SourceFileLastWriteTime = rftLastWriteTime;

    m_ParseType = ParseType;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    ASSERT(cNumRecs != 0);
    ASSERT(prgNodeInfo != NULL);

    if (m_fAssemblyFound)
    {
        CUnicodeString s;
        PCWSTR ManifestPath;
        IFW32FALSE_EXIT(m_Assembly->GetManifestPath(&ManifestPath, NULL));
        s = ManifestPath;
        this->LogParseError(MSG_SXS_MANIFEST_MULTIPLE_TOP_ASSEMBLY, &s);
        goto Exit;
    }

    m_fAssemblyFound = true;

    m_fMetadataSatelliteAlreadyFound = false;

    // Now let's tell all the contributors that we're about to begin a parsing session.
    for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(m_ActCtxGenCtx->m_Contributors[i].Fire_ParseBeginning(
                    m_ActCtxGenCtx,
                    m_AssemblyContext,
                    0, // FileFlags
                    m_ParseType,
                    m_ParseContext.SourceFilePathType,
                    m_ParseContext.SourceFile,
                    m_ParseContext.SourceFileCch,
                    m_ParseContext.SourceFileLastWriteTime,
                    m_Assembly->m_ManifestVersionMajor,
                    m_Assembly->m_ManifestVersionMinor,
                    m_Assembly->m_MetadataSatelliteRosterIndex));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_assemblyIdentity(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    const BOOL fGeneratingActCtx = (m_ActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
    ULONG i;
    DWORD dwValidateFlags = 0;

    if (m_fIdentityFound)
    {
        this->LogParseError(MSG_SXS_MULTIPLE_IDENTITY, CEventLogString(prgNodeInfo[0].pszText, prgNodeInfo[0].cchText));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Manifest %ls has multiple identities\n", static_cast<PCWSTR>(m_buffCurrentFileName));
        ORIGINATE_WIN32_FAILURE_AND_EXIT(
            MultipleIdentities,
            ERROR_SXS_MANIFEST_PARSE_ERROR);
    }

    m_fIdentityFound = true;

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromIdentityElement(
            0,                                  // DWORD Flags,
            &m_ParseContext,
            ASSEMBLY_IDENTITY_TYPE_DEFINITION,  // ULONG Type,
            &AssemblyIdentity,                  // PASSEMBLY_IDENTITY *AssemblyIdentityOut,
            cNumRecs,
            prgNodeInfo));

    // If the identity that was created is a policy statement, then we
    // set the internal parse type to our special 'intuited' parse type
    // for later checks of missing attributes and whatnot.  This does
    // duplicate work in ValidateAssembly that does the same thing, but
    // we need to preemptively set this parse type before we go validating.
    
    // if (m_IntuitedParseType == eActualParseType_Undetermined)
    {
        BOOL fIsPolicy = FALSE;
        IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));

        if (fIsPolicy)
            m_IntuitedParseType = eActualParseType_PolicyManifest;
        else
            m_IntuitedParseType = eActualParseType_Manifest;
    }

    if ((m_IntuitedParseType == eActualParseType_Manifest) ||
        (m_IntuitedParseType == eActualParseType_PolicyManifest) ||
        (m_ParseType == XML_FILE_TYPE_MANIFEST) ||
        (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION))
    {
        dwValidateFlags = eValidateIdentity_VersionRequired;
    }

    IFW32FALSE_EXIT(
        this->ValidateIdentity(
            dwValidateFlags,
            ASSEMBLY_IDENTITY_TYPE_DEFINITION,
            AssemblyIdentity));

    if (fGeneratingActCtx)
    {
        if (m_Assembly->IsRoot())
        {
            // If we're generating the actctx and this is the root assembly, it's possible
            // that we got to it by a filesystem path (e.g. private assembly) rather than 
            // an actual reference, so we need to fix up the assembly's identity information
            // appropriately.
            IFW32FALSE_EXIT(m_Assembly->m_Information.SetProbedIdentity(AssemblyIdentity));
        }
        else
        {
            // If we're generating the actctx and this isn't the root assembly, we need to verify
            // that it's the right one.
            BOOL fEqual;
            IFW32FALSE_EXIT(
                ::SxsAreAssemblyIdentitiesEqual(
                    SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF,
                    m_Assembly->GetAssemblyIdentity(),
                    AssemblyIdentity,
                    &fEqual));

            if (!fEqual)
            {
                this->LogParseError(MSG_SXS_COMPONENT_MANIFEST_PROBED_IDENTITY_MISMATCH);
                // LogParseError sets the last error appropriate to the message logged
                goto Exit;
            }
        }
    }

    if (m_IntuitedParseType == eActualParseType_PolicyManifest)
    {
        IFALLOCFAILED_EXIT(m_CurrentPolicyStatement = new CPolicyStatement);
        IFW32FALSE_EXIT(m_CurrentPolicyStatement->Initialize());
    }

    // Tell everyone that we're sure who we are...
    for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(
            m_ActCtxGenCtx->m_Contributors[i].Fire_IdentityDetermined(
                    m_ActCtxGenCtx,
                    m_AssemblyContext,
                    &m_ParseContext,
                    AssemblyIdentity));
    }

    // fix up assembly and assembly context so we know where to copy to
    // also save the manifest
    IFW32FALSE_EXIT(m_Assembly->m_Information.SetAssemblyIdentity(AssemblyIdentity));
    if (m_AssemblyContext->AssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(m_AssemblyContext->AssemblyIdentity));

    m_AssemblyContext->AssemblyIdentity = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    if (AssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(AssemblyIdentity);

    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_noInherit(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(
        (m_ParseType == XML_FILE_TYPE_MANIFEST) ||
        (m_ParseType == XML_FILE_TYPE_APPLICATION_CONFIGURATION) ||
        (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION));

    switch (m_ParseType)
    {
    case XML_FILE_TYPE_MANIFEST:
        if (cNumRecs != 1)
        {
            this->LogParseError(MSG_SXS_MANIFEST_PARSE_NO_INHERIT_ATTRIBUTES_NOT_ALLOWED);
            goto Exit;
        }
        if (m_ActCtxGenCtx->m_NoInherit)
        {
            this->LogParseError(MSG_SXS_MANIFEST_PARSE_MULTIPLE_NO_INHERIT);
            goto Exit;
        }
        if (m_fIdentityFound)
        {
            this->LogParseError(
                MSG_SXS_MANIFEST_ELEMENT_MUST_OCCUR_BEFORE,
                CEventLogString(L"noInherit"),
                CEventLogString(L"assemblyIdentity"));
            goto Exit;
        }

        m_ActCtxGenCtx->m_NoInherit = true;
        break;

    case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
        this->LogParseError(MSG_SXS_POLICY_PARSE_NO_INHERIT_NOT_ALLOWED);
        goto Exit;

    default:
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_noInheritable(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(
        (m_ParseType == XML_FILE_TYPE_MANIFEST) ||
        (m_ParseType == XML_FILE_TYPE_APPLICATION_CONFIGURATION) ||
        (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION));

    switch (m_ParseType)
    {
    case XML_FILE_TYPE_MANIFEST:
        if (cNumRecs != 1)
        {
            this->LogParseError(MSG_SXS_MANIFEST_PARSE_NO_INHERIT_ATTRIBUTES_NOT_ALLOWED);
            goto Exit;
        }

        if (m_fNoInheritableFound)
        {
            this->LogParseError(MSG_SXS_MANIFEST_PARSE_MULTIPLE_NOINHERITABLE);
            goto Exit;
        }
        if (m_fIdentityFound)
        {
            this->LogParseError(
                MSG_SXS_MANIFEST_ELEMENT_MUST_OCCUR_BEFORE,
                CEventLogString(L"noInheritable"),
                CEventLogString(L"assemblyIdentity"));
            goto Exit;
        }


        m_fNoInheritableFound = true;

        break;

    case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
    case XML_FILE_TYPE_COMPONENT_CONFIGURATION:
        this->LogParseError(MSG_SXS_POLICY_PARSE_NO_INHERIT_NOT_ALLOWED);
        goto Exit;

    default:
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_dependency(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    bool fFound;
    SIZE_T cb;

    m_fIsDependencyOptional = false;
    m_fDependencyChildHit = false;
    m_fIsMetadataSatellite = false;

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_optional,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(m_fIsDependencyOptional),
            &m_fIsDependencyOptional,
            cb,
            &::SxspValidateBoolAttribute,
            0));

    if (!fFound)
        m_fIsDependencyOptional = false;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_dependency_dependentAssembly(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    bool fFound;
    SIZE_T cb;

    if (m_fDependencyChildHit == false)
    {
        m_fDependencyChildHit = true;
    }
    else
    {
        this->LogParseError(MSG_SXS_MANIFEST_MULTIPLE_DEPENDENTASSEMBLY_IN_DEPENDENCY);
        goto Exit;
    }

    m_fAssemblyIdentityChildOfDependenctAssemblyHit = false;

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_metadataSatellite,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(m_fIsMetadataSatellite),
            &m_fIsMetadataSatellite,
            cb,
            &::SxspValidateBoolAttribute,
            0));

    if (!fFound)
        m_fIsMetadataSatellite = false;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_dependency_dependentAssembly_bindingRedirect(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    bool fFound;
    bool fValid;
    SIZE_T cb;
    CSmallStringBuffer buffOldVersion;
    CSmallStringBuffer buffNewVersion;

    INTERNAL_ERROR_CHECK(m_CurrentPolicyStatement != NULL);

    if (m_IntuitedParseType != eActualParseType_PolicyManifest)
    {
        this->LogParseError(MSG_SXS_BINDING_REDIRECTS_ONLY_IN_COMPONENT_CONFIGURATION);
        goto Exit;
    }

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
            &s_AttributeName_oldVersion,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(buffOldVersion),
            &buffOldVersion,
            cb,
            NULL,
            0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
            &s_AttributeName_newVersion,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(buffNewVersion),
            &buffNewVersion,
            cb,
            NULL,
            0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(m_CurrentPolicyStatement->AddRedirect(buffOldVersion, buffNewVersion, fValid));

    if (!fValid)
    {
        this->LogParseError(MSG_SXS_BINDING_REDIRECT_MISSING_REQUIRED_ATTRIBUTES);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_dependency_dependentAssembly_assemblyIdentity(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    ULONG ParseType;

    ASSERT(cNumRecs != 0);
    ASSERT(prgNodeInfo != NULL);

    // We're either parsing a manifest or a policy file; what else??
    INTERNAL_ERROR_CHECK(
            (m_ParseType == XML_FILE_TYPE_MANIFEST) ||
            (m_ParseType == XML_FILE_TYPE_APPLICATION_CONFIGURATION) ||
            (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION));
    
    if (m_fAssemblyIdentityChildOfDependenctAssemblyHit == false)
        m_fAssemblyIdentityChildOfDependenctAssemblyHit = true;
    else
    {
        this->LogParseError(MSG_SXS_MANIFEST_MULTIPLE_ASSEMBLYIDENTITY_IN_DEPENDENCYASSEMBLY);
        goto Exit;
    }

    switch (m_IntuitedParseType)
    {
    case eActualParseType_Undetermined:
        ParseType = m_ParseType;
        break;
    case eActualParseType_PolicyManifest:
        ParseType = XML_FILE_TYPE_COMPONENT_CONFIGURATION;
        break;
    case eActualParseType_Manifest:
        ParseType = XML_FILE_TYPE_MANIFEST;
        break;
    default:
        INTERNAL_ERROR_CHECK(FALSE);
        ParseType = m_ParseType;
        break;
    }
    switch (ParseType)
    {
    case XML_FILE_TYPE_MANIFEST:
        IFW32FALSE_EXIT(
            ::SxspCreateAssemblyIdentityFromIdentityElement(
                0,
                &m_ParseContext,
                ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                &pAssemblyIdentity,
                cNumRecs,
                prgNodeInfo));

        IFW32FALSE_EXIT(
            this->ValidateIdentity(
                eValidateIdentity_VersionRequired | eValidateIdentity_PoliciesNotAllowed,
                ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                pAssemblyIdentity));

        // If we're not installing, process the identity...
        if (m_ActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            IFW32FALSE_EXIT(::SxspEnqueueAssemblyReference(m_ActCtxGenCtx, m_Assembly, pAssemblyIdentity, m_fIsDependencyOptional, m_fIsMetadataSatellite));

        break;

    case XML_FILE_TYPE_COMPONENT_CONFIGURATION:
        {
        BOOL fValidDependencyAssemblyIdentity = FALSE;
        PCWSTR pszName1 = NULL, pszName2 = NULL;
        SIZE_T cchName1 = 0, cchName2 = 0;

        if (m_CurrentPolicyDependentAssemblyIdentity != NULL)
        {
            this->LogParseError(MSG_SXS_COMPONENT_CONFIGURATION_MANIFESTS_MAY_ONLY_HAVE_ONE_DEPENDENCY);
            goto Exit;
        }

        IFW32FALSE_EXIT(
            ::SxspCreateAssemblyIdentityFromIdentityElement(
                0,
                &m_ParseContext,
                ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                &pAssemblyIdentity,
                cNumRecs,
                prgNodeInfo));
        // check the name in dependency-assemblyidentity match with the name in assembly-assemblyidentity        
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                m_Assembly->GetAssemblyIdentity(),
                &s_IdentityAttribute_name,
                &pszName1,          // something in a format of "Policy.1212.1221.assemblyname"
                &cchName1));

        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                pAssemblyIdentity,
                &s_IdentityAttribute_name,
                &pszName2,          // would be something as "assemblyname"
                &cchName2));

        if ((cchName1 > cchName2) && (cchName2 !=0))
        {
            if ( (*(pszName1 + (cchName1 - cchName2 -1)) == L'.') && (::FusionpCompareStrings(
                            pszName1 + (cchName1 - cchName2), cchName2,
                            pszName2, cchName2, FALSE // must be case-sensitive for values
                            ) == 0 ))  
            {                
                fValidDependencyAssemblyIdentity = TRUE;
            }
        }
    
        if (fValidDependencyAssemblyIdentity) 
        {
            IFW32FALSE_EXIT(
                this->ValidateIdentity(
                    eValidateIdentity_VersionNotAllowed | eValidateIdentity_PoliciesNotAllowed,
                    ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                    pAssemblyIdentity));

            // We'll keep track of this so that we can recognize multiple dependentAssembly elements on installation
            // of policies.
            m_CurrentPolicyDependentAssemblyIdentity = pAssemblyIdentity;
            pAssemblyIdentity = NULL;
        }
        else // print a message and ignore this entry
        {           
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_POLICY | FUSION_DBG_LEVEL_INFO,
                "SXS.DLL: unexpected assemblyidentity within dependency tag in component policy \"%ls\"\n",                
                m_buffCurrentFileName
                );
        }
        } // end of this case   

        break;

#if 0
    case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
        IFW32FALSE_EXIT(this->ParseElementAttributes(cNumRecs, prgpNodeInfo, NUMBER_OF(rgPolicyAttributes), rgPolicyAttributes));

        if (!(m_fAssemblyNamePresent && m_fOldVersionPresent && m_fNewVersionPresent))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Policy dependency tag found and either assemblyname, oldversion or newversion attributes are missing\n");
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        break;
#endif // 0

    default:
        // Internal error!
        INTERNAL_ERROR_CHECK(FALSE);
    }

    fSuccess = TRUE;
Exit:
    if (pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    ASSERT(cNumRecs != 0);
    ASSERT(prgNodeInfo != NULL);

    if (m_fAssemblyFound)
    {
        CUnicodeString s;
        PCWSTR ManifestPath;
        IFW32FALSE_EXIT(m_Assembly->GetManifestPath(&ManifestPath, NULL));
        s = ManifestPath;
        this->LogParseError(MSG_SXS_MANIFEST_MULTIPLE_TOP_ASSEMBLY, &s);
        goto Exit;
    }

    m_fAssemblyFound = true;

    m_fMetadataSatelliteAlreadyFound = false;

    // Now let's tell all the contributors that we're about to begin a parsing session.
    for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(
            m_ActCtxGenCtx->m_Contributors[i].Fire_ParseBeginning(
                m_ActCtxGenCtx,
                m_AssemblyContext,
                0, // FileFlags
                m_ParseType,
                m_ParseContext.SourceFilePathType,
                m_ParseContext.SourceFile,
                m_ParseContext.SourceFileCch,
                m_ParseContext.SourceFileLastWriteTime,
                m_Assembly->m_ManifestVersionMajor,
                m_Assembly->m_ManifestVersionMinor,
                m_Assembly->m_MetadataSatelliteRosterIndex));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    fSuccess = TRUE;
    // Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    fSuccess = TRUE;
    // Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_assemblyIdentity(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromIdentityElement(
            0,
            &m_ParseContext,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            &pAssemblyIdentity,
            cNumRecs,
            prgNodeInfo));

    IFW32FALSE_EXIT(
        this->ValidateIdentity(
            eValidateIdentity_VersionRequired | eValidateIdentity_PoliciesNotAllowed,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            pAssemblyIdentity));

    fSuccess = TRUE;
Exit:
    if (pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    fSuccess = TRUE;
    // Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    CPolicyStatement *pPolicyStatement = NULL;

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromIdentityElement(
            0,
            &m_ParseContext,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            &pAssemblyIdentity,
            cNumRecs,
            prgNodeInfo));

    IFW32FALSE_EXIT(
        this->ValidateIdentity(
            eValidateIdentity_VersionNotAllowed | eValidateIdentity_PoliciesNotAllowed,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            pAssemblyIdentity));

    IFW32FALSE_EXIT(
        ::SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
            SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION,
            pAssemblyIdentity,
            m_buffCurrentApplicationPolicyIdentityKey,
            NULL));

    IFW32FALSE_EXIT(m_ActCtxGenCtx->m_ApplicationPolicyTable.Find(m_buffCurrentApplicationPolicyIdentityKey, pPolicyStatement));
    if (pPolicyStatement != NULL)
    {
        pPolicyStatement = NULL;
        this->LogParseError(MSG_SXS_APPLICATION_CONFIGURATION_MANIFEST_MAY_ONLY_HAVE_ONE_DEPENDENTASSEMBLY_PER_IDENTITY);
        goto Exit;
    }

    IFALLOCFAILED_EXIT(pPolicyStatement = new CPolicyStatement);
    IFW32FALSE_EXIT(pPolicyStatement->Initialize());
    IFW32FALSE_EXIT(m_ActCtxGenCtx->m_ApplicationPolicyTable.Insert(m_buffCurrentApplicationPolicyIdentityKey, pPolicyStatement));
    m_CurrentPolicyStatement = pPolicyStatement;
    pPolicyStatement = NULL;

    if (m_CurrentPolicyDependentAssemblyIdentity != NULL)
    {
        ::SxsDestroyAssemblyIdentity(m_CurrentPolicyDependentAssemblyIdentity);
        m_CurrentPolicyDependentAssemblyIdentity = NULL;
    }

    m_CurrentPolicyDependentAssemblyIdentity = pAssemblyIdentity;
    pAssemblyIdentity = NULL;

    fSuccess = TRUE;
Exit:
    if (pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    if (pPolicyStatement != NULL)
        FUSION_DELETE_SINGLETON(pPolicyStatement);

    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmallStringBuffer buffOldVersion;
    CSmallStringBuffer buffNewVersion;
    bool fFound;
    bool fValid;
    SIZE_T cb;

    if (m_CurrentPolicyStatement == NULL)
    {
        this->LogParseError(MSG_SXS_APPLICATION_CONFIGURATION_MANIFEST_DEPENDENTASSEMBLY_MISSING_IDENTITY);
        goto Exit;
    }

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
            &s_AttributeName_oldVersion,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(buffOldVersion),
            &buffOldVersion,
            cb,
            NULL,
            0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
            &s_AttributeName_newVersion,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(buffNewVersion),
            &buffNewVersion,
            cb,
            NULL,
            0));
    INTERNAL_ERROR_CHECK(fFound);

    // If either are not found, log an error
    if (!fFound)
    {
        this->LogParseError(MSG_SXS_BINDING_REDIRECT_MISSING_REQUIRED_ATTRIBUTES);
        goto Exit;
    }

    IFW32FALSE_EXIT(m_CurrentPolicyStatement->AddRedirect(buffOldVersion, buffNewVersion, fValid));
    if (! fValid)
    {       
        // log an error
        ::FusionpLogError(
            MSG_SXS_POLICY_VERSION_OVERLAP,
            CEventLogString(m_AssemblyContext->PolicyPath),
            CEventLogString(buffOldVersion),
            CEventLogString(buffNewVersion));

        ORIGINATE_WIN32_FAILURE_AND_EXIT(PolicyVersionOverlap, ERROR_SXS_MANIFEST_PARSE_ERROR);
    }


    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Parse_PartialAssemblyVersion(
    PVOID pvDatum,
    BOOL fAlreadyFound,
    CBaseStringBuffer &rbuff
    )
{
    return reinterpret_cast<CPartialAssemblyVersion *>(pvDatum)->Parse(rbuff, rbuff.Cch());
}

BOOL
CNodeFactory::XMLParser_Parse_String(
    LPVOID pvDatum,
    BOOL fAlreadyFound,
    CBaseStringBuffer &rbuff)
{
    return ((CBaseStringBuffer *) pvDatum)->Win32Assign(rbuff);
}

BOOL
CNodeFactory::ParseElementAttributes(
    USHORT cNumRecs,
    XML_NODE_INFO **prgpNodeInfo,
    SIZE_T cEntries,
    const AttributeMapEntry *prgEntries
    )
{
    BOOL fSuccess = FALSE;

    ULONG i, j;

    for (i=1; i<cNumRecs; i++)
    {
        // Skip things we don't understand.
        if (prgpNodeInfo[i]->dwType != XML_ATTRIBUTE)
            continue;

        for (j=0; j<cEntries; j++)
        {
            if (::FusionpCompareStrings(
                    prgEntries[j].m_pszAttributeName,
                    prgEntries[j].m_cchAttributeName,
                    prgpNodeInfo[i]->pwcText,
                    prgpNodeInfo[i]->ulLen,
                    false) == 0)
            {
                // Because attribute values may be multipart due to entity references,
                // we accumulate the attibute value into buffTemp to start, and then do
                // the parsing/whatever afterwards.
                CStringBuffer buffTemp;
                BOOL *pfIndicator = (BOOL *) (((ULONG_PTR) this) + prgEntries[j].m_offsetIndicator);

                while ((++i < cNumRecs) &&
                       (prgpNodeInfo[i]->dwType == XML_PCDATA))
                {
                    if (!buffTemp.Win32Append(prgpNodeInfo[i]->pwcText, prgpNodeInfo[i]->ulLen))
                        goto Exit;
                }

                // The outer for(;;) loop is going to increment i, so we need to back it up one
                // place...
                i--;

                // Call the appropriate value type handler function...
                if (prgEntries[j].m_pfn != NULL)
                {
                    if (!((this->*(prgEntries[j].m_pfn))(((LPBYTE) this) + prgEntries[j].m_offsetData, *pfIndicator, buffTemp)))
                        goto Exit;
                }

                *pfIndicator = TRUE;

                break;
            }
        }
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

HRESULT
CNodeFactory::LogParseError(
    DWORD dwLastParseError,
    const UNICODE_STRING *p1,
    const UNICODE_STRING *p2,
    const UNICODE_STRING *p3,
    const UNICODE_STRING *p4,
    const UNICODE_STRING *p5,
    const UNICODE_STRING *p6,
    const UNICODE_STRING *p7,
    const UNICODE_STRING *p8,
    const UNICODE_STRING *p9,
    const UNICODE_STRING *p10,
    const UNICODE_STRING *p11,
    const UNICODE_STRING *p12,
    const UNICODE_STRING *p13,
    const UNICODE_STRING *p14,
    const UNICODE_STRING *p15,
    const UNICODE_STRING *p16,
    const UNICODE_STRING *p17,
    const UNICODE_STRING *p18,
    const UNICODE_STRING *p19,
    const UNICODE_STRING *p20
    )
{
    return
        ::FusionpLogParseError(
            m_ParseContext.SourceFile,
            m_ParseContext.SourceFileCch,
            m_ParseContext.LineNumber,
            dwLastParseError,
            p1, p2, p3, p4, p5,
            p6, p7, p8, p9, p10,
            p11, p12, p13, p14, p15,
            p16, p17, p18, p19, p20);
}

VOID
CNodeFactory::ParseErrorCallback_MissingRequiredAttribute(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    )
{
    // CNodeFactory *pThis = (CNodeFactory *) ErrorContext;

    ::FusionpLogRequiredAttributeMissingParseError(
        ParseContext->SourceFile,
        ParseContext->SourceFileCch,
        ParseContext->LineNumber,
        ParseContext->ElementName,
        ParseContext->ElementNameCch,
        AttributeName->Name,
        AttributeName->NameCch);
}

VOID
CNodeFactory::ParseErrorCallback_InvalidAttributeValue(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    )
{
    // CNodeFactory *pThis = (CNodeFactory *) ErrorContext;

    ::FusionpLogInvalidAttributeValueParseError(
        ParseContext->SourceFile,
        ParseContext->SourceFileCch,
        ParseContext->LineNumber,
        ParseContext->ElementName,
        ParseContext->ElementNameCch,
        AttributeName->Name,
        AttributeName->NameCch);
}

VOID
CNodeFactory::ParseErrorCallback_AttributeNotAllowed(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    )
{
    // CNodeFactory *pThis = (CNodeFactory *) ErrorContext;

    ::FusionpLogAttributeNotAllowedParseError(
        ParseContext->SourceFile,
        ParseContext->SourceFileCch,
        ParseContext->LineNumber,
        ParseContext->ElementName,
        ParseContext->ElementNameCch,
        AttributeName->Name,
        AttributeName->NameCch);
}

static
VOID
SxspDbgPrintXmlNodeInfo(
    ULONG Level,
    XML_NODE_INFO *pNode
    )
{
    CUnicodeString s(pNode->pwcText, pNode->ulLen);

#if DBG_SXS
    ::FusionpDbgPrintEx(Level, "SXS.DLL: XML_NODE_INFO at %p\n", pNode);
    ::FusionpDbgPrintEx(Level, "    dwSize = %d\n", pNode->dwSize);
    ::FusionpDbgPrintEx(Level, "    dwType = %d (%s)\n", pNode->dwType, SxspFormatXmlNodeType(pNode->dwType));
    ::FusionpDbgPrintEx(Level, "    dwSubType = %d\n", pNode->dwSubType);
    ::FusionpDbgPrintEx(Level, "    fTerminal = %d\n", pNode->fTerminal);

    ::FusionpDbgPrintEx(Level, "    pwcText = %p (\"%wZ\")\n", pNode->pwcText, &s);
    ::FusionpDbgPrintEx(Level, "    ulLen = %d\n", pNode->ulLen);
    ::FusionpDbgPrintEx(Level, "    ulNsPrefixLen = %d\n", pNode->ulNsPrefixLen);
    ::FusionpDbgPrintEx(Level, "    pNode = %p\n", pNode->pNode);
    ::FusionpDbgPrintEx(Level, "    pReserved = %p\n", pNode->pReserved);
#else
    ::FusionpDbgPrintEx(Level, "SXS.DLL: XML_NODE_INFO at %p: \"%wZ\"\n", pNode, &s);
#endif
}


static
PCSTR
SxspFormatXmlNodeType(
    DWORD dwType
    )
{
    PCSTR Result = "Unknown";

#define HANDLE_NODE_TYPE(x) case static_cast<DWORD>(x): Result = #x; break;

    switch (dwType)
    {
        HANDLE_NODE_TYPE(XML_ELEMENT)
        HANDLE_NODE_TYPE(XML_ATTRIBUTE)
        HANDLE_NODE_TYPE(XML_PI)
        HANDLE_NODE_TYPE(XML_XMLDECL)
        HANDLE_NODE_TYPE(XML_DOCTYPE)
        HANDLE_NODE_TYPE(XML_DTDATTRIBUTE)
        HANDLE_NODE_TYPE(XML_ENTITYDECL)
        HANDLE_NODE_TYPE(XML_ELEMENTDECL)
        HANDLE_NODE_TYPE(XML_ATTLISTDECL)
        HANDLE_NODE_TYPE(XML_NOTATION)
        HANDLE_NODE_TYPE(XML_GROUP)
        HANDLE_NODE_TYPE(XML_INCLUDESECT)
        HANDLE_NODE_TYPE(XML_PCDATA)
        HANDLE_NODE_TYPE(XML_CDATA)
        HANDLE_NODE_TYPE(XML_IGNORESECT)
        HANDLE_NODE_TYPE(XML_COMMENT)
        HANDLE_NODE_TYPE(XML_ENTITYREF)
        HANDLE_NODE_TYPE(XML_WHITESPACE)
        HANDLE_NODE_TYPE(XML_NAME)
        HANDLE_NODE_TYPE(XML_NMTOKEN)
        HANDLE_NODE_TYPE(XML_STRING)
        HANDLE_NODE_TYPE(XML_PEREF)
        HANDLE_NODE_TYPE(XML_MODEL)
        HANDLE_NODE_TYPE(XML_ATTDEF)
        HANDLE_NODE_TYPE(XML_ATTTYPE)
        HANDLE_NODE_TYPE(XML_ATTPRESENCE)
        HANDLE_NODE_TYPE(XML_DTDSUBSET)
    }

    return Result;
}

BOOL
CNodeFactory::ValidateIdentity(
    DWORD Flags,
    ULONG Type,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR pszTemp = NULL;
    SIZE_T cchTemp = 0;
    bool fSyntaxValid = false;
    bool fError = false;
    BOOL fIsPolicy;

    PARAMETER_CHECK((Flags & ~(
                            eValidateIdentity_VersionRequired |
                            eValidateIdentity_PoliciesNotAllowed |
                            eValidateIdentity_VersionNotAllowed)) == 0);
    PARAMETER_CHECK((Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) || (Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE));
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    //
    // only one of these flags is allowed
    //
    IFINVALID_FLAGS_EXIT_WIN32(Flags,
        eValidateIdentity_PoliciesNotAllowed | 
        eValidateIdentity_VersionNotAllowed | 
        eValidateIdentity_VersionRequired);

    //
    // Get the type of this assembly
    //
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));

    //
    // If it's policy, then make sure that policies are allowed.  Otherwise, fail out.
    //
    if (fIsPolicy)
    {
        if (Flags & eValidateIdentity_PoliciesNotAllowed)
        {
            FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Manifest \"%ls\" (line %d) contains a type=\"win32-policy\" where it shouldn't\n",
                m_ParseContext.SourceFile,
                m_ParseContext.LineNumber);

            fError = true;
        }
        else
        {
            m_AssemblyContext->Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_IS_SYSTEM_POLICY_INSTALLATION;           
        }
    }

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_name,
            &pszTemp,
            &cchTemp));

    if (cchTemp == 0)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Manifest \"%ls\" (line %d) is missing name attribute; report to owner of \"%ls\"\n",
            m_ParseContext.SourceFile,
            m_ParseContext.LineNumber,
            m_ParseContext.SourceFile);

        fError = true;
    }

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            &pszTemp,
            &cchTemp));

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_version,
            &pszTemp,
            &cchTemp));

    if (cchTemp != 0)
    {
        ASSEMBLY_VERSION av;

        IFW32FALSE_EXIT(CFusionParser::ParseVersion(av, pszTemp, cchTemp, fSyntaxValid));

        if (!fSyntaxValid)
        {
            ::FusionpLogInvalidAttributeValueParseError(
                m_ParseContext.SourceFile,
                m_ParseContext.SourceFileCch,
                m_ParseContext.LineNumber,
                m_ParseContext.ElementName,
                m_ParseContext.ElementNameCch,
                s_IdentityAttribute_version);

            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidVersionNumber, ERROR_SXS_MANIFEST_PARSE_ERROR);
        }
    }

    if ((Flags & (eValidateIdentity_VersionNotAllowed | eValidateIdentity_VersionRequired)) != 0)
    {
        if ((Flags & eValidateIdentity_VersionNotAllowed) != 0 && cchTemp != 0)
        {
            fError = true;
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Manifest \"%ls\" (line %d) has a version attribute where it may not appear; report to owner of \"%ls\"\n",
                m_ParseContext.SourceFile,
                m_ParseContext.LineNumber,
                m_ParseContext.SourceFile);
        }
        else if ((Flags & eValidateIdentity_VersionRequired) != 0 && cchTemp == 0)
        {
            fError = true;
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Manifest \"%ls\" (line %d) is missing version attribute; report to owner of \"%ls\"\n",
                m_ParseContext.SourceFile,
                m_ParseContext.LineNumber,
                m_ParseContext.SourceFile);
        }
    }

    if (fError)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Manifest \"%ls\" is missing required attribute or contains disallowed attribute; report to owner of \"%ls\"\n",
            m_ParseContext.SourceFile,
            m_ParseContext.SourceFile);

        ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidIdentity, ERROR_SXS_MANIFEST_PARSE_ERROR);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::ValidateElementAttributes(
    PCSXS_NODE_INFO prgNodes,
    SIZE_T cNodes,
    PCELEMENT_LEGAL_ATTRIBUTE prgAttributes,
    UCHAR cAttributes
    )
{
    FN_PROLOG_WIN32

    SIZE_T i;
    UCHAR j;
    UCHAR cRequiredAttributes, cRequiredAttributesFound;
    UCHAR rgRequiredAttributeFoundBitMask[8]; // 8 * 32 = 256
    BOOL fParseFailed = FALSE;

    PARAMETER_CHECK((cNodes == 0) || (prgNodes != NULL));
    PARAMETER_CHECK((cAttributes == 0) || (prgAttributes != NULL));

    cRequiredAttributes = 0;
    cRequiredAttributesFound = 0;

    for (i=0; i<cAttributes; i++)
        if (prgAttributes[i].m_dwFlags & ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED)
            cRequiredAttributes++;

    rgRequiredAttributeFoundBitMask[0] = 0;
    rgRequiredAttributeFoundBitMask[1] = 0;
    rgRequiredAttributeFoundBitMask[2] = 0;
    rgRequiredAttributeFoundBitMask[3] = 0;
    rgRequiredAttributeFoundBitMask[4] = 0;
    rgRequiredAttributeFoundBitMask[5] = 0;
    rgRequiredAttributeFoundBitMask[6] = 0;
    rgRequiredAttributeFoundBitMask[7] = 0;

    for (i=0; i<cNodes; i++)
    {
        if (prgNodes[i].Type == SXS_ATTRIBUTE)
        {
            const SIZE_T cchText = prgNodes[i].cchText;
            const SIZE_T cchNamespace = prgNodes[i].NamespaceStringBuf.Cch();
            const PCWSTR pszText = prgNodes[i].pszText;

            // Ignore any attributes that start with xml
            if ((cchText >= 3) &&
                ((pszText[0] == L'x') || (pszText[0] == L'X')) &&
                ((pszText[1] == L'm') || (pszText[1] == L'M')) &&
                ((pszText[2] == L'l') || (pszText[2] == L'L')))
            {
                continue;
            }
            if (cchNamespace != 0 )
            {
                continue;
            }

            for (j=0; j<cAttributes; j++)
            {
                if ((prgAttributes[j].m_pName != NULL) &&
                    (cchText == prgAttributes[j].m_pName->NameCch) &&
                    (cchNamespace == prgAttributes[j].m_pName->NamespaceCch) &&
                    (::FusionpCompareStrings(prgNodes[i].NamespaceStringBuf, cchNamespace, prgAttributes[j].m_pName->Namespace, cchNamespace, false) == 0) &&
                    (::FusionpCompareStrings(pszText, cchText, prgAttributes[j].m_pName->Name, cchText, false) == 0))
                {
                    if (prgAttributes[j].m_pfnValidator != NULL)
                    {
                        CSmallStringBuffer buffValue;
                        bool fValid = false;
                        SIZE_T cb;
                        SIZE_T i2;

                        for (i2=i+1; i2<cNodes; i2++)
                        {
                            if (prgNodes[i2].Type == SXS_PCDATA)
                                IFW32FALSE_EXIT(buffValue.Win32Append(prgNodes[i2].pszText, prgNodes[i2].cchText));
                            else
                                break;
                        }

                        IFW32FALSE_EXIT(
                            (*prgAttributes[j].m_pfnValidator)(
                                prgAttributes[j].m_dwValidatorFlags,
                                buffValue,
                                fValid,
                                0,
                                NULL,
                                cb));

                        if (!fValid)
                        {
                            ::FusionpLogInvalidAttributeValueParseError(
                                m_ParseContext.SourceFile,
                                m_ParseContext.SourceFileCch,
                                m_ParseContext.LineNumber,
                                m_ParseContext.ElementName,
                                m_ParseContext.ElementNameCch,
                                prgAttributes[j].m_pName->Name,
                                prgAttributes[j].m_pName->NameCch);
                            
                            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidAttributeValue, ERROR_SXS_MANIFEST_PARSE_ERROR);
                        }
                    }

                    if (prgAttributes[j].m_dwFlags & ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED)
                    {
                        rgRequiredAttributeFoundBitMask[(j / 32)] |= (1 << (j % 32));
                        cRequiredAttributesFound++;
                    }

                    break;
                }
            }

            if (j == cAttributes)
            {
                // We found an illegal attribute!!
                ::FusionpLogAttributeNotAllowedParseError(
                    m_ParseContext.SourceFile,
                    m_ParseContext.SourceFileCch,
                    m_ParseContext.LineNumber,
                    prgNodes[0].pszText,
                    prgNodes[0].cchText,
                    prgNodes[i].pszText,
                    prgNodes[i].cchText);

                // We don't just go to exit here because we want to report all the bad attributes and missing attributes...
                fParseFailed = TRUE;
            }
        }
    }

    if (cRequiredAttributesFound != cRequiredAttributes)
    {
        for (j=0; j<cAttributes; j++)
        {
            if (prgAttributes[j].m_dwFlags & ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED)
            {
                if ((rgRequiredAttributeFoundBitMask[(j / 32)] & (1 << (j % 32))) == 0)
                {
                    ::FusionpLogRequiredAttributeMissingParseError(
                        m_ParseContext.SourceFile,
                        m_ParseContext.SourceFileCch,
                        m_ParseContext.LineNumber,
                        prgNodes[0].pszText,
                        prgNodes[0].cchText,
                        prgAttributes[j].m_pName->Name,
                        prgAttributes[j].m_pName->NameCch);

                    fParseFailed = TRUE;
                }
            }
        }
    }

    if (fParseFailed)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(ParseError, ERROR_SXS_MANIFEST_PARSE_ERROR);

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\parsing.h ===
#if !defined(_FUSION_SXS_PARSING_H_INCLUDED_)
#define _FUSION_SXS_PARSING_H_INCLUDED_

#pragma once

PCWSTR
SxspFindCharacterInString(
    PCWSTR sz,
    SIZE_T cch,
    WCHAR wch
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\parsing.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    parsing.cpp

Abstract:

    Parsing functions for sxs.dll

Author:

    Michael J. Grier (MGrier) 9-May-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "fusionparser.h"

PCWSTR
SxspFindCharacterInString(
    PCWSTR sz,
    SIZE_T cch,
    WCHAR wch
    )
{
    while (cch != 0)
    {
        if (*sz == wch)
            return sz;

        sz++;
        cch--;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\parsepolicy.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    parsepolicy.cpp

Abstract:

    Functions to parse configuration (policy) manifests.

Author:

    Michael J. Grier (MGrier) January 12, 2001

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "probedassemblyinformation.h"
#include "fusionparser.h"
#include "cteestream.h"
#include "cresourcestream.h"
#include "nodefactory.h"
#include "fusioneventlog.h"
#include "actctxgenctx.h"


extern CHAR NodefactoryTypeName[] = "CNodeFactory";

SxspComponentParsePolicyCore(
    ULONG Flags,
    PACTCTXGENCTX pGenContext,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement,
    IStream *pSourceStream,
    ACTCTXCTB_ASSEMBLY_CONTEXT *pAssemblyContext = NULL
    )
{
    BOOL                        fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    
    CSxsPointer<CNodeFactory, NodefactoryTypeName>   NodeFactory;
    CSmartRef<IXMLParser>       pIXmlParser;
    PASSEMBLY                   Assembly = NULL;
    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> AssemblyIdentity;
    ACTCTXCTB_ASSEMBLY_CONTEXT  LocalAssemblyContext;
    STATSTG                     Stats;
    ULONG                       i;

    rpPolicyStatement = NULL;

    PARAMETER_CHECK(pGenContext != NULL);
    PARAMETER_CHECK(pSourceStream != NULL);
    if (pAssemblyContext == NULL)
    {
        pAssemblyContext = &LocalAssemblyContext;
    }

    IFALLOCFAILED_EXIT(Assembly = new ASSEMBLY);
    IFW32FALSE_EXIT(Assembly->m_Information.Initialize(PolicyAssemblyInformation));

    //
    // Copy the assembly identity, stick it into the callback structure
    //
    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            0, 
            PolicyAssemblyInformation.GetAssemblyIdentity(), 
            &AssemblyIdentity));

    //
    // Set up the structure in general
    //
    pAssemblyContext->AssemblyIdentity = AssemblyIdentity.Detach();
    
    IFW32FALSE_EXIT(
        PolicyAssemblyInformation.GetManifestPath(
            &pAssemblyContext->ManifestPath, 
            &pAssemblyContext->ManifestPathCch));

    IFCOMFAILED_ORIGINATE_AND_EXIT(pSourceStream->Stat(&Stats, STATFLAG_NONAME));

    //
    // Set up the node factory
    //
    IFW32FALSE_EXIT(NodeFactory.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(NodeFactory->Initialize(pGenContext, Assembly, pAssemblyContext));
    IFCOMFAILED_ORIGINATE_AND_EXIT(NodeFactory->SetParseType(
        XML_FILE_TYPE_COMPONENT_CONFIGURATION,
        PolicyAssemblyInformation.GetManifestPathType(),
        PolicyAssemblyInformation.GetManifestPath(),
        Stats.mtime));
    
    //
    // Obtain the parser
    //
    IFW32FALSE_EXIT(::SxspGetXMLParser(IID_IXMLParser, (PVOID*)&pIXmlParser));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXmlParser->SetFactory(NodeFactory));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXmlParser->SetInput(pSourceStream));

    //
    // And they're off!
    //
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXmlParser->Run(-1));
    
    //
    // Tell the contributors we want to be done with this file...
    //
    for (i = 0; i < pGenContext->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(pGenContext->m_Contributors[i].Fire_ParseEnding(pGenContext, pAssemblyContext));
    }

    rpPolicyStatement = NodeFactory->m_CurrentPolicyStatement;
    NodeFactory->m_CurrentPolicyStatement = NULL;

    fSuccess = TRUE;
Exit:
    {
        CSxsPreserveLastError ple;

        for (i = 0; i < pGenContext->m_ContributorCount; i++)
        {
            pGenContext->m_Contributors[i].Fire_ParseEnded(pGenContext, pAssemblyContext);
        }

        if (Assembly != NULL)
            Assembly->Release();

        ple.Restore();
    }

    return fSuccess;
}
    




BOOL
SxspParseNdpGacComponentPolicy(
    ULONG Flags,
    PACTCTXGENCTX pGenContext,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement
    )
{
    FN_PROLOG_WIN32;
    CResourceStream DllStream;

    IFW32FALSE_EXIT(
        DllStream.Initialize(
            PolicyAssemblyInformation.GetManifestPath(), 
            MAKEINTRESOURCEW(RT_MANIFEST)));
    
    IFW32FALSE_EXIT(SxspComponentParsePolicyCore(
        Flags, 
        pGenContext, 
        PolicyAssemblyInformation, 
        rpPolicyStatement, 
        &DllStream));
    
    FN_EPILOG;
}


BOOL
SxspParseComponentPolicy(
    DWORD Flags,
    PACTCTXGENCTX pActCtxGenCtx,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement
    )
{
    FN_PROLOG_WIN32;
    CFileStream FileStream;

    IFW32FALSE_EXIT(
        FileStream.OpenForRead(
            PolicyAssemblyInformation.GetManifestPath(),
            CImpersonationData(),
            FILE_SHARE_READ,
            OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN));

    IFW32FALSE_EXIT(SxspComponentParsePolicyCore(
        Flags,
        pActCtxGenCtx,
        PolicyAssemblyInformation,
        rpPolicyStatement,
        &FileStream));

    FN_EPILOG;
}


BOOL
SxspParseApplicationPolicy(
    DWORD Flags,
    PACTCTXGENCTX pActCtxGenCtx,
    ULONG ulPolicyPathType,
    PCWSTR pszPolicyPath,
    SIZE_T cchPolicyPath,
    IStream *pIStream
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    // declaration order here is partially deliberate, to control cleanup order.
    // normally, declaration order is determined by not declaring until you have
    // the data to initialize with the ctor, but the use of goto messes that up
    CSxsPointer<CNodeFactory, NodefactoryTypeName> NodeFactory;
    CSmartRef<IXMLParser> pIXMLParser;
    ACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    ULONG i;
    PASSEMBLY Assembly = NULL;
    CStringBuffer buffPath;
    STATSTG statstg;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    PARAMETER_CHECK(ulPolicyPathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);

    IFALLOCFAILED_EXIT(Assembly = new ASSEMBLY);

    IFW32FALSE_EXIT(buffPath.Win32Assign(pszPolicyPath, cchPolicyPath));

    IFW32FALSE_EXIT(Assembly->m_Information.Initialize());

    AssemblyContext.AssemblyIdentity = NULL;

    AssemblyContext.Flags = 0;
    AssemblyContext.AssemblyRosterIndex = 1; // hack alert
    AssemblyContext.PolicyPathType = ulPolicyPathType;
    AssemblyContext.PolicyPath = pszPolicyPath;
    AssemblyContext.PolicyPathCch = cchPolicyPath;
    AssemblyContext.ManifestPathType = ACTIVATION_CONTEXT_PATH_TYPE_NONE;
    AssemblyContext.ManifestPath = NULL;
    AssemblyContext.ManifestPathCch = 0;
    AssemblyContext.TeeStreamForManifestInstall = NULL;
    AssemblyContext.pcmWriterStream = NULL;
    AssemblyContext.InstallationInfo = NULL;
    AssemblyContext.AssemblySecurityContext = NULL;
    AssemblyContext.TextuallyEncodedIdentity = NULL;
    AssemblyContext.TextuallyEncodedIdentityCch = 0;

    IFW32FALSE_EXIT(NodeFactory.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(NodeFactory->Initialize(pActCtxGenCtx, Assembly, &AssemblyContext));

    NodeFactory->m_pApplicationPolicyTable = &pActCtxGenCtx->m_ApplicationPolicyTable;

    // Everyone's ready; let's get the XML parser:
    IFW32FALSE_EXIT(::SxspGetXMLParser(IID_IXMLParser, (LPVOID *) &pIXMLParser));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXMLParser->SetFactory(NodeFactory));

    IFCOMFAILED_EXIT(pIStream->Stat(&statstg, STATFLAG_NONAME));

    // Open up the policy file and try parsing it...
    IFW32FALSE_EXIT(
        NodeFactory->SetParseType(
            XML_FILE_TYPE_APPLICATION_CONFIGURATION,
            ulPolicyPathType,
            buffPath,
            statstg.mtime));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXMLParser->SetInput(pIStream));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXMLParser->Run(-1));

    NodeFactory->m_CurrentPolicyStatement = NULL;

    // Tell the contributors we want to be done with this file...
    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        IFW32FALSE_EXIT(pActCtxGenCtx->m_Contributors[i].Fire_ParseEnding(pActCtxGenCtx, &AssemblyContext));

    fSuccess = TRUE;

Exit:
    CSxsPreserveLastError ple;

    // And tell them we're done.
    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        pActCtxGenCtx->m_Contributors[i].Fire_ParseEnded(pActCtxGenCtx, &AssemblyContext);

    if ( ple.LastError() == ERROR_SXS_MANIFEST_PARSE_ERROR || ple.LastError() == ERROR_SXS_MANIFEST_FORMAT_ERROR)
    { // log a general failure eventlog
        ::FusionpLogError(MSG_SXS_PARSE_MANIFEST_FAILED);
    }

    if (Assembly != NULL)
        Assembly->Release();

    ple.Restore();

    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\nodefactory.h ===
#if !defined(_FUSION_SXS_NODEFACTORY_H_INCLUDED_)
#define _FUSION_SXS_NODEFACTORY_H_INCLUDED_

#pragma once

#include "FusionEventLog.h"
#include <windows.h>
#include <sxsp.h>
#include <ole2.h>
#include <xmlparser.h>
#include "fusionbuffer.h"
#include "partialassemblyversion.h"
#include "xmlns.h"
#include "stringpool.h"
#include "policystatement.h"

#define ELEMENT_LEGAL_ATTRIBUTE_FLAG_IGNORE             (0x00000001)
#define ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED           (0x00000002)

typedef struct _ELEMENT_LEGAL_ATTRIBUTE
{
    DWORD m_dwFlags;
    PCATTRIBUTE_NAME_DESCRIPTOR m_pName;
    SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE m_pfnValidator;
    DWORD m_dwValidatorFlags;
} ELEMENT_LEGAL_ATTRIBUTE, PELEMENT_LEGAL_ATTRIBUTE;

typedef const struct _ELEMENT_LEGAL_ATTRIBUTE *PCELEMENT_LEGAL_ATTRIBUTE;

class __declspec(uuid("832ff3cf-05bd-4eda-962f-d0a5307d55ae"))
CNodeFactory : public IXMLNodeFactory
{
public:

    CNodeFactory();
    ~CNodeFactory();

    BOOL Initialize(
        PACTCTXGENCTX ActCtxGenCtx,
        PASSEMBLY Assembly,
        PACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );

    BOOL SetParseType(ULONG ParseType, ULONG PathType, const CBaseStringBuffer &buffFileName, const FILETIME &rftLastWriteTime);
    VOID ResetParseState();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef() { return 1; }
    STDMETHODIMP_(ULONG) Release() { return 1; }
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // IXMLNodeFactory methods:
    STDMETHODIMP NotifyEvent(IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHODIMP BeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP EndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP Error(IXMLNodeSource *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);
    STDMETHODIMP CreateNode(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);

    HRESULT FirstCreateNodeCall(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT NodeCount, const SXS_NODE_INFO *prgNodeInfo);

    enum
    {
        eValidateIdentity_VersionRequired       = 0x00000001,
        eValidateIdentity_PoliciesNotAllowed    = 0x00000002,
        eValidateIdentity_VersionNotAllowed     = 0x00000008,
    };

    enum
    {
        eActualParseType_Undetermined,
        eActualParseType_Manifest,
        eActualParseType_PolicyManifest
    } m_IntuitedParseType;


    BOOL ValidateIdentity(DWORD Flags, ULONG Type, PCASSEMBLY_IDENTITY AssemblyIdentity);
    BOOL ValidateElementAttributes(PCSXS_NODE_INFO prgNodes, SIZE_T cNodes, PCELEMENT_LEGAL_ATTRIBUTE prgAttributes, UCHAR cAttributes);

    PCACTCTXCTB_PARSE_CONTEXT GetParseContext() const { return &m_ParseContext; }

#if FUSION_XML_TREE
    HRESULT CreateXmlNode(PSXS_XML_NODE pParent, ULONG cNodes, XML_NODE_INFO **prgpNodes, PSXS_XML_NODE &rpNewNode);
#endif // FUSION_XML_TREE

// protected:
    PACTCTXGENCTX m_ActCtxGenCtx;
    PASSEMBLY m_Assembly;
    CXMLNamespaceManager m_XMLNamespaceManager;
    ULONG m_ParseType;

    bool m_fFirstCreateNodeCall;

    // We only track the state of the parse with respect to the tags that
    // we're interested in for metadata purposes.  This amounts to just the
    // <ASSEMBLY> tag, and the dependencies.  We ignore the rest.
    enum XMLParseState
    {
        eNotParsing,
        eParsing_doc,
        eParsing_doc_assembly,
        eParsing_doc_assembly_assemblyIdentity,
        eParsing_doc_assembly_comInterfaceExternalProxyStub,
        eParsing_doc_assembly_description,
        eParsing_doc_assembly_dependency,
        eParsing_doc_assembly_dependency_dependentAssembly,
        eParsing_doc_assembly_dependency_dependentAssembly_assemblyIdentity,
        eParsing_doc_assembly_dependency_dependentAssembly_bindingRedirect,
        eParsing_doc_assembly_file,
        eParsing_doc_assembly_file_comClass,
        eParsing_doc_assembly_file_comClass_progid,
        eParsing_doc_assembly_file_comInterfaceProxyStub,
        eParsing_doc_assembly_file_typelib,
        eParsing_doc_assembly_file_windowClass,
        eParsing_doc_assembly_clrSurrogate,
        eParsing_doc_assembly_clrClass,
        eParsing_doc_assembly_clrClass_progid,
        eParsing_doc_assembly_noInherit,
        eParsing_doc_assembly_noInheritable,
        eParsing_doc_configuration,
        eParsing_doc_configuration_windows,
        eParsing_doc_configuration_windows_assemblyBinding,
        eParsing_doc_configuration_windows_assemblyBinding_assemblyIdentity,
        eParsing_doc_configuration_windows_assemblyBinding_dependentAssembly,
        eParsing_doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity,
        eParsing_doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect,
        eFatalParseError,
    } m_xpsParseState;

    ULONG m_cUnknownChildDepth;
    PACTCTXCTB_ASSEMBLY_CONTEXT m_AssemblyContext;
    ACTCTXCTB_PARSE_CONTEXT m_ParseContext;
    CSmallStringBuffer m_buffElementPath;
    CStringBuffer m_buffCurrentFileName;

    PASSEMBLY_IDENTITY m_CurrentPolicyDependentAssemblyIdentity;
    CPolicyStatement *m_CurrentPolicyStatement;
    CCaseInsensitiveUnicodeStringPtrTable<CPolicyStatement> *m_pApplicationPolicyTable;
    CStringBuffer m_buffCurrentApplicationPolicyIdentityKey;

    bool m_fAssemblyFound;
    bool m_fIdentityFound;
    bool m_fIsDependencyOptional;
    bool m_fDependencyChildHit;
    bool m_fAssemblyIdentityChildOfDependenctAssemblyHit;
    bool m_fIsMetadataSatellite;
    bool m_fMetadataSatelliteAlreadyFound;
    bool m_fNoInheritableFound;

    HRESULT ConvertXMLNodeInfoToSXSNodeInfo(const XML_NODE_INFO *pNodeInfo, SXS_NODE_INFO & sxsNodeInfo);

#if FUSION_XML_TREE
    CStringPool m_ParseTreeStringPool;
    SXS_XML_DOCUMENT m_XmlDocument;
    SXS_XML_NODE *m_CurrentNode;
    SXS_XML_NODE *m_CurrentParent;
    SXS_XML_STRING m_InlineStringArray[64];
    SXS_XML_STRING *m_ActualStringArray;
#endif

    //
    //  XML Parsing worker functions:
    //

    typedef BOOL (CNodeFactory::*XMLParserWorkerFunctionPtr)(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);

    BOOL XMLParser_Element_doc_assembly(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_noInherit(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_noInheritable(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_assemblyIdentity(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_dependency(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_dependency_dependentAssembly(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_dependency_dependentAssembly_assemblyIdentity(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_dependency_dependentAssembly_bindingRedirect(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);

    BOOL XMLParser_Element_doc_configuration(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_assemblyIdentity(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);


    //
    //  Parsing helper functions:
    //

    enum XMLAttributeType
    {
        eAttributeTypeString,   // represented by a CStringBuffer
        eAttributeTypeVersion,  // represented by a ASSEMBLY_VERSION
    };

    //
    //  Parser datatype specific worker functions.  The first two parameters
    //  are combined to refer the member to actually modify.  The third is the
    //  character string to be used as the value of the attribute.
    //
    //  As an optimization, the datatype worker function may modify/destroy
    //  the value in the third parameter.  For example, the worker function
    //  which just copies a CStringBuffer to another CStringBuffer actually
    //  uses the CStringBuffer::TakeValue() member which avoids performing
    //  a dynamic allocation if the attribute value exceeded the non-dynamically
    //  allocated portion of the CStringBuffer.
    //

    typedef BOOL (CNodeFactory::*XMLParserValueParserFunctionPtr)(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);

    BOOL XMLParser_Parse_String(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_Version(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_ULARGE_INTEGER(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_FILETIME(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_GUID(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_BLOB(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_InstallAction(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_Boolean(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_PartialAssemblyVersion(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);

    struct AttributeMapEntry
    {
        LPCWSTR m_pszAttributeName;
        SIZE_T m_cchAttributeName;
        SIZE_T m_offsetData;
        SIZE_T m_offsetIndicator;
        XMLParserValueParserFunctionPtr m_pfn;
    };

    BOOL ParseElementAttributes(
        USHORT cNumRecs,
        XML_NODE_INFO **prgpNodeInfo,
        SIZE_T cAttributeMapEntries,
        const AttributeMapEntry *prgEntries);

    HRESULT LogParseError(
        DWORD dwLastParseError,
        const UNICODE_STRING *p1 = NULL,
        const UNICODE_STRING *p2 = NULL,
        const UNICODE_STRING *p3 = NULL,
        const UNICODE_STRING *p4 = NULL,
        const UNICODE_STRING *p5 = NULL,
        const UNICODE_STRING *p6 = NULL,
        const UNICODE_STRING *p7 = NULL,
        const UNICODE_STRING *p8 = NULL,
        const UNICODE_STRING *p9 = NULL,
        const UNICODE_STRING *p10 = NULL,
        const UNICODE_STRING *p11 = NULL,
        const UNICODE_STRING *p12 = NULL,
        const UNICODE_STRING *p13 = NULL,
        const UNICODE_STRING *p14 = NULL,
        const UNICODE_STRING *p15 = NULL,
        const UNICODE_STRING *p16 = NULL,
        const UNICODE_STRING *p17 = NULL,
        const UNICODE_STRING *p18 = NULL,
        const UNICODE_STRING *p19 = NULL,
        const UNICODE_STRING *p20 = NULL
        );

    static VOID WINAPI ParseErrorCallback_MissingRequiredAttribute(
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
        );

    static VOID WINAPI ParseErrorCallback_AttributeNotAllowed(
        IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
        );

    static VOID WINAPI ParseErrorCallback_InvalidAttributeValue(
        IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
        );

private:
    CNodeFactory(const CNodeFactory &);
    void operator =(const CNodeFactory &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\partialassemblyversion.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    partialassemblyversion.cpp

Abstract:

    Class describing a partial/wildcarded assembly version.

Author:

    Michael J. Grier (MGrier) 13-May-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "partialassemblyversion.h"

BOOL
CPartialAssemblyVersion::Parse(
    PCWSTR sz,
    SIZE_T Cch
    )
{
    BOOL fSuccess = FALSE;
    ULONG cDots = 0;
    PCWSTR pszTemp;
    SIZE_T CchLeft;
    USHORT usTemp;
    ASSEMBLY_VERSION avTemp;
    PCWSTR pszLast;
    BOOL MajorSpecified = FALSE;
    BOOL MinorSpecified = FALSE;
    BOOL BuildSpecified = FALSE;
    BOOL RevisionSpecified = FALSE;

    // Somehow people often leave trailing nulls; we'll just back off Cch in this case.
    while ((Cch != 0) && (sz[Cch - 1] == L'\0'))
        Cch--;

    avTemp.Major = 0;
    avTemp.Minor = 0;
    avTemp.Revision = 0;
    avTemp.Build = 0;

    // "*" means everything unspecified...
    if ((Cch == 1) && (sz[0] == L'*'))
    {
        m_MajorSpecified = FALSE;
        m_MinorSpecified = FALSE;
        m_BuildSpecified = FALSE;
        m_RevisionSpecified = FALSE;

        fSuccess = TRUE;
        goto Exit;
    }

    pszTemp = sz;
    CchLeft = Cch;

    while (CchLeft-- != 0)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'.')
        {
            cDots++;

            if (cDots >= 4)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
        }
        else if ((wch != L'*') && ((wch < L'0') || (wch > L'9')))
        {
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
    }

    if (cDots < 3)
    {
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    pszTemp = sz;
    pszLast = sz + Cch;

    usTemp = 0;
    for (;;)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'*')
        {
            // If there's been a previous digit, we can't then have a * (there's no matching version number "5*")
            if (MajorSpecified)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            if (*pszTemp != L'.')
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            break;
        }

        if (wch == L'.')
            break;

        usTemp = (usTemp * 10) + (wch - L'0');
        MajorSpecified = TRUE;
    }
    avTemp.Major = usTemp;

    usTemp = 0;
    for (;;)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'*')
        {
            // If there's been a previous digit, we can't then have a * (there's no matching version number "5*")
            if (MinorSpecified)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            if (*pszTemp != L'.')
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            break;
        }

        if (wch == L'.')
            break;

        usTemp = (usTemp * 10) + (wch - L'0');
        MinorSpecified = TRUE;
    }
    avTemp.Minor = usTemp;

    usTemp = 0;
    for (;;)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'*')
        {
            // If there's been a previous digit, we can't then have a * (there's no matching version number "5*")
            if (RevisionSpecified)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            if (*pszTemp != L'.')
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            break;
        }

        if (wch == L'.')
            break;

        usTemp = (usTemp * 10) + (wch - L'0');
        RevisionSpecified = TRUE;
    }
    avTemp.Revision = usTemp;

    // Now the tricky bit.  We aren't necessarily null-terminated, so we
    // have to just look for hitting the end.
    usTemp = 0;
    while (pszTemp < pszLast)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'*')
        {
            // If there's been a previous digit, we can't then have a * (there's no matching version number "5*")
            if (MajorSpecified)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            // If that wasn't the last character, it was wrong.
            if (pszTemp < pszLast)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            break;
        }

        usTemp = (usTemp * 10) + (wch - L'0');
        BuildSpecified = TRUE;
    }
    avTemp.Build = usTemp;

    m_AssemblyVersion = avTemp;

    m_MajorSpecified = MajorSpecified;
    m_MinorSpecified = MinorSpecified;
    m_RevisionSpecified = RevisionSpecified;
    m_BuildSpecified = BuildSpecified;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\partialassemblyversion.h ===
#if !defined(_FUSION_SXS_PARTIALVERSION_H_INCLUDED_)
#define _FUSION_SXS_PARTIALVERSION_H_INCLUDED_

#pragma once

#include <sxsapi.h>
#include "fusionbuffer.h"

//
//  A CPartialAssemblyVersion is a class that wraps an inexact version
//  specification.
//
//  The initial implementation just assumes that it's basically an ASSEMBLY_VERSION,
//  but that any of the fields may be "wildcarded".
//
//  Future versions may allow for more interesting partial version specifications
//  such as "major=5; minor=1; build=2103; revision >= 100".  This is beyond the
//  bounds of the initial implementation, but forms the basis for the public
//  interface (parse, format, test match)
//

class CPartialAssemblyVersion
{
public:
    CPartialAssemblyVersion() : m_MajorSpecified(FALSE), m_MinorSpecified(FALSE), m_BuildSpecified(FALSE), m_RevisionSpecified(FALSE) { }
    ~CPartialAssemblyVersion() { }

    BOOL Parse(PCWSTR VersionString, SIZE_T VersionStringCch);
    BOOL Format(CBaseStringBuffer &rOutputBuffer, SIZE_T *CchOut) const;

    BOOL Matches(const ASSEMBLY_VERSION &rav) const;

    // Returns true of any ASSEMBLY_VERSION would match (e.g. "*" or "*.*.*.*")
    BOOL MatchesAny() const { return !(m_MajorSpecified || m_MinorSpecified || m_BuildSpecified || m_RevisionSpecified); }

protected:
    ASSEMBLY_VERSION m_AssemblyVersion;
    BOOL m_MajorSpecified, m_MinorSpecified, m_BuildSpecified, m_RevisionSpecified;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pcmtestfactory.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pcmtestfactory.cpp

Abstract:
    implementation of a nodefactory for Precompiled manifest testing

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/

#include "stdinc.h"
#include "fusioneventlog.h"
#include "pcmtestfactory.h"
#include "stdio.h"
#include "FusionEventLog.h"
#include <ole2.h>
#include "xmlparser.hxx"
#include "xmlparsertest.hxx"

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE PCMTestFactory::NotifyEvent(
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt)
{
    UNUSED(pSource);
    UNUSED(iEvt);

    // do nothing because PCM does not contain NotifyEvent record
    return NOERROR;
}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE PCMTestFactory::BeginChildren(
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    HRESULT hr = NOERROR;
    UNUSED(pSource);
    UNUSED(pNodeInfo);

    m_pFileStream->fprintf("BeginChildren\n");
    return hr;

}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE PCMTestFactory::EndChildren(
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmptyNode,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    HRESULT hr = NOERROR ;

    UNUSED(pSource);
    UNUSED(fEmptyNode);
    UNUSED(pNodeInfo);

    m_pFileStream->fprintf("EndChildren");
    if ( fEmptyNode ) {
        m_pFileStream->fprintf("(fEmpty=TRUE)\n");
    }else
        m_pFileStream->fprintf("(fEmpty=FALSE)\n");

    return hr;
}

VOID PCMTestFactory::PrintXMLNodeType(DWORD dwType)
{
    m_pFileStream->fprintf("\t\tdwType           = ");

    switch(dwType) {
        case XML_CDATA:
            m_pFileStream->fprintf("XML_CDATA\n");
            break;
        case XML_COMMENT :
            m_pFileStream->fprintf("XML_COMMENT\n");
            break ;
        case XML_WHITESPACE :
            m_pFileStream->fprintf("XML_WHITESPACE\n");
            break ;
        case XML_ELEMENT :
            m_pFileStream->fprintf("XML_ELEMENT\n");
            break ;
        case XML_ATTRIBUTE :
            m_pFileStream->fprintf("XML_ATTRIBUTE\n");
            break ;
        case XML_PCDATA :
            m_pFileStream->fprintf("XML_PCDATA\n");
            break ;
        case XML_PI:
            m_pFileStream->fprintf("XML_PI\n");
            break;
        case XML_XMLDECL :
            m_pFileStream->fprintf("XML_XMLDECL\n");
            break;
        case XML_DOCTYPE :
            m_pFileStream->fprintf("XML_DOCTYPE\n");
            break;
        case XML_ENTITYDECL :
            m_pFileStream->fprintf("XML_ENTITYDECL\n");
            break;
        case XML_ELEMENTDECL :
            m_pFileStream->fprintf("XML_ELEMENTDECL\n");
            break;
        case XML_ATTLISTDECL :
            m_pFileStream->fprintf("XML_ATTLISTDECL\n");
            break;
        case XML_NOTATION :
            m_pFileStream->fprintf("XML_NOTATION\n");
            break;
        case XML_ENTITYREF :
            m_pFileStream->fprintf("XML_ENTITYREF\n");
            break;
        case XML_DTDATTRIBUTE:
            m_pFileStream->fprintf("XML_DTDATTRIBUTE\n");
            break;
        case XML_GROUP :
            m_pFileStream->fprintf("XML_GROUP\n");
            break;
        case XML_INCLUDESECT :
            m_pFileStream->fprintf("XML_INCLUDESECT\n");
            break;
        case XML_NAME :
            m_pFileStream->fprintf("XML_NAME\n");
            break;
        case XML_NMTOKEN :
            m_pFileStream->fprintf("XML_NMTOKEN\n");
            break;
        case XML_STRING :
            m_pFileStream->fprintf("XML_STRING\n");
            break;
        case XML_PEREF :
            m_pFileStream->fprintf("XML_PEREF\n");
            break;
        case XML_MODEL :
            m_pFileStream->fprintf("XML_MODEL\n");
            break;
        case XML_ATTDEF :
            m_pFileStream->fprintf("XML_ATTDEF\n");
            break;
        case XML_ATTTYPE :
            m_pFileStream->fprintf("XML_ATTTYPE\n");
            break;
        case XML_ATTPRESENCE :
            m_pFileStream->fprintf("XML_ATTPRESENCE\n");
            break;
        case XML_DTDSUBSET :
            m_pFileStream->fprintf("XML_DTDSUBSET\n");
            break;
        case XML_LASTNODETYPE :
            m_pFileStream->fprintf("XML_LASTNODETYPE\n");
            break;
        default :
            m_pFileStream->fprintf(" NOT KNOWN TYPE! ERROR!!\n");
    } // end of switch

}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE PCMTestFactory::CreateNode(
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
{
    HRESULT hr = NOERROR;
    DWORD i;

    UNUSED(pSource);
    UNUSED(pNode);
    UNUSED(apNodeInfo);
    UNUSED(cNumRecs);

    m_pFileStream->fprintf("CreateNode\n");
    for( i = 0; i < cNumRecs; i++)
        PrintSingleXMLNode(apNodeInfo[i]);
    return hr;
}

VOID PCMTestFactory::PrintSingleXMLNode(XML_NODE_INFO * pNode)
{
    m_pFileStream->fprintf("\tXML_NODE_INFO: \n");
    m_pFileStream->fprintf("\t\tdwSize           = %d \n", pNode->dwSize);
    PrintXMLNodeType(pNode->dwType);
    m_pFileStream->fprintf("\t\tdwSubType        = %d \n", pNode->dwSubType);
    m_pFileStream->fprintf("\t\tfTerminal        = %d \n", pNode->fTerminal);
    m_pFileStream->fwrite((PVOID)(pNode->pwcText), sizeof(WCHAR), pNode->ulLen);
    m_pFileStream->fprintf("\t\tulLen            = %d \n", pNode->ulLen);
    m_pFileStream->fprintf("\t\tulNsPrefixLen    = %d \n", pNode->ulNsPrefixLen);
    m_pFileStream->fprintf("\t\tpNode            = NULL\n");
    m_pFileStream->fprintf("\t\tpReserved        = NULL \n\n");
}

STDMETHODIMP_(ULONG)
PCMTestFactory::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
}
STDMETHODIMP_(ULONG)
PCMTestFactory::Release()
{
    ULONG lRet = InterlockedDecrement ((PLONG)&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);

    return lRet;
}

STDMETHODIMP
PCMTestFactory::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == __uuidof(this))
    {
        *ppv = this;
    }
    else if (riid == IID_IUnknown
        || riid == IID_IXMLNodeFactory)
    {
        *ppv = static_cast<IXMLNodeFactory*> (this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pcmwriter.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pcmwriter.cpp

Abstract:
    implementation of Precompiled manifest writer

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/

#include "stdinc.h"
#include "pcm.h"
#include "nodefactory.h"
//helper APIs
HRESULT CPrecompiledManifestWriter::SetFactory(IXMLNodeFactory *pNodeFactory)
{
    if (! pNodeFactory)
        return E_INVALIDARG;

    m_pNodeFactory = pNodeFactory;

    return NOERROR;
}

HRESULT CPrecompiledManifestWriter::Close()
{
    HRESULT hr = NOERROR;

    if (m_pFileStream)
        hr = m_pFileStream->Close(m_ulRecordCount, m_usMaxNodeCount);

    return hr;
}
HRESULT CPrecompiledManifestWriter::Initialize(PCWSTR pcmFileName)
{
    HRESULT hr = NOERROR;
    CStringBuffer buffFileName;

    if ( ! pcmFileName )
        return E_INVALIDARG;

    hr = buffFileName.Assign(pcmFileName, ::wcslen(pcmFileName));
    if (FAILED(hr))
        return hr;

    // Initialize() is assumed to be called only once
    if (m_pFileStream != NULL){
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %S is called more than once\n", __FUNCTION__);

        return E_UNEXPECTED;
    }

    m_pFileStream = new CPrecompiledManifestWriterStream;
    if ( !m_pFileStream )
        return E_OUTOFMEMORY;

    hr = m_pFileStream->SetSink(buffFileName);
    if (FAILED(hr))
        goto Exit;

    hr = WritePCMHeader();
    if ( FAILED(hr))
        goto Exit;

    hr= NOERROR;

Exit:
    return hr;

}

// we assume that this pStream is initialized by using SetSink....
HRESULT CPrecompiledManifestWriter::SetWriterStream(CPrecompiledManifestWriterStream * pSinkedStream)
{
    if ( ! pSinkedStream )
        return E_INVALIDARG;

    ASSERT(pSinkedStream->IsSinkedStream() == TRUE);

    m_pFileStream = pSinkedStream;

    return NOERROR;
}

// write helper APIs
HRESULT CPrecompiledManifestWriter::GetPCMRecordSize(XML_NODE_INFO ** ppNodeInfo, USHORT iNodeCount, ULONG * pSize)
{
    ULONG ulSize = 0 ;
    XML_NODE_INFO *pNode = NULL;
    USHORT i = 0 ;
    ULONG ulSingleRecordSize = offsetof(XML_NODE_INFO, pNode);
    HRESULT hr = NOERROR;

    if ( pSize)
        *pSize = 0 ;

    if ((!pSize) || (!ppNodeInfo) || (!*ppNodeInfo))
       return E_INVALIDARG;
    // validate ppNodeInfo
    for (i=0;i<iNodeCount;i++)
        if (!ppNodeInfo[i])
            return E_INVALIDARG;

    *pSize = 0;
    for ( i=0; i < iNodeCount; i++){
        pNode = ppNodeInfo[i];
        ASSERT(pNode);
        //ulSize += ulSingleRecordSize = sizeof(XML_NODE_INFO)- sizeof(PVOID) - sizeof(PVOID);
        ulSize += ulSingleRecordSize = offsetof(XML_NODE_INFO, pNode);
        ulSize += pNode->ulLen * sizeof(WCHAR);
    }
    if ( pSize)
    *pSize = ulSize;

    return hr;
}

HRESULT CPrecompiledManifestWriter::WritePCMHeader()
{
    HRESULT hr = NOERROR;
    PCMHeader pcmHeader;

    pcmHeader.iVersion = 1;
    pcmHeader.ulRecordCount = 0 ;
    pcmHeader.usMaxNodeCount = 0 ;

    hr = m_pFileStream->WriteWithDelay((PVOID)&(pcmHeader), sizeof(PCMHeader), NULL);
    if (FAILED(hr))
        goto Exit;
    hr = NOERROR;

Exit:
    return hr;
}

HRESULT CPrecompiledManifestWriter::WritePCMRecordHeader(PCM_RecordHeader * pHeader)
{
    HRESULT hr = NOERROR;

    ASSERT(m_pFileStream);
    if ( ! pHeader)
        return E_INVALIDARG;

    hr = m_pFileStream->WriteWithDelay((PVOID)(pHeader), sizeof(PCM_RecordHeader), NULL);
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

inline void FromXMLNodeToPCMXMLNode(PCM_XML_NODE_INFO *pPCMNode, XML_NODE_INFO *pNode)
{
    ASSERT(pPCMNode && pNode);

    pPCMNode->dwSize    = pNode->dwSize;
    pPCMNode->dwType    = pNode->dwType ;
    pPCMNode->dwSubType = pNode->dwSubType ;
    pPCMNode->fTerminal = pNode->fTerminal ;
    pPCMNode->ulLen     = pNode->ulLen ;
    pPCMNode->ulNsPrefixLen = pNode->ulNsPrefixLen ;
    pPCMNode->offset    = 0 ;

    return;

}
HRESULT CPrecompiledManifestWriter::WritePCMXmlNodeInfo(XML_NODE_INFO ** ppNodeInfo, USHORT iNodeCount, RECORD_TYPE_PRECOMP_MANIFEST typeID, PVOID param)
{
    HRESULT hr = NOERROR;
    ULONG offset ;
    USHORT i;
    PCM_XML_NODE_INFO pcmNode;
    XML_NODE_INFO * pNode = NULL ;
    USHORT  uTextAddr;
    USHORT  uTextOffset;
    ULONG   cbWritten;
    LPWSTR *ppText = NULL;
    ULONG  *pcbLen = NULL;
    LPWSTR pstr;
    ULONG  ulLen;

    if ((!ppNodeInfo) || (!*ppNodeInfo))
        return E_INVALIDARG;
    if (!((typeID == ENDCHILDREN_PRECOMP_MANIFEST) || (typeID == BEGINCHILDREN_PRECOMP_MANIFEST) ||
        (typeID == CREATENODE_PRECOMP_MANIFEST)))
        return E_INVALIDARG;

    if (!m_pFileStream)
        return E_UNEXPECTED;

    //uTextAddr = sizeof(PCM_RecordHeader) + NodeCount * sizeof(PCM_XML_NODE_INFO);
    // RecordHeader is read before the boby(XML_NODE_INFO) is read
    uTextAddr = iNodeCount * sizeof(PCM_XML_NODE_INFO);
    uTextOffset = 0;


    if (typeID ==  ENDCHILDREN_PRECOMP_MANIFEST) // param1 is fEmpty;
        uTextAddr += sizeof(BOOL);
    else if (typeID ==  CREATENODE_PRECOMP_MANIFEST) // param1 = linenumber
        uTextAddr += sizeof(ULONG);

    if ( iNodeCount == 1) { // for BeginChildren and EndChildren
        ppText = &pstr;
        pcbLen = &ulLen;
    }
    else
    {
        ppText = FUSION_NEW_ARRAY(LPWSTR, iNodeCount);
        if (!ppText) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pcbLen = FUSION_NEW_ARRAY(ULONG, iNodeCount);
        if (!pcbLen ){
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // write all records
    for (i=0; i<iNodeCount; i++) {
        pNode = ppNodeInfo[i];
        if (!pNode) {
            hr = E_FAIL;
            goto Exit;
        }
        ppText[i] = (LPWSTR)(pNode->pwcText) ;
        pcbLen[i] = pNode->ulLen * sizeof(WCHAR);

        //pPCMNode = static_cast<PCM_XML_NODE_INFO *>(pNode);
        FromXMLNodeToPCMXMLNode(&pcmNode, pNode);  // void function
        pcmNode.offset = uTextAddr + uTextOffset;
        uTextAddr = uTextAddr + uTextOffset;
        uTextOffset = (USHORT)pcmNode.ulLen * sizeof(WCHAR) ;

        hr = m_pFileStream->WriteWithDelay((PVOID)&pcmNode, sizeof(PCM_XML_NODE_INFO), &cbWritten);
        if ( FAILED(hr))
            goto Exit;
    }

    if ( typeID == ENDCHILDREN_PRECOMP_MANIFEST)  // write fEmpty into the file
        hr = m_pFileStream->WriteWithDelay(param, sizeof(BOOL), &cbWritten);
    else if ( typeID == CREATENODE_PRECOMP_MANIFEST)
        hr = m_pFileStream->WriteWithDelay(param, sizeof(ULONG), &cbWritten);

    // write texts in all records
    for (i=0; i<iNodeCount; i++) {
        hr = m_pFileStream->WriteWithDelay((PVOID)ppText[i], (ULONG)pcbLen[i], &cbWritten);
        if ( FAILED(hr))
            goto Exit;
    }

Exit :

    if ((ppText) && (ppText != &pstr))
        FUSION_DELETE_ARRAY(ppText);

    if ( (pcbLen) && ( pcbLen != &ulLen))
        FUSION_DELETE_ARRAY(pcbLen);

    return hr;
}

// write APIs
HRESULT CPrecompiledManifestWriter::WritePrecompiledManifestRecord(RECORD_TYPE_PRECOMP_MANIFEST typeID,
                                                            PVOID pData, USHORT NodeCount, PVOID param)
{
    HRESULT hr=NOERROR;
    PCM_RecordHeader pcmHeader;
    XML_NODE_INFO ** apNodeInfo = NULL ;


    if (!pData)
        return E_INVALIDARG;

    // validate typeID and param
    if ((typeID ==  ENDCHILDREN_PRECOMP_MANIFEST) || (typeID ==  CREATENODE_PRECOMP_MANIFEST)){
        if (!param)
            return E_INVALIDARG;
    }else if (typeID !=  BEGINCHILDREN_PRECOMP_MANIFEST)
        return E_INVALIDARG;

    apNodeInfo = (XML_NODE_INFO **)pData;

    pcmHeader.typeID = typeID;
    hr = GetPCMRecordSize(apNodeInfo, NodeCount, &pcmHeader.RecordSize) ;  // the size contains each string's length
    if (FAILED(hr))
        goto Exit;

    if (typeID ==  ENDCHILDREN_PRECOMP_MANIFEST)  // param1 is fEmpty;
        pcmHeader.RecordSize += sizeof(BOOL);
    else if (typeID ==  CREATENODE_PRECOMP_MANIFEST)  // param1 is Current Line number
        pcmHeader.RecordSize += sizeof(ULONG);

    pcmHeader.NodeCount = NodeCount;

    hr = WritePCMRecordHeader(&pcmHeader);
    if (FAILED(hr))
        goto Exit;

    hr = WritePCMXmlNodeInfo(apNodeInfo, NodeCount, typeID, param);
    if (FAILED(hr))
        goto Exit;

    m_ulRecordCount ++ ;
    if ( NodeCount > m_usMaxNodeCount )
        m_usMaxNodeCount = NodeCount;

    hr = NOERROR;
Exit:
    return hr;
}


// IUnknown
ULONG CPrecompiledManifestWriter::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
}

ULONG CPrecompiledManifestWriter::Release()
{
    ULONG lRet = InterlockedDecrement ((PLONG)&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);
    return lRet;
}

HRESULT CPrecompiledManifestWriter::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (riid == __uuidof(this))
    {
        *ppv = this;
    }
    else if (riid ==  IID_IUnknown
        || riid == IID_IXMLNodeFactory)
    {
        *ppv = static_cast<IXMLNodeFactory*> (this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

// IXMLNodeFactory methods:
HRESULT CPrecompiledManifestWriter::NotifyEvent(IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt)
{
    ASSERT(m_pNodeFactory);
    // no hr-canonicalization is needed because these two nodefactories are supposed to return the correct range of values
    return m_pNodeFactory->NotifyEvent(pSource, iEvt);
}

HRESULT CPrecompiledManifestWriter::BeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo)
{
    HRESULT hr = NOERROR;
    ASSERT(m_pNodeFactory);
    hr = m_pNodeFactory->BeginChildren(pSource, pNodeInfo);
    if ( FAILED(hr))
        goto Exit;

    // write pcm file
    hr = WritePrecompiledManifestRecord(BEGINCHILDREN_PRECOMP_MANIFEST,
                                            &pNodeInfo, 1, NULL);
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT CPrecompiledManifestWriter::EndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo)
{
    HRESULT hr = NOERROR;
    ASSERT(m_pNodeFactory);
    hr = m_pNodeFactory->EndChildren(pSource, fEmpty, pNodeInfo);
    if ( FAILED(hr))
        goto Exit;

    // write pcm file
    hr = WritePrecompiledManifestRecord(ENDCHILDREN_PRECOMP_MANIFEST, &pNodeInfo, 1, &fEmpty);
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT CPrecompiledManifestWriter::Error(IXMLNodeSource *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo)
{
    ASSERT(m_pNodeFactory);
    // no hr-canonicalization is needed because these two nodefactories are supposed to return the correct range of values
    return m_pNodeFactory->Error(pSource, hrErrorCode, cNumRecs, apNodeInfo);
}

HRESULT CPrecompiledManifestWriter::CreateNode(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo)
{
    ULONG ulLineNumber ;
    HRESULT hr = NOERROR;

    ASSERT(m_pNodeFactory);
    if ( ! m_pNodeFactory)
        return E_UNEXPECTED;

    hr = m_pNodeFactory->CreateNode(pSource, pNodeParent, cNumRecs, apNodeInfo);
    if ( FAILED(hr))
        goto Exit;

    ulLineNumber = pSource->GetLineNumber();
    hr = WritePrecompiledManifestRecord(CREATENODE_PRECOMP_MANIFEST,
                                            apNodeInfo, cNumRecs, &ulLineNumber);
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT CPrecompiledManifestWriter::Initialize(PACTCTXGENCTX ActCtxGenCtx, PASSEMBLY Assembly,
                                    PACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    CSmartRef<CNodeFactory> pNodeFactory;

    if (! m_pNodeFactory) {
        pNodeFactory = new CNodeFactory;
        if (!pNodeFactory) {
            return E_OUTOFMEMORY;
        }
        m_pNodeFactory = pNodeFactory;
    }
    else {
        hr = pNodeFactory.QueryInterfaceFrom(m_pNodeFactory);
        ASSERT(SUCCEEDED(hr));
    }

    IFW32FALSE_EXIT(pNodeFactory->Initialize(ActCtxGenCtx, Assembly, AssemblyContext));

    IFCOMFAILED_EXIT(this->SetWriterStream(reinterpret_cast<CPrecompiledManifestWriterStream*>(AssemblyContext->pcmWriterStream));

    // this must be called in order for later use
    IFCOMFAILED_EXIT(this->WritePCMHeader());

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pcmreader.cpp ===
/*++                                                                                                          /*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pcmreader.cpp

Abstract:
    implementation of PrecompiledManifestReader

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/

#include "stdinc.h"
#include "pcm.h"


/* main function of this class
pwcText in XML_NODE_INFO is not allocated in the code because we use file mapping
*/
HRESULT
CPrecompiledManifestReader::InvokeNodeFactory(PCWSTR pcmFileName, IXMLNodeFactory * pXMLNodeFactory)
{
    HRESULT                 hr = NOERROR;
    PCMHeader               pcmHeader;
    PCM_RecordHeader        pcmRecordHeader;
    typedef XML_NODE_INFO*  PXML_NODE_INFO;
    PXML_NODE_INFO*         ppNodes = NULL;  // array of PXML_NODE_INFO
    XML_NODE_INFO*          pXMLData = NULL;

    ULONG                   i, j;
    BOOL                    fEmpty = FALSE;

    if ((!pcmFileName)  || (!pXMLNodeFactory))
        return E_INVALIDARG;

    hr = OpenForRead(pcmFileName);
    if (FAILED(hr))
        goto Exit;

    hr = ReadPCMHeader(&pcmHeader);
    if (FAILED(hr))
        goto Exit;

    if ( pcmHeader.iVersion != 1) { // wrong version number
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Wrong Version of Precompiled manifest file %S in %S()\n", pcmFileName, __FUNCTION__);

        hr = E_FAIL;
        goto Exit;
    }

    // by allocate the maximum PXML_NODE_INFO, this space would be reused
    ppNodes = FUSION_NEW_ARRAY(PXML_NODE_INFO, pcmHeader.usMaxNodeCount);
    if (!ppNodes) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pXMLData = FUSION_NEW_ARRAY(XML_NODE_INFO, pcmHeader.usMaxNodeCount);
    if (!pXMLData){
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    memset(pXMLData, 0, sizeof(XML_NODE_INFO)*pcmHeader.usMaxNodeCount);

    // setup the pointer array and data
    for (i=0;i<pcmHeader.usMaxNodeCount; i++)
        ppNodes[i] = &pXMLData[i];

    for ( i=0; i<pcmHeader.ulRecordCount; i++) {
        hr = ReadPCMRecordHeader(&pcmRecordHeader);
        if (FAILED(hr))
            goto Exit;

        switch(pcmRecordHeader.typeID) {
            case ENDCHILDREN_PRECOMP_MANIFEST :
                hr = ReadPCMRecord(ppNodes, &pcmRecordHeader, &fEmpty); // fEmpty would be set
                break;
            case CREATENODE_PRECOMP_MANIFEST :
                hr = ReadPCMRecord(ppNodes, &pcmRecordHeader, NULL);    // m_ulLineNumber would be Set
                break;
            case BEGINCHILDREN_PRECOMP_MANIFEST :
                hr = ReadPCMRecord(ppNodes, &pcmRecordHeader, NULL);
                break;
            default:
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %S() failed for invalid typeID in PCM Record", __FUNCTION__);

                hr = E_UNEXPECTED;
        } // end of swtich

        if (FAILED(hr))
            goto Exit;

        switch (pcmRecordHeader.typeID){
            case CREATENODE_PRECOMP_MANIFEST:
                hr = pXMLNodeFactory->CreateNode(this, NULL, (USHORT)(pcmRecordHeader.NodeCount), ppNodes);
                // "this" is passed in CreateNode because it has implemented IXMLNodeSource
            break;
            case BEGINCHILDREN_PRECOMP_MANIFEST:
                hr = pXMLNodeFactory->BeginChildren(NULL, *ppNodes);
            break;
            case ENDCHILDREN_PRECOMP_MANIFEST :
                hr = pXMLNodeFactory->EndChildren(NULL, fEmpty, *ppNodes);
            break;
            default:
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %S() failed for invalid typeID in PCM Record", __FUNCTION__);

                hr = E_UNEXPECTED;
            break;
        }// end of switch
        if ( FAILED(hr))
            goto Exit;


    } // end of for

    hr = Close();
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:

    if (pXMLData)
    {
        FUSION_DELETE_ARRAY(pXMLData);
        pXMLData = NULL;
    }

    if (ppNodes)
    {
        FUSION_DELETE_ARRAY(ppNodes);
        ppNodes = NULL;
    }

    return hr;
}

// helper functions
HRESULT
CPrecompiledManifestReader::ReadPCMHeader(PCMHeader* pHeader)
{
    HRESULT hr = NOERROR;

    if ( ! pHeader )
        return E_INVALIDARG;

    ASSERT(m_lpMapAddress);

    hr = this->Read((PVOID)pHeader, sizeof(PCMHeader), NULL);
    if ( FAILED(hr))
        goto Exit;

    if ( pHeader->iVersion != 1 ){ // wrong file header, stop
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Wrong Version of Precompiled manifest file in %S()\n", __FUNCTION__);

        hr = E_UNEXPECTED;
        goto Exit;
    }
    hr = NOERROR;

Exit:
    return hr;
}

HRESULT
CPrecompiledManifestReader::ReadPCMRecordHeader(PCM_RecordHeader * pHeader)
{
    HRESULT hr = NOERROR;
    if (!pHeader)
        return E_INVALIDARG;

    ASSERT(m_lpMapAddress);
    return this->Read((PVOID)pHeader, sizeof(PCM_RecordHeader), NULL);
}

inline void FromPCMXMLNodeToXMLNode(XML_NODE_INFO * pNode, PCM_XML_NODE_INFO * pPCMNode)
{
    ASSERT(pNode && pPCMNode);

    pNode->dwSize       = pPCMNode->dwSize;
    pNode->dwType       = pPCMNode->dwType;
    pNode->dwSubType    = pPCMNode->dwSubType;
    pNode->fTerminal    = pPCMNode->fTerminal;
    pNode->ulLen        = pPCMNode->ulLen;
    pNode->ulNsPrefixLen= pPCMNode->ulNsPrefixLen;

    pNode->pwcText      = NULL;

    return;
}

HRESULT
CPrecompiledManifestReader::ReadPCMRecord(XML_NODE_INFO ** ppNodes,
        PCM_RecordHeader * pRecordHeader, PVOID param)
{
    HRESULT hr = NOERROR;
    ULONG i, strOffset;
    PVOID pData, ptr;
    PCM_XML_NODE_INFO pcmNode;

    if ( !ppNodes || !pRecordHeader)
        return E_INVALIDARG;

    // point to the data in the mapped file
    pData = (BYTE *)m_lpMapAddress + m_dwFilePointer;

    switch (pRecordHeader->typeID){
        default:
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %S() failed for invalid typeID in PCM Record", __FUNCTION__);

            hr = E_UNEXPECTED;
            goto Exit;
        break;
        case CREATENODE_PRECOMP_MANIFEST:
            memcpy(PVOID(&m_ulLineNumberFromCreateNodeRecord), (BYTE *)pData + pRecordHeader->NodeCount * sizeof(PCM_XML_NODE_INFO), sizeof(ULONG));
            break;
        case BEGINCHILDREN_PRECOMP_MANIFEST:
            break;
        case ENDCHILDREN_PRECOMP_MANIFEST :
            ASSERT(param);
            memcpy(param, (BYTE *)pData + pRecordHeader->NodeCount * sizeof(PCM_XML_NODE_INFO), sizeof(BOOL));
            break;
    } // end of switch

    ptr = pData;
    for (i=0; i< pRecordHeader->NodeCount; i++) {
        //memcpy((PVOID)ppNodes[i], ptr, sizeof(PCM_XML_NODE_INFO));
        memcpy((PVOID)&pcmNode, ptr, sizeof(PCM_XML_NODE_INFO));
        FromPCMXMLNodeToXMLNode(ppNodes[i], &pcmNode); // void func

        // reset pwcText
        strOffset=pcmNode.offset;
        ppNodes[i]->pwcText = (WCHAR*)((BYTE *)pData + strOffset);

        ppNodes[i]->pNode = NULL;
        ppNodes[i]->pReserved = NULL;
        ptr = (BYTE *)ptr + sizeof(PCM_XML_NODE_INFO);
    }

    // reset the pointer of file
    m_dwFilePointer += pRecordHeader->RecordSize;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CPrecompiledManifestReader::Close()
{
    HRESULT hr = NOERROR;

    if (m_lpMapAddress)
        if ( ! ::UnmapViewOfFile(m_lpMapAddress)) {
            // continue the close process even hr is not NOERROR
            hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        }

    if (m_hFileMapping != INVALID_HANDLE_VALUE)
        if ( ! ::CloseHandle(m_hFileMapping)) {
            // UnmapViewOfFile is done successfully
            if ( hr == NOERROR )
                hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        }

    if (m_hFile != INVALID_HANDLE_VALUE)
        if ( ! ::CloseHandle(m_hFile)) {
            // UnmapViewOfFile and CloseHandle(filemapping) is done successfully
            if ( hr == NOERROR )
                hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        }

    if ( FAILED(hr))
        goto Exit;

    this->Reset();

    hr = NOERROR;
Exit:
    return hr;
}

VOID CPrecompiledManifestReader::Reset()
{
    m_lpMapAddress = NULL;
    m_hFileMapping = INVALID_HANDLE_VALUE;
    m_hFile = INVALID_HANDLE_VALUE;
    m_dwFilePointer = 0;

    return;
}

HRESULT
CPrecompiledManifestReader::OpenForRead(
    PCWSTR pszPath,
    DWORD dwShareMode,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes
    )
{
    HRESULT hr = NOERROR;

    if (pszPath == NULL)
        return E_INVALIDARG;

    if (m_hFile != INVALID_HANDLE_VALUE){
        hr = E_UNEXPECTED;
        goto Exit;
    }

    m_hFile = ::CreateFileW(
        pszPath,
        GENERIC_READ,
        dwShareMode,
        NULL,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        NULL);

    if (m_hFile == INVALID_HANDLE_VALUE){
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %S() failed; GetLastError() = %d\n", __FUNCTION__, ::FusionpGetLastWin32Error());

        hr = E_UNEXPECTED;
        goto Exit;
    }


    m_dwFileSize = GetFileSize(m_hFile, NULL);
    if ( m_dwFileSize== INVALID_FILE_SIZE ) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %S() call GetFileSize failed, GetLastError() = %d\n", __FUNCTION__, ::FusionpGetLastWin32Error());

        hr = E_UNEXPECTED;
        goto Exit;
    }

    // open filemapping
    ASSERT(m_hFileMapping == INVALID_HANDLE_VALUE);
    if (m_hFileMapping != INVALID_HANDLE_VALUE){
        hr = E_UNEXPECTED;
        goto Exit;
    }

    m_hFileMapping = ::CreateFileMappingW(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (m_hFileMapping == INVALID_HANDLE_VALUE){
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    // map view of file
    ASSERT(m_lpMapAddress == NULL);
    if ( m_lpMapAddress ) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    m_lpMapAddress = MapViewOfFile(m_hFileMapping, FILE_MAP_READ, 0, 0, 0); // mpa the whole file
    if (!m_lpMapAddress) {
        hr = E_FAIL;
        goto Exit;
    }

    hr = NOERROR;
Exit:
    if ( FAILED(hr))
        Close();

    return hr;
}
// IStream methods:
HRESULT
CPrecompiledManifestReader::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    DWORD dwData;
    ULONG cbRead;

    if (pcbRead)
        *pcbRead = 0;

    if (!pv)
        return E_INVALIDARG;

    if ( m_dwFilePointer >= m_dwFileSize )  // read at the file end
        return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

    dwData = m_dwFileSize - m_dwFilePointer;

    cbRead = (cb <= dwData) ? cb : dwData;
    memcpy(pv, (BYTE *)m_lpMapAddress + m_dwFilePointer, cbRead);

    m_dwFilePointer += cbRead;

    if (pcbRead)
        *pcbRead = cbRead;

    return NOERROR;
}
HRESULT
CPrecompiledManifestReader::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    if (pcbWritten)
        *pcbWritten = 0;

    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    if (plibNewPosition)
        plibNewPosition->QuadPart = 0;

    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::SetSize(ULARGE_INTEGER libNewSize)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    if (pcbWritten)
        pcbWritten->QuadPart = 0;

    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Commit(DWORD grfCommitFlags)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Revert()
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Clone(IStream **ppIStream)
{
    if ( ppIStream )
        *ppIStream = NULL;
    ASSERT(FALSE);
    return E_NOTIMPL;
}

// IXMLNodeSource methods, only GetLineNumber are implemented got PCM purpose
HRESULT
CPrecompiledManifestReader::SetFactory(IXMLNodeFactory *pNodeFactory)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::GetFactory(IXMLNodeFactory** ppNodeFactory)
{
    if (ppNodeFactory)
        *ppNodeFactory = NULL;
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Abort(BSTR bstrErrorInfo)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
ULONG
CPrecompiledManifestReader::GetLineNumber(void)
{
    ASSERT(m_ulLineNumberFromCreateNodeRecord != (ULONG)-1);
    ULONG tmp = m_ulLineNumberFromCreateNodeRecord;
    // do not reset it to be (-1) because the caller may call this function more than once
    //m_ulLineNumberFromCreateNodeRecord = (ULONG)-1;
    return tmp;
}
ULONG
CPrecompiledManifestReader::GetLinePosition(void)
{
    ASSERT(FALSE);
    return ULONG(-1);
}
ULONG
CPrecompiledManifestReader::GetAbsolutePosition(void)
{
    ASSERT(FALSE);
    return ULONG(-1);
}
HRESULT
CPrecompiledManifestReader::GetLineBuffer(const WCHAR  **ppwcBuf, ULONG  *pulLen, ULONG  *pulStartPos)
{
    if (ppwcBuf)
        *ppwcBuf = NULL;
    if (pulLen)
        * pulLen = 0;
    if (pulStartPos)
        *pulStartPos = NULL;

    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::GetLastError(void)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::GetErrorInfo(BSTR  *pbstrErrorInfo)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
ULONG
CPrecompiledManifestReader::GetFlags()
{
    ASSERT(FALSE);
    return ULONG(-1);
}
HRESULT
CPrecompiledManifestReader::GetURL(const WCHAR  **ppwcBuf)
{
    if (ppwcBuf)
        *ppwcBuf = NULL;

    ASSERT(FALSE);
    return E_NOTIMPL;
}

// IUnknown method implementation
ULONG
CPrecompiledManifestReader::AddRef()
{
    ULONG ulResult = ::InterlockedIncrement((LONG *) &m_cRef);
    return ulResult;
}

ULONG
CPrecompiledManifestReader::Release()
{
    ULONG ulResult = ::InterlockedDecrement((LONG *) &m_cRef);
    if (ulResult == 0 )
    {
        FUSION_DELETE_SINGLETON(this);
    }
    return ulResult;
}

HRESULT
CPrecompiledManifestReader::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = NOERROR;
    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL){
        hr = E_POINTER;
        goto Exit;
    }

    if (riid == __uuidof(this))
        *ppvObj = this;
    else if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        pIUnknown = static_cast<IStream *>(this);
    else if ( riid == IID_IXMLNodeSource )
        pIUnknown = static_cast<IXMLNodeSource *>(this);
    else
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    AddRef();
    if (pIUnknown != NULL)
        *ppvObj = pIUnknown;

    hr = NOERROR;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pcmwriterstream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pcmWriterStream.cpp

Abstract:
    implementation of a filestream for Precompiled manifest writer

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/

#include "stdinc.h"
#include "pcm.h"
#include "pcmWriterStream.h"

HRESULT CPrecompiledManifestWriterStream::WriteWithDelay(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr=NOERROR;

    if (pcbWritten)
        *pcbWritten = 0 ;

    if (m_fBuffer)
    {
        if (FAILED(hr = m_buffer.Append(reinterpret_cast<const BYTE*>(pv), cb)))
            goto Exit;
        if ( pcbWritten)
            *pcbWritten = cb;
    }
    else
    {
        DWORD dwBytesWritten = 0;

        ASSERT(m_hFile != INVALID_HANDLE_VALUE);

        BOOL fSuccess = (cb == 0) || WriteFile(m_hFile, pv, cb, &dwBytesWritten, NULL);
        if (!fSuccess)
            hr = FusionpHresultFromLastError();
        else if (dwBytesWritten != cb)
            hr = E_FAIL;
        if ( pcbWritten)
            *pcbWritten = dwBytesWritten;
    }

    hr = NOERROR;
Exit:
    return hr;

}

BOOL
CPrecompiledManifestWriterStream::SetSink(
    const CBaseStringBuffer &rbuff,
    DWORD   openOrCreate
    )
{
    BOOL fSuccess = FALSE;
    DWORD dwBytesWritten = 0;
    DWORD dwBufferSize = 0;

    //
    // NTRAID#NTBUG9-164736-2000/8/17-a-JayK share should be 0
    //
    if (!Base::OpenForWrite(rbuff, FILE_SHARE_WRITE, openOrCreate))
        goto Exit;

    dwBufferSize = static_cast<DWORD>(m_buffer.GetCurrentCb());
    fSuccess = TRUE;
    if (dwBufferSize > 0){
        ASSERT ( m_hFile != INVALID_HANDLE_VALUE );
        fSuccess = WriteFile(m_hFile, m_buffer, dwBufferSize, &dwBytesWritten, NULL/*overlapped*/);

        if (fSuccess && dwBytesWritten != dwBufferSize){
            ::FusionpSetLastWin32Error(ERROR_WRITE_FAULT);
            fSuccess = FALSE;
        }
    }
    m_fBuffer = FALSE;

Exit:
    if (!fSuccess){
        DWORD dwLastError = ::FusionpGetLastWin32Error();
        m_buffer.Clear(true);
        ::FusionpSetLastWin32Error(dwLastError);
    }
    else
        m_buffer.Clear(true);

    return fSuccess;
}

//besides close, rewrite MaxNodeCount, RecordCount into the header of the file
HRESULT CPrecompiledManifestWriterStream::Close(ULONG ulRecordCount, DWORD dwMaxNodeCount)
{
    HRESULT hr = NOERROR;
    LARGE_INTEGER liMove ;

    ASSERT(m_hFile != INVALID_HANDLE_VALUE);

    // write RecordCount;
    liMove.LowPart = offsetof(PCMHeader, ulRecordCount);
    liMove.HighPart = 0 ;

    hr = Base::Seek(liMove, FILE_BEGIN, NULL);
    if ( FAILED(hr))
        goto Exit;

    hr = WriteWithDelay((PVOID)&ulRecordCount, sizeof(ULONG), NULL);
    if ( FAILED(hr))
        goto Exit;

    // write MaxNodeCount;
    liMove.LowPart = offsetof(PCMHeader, usMaxNodeCount);
    liMove.HighPart = 0 ;

    hr = Base::Seek(liMove, FILE_BEGIN, NULL);
    if ( FAILED(hr))
        goto Exit;

    hr = WriteWithDelay((PVOID)&dwMaxNodeCount, sizeof(ULONG), NULL);
    if ( FAILED(hr))
        goto Exit;

    if ( ! Base::Close()) {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;

}

BOOL CPrecompiledManifestWriterStream::IsSinkedStream()
{
    if ((m_fBuffer == FALSE) && (m_hFile != INVALID_HANDLE_VALUE))
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pcmtestfactory.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pcmtestfactory.h

Abstract:
    definition of a nodefactory for Precompiled manifest testing

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/
#pragma once

#include <stdio.h>
#include <windows.h>
#include <ole2.h>
#include <xmlparser.h>
#include "simplefp.h"

class __declspec(uuid("79fd77ad-f467-44ad-8cf9-2f259eeb3878"))
PCMTestFactory : public IXMLNodeFactory
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IXMLNodeFactory
    STDMETHODIMP NotifyEvent(IXMLNodeSource __RPC_FAR *pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHODIMP BeginChildren(IXMLNodeSource __RPC_FAR *pSource, XML_NODE_INFO* __RPC_FAR pNodeInfo);
    STDMETHODIMP EndChildren(IXMLNodeSource __RPC_FAR *pSource, BOOL fEmptyNode, XML_NODE_INFO* __RPC_FAR pNodeInfo);
    STDMETHODIMP Error(IXMLNodeSource __RPC_FAR *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
    {
        return hrErrorCode;
    }
    STDMETHODIMP CreateNode(IXMLNodeSource __RPC_FAR *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

    PCMTestFactory(PCSTR pFileName= NULL) : m_cRef(0)
    {
        m_pFileStream = new CSimpleFileStream(pFileName);
    }

    ~PCMTestFactory(){
        CSxsPreserveLastError ple;
        ASSERT(m_cRef == 0);
        if (m_pFileStream)
            FUSION_DELETE_SINGLETON(m_pFileStream);

        ple.Restore();
    }

private :
    VOID PrintSingleXMLNode(XML_NODE_INFO * pNode);
    VOID PrintXMLNodeType(DWORD dwType);

    ULONG                   m_cRef;
    CSimpleFileStream* m_pFileStream;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pcm.h ===
/*++                                                                                                          /*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pcm.h

Abstract:
    Define common data structure for precompiled-manifest Writer and Reader
    and class definition of PrecompiledManifetWriter and
    PrecompiledManifestReader

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_PCM_H_INCLUDED_)
#define _FUSION_SXS_PCM_H_INCLUDED_

#pragma once

#include "stdinc.h"
#include <ole2.h>
#include <xmlparser.h>
#include "nodefactory.h"
#include "pcmWriterStream.h"

// pcm structure shared between PCMWriter and PCMReader
typedef enum _RECORD_TYPE_PRECOMP_MANIFEST{
    CREATENODE_PRECOMP_MANIFEST     = 1,
    BEGINCHILDREN_PRECOMP_MANIFEST  = CREATENODE_PRECOMP_MANIFEST + 1,
    ENDCHILDREN_PRECOMP_MANIFEST    = BEGINCHILDREN_PRECOMP_MANIFEST + 1
} RECORD_TYPE_PRECOMP_MANIFEST;

typedef struct _PCM_Header{
    int     iVersion;
    ULONG   ulRecordCount;
    USHORT  usMaxNodeCount;
}PCMHeader;

typedef struct _PCM_RecordHeader{
    int     typeID ;
    ULONG   RecordSize;
    ULONG   NodeCount;
}PCM_RecordHeader;

typedef struct _PCM_XML_NODE_INFO{
    DWORD           dwSize;
    DWORD           dwType;
    DWORD           dwSubType;
    BOOL            fTerminal;
    ULONG           offset;
    ULONG           ulLen;
    ULONG           ulNsPrefixLen;
}PCM_XML_NODE_INFO;

class __declspec(uuid("6745d578-5d84-4890-aa6a-bd794ea50421"))
CPrecompiledManifestReader : public IXMLNodeSource, public IStream {
public :
    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // IXMLNodeSource methods, only GetLineNumber is implemented got PCM purpose
    STDMETHODIMP SetFactory(IXMLNodeFactory __RPC_FAR *pNodeFactory);
    STDMETHODIMP GetFactory(IXMLNodeFactory** ppNodeFactory);
    STDMETHODIMP Abort(BSTR bstrErrorInfo);
    STDMETHODIMP_(ULONG) GetLineNumber(void);
    STDMETHODIMP_(ULONG) GetLinePosition(void);
    STDMETHODIMP_(ULONG) GetAbsolutePosition(void);
    STDMETHODIMP GetLineBuffer(const WCHAR  **ppwcBuf, ULONG  *pulLen, ULONG  *pulStartPos);
    STDMETHODIMP GetLastError(void);
    STDMETHODIMP GetErrorInfo(BSTR  *pbstrErrorInfo);
    STDMETHODIMP_(ULONG) GetFlags();
    STDMETHODIMP GetURL(const WCHAR  **ppwcBuf);

    // IStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);


    CPrecompiledManifestReader():m_hFile(INVALID_HANDLE_VALUE),
                            m_hFileMapping(INVALID_HANDLE_VALUE), m_lpMapAddress(NULL),
                            m_ulLineNumberFromCreateNodeRecord(ULONG(-1)),
                            m_dwFilePointer(0), m_dwFileSize(0),
                            m_cRef(0) { }

    ~CPrecompiledManifestReader() { CSxsPreserveLastError ple; this->Close(); ple.Restore(); }

    HRESULT InvokeNodeFactory(PCWSTR pcmFileName, IXMLNodeFactory *pNodeFactory);
    VOID Reset();

protected:
    HANDLE                  m_hFile;
    HANDLE                  m_hFileMapping;
    LPVOID                  m_lpMapAddress;
    ULONG                   m_ulLineNumberFromCreateNodeRecord;
    DWORD                   m_dwFilePointer; // should we limit the size of pcm file? Since manifest file is not very huge...
    DWORD                   m_dwFileSize;

    ULONG                   m_cRef;

    HRESULT Close(
        );

    HRESULT OpenForRead(
        IN PCWSTR pszPCMFileName,
        IN DWORD dwShareMode = FILE_SHARE_READ,                        // share mode
        IN DWORD dwCreationDisposition = OPEN_EXISTING,                // how to create
        IN DWORD dwFlagsAndAttributes = FILE_FLAG_SEQUENTIAL_SCAN      // file attributes
        );

    HRESULT ReadPCMHeader(
        OUT PCMHeader* pHeader
        );
    HRESULT ReadPCMRecordHeader(
        OUT PCM_RecordHeader * pHeader
        );

    HRESULT ReadPCMRecord(
        OUT XML_NODE_INFO ** ppNodes,
        OUT PCM_RecordHeader * pRecordHeader,
        OUT PVOID param
        );
};

class __declspec(uuid("1b345c93-eb16-4d07-b366-81e8a2b88414"))
CPrecompiledManifestWriter : public IXMLNodeFactory {
public :
    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // IXMLNodeFactory methods:
    STDMETHODIMP NotifyEvent(IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHODIMP BeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP EndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP Error(IXMLNodeSource *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);
    STDMETHODIMP CreateNode(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);

    // constructor and destructor
    CPrecompiledManifestWriter() : m_cRef(0), m_ulRecordCount(0), m_usMaxNodeCount(0) { }

    ~CPrecompiledManifestWriter() { }

    // write APIs

    HRESULT Initialize(
        PACTCTXGENCTX ActCtxGenCtx,
        PASSEMBLY Assembly,
        PACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext);

    HRESULT SetWriterStream(CPrecompiledManifestWriterStream * pSinkedStream); // usually, filename of PCM is not available when
                                                             // the stream is opened. and stream is inited by caller
    HRESULT Initialize(PCWSTR pcmFileName);
    HRESULT WritePrecompiledManifestRecord(
        IN RECORD_TYPE_PRECOMP_MANIFEST typeID,
        IN PVOID    pData,
        IN USHORT   NodeCount,
        IN PVOID    param = NULL
        );
    HRESULT SetFactory(IXMLNodeFactory *pNodeFactory);
    HRESULT Close();

protected:
    CSmartRef<IXMLNodeFactory>          m_pNodeFactory;
    CSmartRef<CPrecompiledManifestWriterStream> m_pFileStream;
    ULONG                               m_ulRecordCount;
    USHORT                              m_usMaxNodeCount;
    ULONG                               m_cRef;

    HRESULT GetPCMRecordSize(
        IN XML_NODE_INFO ** ppNodeInfo,
        IN USHORT iNodeCount,
        IN ULONG * pSize
        );

    HRESULT WritePCMHeader( // version is forced to be 1, and the recordCount is forced to be 0;
        );

    HRESULT WritePCMRecordHeader(
        IN PCM_RecordHeader * pHeader
        );

    HRESULT WritePCMXmlNodeInfo(
        IN XML_NODE_INFO ** ppNodeInfo,
        IN USHORT iNodeCount,
        IN RECORD_TYPE_PRECOMP_MANIFEST typeID,
        IN PVOID param
        );
};

#endif // _FUSION_SXS_PRECOMPILED_MANIFEST_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pendingassembly.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pendingassembly.cpp

Abstract:

    Sources for the CPendingAssembly class

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    xiaoyuw     09/2000         replace attributes with assembly identity
--*/

#include "stdinc.h"
#include "pendingassembly.h"

CPendingAssembly::CPendingAssembly() :
    m_SourceAssembly(NULL),
    m_Identity(NULL),
    m_Optional(false),
    m_MetadataSatellite(false)
{
}

CPendingAssembly::~CPendingAssembly()
{
    if (m_Identity != NULL)
    {
        ::SxsDestroyAssemblyIdentity(m_Identity);
        m_Identity = NULL;
    }
}

BOOL
CPendingAssembly::Initialize(
    PASSEMBLY Assembly,
    PCASSEMBLY_IDENTITY Identity,
    bool Optional,
    bool MetadataSatellite
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_Identity == NULL);

    PARAMETER_CHECK(Identity != NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, Identity, &m_Identity));
    m_SourceAssembly = Assembly;
    m_Optional = Optional;
    m_MetadataSatellite = MetadataSatellite;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pcmwriterstream.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CPrecompiledManifestWriterStream.h

Abstract:
    Like a CFileStream (its base) but also implements Commit over
      associated PCMWriter. This functionality was
      moved out of CFileStream.

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_PCMWriterStream_H_INCLUDED_)
#define _FUSION_SXS_PCMWriterStream_H_INCLUDED_
#pragma once

#include "stdinc.h"
#include "FileStream.h"
#include "SmartRef.h"

class CPrecompiledManifestWriterStream : public CReferenceCountedFileStream
//class CPrecompiledManifestWriterStream : public CFileStreamBase // not delete 
{
private:
    typedef CReferenceCountedFileStream Base;
    //typedef CFileStreamBase Base;

public:
    CPrecompiledManifestWriterStream() : Base(), m_fBuffer(TRUE) { }
    ~CPrecompiledManifestWriterStream() {}

    HRESULT     WriteWithDelay(void const *pv, ULONG cb, ULONG *pcbWritten);

    // NTRAID#NTBUG9-164736-2000/8/17-a-JayK openOrCreate should probably default
    // default to safer CREATE_NEW but I'm preserving existing behavior where
    // it doesn't hurt me.
    BOOL        SetSink(const CBaseStringBuffer &rbuff, DWORD openOrCreate = CREATE_ALWAYS);
    HRESULT     Close(ULONG, DWORD);     //besides close, rewrite MaxNodeCount, RecordCount into the header of the file
    BOOL        IsSinkedStream(void);

protected:
    CByteBuffer         m_buffer;
    BOOL                m_fBuffer;

private:
    CPrecompiledManifestWriterStream(const CPrecompiledManifestWriterStream &);
    void operator =(const CPrecompiledManifestWriterStream &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\preprocessor.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Preprocessor.h

Abstract:

    Standard C/C++ Preprocessor magic.

Author:

    Jay Krell (a-JayK) December 2000

Environment:


Revision History:

--*/
#pragma once

#define PASTE_(x,y) x##y
#define PASTE(x,y)  PASTE_(x,y)

#define STRINGIZE_(x) # x
#define STRINGIZE(x) STRINGIZE_(x)
#define STRINGIZEW(x) PASTE(L, STRINGIZE_(x))

/* Visual C++ extension, rarely needed, useful in preprocessing .rgs files */
#define CHARIZE_(x) #@ x
#define CHARIZE(x) CHARIZE_(x)
#define CHARIZEW(x) PASTE(L, CHARIZE_(x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\policystatement.cpp ===
#include "stdinc.h"
#include "fusionparser.h"
#include "policystatement.h"
#include "sxsid.h"

BOOL
CPolicyStatementRedirect::Initialize(
    const CBaseStringBuffer &rbuffFromVersionRange,
    const CBaseStringBuffer &rbuffToVersion,
    bool &rfValid
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PCWSTR pszDash;
    CStringBuffer buffTemp;
    ASSEMBLY_VERSION avFromMin = { 0 };
    ASSEMBLY_VERSION avFromMax = { 0 };
    ASSEMBLY_VERSION avTo = { 0 };
    bool fValid;

    rfValid = false;

    INTERNAL_ERROR_CHECK(rbuffToVersion.Cch() < NUMBER_OF(m_rgwchNewVersion));

    // let's see if we have a singleton or a range...
    pszDash = wcschr(rbuffFromVersionRange, L'-');

    if (pszDash == NULL)
    {
        // It must be a singleton.  Parse it.
        IFW32FALSE_EXIT(CFusionParser::ParseVersion(avFromMin, rbuffFromVersionRange, rbuffFromVersionRange.Cch(), fValid));

        if (fValid)
            avFromMax = avFromMin;
    }
    else
    {
        SIZE_T cchFirstSegment = static_cast<SIZE_T>(pszDash - rbuffFromVersionRange);

        IFW32FALSE_EXIT(CFusionParser::ParseVersion(avFromMin, rbuffFromVersionRange, cchFirstSegment, fValid));

        if (fValid)
        {
            IFW32FALSE_EXIT(CFusionParser::ParseVersion(avFromMax, pszDash + 1, rbuffFromVersionRange.Cch() - (cchFirstSegment + 1), fValid));

            if (avFromMin > avFromMax)
                fValid = false;
        }
    }

    if (fValid)
        IFW32FALSE_EXIT(CFusionParser::ParseVersion(avTo, rbuffToVersion, rbuffToVersion.Cch(), fValid));

    if (fValid)
    {
        // Everything parsed OK.  We keep the binary/numeric form of the from range so that we can do
        // fast comparisons, but we keep the string of the to version because assembly identity attributes
        // are stored as strings.

        m_cchNewVersion = rbuffToVersion.Cch();
        memcpy(m_rgwchNewVersion, static_cast<PCWSTR>(rbuffToVersion), (rbuffToVersion.Cch() + 1) * sizeof(WCHAR));

        m_avFromMin = avFromMin;
        m_avFromMax = avFromMax;

        rfValid = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CPolicyStatementRedirect::TryMap(
    const ASSEMBLY_VERSION &rav,
    SIZE_T cchBuffer,
    PWSTR pBuffer,
    SIZE_T &rcchWritten,
    bool &rfMapped
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    rfMapped = false;
    rcchWritten = 0;

    if ((rav >= m_avFromMin) &&
        (rav <= m_avFromMax))
    {
        if ((m_cchNewVersion + 1) > cchBuffer)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(BufferTooSmall, ERROR_INSUFFICIENT_BUFFER);

        memcpy(pBuffer, m_rgwchNewVersion, (m_cchNewVersion + 1) * sizeof(WCHAR));
        rcchWritten = m_cchNewVersion;

        rfMapped = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CPolicyStatementRedirect::CheckForOverlap(
    const CPolicyStatementRedirect &rRedirect,
    bool &rfOverlaps
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    rfOverlaps = false;

    // we can assume that the other redirect is well formed (min <= max)

    if (((rRedirect.m_avFromMax >= m_avFromMin) &&
         (rRedirect.m_avFromMax <= m_avFromMax)) ||
        ((rRedirect.m_avFromMin <= m_avFromMax) &&
         (rRedirect.m_avFromMin >= m_avFromMin)))
    {
        rfOverlaps = true;
    }

    fSuccess = TRUE;
// Exit:
    return fSuccess;
}

//
//  Implementation of CPolicyStatement
//

BOOL
CPolicyStatement::Initialize()
{
    return TRUE;
}

BOOL
CPolicyStatement::AddRedirect(
    const CBaseStringBuffer &rbuffFromVersion,
    const CBaseStringBuffer &rbuffToVersion,
    bool &rfValid
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CPolicyStatementRedirect *Redirect = NULL;
    CDequeIterator<CPolicyStatementRedirect, FIELD_OFFSET(CPolicyStatementRedirect, m_leLinks)> iter;
    bool fOverlaps;
    bool fValid = false;

    rfValid = false;

    IFALLOCFAILED_EXIT(Redirect = new CPolicyStatementRedirect);

    IFW32FALSE_EXIT(Redirect->Initialize(rbuffFromVersion, rbuffToVersion, fValid));

    if (fValid)
    {
        iter.Rebind(&m_Redirects);

        for (iter.Reset(); iter.More(); iter.Next())
        {
            IFW32FALSE_EXIT(iter->CheckForOverlap(*Redirect, fOverlaps));

            if (fOverlaps)
            {
                fValid = false;
                break;
            }
        }

        iter.Unbind();
    }

    if (fValid)
    {
        // Looks good; add it!

        m_Redirects.AddToTail(Redirect);
        Redirect = NULL;

        rfValid = true;
    }

    fSuccess = TRUE;
Exit:
    if (Redirect != NULL)
        FUSION_DELETE_SINGLETON(Redirect);

    return fSuccess;
}

BOOL
CPolicyStatement::ApplyPolicy(
    PASSEMBLY_IDENTITY AssemblyIdentity,
    bool &rfPolicyApplied
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR Version = NULL;
    SIZE_T VersionCch = 0;
    WCHAR rgwchVersionBuffer[(4 * 5) + (3 * 1) + 1];
    SIZE_T cchWritten = 0;
    CDequeIterator<CPolicyStatementRedirect, FIELD_OFFSET(CPolicyStatementRedirect, m_leLinks)> iter;
    ASSEMBLY_VERSION av;
    bool fSyntaxValid;
    bool fMapped = false;

    rfPolicyApplied = false;

    PARAMETER_CHECK(AssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            0,
            AssemblyIdentity,
            &s_IdentityAttribute_version,
            &Version,
            &VersionCch));

    IFW32FALSE_EXIT(CFusionParser::ParseVersion(av, Version, VersionCch, fSyntaxValid));

    // An invalid version number should have been caught earlier.
    INTERNAL_ERROR_CHECK(fSyntaxValid);

    iter.Rebind(&m_Redirects);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        IFW32FALSE_EXIT(iter->TryMap(av, NUMBER_OF(rgwchVersionBuffer), rgwchVersionBuffer, cchWritten, fMapped));

        if (fMapped)
            break;
    }

    if (fMapped)
    {
        IFW32FALSE_EXIT(
            ::SxspSetAssemblyIdentityAttributeValue(
                SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                AssemblyIdentity,
                &s_IdentityAttribute_version,
                rgwchVersionBuffer,
                cchWritten));

        rfPolicyApplied = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\probedassemblyinformation.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    probedassemblyinformation.cpp

Abstract:

    Class that contains all the relevant information about an assembly
    that has been found in the assembly store.

Author:

    Michael J. Grier (MGrier) 11-May-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "probedassemblyinformation.h"
#include "fusionparser.h"

#define POLICY_FILE_EXTENSION L".policy"

#define IS_NT_DOS_PATH(_x) (((_x)[0] == L'\\') && ((_x)[1] == L'?') && ((_x)[2] == L'?') && \
    ((_x)[3] == '\\'))

CProbedAssemblyInformation::~CProbedAssemblyInformation()
{
}

BOOL
CProbedAssemblyInformation::Initialize()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(m_OriginalReference.Initialize());
    IFW32FALSE_EXIT(m_CheckpointedReference.Initialize());
    IFW32FALSE_EXIT(Base::Initialize());
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::Initialize(
    const CAssemblyReference &r
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(m_OriginalReference.Initialize(r));
    IFW32FALSE_EXIT(m_CheckpointedReference.Initialize());
    IFW32FALSE_EXIT(Base::Initialize(r));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

// "copy initializer"
BOOL
CProbedAssemblyInformation::Initialize(
    const CProbedAssemblyInformation &r
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(this->Initialize());
    IFW32FALSE_EXIT(this->Assign(r));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::SetOriginalReference(
    const CAssemblyReference &r,
    bool fCopySpecifiedFieldsFromOriginal
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CStringBuffer OriginalAssemblyName;

    if (fCopySpecifiedFieldsFromOriginal)
    {
        PCWSTR OldName;
        SIZE_T OldCch;

        IFW32FALSE_EXIT(r.GetAssemblyName(&OldName, &OldCch));
        IFW32FALSE_EXIT(OriginalAssemblyName.Win32Assign(OldName, OldCch));
    }

    IFW32FALSE_EXIT(m_OriginalReference.Assign(r));

    // nothing that can fail should appear below here in this function

    m_ManifestPathBuffer.Clear();

    if (fCopySpecifiedFieldsFromOriginal)
    {
        //
        // Caution - this scorches the original assembly information, but it
        // looks like in semantics of this function, that's what we want to
        // do.
        //
        if (m_pAssemblyIdentity != NULL)
        {
            ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
            m_pAssemblyIdentity = NULL;
        }

        IFW32FALSE_EXIT(
            ::SxsDuplicateAssemblyIdentity(
                0,
                r.GetAssemblyIdentity(),
                &m_pAssemblyIdentity));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::ResetProbedToOriginal()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    IFW32FALSE_EXIT(Base::Assign(m_OriginalReference));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
CProbedAssemblyInformation::Assign(
    const CProbedAssemblyInformation &r
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(Base::Assign(r));

    // manifest
    IFW32FALSE_EXIT(m_ManifestPathBuffer.Win32Assign(r.m_ManifestPathBuffer));
    m_ManifestPathType = r.m_ManifestPathType;
    m_ManifestLastWriteTime = r.m_ManifestLastWriteTime;
    m_ManifestStream = r.m_ManifestStream;
    m_ManifestFlags = r.m_ManifestFlags;

    // policy
    IFW32FALSE_EXIT(m_PolicyPathBuffer.Win32Assign(r.m_PolicyPathBuffer));
    m_PolicyPathType = r.m_PolicyPathType;
    m_PolicyLastWriteTime = r.m_PolicyLastWriteTime;
    m_PolicyStream = r.m_PolicyStream;
    m_PolicyFlags = r.m_PolicyFlags;
    m_PolicySource = r.m_PolicySource;

    IFW32FALSE_EXIT(m_OriginalReference.Assign(r.m_OriginalReference));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::SetPolicyPath(
    ULONG PathType,
    PCWSTR  Path,
    SIZE_T PathCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PARAMETER_CHECK(PathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    IFW32FALSE_EXIT(m_PolicyPathBuffer.Win32Assign(Path, PathCch));
    m_PolicyPathType = PathType;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::SetManifestPath(
    ULONG PathType,
    const CBaseStringBuffer &rbuff
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PARAMETER_CHECK(PathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    IFW32FALSE_EXIT(this->SetManifestPath(PathType, rbuff, rbuff.Cch()));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::SetManifestPath(
    ULONG PathType,
    PCWSTR path,
    SIZE_T path_t
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PARAMETER_CHECK(PathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    IFW32FALSE_EXIT(m_ManifestPathBuffer.Win32Assign(path, path_t));
    m_ManifestPathType = PathType;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::ProbeManifestExistence(
    const CImpersonationData &ImpersonationData,
    bool &rfManifestExistsOut
    ) const
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    WIN32_FILE_ATTRIBUTE_DATA wfad;
    CImpersonate impersonate(ImpersonationData);
    bool ManifestExistsTemp = false; // used to hold eventual value to pass out
    bool fNotFound = false;

    rfManifestExistsOut = false;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    //
    // if we have a stream that implements Stat, use that
    // also, if we have a nonzero time and the stream doesn't implement Stat,
    // just stick with the nonzero time we already have
    //
    if (m_ManifestStream != NULL)
    {
        ManifestExistsTemp = true;
    }
    else
    {
        PCWSTR ManifestPath = m_ManifestPathBuffer;
        PARAMETER_CHECK(IS_NT_DOS_PATH(ManifestPath) == FALSE);

        IFW32FALSE_EXIT(impersonate.Impersonate());
        IFW32FALSE_EXIT_UNLESS2(
            ::GetFileAttributesExW(m_ManifestPathBuffer, GetFileExInfoStandard, &wfad),
            LIST_2(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND),
            fNotFound);

        if (!fNotFound)
            ManifestExistsTemp = true;

        IFW32FALSE_EXIT(impersonate.Unimpersonate());
    }

    rfManifestExistsOut = ManifestExistsTemp;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::SetManifestLastWriteTime(
    PACTCTXGENCTX pActCtxGenCtx,
    BOOL fDuringBindingAndProbingPrivateManifest)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    WIN32_FILE_ATTRIBUTE_DATA wfad;
    CImpersonate impersonate(pActCtxGenCtx->m_ImpersonationData);
    PCWSTR ManifestPath = m_ManifestPathBuffer;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    PARAMETER_CHECK(!IS_NT_DOS_PATH(ManifestPath));

    //
    // if we have a stream that implements Stat, use that
    // also, if we have a nonzero time and the stream doesn't implement Stat,
    // just stick with the nonzero time we already have
    //
    if (m_ManifestStream != NULL)
    {
        STATSTG stat;
        HRESULT hr;

        hr = m_ManifestStream->Stat(&stat, STATFLAG_NONAME);
        if (hr == E_NOTIMPL && m_ManifestLastWriteTime != 0)
        {
            fSuccess = TRUE;
            goto Exit;
        }
        if (hr != E_NOTIMPL)
        {
            IFCOMFAILED_EXIT(hr);
            m_ManifestLastWriteTime = stat.mtime;
            fSuccess = TRUE;
            goto Exit;
        }
    }

    IFW32FALSE_EXIT(impersonate.Impersonate());

    PARAMETER_CHECK(IS_NT_DOS_PATH(ManifestPath) == FALSE);

    BOOL   CrossesReparsePoint;

    if (fDuringBindingAndProbingPrivateManifest)
    {
        //check whether there is a reparse point cross the path
        CrossesReparsePoint = FALSE;
        IFW32FALSE_EXIT(
            ::SxspDoesPathCrossReparsePoint(
                pActCtxGenCtx->m_ApplicationDirectoryBuffer,
                pActCtxGenCtx->m_ApplicationDirectoryBuffer.Cch(),
                ManifestPath,
                wcslen(ManifestPath),
                CrossesReparsePoint));

        if (CrossesReparsePoint) // report error instead of ignore and continue
        {
            ::FusionpSetLastWin32Error(ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT);
            goto Exit;
        }
    }

    // BUGBUGBUG!
    IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileAttributesExW(ManifestPath, GetFileExInfoStandard, &wfad));
    if( wfad.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
    {
        ::FusionpSetLastWin32Error(ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT);
        goto Exit;
    }

    m_ManifestLastWriteTime = wfad.ftLastWriteTime;
    IFW32FALSE_EXIT(impersonate.Unimpersonate());

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::ProbeAssembly(
    DWORD dwFlags,
    PACTCTXGENCTX pActCtxGenCtx,
    LanguageProbeType lpt,
    bool &rfFound
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR Slash;
    ULONG index;
    BOOL fPrivateAssembly = FALSE;
    bool fManifestExists = false;
    bool fDone = false;
    ULONG ApplicationDirectoryPathType;
    DWORD dwGenerateManifestPathFlags = 0;

    rfFound = false;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    PARAMETER_CHECK((dwFlags & ~(ProbeAssembly_SkipPrivateAssemblies)) == 0);

    IFW32FALSE_EXIT(this->LookForPolicy(pActCtxGenCtx));
    IFW32FALSE_EXIT(this->LookForNDPWin32Policy(pActCtxGenCtx));

    if (pActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_INSTALL)
        dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED;

    if (dwFlags & ProbeAssembly_SkipPrivateAssemblies)
        dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_PRIVATE_ASSEMBLIES;

    ApplicationDirectoryPathType = pActCtxGenCtx->m_ApplicationDirectoryPathType;

    if ((lpt != eExplicitBind) && (lpt != eLanguageNeutral))
    {
        if (!pActCtxGenCtx->m_ApplicationDirectoryHasBeenProbedForLanguageSubdirs)
        {
            SIZE_T cch;
            CSmallStringBuffer buffTemp;

            IFW32FALSE_EXIT(buffTemp.Win32Assign(pActCtxGenCtx->m_ApplicationDirectoryBuffer));
            cch = buffTemp.Cch();

            // Ok, let's see what's there.
            IFW32FALSE_EXIT(this->ProbeLanguageDir(buffTemp, pActCtxGenCtx->m_SpecificLanguage, pActCtxGenCtx->m_ApplicationDirectoryHasSpecificLanguageSubdir));
            buffTemp.Left(cch);

            IFW32FALSE_EXIT(this->ProbeLanguageDir(buffTemp, pActCtxGenCtx->m_GenericLanguage, pActCtxGenCtx->m_ApplicationDirectoryHasGenericLanguageSubdir));
            buffTemp.Left(cch);

            IFW32FALSE_EXIT(this->ProbeLanguageDir(buffTemp, pActCtxGenCtx->m_SpecificSystemLanguage, pActCtxGenCtx->m_ApplicationDirectoryHasSpecificSystemLanguageSubdir));
            buffTemp.Left(cch);

            IFW32FALSE_EXIT(this->ProbeLanguageDir(buffTemp, pActCtxGenCtx->m_GenericSystemLanguage, pActCtxGenCtx->m_ApplicationDirectoryHasGenericSystemLanguageSubdir));

            pActCtxGenCtx->m_ApplicationDirectoryHasBeenProbedForLanguageSubdirs = true;
        }

        switch (lpt)
        {
        case eSpecificLanguage:
            if (!pActCtxGenCtx->m_ApplicationDirectoryHasSpecificLanguageSubdir)
                dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS;
            break;

        case eGenericLanguage:
            if (!pActCtxGenCtx->m_ApplicationDirectoryHasGenericLanguageSubdir)
                dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS;
            break;

        case eSpecificSystemLanguage:
            if (!pActCtxGenCtx->m_ApplicationDirectoryHasSpecificSystemLanguageSubdir)
                dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS;
            break;

        case eGenericSystemLanguage:
            if (!pActCtxGenCtx->m_ApplicationDirectoryHasGenericSystemLanguageSubdir)
                dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS;
            break;
        }
    }

    for (index=0; !fDone; index++)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateManifestPathForProbing(
                index,
                dwGenerateManifestPathFlags,
                pActCtxGenCtx->m_AssemblyRootDirectoryBuffer,
                pActCtxGenCtx->m_AssemblyRootDirectoryBuffer.Cch(),
                ApplicationDirectoryPathType,
                pActCtxGenCtx->m_ApplicationDirectoryBuffer,
                pActCtxGenCtx->m_ApplicationDirectoryBuffer.Cch(),
                m_pAssemblyIdentity,
                m_ManifestPathBuffer,
                &fPrivateAssembly,
                fDone));

        // The SxspGenerateManifestPathForProbing() call might not have generated a candidate; only probe for the manifest
        // if it makes sense.
        if (m_ManifestPathBuffer.Cch() != 0)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_PROBING,
                "SXS.DLL: Probing for manifest: %S\n", static_cast<PCWSTR>(m_ManifestPathBuffer));

            /*
            verify minimal access, and get last write time in
            case caller asked for it
            */

            IFW32FALSE_EXIT(this->ProbeManifestExistence(pActCtxGenCtx->m_ImpersonationData, fManifestExists));
            if (fManifestExists)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_PROBING,
                    "SXS.DLL: Probed manifest: %S is FOUND !!!\n", static_cast<PCWSTR>(m_ManifestPathBuffer));

                break;
            }
        }
    }

    if (fManifestExists)
    {
        CSmallStringBuffer sbFileExtension;
        m_ManifestPathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;

        IFW32FALSE_EXIT(this->SetManifestLastWriteTime(pActCtxGenCtx, fPrivateAssembly));

            // find an existed manifest-file
        Slash = wcsrchr(m_ManifestPathBuffer, L'\\');

        INTERNAL_ERROR_CHECK(Slash != NULL);

        IFW32FALSE_EXIT(m_ManifestPathBuffer.Win32GetPathExtension(sbFileExtension));

        //
        // Now that we're doing GAC probing, and assemblies in there live in DLLs, we
        // need to loosen this restriction somewhat.  If the filename ends in DLL or MUI,
        // then it's got to have its manifest in resources.  Otherwise, it's probably
        // a file - we can autodetect
        //
        if (FusionpEqualStrings(sbFileExtension, sbFileExtension.Cch(), L"DLL", 3, true) ||
            FusionpEqualStrings(sbFileExtension, sbFileExtension.Cch(), L"MUI", 3, true))
        {
            m_ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_RESOURCE;
        }
        else {
            m_ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT;
        }

        if (fPrivateAssembly) { // manifest file is found from private dirs
            m_ManifestFlags |= ASSEMBLY_PRIVATE_MANIFEST;
        }
    }

    rfFound = fManifestExists;

    fSuccess = TRUE;
Exit:

    return fSuccess;
}

#define GENERATE_NDP_PATH_NO_ROOT               (0x00000001)
#define GENERATE_NDP_PATH_WILDCARD_VERSION      (0x00000002)
#define GENERATE_NDP_PATH_PATH_ONLY             (0x00000004)
#define GENERATE_NDP_PATH_IS_POLICY             (0x00000008)
#define GENERATE_NDP_PATH_ASSEMBLY_NAME_ONLY    (0x00000010)

BOOL
SxspGenerateNDPGacPath(
    ULONG               ulFlags,
    PCASSEMBLY_IDENTITY pAsmIdent,
    CBaseStringBuffer  *psbAssemblyRoot,
    CBaseStringBuffer  &rsbOutput
    )
{
    FN_PROLOG_WIN32;

    typedef struct _STRING_AND_LENGTH {
        PCWSTR pcwsz;
        SIZE_T cch;
    } STRING_AND_LENGTH;

    CSmallStringBuffer  GlobalGacPath;
    SIZE_T              cchRequired;
    STRING_AND_LENGTH   Name, Version, Language, PublicKeyToken, AssemblyRoot;
    bool                fRootNeedsSlash = false;

    rsbOutput.Clear();

    if ((psbAssemblyRoot == NULL) && ((ulFlags & GENERATE_NDP_PATH_NO_ROOT) == 0))
    {
        IFW32FALSE_EXIT(SxspGetNDPGacRootDirectory(GlobalGacPath));
        psbAssemblyRoot = &GlobalGacPath;
    }

    if (psbAssemblyRoot)
    {
        AssemblyRoot.pcwsz = *psbAssemblyRoot;
        AssemblyRoot.cch = psbAssemblyRoot->Cch();
        fRootNeedsSlash = !psbAssemblyRoot->HasTrailingPathSeparator();
    }
    else
    {
        AssemblyRoot.pcwsz = NULL;
        AssemblyRoot.cch = 0;
    }

        
    
    IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
        0, 
        pAsmIdent, 
        &s_IdentityAttribute_name, 
        &Name.pcwsz, &Name.cch));

    if ((ulFlags & GENERATE_NDP_PATH_WILDCARD_VERSION) == 0)
    {
        IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, 
            pAsmIdent, 
            &s_IdentityAttribute_version, 
            &Version.pcwsz, &Version.cch));
    }
    else
    {
        Version.pcwsz = L"*";
        Version.cch = 1;            
    }

    //
    // Allow for international language - in the NDP, this is the "blank" value.
    //
    IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
        SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, 
        pAsmIdent, 
        &s_IdentityAttribute_language, 
        &Language.pcwsz, &Language.cch));

    //
    // If we got back "international", use the blank string instead.
    //
    if (FusionpEqualStrings(Language.pcwsz, Language.cch, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE, NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE) - 1, true))
    {
        Language.pcwsz = 0;
        Language.cch = 0;
    }

    IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
        0,
        pAsmIdent,
        &s_IdentityAttribute_publicKeyToken,
        &PublicKeyToken.pcwsz, &PublicKeyToken.cch));

    //
    // Calcuate the required length: 
    // %gacpath%\{name}\{version}_{language}_{pkt}\{name}.dll
    //
    cchRequired = (AssemblyRoot.cch + 1) +  (Name.cch + 1 + Version.cch + 1 + PublicKeyToken.cch);

    //
    // They want the whole path to the DLL
    //
    if ((ulFlags & GENERATE_NDP_PATH_PATH_ONLY) == 0)
    {
        cchRequired += (Name.cch + 1 + (NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_DLL) - 1));
    }

    //
    // Build the string
    //
    IFW32FALSE_EXIT(rsbOutput.Win32ResizeBuffer(cchRequired, eDoNotPreserveBufferContents));


    //
    // If they want the full path, that's 12 components.  Otherwise, just 9.
    //
    IFW32FALSE_EXIT(rsbOutput.Win32AssignW(
        ((ulFlags & GENERATE_NDP_PATH_PATH_ONLY) ? ((ulFlags & GENERATE_NDP_PATH_ASSEMBLY_NAME_ONLY) ? 3 : 9) : 12),
        AssemblyRoot.pcwsz, AssemblyRoot.cch,           // Root path
        L"\\", (fRootNeedsSlash ? 1 : 0),               // Slash
        Name.pcwsz, Name.cch,
        L"\\", 1,
        Version.pcwsz, Version.cch,
        L"_", 1,
        Language.pcwsz, Language.cch,
        L"_", 1,
        PublicKeyToken.pcwsz, PublicKeyToken.cch,
        L"\\", 1,
        Name.pcwsz, Name.cch,
        ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_DLL, NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_DLL)-1));

    FN_EPILOG;
}



BOOL
CProbedAssemblyInformation::LookForNDPWin32Policy(
    PACTCTXGENCTX       pActCtxGenCtx
    )
/*++

Purpose:
    1. Get the location of the GAC
    2. Create a path of the form %gac%\Policy.Vmajor.Vminor.AssemblyName\*_{language}_{pubkeytoken}
    3. Find all directories that match the wildcard, find the version with the highest value
    4. Find %thatpath%\Policy.VMajor.VMinor.AssemblyName.Dll
    5. Look for a win32 policy manifest in resource ID 1, type RT_MANIFEST
--*/
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CPolicyStatement   *pFoundPolicyStatement = NULL;
    CSmallStringBuffer  Prober;
    CSmallStringBuffer  EncodedPolicyIdentity;
    CFindFile           FindFiles;
    ASSEMBLY_VERSION    HighestAssemblyVersion = {0};
    WIN32_FIND_DATAW    FindData;
    bool                fNotFound = false, fPolicyFound = false, fPolicyApplied = false, fFound = false;
    BOOL                fCrossesReparse = FALSE;
    DWORD               dwCrossError = 0;
    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> PolicyIdentity;
    CProbedAssemblyInformation ProbedAssembly;

    //
    // If there's no public key token in the current assembly identity, then we can't
    // possibly look for it in any public places - stop right now.
    //
    {
        PCWSTR Version;
        SIZE_T cchVersion;
        IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, 
            m_pAssemblyIdentity, 
            &s_IdentityAttribute_publicKeyToken, 
            &Version, &cchVersion));

        if ((Version == NULL) || (cchVersion == 0) || ::FusionpEqualStrings(
            SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE,
            NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1,
            Version, cchVersion, true))
        {
            FN_SUCCESSFUL_EXIT();
        }
    }

    //
    // Generate the textual and non-textual policy identity from the actual identity
    //
    IFW32FALSE_EXIT(SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
        0,
        m_pAssemblyIdentity,
        EncodedPolicyIdentity,
        &PolicyIdentity));

    //
    // See if we've got policy already
    //
    IFW32FALSE_EXIT(pActCtxGenCtx->m_ApplicationPolicyTable.Find(EncodedPolicyIdentity, pFoundPolicyStatement));
    if (pFoundPolicyStatement != NULL)
    {
        CPolicyStatement *pTempStatement = pFoundPolicyStatement;
        pFoundPolicyStatement = NULL;
        IFW32FALSE_EXIT(pTempStatement->ApplyPolicy(m_pAssemblyIdentity, fPolicyApplied));

        if (fPolicyApplied)
            FN_SUCCESSFUL_EXIT();
    }

    //
    // Otherwise, we have to go look in the GAC for a policy for this assembly
    //
    IFW32FALSE_EXIT(SxspGenerateNDPGacPath(
        GENERATE_NDP_PATH_WILDCARD_VERSION | GENERATE_NDP_PATH_PATH_ONLY,
        PolicyIdentity,
        NULL,
        Prober));

    //
    // Now let's find all the directories in the GAC that match this wildcard
    //
    IFW32FALSE_EXIT_UNLESS2(
        FindFiles.Win32FindFirstFile(Prober, &FindData),
        LIST_2(ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND),
        fNotFound);

    if (!fNotFound) do
    {
        ASSEMBLY_VERSION ThisVersion;
        bool fValid = false;
        
        //
        // Skip non-directories and dot/dotdot
        //
        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            continue;
        else if (FusionpIsDotOrDotDot(FindData.cFileName))
            continue;
        
        //
        // Neat, found a match to that pattern. Tease apart the "version" part of the directory - should
        // be everything up to the first underscore in the path
        //       
        PCWSTR pcwszFirstUnderscore = StringFindChar(FindData.cFileName, L'_');

        //
        // Oops, that wasn't a valid path, we'll ignore it quietly
        //
        if (pcwszFirstUnderscore == NULL)
            continue;

        IFW32FALSE_EXIT(CFusionParser::ParseVersion(
            ThisVersion, 
            FindData.cFileName,
            pcwszFirstUnderscore - FindData.cFileName,
            fValid));

        //
        // Sneaky buggers, putting something that's not a version up front.
        //
        if (!fValid)
            continue;

        //
        // Spiffy, we found something that's a version number - is it what we're looking
        // for?
        //
        if (!fPolicyFound || (ThisVersion > HighestAssemblyVersion))
        {
            HighestAssemblyVersion = ThisVersion;
            fPolicyFound = true;
        }
    } while (::FindNextFileW(FindFiles, &FindData));

    //
    // Make sure that we quit out nicely here
    //
    if (!fNotFound && (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES))
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(FindNextFile, ::FusionpGetLastWin32Error());
    }

    //
    // Otherwise, let's parse the statement we found, if there was one.
    //
    if (fPolicyFound)
    {
        //
        // Ensure we have space for 65535.65535.65535.65535
        //
        IFW32FALSE_EXIT(Prober.Win32ResizeBuffer((5 * 4) + 3, eDoNotPreserveBufferContents));
        IFW32FALSE_EXIT(Prober.Win32Format(L"%u.%u.%u.%u", 
            HighestAssemblyVersion.Major,
            HighestAssemblyVersion.Minor,
            HighestAssemblyVersion.Revision,
            HighestAssemblyVersion.Build));
            
        //
        // Ok, now we have the 'highest version' available for the policy.  Let's go swizzle the
        // policy identity and re-generate the path with that new version
        //
        IFW32FALSE_EXIT(ProbedAssembly.Initialize());
        IFW32FALSE_EXIT(SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            PolicyIdentity,
            &s_IdentityAttribute_version,
            static_cast<PCWSTR>(Prober),
            Prober.Cch()));

#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_POLICY, 
            "%s(%d) : Should find this policy identity in the GAC\n",
            __FILE__,
            __LINE__);
        SxspDbgPrintAssemblyIdentity(FUSION_DBG_LEVEL_POLICY, PolicyIdentity);
#endif

        //
        // Now regenerate the path, set it into the actual prober
        //
        IFW32FALSE_EXIT(SxspGenerateNDPGacPath(0, PolicyIdentity, NULL, Prober));

        //
        // Caution! If this path crosses a reparse point, we could really ham up the
        // system while it tries to get to the file, or we could have a security hole
        // where someone has created a reparse point to somewhere untrusted in the
        // filesystem.  Disallow this here.
        //
        IFW32FALSE_EXIT(SxspDoesPathCrossReparsePoint(NULL, 0, Prober, Prober.Cch(), fCrossesReparse));
        if (fCrossesReparse)
        {
            FN_SUCCESSFUL_EXIT();
        }
            
        
        IFW32FALSE_EXIT(ProbedAssembly.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, Prober));
        IFW32FALSE_EXIT(ProbedAssembly.SetProbedIdentity(PolicyIdentity));
        IFW32FALSE_EXIT(SxspParseNdpGacComponentPolicy(0, pActCtxGenCtx, ProbedAssembly, pFoundPolicyStatement));

        IFW32FALSE_EXIT(pFoundPolicyStatement->ApplyPolicy(m_pAssemblyIdentity, fPolicyApplied));
        IFW32FALSE_EXIT(pActCtxGenCtx->m_ComponentPolicyTable.Insert(EncodedPolicyIdentity, pFoundPolicyStatement));

        // pActCtxGenCtx->m_ComponentPolicyTable owns pFoundPolicyStatement
        pFoundPolicyStatement = NULL;
    }

    fSuccess = TRUE;
    FusionpClearLastWin32Error();
Exit:
    if (pFoundPolicyStatement) 
    {
        CSxsPreserveLastError ple;
        delete pFoundPolicyStatement;
        pFoundPolicyStatement = NULL;
        ple.Restore();
    }

    return fSuccess;
}
    
BOOL
CProbedAssemblyInformation::LookForPolicy(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CStringBuffer EncodedPolicyIdentity;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    SIZE_T CandidatePolicyDirectoryCch;
    CPolicyStatement *pPolicyStatement = NULL;
    bool fPolicyApplied = false;
    bool fAnyPoliciesFound = false;
    bool fAnyFilesFound = false;
    PASSEMBLY_IDENTITY PolicyIdentity = NULL;
    BOOL fAreWeInOSSetupMode = FALSE;

    //
    // app policy, foo.exe.config
    //
    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    IFW32FALSE_EXIT(
        ::SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
            SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION,
            m_pAssemblyIdentity,
            EncodedPolicyIdentity,
            NULL));

    IFW32FALSE_EXIT(pActCtxGenCtx->m_ApplicationPolicyTable.Find(EncodedPolicyIdentity, pPolicyStatement));

    if (pPolicyStatement != NULL)
    {
        CPolicyStatement *pTempPolicyStatement = pPolicyStatement;
        pPolicyStatement = NULL; // so we don't delete it in the exit path if ApplyPolicy fails...
        IFW32FALSE_EXIT(pTempPolicyStatement->ApplyPolicy(m_pAssemblyIdentity, fPolicyApplied));
    }

    //
    // publisher policy %windir%\winsxs\Policy\...
    //
    if (!fPolicyApplied)
        IFW32FALSE_EXIT(FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode));
    if (!fPolicyApplied && !fAreWeInOSSetupMode)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
                0,
                m_pAssemblyIdentity,
                EncodedPolicyIdentity,
                &PolicyIdentity));

        // See if there's a policy statement already available for this...
        IFW32FALSE_EXIT(pActCtxGenCtx->m_ComponentPolicyTable.Find(EncodedPolicyIdentity, pPolicyStatement));

        if (pPolicyStatement == NULL)
        {
            CStringBuffer CandidatePolicyDirectory;

            IFW32FALSE_EXIT(
                ::SxspGenerateSxsPath(
                    0,
                    SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY,
                    pActCtxGenCtx->m_AssemblyRootDirectoryBuffer,
                    pActCtxGenCtx->m_AssemblyRootDirectoryBuffer.Cch(),
                    PolicyIdentity,
                    CandidatePolicyDirectory));

            // Save the number of characters up through and including the slash so that
            // we can repeatedly append and then call .Left() on the string buffer.
            CandidatePolicyDirectoryCch = CandidatePolicyDirectory.Cch();

            IFW32FALSE_EXIT(CandidatePolicyDirectory.Win32Append(L"*" POLICY_FILE_EXTENSION, 1 + (NUMBER_OF(POLICY_FILE_EXTENSION) - 1)));

            {
                WIN32_FIND_DATAW wfd;

                hFind = ::FindFirstFileW(CandidatePolicyDirectory, &wfd);
                if (hFind == INVALID_HANDLE_VALUE)
                {
                    const DWORD dwLastError = ::FusionpGetLastWin32Error();

                    if ((dwLastError != ERROR_PATH_NOT_FOUND) &&
                        (dwLastError != ERROR_FILE_NOT_FOUND))
                    {
                        ::FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_ERROR,
                            "SXS.DLL:%s FindFirstFileW(%ls)\n",
                            __FUNCTION__,
                            static_cast<PCWSTR>(CandidatePolicyDirectory)
                            );
                        TRACE_WIN32_FAILURE_ORIGINATION(FindFirstFileW);
                        goto Exit;
                    }
                }

                if (hFind != INVALID_HANDLE_VALUE)
                {
                    fAnyFilesFound = true;
                    ASSEMBLY_VERSION avHighestVersionFound = { 0, 0, 0, 0 };

                    for (;;)
                    {
                        // Skip any directories we find; this will skip "." and ".."
                        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                        {
                            ASSEMBLY_VERSION avTemp;
                            bool fValid;
                            SIZE_T cchFileName = ::wcslen(wfd.cFileName);

                            if (cchFileName > NUMBER_OF(POLICY_FILE_EXTENSION))
                            {
                                IFW32FALSE_EXIT(
                                    CFusionParser::ParseVersion(
                                        avTemp,
                                        wfd.cFileName,
                                        cchFileName - (NUMBER_OF(POLICY_FILE_EXTENSION) - 1),
                                        fValid));

                                // If there are randomly named files in the directory, we just skip them.
                                if (fValid)
                                {
                                    if ((!fAnyPoliciesFound) ||
                                        (avTemp > avHighestVersionFound))
                                    {
                                        fAnyPoliciesFound = true;
                                        CandidatePolicyDirectory.Left(CandidatePolicyDirectoryCch);
                                        IFW32FALSE_EXIT(CandidatePolicyDirectory.Win32Append(wfd.cFileName, cchFileName));
                                        avHighestVersionFound = avTemp;
                                    }
                                }
                            }
                        }
                        if (!::FindNextFileW(hFind, &wfd))
                        {
                            const DWORD dwLastError = ::FusionpGetLastWin32Error();
                            BOOL fTemp;

                            if (dwLastError != ERROR_NO_MORE_FILES)
                            {
                                TRACE_WIN32_FAILURE_ORIGINATION(FindNextFileW);
                                goto Exit;
                            }

                            fTemp = ::FindClose(hFind);
                            hFind = INVALID_HANDLE_VALUE;

                            if (!fTemp)
                            {
                                TRACE_WIN32_FAILURE_ORIGINATION(FindClose);
                                goto Exit;
                            }

                            break;
                        }
                    }
                }
            }

            if (fAnyFilesFound)
            {
                if (fAnyPoliciesFound)
                {
                    CProbedAssemblyInformation PolicyAssemblyInformation;

                    IFW32FALSE_EXIT(PolicyAssemblyInformation.Initialize());
                    IFW32FALSE_EXIT(PolicyAssemblyInformation.SetOriginalReference(PolicyIdentity));
                    IFW32FALSE_EXIT(PolicyAssemblyInformation.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, CandidatePolicyDirectory));

                    // For one thing, let's set the version number...
                    IFW32FALSE_EXIT(
                        ::SxspSetAssemblyIdentityAttributeValue(
                            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                            PolicyIdentity,
                            &s_IdentityAttribute_version,
                            static_cast<PCWSTR>(CandidatePolicyDirectory) + CandidatePolicyDirectoryCch,
                            CandidatePolicyDirectory.Cch() - CandidatePolicyDirectoryCch - (NUMBER_OF(POLICY_FILE_EXTENSION) - 1)));

                    IFW32FALSE_EXIT(PolicyAssemblyInformation.SetProbedIdentity(PolicyIdentity));

                    // We found one!  Let's parse it, looking for a remapping of our identity.
                    IFW32FALSE_EXIT(
                        ::SxspParseComponentPolicy(
                            0,
                            pActCtxGenCtx,
                            PolicyAssemblyInformation,
                            pPolicyStatement));
                }
                else
                {
                    IFALLOCFAILED_EXIT(pPolicyStatement = new CPolicyStatement);
                    IFW32FALSE_EXIT(pPolicyStatement->Initialize());
                }

                IFW32FALSE_EXIT(pActCtxGenCtx->m_ComponentPolicyTable.Insert(EncodedPolicyIdentity, pPolicyStatement, ERROR_SXS_DUPLICATE_ASSEMBLY_NAME));
            }
        }

        // If there was a component policy statement, let's try it out!
        if (pPolicyStatement != NULL)
            IFW32FALSE_EXIT(pPolicyStatement->ApplyPolicy(m_pAssemblyIdentity, fPolicyApplied));
    }

    fSuccess = TRUE;
Exit:
    if (PolicyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(PolicyIdentity);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;

        ::FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;

        ple.Restore();
    }

    return fSuccess;
}

BOOL
CProbedAssemblyInformation::SetOriginalReference(
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(AssemblyIdentity != NULL);

    IFW32FALSE_EXIT(m_OriginalReference.SetAssemblyIdentity(AssemblyIdentity));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::SetProbedIdentity(
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(AssemblyIdentity != NULL);

    IFW32FALSE_EXIT(Base::SetAssemblyIdentity(AssemblyIdentity));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProbedAssemblyInformation::ApplyPolicyDestination(
    const CAssemblyReference    &r,
    SXS_POLICY_SOURCE           s,
    const GUID &                g
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PCASSEMBLY_IDENTITY OldIdentity = m_pAssemblyIdentity;

    INTERNAL_ERROR_CHECK(this->IsInitialized());
    INTERNAL_ERROR_CHECK(r.IsInitialized());

    // Simply put, take anything in r that's specified and override our settings with it.
    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            0,
            r.GetAssemblyIdentity(),
            &m_pAssemblyIdentity));

    m_PolicySource = s;
    m_SystemPolicyGuid = g;

    if (OldIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(OldIdentity));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
CProbedAssemblyInformation::ProbeLanguageDir(
    CBaseStringBuffer &rbuffApplicationDirectory,
    const CBaseStringBuffer &rbuffLanguage,
    bool &rfFound
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD dwFileAttributes;

    rfFound = false;

    IFW32FALSE_EXIT(rbuffApplicationDirectory.Win32Append(rbuffLanguage));

    dwFileAttributes = ::GetFileAttributesW(rbuffApplicationDirectory);
    if (dwFileAttributes == ((DWORD) -1))
    {
        const DWORD dwLastError = ::FusionpGetLastWin32Error();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributes, dwLastError);
    }
    else
    {
        if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            rfFound = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\protectionui.h ===
#pragma once
#include "FusionBuffer.h"

class CAssemblyRecoveryInfo;

class CSXSMediaPromptDialog
{
public:
    enum DialogResults
    {
        DialogCancelled = 1,
        DialogMediaFound = 2,
        DialogUnknown = 3
    };

private:
    const CCodebaseInformation* m_CodebaseInfo;

    bool m_fIsCDROM;
    CStringBuffer m_buffCodebaseInfo;
    HWND m_hOurWnd;
    PVOID m_pvDeviceChange;
    UINT m_uiAutoRunMsg;
    DWORD m_DeviceChangeMask;
    DWORD m_DeviceChangeFlags;

    BOOL DisplayMessage(HWND hw, UINT uContentText, UINT uDialogFlags, int &riResult);

    static
    INT_PTR
    CALLBACK
    OurDialogProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

public:

    CSXSMediaPromptDialog();
    ~CSXSMediaPromptDialog();

    BOOL Initialize(
        const CCodebaseInformation* CodebaseInfo
        );

    BOOL ShowSelf(DialogResults &rResultsOut);

private:
    CSXSMediaPromptDialog(const CSXSMediaPromptDialog &);
    void operator =(const CSXSMediaPromptDialog &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\pendingassembly.h ===
#if !defined(_FUSION_SXS_PENDINGASSEMBLY_H_INCLUDED_)
#define _FUSION_SXS_PENDINGASSEMBLY_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pendingassembly.h

Abstract:

    Sources for the CPendingAssembly class

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    xiaoyuw     09/2000         replace attributes with assembly identity
--*/

class CPendingAssembly
{
public:
    CPendingAssembly();
    ~CPendingAssembly();

    BOOL Initialize(PASSEMBLY SourceAssembly, PCASSEMBLY_IDENTITY Identity, bool Optional, bool IsMetadataSatellite);
    PASSEMBLY SourceAssembly() const { return m_SourceAssembly; }
    PCASSEMBLY_IDENTITY GetIdentity() const { return m_Identity; }
    bool IsOptional() const { return m_Optional; }
    bool IsMetadataSatellite() const { return m_MetadataSatellite; }
    void DeleteYourself() { delete this; }

    SMARTTYPEDEF(CPendingAssembly);

    CDequeLinkage m_Linkage;
protected:
    PASSEMBLY m_SourceAssembly;
    PASSEMBLY_IDENTITY m_Identity;
    bool m_Optional;
    bool m_MetadataSatellite;

private:
    CPendingAssembly(const CPendingAssembly &);
    void operator =(const CPendingAssembly &);
};

SMARTTYPE(CPendingAssembly);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\policystatement.h ===
#if !defined(_FUSION_DLL_WHISTLER_POLICYSTATEMENT_H_INCLUDED_)
#define _FUSION_DLL_WHISTLER_POLICYSTATEMENT_H_INCLUDED_

#pragma once

#include "stdinc.h"
#include "fusionbuffer.h"
#include "fusiondequelinkage.h"
#include "fusiondeque.h"
#include <sxsapi.h>

class CPolicyStatementRedirect
{
public:
    inline CPolicyStatementRedirect() { }
    inline ~CPolicyStatementRedirect() { }


    BOOL Initialize(
        const CBaseStringBuffer &rbuffFromVersionRange,
        const CBaseStringBuffer &rbuffToVersion,
        bool &rfValid
        );

    BOOL TryMap(
        const ASSEMBLY_VERSION &rav,
        SIZE_T cchBuffer,
        PWSTR pBuffer,
        SIZE_T &rcchWritten,
        bool &rfMapped
        );

    BOOL CheckForOverlap(
        const CPolicyStatementRedirect &rRedirect,
        bool &rfOverlaps
        );

    CDequeLinkage m_leLinks;
    ASSEMBLY_VERSION m_avFromMin;
    ASSEMBLY_VERSION m_avFromMax;
    SIZE_T m_cchNewVersion;
    WCHAR m_rgwchNewVersion[(4 * 5) + (3 * 1) + 1];

private:
    CPolicyStatementRedirect(const CPolicyStatementRedirect &r);
    void operator =(const CPolicyStatementRedirect &r);
};

class CPolicyStatement
{
public:
    inline CPolicyStatement() { }
    inline ~CPolicyStatement() { m_Redirects.Clear<CPolicyStatement>(this, &CPolicyStatement::ClearDequeEntry); }

    BOOL Initialize();

    BOOL AddRedirect(
        const CBaseStringBuffer &rbuffFromVersion,
        const CBaseStringBuffer &rbuffToVersion,
        bool &rfValid
        );

    BOOL ApplyPolicy(
        PASSEMBLY_IDENTITY AssemblyIdentity,
        bool &rfPolicyApplied
        );

    VOID ClearDequeEntry(CPolicyStatementRedirect *p) const { FUSION_DELETE_SINGLETON(p); }

    CDeque<CPolicyStatementRedirect, FIELD_OFFSET(CPolicyStatementRedirect, m_leLinks)> m_Redirects;

private:
    CPolicyStatement(const CPolicyStatement &r);
    void operator =(const CPolicyStatement &r);
};

#endif // !defined(_FUSION_DLL_WHISTLER_POLICYSTATEMENT_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\protectionui.cpp ===
#include "stdinc.h"
#include "dbt.h"
#include "devguid.h"
#include "dialogs.h"
#include "CAssemblyRecoveryInfo.h"
#include "protectionui.h"
#include "recover.h"
#include "SxsExceptionHandling.h"

//
// FAKERY
//
extern HINSTANCE g_hInstance;
extern HANDLE g_hSxsLoginEvent;
HDESK   g_hDesktop = NULL;

BOOL
SxspSpinUntilValidDesktop()
{
    FN_PROLOG_WIN32

    //
    // NTRAID#NTBUG9-219455-2000/12/13-MGrier Postponed to Blackcomb; the
    //   current code does the same thing that WFP is doing; it's just that
    //   we should really have them pass us the desktop.
    //
    // We should be relying on what WFP has already
    // found to be the 'proper' input desktop. Doing so, however requires a
    // change to the interface between SXS and SFC to pass along a pointer to
    // the WFP desktop handle.  Not a bad thing, just .. not implemented yet.
    //
    while (g_hDesktop == NULL)
    {
        DWORD dwResult = ::WaitForSingleObject(g_hSxsLoginEvent, INFINITE);

        if (dwResult == WAIT_OBJECT_0)
            IFW32NULL_ORIGINATE_AND_EXIT(g_hDesktop = ::OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED));

        else if (dwResult == WAIT_FAILED)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(WaitForSingleObject, ::FusionpGetLastWin32Error());
    }

    FN_EPILOG
}

CSXSMediaPromptDialog::CSXSMediaPromptDialog()
    : m_hOurWnd((HWND)INVALID_HANDLE_VALUE),
      m_pvDeviceChange(NULL),
      m_uiAutoRunMsg(0),
      m_DeviceChangeMask(0),
      m_DeviceChangeFlags(0),
      m_fIsCDROM(false),
      m_CodebaseInfo(NULL)
{
}

CSXSMediaPromptDialog::~CSXSMediaPromptDialog()
{
}

BOOL
CSXSMediaPromptDialog::Initialize(
    const CCodebaseInformation* CodebaseInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(CodebaseInfo != NULL);

    SxsWFPResolveCodebase CodebaseType;

    IFW32FALSE_EXIT(CodebaseInfo->Win32GetType(CodebaseType));

    PARAMETER_CHECK(
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_FILE) ||
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_WINSOURCE) ||
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_CDROM));

    m_CodebaseInfo = CodebaseInfo;
    switch (CodebaseType)
    {
    case CODEBASE_RESOLVED_URLHEAD_CDROM:
        m_fIsCDROM = true;
        break;

    case CODEBASE_RESOLVED_URLHEAD_WINSOURCE:
        {
            CFusionRegKey hkSetupInfo;
            DWORD dwWasFromCDRom;

            IFREGFAILED_ORIGINATE_AND_EXIT(
                ::RegOpenKeyExW(
			        HKEY_LOCAL_MACHINE,
			        WINSXS_INSTALL_SOURCE_BASEDIR,
			        0,
			        KEY_READ | FUSIONP_KEY_WOW64_64KEY,
			        &hkSetupInfo));

            if (!::FusionpRegQueryDwordValueEx(
                    0,
                    hkSetupInfo,
                    WINSXS_INSTALL_SOURCE_IS_CDROM,
                    &dwWasFromCDRom))
            {
                dwWasFromCDRom = 0;
            }

            m_fIsCDROM = (dwWasFromCDRom != 0);
            break;
        }

    case CODEBASE_RESOLVED_URLHEAD_FILE:
        {
            CSmallStringBuffer buffVolumePathName;

            IFW32FALSE_EXIT(
                ::SxspGetVolumePathName(
                    0,
                    CodebaseInfo->GetCodebase(),
                    buffVolumePathName));

            if (::GetDriveTypeW(buffVolumePathName) == DRIVE_CDROM)
            {
                m_fIsCDROM = true;
            }

            break;
        }
    }

    FN_EPILOG
}

BOOL
CSXSMediaPromptDialog::DisplayMessage(
    HWND hDlg,
    UINT uContentText,
    UINT uDialogFlags,
    int &riResult
    )
{
    FN_PROLOG_WIN32

    WCHAR wcTitle[MAX_PATH*2];
    WCHAR wcContent[MAX_PATH*2];
    int iResult = 0;

    IFW32ZERO_ORIGINATE_AND_EXIT(::LoadStringW(g_hInstance, uContentText, wcContent, NUMBER_OF(wcContent)));
    IFW32ZERO_ORIGINATE_AND_EXIT(::LoadStringW(g_hInstance, IDS_TITLE, wcTitle, NUMBER_OF(wcTitle)));
    IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::MessageBoxW(hDlg, wcContent, wcTitle, uDialogFlags));

    riResult = iResult;

    FN_EPILOG
}

BOOL
CSXSMediaPromptDialog::ShowSelf(
    CSXSMediaPromptDialog::DialogResults &rResult
    )
{
    FN_PROLOG_WIN32

    INT_PTR i;

    IFW32FALSE_EXIT(::SxspSpinUntilValidDesktop());
    IFW32FALSE_ORIGINATE_AND_EXIT(::SetThreadDesktop(g_hDesktop));

    i = ::DialogBoxParamW(
            g_hInstance,
            MAKEINTRESOURCEW(
                m_fIsCDROM ? 
                    IDD_SFC_CD_PROMPT :
                    IDD_SFC_NETWORK_PROMPT),
            NULL,
            &CSXSMediaPromptDialog::OurDialogProc,
            (LPARAM)this);

    if (i == -1)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(DialogBoxParamW, ::FusionpGetLastWin32Error());

    rResult = static_cast<DialogResults>(i);

    FN_EPILOG
}


BOOL
SxspFindInstallWindowsSourcePath(
    OUT CBaseStringBuffer &rbuffTempStringBuffer
    )
{
    FN_PROLOG_WIN32

    CFusionRegKey rhkInstallSource;
    
    rbuffTempStringBuffer.Clear();

    IFREGFAILED_ORIGINATE_AND_EXIT(
        ::RegOpenKeyExW(
            HKEY_LOCAL_MACHINE, 
            WINSXS_INSTALL_SOURCE_BASEDIR,
            0,
            KEY_READ | FUSIONP_KEY_WOW64_64KEY,
            &rhkInstallSource));

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkInstallSource,
            WINSXS_INSTALL_SOURCEPATH_REGKEY,
            rbuffTempStringBuffer));

    //
    // Now let's be really cheesy and find the fourth slash (\\foo\bar\), and
    // clip everything after that.
    //
    PCWSTR cursor = rbuffTempStringBuffer;
    ULONG ulSlashCount = 0;
    while ( *cursor && ulSlashCount < 4 )
    {
        if (*cursor == L'\\')
            ulSlashCount++;

        cursor++;
    }

    //
    // If we got 3 or less, then it's \\foo\bar or \\foo, which should be
    // illegal.  Otherwise, clip everything off past this point.
    //
    if (ulSlashCount > 3)
    {
        rbuffTempStringBuffer.Left(cursor - rbuffTempStringBuffer);
        rbuffTempStringBuffer.RemoveTrailingPathSeparators();
    }

    FN_EPILOG
}

INT_PTR
CALLBACK
CSXSMediaPromptDialog::OurDialogProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    FN_TRACE();
    INT_PTR iResult = 0;
    int iMessageBoxResult = 0;

#define WM_TRYAGAIN (WM_USER + 1)

    static CSXSMediaPromptDialog    *pThis = NULL;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pThis = reinterpret_cast<CSXSMediaPromptDialog *>(lParam);

            FLASHWINFO winfo;

            ASSERT(pThis != NULL);
            ASSERT(pThis->m_hOurWnd == INVALID_HANDLE_VALUE);
            pThis->m_hOurWnd = hDlg;

            //
            // Center the window, bring it forward
            //
            {
                RECT rcWindow;
                LONG x, y, w, h;

                ::GetWindowRect(hDlg, &rcWindow);  // error check?

                w = rcWindow.right - rcWindow.left + 1;
                h = rcWindow.bottom - rcWindow.top + 1;
                x = (::GetSystemMetrics(SM_CXSCREEN) - w) / 2;  // error check?
                y = (::GetSystemMetrics(SM_CYSCREEN) - h) / 2;  // error check?

                ::MoveWindow(hDlg, x, y, w, h, FALSE);  // error check?

                winfo.cbSize = sizeof(winfo);
                winfo.hwnd = hDlg;
                winfo.dwFlags = FLASHW_ALL;
                winfo.uCount = 3;
                winfo.dwTimeout = 0;
                ::SetForegroundWindow(hDlg); // error check?
                ::FlashWindowEx(&winfo);     // error check?
            }

            //
            // Create the device-change notification
            //
            if (pThis->m_pvDeviceChange == NULL)
            {
                DEV_BROADCAST_DEVICEINTERFACE_W FilterData = { 0 };

                FilterData.dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
                FilterData.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
                FilterData.dbcc_classguid  = GUID_DEVCLASS_CDROM;

                IFW32NULL_ORIGINATE_AND_EXIT(
                    // Change this to RegisterDeviceNotificationW in Blackcomb.
                    pThis->m_pvDeviceChange = ::RegisterDeviceNotification(
                        hDlg,
                        &FilterData,
                        DEVICE_NOTIFY_WINDOW_HANDLE));
            }

            //
            // Turn off autorun
            //
            IFW32ZERO_ORIGINATE_AND_EXIT(pThis->m_uiAutoRunMsg = ::RegisterWindowMessageW(L"QueryCancelAutoPlay"));

            //
            // Fidget with the text in the popup dialog now
            //
            {
                CSmallStringBuffer sbFormatter;
                CSmallStringBuffer buffFormattedText;
                CStringBufferAccessor acc;

                //
                // It is ok if these memory allocations fail, the ui will degrade.
                // As well, that's a reason to leave the buffers "small" and not "tiny".
                // ?
                //
                sbFormatter.Win32ResizeBuffer(512, eDoNotPreserveBufferContents);
                buffFormattedText.Win32ResizeBuffer(512, eDoNotPreserveBufferContents);

                //
                // Set the "Insert your .... now"
                //
                sbFormatter.Clear();
                acc.Attach(&sbFormatter);
                ::GetDlgItemTextW( // error check?
                    hDlg,
                    IDC_MEDIA_NAME,
                    acc,
                    static_cast<DWORD>(sbFormatter.GetBufferCch()));
                acc.Detach();

                if (pThis->m_CodebaseInfo->GetPromptText().Cch() != 0)
                {
                    IFW32FALSE_EXIT(buffFormattedText.Win32Format(
                        sbFormatter,
                        static_cast<PCWSTR>(pThis->m_CodebaseInfo->GetPromptText())));
                    ::SetDlgItemTextW(hDlg, IDC_MEDIA_NAME, static_cast<PCWSTR>(buffFormattedText)); // error check?
                }
                else
                {
#if DBG
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP,
                        "SXS: %s - setting IDC_MEDIA_NAME to empty\n", __FUNCTION__);
#endif
                    ::SetDlgItemTextW(hDlg, IDC_MEDIA_NAME, L""); // error check?
                }

                //
                // Now, depending on what kind of box this is..
                //
                if (!pThis->m_fIsCDROM)
                {
                    CSmallStringBuffer buffTempStringBuffer;
                    SxsWFPResolveCodebase CodebaseType;
                    
                    sbFormatter.Clear();
                    acc.Attach(&sbFormatter);

                    ::GetDlgItemTextW( // error check?
                        hDlg,
                        IDC_NET_NAME,
                        acc,
                        static_cast<DWORD>(sbFormatter.GetBufferCch()));

                    acc.Detach();

                    IFW32FALSE_EXIT(pThis->m_CodebaseInfo->Win32GetType(CodebaseType));

                    //
                    // If this is the Windows install media, display something
                    // pleasant to the user - \\server\share only!
                    //
                    if (CodebaseType == CODEBASE_RESOLVED_URLHEAD_WINSOURCE)
                    {
                        IFW32FALSE_EXIT(::SxspFindInstallWindowsSourcePath(buffTempStringBuffer));
                    }
                    else
                    {

                        IFW32FALSE_EXIT(buffTempStringBuffer.Win32Assign(pThis->m_CodebaseInfo->GetCodebase()));
                    }

                    if (buffTempStringBuffer.Cch() != 0)
                    {
                        IFW32FALSE_EXIT(buffFormattedText.Win32Format(sbFormatter, static_cast<PCWSTR>(buffTempStringBuffer)));
                        IFW32FALSE_EXIT(::SetDlgItemTextW(hDlg, IDC_NET_NAME, buffFormattedText));
                    }
                    else
                    {
#if DBG
                        ::FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_WFP,
                            "SXS: %s - setting IDC_NET_NAME to empty\n", __FUNCTION__);
#endif
                        IFW32FALSE_EXIT(::SetDlgItemTextW(hDlg, IDC_NET_NAME, L""));
                    }
                }
                else
                {
                    //
                    // TODO (jonwis) : This is a CD-rom based install, so we should do
                    // something sane about prompting for the windows CD.
                    //
                }



                //
                // Now get the prompt from the resources.. we only have one, really.
                //
                sbFormatter.Clear();
                acc.Attach(&sbFormatter);

                ::LoadStringW(  // error check?
                    g_hInstance,
                    IDS_RESTORE_TEXT,
                    acc.GetBufferPtr(),
                    acc.GetBufferCchAsDWORD());

                acc.Detach();

                ::SetDlgItemTextW(hDlg, IDC_PROMPT_TEXT, sbFormatter); // error check?
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_RETRY:
            pThis->m_DeviceChangeMask = static_cast<DWORD>(-1);
            pThis->m_DeviceChangeFlags = DBTF_MEDIA;
            // Change this to PostMessageW in Blackcomb.
            IFW32FALSE_EXIT(::PostMessage(hDlg, WM_TRYAGAIN, 0, 0));
            break;

        case IDC_INFO:
            IFW32FALSE_EXIT(
                pThis->DisplayMessage(
                    NULL,
                    pThis->m_fIsCDROM ? IDS_MORE_INFORMATION_CD : IDS_MORE_INFORMATION_NET,
                    MB_ICONINFORMATION | MB_SERVICE_NOTIFICATION | MB_OK,
                    iMessageBoxResult));
			
            break;

        case IDCANCEL:
            IFW32FALSE_EXIT(
                pThis->DisplayMessage(
                    hDlg,
                    IDS_CANCEL_CONFIRM,
                    MB_APPLMODAL | MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING,
                    iMessageBoxResult));

            if (iMessageBoxResult == IDYES)
            {
                ::UnregisterDeviceNotification(pThis->m_pvDeviceChange); // error check?
                ::EndDialog(hDlg, CSXSMediaPromptDialog::DialogCancelled); // error check?
            }

            break;
        }

        break;  // WM_COMMAND

    case WM_DEVICECHANGE:

        if (wParam == DBT_DEVICEARRIVAL)
        {
            DEV_BROADCAST_VOLUME *dbv = reinterpret_cast<DEV_BROADCAST_VOLUME*>(lParam);
            ASSERT(dbv != NULL);

            if (dbv->dbcv_devicetype == DBT_DEVTYP_VOLUME)
            {
                pThis->m_DeviceChangeMask = dbv->dbcv_unitmask;
                pThis->m_DeviceChangeFlags = dbv->dbcv_flags;
                ::PostMessage(hDlg, WM_TRYAGAIN, 0, 0); // error check?
            }
        }

        break;

    case WM_TRYAGAIN:
        ::UnregisterDeviceNotification(pThis->m_pvDeviceChange); // error check?
        ::EndDialog(hDlg, CSXSMediaPromptDialog::DialogMediaFound); // error check?
        break;
    }

Exit:

    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\probedassemblyinformation.h ===
#if !defined(_FUSION_SXS_PROBEDASSEMBLYINFORMATION_H_INCLUDED_)
#define _FUSION_SXS_PROBEDASSEMBLYINFORMATION_H_INCLUDED_

#pragma once

#include "sxsp.h"
#include "assemblyreference.h"
#include "impersonationdata.h"
#include <sxsapi.h>

class CProbedAssemblyInformation : protected CAssemblyReference
{
    typedef CAssemblyReference Base;

protected:
public:
    CProbedAssemblyInformation()
        :
        m_ManifestFlags(ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT),
        m_PolicySource(SXS_POLICY_UNSPECIFIED),
        m_ManifestPathType(ACTIVATION_CONTEXT_PATH_TYPE_NONE),
        m_PolicyPathType(ACTIVATION_CONTEXT_PATH_TYPE_NONE)
    {
        m_ManifestLastWriteTime.dwLowDateTime = 0;
        m_ManifestLastWriteTime.dwHighDateTime = 0;
        m_PolicyLastWriteTime.dwLowDateTime = 0;
        m_PolicyLastWriteTime.dwHighDateTime = 0;
    }

    ~CProbedAssemblyInformation();

    BOOL Initialize();
    BOOL Initialize(const CAssemblyReference &r);
    BOOL Initialize(const CProbedAssemblyInformation &r);

    using CAssemblyReference::GetAssemblyIdentity;
    using CAssemblyReference::GetAssemblyName;
    using CAssemblyReference::GetPublicKeyToken;
    using CAssemblyReference::SetAssemblyIdentity;
    using CAssemblyReference::SetLanguage;
    using CAssemblyReference::SetProcessorArchitecture;
    using CAssemblyReference::SetPublicKeyToken;
    using CAssemblyReference::ClearLanguage;

    enum LanguageProbeType
    {
        eExplicitBind,
        eLanguageNeutral,
        eSpecificLanguage,
        eGenericLanguage,
        eSpecificSystemLanguage,
        eGenericSystemLanguage
    };

    enum ProbeAssemblyFlags
    {
        ProbeAssembly_SkipPrivateAssemblies = 0x00000001,
    };

    BOOL ProbeAssembly(DWORD dwFlags, PACTCTXGENCTX pActCtxGenCtx, LanguageProbeType lpt, bool &rfFound);

    BOOL Assign(const CProbedAssemblyInformation &r);

    BOOL SetOriginalReference(const CAssemblyReference &r, bool fCopyValidFieldsFromPartialReference = true);
    const CAssemblyReference &GetOriginalReference() const;

    BOOL SetOriginalReference(PCASSEMBLY_IDENTITY AssemblyIdentity);
    BOOL SetProbedIdentity(PCASSEMBLY_IDENTITY AssemblyIdentity);
    BOOL ResetProbedToOriginal();

    // manifest
    BOOL SetManifestPath(ULONG ulPathType, const CBaseStringBuffer &rbuff);
    BOOL SetManifestPath(ULONG ulPathType, PCWSTR Path, SIZE_T PathCch);
    BOOL GetManifestPath(PCWSTR *Path, SIZE_T *PathCch) const;
    const CBaseStringBuffer &GetManifestPath() const { return m_ManifestPathBuffer; }
    ULONG GetManifestPathType() const { return m_ManifestPathType; }
    ULONG GetManifestFlags() const;
    BOOL SetManifestFlags(ULONG Flags);
    BOOL SetManifestLastWriteTime(const FILETIME &LastWriteTime);
    const FILETIME &GetManifestLastWriteTime() const;
    BOOL SetManifestLastWriteTime(PACTCTXGENCTX pActCtxGenCtx, BOOL fDuringBindingAndProbingPrivateManifest = FALSE);
    BOOL SetManifestStream(IStream* Stream);
    IStream* GetManifestStream() const;

    BOOL ProbeManifestExistence(const CImpersonationData &ImpersonationData, bool &rfManifestExists) const;

    // APPLICATION policy, not component policy...
    ULONG GetPolicyFlags() const;
    BOOL SetPolicyFlags(ULONG Flags);
    BOOL GetPolicyPath(PCWSTR &rPath, SIZE_T &rPathCch) const;
    const FILETIME &GetPolicyLastWriteTime() const;
    BOOL SetPolicyPath(ULONG PathType, PCWSTR Path, SIZE_T PathCch);
    const CBaseStringBuffer &GetPolicyPath() const { return m_PolicyPathBuffer; }
    ULONG GetPolicyPathType() const { return m_PolicyPathType; }
    BOOL SetPolicyStream(IStream* Stream);
    IStream* GetPolicyStream() const;

    BOOL IsPrivateAssembly() const;
    SXS_POLICY_SOURCE GetPolicySource() const;
    void SetPolicySource(SXS_POLICY_SOURCE ps);
    BOOL ApplyPolicyDestination(const CAssemblyReference &r, SXS_POLICY_SOURCE s, const GUID &g);

protected:
    BOOL LookForPolicy(PACTCTXGENCTX pActCtxGenCtx);
    BOOL LookForNDPWin32Policy(PACTCTXGENCTX pActCtxGenCtx);
    BOOL ProbeLanguageDir(CBaseStringBuffer &rbuffApplicationDirectory, const CBaseStringBuffer &rbuffLanguage, bool &rfFound);

    CAssemblyReference m_OriginalReference;
    CAssemblyReference m_CheckpointedReference;

    // manifest
    ULONG m_ManifestPathType;
    CStringBuffer m_ManifestPathBuffer;
    FILETIME m_ManifestLastWriteTime;
    CSmartRef<IStream> m_ManifestStream;
    ULONG  m_ManifestFlags;

    // policy
    ULONG m_PolicyPathType;
    CSmallStringBuffer m_PolicyPathBuffer; // only used when policy is present
    FILETIME m_PolicyLastWriteTime;
    SXS_POLICY_SOURCE m_PolicySource;
    GUID    m_SystemPolicyGuid;
    CSmartRef<IStream> m_PolicyStream;
    ULONG  m_PolicyFlags;

private: // deliberately not implemented
    CProbedAssemblyInformation(const CProbedAssemblyInformation&);
    void operator=(const CProbedAssemblyInformation&);
};

inline const CAssemblyReference& CProbedAssemblyInformation::GetOriginalReference() const
{
    return m_OriginalReference;
}

inline BOOL CProbedAssemblyInformation::GetManifestPath(PCWSTR *Path, SIZE_T *PathCch) const
{
    if (Path != NULL)
        *Path = m_ManifestPathBuffer;

    if (PathCch != NULL)
        *PathCch = m_ManifestPathBuffer.Cch();

    return TRUE;
}

inline BOOL CProbedAssemblyInformation::SetManifestLastWriteTime(const FILETIME &LastWriteTime)
{
    m_ManifestLastWriteTime = LastWriteTime;
    return TRUE;
}

inline const FILETIME& CProbedAssemblyInformation::GetManifestLastWriteTime() const
{
    return m_ManifestLastWriteTime;
}

inline BOOL
CProbedAssemblyInformation::GetPolicyPath(
    PCWSTR &rPath,
    SIZE_T &rPathCch
    ) const
{
    rPath = static_cast<PCWSTR>(m_PolicyPathBuffer);
    rPathCch = m_PolicyPathBuffer.Cch();

    return TRUE;
}

inline ULONG CProbedAssemblyInformation::GetPolicyFlags() const
{
    return m_PolicyFlags;
}

inline BOOL CProbedAssemblyInformation::SetPolicyFlags(ULONG Flags)
{
    m_PolicyFlags = Flags;
    return TRUE;
}

inline const FILETIME& CProbedAssemblyInformation::GetPolicyLastWriteTime() const
{
    return m_PolicyLastWriteTime;
}

inline ULONG CProbedAssemblyInformation::GetManifestFlags() const
{
    return m_ManifestFlags;
}

inline BOOL CProbedAssemblyInformation::SetManifestFlags(ULONG Flags)
{
    m_ManifestFlags = Flags;
    return TRUE;
}

inline BOOL CProbedAssemblyInformation::SetManifestStream(IStream* Stream)
{
    m_ManifestStream = Stream;
    return TRUE;
}

inline BOOL CProbedAssemblyInformation::SetPolicyStream(IStream* Stream)
{
    m_PolicyStream = Stream;
    return TRUE;
}

inline IStream* CProbedAssemblyInformation::GetPolicyStream() const
{
    return m_PolicyStream;
}

inline IStream* CProbedAssemblyInformation::GetManifestStream() const
{
    return m_ManifestStream;
}

inline BOOL CProbedAssemblyInformation::IsPrivateAssembly() const
{
    return ((m_ManifestFlags & ASSEMBLY_PRIVATE_MANIFEST) ? TRUE : FALSE);
}

inline SXS_POLICY_SOURCE CProbedAssemblyInformation::GetPolicySource() const
{
    return m_PolicySource;
}

inline void CProbedAssemblyInformation::SetPolicySource(SXS_POLICY_SOURCE ps)
{
    m_PolicySource = ps;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\purevirt.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    purevirt.c

Abstract:

    Implementation of _purecall to eliminate msvcrt.dll dependency
        in sxs.dll / csrss.exe.

Author:

    Jay Krell (a-JayK) July 2000

Revision History:

--*/
/*
see \nt\base\crts\crtw32\misc\purevirt.c
    \nt\base\crts\crtw32\hack\stubs.c
*/

#include "stdinc.h"
#include "debmacro.h"
#include "fusiontrace.h"

/***
*void _purecall(void) -
*
*Purpose:
*
*Entry:
*	No arguments
*
*Exit:
*	Never returns
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _purecall(
	void
	)
{
    ::RaiseException((DWORD) STATUS_NOT_IMPLEMENTED, EXCEPTION_NONCONTINUABLE, 0, NULL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\query.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    query.cpp

Abstract:

    Information querying functions for sxs.dll

Author:

    Michael J. Grier (MGrier) 22-May-2001

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

BOOL
SxspQueryManifestInformationBasic(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T cbWrittenOrRequired OPTIONAL
    );

BOOL
SxsQueryManifestInformation(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN ULONG ulInfoClass,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T pcbWrittenOrRequired OPTIONAL
    )
{
    FN_PROLOG_WIN32;

    if (pcbWrittenOrRequired != NULL)
        *pcbWrittenOrRequired = 0;

    PARAMETER_CHECK((dwFlags & ~SXS_QUERY_MANIFEST_INFORMATION_FLAG_SOURCE_IS_DLL) == 0);
    PARAMETER_CHECK(pszSource != NULL);
    PARAMETER_CHECK(ulInfoClass == SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC);
    // ignore infoclass specific flags
    PARAMETER_CHECK((cbBuffer == 0) || (lpBuffer != NULL)); // can't have a nonzero-sized buffer with a NULL pointer to it
    PARAMETER_CHECK((cbBuffer != 0) || (pcbWrittenOrRequired != NULL));

    switch (ulInfoClass)
    {
    default:
        INTERNAL_ERROR_CHECK(
            (ulInfoClass == SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC)
            );
        ORIGINATE_WIN32_FAILURE_AND_EXIT(InternalErrorNoCaseForInfoClass, ERROR_INTERNAL_ERROR);
        break;

    case SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC:
        IFW32FALSE_EXIT(
            ::SxspQueryManifestInformationBasic(
                dwFlags,
                pszSource,
                dwInfoClassSpecificFlags,
                cbBuffer,
                lpBuffer,
                pcbWrittenOrRequired));
        break;
    }

    FN_EPILOG;
}

BOOL
SxspQueryManifestInformationBasic(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T pcbWrittenOrRequired OPTIONAL
    )
{
    FN_PROLOG_WIN32;

    ACTCTXGENCTX ActCtxGenCtx;
    ULONG ManifestFlags;
    CImpersonationData ImpersonationData;
    PCWSTR Slash = NULL;
    CSmartRef<ASSEMBLY> Asm;
    CStringBuffer buffManifestPath;
    USHORT ProcessorArchitecture = ::SxspGetSystemProcessorArchitecture();
    LANGID LangId = ::GetUserDefaultUILanguage();
    CStringBufferAccessor acc;
    SIZE_T cch, cchRequired;
    SIZE_T cbRequired, cbLeft, cbWritten;
    PCASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    CStringBuffer buffShortName;
    PWSTR Cursor;
    PSXS_MANIFEST_INFORMATION_BASIC psmib;
    CResourceStream DllStream;
    CFileStream FileStream;
    IStream* pStream = NULL;
    CProbedAssemblyInformation AssemblyInformation;

    if (pcbWrittenOrRequired != NULL)
        *pcbWrittenOrRequired = 0;

    // We'll assume that SxsQueryManifestInformation checked everything
    // except dwInfoClassSpecificFlags.

    PARAMETER_CHECK((dwInfoClassSpecificFlags & ~(
        SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY |
        SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME)) == 0);

    //
    // If this is a DLL source, then ensure that the size is at least big enough for our basic
    // data, and ensure that the flags are zero (in this rev, that's all that's allowed.
    //
    if (dwFlags & SXS_QUERY_MANIFEST_INFORMATION_FLAG_SOURCE_IS_DLL)
    {
        PCSXS_MANIFEST_INFORMATION_SOURCE_DLL pDllSource = (PCSXS_MANIFEST_INFORMATION_SOURCE_DLL)pszSource;
        const DWORD dwValidFlags = 
            SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_LANGUAGE_VALID | 
            SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_TYPE_VALID |
            SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_ID_VALID;

        PARAMETER_CHECK(pDllSource->dwSize >= sizeof(SXS_MANIFEST_INFORMATION_SOURCE_DLL));
        PARAMETER_CHECK((pDllSource->dwFlags & ~dwValidFlags) == 0);
        PARAMETER_CHECK(pDllSource->pcwszDllPath!= NULL);
        PARAMETER_CHECK(((pDllSource->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_LANGUAGE_VALID) == 0) || (pDllSource->Language != 0));
        PARAMETER_CHECK(((pDllSource->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_TYPE_VALID) == 0) || (pDllSource->pcwszResourceType != NULL));
        PARAMETER_CHECK(((pDllSource->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_ID_VALID) == 0) || (pDllSource->pcwszResourceName != NULL));
    }
    
    IFW32FALSE_EXIT(
        ::SxspInitActCtxGenCtx(
                &ActCtxGenCtx,         // context out
                MANIFEST_OPERATION_VALIDATE_SYNTAX,
                0,
                0,
                ImpersonationData,
                ProcessorArchitecture,
                LangId,
                ACTIVATION_CONTEXT_PATH_TYPE_NONE,
                0,
                NULL));

    IFALLOCFAILED_EXIT(Asm = new ASSEMBLY);

    //
    // For DLL sources, tease apart the version and whatnot from the
    // structure passed in.
    //
    if (dwFlags & SXS_QUERY_MANIFEST_INFORMATION_FLAG_SOURCE_IS_DLL)
    {
        PCSXS_MANIFEST_INFORMATION_SOURCE_DLL pcSourceInfo = (PCSXS_MANIFEST_INFORMATION_SOURCE_DLL)pszSource;
        IFW32FALSE_EXIT(SxspGetFullPathName(pcSourceInfo->pcwszDllPath, buffManifestPath, NULL));

        //
        // Default action... just go use the normal "find the first in the dll" thing
        //
        if (pcSourceInfo->dwFlags == 0)
        {
            IFW32FALSE_EXIT(DllStream.Initialize(buffManifestPath, (PCWSTR)RT_MANIFEST));
        }
        else
        {
            const DWORD dwFlags = pcSourceInfo->dwFlags;
            
            IFW32FALSE_EXIT(
                DllStream.Initialize(
                    buffManifestPath, 
                    ((dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_TYPE_VALID) ? pcSourceInfo->pcwszResourceType : (PCWSTR)RT_MANIFEST),
                    ((dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_ID_VALID) ? pcSourceInfo->pcwszResourceName :  NULL),
                    ((dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_LANGUAGE_VALID) ? (WORD)pcSourceInfo->Language : (WORD)MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))));
        }
          
        pStream = &DllStream;
    }
    //
    // Otherwise, dumb file.
    //
    else
    {
        IFW32FALSE_EXIT(SxspGetFullPathName(pszSource, buffManifestPath, NULL));
        IFW32FALSE_EXIT(
            FileStream.OpenForRead(
                buffManifestPath, 
                CImpersonationData(),
                FILE_SHARE_READ,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL));
        pStream = &FileStream;
    }

    ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_STREAM;            
    IFW32FALSE_EXIT(AssemblyInformation.Initialize());
    IFW32FALSE_EXIT(AssemblyInformation.SetManifestFlags(ManifestFlags));
    IFW32FALSE_EXIT(AssemblyInformation.SetManifestStream(pStream));
    IFW32FALSE_EXIT(AssemblyInformation.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, buffManifestPath));
    IFW32FALSE_EXIT(AssemblyInformation.SetManifestLastWriteTime(&ActCtxGenCtx));

    IFW32FALSE_EXIT(::SxspInitAssembly(Asm, AssemblyInformation));
    Asm->m_AssemblyRosterIndex = 1; // set it to be the root...
    IFW32FALSE_EXIT(::SxspIncorporateAssembly(&ActCtxGenCtx, Asm));
    IFW32FALSE_EXIT(::SxspFireActCtxGenEnding(&ActCtxGenCtx));
    pStream->Release();

    AssemblyIdentity = Asm->m_Information.GetAssemblyIdentity();

    cchRequired = 0;

    if ((dwInfoClassSpecificFlags & SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY) == 0)
    {
        SIZE_T TextuallyEncodedIdentityBufferBytes = 0;

        IFW32FALSE_EXIT(
            ::SxsComputeAssemblyIdentityEncodedSize(
                0,
                AssemblyIdentity,
                NULL,
                SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                &TextuallyEncodedIdentityBufferBytes));
        INTERNAL_ERROR_CHECK((TextuallyEncodedIdentityBufferBytes % sizeof(WCHAR)) == 0);

        cchRequired += ((TextuallyEncodedIdentityBufferBytes / sizeof(WCHAR)) + 1);
    }

    if ((dwInfoClassSpecificFlags & SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME) == 0)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                NULL, 0,
                AssemblyIdentity,
                buffShortName));

        cchRequired += (buffShortName.Cch() + 1);
    }

    cbRequired = sizeof(SXS_MANIFEST_INFORMATION_BASIC) + (cchRequired * sizeof(WCHAR));

    if (cbRequired > cbBuffer)
    {
        *pcbWrittenOrRequired = cbRequired;
        ORIGINATE_WIN32_FAILURE_AND_EXIT(BufferTooSmall, ERROR_INSUFFICIENT_BUFFER);
    }

    psmib = (PSXS_MANIFEST_INFORMATION_BASIC) lpBuffer;

    psmib->lpIdentity = NULL;
    psmib->lpShortName = NULL;
    psmib->ulFileCount = ActCtxGenCtx.m_ulFileCount;

    Cursor = (PWSTR) (psmib + 1);
    cbLeft = (cbBuffer - sizeof(SXS_MANIFEST_INFORMATION_BASIC));
    cbWritten = sizeof(SXS_MANIFEST_INFORMATION_BASIC);

    if ((dwInfoClassSpecificFlags & SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY) == 0)
    {
        SIZE_T cbActual;

        IFW32FALSE_EXIT(
            ::SxsEncodeAssemblyIdentity(
                0,
                AssemblyIdentity,
                NULL,
                SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                cbLeft,
                Cursor,
                &cbActual));

        INTERNAL_ERROR_CHECK((cbActual % sizeof(WCHAR)) == 0);
        INTERNAL_ERROR_CHECK(cbLeft >= cbActual);

        psmib->lpIdentity = Cursor;

        cbLeft -= cbActual;
        cbWritten += cbActual;

        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + cbActual);

        INTERNAL_ERROR_CHECK(cbLeft >= sizeof(WCHAR));

        *Cursor++ = L'\0';
        cbLeft -= sizeof(WCHAR);
        cbWritten += sizeof(WCHAR);
    }

    if ((dwInfoClassSpecificFlags & SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME) == 0)
    {
        cch = buffShortName.Cch();

        INTERNAL_ERROR_CHECK(cbLeft >= ((cch + 1) * sizeof(WCHAR)));

        memcpy(Cursor, static_cast<PCWSTR>(buffShortName), (cch + 1) * sizeof(WCHAR));
        psmib->lpShortName = Cursor;

        cbLeft -= ((cch + 1) * sizeof(WCHAR));
        cbWritten += ((cch + 1) * sizeof(WCHAR));

        Cursor += (cch + 1);
    }

    if (pcbWrittenOrRequired != NULL)
        *pcbWrittenOrRequired = cbWritten;

    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sect_attribs.h ===
/***
*sect_attribs.h - section attributes for IA64 CRTs
*
*       Copyright (c) 1998-1999, Microsoft Corporation. All rights reserved.
*
*Revision History:
*       04-14-98  JWM   File created
*       04-28-99  PML   Wrap for IA64 only, define _CRTALLOC
*
****/

#ifdef  _M_IA64

#pragma section(".CRT$XCA",long,read)
#pragma section(".CRT$XCAA",long,read)
#pragma section(".CRT$XCZ",long,read)
#pragma section(".CRT$XIA",long,read)
#pragma section(".CRT$XIC",long,read)
#pragma section(".CRT$XIY",long,read)
#pragma section(".CRT$XIZ",long,read)
#pragma section(".CRT$XLA",long,read)
#pragma section(".CRT$XLZ",long,read)
#pragma section(".CRT$XPA",long,read)
#pragma section(".CRT$XPX",long,read)
#pragma section(".CRT$XPZ",long,read)
#pragma section(".CRT$XTA",long,read)
#pragma section(".CRT$XTB",long,read)
#pragma section(".CRT$XTX",long,read)
#pragma section(".CRT$XTZ",long,read)
#pragma section(".rdata$T",long,read)

#define _CRTALLOC(x) __declspec(allocate(x))

#else   /* ndef _M_IA64 */

#define _CRTALLOC(x)

#endif  /* ndef _M_IA64 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\recover.cpp ===
#include "stdinc.h"
#include "xmlparser.hxx"
#include "FusionEventLog.h"
#include "hashfile.h"
#include "CAssemblyRecoveryInfo.h"
#include "recover.h"
#include "sxsprotect.h"
#include "fusionheap.h"
#include "fusionparser.h"
#include "protectionui.h"
#include "parsing.h"
#include "msi.h"

#define WINSXS_INSTALLATION_INFO_REGKEY  ( ASSEMBLY_REGISTRY_ROOT L"\\Installations")

class CSetErrorMode
{
public:
    CSetErrorMode(UINT uMode) { m_uiPreviousMode = ::SetErrorMode(uMode); }
    ~CSetErrorMode() { ::SetErrorMode(m_uiPreviousMode); }

private:
    UINT m_uiPreviousMode;

    CSetErrorMode();
    CSetErrorMode(const CSetErrorMode &r);
    void operator =(const CSetErrorMode &r);
};

BOOL
SxspOpenAssemblyInstallationKey(
    DWORD dwFlags,
    DWORD dwAccess,
    CRegKey &rhkAssemblyInstallation
    )
{
    FN_PROLOG_WIN32

    rhkAssemblyInstallation = CRegKey::GetInvalidValue();

    PARAMETER_CHECK(dwFlags == 0);

    IFREGFAILED_ORIGINATE_AND_EXIT(
        ::RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            WINSXS_INSTALLATION_INFO_REGKEY,
            0, NULL,
            0,
            dwAccess | FUSIONP_KEY_WOW64_64KEY,
            NULL,
            &rhkAssemblyInstallation ,
            NULL));

    FN_EPILOG
    
}


BOOL
SxspSaveAssemblyRegistryData(
    DWORD Flags,
    IN PCASSEMBLY_IDENTITY pcAssemblyIdentity
    )
{
    FN_PROLOG_WIN32

    CFusionRegKey hkAllInstallInfo;
    CFusionRegKey hkAssemblyKey;
    CSmallStringBuffer buffRegKeyName;
    CStringBuffer buffTargetFile;
    BOOL fTempFlag;
    CTokenPrivilegeAdjuster Adjuster;

    PARAMETER_CHECK(Flags == 0);

    IFW32FALSE_EXIT(Adjuster.Initialize());
    IFW32FALSE_EXIT(Adjuster.AddPrivilege(L"SeBackupPrivilege"));
    IFW32FALSE_EXIT(Adjuster.EnablePrivileges());
    
    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0, KEY_ALL_ACCESS, hkAllInstallInfo));
    IFW32FALSE_EXIT(SxspGenerateAssemblyNameInRegistry(pcAssemblyIdentity, buffRegKeyName));

    //
    // Generate the path of this target file.  This could move into SxspGenerateSxsPath,
    // but that's really gross looking and error prone... the last thing I want to do
    // is break it..
    //
    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffTargetFile));
    IFW32FALSE_EXIT(buffTargetFile.Win32AppendPathElement(
        REGISTRY_BACKUP_ROOT_DIRECTORY_NAME,
        REGISTRY_BACKUP_ROOT_DIRECTORY_NAME_CCH ));

    //
    // Ensure the target path is there, don't fail if the path exists
    //
    IFW32FALSE_EXIT_UNLESS2( CreateDirectoryW(buffTargetFile, NULL),
        { ERROR_ALREADY_EXISTS },
        fTempFlag );
        
    IFW32FALSE_EXIT(buffTargetFile.Win32AppendPathElement(buffRegKeyName));

    //
    // Now open the target subkey
    //
    IFW32FALSE_EXIT(hkAllInstallInfo.OpenSubKey(
        hkAssemblyKey,
        buffRegKeyName,
        KEY_ALL_ACCESS,
        REG_OPTION_BACKUP_RESTORE ) );

    //
    // Ensure the target path is there
    //

    //
    // And blort it out
    //
    DeleteFileW(buffTargetFile);
    IFW32FALSE_EXIT(hkAssemblyKey.Save(buffTargetFile));

    IFW32FALSE_EXIT(Adjuster.DisablePrivileges());

    FN_EPILOG
}


//
// BUGBUG: The BBT folk need the 'codebase' key to be at the top level.
//   Why we're shipping metadata that's only required for an internal
//   build tool is beyond my meager understanding.
//   - jonwis 07/11/2002
//
#define SXS_BBT_REG_HACK (TRUE)


BOOL
SxspAddAssemblyInstallationInfo(
    DWORD dwFlags, 
    IN CAssemblyRecoveryInfo& AssemblyInfo,
    IN const CCodebaseInformation& rcCodebase
    )
/*++

Called by SxsInstallAssemblyW to add the codebase and prompt information to the
registry for future use with SxspGetAssemblyInstallationInfoW.

--*/
{
    FN_PROLOG_WIN32

    CFusionRegKey   hkAllInstallationInfo;
    CFusionRegKey   hkSingleAssemblyInfo;
    CStringBuffer   buffRegKeyName;
    const CSecurityMetaData &rcsmdAssemblySecurityData = AssemblyInfo.GetSecurityInformation();
    const CBaseStringBuffer &rcbuffAssemblyIdentity = rcsmdAssemblySecurityData.GetTextualIdentity();
    
    DWORD   dwDisposition;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS: %s - starting\n", __FUNCTION__);

    PARAMETER_CHECK((dwFlags & ~(SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH)) == 0);

    //
    // Create or open the top-level key - take our name and append the
    // key to it.
    //
    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0, KEY_CREATE_SUB_KEY, hkAllInstallationInfo));

    //
    // Convert back to an identity so we can figure out where to install this data to
    //
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(rcbuffAssemblyIdentity, buffRegKeyName));

    IFW32FALSE_EXIT(
        hkAllInstallationInfo.OpenOrCreateSubKey(
            hkSingleAssemblyInfo,
            buffRegKeyName,
            KEY_WRITE | KEY_READ | FUSIONP_KEY_WOW64_64KEY,
            0,
            &dwDisposition));

    ULONG WriteRegFlags;
    WriteRegFlags = 0;
    if (dwFlags & SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH)
    {
        WriteRegFlags |= SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_TO_REGISTRY_KEY_FLAG_REFRESH;
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - propping recovery flag to WritePrimaryAssemblyInfoToRegistryKey\n",
            __FUNCTION__);
#endif
    }

    IFW32FALSE_EXIT(AssemblyInfo.PrepareForWriting());
    IFW32FALSE_EXIT(AssemblyInfo.WritePrimaryAssemblyInfoToRegistryKey(WriteRegFlags, hkSingleAssemblyInfo));    
    IFW32FALSE_EXIT(AssemblyInfo.WriteSecondaryAssemblyInfoIntoRegistryKey( hkSingleAssemblyInfo ) );

    //
    // If we got this far, then we've got all the right moves.
    //

//
// Are we still being broken for BBT?  If so, then write the codebase generated for this
// installation back into the "Codebase" value of the single-assembly-info key.  This
// ensures last-installer-wins semantic.
//
#if SXS_BBT_REG_HACK
    if ((dwFlags & SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH) == 0)
    {
        IFW32FALSE_EXIT(hkSingleAssemblyInfo.SetValue(
            CSMD_TOPLEVEL_CODEBASE,
            rcCodebase.GetCodebase()));
    }
    else
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - refresh/wfp/sfc not writing top level codebase\n",
            __FUNCTION__);
#endif
    }
#endif

    FN_EPILOG
}

BOOL
SxspLookForCDROMLocalPathForURL(
    IN const CBaseStringBuffer &rbuffURL,
    OUT CBaseStringBuffer &rbuffLocalPath
    )
{
    FN_PROLOG_WIN32

    BOOL fFoundMedia = FALSE;
    CSmallStringBuffer sbIdentData1, sbIdentData2;
    CSmallStringBuffer buffDriveStrings;
    CSmallStringBuffer buffTemp;
    CStringBufferAccessor acc;
    SIZE_T HeadLength = 0;
    PCWSTR wcsCursor = NULL;
    ULONG ulSerialNumber = 0;
    WCHAR rgchVolumeName[MAX_PATH];
    SIZE_T i;
    PCWSTR pszSource = rbuffURL;
    SIZE_T cchTemp;

    enum CDRomSearchType
    {
        CDRST_Tagfile,
        CDRST_SerialNumber,
        CDRST_VolumeName
    } SearchType;


    rbuffLocalPath.Clear();

#define ENTRY(_x, _st) { _x, NUMBER_OF(_x) - 1, _st },

    const static struct
    {
        PCWSTR pszPrefix;
        SIZE_T cchPrefix;
        CDRomSearchType SearchType;
    } s_rgMap[] =
    {
        ENTRY(L"tagfile", CDRST_Tagfile)
        ENTRY(L"serialnumber", CDRST_SerialNumber)
        ENTRY(L"volumename", CDRST_VolumeName)
    };

#undef ENTRY

    SearchType = CDRST_Tagfile; // arbitrary initialization to make compiler happy about init only
                                // occurring in the for loop

    for (i=0; i<NUMBER_OF(s_rgMap); i++)
    {
        if (::_wcsnicmp(s_rgMap[i].pszPrefix, rbuffURL, s_rgMap[i].cchPrefix) == 0)
        {
            HeadLength = s_rgMap[i].cchPrefix;
            SearchType = s_rgMap[i].SearchType;
            break;
        }
    }

    // If it wasn't in the map, it's a bogus cdrom: url so we just skip it.
    if (i == NUMBER_OF(s_rgMap))
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: %s() - no prefix found, skipping CDROM Drive %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffURL));
#endif
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Get the type of identifier here, and then move the cursor past them and
    // the slashes in the url.
    //
    pszSource += HeadLength;
    pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());

    //
    // Spin past slashes, assign chunklets
    //
    IFW32FALSE_EXIT(sbIdentData1.Win32Assign(pszSource, wcscspn(pszSource, CUnicodeCharTraits::PathSeparators())));
    pszSource += sbIdentData1.Cch();
    pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());

    //
    // If this is a tagfile, also get another blobbet of data off the string
    //
    if (SearchType == CDRST_Tagfile)
    {
        IFW32FALSE_EXIT(sbIdentData2.Win32Assign(pszSource, wcscspn(pszSource, CUnicodeCharTraits::PathSeparators())));
        pszSource += sbIdentData2.Cch();
        pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());
    }
    else if (SearchType == CDRST_SerialNumber)
    {
        IFW32FALSE_EXIT(CFusionParser::ParseULONG(
            ulSerialNumber,
            sbIdentData1,
            sbIdentData1.Cch(),
            16));
    }

    // Find the CDROM drives...

    IFW32ZERO_ORIGINATE_AND_EXIT(cchTemp = ::GetLogicalDriveStringsW(0, NULL));
    IFW32FALSE_EXIT(buffDriveStrings.Win32ResizeBuffer(cchTemp + 1, eDoNotPreserveBufferContents));

    acc.Attach(&buffDriveStrings);

    IFW32ZERO_ORIGINATE_AND_EXIT(
        ::GetLogicalDriveStringsW(
            acc.GetBufferCchAsDWORD(),
            acc));

    acc.Detach();

    wcsCursor = buffDriveStrings;

    //
    // Look at all the found drive letters
    //
    while ((wcsCursor != NULL) &&
           (wcsCursor[0] != L'\0') &&
           !fFoundMedia)
    {
        DWORD dwSerialNumber;
        const UINT uiDriveType = ::GetDriveTypeW(wcsCursor);

        if (uiDriveType != DRIVE_CDROM)
        {
            wcsCursor += (::wcslen(wcsCursor) + 1);
            continue;
        }

        CSetErrorMode sem(SEM_FAILCRITICALERRORS);
        bool fNotReady;

        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS2(
            ::GetVolumeInformationW(
                wcsCursor,
                rgchVolumeName,
                NUMBER_OF(rgchVolumeName),
                &dwSerialNumber,
                NULL,
                NULL,
                NULL,
                0),
            LIST_2(ERROR_NOT_READY, ERROR_CRC),
            fNotReady);

        if (fNotReady)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS.DLL: %s() - CDROM Drive %ls has no media present or had read errors; skipping\n",
                __FUNCTION__,
                wcsCursor);

            // skip past this drive
            wcsCursor += (::wcslen(wcsCursor) + 1);
            continue;
        }

        switch (SearchType)
        {
        case CDRST_Tagfile:
            {
                CFusionFile     FileHandle;
                CStringBufferAccessor acc;
                DWORD           dwTextLength;
                bool fNoFile;
                CHAR rgchBuffer[32];

                IFW32FALSE_EXIT_UNLESS2(
                    FileHandle.Win32CreateFile(
                        sbIdentData1,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        OPEN_EXISTING),
                    LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_NOT_READY),
                    fNoFile);

                if (fNoFile)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP,
                        "SXS.DLL: %s() - CDROM Drive %ls could not open tag file \"%ls\"; skipping\n",
                        __FUNCTION__,
                        wcsCursor,
                        static_cast<PCWSTR>(sbIdentData1));

                    // skip past this drive
                    wcsCursor += (::wcslen(wcsCursor) + 1);
                    continue;
                }

                buffTemp.Clear();

                for (;;)
                {
                    IFW32FALSE_ORIGINATE_AND_EXIT(
                        ::ReadFile(
                            FileHandle,
                            rgchBuffer,
                            sizeof(rgchBuffer),
                            &dwTextLength,
                            NULL));

                    IFW32FALSE_EXIT(buffTemp.Win32Append(rgchBuffer, dwTextLength));

                    if ((dwTextLength != sizeof(rgchBuffer)) ||
                        (buffTemp.Cch() > sbIdentData2.Cch()))
                        break;
                }

                fFoundMedia = (::FusionpCompareStrings(buffTemp, sbIdentData2, true) == 0);

                break;
            }
        case CDRST_SerialNumber:
            fFoundMedia = (dwSerialNumber == ulSerialNumber);
            break;

        case CDRST_VolumeName:
            fFoundMedia = (::FusionpCompareStrings(rgchVolumeName, ::wcslen(rgchVolumeName), sbIdentData1, true) == 0);
            break;

        default:
            INTERNAL_ERROR_CHECK(false);
            break;
        }

        if (!fFoundMedia)
            wcsCursor += ::wcslen(wcsCursor) + 1;
    }

    if (fFoundMedia)
    {
        IFW32FALSE_EXIT(buffTemp.Win32Assign(wcsCursor, ::wcslen(wcsCursor)));
        IFW32FALSE_EXIT(buffTemp.Win32AppendPathElement(pszSource, ::wcslen(pszSource)));
        IFW32FALSE_EXIT(rbuffLocalPath.Win32Assign(buffTemp));
    }

    FN_EPILOG
}

BOOL
SxspResolveWinSourceMediaURL(
    const CBaseStringBuffer &rbuffCodebaseInfo,
    CBaseStringBuffer &rbuffLocalPath
    )
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffWindowsInstallSource;
    CSmallStringBuffer buffLocalPathTemp;
#if DBG
    CSmallStringBuffer buffLocalPathCodebasePrefix;
#endif
    DWORD dwWin32Error;
    DWORD dwFileAttributes;

    const static PCWSTR AssemblySourceStrings[] = {
        WINSXS_INSTALL_SVCPACK_REGKEY,
        WINSXS_INSTALL_SOURCEPATH_REGKEY
    };

    SIZE_T iWhichSource = 0;
    bool fFoundCodebase = false;
    CFusionRegKey hkSetupInfo;
    DWORD dwWasFromCDRom = 0;

    rbuffLocalPath.Clear();

    IFREGFAILED_ORIGINATE_AND_EXIT(
        ::RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            WINSXS_INSTALL_SOURCE_BASEDIR,
            0,
            KEY_READ | FUSIONP_KEY_WOW64_64KEY,
            &hkSetupInfo));

    if (!::FusionpRegQueryDwordValueEx(
            0,
            hkSetupInfo,
            WINSXS_INSTALL_SOURCE_IS_CDROM,
            &dwWasFromCDRom))
    {
        dwWasFromCDRom = 0;
    }

    for (iWhichSource = 0; (!fFoundCodebase) && iWhichSource < NUMBER_OF(AssemblySourceStrings); iWhichSource++)
    {
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hkSetupInfo,
                AssemblySourceStrings[iWhichSource],
                buffWindowsInstallSource));

        //
        // This really _really_ should not be empty.  If it is, then someone
        // went and fiddled with the registry on us.
        //
        if (buffWindowsInstallSource.Cch() == 0)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - skipping use of source string \"%ls\" in registry because either missing or null value\n",
                __FUNCTION__,
                AssemblySourceStrings[iWhichSource]);

            continue;
        }

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS: %s - WFP probing windows source location \"%ls\"\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffWindowsInstallSource));

        //
        // If this was from a CD, then spin through the list of CD's in the system
        // and see if we can match the codebase against the root dir of the CD
        //
        if (dwWasFromCDRom)
        {
            CSmallStringBuffer buffDriveStrings;
            CStringBufferAccessor acc;
            PCWSTR pszCursor;
            SIZE_T cchTemp;

            IFW32ZERO_EXIT(cchTemp = ::GetLogicalDriveStringsW(0, NULL));
            IFW32FALSE_EXIT(buffDriveStrings.Win32ResizeBuffer(cchTemp + 1, eDoNotPreserveBufferContents));

            acc.Attach(&buffDriveStrings);

            IFW32ZERO_EXIT(
                ::GetLogicalDriveStringsW(
                    acc.GetBufferCchAsDWORD(),
                    acc.GetBufferPtr()));

            acc.Detach();

            pszCursor = buffDriveStrings;

            while (pszCursor[0] != L'\0')
            {
                if (::GetDriveTypeW(pszCursor) == DRIVE_CDROM)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP,
                        "SXS: %s - Scanning CDROM drive \"%ls\" for windows source media\n",
                        __FUNCTION__,
                        pszCursor);

                    IFW32FALSE_EXIT(buffLocalPathTemp.Win32Assign(pszCursor, ::wcslen(pszCursor)));
                    IFW32FALSE_EXIT(buffLocalPathTemp.Win32AppendPathElement(rbuffCodebaseInfo));

                    IFW32FALSE_EXIT(
                        ::SxspGetFileAttributesW(
                            buffLocalPathTemp,
                            dwFileAttributes,
                            dwWin32Error,
                            4,
                            ERROR_FILE_NOT_FOUND,
                            ERROR_PATH_NOT_FOUND,
                            ERROR_NOT_READY,
                            ERROR_ACCESS_DENIED));

                    if (dwWin32Error == ERROR_SUCCESS)
                    {
#if DBG
                        buffLocalPathCodebasePrefix.Win32Assign(pszCursor, ::wcslen(pszCursor));
#endif
                        fFoundCodebase = true;
                        break;
                    }

                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP,
                        "SXS: %s - Could not find key file \"%ls\"; moving on to next drive\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(buffLocalPathTemp));
                }

                pszCursor += ::wcslen(pszCursor) + 1;
            }

            if (fFoundCodebase)
                break;

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - Could not find any CDROMs with key file \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(rbuffCodebaseInfo));

            buffLocalPathTemp.Clear();
        }
        else
        {
            //
            // This wasn't a CD-rom installation, so prepend the install source path to
            // the string that was passed in.
            //

            IFW32FALSE_EXIT(buffLocalPathTemp.Win32Assign(buffWindowsInstallSource));
            IFW32FALSE_EXIT(buffLocalPathTemp.Win32AppendPathElement(rbuffCodebaseInfo));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - trying to access windows source file \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffLocalPathTemp));

            IFW32FALSE_EXIT(
                ::SxspGetFileAttributesW(
                    buffLocalPathTemp,
                    dwFileAttributes,
                    dwWin32Error,
                    4,
                    ERROR_FILE_NOT_FOUND,
                    ERROR_PATH_NOT_FOUND,
                    ERROR_NOT_READY,
                    ERROR_ACCESS_DENIED));

            if (dwWin32Error == ERROR_SUCCESS)
            {
#if DBG
                buffLocalPathCodebasePrefix.Win32Assign(buffWindowsInstallSource);
#endif
                fFoundCodebase = true;
                break;
            }

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - Unable to find key file \"%ls\"; win32 status = %lu\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffLocalPathTemp),
                dwWin32Error);

            buffLocalPathTemp.Clear();
        }
        if (fFoundCodebase)
            break;
    }

    IFW32FALSE_EXIT(rbuffLocalPath.Win32Assign(buffLocalPathTemp));

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s - buffLocalPathCodebasePrefix \"%ls\" and returning rbuffLocalPath \"%ls\"\n",
        __FUNCTION__,
        static_cast<PCWSTR>(buffLocalPathCodebasePrefix),
        static_cast<PCWSTR>(rbuffLocalPath)
        );
#endif

    FN_EPILOG
}


#define SXSP_REPEAT_UNTIL_LOCAL_PATH_AVAILABLE_FLAG_UI (0x00000001)

BOOL
SxspRepeatUntilLocalPathAvailable(
    IN ULONG Flags,
    IN const CAssemblyRecoveryInfo &rRecoveryInfo,
    IN const CCodebaseInformation  *pCodeBaseIn,
    IN SxsWFPResolveCodebase CodebaseType,
    IN const CBaseStringBuffer &rbuffCodebaseInfo,
    OUT CBaseStringBuffer &rbuffLocalPath,
    OUT BOOL              &fRetryPressed
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    BOOL fCodebaseOk = FALSE;
    CSmallStringBuffer buffFinalLocalPath;
    DWORD dwAttributes;

    PARAMETER_CHECK(pCodeBaseIn != NULL);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s - got codebase \"%ls\"\n",
        __FUNCTION__,
        static_cast<PCWSTR>(pCodeBaseIn->GetCodebase()));

    rbuffLocalPath.Clear();
    fRetryPressed = FALSE;


    PARAMETER_CHECK(
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_FILE) ||
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_WINSOURCE) ||
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_CDROM));

    PARAMETER_CHECK((Flags & ~(SXSP_REPEAT_UNTIL_LOCAL_PATH_AVAILABLE_FLAG_UI)) == 0);

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s() CodebaseType : %s (0x%lx)\n",
            __FUNCTION__,
            (CodebaseType == CODEBASE_RESOLVED_URLHEAD_FILE) ? "file"
            : (CodebaseType == CODEBASE_RESOLVED_URLHEAD_WINSOURCE) ? "winsource"
            : (CodebaseType == CODEBASE_RESOLVED_URLHEAD_CDROM) ? "cdrom"
            : "",
            static_cast<ULONG>(CodebaseType)
        );
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s() rbuffCodebaseInfo : %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffCodebaseInfo)
        );
#endif

    for (;;)
    {
        bool fNotFound = true;

        // First, let's see if we have to do any trickery.
        switch (CodebaseType)
        {
        case CODEBASE_RESOLVED_URLHEAD_CDROM:
            IFW32FALSE_EXIT(
                ::SxspLookForCDROMLocalPathForURL(
                    rbuffCodebaseInfo,
                    buffFinalLocalPath));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - cdrom: URL resolved to \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffFinalLocalPath));

            break;

        case CODEBASE_RESOLVED_URLHEAD_WINSOURCE:
            IFW32FALSE_EXIT(
                ::SxspResolveWinSourceMediaURL(
                    rbuffCodebaseInfo,
                    buffFinalLocalPath));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - windows source URL resolved to \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffFinalLocalPath));

            break;

        case CODEBASE_RESOLVED_URLHEAD_FILE:
            IFW32FALSE_EXIT(buffFinalLocalPath.Win32Assign(rbuffCodebaseInfo));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - file: URL resolved to \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffFinalLocalPath));

            break;
        }

        if (buffFinalLocalPath.Cch() != 0)
        {
            DWORD dwWin32Error = NO_ERROR;

            IFW32FALSE_EXIT(
                ::SxspGetFileAttributesW(
                    buffFinalLocalPath,
                    dwAttributes,
                    dwWin32Error,
                    5,
                        ERROR_PATH_NOT_FOUND,
                        ERROR_FILE_NOT_FOUND,
                        ERROR_BAD_NET_NAME,
                        ERROR_BAD_NETPATH,
                        ERROR_ACCESS_DENIED));

            if (dwWin32Error == ERROR_SUCCESS)
                break;
        }

        if ((Flags & SXSP_REPEAT_UNTIL_LOCAL_PATH_AVAILABLE_FLAG_UI) == 0)
        {
            buffFinalLocalPath.Clear();
            break;
        }

        //
        // Nope, didn't find it (or the codebase specified is gone.  Ask the user
        // to insert media or whatnot so we can find it again.
        //
        if (fNotFound)
        {
            CSXSMediaPromptDialog PromptBox;
            CSXSMediaPromptDialog::DialogResults result;

            IFW32FALSE_EXIT(PromptBox.Initialize(pCodeBaseIn));

            IFW32FALSE_EXIT(PromptBox.ShowSelf(result));

            if (result == CSXSMediaPromptDialog::DialogCancelled)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - user cancelled media prompt dialog\n",
                    __FUNCTION__);

                buffFinalLocalPath.Clear();
                break;
            }

            // Otherwise, try again!
            fRetryPressed = TRUE;
            break;
        }
    }

    IFW32FALSE_EXIT(rbuffLocalPath.Win32Assign(buffFinalLocalPath));

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s - returning rbuffLocalPath \"%ls\"\n",
        __FUNCTION__,
        static_cast<PCWSTR>(rbuffLocalPath)
        );
#endif

    FN_EPILOG
}

BOOL
SxspAskDarwinDoReinstall(
    IN PCWSTR buffLocalPath)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    UINT (WINAPI * pfnMsiProvideAssemblyW)(
        LPCWSTR wzAssemblyName,
        LPCWSTR szAppContext,
        DWORD dwInstallMode,
        DWORD dwUnused,
        LPWSTR lpPathBuf,
        DWORD *pcchPathBuf) = NULL;

    INSTALLUILEVEL (WINAPI * pfnMsiSetInternalUI)(
        INSTALLUILEVEL  dwUILevel,     // UI level
        HWND  *phWnd)                   // handle of owner window
         = NULL;

    INSTALLUILEVEL OldInstallUILevel;
    CDynamicLinkLibrary hMSIDll;

    //
    // We should hoist the load/unload out of the loop.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(hMSIDll.Win32LoadLibrary(L"msi.dll"));
    IFW32NULL_ORIGINATE_AND_EXIT(hMSIDll.Win32GetProcAddress("MsiProvideAssemblyW", &pfnMsiProvideAssemblyW));
    IFW32NULL_ORIGINATE_AND_EXIT(hMSIDll.Win32GetProcAddress("MsiSetInternalUI", &pfnMsiSetInternalUI));

    // No real failure from this API...
    OldInstallUILevel = (*pfnMsiSetInternalUI)(INSTALLUILEVEL_NONE, NULL);
    IFREGFAILED_ORIGINATE_AND_EXIT((*pfnMsiProvideAssemblyW)(buffLocalPath, NULL, REINSTALLMODE_FILEREPLACE, MSIASSEMBLYINFO_WIN32ASSEMBLY, NULL, NULL));
    // and restore it
    (*pfnMsiSetInternalUI)(OldInstallUILevel, NULL);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxspRecoverAssembly(
    IN const CAssemblyRecoveryInfo &AsmRecoveryInfo,
    IN CRecoveryCopyQueue *pRecoveryQueue,
    OUT SxsRecoveryResult &rStatus
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmallStringBuffer sbPerTypeCodebaseString;
    SxsWFPResolveCodebase CodebaseType;
    SXS_INSTALLW Install = { sizeof(SXS_INSTALLW) };
    Install.dwFlags |= SXS_INSTALL_FLAG_REPLACE_EXISTING;
    bool fNotFound = false;
    CCodebaseInformationList::ConstIterator CodebaseIterator;
    const CCodebaseInformationList& CodebaseList = AsmRecoveryInfo.GetCodeBaseList();
    ULONG RetryNumber = 0;
    BOOL  fRetryPressed = FALSE;
    ULONG RetryPressedCount = 0;

    rStatus = Recover_Unknown;

    //
    // As long as they hit retry, keep putting up the ui, cycling through the paths.
    //
    for (RetryNumber = 0 ; (rStatus != Recover_OK) && RetryNumber != 3 ; RetryNumber += (fRetryPressed ? 0 : 1))
    {
        for (CodebaseIterator = CodebaseList.Begin() ; (rStatus != Recover_OK) && CodebaseIterator != CodebaseList.End() ; ++CodebaseIterator)
        {
            fRetryPressed = FALSE;

            //
            // eg:
            // xcopy /fiver \\winbuilds\release\main\usa\latest.idw\x86fre\pro\i386 x:\blah\blah\i386
            //
            //  buffLocalPath                    x:\blah\blah\i386\asms\1000\msft\windows\gdiplus\gdiplus.man
            //  buffLocalPathCodebasePrefix      x:\blah\blah
            //  buffCodebaseMetaPrefix           x-ms-windows://
            //  buffCodebaseTail                 \i386\asms\1000\msft\windows\gdiplus\gdiplus.man.
            //
            //  Install.lpCodeBaseUrl            x:\blah\blah
            //  Install.lpManifestPath           x:\blah\blah\i386\asms\1000\msft\windows\gdiplus\gdiplus.man
            //

            CSmallStringBuffer buffLocalPath;
            CSmallStringBuffer buffCodebaseTail;

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - beginning recovery of assembly directory \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(AsmRecoveryInfo.GetAssemblyDirectoryName()));

            //
            // Go try and get the codebase resolved
            //

            rStatus = Recover_Unknown;

            IFW32FALSE_EXIT(
                ::SxspDetermineCodebaseType(
                    // this should be cached in m_CodebaseInfo.
                    CodebaseIterator->GetCodebase(),
                    CodebaseType,
                    &buffCodebaseTail));
                    
            if (CodebaseType == CODEBASE_RESOLVED_URLHEAD_UNKNOWN)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - Couldn't figure out what to do with codebase \"%ls\"; skipping\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(CodebaseIterator->GetCodebase()));

                rStatus = Recover_SourceMissing;
                continue;
            }

            if (!::SxspRepeatUntilLocalPathAvailable(
                    (RetryNumber == 2 && (CodebaseIterator == (CodebaseList.Begin() + (RetryPressedCount % CodebaseList.GetSize()))))
                        ? SXSP_REPEAT_UNTIL_LOCAL_PATH_AVAILABLE_FLAG_UI : 0,
                    AsmRecoveryInfo, &*CodebaseIterator, CodebaseType, buffCodebaseTail, buffLocalPath, fRetryPressed))
            {
                continue;
            }
            if (fRetryPressed)
                RetryPressedCount += 1;

            if (buffLocalPath.Cch() == 0 )
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - unable to resolve codebase \"%ls\" to a local path\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(CodebaseIterator->GetCodebase()));

                rStatus = Recover_ManifestMissing;
                continue;
            }

            Install.lpManifestPath = buffLocalPath;
            Install.dwFlags |= SXS_INSTALL_FLAG_REFRESH;

            IFW32FALSE_EXIT_UNLESS2(
                ::SxsInstallW(&Install),
                LIST_2(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND),
                fNotFound);

            if (fNotFound)
            {
                rStatus = Recover_ManifestMissing; // may also be a file in the assembly missing

                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - installation from %ls failed with win32 last error = %ld\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(buffLocalPath),
                    ::FusionpGetLastWin32Error());
                continue;
            }
            else
            {
                rStatus = Recover_OK;
                break;
            }
        }

        //
        // Last chance - try MSI reinstallation
        //
        if ( rStatus != Recover_OK )
        {
            BOOL fMsiKnowsAssembly = FALSE;
            const CBaseStringBuffer &rcbuffIdentity = AsmRecoveryInfo.GetSecurityInformation().GetTextualIdentity();
            
            IFW32FALSE_EXIT(SxspDoesMSIStillNeedAssembly( rcbuffIdentity, fMsiKnowsAssembly));

            if ( fMsiKnowsAssembly && ::SxspAskDarwinDoReinstall(rcbuffIdentity))
            {
                rStatus = Recover_OK;
                break;
            }
        }
        
    }
    fSuccess = TRUE;
Exit:
    CSxsPreserveLastError ple;

    //
    // Here we have to check something.  If the assembly wasn't able to be reinstalled,
    // then we do the following:
    //
    // 1. Rename away old assembly directory to .old or similar
    // 2. Log a message to the event log
    //

    DWORD dwMessageToPrint = 0;

    if (rStatus != Recover_OK)
    {
        dwMessageToPrint = MSG_SXS_SFC_ASSEMBLY_RESTORE_FAILED;
    }
    else
    {
        dwMessageToPrint = MSG_SXS_SFC_ASSEMBLY_RESTORE_SUCCESS;
    }

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS.DLL: %s: Recovery of assembly \"%ls\" resulted in fSuccess=%d rStatus=%d\n",
        __FUNCTION__,
        static_cast<PCWSTR>(AsmRecoveryInfo.GetAssemblyDirectoryName()),
        fSuccess,
        rStatus);

    ::FusionpLogError(
        dwMessageToPrint,
        CUnicodeString(AsmRecoveryInfo.GetAssemblyDirectoryName()));

    ple.Restore();

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\simplefp.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SimpleFp.cpp

Abstract:

    simple file pointer, to replace msvcrt.dll

Author:

    Xiaoyu Wu(xiaoyuw) July 2000

Revision History:

--*/
#include "stdinc.h"
#include "simplefp.h"
#include "fusiontrace.h"
#include "csxspreservelasterror.h"
#include "util.h"

CSimpleFileStream::CSimpleFileStream(PCSTR pFileName)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!pFileName)
    {
        // duplicate it so we can close it like normal
        HANDLE hFile = GetStdHandle(STD_ERROR_HANDLE);
        IFW32FALSE_ORIGINATE_AND_EXIT(::DuplicateHandle(::GetCurrentProcess(), hFile, ::GetCurrentProcess(), &m_hFile, 0, FALSE, DUPLICATE_SAME_ACCESS));
    }
    else
    {
        IFCOMFAILED_EXIT(this->fopen(pFileName));
    }
    fSuccess = FALSE;
Exit:
    ;
}

CSimpleFileStream::~CSimpleFileStream()
{
    if ( m_hFile != INVALID_HANDLE_VALUE) // if it is GetStdHandle, Could I close the handle?
    {
        CSxsPreserveLastError ple;
        this->fclose();
        ple.Restore();
    }
}

HRESULT
CSimpleFileStream::fopen(
    PCSTR pFileName
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    if ( m_hFile != INVALID_HANDLE_VALUE)
    {
        IFCOMFAILED_EXIT(this->fclose());
    }

    IFW32INVALIDHANDLE_ORIGINATE_AND_EXIT(
        m_hFile = ::CreateFileA(
            pFileName,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            0,
            NULL));

    FN_EPILOG
}

HRESULT
CSimpleFileStream::fclose()
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        IFCOMFAILED_EXIT(E_UNEXPECTED);
    }

    IFW32FALSE_ORIGINATE_AND_EXIT(::CloseHandle(m_hFile));

    hr = NOERROR;
Exit:
    m_hFile = INVALID_HANDLE_VALUE; // avoid the destructor to call it repeatly
    return hr;
}

HRESULT
CSimpleFileStream::fprintf(
    const char *format,
    ...
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    va_list ap;
    char rgchBuffer[2048];
    int cchIn = 0;
    DWORD cchWritten = 0;

    ASSERT(m_hFile != INVALID_HANDLE_VALUE);

    if ( m_hFile == INVALID_HANDLE_VALUE)
        IFCOMFAILED_EXIT(E_UNEXPECTED);

    va_start(ap, format);
    cchIn = _vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer) - 1, format, ap);
    rgchBuffer[NUMBER_OF(rgchBuffer) - 1] = 0;
    va_end(ap);
    if (cchIn < 0)
        IFCOMFAILED_EXIT(E_UNEXPECTED);

    IFW32FALSE_ORIGINATE_AND_EXIT(::WriteFile(m_hFile, rgchBuffer, cchIn, &cchWritten, NULL));

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT CSimpleFileStream::fwrite(const VOID* pData, SIZE_T itemsize, SIZE_T itemcount)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    SIZE_T count = 0;
    DWORD ByteWritten = 0;

    ASSERT(m_hFile != INVALID_HANDLE_VALUE);

    if ( m_hFile == INVALID_HANDLE_VALUE)
        IFCOMFAILED_EXIT(E_UNEXPECTED);

    count = itemsize * itemcount;

    while (count > ULONG_MAX)
    {
        IFW32FALSE_ORIGINATE_AND_EXIT(::WriteFile(m_hFile, pData, ULONG_MAX, &ByteWritten, NULL));
        count -= ULONG_MAX;
    }
    if (count != 0)
    {
        IFW32FALSE_ORIGINATE_AND_EXIT(::WriteFile(m_hFile, pData, static_cast<DWORD>(count), &ByteWritten, NULL));
    }

    hr = NOERROR;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sources.inc ===
!IF 0
Copyright (c) 1989-2001  Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

SOURCES_USED=$(SOURCES_USED) ..\sources.inc

TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)
TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)sxs1

INCLUDES= \
 ..; \
 $(FUSION_INC_PATH); \
 $(FUSION_PATH)\xmlparser; \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\eventlog\$(FUSION_BUILD_LEAF_DIRECTORY)\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(INCLUDES); \
 $(COM_INC_PATH); \
 $(ADMIN_INC_PATH)

C_DEFINES=$(C_DEFINES) -DSXSP_EXTENSIBLE_CONTRIBUTORS=0

SOURCES=\
 ..\actctxctb.cpp \
 ..\actctxgen.cpp \
 ..\actctxgenctxctb.cpp \
 ..\asmmetadata.cpp \
 ..\assemblyreference.cpp \
 ..\cassemblyrecoveryinfo.cpp \
 ..\cmemorystream.cpp \
 ..\comclass.cpp \
 ..\comclsidmap.cpp \
 ..\comgoop.cpp \
 ..\cominterface.cpp \
 ..\comprogid.cpp \
 ..\comtypelib.cpp \
 ..\cresourcestream.cpp \
 ..\csecuritymetadata.cpp \
 ..\cstreamtap.cpp \
 ..\cteestream.cpp \
 ..\dllredir.cpp \
 ..\dumpers.cpp \
 ..\fileoper.cpp \
 ..\filestream.cpp \
 ..\gsgenctx.cpp \
 ..\guidsectgen.cpp \
 ..\sxsuninstall.cpp \
 ..\hashfile.cpp \
 ..\sxsclrhelpers.cpp 

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdinc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sources_2.inc ===
!IF 0
Copyright (c) 1989-2001  Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

SOURCES_USED=$(SOURCES_USED) ..\sources_2.inc

TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)
TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)sxs2

INCLUDES= \
 ..; \
 $(FUSION_INC_PATH); \
 $(FUSION_PATH)\xmlparser; \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\eventlog\$(FUSION_BUILD_LEAF_DIRECTORY)\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(INCLUDES); \
 $(COM_INC_PATH)

C_DEFINES=$(C_DEFINES) -DSXSP_EXTENSIBLE_CONTRIBUTORS=0

SOURCES=\
 ..\nodefactory.cpp \
 ..\recover.cpp \
 ..\parsepolicy.cpp \
 ..\parsing.cpp \
 ..\partialassemblyversion.cpp \
 ..\pendingassembly.cpp \
 ..\policystatement.cpp \
 ..\probedassemblyinformation.cpp \
 ..\protectionui.cpp \
 ..\purevirt.cpp \
 ..\query.cpp \
 ..\simplefp.cpp \
 ..\ssgenctx.cpp \
 ..\strongname.cpp \
 ..\strsectgen.cpp \
 ..\sxsactctx.cpp \
 ..\sxsasmcache.cpp \
 ..\sxsasmname.cpp \
 ..\sxsasmitem.cpp \
 ..\sxsdebug.cpp \
 ..\sxsinstall.cpp \
 ..\sxsntrtl.cpp \
 ..\sxspath.cpp \
 ..\sxsprobe.cpp \
 ..\sxsprotect.cpp \
 ..\sxssfcscan.cpp \
 ..\sxsxmltree.cpp \
 ..\util.cpp \
 ..\windowclass.cpp \
 ..\ndpclassinfo.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdinc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\recover.h ===
#pragma once

#include "FusionArray.h"
#include "SxsApi.h"
#include "CSecurityMetaData.h"

#define SXSRECOVER_MODE_MASK        ( 0x0000000F )
#define SXSRECOVER_NOTHING          ( 0x00000000 )
#define SXSRECOVER_MANIFEST         ( 0x00000001 )
#define SXSRECOVER_ASSEMBLYMEMBER   ( 0x00000002 )
#define SXSRECOVER_FULL_ASSEMBLY    ( SXSRECOVER_ASSEMBLYMEMBER | SXSRECOVER_MANIFEST )

enum SxsRecoveryResult
{
    Recover_OK,
    Recover_ManifestMissing,
    Recover_CatalogInvalid,
    Recover_OneOrMoreFailed,
    Recover_SourceMissing,
    Recover_Unknown
};

#if DBG
#define ENUM_TO_STRING( x ) case x: return (L#x)

inline static PCWSTR SxspRecoveryResultToString( const SxsRecoveryResult r )
{
    switch ( r )
    {
        ENUM_TO_STRING( Recover_OK );
        ENUM_TO_STRING( Recover_ManifestMissing );
        ENUM_TO_STRING( Recover_CatalogInvalid );
        ENUM_TO_STRING( Recover_OneOrMoreFailed );
        ENUM_TO_STRING( Recover_SourceMissing );
        ENUM_TO_STRING( Recover_Unknown );
    }

    return L"Bad SxsRecoveryResult value";
}
#undef ENUM_TO_STRING
#endif

class CAssemblyRecoveryInfo;


class CRecoveryCopyQueue;

BOOL
SxspOpenAssemblyInstallationKey(
    DWORD dwFlags,
    DWORD dwAccess,
    CRegKey &rhkAssemblyInstallation
    );

BOOL
SxspRecoverAssembly(
    IN          const CAssemblyRecoveryInfo &AsmRecoverInfo,
    IN          CRecoveryCopyQueue *pRecoveryQueue,
    OUT         SxsRecoveryResult &rStatus
    );


#define SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH (0x00000001)
BOOL
SxspAddAssemblyInstallationInfo(
    DWORD dwFlags,
    IN CAssemblyRecoveryInfo& rcAssemblyInfo,
    IN const CCodebaseInformation& rcCodebaeInfo
    );

class CRecoveryCopyQueue
{
private:
    __declspec(align(16))
    SLIST_HEADER                m_PostCopyList;
    BOOL                        m_bDoingOwnCopies;
    CStringBuffer               m_sbAssemblyInstallRoot;
    CFusionArray<CStringBuffer> m_EligbleCopies;

    //
    // As the copy callback is triggered, we get pairs of source/destination
    // strings that indicate where files should be copied.  These get stored
    // in the m_PostCopyList queue, and consumed in the queue flush.  As part
    // of the installation callback, we validate that the file being copied to
    // does in fact match the hash stored in the m_pValidateTable, if it is
    // non-null.
    //
    class CQueueElement : public SINGLE_LIST_ENTRY
    {
    public:
        CStringBuffer sbSource;
        CStringBuffer sbDestination;

    private:
        CQueueElement(const CQueueElement &);
        void operator =(const CQueueElement &);
    };

    BOOL InternalCopyCallback(PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS);

public:
    CRecoveryCopyQueue(bool bDoOwnCopies = true);
    ~CRecoveryCopyQueue();

    BOOL Initialize();

    //
    // This is in the setup phase - indicate that this item is to be copied
    // over as part of the protection copy progress.  This entry is the assembly-
    // relative name of the file in question.
    //
    BOOL AddRecoveryItem(const CBaseStringBuffer &rsbItem);
    BOOL AddRecoveryItem(const CBaseStringBuffer *prgsbItems, SIZE_T cItems);

    //
    // Callback used by the copy queue functionality
    //
    static BOOL WINAPI staticCopyCallback(PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS);

    //
    // After the assembly install process completes, this function is called by
    // SxspRecoverAssembly to do the actual copies of stuff.
    //
    BOOL FlushPending( BOOL &bFullCopyQueueRecovered );

private:
    CRecoveryCopyQueue(const CRecoveryCopyQueue &);
    void operator =(const CRecoveryCopyQueue &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\simplefp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SimpleFp.h

Abstract:

    simple FILE*, instead of msvcrt.dll

Author:

    Xiaoyu Wu(xiaoyuw) July 2000

Revision History:

--*/
#pragma once

#include <stdio.h>

class CSimpleFileStream
{
public:
    HRESULT fopen(PCSTR pFileName); // can be a file name, "stderr", "stdout"
    HRESULT fclose();
    static HRESULT printf(const WCHAR *format, ...)
    {
        HRESULT hr = NOERROR;
        va_list ap;
        WCHAR rgchBuffer[2048];
        int cch;
        DWORD cchWritten;

        va_start(ap, format);
        cch = _vsnwprintf(rgchBuffer, NUMBER_OF(rgchBuffer), format, ap);
        rgchBuffer[NUMBER_OF(rgchBuffer) - 1] = 0;
        va_end(ap);
        if (cch < 0) {// error case
            hr = E_UNEXPECTED;
            goto Exit;
        }

        if( !WriteConsole(GetStdHandle(STD_ERROR_HANDLE), rgchBuffer, cch, &cchWritten, NULL)){
            DWORD dwError = ::FusionpGetLastWin32Error();
            hr = HRESULT_FROM_WIN32(dwError);
            goto Exit;
        }

        hr = NOERROR;
Exit :
        return hr;
     }

    HRESULT fprintf(const char *format, ...);
    HRESULT fwrite(const VOID*, SIZE_T, SIZE_T);

    CSimpleFileStream(PCSTR pFileName);
    ~CSimpleFileStream();

private:
    HANDLE m_hFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sources_1.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

FUSION_BUILD_HALF_NUMBER=1
!include ..\sources.inc

SOURCES=\
 ..\actctxctb.cpp \
 ..\actctxgen.cpp \
 ..\actctxgenctxctb.cpp \
 ..\asmmetadata.cpp \
 ..\assemblyreference.cpp \
 ..\cassemblyrecoveryinfo.cpp \
 ..\cmemorystream.cpp \
 ..\comclass.cpp \
 ..\comclsidmap.cpp \
 ..\comgoop.cpp \
 ..\cominterface.cpp \
 ..\comprogid.cpp \
 ..\comtypelib.cpp \
 ..\cresourcestream.cpp \
 ..\csecuritymetadata.cpp \
 ..\cstreamtap.cpp \
 ..\cteestream.cpp \
 ..\dllredir.cpp \
 ..\dumpers.cpp \
 ..\fileoper.cpp \
 ..\filestream.cpp \
 ..\gsgenctx.cpp \
 ..\guidsectgen.cpp \
 ..\sxsuninstall.cpp \
 ..\hashfile.cpp \
 ..\sxsclrhelpers.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\ssgenctx.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ssgenctx.h

Abstract:

    Class definition for the string section generation context object.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#if !defined(_FUSION_SSGENCTX_H_INCLUDED_)
#define _FUSION_SSGENCTX_H_INCLUDED_

#pragma once

class CSSGenCtx
{
public:
    static BOOL Create(
                PSTRING_SECTION_GENERATION_CONTEXT *SSGenContext,
                ULONG DataFormatVersion,
                BOOL CaseInSensitive,
                STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
                PVOID CallbackContext
                );

    BOOL Add(PCWSTR String, SIZE_T Cch, PVOID DataContext, ULONG AssemblyRosterIndex, DWORD DuplicateErrorCode);
    BOOL Find(PCWSTR String, SIZE_T Cch, PVOID *DataContext, BOOL *Found);
    BOOL DoneAdding();
    BOOL GetSectionSize(PSIZE_T SectionSize);
    BOOL GetSectionData(SIZE_T BufferSize, PVOID Buffer, SIZE_T *BytesWritten);
    PVOID GetCallbackContext() { return m_CallbackContext; }

    VOID DeleteYourself() { FUSION_DELETE_SINGLETON(this); }

    ~CSSGenCtx();
protected:
    CSSGenCtx();

    static int __cdecl CompareStringSectionEntries(const void *elem1, const void *elem2);

    STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION m_CallbackFunction;
    PVOID m_CallbackContext;

    class Entry
    {
    public:
        Entry() : m_PseudoKey(0), m_DataContext(NULL), m_Next(NULL) { }
        ~Entry() { }

        BOOL Initialize(PCWSTR String, SIZE_T Cch, ULONG PseudoKey, PVOID DataContext, ULONG AssemblyRosterIndex);
        BOOL GetEntryDataSize(CSSGenCtx *pSSGenCtx, SIZE_T &rSize);
        BOOL GetEntryData(CSSGenCtx *pSSGenCtx, SIZE_T BufferSize, PVOID Buffer, SIZE_T *BytesWritten);

        CStringBuffer m_StringBuffer;
        ULONG m_PseudoKey;
        ULONG m_HashBucketIndex;
        LONG m_EntryOffset;
        PVOID m_DataContext;
        Entry *m_Next;
        ULONG m_AssemblyRosterIndex;
    private:
        Entry(const Entry &);
        void operator =(const Entry &);
    };

    friend Entry;

    ULONG m_EntryCount;
    Entry *m_FirstEntry;
    Entry *m_LastEntry;
    ULONG m_DataFormatVersion;
    bool m_CaseInSensitive;
    ULONG m_HashTableSize;
    bool m_DoneAdding;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\ssgenctx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ssgenctx.cpp

Abstract:

    String section generation context object implementation.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "ssgenctx.h"

typedef struct _CALLBACKDATA
{
    union
    {
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE GetDataSize;
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA GetData;
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED EntryDeleted;
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE GetUserDataSize;
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA GetUserData;
    } u;
} CALLBACKDATA, *PCALLBACKDATA;

BOOL CSSGenCtx::Create(
    PSTRING_SECTION_GENERATION_CONTEXT *SSGenContext,
    ULONG DataFormatVersion,
    BOOL CaseInSensitive,
    STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    PVOID CallbackContext
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSSGenCtx *pSSGenCtx;

    IFALLOCFAILED_EXIT(pSSGenCtx = new CSSGenCtx);
    pSSGenCtx->m_CallbackFunction = CallbackFunction;
    pSSGenCtx->m_CallbackContext = CallbackContext;
    pSSGenCtx->m_CaseInSensitive = (CaseInSensitive != FALSE);
    pSSGenCtx->m_DataFormatVersion = DataFormatVersion;

    *SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) pSSGenCtx;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

CSSGenCtx::CSSGenCtx() : m_DoneAdding(false)
{
    m_FirstEntry = NULL;
    m_LastEntry = NULL;
    m_EntryCount = 0;
    m_HashTableSize = 0;
}

CSSGenCtx::~CSSGenCtx()
{
    CSxsPreserveLastError ple;
    CALLBACKDATA CBData;

    Entry *pEntry = m_FirstEntry;

    while (pEntry != NULL)
    {
        Entry *pNext = pEntry->m_Next;

        CBData.u.EntryDeleted.DataContext = pEntry->m_DataContext;
        (*m_CallbackFunction)(
            m_CallbackContext,
            STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED,
            &CBData);

        FUSION_DELETE_SINGLETON(pEntry);
        pEntry = pNext;
    }

    ple.Restore();
}

BOOL
CSSGenCtx::Add(
    PCWSTR String,
    SIZE_T Cch,
    PVOID DataContext,
    ULONG AssemblyRosterIndex,
    DWORD DuplicateErrorCode
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG PseudoKey = 0;
    Entry *pEntry = NULL;

    PARAMETER_CHECK(DuplicateErrorCode != ERROR_SUCCESS);

    INTERNAL_ERROR_CHECK(!m_DoneAdding);

    if ((String != NULL) && (String[0] == L'\0'))
        String = NULL;

    IFW32FALSE_EXIT(::SxspHashString(String, Cch, &PseudoKey, m_CaseInSensitive));

    for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
    {
        if ((pEntry->m_PseudoKey == PseudoKey) &&
            (pEntry->m_StringBuffer.Cch() == Cch) &&
            (::FusionpCompareStrings(
                String,
                Cch,
                pEntry->m_StringBuffer,
                Cch,
                m_CaseInSensitive) == 0))
        {
            ::FusionpSetLastWin32Error(DuplicateErrorCode);
            pEntry = NULL;
            goto Exit;
        }
    }

    IFALLOCFAILED_EXIT(pEntry = new Entry);

    if (!pEntry->Initialize(String, Cch, PseudoKey, DataContext, AssemblyRosterIndex))
        goto Exit;

    if (m_LastEntry == NULL)
        m_FirstEntry = pEntry;
    else
        m_LastEntry->m_Next = pEntry;

    m_LastEntry = pEntry;

    pEntry = NULL;

    m_EntryCount++;

    fSuccess = TRUE;

Exit:
    FUSION_DELETE_SINGLETON(pEntry);
    return fSuccess;
}

BOOL
CSSGenCtx::Find(
    PCWSTR String,
    SIZE_T Cch,
    PVOID *DataContext,
    BOOL *Found
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG PseudoKey = 0;
    Entry *pEntry = NULL;

    if (DataContext != NULL)
        *DataContext = NULL;

    if (Found != NULL)
        *Found = FALSE;

    if ((String != NULL) && (String[0] == L'\0'))
        String = NULL;

    PARAMETER_CHECK(Found != NULL);
    PARAMETER_CHECK((Cch == 0) || (String != NULL));

    IFW32FALSE_EXIT(::SxspHashString(String, Cch, &PseudoKey, m_CaseInSensitive));

    for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
    {
        if ((pEntry->m_PseudoKey == PseudoKey) &&
            (pEntry->m_StringBuffer.Cch() == Cch) &&
            (::FusionpCompareStrings(
                String,
                Cch,
                pEntry->m_StringBuffer,
                Cch,
                m_CaseInSensitive) == 0))
            break;
    }

    if (pEntry != NULL)
    {
        *Found = TRUE;

        if (DataContext != NULL)
            *DataContext = pEntry->m_DataContext;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CSSGenCtx::DoneAdding()
{
    if (!m_DoneAdding)
    {
        // This is where to really figure out the optimal hash table size

        // first level guess...
        if (m_EntryCount < 3)
            m_HashTableSize = 0;
        else if (m_EntryCount < 15)
            m_HashTableSize = 3;
        else if (m_EntryCount < 100)
            m_HashTableSize = 11;
        else
            m_HashTableSize = 101;

        m_DoneAdding = true;
    }

    return TRUE;
}

BOOL
CSSGenCtx::GetSectionSize(
    PSIZE_T SizeOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T UserDataSize = 0;
    SIZE_T HeaderSize = 0;
    SIZE_T EntryListSize = 0;
    SIZE_T EntryDataSize = 0;
    SIZE_T StringsSize = 0;
    SIZE_T HashTableSize = 0;
    CALLBACKDATA CBData;
    Entry *pEntry = NULL;

    if (SizeOut != NULL)
        *SizeOut = 0;

    PARAMETER_CHECK(SizeOut != NULL);

    HeaderSize = sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER);

    if (m_HashTableSize != 0)
    {
        //
        // The data for the hash table includes:
        //
        //  1. a small fixed sized struct representing the metadata for the hash
        //      table (ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE)
        //
        //  2. For each table bucket, a small struct pointing to the beginning of
        //      the collision chain and the length of said chain
        //      (ACTIVATION_CONTEXT_SECTION_STRING_HASH_BUCKET)
        //
        //  3. One entry in a collision chain per entry in the table.  The entry
        //      is a LONG offset from the beginning of the section.
        //

        HashTableSize = sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE) +
            (m_HashTableSize * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET)) +
            (m_EntryCount * sizeof(LONG));
    }

    CBData.u.GetUserDataSize.DataSize = 0;
    (*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE, &CBData);
    UserDataSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserDataSize.DataSize);

    EntryListSize = m_EntryCount * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY);

    for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
    {
        CBData.u.GetDataSize.DataContext = pEntry->m_DataContext;
        CBData.u.GetDataSize.DataSize = 0;
        (*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE, &CBData);
        EntryDataSize += ROUND_ACTCTXDATA_SIZE(CBData.u.GetDataSize.DataSize);

        // Only allocate space for non-null strings.  If the null string is a key in the table,
        // it takes up 0 bytes.
        if (pEntry->m_StringBuffer.Cch() != 0)
            StringsSize += ROUND_ACTCTXDATA_SIZE((pEntry->m_StringBuffer.Cch() + 1) * sizeof(WCHAR));
    }

    // If there's nothing to contain, don't even ask for space for the header.
    if ((UserDataSize == 0) && (m_EntryCount == 0))
        *SizeOut = 0;
    else
        *SizeOut = HeaderSize + UserDataSize + EntryListSize + EntryDataSize + StringsSize + HashTableSize;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CSSGenCtx::GetSectionData(
    SIZE_T BufferSize,
    PVOID Buffer,
    PSIZE_T BytesWritten
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    SIZE_T BytesSoFar = 0;
    SIZE_T BytesLeft = BufferSize;
    PACTIVATION_CONTEXT_STRING_SECTION_HEADER Header;
    PACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE HashTable = NULL;
    PACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET HashBucket = NULL;
    PLONG HashCollisionChain = NULL;
    CALLBACKDATA CBData;
    PVOID Cursor = NULL;
    SIZE_T RoundedSize;

    if (BytesWritten != NULL)
        *BytesWritten = 0;

    if (BytesLeft < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER))
    {
        ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    Header = (PACTIVATION_CONTEXT_STRING_SECTION_HEADER) Buffer;

    Cursor = (PVOID) (Header + 1);

    Header->Magic = ACTIVATION_CONTEXT_STRING_SECTION_MAGIC;
    Header->HeaderSize = sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER);
    Header->FormatVersion = ACTIVATION_CONTEXT_STRING_SECTION_FORMAT_WHISTLER;
    Header->DataFormatVersion = m_DataFormatVersion;

    Header->Flags = 0;
    if (m_CaseInSensitive)
        Header->Flags |= ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE;

    Header->ElementCount = m_EntryCount;
    Header->ElementListOffset = 0; // filled in after we figure out the user data area
    Header->HashAlgorithm = SxspGetHashAlgorithm();
    Header->SearchStructureOffset = 0;
    Header->UserDataOffset = 0; // filled in below
    Header->UserDataSize = 0;

    BytesLeft -= sizeof(*Header);
    BytesSoFar += sizeof(*Header);

    CBData.u.GetUserDataSize.DataSize = 0;
    (*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE, &CBData);

    RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserDataSize.DataSize);

    if (RoundedSize > BytesLeft)
    {
        ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    if (RoundedSize != 0)
    {
        CBData.u.GetUserData.SectionHeader = Header;
        CBData.u.GetUserData.BufferSize = RoundedSize;
        CBData.u.GetUserData.Buffer = Cursor;
        CBData.u.GetUserData.BytesWritten = 0;

        (*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA, &CBData);

        ASSERT(CBData.u.GetUserData.BytesWritten <= RoundedSize);

        RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserData.BytesWritten);

        if (RoundedSize != 0)
        {
            BytesLeft -= RoundedSize;
            BytesSoFar += RoundedSize;

            Header->UserDataSize = static_cast<ULONG>(CBData.u.GetUserData.BytesWritten);
            Header->UserDataOffset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) Header));
            Cursor = (PVOID) (((ULONG_PTR) Cursor) + RoundedSize);
        }
    }

    // Finally the array of entries...

    if (m_EntryCount != 0)
    {
        PVOID DataCursor;
        PACTIVATION_CONTEXT_STRING_SECTION_ENTRY EntryArray;
        ULONG iEntry;
        Entry *SrcEntry;

        if (BytesLeft < (m_EntryCount * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY)))
        {
            ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        BytesLeft -= (m_EntryCount * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY));
        BytesSoFar += (m_EntryCount * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY));

        EntryArray = (PACTIVATION_CONTEXT_STRING_SECTION_ENTRY) Cursor;
        Header->ElementListOffset = static_cast<LONG>(((LONG_PTR) EntryArray) - ((LONG_PTR) Header));
        DataCursor = (PVOID) (EntryArray + m_EntryCount);
        SrcEntry = m_FirstEntry;

        iEntry = 0;

        while (SrcEntry != NULL)
        {
            // Record the offset to this entry; we use it later during hash table population
            SrcEntry->m_EntryOffset = static_cast<LONG>(((LONG_PTR) &EntryArray[iEntry]) - ((LONG_PTR) Header));

            EntryArray[iEntry].PseudoKey = SrcEntry->m_PseudoKey;
            EntryArray[iEntry].AssemblyRosterIndex = SrcEntry->m_AssemblyRosterIndex;

            if (SrcEntry->m_StringBuffer.Cch() != 0)
            {
                const USHORT Cb = static_cast<USHORT>((SrcEntry->m_StringBuffer.Cch() + 1) * sizeof(WCHAR));
                RoundedSize = ROUND_ACTCTXDATA_SIZE(Cb);

                if (BytesLeft < RoundedSize)
                {
                    ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                EntryArray[iEntry].KeyLength = Cb - sizeof(WCHAR);
                EntryArray[iEntry].KeyOffset = static_cast<LONG>(((LONG_PTR) DataCursor) - ((LONG_PTR) Header));

                memcpy(
                    DataCursor,
                    static_cast<PCWSTR>(SrcEntry->m_StringBuffer),
                    Cb);

                DataCursor = (PVOID) (((ULONG_PTR) DataCursor) + RoundedSize);

                BytesLeft -= Cb;
                BytesSoFar += Cb;
            }
            else
            {
                EntryArray[iEntry].KeyLength = 0;
                EntryArray[iEntry].KeyOffset = 0;
            }

            CBData.u.GetDataSize.DataContext = SrcEntry->m_DataContext;
            CBData.u.GetDataSize.DataSize = 0;

            (*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE, &CBData);

            if (CBData.u.GetDataSize.DataSize != 0)
            {
                RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetDataSize.DataSize);

                if (BytesLeft < RoundedSize)
                {
                    ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                CBData.u.GetData.SectionHeader = Header;
                CBData.u.GetData.DataContext = SrcEntry->m_DataContext;
                CBData.u.GetData.BufferSize = RoundedSize;
                CBData.u.GetData.Buffer = DataCursor;
                CBData.u.GetData.BytesWritten = 0;

                (*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA, &CBData);

                if (CBData.u.GetData.BytesWritten != 0)
                {
                    // If this assert fires, a contributor wrote past the bounds they
                    // were given.
                    ASSERT(CBData.u.GetData.BytesWritten <= RoundedSize);
                    if (CBData.u.GetData.BytesWritten > RoundedSize)
                    {
                        // Probably we have memory corruption, but at least we'll bail and
                        // avoid further scribbling on memory.
                        ::FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_ERROR,
                            "SXS.DLL: String section data generation callback wrote more bytes than it should have.  Bailing out and hoping memory isn't trashed.\n");

                        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
                        goto Exit;
                    }

                    RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetData.BytesWritten);

                    BytesLeft -= RoundedSize;
                    BytesSoFar += RoundedSize;

                    EntryArray[iEntry].Offset = static_cast<LONG>(((LONG_PTR) DataCursor) - ((LONG_PTR) Header));
                    EntryArray[iEntry].Length = static_cast<ULONG>(CBData.u.GetData.BytesWritten);

                    DataCursor = (PVOID) (((ULONG_PTR) DataCursor) + RoundedSize);
                }
                else
                {
                    EntryArray[iEntry].Offset = 0;
                    EntryArray[iEntry].Length = 0;
                }
            }
            else
            {
                EntryArray[iEntry].Offset = 0;
                EntryArray[iEntry].Length = 0;
            }

            SrcEntry = SrcEntry->m_Next;
            iEntry++;
        }

        ASSERT(iEntry == m_EntryCount);

        // If we're not generating a hash table, let's sort 'em.
        if (m_HashTableSize == 0)
        {
            qsort(EntryArray, m_EntryCount, sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY), &CSSGenCtx::CompareStringSectionEntries);
            Header->Flags |= ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER;
        }

        Cursor = (PVOID) DataCursor;
    }

    // Write the hash table at the end.  We do it here so that the placement of everything else is
    // already worked out.
    if (m_HashTableSize != 0)
    {
        ULONG iBucket;
        Entry *pEntry;
        ULONG cCollisions;

        if (BytesLeft < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE))
        {
            ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        HashTable = (PACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE) Cursor;
        Cursor = (PVOID) (HashTable + 1);

        BytesLeft -= sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE);
        BytesSoFar += sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE);

        if (BytesLeft < (m_HashTableSize * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET)))
        {
            ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        HashBucket = (PACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET) Cursor;
        Cursor = (PVOID) (HashBucket + m_HashTableSize);

        BytesLeft -= (m_HashTableSize * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET));
        BytesSoFar += (m_HashTableSize * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET));

        Header->SearchStructureOffset = static_cast<LONG>(((LONG_PTR) HashTable) - ((LONG_PTR) Header));
        HashTable->BucketTableEntryCount = m_HashTableSize;
        HashTable->BucketTableOffset = static_cast<LONG>(((LONG_PTR) HashBucket) - ((LONG_PTR) Header));

        if (BytesLeft < (m_EntryCount * sizeof(LONG)))
        {
            ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        HashCollisionChain = (PLONG) Cursor;
        Cursor = (PVOID) (HashCollisionChain + m_EntryCount);

        BytesLeft -= (m_EntryCount * sizeof(LONG));
        BytesSoFar += (m_EntryCount * sizeof(LONG));

        // In a disgusting move, we need to iterate over the hash buckets (not elements)
        // finding which entries would go into the bucket so that we can build up the
        // collision chain.

        for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
            pEntry->m_HashBucketIndex = pEntry->m_PseudoKey % m_HashTableSize;

        cCollisions = 0;

        for (iBucket=0; iBucket<m_HashTableSize; iBucket++)
        {
            bool fFirstForThisBucket = true;

            HashBucket[iBucket].ChainCount = 0;
            HashBucket[iBucket].ChainOffset = 0;

            for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
            {
                if (pEntry->m_HashBucketIndex == iBucket)
                {
                    if (fFirstForThisBucket)
                    {
                        HashBucket[iBucket].ChainOffset = static_cast<LONG>(((LONG_PTR) &HashCollisionChain[cCollisions]) - ((LONG_PTR) Header));
                        fFirstForThisBucket = false;
                    }
                    HashBucket[iBucket].ChainCount++;
                    HashCollisionChain[cCollisions++] = pEntry->m_EntryOffset;
                }
            }
        }
    }

    if (BytesWritten != NULL)
        *BytesWritten = BytesSoFar;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

int
__cdecl
CSSGenCtx::CompareStringSectionEntries(
    const void *elem1,
    const void *elem2
    )
{
    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY pEntry1 = reinterpret_cast<PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY>(elem1);
    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY pEntry2 = reinterpret_cast<PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY>(elem2);

    if (pEntry1->PseudoKey < pEntry2->PseudoKey)
        return -1;
    else if (pEntry1->PseudoKey == pEntry2->PseudoKey)
        return 0;

    return 1;
}


BOOL
CSSGenCtx::Entry::Initialize(
    PCWSTR String,
    SIZE_T Cch,
    ULONG PseudoKey,
    PVOID DataContext,
    ULONG AssemblyRosterIndex
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(m_StringBuffer.Win32Assign(String, Cch));
    m_DataContext = DataContext;
    m_PseudoKey = PseudoKey;
    m_AssemblyRosterIndex = AssemblyRosterIndex;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\stdinc.h ===
#pragma once
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#if FUSION_WIN2000
typedef unsigned short WORD;
typedef unsigned long DWORD;
#define _NTSLIST_DIRECT_ 1
#define NTSLIST_ASSERT(x) /* empty */
#include <ntslist.h>
#endif // FUSION_WIN2000
#include <windows.h>
#include <stdio.h>
#include <limits.h>
#include "fusionlastwin32error.h"
#include "fusionntdll.h"
#include "fusionunused.h"
#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#endif
#if !defined(MAXDWORD)
#define MAXDWORD (~(DWORD)0)
#endif

#include "sxsp.h"
#include "nodefactory.h"
#include "fusionbuffer.h"
#include "fusionhash.h"
#include "sxspath.h"
#include "probedassemblyinformation.h"

#include <ole2.h>
#include <xmlparser.h>
#include <wchar.h>
#include "filestream.h"
#include "fusionhandle.h"
#include "cteestream.h"
#include "cresourcestream.h"
#include "fusionxml.h"
#include "util.h"
#include "sxsexceptionhandling.h"
#include "csxspreservelasterror.h"
#include "smartptr.h"
#include "fusioneventlog.h"
#include "fusionstring.h"
#include "fusionparser.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "policystatement.h"
#include "smartptr.h"
#include "actctxgenctx.h"

#include <sxstypes.h>
#include <sxsapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\strongname.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    strongname.cpp

Abstract:

    Fusion Win32 implementation of the Fusion URT strong-name stuff

Author:

    Jon Wiswall (jonwis) 11-October-2000

Revision History:

    jonwis/7-November-2000: Added ability to find a strong name from a
        certificate context structure, as well as the ability to scan
        a catalog for strong names.  Also changed the way strong names
        are generated from a public key to be identically in-line with
        Fusion URT.

--*/

#include "stdinc.h"
#include "wincrypt.h"
#include "fusionbuffer.h"
#include "strongname.h"
#include "hashfile.h"
#include "Sxsp.h"

BOOL
SxspHashStringToBytes(
    PCWSTR hsHashString,
    SIZE_T cchHashString,
    CFusionArray<BYTE> &OutputBuffer
    )
{
    //
    // 2 here is not sizeof(WCHAR) it is how many digits a byte takes to print (or be scanned from,
    // as is actually happening here)
    //
    DWORD dwByteCount = static_cast<DWORD>(cchHashString) / 2;
    DWORD dwIdx = 0;
    int  iHi, iLo;
    BOOL bSuccess = FALSE;

    FN_TRACE_WIN32(bSuccess);

    //
    // We look on odd numbers with disdain.
    //
    PARAMETER_CHECK((cchHashString % 2) == 0);
    if ( OutputBuffer.GetSize() != dwByteCount )
    {
        IFW32FALSE_EXIT(OutputBuffer.Win32SetSize(dwByteCount, CFusionArray<BYTE>::eSetSizeModeExact));
    }

    //
    // Sneak through the list of characters and turn them into the
    // hi and lo nibbles per byte position, then write them into the
    // output buffer.
    //
    for (DWORD i = 0; (i < cchHashString) && (dwIdx < OutputBuffer.GetSize()); i += 2)
    {
        if (((iHi = SxspHexDigitToValue(hsHashString[i])) >= 0) &&
             ((iLo = SxspHexDigitToValue(hsHashString[i+1])) >= 0))
        {
            OutputBuffer[dwIdx++] = static_cast<BYTE>(((iHi & 0xF) << 4) | (iLo & 0xF));
        }
        else
        {
            // Something bad happened while trying to read from the string,
            // maybe it contained invalid values?
            goto Exit;
        }
    }

    bSuccess = TRUE;

Exit:
    return bSuccess;
}


inline VOID
pReverseByteString(PBYTE pbBytes, SIZE_T cbBytes)
{
    SIZE_T  index = 0;

    if (cbBytes-- == 0) return;

    while (index < cbBytes)
    {
        BYTE bLeft = pbBytes[index];
        BYTE bRight = pbBytes[cbBytes];
        pbBytes[index++] = bRight;
        pbBytes[cbBytes--] = bLeft;
    }
}

BOOL
SxspHashBytesToString(
    IN const BYTE*    pbSource,
    IN SIZE_T   cbSource,
    OUT CBaseStringBuffer &sbDestination
    )
{
    BOOL bSuccess = FALSE;
    DWORD i;
    PWSTR pwsCursor;
    static WCHAR HexCharList[] = L"0123456789abcdef";

    CStringBufferAccessor Accessor;

    FN_TRACE_WIN32(bSuccess);

    sbDestination.Clear();

    IFW32FALSE_EXIT(sbDestination.Win32ResizeBuffer((cbSource + 1) * 2, eDoNotPreserveBufferContents));

    Accessor.Attach(&sbDestination);
    pwsCursor = Accessor;
    for (i = 0; i < cbSource; i++)
    {
        pwsCursor[i*2]      = HexCharList[ (pbSource[i] >> 4) & 0x0F ];
        pwsCursor[i*2+1]    = HexCharList[ pbSource[i] & 0x0F ];
    }
    //
    // Because of the way string accessors and clear works, we have to clip off
    // the rest by a null character.  Odd, but it works.
    //
    pwsCursor[i*2] = L'\0';

    bSuccess = TRUE;
Exit:
    return bSuccess;
}

BOOL
SxspGetStrongNameOfKey(
    IN const CFusionArray<BYTE> &PublicKeyBits,
    OUT CFusionArray<BYTE> &StrongNameBits
    )
/*++

Note to posterity:

This implementation has been blessed by the Fusion URT people to be identically
in synch with their implementation.  Do _not_ change anything here unless you're
really sure there's a bug or there's a change in spec.  The basic operation of this
is as follows:

- Get crypto provider
- Create a SHA1 hash object from the crypto stuff
- Hash the data
- Extract the hash data into the output buffer
- Move the low order 8-bytes of the hash (bytes 11 through 19) down to 0-7
- Reverse the bytes to obtain a "network ordered" 64-bit string

The last two steps are the important thing - work with Rudi Martin (Fusion URT)
if you think there's a better way.

--*/
{
    FN_PROLOG_WIN32
    
    CFusionHash             hHash;
    PSXS_PUBLIC_KEY_INFO    pPubKeyInfo;

    PARAMETER_CHECK(PublicKeyBits.GetSize() >= sizeof(*pPubKeyInfo));

    //
    // Convert our pointer back for a second - it's a persisted version of this
    // structure anyhow.
    //
    pPubKeyInfo = (PSXS_PUBLIC_KEY_INFO)PublicKeyBits.GetArrayPtr();

    //
    // Make ourselves a hash object.
    //
    IFW32FALSE_EXIT(hHash.Win32Initialize(CALG_SHA1));

    //
    // Hash the actual data that we were passed in to generate the strong name.
    //
    IFW32FALSE_EXIT(
        hHash.Win32HashData(
            PublicKeyBits.GetArrayPtr(), 
            PublicKeyBits.GetSize()));

    //
    // Find out how big the hash data really is from what was hashed.
    //
    IFW32FALSE_EXIT(hHash.Win32GetValue(StrongNameBits));

    //
    // Move the last eight bytes of the hash downwards using memmove, because
    // it knows about things like overlapping blocks.
    //
    PBYTE pbBits = static_cast<PBYTE>(StrongNameBits.GetArrayPtr());
    ::RtlMoveMemory(
        pbBits,
        pbBits + (StrongNameBits.GetSize() - STRONG_NAME_BYTE_LENGTH),
        STRONG_NAME_BYTE_LENGTH);
    pReverseByteString(pbBits, STRONG_NAME_BYTE_LENGTH);

    IFW32FALSE_EXIT(StrongNameBits.Win32SetSize(STRONG_NAME_BYTE_LENGTH, CFusionArray<BYTE>::eSetSizeModeExact));

    FN_EPILOG
}



BOOL
SxspDoesStrongNameMatchKey(
    IN  const CBaseStringBuffer &rbuffKeyString,
    IN  const CBaseStringBuffer &rbuffStrongNameString,
    OUT BOOL                    &rfKeyMatchesStrongName
    )
{
    FN_PROLOG_WIN32

    CSmallStringBuffer  buffStrongNameCandidate;

    PARAMETER_CHECK(::SxspIsFullHexString(rbuffKeyString, rbuffKeyString.Cch()));
    PARAMETER_CHECK(::SxspIsFullHexString(rbuffStrongNameString, rbuffStrongNameString.Cch()));

    //
    // Convert the key over to its corresponding strong name
    //
    IFW32FALSE_EXIT(::SxspGetStrongNameOfKey(rbuffKeyString, buffStrongNameCandidate));

    //
    // And compare what the caller thinks it should be.
    //
    rfKeyMatchesStrongName = (::FusionpCompareStrings(
        rbuffStrongNameString,
        rbuffStrongNameString.Cch(),
        buffStrongNameCandidate,
        buffStrongNameCandidate.Cch(),
        false) == 0);


    FN_EPILOG
}



BOOL
SxspGetStrongNameOfKey(
    IN const CBaseStringBuffer &rbuffKeyString,
    OUT CBaseStringBuffer &sbStrongName
    )
{
    CFusionArray<BYTE> KeyBytes, StrongNameBytes;
    BOOL        bSuccess = FALSE;

    FN_TRACE_WIN32(bSuccess);

    //
    // Convert the string to bytes, generate the strong name, convert back to
    // a string.
    //
    IFW32FALSE_EXIT(::SxspHashStringToBytes(rbuffKeyString, rbuffKeyString.Cch(), KeyBytes));
    IFW32FALSE_EXIT(::SxspGetStrongNameOfKey(KeyBytes, StrongNameBytes));
    IFW32FALSE_EXIT(::SxspHashBytesToString(StrongNameBytes.GetArrayPtr(), StrongNameBytes.GetSize(), sbStrongName));

    bSuccess = TRUE;
Exit:
    return bSuccess;
}

BOOL
SxspAcquireStrongNameFromCertContext(
    CBaseStringBuffer &rbuffStrongNameString,
    CBaseStringBuffer &sbPublicKeyString,
    PCCERT_CONTEXT pCertContext
    )
/*++

Note to posterity:

This is the other "black magic" of the strong-name stuff.  Fusion URT takes whatever
CryptExportKey blops out, tacks on a magic header of their design (which I have
copied into SXS_PUBLIC_KEY_INFO), then hashes the whole thing.  This routine knows
how to interact with a pCertContext object (like one you'd get from a certificate
file or by walking through a catalog) and turn the certificate into a strong name
and public key blob.  The public key blob is returned in a hex string, and can
be converted back to bytes (for whatever purpose) via SxspHashStringToBytes.

Don't change anything you see below, unless there's a bug or there's been a spec
change.  If you've got problems with this file, please notify Jon Wiswall (jonwis)
and he'll be able to better help you with debugging or whatnot.

--*/
{
    BOOL                    bSuccess = FALSE;
    HCRYPTPROV              hCryptProv = NULL;
    HCRYPTHASH              hCryptHash = NULL;
    HCRYPTKEY               hCryptKey = NULL;
    BYTE                    bKeyInfo[2048] = { 0 };
    PSXS_PUBLIC_KEY_INFO    pKeyWrapping = reinterpret_cast<PSXS_PUBLIC_KEY_INFO>(bKeyInfo);
    DWORD                   dwDump;
    CFusionArray<BYTE>      bPublicKeyContainer;
    CFusionArray<BYTE>      bStrongNameContainer;

    FN_TRACE_WIN32(bSuccess);

    rbuffStrongNameString.Clear();
    sbPublicKeyString.Clear();

    //
    // Get a crypto context that only does RSA verification - ie, doesn't use private keys
    //
    IFW32FALSE_EXIT(::SxspAcquireGlobalCryptContext(&hCryptProv));

    //
    // Take the public key info that we found on this certificate context and blop it back
    // into a real internal crypto key.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::CryptImportPublicKeyInfoEx(
            hCryptProv,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            &(pCertContext->pCertInfo->SubjectPublicKeyInfo),
            CALG_RSA_SIGN,
            0,
            NULL,
            &hCryptKey));

    //
    // The stuff we swizzle will be about 200 bytes, so this is serious overkill
    // until such time as people start using 16384-bit keys.
    //
    pKeyWrapping->KeyLength =
        sizeof(bKeyInfo) - offsetof(SXS_PUBLIC_KEY_INFO, pbKeyInfo);

    //
    // Extract the key data from the crypto key back into a byte stream. This seems to
    // be what the fusion-urt people do, in order to get a byte string to hash.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(
        CryptExportKey(
            hCryptKey,
            NULL,
            PUBLICKEYBLOB,
            0,
            pKeyWrapping->pbKeyInfo,
            &pKeyWrapping->KeyLength));

    //
    // Sacred values from the fusion-urt people
    //
    pKeyWrapping->SigAlgID = CALG_RSA_SIGN;
    pKeyWrapping->HashAlgID = CALG_SHA1;

    dwDump = pKeyWrapping->KeyLength + offsetof(SXS_PUBLIC_KEY_INFO, pbKeyInfo);

    IFW32FALSE_EXIT(
        ::SxspHashBytesToString(
            reinterpret_cast<const BYTE*>(pKeyWrapping),
            dwDump,
            sbPublicKeyString));

    IFW32FALSE_EXIT(bPublicKeyContainer.Win32Assign(dwDump, bKeyInfo));

    IFW32FALSE_EXIT(
        ::SxspGetStrongNameOfKey(
            bPublicKeyContainer,
            bStrongNameContainer));

    INTERNAL_ERROR_CHECK(bStrongNameContainer.GetSize() == STRONG_NAME_BYTE_LENGTH);

    //
    // Great - this is the official strong name of the 2000 Fusolympics.
    //
    IFW32FALSE_EXIT(
        ::SxspHashBytesToString(
            bStrongNameContainer.GetArrayPtr(),
            STRONG_NAME_BYTE_LENGTH,
            rbuffStrongNameString));

    bSuccess = TRUE;

Exit:

    if (hCryptKey != NULL)        CryptDestroyKey(hCryptKey);
    if (hCryptHash != NULL)       CryptDestroyHash(hCryptHash);

    return bSuccess;
}



inline BOOL
SxspAreStrongNamesAllowedToNotMatchCatalogs(BOOL &bAllowed)
{
    //
    // This function is our back-door past the strong-name system while
    // Whistler is still in beta/rtm.  The test certificate, if installed,
    // indicates that it's ok to let strong names not match catalogs.
    //
    // The certificate data here is from \nt\admin\ntsetup\syssetup\crypto.c in
    // SetupAddOrRemoveTestCertificate.  Please ensure that this gets updated.
    //
    BOOL            fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CRYPT_HASH_BLOB HashBlob;
    HCERTSTORE      hSystemStore = NULL;
    PCCERT_CONTEXT  pCertContext = NULL;

    BYTE bTestRootHashList[][20] = {
        {0x2B, 0xD6, 0x3D, 0x28, 0xD7, 0xBC, 0xD0, 0xE2, 0x51, 0x19, 0x5A, 0xEB, 0x51, 0x92, 0x43, 0xC1, 0x31, 0x42, 0xEB, 0xC3}
    };

    bAllowed = FALSE;

    //
    // Cause the root store to be opened on the local machine.
    //
    IFW32NULL_ORIGINATE_AND_EXIT(
        hSystemStore = ::CertOpenStore(
            CERT_STORE_PROV_SYSTEM,
            X509_ASN_ENCODING,
            (HCRYPTPROV)NULL,
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            L"ROOT"));

    for (int i = 0; i < NUMBER_OF(bTestRootHashList); i++)
    {
        bool fNotFound;

        HashBlob.cbData = sizeof(bTestRootHashList[i]);
        HashBlob.pbData = bTestRootHashList[i];

        IFW32NULL_ORIGINATE_AND_EXIT_UNLESS2(
            pCertContext = ::CertFindCertificateInStore(
                hSystemStore,
                X509_ASN_ENCODING,
                0,
                CERT_FIND_HASH,
                &HashBlob,
                NULL),
            LIST_1(static_cast<DWORD>(CRYPT_E_NOT_FOUND)),
            fNotFound);

        if (pCertContext != NULL)
        {
            bAllowed = TRUE;
            break;
        }
    }

    if (!bAllowed)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s - no test certificate installed on machine\n",
            __FUNCTION__);
    }

    fSuccess = TRUE;
Exit:
    CSxsPreserveLastError ple;

    if (pCertContext) ::CertFreeCertificateContext(pCertContext);
    if (hSystemStore) ::CertCloseStore(hSystemStore, CERT_CLOSE_STORE_FORCE_FLAG);

    ple.Restore();

    return fSuccess;
}




CPublicKeyInformation::CPublicKeyInformation()
    : m_fInitialized(false)
{
}

CPublicKeyInformation::~CPublicKeyInformation()
{
}

BOOL
CPublicKeyInformation::GetStrongNameBytes(
    OUT CFusionArray<BYTE> & cbStrongNameBytes
) const
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(m_StrongNameBytes.Win32Clone(cbStrongNameBytes));

    FN_EPILOG
}

BOOL
CPublicKeyInformation::GetStrongNameString(
    OUT CBaseStringBuffer &rbuffStrongNameString
   ) const
{
    FN_PROLOG_WIN32

    rbuffStrongNameString.Clear();
    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(rbuffStrongNameString.Win32Assign(m_StrongNameString));

    FN_EPILOG
}

BOOL
CPublicKeyInformation::GetPublicKeyBitLength(
    OUT ULONG &ulKeyLength
) const
{
    BOOL fSuccess = FALSE;
    BOOL fLieAboutPublicKeyBitLength = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ulKeyLength = 0;

    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(::SxspAreStrongNamesAllowedToNotMatchCatalogs(fLieAboutPublicKeyBitLength));

    if (fLieAboutPublicKeyBitLength)
    {
#if DBG
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INFO,
            "SXS: %s() - Lying about key length because we're still in test mode (%lu actual, %lu spoofed.)\n",
            __FUNCTION__,
            m_KeyLength,
            SXS_MINIMAL_SIGNING_KEY_LENGTH);
#endif
        ulKeyLength = SXS_MINIMAL_SIGNING_KEY_LENGTH;
    }
    else
    {
        ulKeyLength = m_KeyLength;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
CPublicKeyInformation::GetWrappedPublicKeyBytes(
    OUT CFusionArray<BYTE> &bPublicKeybytes
) const
{
    FN_PROLOG_WIN32
    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(m_PublicKeyBytes.Win32Clone(bPublicKeybytes));
    FN_EPILOG
}

BOOL
CPublicKeyInformation::Initialize(
    IN const CBaseStringBuffer &rsbCatalogFile
    )
{
    BOOL        fSuccess = FALSE;
    CFusionFile       CatalogFile;

    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(m_CatalogSourceFileName.Win32Assign(rsbCatalogFile));

    IFW32FALSE_EXIT(
		CatalogFile.Win32CreateFile(
			rsbCatalogFile,
			GENERIC_READ,
			FILE_SHARE_READ,
			OPEN_EXISTING));

    IFW32FALSE_EXIT(this->Initialize(CatalogFile));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CPublicKeyInformation::Initialize(
    IN PCWSTR pszCatalogFile
    )
{
    BOOL fSuccess = FALSE;
    CFusionFile CatalogFile;

    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(m_CatalogSourceFileName.Win32Assign(pszCatalogFile, wcslen(pszCatalogFile)));

    IFW32FALSE_EXIT(
		CatalogFile.Win32CreateFile(
			pszCatalogFile,
			GENERIC_READ,
			FILE_SHARE_READ,
			OPEN_EXISTING));

    IFW32FALSE_EXIT(this->Initialize(CatalogFile));

    fSuccess = TRUE;
Exit:

    return fSuccess;
}

BOOL
CPublicKeyInformation::Initialize(
    IN CFusionFile& CatalogFileHandle
)
{
    BOOL                fSuccess = FALSE;
    CFileMapping        FileMapping;
    CMappedViewOfFile   MappedFileView;
    ULONGLONG           cbCatalogFile = 0;
    HCERTSTORE          hTempStore = NULL;
    PCCERT_CONTEXT      pSignerContext = NULL;
    PCCTL_CONTEXT       pContext = NULL;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(CatalogFileHandle != INVALID_HANDLE_VALUE);

    IFW32FALSE_EXIT(CatalogFileHandle.Win32GetSize(cbCatalogFile));
    IFW32FALSE_EXIT(FileMapping.Win32CreateFileMapping(CatalogFileHandle, PAGE_READONLY, cbCatalogFile, NULL));
    IFW32FALSE_EXIT(MappedFileView.Win32MapViewOfFile(FileMapping, FILE_MAP_READ, 0, (SIZE_T)cbCatalogFile));

    IFW32NULL_EXIT(pContext = (PCCTL_CONTEXT)CertCreateCTLContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        static_cast<const BYTE*>(static_cast<void*>(MappedFileView)),
        static_cast<DWORD>(cbCatalogFile)));

    hTempStore = pContext->hCertStore;
    IFW32FALSE_ORIGINATE_AND_EXIT(::CryptMsgGetAndVerifySigner(
        pContext->hCryptMsg,
        1,
        &hTempStore,
        0,
        &pSignerContext,
        NULL));

    // BUGBUG
    IFW32NULL_EXIT(pSignerContext);

    IFW32FALSE_EXIT(this->Initialize(pSignerContext));

    fSuccess = TRUE;
Exit:

    return fSuccess;
}



BOOL
CPublicKeyInformation::Initialize(IN PCCERT_CONTEXT pCertContext)
{
    BOOL                    fSuccess = FALSE;
    DWORD                   dwNameStringLength;
    CStringBufferAccessor   Access;
    FN_TRACE_WIN32(fSuccess);
    PARAMETER_CHECK(pCertContext != NULL);

    IFW32FALSE_EXIT(
        ::SxspAcquireStrongNameFromCertContext(
            m_StrongNameString,
            m_PublicKeyByteString,
            pCertContext));

    IFW32FALSE_EXIT(SxspHashStringToBytes(m_StrongNameString, m_StrongNameString.Cch(), m_StrongNameBytes));
    IFW32FALSE_EXIT(SxspHashStringToBytes(m_PublicKeyByteString, m_PublicKeyByteString.Cch(), m_PublicKeyBytes));
    IFW32ZERO_EXIT(m_KeyLength = CertGetPublicKeyLength(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        &pCertContext->pCertInfo->SubjectPublicKeyInfo));

    Access.Attach(&m_SignerDisplayName);

    dwNameStringLength = ::CertGetNameStringW(
        pCertContext,
        CERT_NAME_FRIENDLY_DISPLAY_TYPE,
        0,
        NULL,
        Access.GetBufferPtr(),
        static_cast<DWORD>(Access.GetBufferCch()));

    if (dwNameStringLength == 0)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(CertGetNameString);
        goto Exit;
    }

    if (dwNameStringLength > Access.GetBufferCch())
    {
        Access.Detach();
        IFW32FALSE_EXIT(m_SignerDisplayName.Win32ResizeBuffer(dwNameStringLength, eDoNotPreserveBufferContents));
        Access.Attach(&m_SignerDisplayName);

        dwNameStringLength = ::CertGetNameStringW(
            pCertContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            0,
            NULL,
            Access.GetBufferPtr(),
            static_cast<DWORD>(Access.GetBufferCch()));
    }

    Access.Detach();

    m_fInitialized = true;
    fSuccess = TRUE;
Exit:
    {
        CSxsPreserveLastError ple;
        if (pCertContext != NULL)
            ::CertFreeCertificateContext(pCertContext);

        ple.Restore();
    }
    return fSuccess;
}


BOOL
CPublicKeyInformation::GetSignerNiceName(
    OUT CBaseStringBuffer &rbuffName
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(rbuffName.Win32Assign(m_SignerDisplayName));

    FN_EPILOG
}



BOOL
CPublicKeyInformation::DoesStrongNameMatchSigner(
    IN const CBaseStringBuffer &rbuffTestStrongName,
    OUT BOOL &rfStrongNameMatchesSigner
   ) const
{
    BOOL    fSuccess = FALSE;
    BOOL    fCanStrongNameMismatch = FALSE;
    FN_TRACE_WIN32(fSuccess);

    rfStrongNameMatchesSigner = (::FusionpCompareStrings(
        rbuffTestStrongName,
        rbuffTestStrongName.Cch(),
        m_StrongNameString,
        m_StrongNameString.Cch(),
        false) == 0);

    if (!rfStrongNameMatchesSigner)
    {
        IFW32FALSE_EXIT(::SxspAreStrongNamesAllowedToNotMatchCatalogs(fCanStrongNameMismatch));

        if (fCanStrongNameMismatch)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS.DLL: %s - !!notice!! Strong name %ls not in catalog %ls, test code allows this\n"
                "                         Please make sure that you have tested with realsigned catalogs.\n",
                __FUNCTION__,
                static_cast<PCWSTR>(rbuffTestStrongName),
                static_cast<PCWSTR>(m_CatalogSourceFileName));

            rfStrongNameMatchesSigner = TRUE;
        }
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\strsectgen.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    strsectgen.cpp

Abstract:

    C-ish wrapper around CSSGenCtx object used to generate a string section.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "ssgenctx.h"

BOOL
SxsInitStringSectionGenerationContext(
    OUT PSTRING_SECTION_GENERATION_CONTEXT *SSGenContext,
    IN ULONG DataFormatVersion,
    IN BOOL CaseInSensitive,
    IN STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    IN LPVOID Context
    )
{
    return CSSGenCtx::Create(
            SSGenContext,
            DataFormatVersion,
            CaseInSensitive,
            CallbackFunction,
            Context);
}

PVOID
WINAPI
SxsGetStringSectionGenerationContextCallbackContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    )
{
    return ((CSSGenCtx *) SSGenContext)->GetCallbackContext();
}

VOID
WINAPI
SxsDestroyStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    )
{
    if (SSGenContext != NULL)
    {
        ((CSSGenCtx *) SSGenContext)->DeleteYourself();
    }
}

BOOL
WINAPI
SxsAddStringToStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN PCWSTR String,
    IN SIZE_T StringCch,
    IN PVOID DataContext,
    IN ULONG AssemblyRosterIndex,
    IN DWORD DuplicateErrorCode
    )
{
    return ((CSSGenCtx *) SSGenContext)->Add(String, StringCch, DataContext, AssemblyRosterIndex, DuplicateErrorCode);
}

BOOL
WINAPI
SxsFindStringInStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT PVOID *DataContext,
    OUT BOOL *Found
    )
{
    return ((CSSGenCtx *) SSGenContext)->Find(String, Cch, DataContext, Found);
}

BOOL
WINAPI
SxsDoneModifyingStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    )
{
    return ((CSSGenCtx *) SSGenContext)->DoneAdding();
}

BOOL
WINAPI
SxsGetStringSectionGenerationContextSectionSize(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    OUT PSIZE_T DataSize
    )
{
    return ((CSSGenCtx *) SSGenContext)->GetSectionSize(DataSize);
}

BOOL
WINAPI
SxsGetStringSectionGenerationContextSectionData(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT PSIZE_T BytesWritten OPTIONAL
    )
{
    return ((CSSGenCtx *) SSGenContext)->GetSectionData(BufferSize, Buffer, BytesWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsactctx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsactctx.cpp

Abstract:

    Implement SxsGenerateActivationContext, called from csrss.exe.

Author:

    Michael J. Grier (MGrier)

Revision History:

    Jay Krell (a-JayK) June 2000
        moved file opening from here (sxs.dll) to csrss.exe client process,
            pass ISequentialStreams to sxs.dll.

--*/
#include "stdinc.h"
#include <windows.h>
#include "sxsapi.h"
#include "sxsp.h"
#include "fusioneventlog.h"
#include "filestream.h"

// temporary dbprint reduction until we fix setup/comctl
static ULONG DbgPrintReduceLevel(ULONG FilterLevel)
{
    if (FilterLevel != FUSION_DBG_LEVEL_ERROR)
        return FilterLevel;
    LONG Error = ::FusionpGetLastWin32Error();
    if (Error == ERROR_FILE_NOT_FOUND || Error == ERROR_PATH_NOT_FOUND)
        return FUSION_DBG_LEVEL_ENTEREXIT;
    return FilterLevel;
}

static
VOID
DbgPrintSxsGenerateActivationContextParameters(
    ULONG FilterLevel,
    PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters,
    PCSTR Function
    )
{
    FilterLevel = DbgPrintReduceLevel(FilterLevel);
#if !DBG
    if (FilterLevel != FUSION_DBG_LEVEL_ERROR)
        return;
#endif
    FusionpDbgPrintEx(
        FilterLevel,
        "SXS: %s() failed Parameters %p{\n"
        "SXS:   Flags:                 0x%lx\n"
        "SXS:   ProcessorArchitecture: 0x%lx\n"
        "SXS:   LangId:                0x%lx\n"
        "SXS:   AssemblyDirectory:     %ls\n"
        "SXS:   TextualIdentity:       %ls\n"
        "SXS:   Manifest:              { %p, %ls }\n"
        "SXS:   Policy:                { %p, %ls }\n"
        "SXS: }\n",
        Function,
        Parameters,
        (Parameters != NULL) ? ULONG(Parameters->Flags) : 0,
        (Parameters != NULL) ? ULONG(Parameters->ProcessorArchitecture) : NULL,
        (Parameters != NULL) ? ULONG(Parameters->LangId) : NULL,
        (Parameters != NULL) ? Parameters->AssemblyDirectory : NULL,
        (Parameters != NULL) ? Parameters->TextualAssemblyIdentity : NULL,
        (Parameters != NULL) ? Parameters->Manifest.Stream : NULL,
        (Parameters != NULL) ? Parameters->Manifest.Path : NULL,
        (Parameters != NULL) ? Parameters->Policy.Stream : NULL,
        (Parameters != NULL) ? Parameters->Policy.Path : NULL);
}

extern "C"
BOOL
WINAPI
SxsGenerateActivationContext(
    PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    RTL_PATH_TYPE PathType;
    BOOL fSxspCloseManifestGraph = FALSE;
    CStringBuffer sbAssemblyDirectory;
    SMARTPTR(CFileStream) SystemDefaultManifestFileStream;
    ACTCTXGENCTX *pActCtxGenCtx = NULL;
    CSmallStringBuffer sbManifestFileName; // rarely used, mainly for system compatible assembly
    DWORD dwWin32Error;

#define IS_NT_DOS_PATH(_x) (((_x)[0] == L'\\') && ((_x)[1] == L'?') && ((_x)[2] == L'?') && ((_x)[3] == L'\\'))

    ::DbgPrintSxsGenerateActivationContextParameters(
        FUSION_DBG_LEVEL_ENTEREXIT,
        Parameters,
        __FUNCTION__);

    PARAMETER_CHECK(Parameters != NULL);
    IFALLOCFAILED_EXIT(pActCtxGenCtx = new ACTCTXGENCTX);

    {
        CImpersonationData ImpersonationData(Parameters->ImpersonationCallback, Parameters->ImpersonationContext);
        Parameters->SectionObjectHandle = NULL;

        IFINVALID_FLAGS_EXIT_WIN32(Parameters->Flags,
                                   SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY |
                                   SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY);

        PARAMETER_CHECK(Parameters->AssemblyDirectory != NULL);

        HARD_VERIFY(IS_NT_DOS_PATH(Parameters->AssemblyDirectory) == FALSE);

        if (Parameters->Flags &
            (SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY
            | SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY))
        {
            PARAMETER_CHECK(Parameters->TextualAssemblyIdentity != NULL);
            PARAMETER_CHECK(Parameters->Manifest.Stream == NULL);
            PARAMETER_CHECK(Parameters->Policy.Stream == NULL);
            //
            // If basesrv passes in a textual assembly identity, we have to create stream for manifest from here !
            //
            BOOL fOpenManifestFailed = FALSE;

            IFW32FALSE_EXIT(sbAssemblyDirectory.Win32Assign(Parameters->AssemblyDirectory, ::wcslen(Parameters->AssemblyDirectory)));

            IFW32FALSE_EXIT(::SxspCreateManifestFileNameFromTextualString(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
                sbAssemblyDirectory,
                Parameters->TextualAssemblyIdentity,
                sbManifestFileName));
            IFW32FALSE_EXIT(SystemDefaultManifestFileStream.Win32Allocate(__FILE__, __LINE__));

            IFW32FALSE_EXIT(SystemDefaultManifestFileStream->OpenForRead(
                sbManifestFileName,               
                CImpersonationData(),FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, // default value for parameters
                dwWin32Error,
                4, 
                ERROR_FILE_NOT_FOUND, 
                ERROR_PATH_NOT_FOUND,
                ERROR_BAD_NETPATH,
                ERROR_BAD_NET_NAME));

            if (dwWin32Error != ERROR_SUCCESS)
            {
                Parameters->SystemDefaultActCxtGenerationResult = BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_NOT_FOUND;
                FN_SUCCESSFUL_EXIT();
            }

            if (Parameters->Manifest.Path == NULL)
                Parameters->Manifest.Path = sbManifestFileName;

            Parameters->Manifest.Stream = SystemDefaultManifestFileStream;
        }
        else
        {
            PARAMETER_CHECK(Parameters->Manifest.Stream != NULL);
        }




        if (Parameters->Manifest.Path != NULL)
        {
            HARD_VERIFY(IS_NT_DOS_PATH(Parameters->Manifest.Path) == FALSE);
        }

        if (Parameters->Policy.Path != NULL)
        {
            HARD_VERIFY(IS_NT_DOS_PATH(Parameters->Policy.Path) == FALSE);
        }

        PathType = ::SxspDetermineDosPathNameType(Parameters->AssemblyDirectory);
        PARAMETER_CHECK((PathType == RtlPathTypeUncAbsolute) ||
                              (PathType == RtlPathTypeLocalDevice) ||
                              (PathType == RtlPathTypeDriveAbsolute) ||
                              (PathType == RtlPathTypeDriveRelative));

        // Ensure that there's a trailing slash...
        IFW32FALSE_EXIT(sbAssemblyDirectory.Win32Assign(Parameters->AssemblyDirectory, ::wcslen(Parameters->AssemblyDirectory)));
        IFW32FALSE_EXIT(sbAssemblyDirectory.Win32EnsureTrailingPathSeparator());

        Parameters->AssemblyDirectory = sbAssemblyDirectory;

        // Allocate and initialize the activation context generation context
        IFW32FALSE_EXIT(
            ::SxspInitActCtxGenCtx(
                pActCtxGenCtx,                  // context out
                MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT,
                0,                              // general flags
                0,                              // operation-specific flags
                ImpersonationData,
                Parameters->ProcessorArchitecture,
                Parameters->LangId,
                ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
                ::wcslen(Parameters->AssemblyDirectory),
                Parameters->AssemblyDirectory));

        if (Parameters->Policy.Stream != NULL)
        {
            SIZE_T cchPolicyPath = (Parameters->Policy.Path != NULL) ? ::wcslen(Parameters->Policy.Path): 0;

            // Do the policy thing...
            IFW32FALSE_EXIT(
                ::SxspParseApplicationPolicy(
                    0,
                    pActCtxGenCtx,
                    ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
                    Parameters->Policy.Path,
                    cchPolicyPath,
                    Parameters->Policy.Stream));
        }

        // Add this manifest (and its policy file) to the context
        IFW32FALSE_EXIT(
            ::SxspAddRootManifestToActCtxGenCtx(
                pActCtxGenCtx,
                Parameters));

        // Add its dependencies, and their dependencies, etc. until there's nothing more to add
        IFW32FALSE_EXIT_UNLESS(
            ::SxspCloseManifestGraph(pActCtxGenCtx),
                ((Parameters->Flags & SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY) && (::FusionpGetLastWin32Error() == ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED)),
                fSxspCloseManifestGraph);

        if (fSxspCloseManifestGraph)
        {
            Parameters->SystemDefaultActCxtGenerationResult |= BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_DEPENDENCY_ASSEMBLY_NOT_FOUND;
            fSuccess = TRUE;
            goto Exit;
        }

        // Build the activation context data blob.
        IFW32FALSE_EXIT(::SxspBuildActCtxData(pActCtxGenCtx, &Parameters->SectionObjectHandle));
        fSuccess = TRUE;
    }

Exit:
#undef IS_NT_DOS_PATH

    // for system default stream,
    if  (Parameters->Manifest.Stream == SystemDefaultManifestFileStream)
        Parameters->Manifest.Stream  = NULL;

    if (pActCtxGenCtx)
        FUSION_DELETE_SINGLETON(pActCtxGenCtx);



    if (!fSuccess) // put a win32-error-message into eventlog
    {
#if !DBG // misindented to reduce fiff
    BOOL fAreWeInOSSetupMode = FALSE;
    //
    // If we can't determine this, then let the first error through.
    //
    if (!::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode) || !fAreWeInOSSetupMode)
#endif
    {
        CSxsPreserveLastError ple;
        ::FusionpLogError(
            MSG_SXS_FUNCTION_CALL_FAIL,
            CEventLogString(L"Generate Activation Context"),
            (Parameters->Manifest.Path != NULL) ? CEventLogString(static_cast<PCWSTR>(Parameters->Manifest.Path)) : CEventLogString(L"Manifest Filename Unknown"),
            CEventLogLastError());
#if DBG
        ::DbgPrintSxsGenerateActivationContextParameters(
            FUSION_DBG_LEVEL_ERROR,
            Parameters,
            __FUNCTION__);
#endif
        ple.Restore();
    }
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\strongname.h ===
#pragma once

#include "wincrypt.h"
#include "fusionarray.h"
#include "FusionHandle.h"

//
// If someone invents a hash with more than 512 bytes, ?JonWis will eat his socks.
//
#define MAX_HASH_BYTES              ( 512 )
#define STRONG_NAME_BYTE_LENGTH     ( 8 )


BOOL
SxspHashStringToBytes(
    IN  PCWSTR pszHashString,
    IN  SIZE_T cchHashString,
    OUT CFusionArray<BYTE> &dest
    );

BOOL
SxspHashBytesToString(
    IN const BYTE*    pbSource,
    IN SIZE_T   cbSource,
    OUT CBaseStringBuffer &sbDestination
    );

BOOL
SxspHashBytesToString(
    IN const BYTE*    pbSource,
    IN SIZE_T   cbSource,
    OUT CBaseStringBuffer &rsbDestination
    );

BOOL
SxspGetStrongNameOfKey(
    IN const CFusionArray<BYTE>& PublicKeyBits,
    OUT CFusionArray<BYTE>& StrongNameBits
    );

BOOL
SxspDoesStrongNameMatchKey(
    IN  const CBaseStringBuffer &rsbKeyString,
    IN  const CBaseStringBuffer &rsbStrongNameString,
    OUT BOOL                    &rfKeyMatchesStrongName
    );

BOOL
SxspGetStrongNameOfKey(
    IN const CBaseStringBuffer &sbKeyString,
    OUT CBaseStringBuffer &sbStrongNameOutput
    );

BOOL
SxspAcquireStrongNameFromCertContext(
    CBaseStringBuffer &rbuffStrongNameString,
    CBaseStringBuffer &rbuffPublicKeyString,
    PCCERT_CONTEXT pCertContext
    );

typedef struct _SXS_PUBLIC_KEY_INFO
{
    unsigned int SigAlgID;
    unsigned int HashAlgID;
    ULONG KeyLength;
    BYTE pbKeyInfo[1];
} SXS_PUBLIC_KEY_INFO, *PSXS_PUBLIC_KEY_INFO;


class CPublicKeyInformation
{
private:
    CFusionArray<BYTE>  m_StrongNameBytes;
    CSmallStringBuffer  m_StrongNameString;
    CFusionArray<BYTE>  m_PublicKeyBytes;
    CSmallStringBuffer  m_PublicKeyByteString;
    CStringBuffer       m_SignerDisplayName;
    CStringBuffer       m_CatalogSourceFileName;
    bool                m_fInitialized;
    ULONG               m_KeyLength;

public:
    BOOL GetStrongNameString(OUT CBaseStringBuffer &rsbStrongNameString ) const;
    BOOL GetStrongNameBytes(OUT CFusionArray<BYTE> &cbStrongNameBytes ) const;
    BOOL GetPublicKeyBitLength(OUT ULONG& ulKeyLength ) const;
    BOOL GetWrappedPublicKeyBytes(OUT CFusionArray<BYTE> &cbPublicKeyBytes ) const;
    BOOL GetSignerNiceName(OUT CBaseStringBuffer &rsbSignerNameString );
    BOOL DoesStrongNameMatchSigner( IN const CBaseStringBuffer &rsbToTest, OUT BOOL &rfFoundInCatalog ) const;

    CPublicKeyInformation();
    ~CPublicKeyInformation();

    BOOL Initialize(IN const CBaseStringBuffer &rsbCatalogName);
    BOOL Initialize(IN PCWSTR pszCatalogName);
    BOOL Initialize(IN CFusionFile &rFileHandle);
    BOOL Initialize(IN const PCCERT_CONTEXT pContext);

private:
    CPublicKeyInformation( const CPublicKeyInformation &);
    CPublicKeyInformation& operator=( const CPublicKeyInformation & );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsasmitem.cpp ===
//depot/private/lab01_fusion/base/win32/fusion/dll/whistler/sxsasmitem.cpp#3 - edit change 16520 (text)
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsasmitem.cpp

Abstract:

    CAssemblyCacheItem implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:
    xiaoyuw     10/26/2000      revise during beta2 code review period

--*/
#include "stdinc.h"
#include "sxsp.h"
#include "fusionbuffer.h"
#include "fusion.h"
#include "sxsasmitem.h"
#include "CAssemblyCacheItemStream.h"
#include "util.h"
#include "fusiontrace.h"
#include "sxsapi.h"

CAssemblyCacheItem::CAssemblyCacheItem() : m_cRef(0),
                    m_pRunOnceCookie(NULL), m_pInstallCookie(NULL),
                    m_fCommit(FALSE), m_fManifest(FALSE)
{
}

CAssemblyCacheItem::~CAssemblyCacheItem()
{
    CSxsPreserveLastError ple;

    ASSERT_NTC(m_cRef == 0);

    if (m_pRunOnceCookie)
    {
        if (!::SxspCancelRunOnceDeleteDirectory(m_pRunOnceCookie))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspCancelRunOnceDeleteDirectory returns FALSE, file a BUG\n");
        }
    }

    if (!m_strTempDir.IsEmpty())
    {
        if (!::SxspDeleteDirectory(m_strTempDir))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspDeleteDirectory returns FALSE, file a BUG\n");
        }
    }

    ple.Restore();
}

HRESULT
CAssemblyCacheItem::Initialize()
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    //create temporary directory for this assembly
    IFW32FALSE_EXIT(::SxspCreateWinSxsTempDirectory(m_strTempDir, NULL, &m_strUidBuf, NULL));
    IFW32FALSE_EXIT(::SxspCreateRunOnceDeleteDirectory(m_strTempDir, &m_strUidBuf, (PVOID *)&m_pRunOnceCookie));

    hr = NOERROR;
Exit:
    return hr ;
}


// ---------------------------------------------------------------------------
// CAssemblyCacheItem::CreateStream
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::CreateStream(
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream** ppStream,
	/* [in, optional] */ ULARGE_INTEGER *puliMaxSize)  // ????? in or OUT ?????
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    CStringBuffer FullPathFileNameBuf;
    CStringBuffer FullPathSubDirBuf;
    CSmartRef<CAssemblyCacheItemStream> pStream;
    const static WCHAR szTemp[] = L"..";

	// The puliMaxSize is intended to be a hint for preallocation of the temporary storage for the stream.  We just don't
	// use it.
	UNUSED(puliMaxSize);
	
	if (ppStream != NULL)
		*ppStream = NULL;

	::FusionpDbgPrintEx(
		FUSION_DBG_LEVEL_INSTALLATION,
		"SXS: %s called with:\n"
		"   dwFlags = 0x%08lx\n"
		"   pszName = \"%ls\"\n"
		"   dwFormat = %lu\n"
		"   dwFormatFlags = %lu\n"
		"   ppStream = %p\n"
		"   puliMaxSize = %p\n",
		__FUNCTION__,
		dwFlags,
		pszName,
		dwFormat,
		dwFormatFlags,
		ppStream,
		puliMaxSize);

    PARAMETER_CHECK(dwFlags == 0);
	PARAMETER_CHECK(pszName != NULL);
	PARAMETER_CHECK(ppStream != NULL);

    //Darwin should clean their code about this : use _WIN32_ flags only
    PARAMETER_CHECK(
		(dwFormat == STREAM_FORMAT_COMPLIB_MANIFEST) ||
		(dwFormat == STREAM_FORMAT_WIN32_MANIFEST) ||
        (dwFormat == STREAM_FORMAT_COMPLIB_MODULE) ||
		(dwFormat == STREAM_FORMAT_WIN32_MODULE));

	PARAMETER_CHECK(dwFormatFlags == 0);

	// It's illegal to have more than one manifest in the assembly...
	PARAMETER_CHECK((!m_fManifest) || ((dwFormat != STREAM_FORMAT_COMPLIB_MANIFEST) && (dwFormat != STREAM_FORMAT_WIN32_MANIFEST)));
	
    *ppStream = NULL;

    // one and only one manifest stream for each assembly item.....
    if ((dwFormat == STREAM_FORMAT_COMPLIB_MANIFEST) || (dwFormat == STREAM_FORMAT_WIN32_MANIFEST))
    {
        INTERNAL_ERROR_CHECK(m_fManifest == FALSE);
        m_fManifest = TRUE;
    }

    INTERNAL_ERROR_CHECK(m_strTempDir.IsEmpty() == FALSE); // temporary directory must be there !
    IFW32FALSE_EXIT(FullPathFileNameBuf.Win32Assign(m_strTempDir));

    IFW32FALSE_EXIT(FullPathFileNameBuf.Win32EnsureTrailingPathSeparator());
    IFW32FALSE_EXIT(FullPathFileNameBuf.Win32Append(pszName, ::wcslen(pszName)));

    // xiaoyuw@ : below wcsstr() is from old code : not sure whether we need do it
    // Do not allow path hackery.
    // need to validate this will result in a relative path within asmcache dir.
    // For now don't allow ".." in path; collapse the path before doing this.

    INTERNAL_ERROR_CHECK(wcsstr(pszName, szTemp) == NULL);

    // before file-copying, create subdirectory if needed
    // check backslash and forword-slash
    IFW32FALSE_EXIT(::SxspCreateMultiLevelDirectory(m_strTempDir, pszName));
    IFALLOCFAILED_EXIT(pStream = new CAssemblyCacheItemStream);
    IFW32FALSE_EXIT(
        pStream->OpenForWrite(
            FullPathFileNameBuf,
            0,
            CREATE_NEW,
            FILE_FLAG_SEQUENTIAL_SCAN));

    if ((dwFormat == STREAM_FORMAT_COMPLIB_MANIFEST) || (dwFormat == STREAM_FORMAT_WIN32_MANIFEST)) // but should not be set both bits
        IFW32FALSE_EXIT(m_strManifestFileName.Win32Assign(FullPathFileNameBuf)); // record manifest filename

    *ppStream = pStream.Disown(); // void func

    hr = NOERROR;
Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::Commit
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::Commit(
    DWORD dwFlags,
	ULONG *pulDisposition
	)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ULONG ulDisposition;
    SXS_INSTALLW Install = { sizeof(Install) };

	::FusionpDbgPrintEx(
		FUSION_DBG_LEVEL_INSTALLATION,
		"SXS: %s called:\n"
		"   dwFlags = 0x%08lx\n"
		"   pulDisposition = %p\n",
		__FUNCTION__,
		dwFlags,
		pulDisposition);

    if (pulDisposition)
        *pulDisposition = 0;

    PARAMETER_CHECK((dwFlags & ~(IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH)) == 0);

    // check internal error whether it is ready to commit
    INTERNAL_ERROR_CHECK(m_fManifest == TRUE);
    INTERNAL_ERROR_CHECK(m_strManifestFileName.IsEmpty() == FALSE); //m_pRunOnceCookie here should be NULL...

	// commit here
    if ((!m_fCommit) || (dwFlags & IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH))
    {
        Install.dwFlags = SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN |
            ((dwFlags & IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH) ? SXS_INSTALL_FLAG_REPLACE_EXISTING : 0);

        if (m_pInstallCookie != NULL)
        {
            Install.dwFlags |= SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID;
            Install.pvInstallCookie = m_pInstallCookie;
        }

        Install.lpManifestPath = m_strManifestFileName;

        IFW32FALSE_EXIT(::SxsInstallW(&Install));

		if ((dwFlags & IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH) && (m_fCommit))
		{
			::FusionpDbgPrintEx(
				FUSION_DBG_LEVEL_INSTALLATION,
				"SXS: %s - setting disposition to IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED\n",
				__FUNCTION__);
			ulDisposition = IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED;
		}
		else
		{
			::FusionpDbgPrintEx(
				FUSION_DBG_LEVEL_INSTALLATION,
				"SXS: %s - setting disposition to IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED\n",
				__FUNCTION__);

			ulDisposition = IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED;
		}

        m_fCommit = TRUE; // committed successfully
    }
    else
    {
		::FusionpDbgPrintEx(
			FUSION_DBG_LEVEL_INSTALLATION,
			"SXS: %s - setting disposition to IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED\n",
			__FUNCTION__);

        ulDisposition = IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED;
    }

    if (pulDisposition)
        *pulDisposition = ulDisposition;

	hr = NOERROR;

Exit :
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::AbortItem
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::AbortItem()
{
	::FusionpDbgPrintEx(
		FUSION_DBG_LEVEL_ERROR,
		"SXS: %s called; returning E_NOTIMPL\n",
		__FUNCTION__);

    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyCacheItem::QueryInterface(REFIID riid, void** ppvObj)
{
    if ((riid == IID_IUnknown) ||
        (riid == IID_IAssemblyCacheItem))
    {
        *ppvObj = static_cast<IAssemblyCacheItem*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCacheItem::AddRef()
{
    return ::SxspInterlockedIncrement (&m_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCacheItem::Release()
{
    ULONG lRet = ::SxspInterlockedDecrement (&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsasmcache.cpp ===
//depot/private/lab01_fusion/base/win32/fusion/dll/whistler/sxsasmcache.cpp#4 - edit change 16520 (text)
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsasmcache.cpp

Abstract:

    CAssemblyCache implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:
    xiaoyuw     10/26/2000      revise during Bate2 code review period
    xiaoyuw     12/21/2000      using new API

--*/

#include "stdinc.h"
#include "fusionbuffer.h"
#include "sxsp.h"
#include "sxsasmitem.h"
#include "sxsasmcache.h"
#include "sxsasmname.h"
#include "fusiontrace.h"


STDAPI
CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved)
{
    HRESULT  hr = NOERROR;
    FN_TRACE_HR(hr);
    CAssemblyCache * pAsmCache = NULL;

	if (ppAsmCache != NULL)
		*ppAsmCache = NULL;

    PARAMETER_CHECK(ppAsmCache != NULL);

    IFALLOCFAILED_EXIT(pAsmCache = new CAssemblyCache);
    pAsmCache->AddRef(); // void
    *ppAsmCache = pAsmCache;

    hr = NOERROR;
Exit:
    return hr;
}


// Fusion -> Sxs
BOOL
SxspTranslateReferenceFrom( 
    IN LPCFUSION_INSTALL_REFERENCE pFusionReference, 
    OUT SXS_INSTALL_REFERENCEW &SxsReference
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(pFusionReference != NULL);
    PARAMETER_CHECK(pFusionReference->cbSize <= SxsReference.cbSize);

    if (RTL_CONTAINS_FIELD(pFusionReference, pFusionReference->cbSize, guidScheme) &&
        RTL_CONTAINS_FIELD(&SxsReference, SxsReference.cbSize, guidScheme))
            SxsReference.guidScheme = pFusionReference->guidScheme;

    if (RTL_CONTAINS_FIELD(pFusionReference, pFusionReference->cbSize, szIdentifier) &&
        RTL_CONTAINS_FIELD(&SxsReference, SxsReference.cbSize, lpIdentifier))
            SxsReference.lpIdentifier = pFusionReference->szIdentifier;

    if (RTL_CONTAINS_FIELD(pFusionReference, pFusionReference->cbSize, szNonCannonicalData) &&
        RTL_CONTAINS_FIELD(&SxsReference, SxsReference.cbSize, lpNonCanonicalData))
            SxsReference.lpNonCanonicalData = pFusionReference->szNonCannonicalData;

    FN_EPILOG
}

// Sxs -> Fusion
BOOL
SxspTranslateReferenceFrom(
    IN PCSXS_INSTALL_REFERENCEW pSxsReference,
    OUT FUSION_INSTALL_REFERENCE &FusionReference
    )
{
    FN_PROLOG_WIN32

    //
    // Pointer must be non-null, and the SXS structure must be either
    // the same size or smaller than the equivalent Fusion structure.
    //
    PARAMETER_CHECK(pSxsReference);

    //
    // Assume size has been set by caller.
    //
    PARAMETER_CHECK(pSxsReference->cbSize <= FusionReference.cbSize);

    if (RTL_CONTAINS_FIELD(&FusionReference, FusionReference.cbSize, guidScheme) &&
        RTL_CONTAINS_FIELD(pSxsReference, pSxsReference->cbSize, guidScheme))
            FusionReference.guidScheme = pSxsReference->guidScheme;

    if (RTL_CONTAINS_FIELD(&FusionReference, FusionReference.cbSize, szIdentifier) &&
        RTL_CONTAINS_FIELD(pSxsReference, pSxsReference->cbSize, lpIdentifier))
            FusionReference.szIdentifier = pSxsReference->lpIdentifier;

    if (RTL_CONTAINS_FIELD(&FusionReference, FusionReference.cbSize, szNonCannonicalData) &&
        RTL_CONTAINS_FIELD(pSxsReference, pSxsReference->cbSize, lpNonCanonicalData))
            FusionReference.szNonCannonicalData = pSxsReference->lpNonCanonicalData;

    FN_EPILOG
}


STDMETHODIMP
CAssemblyCache::UninstallAssembly(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName,
        /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
        /* [out, optional] */ ULONG *pulDisposition)
{
    HRESULT hr=S_OK;
    FN_TRACE_HR(hr);

    SXS_UNINSTALLW Uninstall;
    SXS_INSTALL_REFERENCEW Reference = { sizeof(Reference) };
    DWORD dwDisposition;

	if (pulDisposition != NULL)
		*pulDisposition = 0;

    PARAMETER_CHECK((pszAssemblyName!= NULL) && (dwFlags ==0));

    ZeroMemory(&Uninstall, sizeof(Uninstall));
    Uninstall.cbSize = sizeof(Uninstall);
    Uninstall.lpAssemblyIdentity = pszAssemblyName;

    if (pRefData != NULL)
    {
        IFW32FALSE_EXIT(::SxspTranslateReferenceFrom(pRefData, Reference));
        Uninstall.lpInstallReference = &Reference;
        Uninstall.dwFlags |= SXS_UNINSTALL_FLAG_REFERENCE_VALID;
    }

    IFW32FALSE_EXIT(::SxsUninstallW(&Uninstall, &dwDisposition));

    if (pulDisposition != NULL)
		*pulDisposition = static_cast<DWORD>(dwDisposition);
    
    FN_EPILOG
}

STDMETHODIMP CAssemblyCache::QueryAssemblyInfo(
        /* [in] */  DWORD dwFlags,
        /* [in] */  LPCWSTR pwzTextualAssembly,
        /* [in, out] */ ASSEMBLY_INFO *pAsmInfo)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PARAMETER_CHECK(((dwFlags == 0) && (pwzTextualAssembly !=NULL)));
    IFW32FALSE_EXIT(::SxsQueryAssemblyInfo(dwFlags, pwzTextualAssembly, pAsmInfo));
    hr = NOERROR;
Exit:
    return hr;
}

STDMETHODIMP
CAssemblyCache::CreateAssemblyCacheItem(
        /* [in] */ DWORD dwFlags,
        /* [in] */ PVOID pvReserved,
        /* [out] */ IAssemblyCacheItem **ppAsmItem,
        /* [in, optional] */ LPCWSTR pszAssemblyName)  // uncanonicalized, comma separted name=value pairs.
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    CSmartRef<CAssemblyCacheItem> pAsmItem;

	if (ppAsmItem != NULL)
		*ppAsmItem = NULL;

    PARAMETER_CHECK((ppAsmItem != NULL) && (dwFlags == 0) && (pvReserved == NULL));

    IFALLOCFAILED_EXIT(pAsmItem = new CAssemblyCacheItem);
    IFCOMFAILED_EXIT(pAsmItem->Initialize());

    *ppAsmItem = pAsmItem.Disown(); // void

    hr = NOERROR;
Exit:
    return hr;
}

STDMETHODIMP
CAssemblyCache::InstallAssembly(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszManifestPath,
        /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    SXS_INSTALLW Install = { sizeof(SXS_INSTALLW) };
    SXS_INSTALL_REFERENCEW Reference = { sizeof(Reference) };

    PARAMETER_CHECK((pszManifestPath != NULL) && (dwFlags == 0));

    Install.lpManifestPath = pszManifestPath;


    if ( pRefData == NULL )
    {
        Install.dwFlags = SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN;
    }
    else
    {
        //
        // Otherwise, the pvReserved is really a "reference"
        //
        Install.dwFlags |= SXS_INSTALL_FLAG_REFERENCE_VALID;
        IFW32FALSE_EXIT(::SxspTranslateReferenceFrom(pRefData, Reference));
        Install.lpReference = &Reference;
    }
    
    IFW32FALSE_EXIT(::SxsInstallW(&Install));

    FN_EPILOG
}



STDMETHODIMP
CAssemblyCache::CreateAssemblyScavenger(
    IAssemblyScavenger **ppAsmScavenger )
{
#if 0
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    PARAMETER_CHECK(ppAsmScavenger != NULL);
    *ppAsmScavenger = NULL;
Exit:
#endif
    return E_NOTIMPL;
}

//
// IUnknown boilerplate...
//

STDMETHODIMP
CAssemblyCache::QueryInterface(REFIID riid, void** ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IAssemblyCache))
    {
        *ppvObj = static_cast<IAssemblyCache*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CAssemblyCache::AddRef()
{
    return SxspInterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CAssemblyCache::Release()
{
    ULONG lRet = SxspInterlockedDecrement(&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsidp.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsasmcache.h ===
//depot/private/lab01_fusion/base/win32/fusion/dll/whistler/sxsasmcache.h#3 - edit change 16520 (text)
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsasmcache.h

Abstract:

    CAssemblyCache implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_ASMCACHE_H_INCLUDED_)
#define _FUSION_SXS_ASMCACHE_H_INCLUDED_

#pragma once

#include "fusion.h"

// CAssemblyCache declaration.
class CAssemblyCache : public IAssemblyCache
{
public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyCache methods
    STDMETHOD (UninstallAssembly)(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName, // uncanonicalized, comma separted name=value pairs.
        /* [in] */ LPCFUSION_INSTALL_REFERENCE lpReference,
        /* [out, optional] */ ULONG *pulDisposition
        );

    STDMETHOD (QueryAssemblyInfo)(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName,
        /* [in, out] */ ASSEMBLY_INFO *pAsmInfo
        );

    STDMETHOD (CreateAssemblyCacheItem)(
        /* [in] */ DWORD dwFlags,
        /* [in] */ PVOID pvReserved,
        /* [out] */ IAssemblyCacheItem **ppAsmItem,
        /* [in, optional] */ LPCWSTR pszAssemblyName  // uncanonicalized, comma separted name=value pairs.
        );

    STDMETHOD (InstallAssembly)( // if you use this, fusion will do the streaming & commit.
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszManifestFilePath,
        /* [in] */ LPCFUSION_INSTALL_REFERENCE lpReference
        );

    STDMETHOD(CreateAssemblyScavenger) (
        /* [out] */ IAssemblyScavenger **ppAsmScavenger
        );

    CAssemblyCache():m_cRef(0)
    {
    }

    ~CAssemblyCache()
    {
        ASSERT_NTC(m_cRef == 0);
    }

private :
    ULONG               m_cRef;
};

#endif // _FUSION_SXS_ASMCACHE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsasmname.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsname.h

Abstract:

    IAssemblyName implementation for MSI

Author:

    Xiaoyu Wu (xiaoyuw) May 2000

Revision History:
	xiaoyuw		09/29//2000		replace attributes with AssemblyIdentity

--*/
#if !defined(_FUSION_SXS_ASMNAME_H_INCLUDED_)
#define _FUSION_SXS_ASMNAME_H_INCLUDED_

#pragma once

#include "fusion.h"
#include "ForwardDeclarations.h"
#include "FusionBuffer.h"

typedef
enum _SXS_ASSEMBLY_NAME_PROPERTY
    {
    SXS_ASM_NAME_NAME                   = 0,
    SXS_ASM_NAME_VERSION                = SXS_ASM_NAME_NAME+ 1,
    SXS_ASM_NAME_PROCESSORARCHITECTURE  = SXS_ASM_NAME_VERSION+ 1,
    SXS_ASM_NAME_LANGUAGE               = SXS_ASM_NAME_PROCESSORARCHITECTURE + 1
}SXS_ASSEMBLY_NAME_PROPERTY;

class CAssemblyName : public IAssemblyName
{
private:
    DWORD               m_cRef;

    PASSEMBLY_IDENTITY  m_pAssemblyIdentity;
    BOOL                m_fIsFinalized;

public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyName methods
    STDMETHOD(SetProperty)(
        /* in */ DWORD  PropertyId,
        /* in */ LPVOID pvProperty,
        /* in */ DWORD  cbProperty);

    STDMETHOD(GetProperty)(
        /* in      */  DWORD    PropertyId,
        /*     out */  LPVOID   pvProperty,
        /* in  out */  LPDWORD  pcbProperty);

    STDMETHOD(Finalize)();

    STDMETHOD(GetDisplayName)(
        /* [out]   */   LPOLESTR  szDisplayName,
        /* in  out */   LPDWORD   pcbDisplayName,
        /* [in]    */   DWORD     dwDisplayFlags);

    STDMETHOD(GetName)(
        /* [out][in] */ LPDWORD lpcbBuffer,
        /* [out] */ WCHAR  __RPC_FAR *pwzName);

    STDMETHOD(GetVersion)(
        /* [out] */ LPDWORD pwVersionHi,
        /* [out] */ LPDWORD pwVersionLow);

    STDMETHOD (IsEqual)(
        /* [in] */ LPASSEMBLYNAME pName,
        /* [in] */ DWORD dwCmpFlags);

    STDMETHOD(BindToObject)(
        /* in      */  REFIID               refIID,
        /* in      */  IAssemblyBindSink   *pAsmBindSink,
        /* in      */  IApplicationContext *pAppCtx,
        /* in      */  LPCOLESTR            szCodebase,
        /* in      */  LONGLONG             llFlags,
        /* in      */  LPVOID               pvReserved,
        /* in      */  DWORD                cbReserved,
        /*     out */  VOID                 **ppv);

    STDMETHODIMP Clone(IAssemblyName **ppName);
    HRESULT Parse(LPCWSTR szDisplayName);

    CAssemblyName();
    ~CAssemblyName();

    HRESULT Init(LPCWSTR szDisplayName, PVOID pData);
    HRESULT GetInstalledAssemblyName(DWORD Flags, ULONG PathType, CBaseStringBuffer &rbuffPath);
    HRESULT DetermineAssemblyType( BOOL &fIsPolicy );
    HRESULT IsAssemblyInstalled(BOOL & fInstalled);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsasmname.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsasmname.cpp

Abstract:

    CAssemblyName implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) May 2000

Revision History:
    xiaoyuw        09/20000    rewrite the code to use Assembly Identity
--*/

#include "stdinc.h"
#include "sxsasmname.h"
#include "fusionparser.h"
#include "parse.h"
#include "sxsp.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "sxsapi.h"
#include "fusiontrace.h"

// ---------------------------------------------------------------------------
// CreateAssemblyNameObject
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyNameObject(
    LPASSEMBLYNAME    *ppAssemblyName,
    LPCOLESTR          szAssemblyName,
    DWORD              dwFlags,
    LPVOID             pvReserved
	)
{

    HRESULT hr = S_OK;
    FN_TRACE_HR(hr);
    CSmartRef<CAssemblyName> pName;

    if (ppAssemblyName)
        *ppAssemblyName = NULL ;

    // validate dwFlags
    // BUGBUG : the valid value of dwFlags are CANOF_PARSE_DISPLAY_NAME and CANOF_SET_DEFAULT_VALUES, but  CANOF_SET_DEFAULT_VALUES
    // is never used...
    // xiaoyuw@10/02/2000
    //
    PARAMETER_CHECK(dwFlags == CANOF_PARSE_DISPLAY_NAME);
    PARAMETER_CHECK(ppAssemblyName != NULL);
    PARAMETER_CHECK(pvReserved == NULL);

    IFALLOCFAILED_EXIT(pName = new CAssemblyName);

    if (dwFlags & CANOF_PARSE_DISPLAY_NAME)
        IFCOMFAILED_EXIT(pName->Parse((LPWSTR)szAssemblyName));

    *ppAssemblyName = pName.Disown();

    FN_EPILOG
}
// ---------------------------------------------------------------------------
// CAssemblyName::SetProperty
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::SetProperty(DWORD PropertyId,
    LPVOID pvProperty, DWORD cbProperty)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE Attribute = NULL;

    // this function is only called inside fusion, so this fucntion has no impact on Darwin
    // maybe more should be added for Assembly Identity, such as StrongName, or random policies
    //
    if ((!pvProperty) || ((PropertyId != SXS_ASM_NAME_NAME) &&
                          (PropertyId != SXS_ASM_NAME_VERSION) &&
                          (PropertyId != SXS_ASM_NAME_PROCESSORARCHITECTURE) &&
                          (PropertyId != SXS_ASM_NAME_LANGUAGE))){
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Fail if finalized.
    if (m_fIsFinalized){
        hr = E_UNEXPECTED;
        goto Exit;
    }

    switch (PropertyId)
    {
    case SXS_ASM_NAME_NAME:                     Attribute = &s_IdentityAttribute_name; break;
    case SXS_ASM_NAME_VERSION:                  Attribute = &s_IdentityAttribute_version; break;
    case SXS_ASM_NAME_PROCESSORARCHITECTURE:    Attribute = &s_IdentityAttribute_processorArchitecture; break;
    case SXS_ASM_NAME_LANGUAGE:                 Attribute = &s_IdentityAttribute_language; break;
    }

    INTERNAL_ERROR_CHECK(Attribute != NULL);
    IFW32FALSE_EXIT(::SxspSetAssemblyIdentityAttributeValue(0, m_pAssemblyIdentity, Attribute, (PCWSTR) pvProperty, cbProperty / sizeof(WCHAR)));

    hr = NOERROR;

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::GetProperty
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetProperty(DWORD PropertyId,
    /* [in] */        LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PCWSTR pszAttributeValue = NULL;
    SIZE_T CchAttributeValue = 0;
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE Attribute = NULL;

    if ((!pvProperty) || (!pcbProperty) || ((PropertyId != SXS_ASM_NAME_NAME) &&
                          (PropertyId != SXS_ASM_NAME_VERSION) &&
                          (PropertyId != SXS_ASM_NAME_PROCESSORARCHITECTURE) &&
                          (PropertyId != SXS_ASM_NAME_LANGUAGE))){
        hr = E_INVALIDARG;
        goto Exit;
    }

    switch (PropertyId)
    {
    case SXS_ASM_NAME_NAME:                     Attribute = &s_IdentityAttribute_name; break;
    case SXS_ASM_NAME_VERSION:                  Attribute = &s_IdentityAttribute_version; break;
    case SXS_ASM_NAME_PROCESSORARCHITECTURE:    Attribute = &s_IdentityAttribute_processorArchitecture; break;
    case SXS_ASM_NAME_LANGUAGE:                 Attribute = &s_IdentityAttribute_language; break;
    }

    INTERNAL_ERROR_CHECK(Attribute != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, m_pAssemblyIdentity, Attribute, &pszAttributeValue, &CchAttributeValue));

    // check whether we have valid attributes
    if (pszAttributeValue == NULL){ // attributes not set yet
        hr = E_UNEXPECTED;
        goto Exit;
    }
    if (CchAttributeValue * sizeof(WCHAR) > *pcbProperty) { // buffer size is not big enough
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pcbProperty = static_cast<DWORD>(CchAttributeValue * sizeof(WCHAR));
        goto Exit;
    }

    // copy the string into the output buffer
    memcpy(pvProperty, pszAttributeValue, CchAttributeValue *sizeof(WCHAR));
    if (pcbProperty)
        *pcbProperty = static_cast<DWORD>(CchAttributeValue * sizeof(WCHAR));

    hr = NOERROR;
Exit:
    return hr;
}
// ---------------------------------------------------------------------------
// CAssemblyName::GetName
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetName(
        /* [out][in] */ LPDWORD lpcwBuffer,
        /* [out] */     WCHAR   *pwzName)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    if (!lpcwBuffer || !pwzName){
        hr = E_INVALIDARG;
        goto Exit;
    }

    IFCOMFAILED_EXIT(this->GetProperty(SXS_ASM_NAME_NAME, pwzName, lpcwBuffer));

    FN_EPILOG
}
// ---------------------------------------------------------------------------
// CAssemblyName::GetVersion
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetVersion(
        /* [out] */ LPDWORD pdwVersionHi,
        /* [out] */ LPDWORD pdwVersionLow)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PCWSTR pszAttributeValue = NULL;
    SIZE_T CchAttributeValue = 0;
    ASSEMBLY_VERSION ver;
    bool fSyntaxValid = false;

    if ((!pdwVersionHi) || (!pdwVersionLow)){
        hr = E_INVALIDARG;
        goto Exit;
    }

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, m_pAssemblyIdentity, &s_IdentityAttribute_version, &pszAttributeValue, &CchAttributeValue));
    if (pszAttributeValue == NULL)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    IFW32FALSE_EXIT(CFusionParser::ParseVersion(ver, pszAttributeValue, CchAttributeValue, fSyntaxValid));
    if (!fSyntaxValid)
    {
        hr = HRESULT_FROM_WIN32(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    *pdwVersionHi  = MAKELONG(ver.Minor, ver.Major);
    *pdwVersionLow = MAKELONG(ver.Build, ver.Revision);

    FN_EPILOG
}

// ---------------------------------------------------------------------------
// CAssemblyName::IsEqual
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::IsEqual(LPASSEMBLYNAME pName, DWORD dwCmpFlags)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    BOOL fEqual = FALSE;

    PARAMETER_CHECK(pName != NULL);
    IFW32FALSE_EXIT(::SxsAreAssemblyIdentitiesEqual(0, m_pAssemblyIdentity, static_cast<CAssemblyName *>(pName)->m_pAssemblyIdentity, &fEqual));
    if (fEqual == TRUE)
        hr = S_OK;
    else
        hr = E_FAIL; // not acurrate, however, it depends on Darwin caller.
Exit:
    return hr;

}
// ---------------------------------------------------------------------------
// CAssemblyName constructor
// ---------------------------------------------------------------------------
CAssemblyName::CAssemblyName():m_cRef(0),
        m_fIsFinalized(FALSE),
        m_pAssemblyIdentity(NULL)
{
}

// ---------------------------------------------------------------------------
// CAssemblyName destructor
// ---------------------------------------------------------------------------
CAssemblyName::~CAssemblyName()
{
    ASSERT_NTC(m_cRef == 0 );
    if (m_pAssemblyIdentity)
    {
        CSxsPreserveLastError ple;
        ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
        ple.Restore();
    }
}
// ---------------------------------------------------------------------------
// CAssemblyName::Init
// ---------------------------------------------------------------------------
HRESULT
CAssemblyName::Init(LPCWSTR pszAssemblyName, PVOID pamd)
{
    HRESULT hr = S_OK;
    FN_TRACE_HR(hr);
    SIZE_T CchAssemblyName = 0;

    UNUSED(pamd);
    //ASSERT(m_pAssemblyIdentity == NULL);
    if (m_pAssemblyIdentity)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &m_pAssemblyIdentity, 0, NULL));

    // set name if present
    if (pszAssemblyName != NULL)
    {
        CchAssemblyName = wcslen(pszAssemblyName);
        IFW32FALSE_EXIT(::SxspSetAssemblyIdentityAttributeValue(0, m_pAssemblyIdentity, &s_IdentityAttribute_name, pszAssemblyName, wcslen(pszAssemblyName)));
    }

    hr = NOERROR;
Exit:
    return hr;
}
// ---------------------------------------------------------------------------
// CAssemblyName::Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyName::Clone(IAssemblyName **ppName)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    CAssemblyName *pName= NULL;

    if (ppName)
        *ppName = NULL;

    if (!ppName){
        hr = E_INVALIDARG ;
        goto Exit;
    }

    if (m_pAssemblyIdentity)
    {
        IFW32FALSE_EXIT(
            ::SxsDuplicateAssemblyIdentity(
                0,                        // DWORD Flags,
                m_pAssemblyIdentity,      // PCASSEMBLY_IDENTITY Source,
                &pAssemblyIdentity));     // PASSEMBLY_IDENTITY *Destination
    }

    IFALLOCFAILED_EXIT(pName = new CAssemblyName);
    pName->m_pAssemblyIdentity = pAssemblyIdentity;
    pAssemblyIdentity = NULL;
    *ppName = pName;
    pName = NULL;

    hr = NOERROR;
Exit:
    if (pAssemblyIdentity)
        SxsDestroyAssemblyIdentity(pAssemblyIdentity);
    if (pName)
        FUSION_DELETE_SINGLETON(pName);

    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::BindToObject
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::BindToObject(
        /* in      */  REFIID               refIID,
        /* in      */  IAssemblyBindSink   *pAsmBindSink,
        /* in      */  IApplicationContext *pAppCtx,
        /* in      */  LPCOLESTR            szCodebase,
        /* in      */  LONGLONG             llFlags,
        /* in      */  LPVOID               pvReserved,
        /* in      */  DWORD                cbReserved,
        /*     out */  VOID               **ppv)

{
    if (!ppv)
        return E_INVALIDARG ;

    *ppv = NULL;
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// CAssemblyName::Finalize
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::Finalize()
{
    m_fIsFinalized = TRUE;
    return NOERROR;
}

BOOL SxspIsAssemblyNameAttributeInAssemblyIdentity(PASSEMBLY_IDENTITY_ATTRIBUTE pAttribute)
{
    if( pAttribute == NULL)
        return FALSE;

    //compare namespace
    if (::FusionpCompareStrings(
                pAttribute->Namespace,
                pAttribute->NamespaceCch,
                SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE,
                NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE) - 1,
                false) == 0 ){ // case-sensitive comparison
        if (::FusionpCompareStrings(
                pAttribute->Name,
                pAttribute->NameCch,
                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
                NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1,
                false) == 0 ){ // case-sensitive comparison
                return TRUE;
            }
            else
                return FALSE;
    }
    else
        return FALSE;

}
//-----------------------------------------------------------------------------------
// CAssemblyName::GetDisplayName
// it would be name,ns1:n1="v1",ns2:n2="v2",ns3:n3="v3",ns4:n4="v4"
// I have to put name first in order not to change Darwin's code
//
// xiaoyuw@09/29/2000
//-----------------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetDisplayName(LPOLESTR szDisplayName,
    LPDWORD pccDisplayName, DWORD dwDisplayFlags)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    SIZE_T BufferSize;
    SIZE_T BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(pccDisplayName != NULL);
    PARAMETER_CHECK((szDisplayName != NULL) || (*pccDisplayName == 0));
    PARAMETER_CHECK(dwDisplayFlags == 0);

    // Need buffer size in bytes...
    BufferSize = (*pccDisplayName) * sizeof(WCHAR);

    IFW32FALSE_EXIT(
        ::SxsEncodeAssemblyIdentity(
            0,
            m_pAssemblyIdentity,
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            BufferSize,
            szDisplayName,
            &BytesWrittenOrRequired));

    if ((BufferSize - BytesWrittenOrRequired) < sizeof(WCHAR))
    {
        // We actually could fit everything but the trailing null character...
        // the BytesWrittenOrRequired actually has the right value for the exit path below;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }else // add the trailing NULL
    {
        szDisplayName[BytesWrittenOrRequired / sizeof (*szDisplayName)] = L'\0';
    }


    hr = NOERROR;

Exit:
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        *pccDisplayName = static_cast<DWORD>((BytesWrittenOrRequired / sizeof(WCHAR)) + 1);

    return hr;
}

HRESULT CAssemblyName::Parse(LPCWSTR szDisplayName)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;

    // Verify display name passed in.
    PARAMETER_CHECK(szDisplayName != NULL);
    PARAMETER_CHECK(szDisplayName[0] != L'\0');

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromTextualString(
            szDisplayName,
            &pAssemblyIdentity));

    if (m_pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);

    m_pAssemblyIdentity = pAssemblyIdentity;
    pAssemblyIdentity = NULL;

    hr = NOERROR;
Exit:
    if (pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return hr;
}
// ---------------------------------------------------------------------------
// CAssemblyName::GetInstalledAssemblyName
// ---------------------------------------------------------------------------
HRESULT
CAssemblyName::GetInstalledAssemblyName(
    IN DWORD Flags,
    IN ULONG PathType,
    CBaseStringBuffer &rBufInstallPath
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    BOOL fIsPolicy;

    IFCOMFAILED_EXIT(this->DetermineAssemblyType(fIsPolicy));
    Flags |= (fIsPolicy ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0);

    if (Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                Flags,
                PathType,
                NULL,
                0,
                m_pAssemblyIdentity,
                rBufInstallPath));

		::FusionpDbgPrintEx(
			FUSION_DBG_LEVEL_MSI_INSTALL,
			"SXS: %s - Generated %Iu character (root omitted) installation path:\n"
			"   \"%ls\"\n",
			__FUNCTION__, rBufInstallPath.Cch(),
			static_cast<PCWSTR>(rBufInstallPath));
    }
    else
    {
        CStringBuffer bufRootDir;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(bufRootDir));
        IFW32FALSE_EXIT(bufRootDir.Win32EnsureTrailingPathSeparator());

        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                Flags,
                PathType,
                bufRootDir,
                bufRootDir.Cch(),
                m_pAssemblyIdentity,
                rBufInstallPath));

		::FusionpDbgPrintEx(
			FUSION_DBG_LEVEL_MSI_INSTALL,
			"SXS: %s - Generated %Iu character installation path:\n"
			"   \"%ls\"\n",
			__FUNCTION__, rBufInstallPath.Cch(),
			static_cast<PCWSTR>(rBufInstallPath));
    }

    FN_EPILOG
}

// TODO :
// 1) this function just check the existence of the directory W/O compare the files under the directory
// 2) this API would return FALSE if something in the middle is wrong, maybe not appropriate
// xiaoyuw@09/29/2000
//
HRESULT CAssemblyName::IsAssemblyInstalled(BOOL &fInstalled)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    CStringBuffer buffInstalledDir;

    fInstalled = FALSE;

    IFCOMFAILED_EXIT(
        this->GetInstalledAssemblyName(
            0,
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            buffInstalledDir));

    if (::GetFileAttributesW(buffInstalledDir) == INVALID_FILE_ATTRIBUTES)
    {
        const DWORD dwLastError = ::GetLastError();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributesW, dwLastError);
    }
    else
        fInstalled = TRUE;

    FN_EPILOG
}

// IUnknown methods
// ---------------------------------------------------------------------------
// CAssemblyName::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyName::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyName::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyName::Release()
{
    ULONG lRet = InterlockedDecrement ((PLONG)&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);
    return lRet;
}

// ---------------------------------------------------------------------------
// CAssemblyName::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::QueryInterface(REFIID riid, void** ppv)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyName)){
        *ppv = static_cast<IAssemblyName*> (this);
        AddRef();
        return S_OK;
    }
    else{
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


HRESULT
CAssemblyName::DetermineAssemblyType( BOOL &fIsPolicy )
{
    HRESULT hr = E_FAIL;
    FN_TRACE_HR(hr);

    INTERNAL_ERROR_CHECK( m_pAssemblyIdentity != NULL );
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(m_pAssemblyIdentity, fIsPolicy));

    hr = S_OK;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsclrhelpers.cpp ===
#include "stdinc.h"


typedef CFusionArray<BYTE> CStackBackingBuffer;

#define WRITE_INTO_BUFFER(cursor, target, length, source, leftover) \
    (target) = (cursor); \
    RtlCopyMemory(cursor, source, length); \
    leftover -= (length); \
    INTERNAL_ERROR_CHECK((length % sizeof(WCHAR) == 0)); \
    (cursor) = (PWSTR)(((ULONG_PTR)(cursor)) + length); \
    *(cursor)++ = UNICODE_NULL;


BOOL
SxspLookupAssemblyIdentityInActCtx(
    HANDLE              hActCtx,
    ULONG               ulRosterIndex,
    CStringBuffer       &TargetString
    )
{
    FN_PROLOG_WIN32;

    SIZE_T cbRequired = 0;
    bool fMoreSpaceRequired = false;
    CStackBackingBuffer TargetRegion;
    PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION pDetailedInfo = NULL;

    TargetString.Clear();

    IFW32FALSE_EXIT_UNLESS2(
        QueryActCtxW(
            0, 
            hActCtx, 
            (PVOID)&ulRosterIndex, 
            AssemblyDetailedInformationInActivationContext, 
            TargetRegion.GetArrayPtr(), 
            TargetRegion.GetSize(), 
            &cbRequired),
        LIST_1(ERROR_INSUFFICIENT_BUFFER),
        fMoreSpaceRequired);

    if (fMoreSpaceRequired)
    {
        IFW32FALSE_EXIT(TargetRegion.Win32SetSize(cbRequired, CStackBackingBuffer::eSetSizeModeExact));

        IFW32FALSE_EXIT(
            QueryActCtxW(
                0,
                hActCtx,
                (PVOID)&ulRosterIndex,
                AssemblyDetailedInformationInActivationContext,
                TargetRegion.GetArrayPtr(),
                TargetRegion.GetSize(),
                &cbRequired));
    }

    pDetailedInfo = (PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)TargetRegion.GetArrayPtr();
    IFW32FALSE_EXIT(TargetString.Win32Assign(
        pDetailedInfo->lpAssemblyEncodedAssemblyIdentity,
        pDetailedInfo->ulEncodedAssemblyIdentityLength / sizeof(WCHAR)));

    FN_EPILOG;
}




BOOL
WINAPI
SxsFindClrClassInformation(
    DWORD       dwFlags,
    PVOID       pvSearchData,
    HANDLE      hActivationContext,
    PVOID       pvDataBuffer,
    SIZE_T      cbDataBuffer,
    PSIZE_T     pcbDataBufferWrittenOrRequired
    )
{
    FN_PROLOG_WIN32;

    SIZE_T                      cbRequired = 0;
    CStringBuffer               AssemblyIdentity;
    CFusionActCtxScope          ActivationScope;
    CFusionActCtxHandle         UsedHandleDuringSearch;
    GUID                        GuidToSearch;
    ACTCTX_SECTION_KEYED_DATA   KeyedData = {sizeof(KeyedData)};
    PSXS_CLR_CLASS_INFORMATION  pOutputStruct = NULL;
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION pComServerRedirect = NULL;
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM pClrShim = NULL;
        
    if (pcbDataBufferWrittenOrRequired)
        *pcbDataBufferWrittenOrRequired = 0;

    PARAMETER_CHECK(pcbDataBufferWrittenOrRequired != NULL);
    PARAMETER_CHECK(pvSearchData != NULL);
    PARAMETER_CHECK(pvDataBuffer || (cbDataBuffer == 0));
    IFINVALID_FLAGS_EXIT_WIN32(dwFlags,
        SXS_FIND_CLR_CLASS_SEARCH_PROGID |
        SXS_FIND_CLR_CLASS_SEARCH_GUID |
        SXS_FIND_CLR_CLASS_ACTIVATE_ACTCTX |
        SXS_FIND_CLR_CLASS_GET_IDENTITY |
        SXS_FIND_CLR_CLASS_GET_PROGID |
        SXS_FIND_CLR_CLASS_GET_RUNTIME_VERSION |
        SXS_FIND_CLR_CLASS_GET_TYPE_NAME);

    //
    // Can't be both... I'm sure there's a logic thing I could do smarter here, but ohwell.
    //
    if ((dwFlags & SXS_FIND_CLR_CLASS_SEARCH_PROGID) && (dwFlags & SXS_FIND_CLR_CLASS_SEARCH_GUID))
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(CantSearchBothProgidAndGuid, ERROR_INVALID_PARAMETER);
    }
    //
    // But it has to be at least one of these.
    //
    else if ((dwFlags & (SXS_FIND_CLR_CLASS_SEARCH_PROGID | SXS_FIND_CLR_CLASS_SEARCH_GUID)) == 0)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MustHaveAtLeastOneSearchTypeSet, ERROR_INVALID_PARAMETER);
    }

    //
    // Activate if necessary
    //
    if (dwFlags & SXS_FIND_CLR_CLASS_ACTIVATE_ACTCTX)
    {
        IFW32FALSE_EXIT(ActivationScope.Win32Activate(hActivationContext));
        AddRefActCtx(hActivationContext);
        UsedHandleDuringSearch = hActivationContext;
    }
    else
    {
        IFW32FALSE_EXIT(GetCurrentActCtx(&UsedHandleDuringSearch));
    }

    //
    // Aha, they wanted a progid search
    //
    if (dwFlags & SXS_FIND_CLR_CLASS_SEARCH_PROGID)
    {
        PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION pProgidFound = NULL;
        
        IFW32FALSE_EXIT(
            FindActCtxSectionStringW(
                0, 
                NULL, 
                ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, 
                (LPCWSTR)pvSearchData, 
                &KeyedData));

        pProgidFound = (PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION)KeyedData.lpData;
        GuidToSearch = *(LPGUID)(((ULONG_PTR)KeyedData.lpSectionBase) + pProgidFound->ConfiguredClsidOffset);
    }
    //
    // They handed us a GUID instead
    //
    else if (dwFlags & SXS_FIND_CLR_CLASS_SEARCH_GUID)
    {
        GuidToSearch = *(LPGUID)pvSearchData;
    }
    //
    // Hmm.. we validated these flags above, how could we possibly get here?
    //
    else
    {
        INTERNAL_ERROR_CHECK(FALSE);
    }

    //
    // Now that we've got the guids, let's look in the GUID clr class table for more information
    //
    RtlZeroMemory(&KeyedData, sizeof(KeyedData));
    KeyedData.cbSize = sizeof(KeyedData);
    IFW32FALSE_EXIT(
        FindActCtxSectionGuid(
            0,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
            &GuidToSearch,
            &KeyedData));

    pComServerRedirect = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)KeyedData.lpData;

    //
    // What do we want to do here if you've asked for a CLR class and yet there's no surrogate
    // information??
    //
    if (pComServerRedirect->ShimDataOffset == 0)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(ThisGuidIsNotAClrClass, ERROR_SXS_KEY_NOT_FOUND);
    }

    pClrShim = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM)(((ULONG_PTR)pComServerRedirect) + pComServerRedirect->ShimDataOffset);

    //
    // Now we've got all the stuff we need.  Calculate the required size of things.
    //
    cbRequired = sizeof(SXS_CLR_CLASS_INFORMATION);
    
    if ((dwFlags & SXS_FIND_CLR_CLASS_GET_PROGID) && (pComServerRedirect->ProgIdLength > 0))
        cbRequired += pComServerRedirect->ProgIdLength + sizeof(WCHAR);

    if (dwFlags & SXS_FIND_CLR_CLASS_GET_IDENTITY)
    {
        IFW32FALSE_EXIT(
            SxspLookupAssemblyIdentityInActCtx(
                UsedHandleDuringSearch, 
                KeyedData.ulAssemblyRosterIndex, 
                AssemblyIdentity));

        if (AssemblyIdentity.Cch() > 0) {
            cbRequired += (AssemblyIdentity.Cch() + 1) * sizeof(WCHAR);
        }
    }

    if ((dwFlags & SXS_FIND_CLR_CLASS_GET_RUNTIME_VERSION) && (pClrShim->ShimVersionLength > 0))
        cbRequired += pClrShim->ShimVersionLength + sizeof(WCHAR);

    if ((dwFlags & SXS_FIND_CLR_CLASS_GET_TYPE_NAME) && (pClrShim->TypeLength > 0))
        cbRequired += pClrShim->TypeLength + sizeof(WCHAR);

    //
    // Is there enough space in the outbound buffer?
    //    
    if (cbRequired <= cbDataBuffer)
    {        
        PWSTR pwszCursor;
        SIZE_T cbRemaining = cbDataBuffer;

        pOutputStruct = (PSXS_CLR_CLASS_INFORMATION)pvDataBuffer;
        pwszCursor = (PWSTR)(pOutputStruct + 1);
        cbRemaining -= sizeof(SXS_CLR_CLASS_INFORMATION);

        pOutputStruct->ReferenceClsid = GuidToSearch;
        pOutputStruct->dwFlags = 0;
        pOutputStruct->dwSize = sizeof(*pOutputStruct);
        pOutputStruct->ulThreadingModel = pComServerRedirect->ThreadingModel;
        pOutputStruct->ulType = pClrShim->Type;

        if (dwFlags & SXS_FIND_CLR_CLASS_GET_IDENTITY)
        {
            SIZE_T cbWritten;
            pOutputStruct->pcwszImplementingAssembly = pwszCursor;
            
            IFW32FALSE_EXIT(
                AssemblyIdentity.Win32CopyIntoBuffer(
                    &pwszCursor, 
                    &cbRemaining, 
                    &cbWritten, 
                    NULL, 
                    NULL, 
                    NULL));
        }
        else
            pOutputStruct->pcwszImplementingAssembly = NULL;

        if (dwFlags & SXS_FIND_CLR_CLASS_GET_PROGID)
        {
            WRITE_INTO_BUFFER(
                pwszCursor, 
                pOutputStruct->pcwszProgId, 
                pComServerRedirect->ProgIdLength, 
                (PVOID)(((ULONG_PTR)pComServerRedirect) + pComServerRedirect->ProgIdOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszProgId = NULL;


        if (dwFlags & SXS_FIND_CLR_CLASS_GET_RUNTIME_VERSION)
        {
            WRITE_INTO_BUFFER(
                pwszCursor, 
                pOutputStruct->pcwszRuntimeVersion, 
                pClrShim->ShimVersionLength, 
                (PVOID)(((ULONG_PTR)pClrShim) + pClrShim->ShimVersionLength),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszRuntimeVersion = NULL;

        if (dwFlags & SXS_FIND_CLR_CLASS_GET_TYPE_NAME)
        {
            WRITE_INTO_BUFFER(
                pwszCursor, 
                pOutputStruct->pcwszTypeName, 
                pClrShim->TypeLength, 
                (PVOID)(((ULONG_PTR)pClrShim) + pClrShim->TypeOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszTypeName = NULL;

        *pcbDataBufferWrittenOrRequired = cbRequired;
    }
    else
    {
        *pcbDataBufferWrittenOrRequired = cbRequired;
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NotEnoughSpaceInOutboundBuffer, ERROR_INSUFFICIENT_BUFFER);
    }
    
    FN_EPILOG;
}
    



BOOL
WINAPI
SxsFindClrSurrogateInformation(
    DWORD       dwFlags,
    LPGUID      lpGuidToFind,
    HANDLE      hActivationContext,
    PVOID       pvDataBuffer,
    SIZE_T      cbDataBuffer,
    PSIZE_T     pcbDataBufferWrittenOrRequired
    )
{
    FN_PROLOG_WIN32;

    SIZE_T cbRequired = 0;
    PSXS_CLR_SURROGATE_INFORMATION pOutputStruct = NULL;
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE pSurrogateInfo = NULL;
    ACTCTX_SECTION_KEYED_DATA KeyedData = {sizeof(KeyedData)};
    CFusionActCtxScope ActCtxScope;
    CFusionActCtxHandle UsedActivationContext;
    CStringBuffer AssemblyIdentity;

    if (pcbDataBufferWrittenOrRequired != NULL)
        *pcbDataBufferWrittenOrRequired = 0;

    //
    // The data buffer has to be present, or the data buffer size has to be zero,
    // and the written-or-required value must be present as well.
    //
    PARAMETER_CHECK(pvDataBuffer || (cbDataBuffer == 0));
    PARAMETER_CHECK(pcbDataBufferWrittenOrRequired != NULL);
    IFINVALID_FLAGS_EXIT_WIN32(dwFlags, 
        SXS_FIND_CLR_SURROGATE_USE_ACTCTX |
        SXS_FIND_CLR_SURROGATE_GET_IDENTITY |
        SXS_FIND_CLR_SURROGATE_GET_RUNTIME_VERSION |
        SXS_FIND_CLR_SURROGATE_GET_TYPE_NAME);

    //
    // Steps we take here:
    // - Activate the actctx if required.
    // - Find the surrogate that corresponds to this progid
    // - Calculate required size of data
    // - If there's enough space, then start copying into the output blob
    // - Otherwise, set the "required" size and error out with ERROR_INSUFFICIENT_BUFFER
    //


    //
    // If we were told to use the actctx, then activate it over this function,
    // and get a reference to it into UsedActivationContext so we can query with
    // it later.
    //
    if (dwFlags & SXS_FIND_CLR_SURROGATE_USE_ACTCTX)
    {
        IFW32FALSE_EXIT(ActCtxScope.Win32Activate(hActivationContext));
        AddRefActCtx(hActivationContext);
        UsedActivationContext = hActivationContext;
    }
    //
    // Otherwise, grab the current actctx and go to town.  This addrefs the activation
    // context, so we can let UsedActivationContext's destructor release it on the
    // exit path.
    //
    else 
    {
        IFW32FALSE_EXIT(GetCurrentActCtx(&UsedActivationContext));
    }

    //
    // Initially, we require at least this amount of space.
    //
    cbRequired += sizeof(SXS_CLR_SURROGATE_INFORMATION);
    IFW32FALSE_EXIT(
        FindActCtxSectionGuid(
            0, 
            NULL, 
            ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES, 
            lpGuidToFind, 
            &KeyedData));
    
    //
    // Start totalling up the size
    //
    pSurrogateInfo = (PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE)KeyedData.lpData;

    if ((dwFlags & SXS_FIND_CLR_SURROGATE_GET_TYPE_NAME) && (pSurrogateInfo->TypeNameLength > 0))
        cbRequired += pSurrogateInfo->TypeNameLength + sizeof(WCHAR);

    if ((dwFlags & SXS_FIND_CLR_SURROGATE_GET_RUNTIME_VERSION) && (pSurrogateInfo->VersionLength > 0))
        cbRequired += pSurrogateInfo->VersionLength + sizeof(WCHAR);

    if (dwFlags & SXS_FIND_CLR_SURROGATE_GET_IDENTITY)
    {
        IFW32FALSE_EXIT(
            SxspLookupAssemblyIdentityInActCtx(
                UsedActivationContext, 
                KeyedData.ulAssemblyRosterIndex, 
                AssemblyIdentity));

        if (AssemblyIdentity.Cch() > 0) 
        {
            cbRequired += (AssemblyIdentity.Cch() + 1) * sizeof(WCHAR);
        }
    }

    //
    // Go stomp the gathered data into the right places
    //    
    if (cbRequired <= cbDataBuffer)
    {
        PWSTR pwszOutputCursor;
        SIZE_T cbRemaining = cbDataBuffer;
        SIZE_T cbWritten = 0;
        
        pOutputStruct = (PSXS_CLR_SURROGATE_INFORMATION)pvDataBuffer;
        pwszOutputCursor = (PWSTR)(pOutputStruct + 1);
        
        pOutputStruct->cbSize = sizeof(SXS_CLR_SURROGATE_INFORMATION);
        pOutputStruct->dwFlags = 0;
        pOutputStruct->SurrogateIdent = pSurrogateInfo->SurrogateIdent;

        //
        // Write things into the output buffer
        //
        if (dwFlags & SXS_FIND_CLR_SURROGATE_GET_IDENTITY)
        {
            pOutputStruct->pcwszImplementingAssembly = pwszOutputCursor;
            
            IFW32FALSE_EXIT(
                AssemblyIdentity.Win32CopyIntoBuffer(
                    &pwszOutputCursor,
                    &cbRemaining,
                    &cbWritten,
                    NULL, NULL, NULL));                
        }
        else
            pOutputStruct->pcwszImplementingAssembly = NULL;


        if (dwFlags & SXS_FIND_CLR_SURROGATE_GET_TYPE_NAME)
        {
            WRITE_INTO_BUFFER(
                pwszOutputCursor,
                pOutputStruct->pcwszSurrogateType,
                pSurrogateInfo->TypeNameLength,
                (PVOID)(((ULONG_PTR)pSurrogateInfo) + pSurrogateInfo->TypeNameOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszSurrogateType = NULL;

        if (dwFlags & SXS_FIND_CLR_SURROGATE_GET_RUNTIME_VERSION)
        {
            WRITE_INTO_BUFFER(
                pwszOutputCursor,
                pOutputStruct->pcwszRuntimeVersion,
                pSurrogateInfo->VersionLength,
                (PVOID)(((ULONG_PTR)pSurrogateInfo) + pSurrogateInfo->VersionOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszRuntimeVersion = NULL;
        
        *pcbDataBufferWrittenOrRequired = cbRequired;

    }
    else
    {
        *pcbDataBufferWrittenOrRequired = cbRequired;
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NotEnoughSpaceInOutputBuffer, ERROR_INSUFFICIENT_BUFFER);
    }

    FN_EPILOG;
}


BOOL
WINAPI
SxsLookupClrGuid(
    DWORD       dwFlags,
    LPGUID      pClsid,
    HANDLE      hActCtx,
    PVOID       pvOutputBuffer,
    SIZE_T      cbOutputBuffer,
    PSIZE_T     pcbOutputBuffer
    )
{
    FN_PROLOG_WIN32;

    if (pcbOutputBuffer)
        *pcbOutputBuffer = 0;

    CStackBackingBuffer BackingBuffer;
    DWORD dwLastError;
    SIZE_T cbRequired = 0;
    PSXS_GUID_INFORMATION_CLR pOutputTarget = NULL;
    PCWSTR pcwszRuntimeVersion = NULL;
    PCWSTR pcwszTypeName = NULL;
    PCWSTR pcwszAssemblyName = NULL;
    SIZE_T cchRuntimeVersion = 0;
    SIZE_T cchTypeName = 0;
    SIZE_T cchAssemblyName = 0;

    enum {
        eFoundSurrogate,
        eFoundClrClass,
        eNotFound
    } FoundThingType = eNotFound;

    PARAMETER_CHECK(pcbOutputBuffer != NULL);
    PARAMETER_CHECK(pvOutputBuffer || (cbOutputBuffer == 0));
    IFINVALID_FLAGS_EXIT_WIN32(dwFlags, 
        SXS_LOOKUP_CLR_GUID_USE_ACTCTX |
        SXS_LOOKUP_CLR_GUID_FIND_SURROGATE |
        SXS_LOOKUP_CLR_GUID_FIND_CLR_CLASS |
        SXS_LOOKUP_CLR_GUID_FIND_ANY);
    //
    // Nothing found yet, let's look into the surrogate data tables first
    //
    if ((FoundThingType == eNotFound) && ((dwFlags & SXS_LOOKUP_CLR_GUID_FIND_SURROGATE) != 0))
    {
        IFW32FALSE_EXIT_UNLESS3(
            SxsFindClrSurrogateInformation(
                SXS_FIND_CLR_SURROGATE_GET_ALL | ((dwFlags & SXS_LOOKUP_CLR_GUID_USE_ACTCTX) ? SXS_FIND_CLR_SURROGATE_USE_ACTCTX : 0),
                pClsid,
                hActCtx,
                BackingBuffer.GetArrayPtr(),
                BackingBuffer.GetSize(),
                &cbRequired),
            LIST_3(ERROR_SXS_SECTION_NOT_FOUND, ERROR_SXS_KEY_NOT_FOUND, ERROR_INSUFFICIENT_BUFFER),
            dwLastError);

        //
        // If we found the key and section, but the buffer was too small, resize and try again
        //
        if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            IFW32FALSE_EXIT(BackingBuffer.Win32SetSize(cbRequired, CStackBackingBuffer::eSetSizeModeExact));

            IFW32FALSE_EXIT_UNLESS3(
                SxsFindClrSurrogateInformation(
                    SXS_FIND_CLR_SURROGATE_GET_ALL | ((dwFlags & SXS_LOOKUP_CLR_GUID_USE_ACTCTX) ? SXS_FIND_CLR_SURROGATE_USE_ACTCTX : 0),
                    pClsid,
                    hActCtx,
                    BackingBuffer.GetArrayPtr(),
                    BackingBuffer.GetSize(),
                    &cbRequired),
                LIST_2(ERROR_SXS_SECTION_NOT_FOUND, ERROR_SXS_KEY_NOT_FOUND),
                dwLastError);
        }

        //
        // Great - we either succeeded during the first call, or we succeeded after
        // resizing our buffers.  Gather information, set the type, and continue.
        //
        if (dwLastError == ERROR_SUCCESS)
        {
            //
            // At this point, BackingBuffer contains goop about a CLR surrogate.  Ensure that
            // our output buffer is large enough, and then fill it out.
            //
            PCSXS_CLR_SURROGATE_INFORMATION pSurrogateInfo = 
                (PCSXS_CLR_SURROGATE_INFORMATION)BackingBuffer.GetArrayPtr();
            
            pcwszAssemblyName = pSurrogateInfo->pcwszImplementingAssembly;
            pcwszTypeName = pSurrogateInfo->pcwszSurrogateType;
            pcwszRuntimeVersion = pSurrogateInfo->pcwszRuntimeVersion;
            FoundThingType = eFoundSurrogate;
        }
    }

    //
    // We've yet to find anything, and the flags say we can look up a clr class
    //
    if ((FoundThingType == eNotFound) && ((dwFlags & SXS_LOOKUP_CLR_GUID_FIND_CLR_CLASS) != 0))
    {
        IFW32FALSE_EXIT_UNLESS3(
            SxsFindClrClassInformation(
                SXS_FIND_CLR_CLASS_SEARCH_GUID | SXS_FIND_CLR_CLASS_GET_ALL,
                (PVOID)pClsid,
                hActCtx,
                BackingBuffer.GetArrayPtr(),
                BackingBuffer.GetSize(),
                &cbRequired),
            LIST_3(ERROR_INSUFFICIENT_BUFFER, ERROR_SXS_SECTION_NOT_FOUND, ERROR_SXS_KEY_NOT_FOUND),
            dwLastError);

        if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            IFW32FALSE_EXIT(BackingBuffer.Win32SetSize(cbRequired, CStackBackingBuffer::eSetSizeModeExact));

            IFW32FALSE_EXIT_UNLESS3(
                SxsFindClrClassInformation(
                    SXS_FIND_CLR_CLASS_SEARCH_GUID | SXS_FIND_CLR_CLASS_GET_ALL,
                    (PVOID)pClsid,
                    hActCtx,
                    BackingBuffer.GetArrayPtr(),
                    BackingBuffer.GetSize(),
                    &cbRequired),
                LIST_2(ERROR_SXS_SECTION_NOT_FOUND, ERROR_SXS_KEY_NOT_FOUND),
                dwLastError);            
        }

        //
        // We succeeded, either after the first query, or after resizing.
        //
        if (dwLastError == ERROR_SUCCESS)
        {
            PCSXS_CLR_CLASS_INFORMATION pClassInfo = 
                (PCSXS_CLR_CLASS_INFORMATION)BackingBuffer.GetArrayPtr();
            FoundThingType = eFoundClrClass;
            pcwszAssemblyName = pClassInfo->pcwszImplementingAssembly;
            pcwszRuntimeVersion = pClassInfo->pcwszRuntimeVersion;
            pcwszTypeName = pClassInfo->pcwszTypeName;
        }
    }
    
    //
    // If we got to this point and didn't find anything, then error out with a reasonable
    // error code.
    //
    if (FoundThingType == eNotFound)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(DidntFindObject, ERROR_NOT_FOUND);
    }

    //
    // Calculate some sizes - string lengths, etc.
    //
    cbRequired = sizeof(SXS_GUID_INFORMATION_CLR);
    cchAssemblyName = StringLength(pcwszAssemblyName);
    cchRuntimeVersion = StringLength(pcwszRuntimeVersion);
    cchTypeName = StringLength(pcwszTypeName);
    cbRequired += (cchAssemblyName + cchRuntimeVersion + cchTypeName + 3) * sizeof(WCHAR);

    //
    // If there was enough space, start stomping data into the output buffer
    //
    if (cbRequired <= cbOutputBuffer)
    {
        PWSTR pwszCursor;
        pOutputTarget = (PSXS_GUID_INFORMATION_CLR)pvOutputBuffer;
        pwszCursor = (PWSTR)(pOutputTarget + 1);

        pOutputTarget->cbSize = sizeof(*pOutputTarget);
        pOutputTarget->dwFlags = 0;

        switch (FoundThingType) {
        case eFoundClrClass: 
            pOutputTarget->dwFlags |= SXS_GUID_INFORMATION_CLR_FLAG_IS_CLASS; 
            break;
        case eFoundSurrogate: 
            pOutputTarget->dwFlags |= SXS_GUID_INFORMATION_CLR_FLAG_IS_SURROGATE; 
            break;
        default:
            INTERNAL_ERROR_CHECK(FALSE);
            break;
        }

        //
        // This grossness is unfortunately required.
        //
        pOutputTarget->pcwszAssemblyIdentity = pwszCursor;
        wcscpy(pwszCursor, pcwszAssemblyName);
        pwszCursor += cchAssemblyName + 1;

        pOutputTarget->pcwszRuntimeVersion= pwszCursor;
        wcscpy(pwszCursor, pcwszRuntimeVersion);
        pwszCursor += cchRuntimeVersion+ 1;

        pOutputTarget->pcwszTypeName = pwszCursor;
        wcscpy(pwszCursor, pcwszTypeName);
        pwszCursor += cchTypeName + 1;

        *pcbOutputBuffer = cbRequired;

    }
    else
    {
        *pcbOutputBuffer = cbRequired;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(NotEnoughSpaceInOutputBuffer, ERROR_INSUFFICIENT_BUFFER);
    }
    
    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsasmitem.h ===
//depot/private/lab01_fusion/base/win32/fusion/dll/whistler/sxsasmitem.h#3 - edit change 16520 (text)
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsasmitem.h

Abstract:

    CAssemblyCacheItem implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:
    xiaoyuw     10/26/2000      revise during Beta2 code-review period
--*/
#if !defined(_FUSION_SXS_ASMITEM_H_INCLUDED_)
#define _FUSION_SXS_ASMITEM_H_INCLUDED_

#pragma once

#include <windows.h>
#include <winerror.h>
#include "fusion.h"
#include "sxsinstall.h"

class CAssemblyCacheItem : public IAssemblyCacheItem
{
public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyCacheItem methods
    STDMETHOD(CreateStream)(
        /* [in]  */ DWORD dwFlags,
        /* [in]  */ LPCWSTR pszName,
        /* [in]  */ DWORD dwFormat,
        /* [in]  */ DWORD dwFormatFlags,
        /* [out] */ IStream** ppStream,
		/* [in, optional] */ ULARGE_INTEGER *puliMaxSize);

    STDMETHOD(Commit)(
        /* [in] */ DWORD dwFlags,
		/* [out, optional] */ ULONG *pulDisposition);
    STDMETHOD(AbortItem)();

    // Constructor and Destructor
    CAssemblyCacheItem();
    ~CAssemblyCacheItem();

    HRESULT Initialize();

private:

    ULONG                       m_cRef;                // refcount
    BOOL                        m_fCommit;             // whether this asmcache has been commit or not
    BOOL                        m_fManifest;           // whether a manifest has been submit before commit or more than once
    ULONG                       m_cStream;             // stream count for an AssemblyCacheItem
    CStringBuffer               m_strTempDir;          // temporary directory for this assembly
    CSmallStringBuffer          m_strUidBuf;           // used in SxsCreateWinSxsTempDirectory

    CStringBuffer               m_strManifestFileName; // full-path manifest filename for Jay's API
    CRunOnceDeleteDirectory     *m_pRunOnceCookie;     // not the cookie to create the temporary directory
    CAssemblyInstall*           m_pInstallCookie;
private:
    CAssemblyCacheItem(const CAssemblyCacheItem &r); // intentionally not implemented
    CAssemblyCacheItem &operator =(const CAssemblyCacheItem &r); // intentionally not implemented

};

#endif // _FUSION_SXS_ASMITEM_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsdebug.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsdebug.cpp

Abstract:

    testing API for sxstest

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:

--*/
#include "stdinc.h"
#include "xmlparser.hxx"
#include "xmlparsertest.hxx"
#include "sxsinstall.h"
#include "sxsprotect.h"
#include <sxsapi.h>
#include "fusiontrace.h"
#include "sxsasmname.h"
#include "strongname.h"
#include "cassemblyrecoveryinfo.h"
#include "protectionui.h"


#define CONFIG_FILE_EXTENSION L".config"

BOOL TestReparsePointOnFullQualifiedPath(PCWSTR fullpath)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL CrossesReparsePoint;
    SIZE_T Start = 0;

    if ((wcschr(fullpath, '\\') == NULL) && (wcschr(fullpath, '/') == NULL))
    {
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    if (wcschr(fullpath, '\\'))
    {
        Start = (SIZE_T)(wcschr(fullpath, '\\') - fullpath);
    }

    if (wcschr(fullpath, '/') != NULL)
        if (Start < (ULONG(wcschr(fullpath, '/') - fullpath)))
            Start = wcschr(fullpath, '/') - fullpath;

    IFW32FALSE_EXIT(
        ::SxspDoesPathCrossReparsePoint(
            fullpath,
            Start,
            CrossesReparsePoint));

    fSuccess = TRUE;

Exit:
    return fSuccess;
}


HRESULT TestDeleteInstalledAssemblyBasedOnAssemblyName()
{

    HRESULT hr = S_OK;
    FN_TRACE_HR(hr);
/*    PCWSTR manifest_files[] = {L"Z:\\tests\\footest\\cdfiles\\cards_chn\\cards.manifest",
        L"Z:\\tests\\footest\\cdfiles\\cards_gen\\cards.manifest",
        L"Z:\\tests\\footest\\cdfiles\\cards_jan\\cards.manifest",
        L"Z:\\tests\\footest\\cdfiles\\cards_en\\cards.manifest",
        L"Z:\\tests\\footest\\cdfiles\\cards_en_us\\cards.manifest" };*/
    //PCWSTR manifest_files[] = { L"Z:\\tests\\footest\\cdfiles\\cards_0000\\cards.manifest" };
    //PCWSTR manifest_files[] = { L"Z:\\tests\\footest\\cdfiles\\policy\\policy1\\asmpol.MANIFEST" };
    PCWSTR manifest_files[] = { L"Z:\\tests\\footest\\cdfiles\\policy\\policy1\\asmpol.MANIFEST" };
    CAssemblyInstall * pInstallCookie=NULL;
    SXS_INSTALL_SOURCE_INFO sinfo;
    CStringBuffer sbTemp;
    const static WCHAR pwzFileName[] = L"c:\\install.logfile";
    //BOOL fEmpty;

    ZeroMemory(&sinfo, sizeof(sinfo));
    sinfo.cbSize = sizeof(sinfo);
    sinfo.pcwszLogFileName = pwzFileName;
    sinfo.dwFlags = SXSINSTALLSOURCE_CREATE_LOGFILE;

    IFW32FALSE_EXIT(::SxsBeginAssemblyInstall(0, NULL, NULL, NULL, NULL, (PVOID *)&pInstallCookie));

    for (DWORD i = 0; i < NUMBER_OF(manifest_files); i++)
    {
        IFW32FALSE_EXIT(::SxsInstallAssemblyW(pInstallCookie, SXS_INSTALL_ASSEMBLY_FLAG_CREATE_LOGFILE, manifest_files[i], &sinfo));
    }

    if (!SUCCEEDED(hr))
    {
        HRESULT oldHr = hr ;
        IFW32FALSE_EXIT(::SxsEndAssemblyInstall(pInstallCookie, SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT, NULL));
        hr = oldHr;
    }else
    {
        IFW32FALSE_EXIT(::SxsEndAssemblyInstall(pInstallCookie, SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT, NULL));
        hr = NOERROR;
    }


    // IFW32FALSE_EXIT(::SxsUninstallAssembly(SXS_UNINSTALL_ASSEMBLY_FLAG_USING_INSTALL_LOGFILE, pwzFileName, NULL, NULL));

    FN_EPILOG
}

HRESULT TestAssemblyName()
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    //const WCHAR super_simple_inputstring[] = L"cards,version=\"1.0.0.0\",processorArchitecture=\"x86\",language=\"0409\",whatever=\"whatever\"";
    const WCHAR super_simple_inputstring[] = L"cards,version=\"1.0.0.0\",processorArchitecture=\"x86\",language=\"0409\"";
    //const WCHAR super_simple_inputstring[] = L"cards,,,,,";
//    const WCHAR simple_inputstring[] = L"ca&#x2c;r&#x2c;d&#x22;s,http://fusion:whatever=\"&#x22;&#x2c;0&#x2c;&#x22;\",http://fusion:processorarchitecture=\"x86\",http://neptune:language=\"0409\"";
//    const WCHAR complex_inputstring[] = L"firstcards&#x22;secondcards,http://fusion:version=\"1.0.0.0\",http://www.shuku.net/novels/prose/zxfjdsw:whatever=\"what&#x2c;ever\"";
    CAssemblyName * pAsmName = NULL;
    IAssemblyName * pIAsmName = NULL;
    LPWSTR szDisplayName = NULL ;
    ULONG ccDisplayName = 0;
    LPWSTR psz = NULL;
    CSmartRef<IAssemblyCache> pCache;
    CStringBuffer bufPath;
    PCWSTR szAssemblyStr = super_simple_inputstring;

    IFCOMFAILED_EXIT(::CreateAssemblyCache(&pCache, 0));
    // parse : convert string from Darwin to Fusion
    IFCOMFAILED_EXIT(::CreateAssemblyNameObject(&pIAsmName, szAssemblyStr, CANOF_PARSE_DISPLAY_NAME, NULL));
    pAsmName = reinterpret_cast<CAssemblyName*>(pIAsmName);
    ccDisplayName = static_cast<ULONG>(wcslen(szAssemblyStr));
    ccDisplayName ++;    // for worst case
    szDisplayName = NEW (WCHAR[ccDisplayName]);

    if (!szDisplayName)
        goto Exit;
    // GetDisplayName: convert string from Fusion to Darwin
    IFCOMFAILED_EXIT(pAsmName->GetDisplayName(szDisplayName, &ccDisplayName, 0));
    //ASSERT(wcscmp(szDisplayName, szAssemblyStr) == 0);
    IFCOMFAILED_EXIT(pAsmName->GetInstalledAssemblyName(0, SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY, bufPath));
    hr = NOERROR;
Exit:
    if (pAsmName)
        pAsmName->Release();

    delete[] szDisplayName;
    delete[] psz ;
    return hr;
}

BOOL
SxspManifestSchemaCheck(
    PCWSTR  parameterstring // this must be a full-qualified filename of a manifest file
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ACTCTXGENCTX ActCtxGenCtx;
    ULONG ManifestFlags;
    CProbedAssemblyInformation AssemblyInformation;
    CImpersonationData ImpersonationData;
    PCWSTR Slash = NULL;
    PASSEMBLY Asm = NULL;
    CStringBuffer buffManifestPath;
    USHORT ProcessorArchitecture = ::SxspGetSystemProcessorArchitecture();
    LANGID LangId = ::GetUserDefaultLangID();
// BUGBUG xiaoyuw@09/17/00 : disable to set Name ans version fro mthe command line for simplicity
    PARAMETER_CHECK(parameterstring != NULL);

    IFW32FALSE_EXIT(AssemblyInformation.Initialize());

    IFW32FALSE_EXIT(buffManifestPath.Win32Assign(parameterstring, ::wcslen(parameterstring)));

    IFW32FALSE_EXIT(
        ::SxspInitActCtxGenCtx(
                &ActCtxGenCtx,         // context out
                MANIFEST_OPERATION_VALIDATE_SYNTAX,
                0,
                0,
                ImpersonationData,
                ProcessorArchitecture,
                LangId,
                ACTIVATION_CONTEXT_PATH_TYPE_NONE,
                0,
                NULL));
    // get manifestpath, manifestName, manifestVersion
    Slash = wcsrchr(buffManifestPath, L'\\');
    PARAMETER_CHECK(Slash != NULL);

    IFALLOCFAILED_EXIT(Asm = new ASSEMBLY);

    ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_FILE;

    IFW32FALSE_EXIT(AssemblyInformation.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, buffManifestPath));

    IFW32FALSE_EXIT(AssemblyInformation.SetManifestFlags(ManifestFlags));
    IFW32FALSE_EXIT(AssemblyInformation.SetManifestLastWriteTime(&ActCtxGenCtx)); // using default parameter-value

    IFW32FALSE_EXIT(::SxspInitAssembly(Asm, AssemblyInformation));
    IFW32FALSE_EXIT(::SxspIncorporateAssembly(&ActCtxGenCtx, Asm));
    IFW32FALSE_EXIT(::SxspFireActCtxGenEnding(&ActCtxGenCtx));

    fSuccess = TRUE;
Exit:
    if (Asm != NULL)
        Asm->Release();

    return fSuccess;
}

#if SXS_PRECOMPILED_MANIFESTS_ENABLED

HRESULT
GetPCMWorkingTime(PCWSTR filename, LARGE_INTEGER* pcmtime)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    CStringBuffer buf ;
    CSmartRef<XMLParserTestFactory>    factory;
    CSmartRef<CPrecompiledManifestReader> pPCMReader;
    LARGE_INTEGER timestart = {0};
    ULONG i = 0;
    ULONG j = 0;

    buf.Assign(filename, ::wcslen(filename));
    buf.Append(L".pcm", 4);

    factory = new XMLParserTestFactory;
    if (! factory) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pPCMReader = new CPrecompiledManifestReader);
    if (! pPCMReader) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    for (j=0; j<10; j++) {
        ::QueryPerformanceCounter(&timestart);
        for (i = 0 ; i < 10; i++) {
            hr = pPCMReader->InvokeNodeFactory(buf, factory);
            if (FAILED(hr))
                goto Exit;
        }
         ::QueryPerformanceCounter(&pcmtime[j]);
         pcmtime[j].QuadPart -= timestart.QuadPart;
    }

    hr = NOERROR;
Exit:
    return hr;
}

#endif // SXS_PRECOMPILED_MANIFESTS_ENABLED

HRESULT GetParserWorkingTime(PCWSTR filename, LARGE_INTEGER* parsertime)
{
    HRESULT                 hr = S_OK;
    FN_TRACE_HR(hr);
    LARGE_INTEGER t1[10], t2[10];
    LARGE_INTEGER timestart;
    ULONG i, j;
    CSmartRef<IXMLParser>    pIXMLParser;
    CSmartRef<XMLParserTestFactory> factory;
    CSmartRef<XMLParserTestFileStream> filestream;

    filestream = NEW (XMLParserTestFileStream());
    if (!filestream) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFileStream, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;

    }

    if (! filestream->open(filename))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to call XMLParserTestFileStream::open\n");

        hr = E_UNEXPECTED;
        goto Exit;
    }

    factory = new XMLParserTestFactory;
    if (! factory) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pIXMLParser = NEW(XMLParser);
    if (pIXMLParser == NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Attempt to instantiate XML parser failed\n");
        goto Exit;
    }

    hr = pIXMLParser->SetInput(filestream); // filestream's RefCount=2
    if (! SUCCEEDED(hr))
        goto Exit;

    hr = pIXMLParser->SetFactory(factory); // factory's RefCount=2
    if (! SUCCEEDED(hr))
        goto Exit;

    for (j =0; j<10; j++) {
        ::QueryPerformanceCounter(&timestart);
        for (i = 0 ; i< 10; i++) {
           hr = pIXMLParser->Run(-1);
           if (FAILED(hr))
               goto Exit;
           pIXMLParser->Reset();
           pIXMLParser->SetFactory(factory);
           filestream->close();
           filestream->open(filename);
           pIXMLParser->SetInput(filestream);
        }
        ::QueryPerformanceCounter(&t1[j]);
        t1[j].QuadPart -= timestart.QuadPart;

        ::QueryPerformanceCounter(&timestart);
        for (i = 0 ; i< 10; i++) {
           hr = NOERROR;
           if (FAILED(hr))
               goto Exit;
           pIXMLParser->Reset();
           pIXMLParser->SetFactory(factory);
           filestream->close();
           filestream->open(filename);
           pIXMLParser->SetInput(filestream);
        }
        ::QueryPerformanceCounter(&t2[j]);
        t2[j].QuadPart -= timestart.QuadPart;

        parsertime[j].QuadPart = t1[j].QuadPart - t2[j].QuadPart;
    }

    hr = NOERROR;
Exit:
    return hr;
}

#if SXS_PRECOMPILED_MANIFESTS_ENABLED

HRESULT TestPCMTime(PCWSTR manifestfilename)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    LARGE_INTEGER tmp1 = {0};
    LARGE_INTEGER tmp2 = {0};
    LARGE_INTEGER parsertime[10] = {0}, pcmtime[10] = {0};
    ULONG i = 0;

    hr = GetParserWorkingTime(manifestfilename, parsertime);
    if (FAILED(hr))
        goto Exit;

    hr = GetPCMWorkingTime(manifestfilename, pcmtime);
    if (FAILED(hr))
        goto Exit;

    for (i= 0 ; i < 10; i ++){
        tmp1.QuadPart = tmp1.QuadPart + parsertime[i].QuadPart;
        tmp2.QuadPart = tmp2.QuadPart + pcmtime[i].QuadPart;
    }
    tmp1.QuadPart = tmp1.QuadPart/10;
    tmp2.QuadPart = tmp2.QuadPart/10;

    ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_INFO,
                    "SxsDebug::TestPCMTime Result:\n\tXMLParser uses %d,\n\tPCM uses %d,\n\tthe difference is %d.\n",
                    tmp1.QuadPart, tmp2.QuadPart, tmp1.QuadPart-tmp2.QuadPart);

    hr = NOERROR;
Exit:
    return hr;
}

/* ---------------------------------------------------------------------------
 Two steps :
   1. paring the manifest file,
        generate the NodeFactory print-out file1,
        generate the precompiled-manifest
   2. using precompiled-manifest and call NodeFactory to generate pcm-printout file2
   3. Compare file1 and file2

--------------------------------------------------------------------------- */
HRESULT
PrecompiledManifestTest(PCWSTR filename) // this is a manifest file name
{
    HRESULT                     hr = S_OK;
    FN_TRACE_HR(hr);
    CSmartRef<IXMLParser>       pIXMLParser;
    CSmartRef<PCMTestFactory>   wfactory;
    CSmartRef<PCMTestFactory>   rfactory;
    CSmartRef<XMLParserTestFileStream> filestream;
    CStringBuffer               buf;
    CSmartRef<CPrecompiledManifestWriter> pPCMWriter;
    CSmartRef<CPrecompiledManifestReader> pPCMReader;
    FILE                        *fp = NULL;

    if (!filename) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    buf.Assign(filename, ::wcslen(filename));
    buf.Append(L".pcm", 4);

    // create filestream for xmlparser ...
    filestream = NEW (XMLParserTestFileStream());
    if (!filestream) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFileStream, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;

    }
    if (! filestream->open(filename))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to call XMLParserTestFileStream::open\n");

        hr = E_UNEXPECTED;
        goto Exit;
    }

    // create PCMWriter for xmlparser
    wfactory = new PCMTestFactory("e:\\manifest.out"));
    if (! wfactory) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pPCMWriter = new CPrecompiledManifestWriter);
    if (! pPCMWriter) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pPCMWriter->Initialize(buf);
    pPCMWriter->SetFactory(wfactory);

    // Create XMLParser
    pIXMLParser = NEW(XMLParser);
    if (pIXMLParser == NULL){
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Attempt to instantiate XML parser failed\n");
        goto Exit;
    }

    hr = pIXMLParser->SetInput(filestream); // filestream's RefCount=2
    if (! SUCCEEDED(hr))
        goto Exit;

    hr = pIXMLParser->SetFactory(pPCMWriter); // wfactory's RefCount=2
    if (! SUCCEEDED(hr))
        goto Exit;

    hr = pIXMLParser->Run(-1);
    if (FAILED(hr))
        goto Exit;

    hr = pPCMWriter->Close();
    if (FAILED(hr))
        goto Exit;

    CSimpleFileStream::printf(L"PCM has been generated!!!\n\n");

    // PCM Reader
    pPCMReader = new CPrecompiledManifestReader);
    if (! pPCMReader) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    rfactory = new PCMTestFactory("e:\\pcm.out"));
    if (! rfactory) {

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pPCMReader->InvokeNodeFactory(buf, rfactory);
    if (FAILED(hr))
        goto Exit;
    hr = NOERROR;
Exit:
    return hr;
}

#endif // SXS_PRECOMPILED_MANIFESTS_ENABLED

BOOL CreateMultiLevelDirectoryTest(PCWSTR pwszNewDirs)
{
    BOOL fSuccess = TRUE;
    FN_TRACE_WIN32(fSuccess);
    const static WCHAR CurrentDirectory[]=L"e:\\tmp\\tmp";

    IFW32FALSE_EXIT(::SxspCreateMultiLevelDirectory(CurrentDirectory, pwszNewDirs));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}
BOOL TestCopyDirectory()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer m1;
    CStringBuffer m2;

    IFW32FALSE_EXIT(m1.Win32Assign(L"Z:\\tmp\\tmp", NUMBER_OF(L"Z:\\tmp\\tmp")-1));
    IFW32FALSE_EXIT(m2.Win32Assign(L"Z:\\tests\\tmp", NUMBER_OF(L"Z:\\tests\\tmp")-1));

    IFW32FALSE_EXIT(::SxspInstallMoveFileExW(m1, m2, MOVEFILE_REPLACE_EXISTING));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}
BOOL TestSxsGeneratePath()
{
    //
    // the result is as below
    //
    //path is c:\winnt\winsxs\Manifests\x86_dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_fb8e827d.Manifest
    //path is Manifests\x86_dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_fb8e827d.Manifest
    //path is c:\winnt\winsxs\Manifests\
    //path is Manifests\x86_dynamicdll_b54bc117ce08a1e8_en-us_2ffeb063.Manifest
    //---------------------------------------
    //path is c:\winnt\winsxs\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_d51541cb\
    //path is x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_d51541cb\
    //path is c:\winnt\winsxs\
    //path is x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95\
    //---------------------------------------
    //path is c:\winnt\winsxs\Policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95\1.1.0.0.Policy
    //path is Policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95\1.1.0.0.Policy
    //path is c:\winnt\winsxs\Policies\
    //path is Policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95\1.1.0.0.Policy

    // if the assembly does not have version, flag=0 and pathType=policy would generate "policy store"
    //       c:\winnt\winsxs\Policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95
    //

    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer PathBuffer;
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    //WCHAR szDisplayName[]=L"policy.1.0.dynamicdll,type=\"win32-policy\",publicKeyToken=\"b54bc117ce08a1e8\",version=\"1.1.0.0\",language=\"en-us\",processorArchitecture=\"x86\"";
    PWSTR szDisplayName[]= {
        L"dynamicdll,type=\"win32\",publicKeyToken=\"b54bc117ce08a1e8\",version=\"1.1.0.0\",language=\"en-us\",processorArchitecture=\"x86\"",
        L"policy.1.0.dynamicdll,type=\"win32-policy\",publicKeyToken=\"b54bc117ce08a1e8\",version=\"1.1.0.0\",language=\"en-us\",processorArchitecture=\"x86\"",
        L"policy.1.0.dynamicdll,type=\"win32-policy\",publicKeyToken=\"b54bc117ce08a1e8\",version=\"1.1.0.0\",language=\"en-us\",processorArchitecture=\"x86\""
    };

    DWORD j, dwPathType;

    DWORD flags[]={
        0,
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
        SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH,
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION};


    printf("---------------------------------------\n");
    for (dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST; dwPathType <= SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY; dwPathType++)
    //for (dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY; dwPathType <= SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY; dwPathType++)
    {
        IFW32FALSE_EXIT(SxspCreateAssemblyIdentityFromTextualString(
                szDisplayName[dwPathType - 1],
                &pAssemblyIdentity));

        for (j = 0 ; j < NUMBER_OF(flags); j++)
        {
            IFW32FALSE_EXIT(::SxspGenerateSxsPath(
                flags[j],
                dwPathType,
                L"c:\\winnt\\winsxs",
                wcslen(L"c:\\winnt\\winsxs"),
                pAssemblyIdentity,
                PathBuffer));
            printf("path is %S\n", static_cast<PCWSTR>(PathBuffer));
        }
        printf("---------------------------------------\n");
        SxsDestroyAssemblyIdentity(pAssemblyIdentity);
        pAssemblyIdentity = NULL;
    }
    fSuccess = TRUE;
Exit:
    if (pAssemblyIdentity)
        SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return fSuccess;
}

BOOL ManifestProbeTest()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD index = 0;
    CStringBuffer PathBuffer;
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;

    ASSEMBLY_IDENTITY_ATTRIBUTE AttributeName;
    ASSEMBLY_IDENTITY_ATTRIBUTE AttributeVersion;
    ASSEMBLY_IDENTITY_ATTRIBUTE AttributeLangID;
    ASSEMBLY_IDENTITY_ATTRIBUTE AttributeProcessorArchitecture;
    PASSEMBLY_IDENTITY_ATTRIBUTE Attributes[] = {
            &AttributeName, &AttributeVersion,
            &AttributeLangID, &AttributeProcessorArchitecture};


    AttributeName.Flags         = 0; // reserved flags : must be 0;
    AttributeName.NamespaceCch  = 0;
    AttributeName.NameCch       = 4;
    AttributeName.ValueCch      = 7;
    AttributeName.Namespace     = NULL;
    AttributeName.Name          = L"name";
    AttributeName.Value         = L"foo.mui";

    AttributeVersion.Flags         = 0; // reserved flags : must be 0;
    AttributeVersion.NamespaceCch  = 0;
    AttributeVersion.NameCch       = 7;
    AttributeVersion.ValueCch      = 7;
    AttributeVersion.Namespace     = NULL;
    AttributeVersion.Name          = L"version";
    AttributeVersion.Value         = L"1.1.1.1";

    AttributeLangID.Flags         = 0; // reserved flags : must be 0;
    AttributeLangID.NamespaceCch  = 0;
    AttributeLangID.NameCch       = 8;
    AttributeLangID.ValueCch      = 5;
    AttributeLangID.Namespace     = NULL;
    AttributeLangID.Name          = L"language";
    AttributeLangID.Value         = L"en-us";

    AttributeProcessorArchitecture .Flags         = 0; // reserved flags : must be 0;
    AttributeProcessorArchitecture .NamespaceCch  = 0;
    AttributeProcessorArchitecture .NameCch       = 21;
    AttributeProcessorArchitecture .ValueCch      = 3;
    AttributeProcessorArchitecture .Namespace     = NULL;
    AttributeProcessorArchitecture .Name          = L"processorArchitecture";
    AttributeProcessorArchitecture .Value         = L"x86";

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(
        0,                                      // DWORD Flags,
        ASSEMBLY_IDENTITY_TYPE_DEFINITION,      // ULONG Type,
        &pAssemblyIdentity,
        4,                                      // ULONG AttributeCount,
        Attributes));                           // PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes


    while(1) {// run until we run out of probing-path
        bool fDone = false;
        if (!::SxspGenerateManifestPathForProbing(
                index,
                0,
                NULL,
                0,
                ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
                L"E:\\APPBASE\\",
                11,
                pAssemblyIdentity,
                PathBuffer,
                NULL,
                fDone))
        {
            goto Exit;
        }

        if (fDone)
            break;

        PathBuffer.Clear();
        index ++;
    }

    fSuccess = TRUE;

Exit:
    if (pAssemblyIdentity)
        SxsDestroyAssemblyIdentity(pAssemblyIdentity);
    if (!fSuccess) {
        DWORD dwLastError = ::FusionpGetLastWin32Error();
        if (dwLastError == BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_DEPENDENCY_ASSEMBLY_NOT_FOUND){
            ::FusionpSetLastWin32Error(0);
            fSuccess = TRUE;
        }
    }
    return fSuccess;
}


#define WATCHBUCKET_NOTIFYSIZE (1024)
typedef struct _tWATCH_BUCKET
{
    HANDLE                  hFile;
    HANDLE                  hCompleteEvent;
    PCSXS_PROTECT_DIRECTORY pProtectInfo;
    OVERLAPPED              olapInfo;
    BYTE                    NotifyInfo[WATCHBUCKET_NOTIFYSIZE];
    DWORD                   dwBytesBack;
}
WATCH_BUCKET, *PWATCH_BUCKET;


HRESULT
TryWatchingDirectories()
{
    PCSXS_PROTECT_DIRECTORY pWatchList;
    SIZE_T cWatchList;
    DWORD dwWhichSignalled;
    DWORD dw;
    PWATCH_BUCKET pWatchBuckets;
    HANDLE* pHandleList;
    HRESULT hrSuccess = E_FAIL;

    FN_TRACE_HR(hrSuccess);

    IFW32FALSE_EXIT(::SxsProtectionGatherEntriesW(&pWatchList, &cWatchList));
    pWatchBuckets = FUSION_NEW_ARRAY(WATCH_BUCKET, cWatchList);
    pHandleList = FUSION_NEW_ARRAY(HANDLE, cWatchList);

    //
    // Fill in the list with handles to directories
    //
    for (dw = 0; dw < cWatchList; dw++)
    {
        PWATCH_BUCKET pbTemp = pWatchBuckets + dw;
        ZeroMemory(pbTemp, sizeof(*pbTemp));

        pbTemp->pProtectInfo = pWatchList + dw;
        pbTemp->hFile = ::CreateFileW(
            pWatchList[dw].pwszDirectory,
            FILE_LIST_DIRECTORY,
            FILE_SHARE_READ | FILE_SHARE_DELETE | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
            NULL);

        pHandleList[dw] = CreateEventW(NULL, FALSE, FALSE, NULL);
        pbTemp->hCompleteEvent = pHandleList[dw];
        pbTemp->olapInfo.hEvent = pHandleList[dw];

        ::ReadDirectoryChangesW(
            pbTemp->hFile,
            (PVOID)(&pbTemp->NotifyInfo),
            WATCHBUCKET_NOTIFYSIZE,
            pbTemp->pProtectInfo->ulRecursiveFlag & SXS_PROTECT_RECURSIVE,
            SXS_PROTECT_FILTER_DEFAULT,
            &pbTemp->dwBytesBack,
            &pbTemp->olapInfo,
            NULL);
    }

    //
    // We now have a list of directories that we need to watch for changes.
    //
    while (true)
    {
        dwWhichSignalled = WaitForMultipleObjects(static_cast<DWORD>(cWatchList), pHandleList, FALSE, INFINITE);
        dwWhichSignalled -= WAIT_OBJECT_0;

        if (dwWhichSignalled < cWatchList)
        {
            //
            // Somebody went and fiddled with a directory!
            //
            dwWhichSignalled -= WAIT_OBJECT_0;
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INFO,
                "Someone changed: %ls\n",
                pWatchBuckets[dwWhichSignalled].pProtectInfo->pwszDirectory);

            ResetEvent(pHandleList[dwWhichSignalled]);

            PFILE_NOTIFY_INFORMATION pCursor;

            pCursor = (PFILE_NOTIFY_INFORMATION) pWatchBuckets[dwWhichSignalled].NotifyInfo;
            while (true)
            {
                ::SxsProtectionNotifyW(
                    (PVOID)pWatchBuckets[dwWhichSignalled].pProtectInfo,
                    pCursor->FileName,
                    pCursor->FileNameLength / sizeof(pCursor->FileName[0]),
                    pCursor->Action);

                if (pCursor->NextEntryOffset)
                    pCursor = (PFILE_NOTIFY_INFORMATION)(((PBYTE)pCursor) + pCursor->NextEntryOffset);
                else
                    break;
            }

            ::ReadDirectoryChangesW(
                pWatchBuckets[dwWhichSignalled].hFile,
                (PVOID)(&pWatchBuckets[dwWhichSignalled].NotifyInfo),
                WATCHBUCKET_NOTIFYSIZE,
                pWatchBuckets[dwWhichSignalled].pProtectInfo->ulRecursiveFlag & SXS_PROTECT_RECURSIVE,
                SXS_PROTECT_FILTER_DEFAULT,
                &pWatchBuckets[dwWhichSignalled].dwBytesBack,
                &pWatchBuckets[dwWhichSignalled].olapInfo,
                NULL);
        }
    }

    hrSuccess = S_OK;
Exit:
    return hrSuccess;
}

BOOL
DllRedirectionTest(
    PCWSTR manifestFileName
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CFileStream manifestFileStream;
    CResourceStream ResourceStream;
    CFileStream policyFileStream;
    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS parameters = {0};
    CUnicodeStringBuffer assemblyDirectory;
    CStringBuffer CandidatePolicyPathBuffer;
    BOOL fPolicyExist=FALSE;
    PWSTR p=NULL;

    p = wcsrchr(manifestFileName, L'.');
    if (p && ((_wcsicmp(p, L".dll") ==0) || (_wcsicmp(p, L".exe") ==0))) // manifest is from a resource of a DLL or EXE
    {
        IFW32FALSE_EXIT(ResourceStream.Initialize(manifestFileName, MAKEINTRESOURCEW(RT_MANIFEST)));
        parameters.Manifest.Path = manifestFileName;
        parameters.Manifest.Stream = &ResourceStream;
        parameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;

        IFW32FALSE_EXIT(assemblyDirectory.Win32Assign(manifestFileName, ::wcslen(manifestFileName)));
        assemblyDirectory.RemoveLastPathElement();
        parameters.AssemblyDirectory = assemblyDirectory;
    }
    else
    {
        IFW32FALSE_EXIT(
            manifestFileStream.OpenForRead(
                manifestFileName,
                CImpersonationData(),
                FILE_SHARE_READ,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN));
        parameters.Manifest.Path = manifestFileName;
        parameters.Manifest.Stream = &manifestFileStream;
        parameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;

        IFW32FALSE_EXIT(assemblyDirectory.Win32Assign(manifestFileName, ::wcslen(manifestFileName)));
        assemblyDirectory.RemoveLastPathElement();
        parameters.AssemblyDirectory = assemblyDirectory;
    }

    // look for policy file in the same dir as the manifest path
    IFW32FALSE_EXIT(CandidatePolicyPathBuffer.Win32Assign(manifestFileName, ::wcslen(manifestFileName)));
    IFW32FALSE_EXIT(CandidatePolicyPathBuffer.Win32ChangePathExtension(CONFIG_FILE_EXTENSION, NUMBER_OF(CONFIG_FILE_EXTENSION) - 1, eErrorIfNoExtension));
    if (::GetFileAttributesW(CandidatePolicyPathBuffer) != -1) { // policy file exists
        fPolicyExist = TRUE;
        IFW32FALSE_EXIT(
            policyFileStream.OpenForRead(
                CandidatePolicyPathBuffer,
                CImpersonationData(),
                FILE_SHARE_READ,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN));

        parameters.Policy.Path = CandidatePolicyPathBuffer;
        parameters.Policy.Stream = &policyFileStream;
    }

    parameters.ProcessorArchitecture = 0 ;
    parameters.LangId = GetUserDefaultUILanguage();

    IFW32FALSE_EXIT(::SxsGenerateActivationContext(&parameters));
    fSuccess = TRUE;
Exit:
    CSxsPreserveLastError ple;

    ::CloseHandle(parameters.SectionObjectHandle);

    ple.Restore();

    return fSuccess;
}

BOOL TestFusionArray(PCWSTR dir1, PCWSTR dir2)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CStringBuffer sbDir1;
    CStringBuffer sbDir2;
    CFusionDirectoryDifference dirResult;


    IFW32FALSE_EXIT(sbDir1.Win32Assign(dir1, wcslen(dir1)));
    IFW32FALSE_EXIT(sbDir2.Win32Assign(dir2, wcslen(dir2)));
    IFCOMFAILED_EXIT(
        ::FusionpCompareDirectoriesSizewiseRecursively(
            &dirResult,
            sbDir1,
            sbDir2));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

//
// this function is written for Testing team to generate pAssemblyIdentity
// there are two ways to generate assemblyIdentity, one is insert one attribute each time,
// another way is to make all attributes to be inserted ready in an array and call
// SxsCreateAssemblyIdentity. The con and pro for both approaches are obvious,
// the input string must be in a format as "ns1:n1=v1;ns2:n2=v2;",
// the whole string ending with a trailing ";", ns could be NULL
// this fucntion does not deal with complicate case such as ns/name/value string contains
// special chars. let me know if you do need deal with it...
//
// xiaoyuw@09/26/2000
//
BOOL SxspGenerateManifestPathOnAssemblyIdentity(
    PCWSTR str,
    PWSTR pszOut,
    ULONG *pCchstr,
    PASSEMBLY_IDENTITY *ppAssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    CStringBuffer PathBuffer;

    if (ppAssemblyIdentity)
        *ppAssemblyIdentity = NULL;

    PARAMETER_CHECK(str != NULL);
    PARAMETER_CHECK(pCchstr != NULL);

    IFW32FALSE_EXIT(
    ::SxspCreateAssemblyIdentityFromTextualString(
        str,
        &pAssemblyIdentity));

    // AssemblyIdentity is created, now generate the path
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            NULL,
            0,
            pAssemblyIdentity,
            PathBuffer));

    IFW32FALSE_EXIT(PathBuffer.Win32CopyStringOut(pszOut, pCchstr));

    if (ppAssemblyIdentity != NULL)
    {
        *ppAssemblyIdentity = pAssemblyIdentity ;
        pAssemblyIdentity = NULL;
    }

    fSuccess = TRUE;

Exit:
    if (pAssemblyIdentity != NULL)
        SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return fSuccess ;
}

/* --------------------------------------------------------------------------------
POLICY_PATH_FLAG_POLICY_IDENTITY_TEXTUAL_FORMAT  : x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_d51541cb
POLICY_PATH_FLAG_FULL_QUALIFIED_POLICIES_DIR     : c:\winnt\winsxs\policies
POLICY_PATH_FLAG_FULL_QUALIFIED_POLICY_FILE_NAME : c:\winnt\winsxs\policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_d51541cb\1.1.0.0.policy, for .cat, you have to replace it manually
-------------------------------------------------------------------------------- */
BOOL SxspGeneratePolicyPathOnAssemblyIdentity(
    DWORD  dwFlag,
    PCWSTR str,
    PWSTR pszOut,
    ULONG *pCchstr,
    PASSEMBLY_IDENTITY *ppAssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PASSEMBLY_IDENTITY pAssemblyIdentity;
    DWORD dwPathType;
    DWORD dwGenerateFlag; 
    CStringBuffer PathBuffer;
    CStringBuffer bufAssemblyRootDirectory;    

    IFW32FALSE_EXIT(
    ::SxspCreateAssemblyIdentityFromTextualString(
        str,
        &pAssemblyIdentity));

    switch (dwFlag)
    {
    case POLICY_PATH_FLAG_POLICY_IDENTITY_TEXTUAL_FORMAT:        
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY;
        dwGenerateFlag = SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION;
        break;
    case POLICY_PATH_FLAG_FULL_QUALIFIED_POLICIES_DIR:     
        {
        IFW32FALSE_EXIT(SxspGetAssemblyRootDirectory(bufAssemblyRootDirectory));
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY;
        dwGenerateFlag = SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH;
        }
        break;
    case POLICY_PATH_FLAG_FULL_QUALIFIED_POLICY_FILE_NAME:  
        {
        IFW32FALSE_EXIT(SxspGetAssemblyRootDirectory(bufAssemblyRootDirectory));
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY;
        dwGenerateFlag = 0;        
        }
        break;
    default:
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        goto Exit;
    }


    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            dwGenerateFlag,
            dwPathType,
            bufAssemblyRootDirectory, 
            bufAssemblyRootDirectory.Cch(),
            pAssemblyIdentity,
            PathBuffer));

    IFW32FALSE_EXIT(PathBuffer.Win32CopyStringOut(pszOut, pCchstr));

    if (ppAssemblyIdentity != NULL)
    {
        *ppAssemblyIdentity = pAssemblyIdentity ;
        pAssemblyIdentity = NULL;
    }
    fSuccess = TRUE;

Exit:
    if (pAssemblyIdentity != NULL)
        SxsDestroyAssemblyIdentity(pAssemblyIdentity);
    return fSuccess ;
}

BOOL TestAssemblyIdentityHash()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG hash1=0, hash2=0;
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &pAssemblyIdentity, 0, NULL));

    Attribute.Flags         = 0;
    Attribute.NamespaceCch  = 18;
    Attribute.Namespace     = L"http://interesting";
    Attribute.NameCch       = 8;
    Attribute.Name          = L"whatever";
    Attribute.ValueCch      = 32;
    Attribute.Value         = L"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";

    IFW32FALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(0, pAssemblyIdentity, &Attribute));
    IFW32FALSE_EXIT(SxsHashAssemblyIdentity(0, pAssemblyIdentity, &hash1));
    ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    // create second assembly identity

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &pAssemblyIdentity, 0, NULL));

    Attribute.Flags         = 0;
    Attribute.NamespaceCch  = 18;
    Attribute.Namespace     = L"http://interesting";
    Attribute.NameCch       = 8;
    Attribute.Name          = L"whatever";
    Attribute.ValueCch      = 32;
    Attribute.Value         = L"/>BABCDGHGHKLMNMNOPSTUVUVYZYZ[\\_`";

    IFW32FALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(0, pAssemblyIdentity, &Attribute));
    IFW32FALSE_EXIT(SxsHashAssemblyIdentity(0, pAssemblyIdentity, &hash2));
    ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    fSuccess = TRUE;
Exit:
    if (pAssemblyIdentity)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return fSuccess;
}

BOOL
TestNewCatalogSignerThingy(
    PCWSTR pcwszCatalog
    )
{
    BOOL fSuccess = FALSE;
    ULONG ulKeyLength;
    CPublicKeyInformation CatalogInformation;
    CSmallStringBuffer sbSignerString;
    CStringBuffer sbCatalogName;
    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(sbCatalogName.Win32Assign(pcwszCatalog, ::wcslen(pcwszCatalog)));
    IFW32FALSE_EXIT(CatalogInformation.Initialize(sbCatalogName));
    IFW32FALSE_EXIT(CatalogInformation.GetStrongNameString(sbSignerString));
    IFW32FALSE_EXIT(CatalogInformation.GetPublicKeyBitLength(ulKeyLength));

    FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "Strong name of catalog signer: %ls\n"
        "Key: %ls (length %ld)\n",
        static_cast<PCWSTR>(sbSignerString),
        ulKeyLength);

    fSuccess = TRUE;
Exit:
    return fSuccess;
};



BOOL TestSystemDefaultActCtxGeneration()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameter = {0};
    WCHAR pszTextualAssemblyIdentity[] =
        L"Microsoft.Windows.SystemCompactAssembly,version=\"1.0.0.0\",type=\"win32\",processorArchitecture=\"x86\"\0";
    CStringBuffer AssemblyDirectory;

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(AssemblyDirectory));
    IFW32FALSE_EXIT(AssemblyDirectory.Win32AppendPathElement(
        MANIFEST_ROOT_DIRECTORY_NAME,
        NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME)-1));
    IFW32FALSE_EXIT(AssemblyDirectory.Win32EnsureTrailingPathSeparator());

    Parameter.ProcessorArchitecture = 0 ;
    Parameter.LangId = 0x0409;
    Parameter.Flags = SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY;
    Parameter.TextualAssemblyIdentity = pszTextualAssemblyIdentity;
    Parameter.AssemblyDirectory = AssemblyDirectory;

    IFW32FALSE_EXIT(SxsGenerateActivationContext(&Parameter));

    fSuccess = TRUE;
Exit:
    // check LastError
    if (Parameter.SectionObjectHandle != NULL)
        ::CloseHandle(Parameter.SectionObjectHandle);

    if (Parameter.Manifest.Stream)
        Parameter.Manifest.Stream->Release();


    return fSuccess;
}

BOOL
TestSfcUIPopup()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CAssemblyRecoveryInfo RecoverInfo;
    CSXSMediaPromptDialog PromptDialog;
    CStringBuffer sbAssemblyName;
    static WCHAR wchTestName[] = L"x86_Microsoft.Tools.VisualCPlusPlus.Runtime-Libraries_6595b64144ccf1df_6.0.0.0_x-ww_ff9986d7";
    bool fNoAssembly;

    IFW32FALSE_EXIT(RecoverInfo.Initialize());
    IFW32FALSE_EXIT(sbAssemblyName.Win32Assign(wchTestName, NUMBER_OF(wchTestName) - 1));
    IFW32FALSE_EXIT(RecoverInfo.AssociateWithAssembly(sbAssemblyName, fNoAssembly));

#if 0
    if (fNoAssembly)
    {
        IFW32FALSE_EXIT(PromptDialog.Initialize(RecoverInfo, CSXSMediaPromptDialog::Source_FileURL));
        IFW32FALSE_EXIT(PromptDialog.ShowSelf());
    }
#endif // 0

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
TestPolicyPathGeneration()
{
    WCHAR str[] = L"policy.1.0.ms-sxstest-folder1,processorArchitecture=\"x86\",type=\"win32-policy\",language=\"en\",version=\"2.2.2.2\",publicKeyToken=\"75e377300ab7b886\"";
    WCHAR pszOut[1024];
    ULONG Cchstr =0;
    for (DWORD dwFlag=0; dwFlag<3; dwFlag++)
    {
        SxspGeneratePolicyPathOnAssemblyIdentity(
            dwFlag,
            str,
            pszOut,
            &Cchstr,
            NULL);
    };
    return TRUE;
}


BOOL
SxspDebug(
    ULONG iOperation,
    DWORD dwFlags,
    PCWSTR pszParameter1,
    PVOID pvParameter2)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    switch (iOperation)
    {
    case SXS_DEBUG_SYSTEM_DEFAULT_ACTCTX_GENERATION:
        IFW32FALSE_EXIT(::TestSystemDefaultActCtxGeneration());
        break;
    case SXS_DEBUG_SFC_UI_TEST:
        IFW32FALSE_EXIT( TestSfcUIPopup() );
        break;
    case SXS_DEBUG_CATALOG_SIGNER_CHECK:
        IFW32FALSE_EXIT(::TestNewCatalogSignerThingy(pszParameter1));
        break;
    case SXS_DEBUG_ASSEMBLY_IDENTITY_HASH:
        IFW32FALSE_EXIT(::TestAssemblyIdentityHash());
        break;
    case SXS_DEBUG_ASSEMBLYNAME_CONVERSION:
        //IFCOMFAILED_EXIT(TestAssemblyName());
        //IFCOMFAILED_EXIT(::TestDeleteInstalledAssemblyBasedOnAssemblyName());
        IFW32FALSE_EXIT(::TestPolicyPathGeneration());
        break;
    case SXS_DEBUG_GET_STRONGNAME:
    {
        CPublicKeyInformation pkInfo;
        CFusionArray<BYTE> PublicKeyBytes;
        CStringBuffer *pStringBuffers = (CStringBuffer*) pvParameter2;
        PCCERT_CONTEXT pContext = (PCCERT_CONTEXT) pszParameter1;

        PARAMETER_CHECK(pszParameter1 != NULL);
        PARAMETER_CHECK(pvParameter2 != NULL);

        IFW32FALSE_EXIT(pkInfo.Initialize(pContext));
        IFW32FALSE_EXIT(pkInfo.GetSignerNiceName(pStringBuffers[0]));
        IFW32FALSE_EXIT(pkInfo.GetStrongNameString(pStringBuffers[1]));
        IFW32FALSE_EXIT(pkInfo.GetWrappedPublicKeyBytes(PublicKeyBytes));
        IFW32FALSE_EXIT(::SxspHashBytesToString(PublicKeyBytes.GetArrayPtr(), PublicKeyBytes.GetSize(), pStringBuffers[2]));
        break;
    }

    case SXS_DEBUG_FUSION_REPARSEPOINT:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFW32FALSE_EXIT(::TestReparsePointOnFullQualifiedPath(pszParameter1));
        break;

    case SXS_DEBUG_FOLDERNAME_FROM_ASSEMBLYIDENTITY_GENERATION:
        {

            WCHAR pstr[1024];
            ULONG cch = NUMBER_OF(pstr);
            PARAMETER_CHECK(pszParameter1 != NULL);
            IFW32FALSE_EXIT(SxspGenerateManifestPathOnAssemblyIdentity(pszParameter1, pstr, &cch, NULL));
        }
        break;
    case SXS_DEBUG_FUSION_ARRAY:
        PARAMETER_CHECK(pszParameter1 != NULL);
        PARAMETER_CHECK(pvParameter2 != NULL);
        IFW32FALSE_EXIT(TestFusionArray(pszParameter1, reinterpret_cast<PCWSTR>(pvParameter2)));
        break;
    case SXS_DEBUG_FORCE_LEAK:
    {
        //
        // Leaking memory intentionally - do not fix!
        // - if pvParameter2 is NULL, then leaks one byte
        // - Otherwise, assumes pvParameter2 is a PDWORD that is now many bytes
        //   should be leaked.
        //
        // Uses new[] to interact with the heap; might want to use the flags to
        //   indicate use of the Fusion heap or whatnot.
        //
        DWORD dwLeakCount = pvParameter2 ? *((PDWORD)pvParameter2) : 1;
        PCHAR pLeaked = NEW(CHAR[ dwLeakCount ]);

        if (pLeaked)
        {
            ::FusionpDbgPrintEx(
              FUSION_DBG_LEVEL_INFO,
              "SxsDebug::ForceLeak allocates %d bytes\n",
              dwLeakCount);
            fSuccess = TRUE;
        }
        else
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INFO,
                "SxsDebug::ForceLeak didn't allocate anything, new failed\n");
        }
        break;
    }

    case SXS_DEBUG_SFC_SCANNER:
        IFW32FALSE_EXIT(SxsProtectionPerformScanNow(NULL, TRUE, TRUE));
        break;

    case SXS_DEBUG_DLL_REDIRECTION:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFW32FALSE_EXIT(::DllRedirectionTest(pszParameter1));
        break;
    case SXS_DEBUG_DIRECTORY_WATCHER:
        IFCOMFAILED_EXIT(TryWatchingDirectories());
        break;
    case SXS_DEBUG_CREAT_MULTILEVEL_DIRECTORY:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFW32FALSE_EXIT(CreateMultiLevelDirectoryTest(pszParameter1));
        break;
    case SXS_DEBUG_PROBE_MANIFST:
        //IFW32FALSE_EXIT(ManifestProbeTest());
        //IFW32FALSE_EXIT(TestSxsGeneratePath());
        IFW32FALSE_EXIT(TestCopyDirectory());
        break;
    case SXS_DEBUG_XML_PARSER:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFCOMFAILED_EXIT(::XMLParserTest(pszParameter1));
        break;
    case SXS_DEBUG_CHECK_MANIFEST_SCHEMA:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFW32FALSE_EXIT(::SxspManifestSchemaCheck(pszParameter1));
        break;
#if SXS_PRECOMPILED_MANIFESTS_ENABLED
    case SXS_DEBUG_PRECOMPILED_MANIFEST:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFCOMFAILED_EXIT(::PrecompiledManifestTest(pszParameter1));
        break;
    case SXS_DEBUG_TIME_PCM:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFCOMFAILED_EXIT(::TestPCMTime(const_cast<LPWSTR>(pszParameter1)));
        break;
#endif // SXS_PRECOMPILED_MANIFESTS_ENABLED
    case SXS_DEBUG_SET_ASSEMBLY_STORE_ROOT:
        {
            PWSTR pszTemp = NULL;
            PCWSTR pszTemp2 = NULL;

            PARAMETER_CHECK(pszParameter1 != NULL);

            // Make a copy of the input string
            IFW32FALSE_EXIT(::FusionDupString(&pszTemp, pszParameter1, ::wcslen(pszParameter1)));

            pszTemp2 = ::SxspInterlockedExchange(&g_AlternateAssemblyStoreRoot, pszTemp);
            if (pszTemp2 != NULL)
                FUSION_DELETE_ARRAY(pszTemp2);

            break;
        }
    case SXS_DEBUG_EXIT_PROCESS:
        ExitProcess(123);
        break;
    case SXS_DEBUG_TERMINATE_PROCESS:
        TerminateProcess(GetCurrentProcess(), 456);
        break;
    } // end of switch

    fSuccess = TRUE;
Exit:
    return fSuccess;
}// end of SxspDebug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsidp.h ===
#if !defined(_FUSION_SXS_ASSEMBLY_IDENTITY_H_INCLUDED_)
#define _FUSION_SXS_ASSEMBLY_IDENTITY_H_INCLUDED_

#pragma once

#include "sxsid.h"

#endif // _FUSION_SXS_ASSEMBLY_IDENTITY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsinstall.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dllredir.cpp

Abstract:

    Activation context section contributor for the DLL Redirection section.

Author:

    Jay Krell (a-JayK) April 2000

Revision History:

--*/
#if (_MSC_VER > 1020)
#pragma once
#endif
#include "Util.h"
#include "cassemblyrecoveryinfo.h"
#include "actctxgenctx.h"

/*-----------------------------------------------------------------------------
Side By(x) Side Install

most of the work is actually done in dllredir.cpp
-----------------------------------------------------------------------------*/

class CAssemblyInstallReferenceInformation
{
    GUID            m_SchemeGuid;
    CStringBuffer   m_buffIdentifier;
    CStringBuffer   m_buffNonCanonicalData;
    CStringBuffer   m_buffGeneratedIdentifier;
    BOOL            m_fIdentityStuffReady;
    DWORD           m_dwFlags;    

    CAssemblyReference m_IdentityReference;


    PRIVATIZE_COPY_CONSTRUCTORS(CAssemblyInstallReferenceInformation);

public:

    SMARTTYPEDEF(CAssemblyInstallReferenceInformation);

    CAssemblyInstallReferenceInformation();

    BOOL Initialize( PCSXS_INSTALL_REFERENCEW RefData );

    const GUID &GetSchemeGuid() const { return m_SchemeGuid; }
    const CBaseStringBuffer &GetIdentifier() const { return m_buffIdentifier; }
    const CBaseStringBuffer &GetGeneratedIdentifier() const { return m_buffGeneratedIdentifier; }
    const CBaseStringBuffer &GetCanonicalData() const { return m_buffNonCanonicalData; }

    DWORD GetFlags() const { return m_dwFlags; }

    BOOL SetIdentity(PCASSEMBLY_IDENTITY pAsmIdent) { return m_IdentityReference.Initialize(pAsmIdent); }

    BOOL ForceReferenceData(PCWSTR pcwszPrecalcedData) {
        FN_PROLOG_WIN32
        IFW32FALSE_EXIT(
            m_buffGeneratedIdentifier.Win32Assign(
                pcwszPrecalcedData,
                pcwszPrecalcedData != NULL ? ::wcslen(pcwszPrecalcedData) : 0));
        m_fIdentityStuffReady = TRUE;
        FN_EPILOG
    }


    BOOL GenerateFileReference(
        IN const CBaseStringBuffer &buffKeyfileName,
        OUT CBaseStringBuffer &buffDrivePath,
        OUT CBaseStringBuffer &buffFilePart,
        OUT DWORD &dwDriveSerial
        );

    const CAssemblyReference &GetIdentity() const { return m_IdentityReference; }
    
    BOOL GenerateIdentifierValue(
        CBaseStringBuffer *pbuffTarget = NULL
        );

    BOOL GetIdentifierValue(CBaseStringBuffer &pBuffTarget) const
    {
        return pBuffTarget.Win32Assign(m_buffGeneratedIdentifier);
    }

    BOOL WriteIntoRegistry(const CFusionRegKey &rhkTargetKey) const;
    BOOL IsReferencePresentIn(const CFusionRegKey &rhkQueryKey, BOOL &rfPresent, BOOL *rfNonCanonicalMatches = NULL) const;
    BOOL DeleteReferenceFrom(const CFusionRegKey &rhkQueryKey, BOOL &rfWasDeleted) const;
    BOOL AcquireContents(const CAssemblyInstallReferenceInformation &);
};

MAKE_CFUSIONARRAY_READY(CAssemblyInstallReferenceInformation, AcquireContents);


#define CINSTALLITEM_VALID_REFERENCE        (0x0000001)
#define CINSTALLITEM_VALID_RECOVERY         (0x0000002)
#define CINSTALLITEM_VALID_IDENTITY         (0x0000004)
#define CINSTALLITEM_VALID_LOGFILE          (0x0000008)

class CInstalledItemEntry
{
    PRIVATIZE_COPY_CONSTRUCTORS(CInstalledItemEntry);
    
public:
    CAssemblyInstallReferenceInformation m_InstallReference;
    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> m_AssemblyIdentity;
    CAssemblyRecoveryInfo m_RecoveryInfo;
    CSmallStringBuffer m_buffLogFileName;
    CCodebaseInformation m_CodebaseInfo;
    DWORD m_dwValidItems;

    CInstalledItemEntry() : m_dwValidItems(0) { }

    ~CInstalledItemEntry() { }

    BOOL AcquireContents( const CInstalledItemEntry &other ); 
};

MAKE_CFUSIONARRAY_READY(CInstalledItemEntry, AcquireContents);

class CAssemblyInstall
{
public:
    CAssemblyInstall();
    ~CAssemblyInstall() { }

    BOOL
    BeginAssemblyInstall(
        DWORD flags,
        PSXS_INSTALLATION_FILE_COPY_CALLBACK installationCallback,
        PVOID  installationContext,
        const CImpersonationData &ImpersonationData
        );

    enum EInstallStage
    {
        eBegin,
        ePer,
        eEnd
    };

    BOOL
    InstallAssembly(
        DWORD   flags,
        PCWSTR  manifestPath,
        PCSXS_INSTALL_SOURCE_INFO pcsisi,
        PCSXS_INSTALL_REFERENCEW pReference
        );

    BOOL
    EndAssemblyInstall(
        DWORD   flags,
        PVOID   pvReserved = NULL
        );

    BOOL
    InstallFile(
        const CBaseStringBuffer &ManifestPath,
        const CBaseStringBuffer &rbuffRelativeCodebase
        );

    CDirWalk::ECallbackResult
    InstallDirectoryDirWalkCallback(
        CDirWalk::ECallbackReason  reason,
        CDirWalk *pdirWalk,
        DWORD dwFlags,
        DWORD dwWalkDirFlags
        );

    static CDirWalk::ECallbackResult
    StaticInstallDirectoryDirWalkCallback(
        CDirWalk::ECallbackReason  reason,
        CDirWalk *dirWalk,
        DWORD                      dwWalkDirFlags
        );

    BOOL
    InstallDirectory(
        const CBaseStringBuffer &rPath,
        DWORD flags,
        WCHAR wchCodebasePathSeparator
        );

    ACTCTXGENCTX        m_ActCtxGenCtx;
    CImpersonationData  m_ImpersonationData;
    BOOL                m_bSuccessfulSoFar;
    PSXS_INSTALL_SOURCE_INFO m_pInstallInfo;
    CFusionArray<CInstalledItemEntry> m_ItemsInstalled;

    // In parallel to the other paths we're building up, we also build a
    // relative path to the base of the directory walk which uses the
    // path separator(s) that were present in the codebase URL.
    WCHAR               m_wchCodebasePathSeparator;
    CMediumStringBuffer m_buffCodebaseRelativePath;

protected:
    BOOL WriteSingleInstallLog(
        const CInstalledItemEntry &item,
        BOOL bOverWrite = FALSE
        );

    SXS_INSTALL_SOURCE_INFO m_CurrentInstallInfoCopy;

private:
    CAssemblyInstall(const CAssemblyInstall &);
    void operator =(const CAssemblyInstall &);
};

#define SXS_REFERENCE_CHUNK_SEPERATOR       (L"_")
#define SXS_REFERENCE_CHUNK_SEPERATOR_CCH   (NUMBER_OF(SXS_REFERENCE_CHUNK_SEPERATOR)-1)
#define WINSXS_INSTALLATION_REFERENCES_SUBKEY ( L"References")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsntrtl.cpp ===
#include "stdinc.h"
#include "sxsp.h"
#include "windows.h"
#include "ntexapi.h"

#define HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

ULONG
SxspSetLastNTError(
    NTSTATUS Status
    );

BOOL
SxspGetAssemblyRootDirectoryHelper(
    SIZE_T CchBuffer,
    WCHAR Buffer[],
    SIZE_T *CchWritten
    )
{
    UNICODE_STRING Src, Dst;
    NTSTATUS Status;
    ULONG Length = 0;
    BOOL fSuccess = FALSE;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ENTEREXIT,
        "SXS.DLL: Entering SxspGetAssemblyRootDirectoryHelper()\n");

    if ((CchBuffer == 0) && (CchWritten == NULL))
    {
        ::SxspSetLastNTError(STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    if ((CchBuffer != 0) && (Buffer == NULL))
    {
        ::SxspSetLastNTError(STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    Dst.Length = 0;

    if (CchBuffer != 0)
        Dst.MaximumLength = static_cast<USHORT>((CchBuffer - 1) * sizeof(WCHAR));
    else
        Dst.MaximumLength = 0;

    Dst.Buffer = Buffer;

    Src.Buffer = (PWSTR) g_AlternateAssemblyStoreRoot;

    if (Src.Buffer != NULL)
    {
        Src.Length = (USHORT) (wcslen(Src.Buffer) * sizeof(WCHAR));
        Src.MaximumLength = Src.Length;
    }
    else
    {
        Src.Buffer = L"%SystemRoot%\\WinSxS\\";
        Src.Length = sizeof(L"%SystemRoot%\\WinSxS\\") - sizeof(WCHAR);
        Src.MaximumLength = Src.Length;
    }

    Status = ::FusionpRtlExpandEnvironmentStrings_U(NULL, &Src, &Dst, &Length);
    if (!NT_SUCCESS(Status))
    {
        if (Status != STATUS_BUFFER_TOO_SMALL)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Unable to expand environment strings; NTSTATUS = 0x%08lx\n", Status);

            SxspSetLastNTError(Status);
            goto Exit;
        }

        if (CchWritten != NULL)
            *CchWritten = (Length / sizeof(WCHAR));

        goto Exit;
    }
    else
    {
        Dst.Buffer[Dst.Length / sizeof(WCHAR)] = UNICODE_NULL;

        if (CchWritten != NULL)
            *CchWritten = Dst.Length / sizeof(WCHAR);
    }

    fSuccess = TRUE;

Exit:
    if (fSuccess)
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ENTEREXIT,
            "SXS.DLL: SxspGetAssemblyRootDirectoryHelper() successful; exiting function.\n");
    else
    {
        if (::FusionpGetLastWin32Error() != ERROR_INSUFFICIENT_BUFFER)
        {
            ::FusionpDbgPrintEx(
               FUSION_DBG_LEVEL_ERROREXITPATH,
               "SXS.DLL: SxspGetAssemblyRootDirectoryHelper() failed; ::FusionpGetLastWin32Error() = %d\n", ::FusionpGetLastWin32Error());
        }
    }

    return fSuccess;
}

ULONG
SxspSetLastNTError(
    NTSTATUS Status
    )
{
    ULONG dwErrorCode;
    dwErrorCode = ::FusionpRtlNtStatusToDosError(Status);
    ::FusionpSetLastWin32Error(dwErrorCode);
    return dwErrorCode;
}

BOOL
SxspHashString(
    PCWSTR String,
    SIZE_T cch,
    PULONG HashValue,
    bool CaseInsensitive
    )
{
    UNICODE_STRING s;
    NTSTATUS Status = STATUS_SUCCESS;

    s.MaximumLength = static_cast<USHORT>(cch * sizeof(WCHAR));
    s.Length = s.MaximumLength;
    s.Buffer = const_cast<PWSTR>(String);

    Status = ::FusionpRtlHashUnicodeString(&s, CaseInsensitive, HASH_ALGORITHM, HashValue);
    if (!NT_SUCCESS(Status))
        ::SxspSetLastNTError(Status);

    return (NT_SUCCESS(Status));
}

ULONG
SxspGetHashAlgorithm(VOID)
{
    return HASH_ALGORITHM;
}

BOOL
SxspCreateLocallyUniqueId(
    OUT PSXSP_LOCALLY_UNIQUE_ID psxsLuid
    )
{
    BOOL fSuccess = FALSE;
    NTSTATUS status;

    status = ::FusionpNtAllocateLocallyUniqueId(&psxsLuid->Luid);
    if (!NT_SUCCESS(status))
    {
        ::SxspSetLastNTError(status);
        goto Exit;
    }
    psxsLuid->Type = esxspLuid;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFormatLocallyUniqueId(
    IN const SXSP_LOCALLY_UNIQUE_ID &rsxsLuid,
    OUT CBaseStringBuffer &rbuffUidBuffer
    )
{
    FN_PROLOG_WIN32

    switch (rsxsLuid.Type)
    {
    case esxspGuid:
        IFW32FALSE_EXIT(::SxspFormatGUID(rsxsLuid.Guid, rbuffUidBuffer));
        break;

    case esxspLuid:
        {
            ULARGE_INTEGER uli;
            CStringBufferAccessor acc;

            uli.LowPart = rsxsLuid.Luid.LowPart;
            uli.HighPart = rsxsLuid.Luid.HighPart;

            IFW32FALSE_EXIT(rbuffUidBuffer.Win32ResizeBuffer(sizeof(ULONGLONG) * CHAR_BIT, eDoNotPreserveBufferContents));

            // better to have all digits, no minus sign probably, for consistent names
            acc.Attach(&rbuffUidBuffer);

            //
            // This would be a good place to use RtlInt64ToUnicodeString, at least
            // #if !SXSP_DOWNLEVEL..
            //
            _ui64tow(uli.QuadPart, acc.GetBufferPtr(), 10);
            acc.Detach();
            break;
        }
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsntrtl.inl ===
#pragma once

#define IS_PATH_SEPARATOR_U(ch) ((ch == L'\\') || (ch == L'/'))

#if FUSION_WIN2000xxxx

PSINGLE_LIST_ENTRY
FirstEntrySList (
    const SLIST_HEADER *ListHead
    );

VOID
InitializeSListHead (
    IN PSLIST_HEADER ListHead
    );

#define RtlInitializeSListHead InitializeSListHead
#define RtlFirstEntrySList FirstEntrySList
#define RtlInterlockedPopEntrySList InterlockedPopEntrySList
#define RtlInterlockedPushEntrySList InterlockedPushEntrySList
#define RtlInterlockedFlushSList InterlockedFlushSList
#define RtlQueryDepthSList QueryDepthSList
#endif

inline BOOL
SxspIsSListEmpty(
    IN const SLIST_HEADER* ListHead
    )
{
#if _NTSLIST_DIRECT_
    return FirstEntrySList(ListHead) == NULL;
#else
    return RtlFirstEntrySList(ListHead) == NULL;
#endif
}

inline VOID
SxspInitializeSListHead(
    IN PSLIST_HEADER ListHead
    )
{
    RtlInitializeSListHead(ListHead);
}

inline PSINGLE_LIST_ENTRY
SxspPopEntrySList(
    IN PSLIST_HEADER ListHead
    )
{
    return RtlInterlockedPopEntrySList(ListHead);
}

inline PSINGLE_LIST_ENTRY
SxspInterlockedPopEntrySList(
    IN PSLIST_HEADER ListHead
    )
{
    return RtlInterlockedPopEntrySList(ListHead);
}

inline PSINGLE_LIST_ENTRY
SxspInterlockedPushEntrySList(
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    )
{
    return RtlInterlockedPushEntrySList(ListHead, ListEntry);
}

inline RTL_PATH_TYPE
SxspDetermineDosPathNameType(
    PCWSTR DosFileName
    )
// RtlDetermineDosPathNameType_U is a bit wacky..
{
    if (   DosFileName[0] == '\\'
        && DosFileName[1] == '\\'
        && DosFileName[2] == '?'
        && DosFileName[3] == '\\'
        )
    {
        if (   (DosFileName[4] == 'u' || DosFileName[4] == 'U')
            && (DosFileName[5] == 'n' || DosFileName[5] == 'N')
            && (DosFileName[6] == 'c' || DosFileName[6] == 'C')
            &&  DosFileName[7] == '\\'
            )
        {
            return RtlPathTypeUncAbsolute;
        }
        if (DosFileName[4] != 0
            && DosFileName[5] == ':'
            && DosFileName[6] == '\\'
            )
        {
            return RtlPathTypeDriveAbsolute;
        }
    }
#if FUSION_WIN
    return RtlDetermineDosPathNameType_U(DosFileName);
#else
    return RtlPathTypeRelative;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsinstall.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SxsInstall.cpp

Abstract:

    Installation support

Author:

    Jay Krell (a-JayK) April 2000

Revision History:

--*/
#include "stdinc.h"
#include "sxsp.h"
#include "NodeFactory.h"
#include "FusionArray.h"
#include "SxsInstall.h"
#include "SxsPath.h"
#include "recover.h"
#include "CAssemblyRecoveryInfo.h"
#include "SxsExceptionHandling.h"
#include "npapi.h"
#include "util.h"
#include "idp.h"

#define SXS_LANG_DEFAULT     (MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT)) // "0x0409"

static
BOOL
WINAPI
SxspInstallCallbackSetupCopyQueue(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS
    );

static
BOOL
WINAPI
SxspInstallCallbackSetupCopyQueueEx(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS
    );

CAssemblyInstall::CAssemblyInstall()
:
m_pInstallInfo(NULL),
m_bSuccessfulSoFar(TRUE)
{
}

BOOL
CAssemblyInstall::BeginAssemblyInstall(
    DWORD dwManifestOperationFlags,
    PSXS_INSTALLATION_FILE_COPY_CALLBACK installationCallback,
    PVOID  installationContext,
    const CImpersonationData &ImpersonationData
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((installationCallback != NULL) || (installationContext == NULL));

    // check for the "built in" ones, translate from bogus PFN values (1, 2, etc.)
    // to real functions
    if (installationCallback == SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE)
    {
        PARAMETER_CHECK(installationContext != NULL);
        installationCallback = SxspInstallCallbackSetupCopyQueue;
        // we can't verify that this is a valid setup copy queue..
    }
    else if (installationCallback == SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE_EX)
    {
        PCSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS typedContext =
            reinterpret_cast<PCSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS>(installationContext);

        PARAMETER_CHECK(installationContext != NULL);
        PARAMETER_CHECK(typedContext->cbSize >= sizeof(SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS));
        installationCallback = SxspInstallCallbackSetupCopyQueueEx;
    }

    m_ImpersonationData = ImpersonationData;

    IFW32FALSE_EXIT(
        ::SxspInitActCtxGenCtx(
            &m_ActCtxGenCtx,              // context out
            MANIFEST_OPERATION_INSTALL,
            0,
            dwManifestOperationFlags,
            ImpersonationData,
            0,                          // processor architecture
            //0                         // langid
            SXS_LANG_DEFAULT,         // langid "0x0409"
            ACTIVATION_CONTEXT_PATH_TYPE_NONE,
            0,
            NULL));

    //
    // Oh where oh where did our call-back go? Oh where, oh where could it be?
    //
    m_ActCtxGenCtx.m_InstallationContext.Callback = installationCallback;
    m_ActCtxGenCtx.m_InstallationContext.Context = installationContext;

    fSuccess = TRUE;
Exit:
    m_bSuccessfulSoFar = m_bSuccessfulSoFar && fSuccess;

    return fSuccess;
}


class CInstallDirectoryDirWalkContext
{
public:
    CAssemblyInstall* m_pThis;
    DWORD             m_dwManifestOperationFlags;
};

CDirWalk::ECallbackResult
CAssemblyInstall::InstallDirectoryDirWalkCallback(
    CDirWalk::ECallbackReason  reason,
    CDirWalk*                  dirWalk,
    DWORD                      dwManifestOperationFlags,
    DWORD                      dwWalkDirFlags
    )
{
#if DBG
#define SET_LINE() Line = __LINE__
    ULONG Line = 0;
#else
#define SET_LINE() /* nothing */
#endif

    SET_LINE();

    CDirWalk::ECallbackResult result = CDirWalk::eKeepWalking;

    //
    // We short circuit more code by doing this up front rather
    // waiting for a directory notification; it'd be even quicker
    // if we could seed the value in CDirWalk, but we can't.
    //
    // actually, what we could do is turn off all file walking
    // by returning eStopWalkingFiles at every directory notification,
    // and and at each directory notification, try the exactly three
    // file names we accept
    //
    if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE) == 0)
    {
        result = CDirWalk::eStopWalkingDirectories;
    }

    if (reason == CDirWalk::eBeginDirectory)
    {
        // Prepend a / only if the current path is non-blank - otherwise, just prepend the
        // path element.
        if (m_buffCodebaseRelativePath.Cch() != 0)
        {
            if (!m_buffCodebaseRelativePath.Win32Append(m_wchCodebasePathSeparator))
            {
                TRACE_WIN32_FAILURE(m_buffCodebaseRelativePath.Win32Append);
                SET_LINE();
                goto Error;
            }
        }

        if (!m_buffCodebaseRelativePath.Win32Append(dirWalk->m_strLastObjectFound))
        {
            TRACE_WIN32_FAILURE(m_buffCodebaseRelativePath.Win32Append);
            SET_LINE();
            goto Error;
        }
    }
    else if (reason == CDirWalk::eFile)
    {
        //
        // the manifest must be in a file whose base name matches its
        // directory's base name, otherwise ignore it and keep going
        //
        // inefficient, but reusing code.

        // check whether this is a catalog file, if so, we would not install it
        {
            PWSTR p = wcsrchr(dirWalk->m_strLastObjectFound, L'.');
            if (p != NULL)
            {
                SIZE_T x = ::wcslen(p);
                if (::FusionpCompareStrings(p, x, (x == 4)? L".cat" : L".catalog", (x == 4)? 4 : 8, true) == 0)
                {
                    SET_LINE();
                    goto Exit;
                }
            }
        }

        {
            CFullPathSplitPointers splitParent;
            CFullPathSplitPointers splitChild;
            CStringBuffer          child;
            CStringBuffer          buffChildCodebase;

            //
            // OS installations get some special treatment.
            //
            if ( dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP )
            {
                CSmallStringBuffer     buffParentWorker;
                CSmallStringBuffer     buffChunklet;

                //
                // If this is an OS-installation, then we need the last two bits of
                // the parent path.  So if we were walking "C:\$win_nt$.~ls\i386\asms", we need
                // the "i386\asms" part out of that.  So we'll generate this differently.
                //
                if (!buffParentWorker.Win32Assign(dirWalk->m_strParent, dirWalk->m_cchOriginalPath)) 
                {
                    SET_LINE();
                    goto Error;
                }

                buffParentWorker.RemoveTrailingPathSeparators();

                //
                // For now, take at most the last two items off the thing.
                //
                for ( ULONG ulItems = 0; (ulItems < 2) && (buffParentWorker.Cch() > 0); ulItems++ )
                {
                    CSmallStringBuffer buffChunklet;

                    if (( ulItems != 0 ) && (!buffChildCodebase.Win32Prepend(m_wchCodebasePathSeparator)))
                    {
                        SET_LINE();
                        goto Error;
                    }
                        
                    if (!buffParentWorker.Win32GetLastPathElement(buffChunklet))
                    {
                        SET_LINE();
                        goto Error;
                    }
                    if (!buffChildCodebase.Win32Prepend(buffChunklet))
                    {
                        SET_LINE();
                        goto Error;
                    }
                    buffParentWorker.RemoveLastPathElement();
                }

                if (!buffChildCodebase.Win32Append(m_wchCodebasePathSeparator))
                {
                    SET_LINE();
                    goto Exit;
                }
                if (!buffChildCodebase.Win32Append(m_buffCodebaseRelativePath))
                {
                    SET_LINE();
                    goto Exit;
                }
            }
            else
            {
                if (!buffChildCodebase.Win32Assign(m_buffCodebaseRelativePath))
                {
                    SET_LINE();
                    goto Error;
                }
            }
            if (!buffChildCodebase.Win32Append(m_wchCodebasePathSeparator))
            {
                SET_LINE();
                goto Error;
            }
            if (!buffChildCodebase.Win32Append(dirWalk->m_strLastObjectFound))
            {
                SET_LINE();
                goto Error;
            }

            if (!child.Win32Assign(dirWalk->m_strParent))
            {
                SET_LINE();
                goto Error;
            }
            if (!child.Win32AppendPathElement(dirWalk->m_strLastObjectFound))
            {
                SET_LINE();
                goto Error;
            }
            if (!splitParent.Initialize(dirWalk->m_strParent))
            {
                SET_LINE();
                goto Error;
            }
            if (!splitChild.Initialize(child))
            {
                SET_LINE();
                goto Error;
            }
            if (!splitParent.IsBaseEqual(splitChild))
            {
                SET_LINE();
                goto Exit;
            }

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INSTALLATION,
                "SXS.DLL: Installing file \"%S\"\n", static_cast<PCWSTR>(child));

            if (!this->InstallFile(child, buffChildCodebase))
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_SETUPLOG,
                    "Failed to install assembly from manifest: \"%S\"; Win32 Error Code = %lu\n", static_cast<PCWSTR>(child), ::GetLastError());

                //
                // If it was .man or .manifest, then it must be a manifest else error.
                //
                // If it was .dll, well, arbitrary .dlls don't necessarily contain
                // manifests, but we already look for .man and .manifest and this
                // .dll's base name matches its directory's name, so this is also
                // an error.
                //
                result = CDirWalk::eError;

                SET_LINE();
                goto Exit;
            }
        }

        //
        // we have a manifest in this directory, don't look for any manifests
        // in this directory or any of its children
        //
        // if we want to enforce one manifest per directory, then we'd have
        // to keep walking, or actually do a two pass in order to not install
        // when we would error later
        //
        result = (CDirWalk::eStopWalkingFiles | CDirWalk::eStopWalkingDirectories);
        SET_LINE();
        goto Exit;
    }
    else if (reason == CDirWalk::eEndDirectory)
    {
        // Trim back to the previous codebase path separator...
        PCWSTR pszPathSeparator = wcsrchr(m_buffCodebaseRelativePath, m_wchCodebasePathSeparator);
        if (pszPathSeparator != NULL)
            m_buffCodebaseRelativePath.Left(pszPathSeparator - m_buffCodebaseRelativePath);
        else
        {   // It's just one path element.
            m_buffCodebaseRelativePath.Clear();
        }

        //
        // find at least one file under the dir, however, no manifest available, this is an error case
        //
        if (((dwWalkDirFlags & SXSP_DIR_WALK_FLAGS_FIND_AT_LEAST_ONE_FILEUNDER_CURRENTDIR) != 0) &&
            ((dwWalkDirFlags & SXSP_DIR_WALK_FLAGS_INSTALL_ASSEMBLY_UNDER_CURRECTDIR_SUCCEED) == 0))
        {
            ::FusionpLogError(
                MSG_SXS_MANIFEST_MISSING_DURING_SETUP,
                 CEventLogString(dirWalk->m_strParent));  // this would log error to Setup.log if it is during setup
            SET_LINE();
            result |= CDirWalk::eError;
        }
    }
#if DBG
    if (Line == 0)
        SET_LINE();
#endif
Exit:
#if DBG
    if ((result & CDirWalk::eError) != 0)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "%s(%lu): %s\n", __FILE__, Line, __FUNCTION__);
    }
#endif
    return result;
Error:
    result = CDirWalk::eError;
    goto Exit;
#undef SET_LINE
}

CDirWalk::ECallbackResult
CAssemblyInstall::StaticInstallDirectoryDirWalkCallback(
    CDirWalk::ECallbackReason   reason,
    CDirWalk*                   dirWalk,
    DWORD                       dwWalkDirFlags
    )
{
    FN_TRACE();

    ASSERT(dirWalk != NULL);
    CInstallDirectoryDirWalkContext* context = reinterpret_cast<CInstallDirectoryDirWalkContext*>(dirWalk->m_context);
    CDirWalk::ECallbackResult result = context->m_pThis->InstallDirectoryDirWalkCallback(reason, dirWalk, context->m_dwManifestOperationFlags, dwWalkDirFlags);
    return result;
}

BOOL
CAssemblyInstall::InstallDirectory(
    const CBaseStringBuffer &rbuffPath,
    DWORD          dwFlags,
    WCHAR wchCodebasePathSeparator
    )
{
    FN_PROLOG_WIN32

#define COMMA ,
    const static PCWSTR filters[] = {L"*" INSTALL_MANIFEST_FILE_NAME_SUFFIXES(COMMA L"*") };
#undef COMMA

    CDirWalk dirWalk;
    CInstallDirectoryDirWalkContext context = { this, dwFlags };

    m_wchCodebasePathSeparator = wchCodebasePathSeparator;
    m_buffCodebaseRelativePath.Clear();

    dirWalk.m_fileFiltersBegin = filters;
    dirWalk.m_fileFiltersEnd   = filters + NUMBER_OF(filters);
    dirWalk.m_context = &context;
    dirWalk.m_callback = StaticInstallDirectoryDirWalkCallback;
    IFW32FALSE_EXIT(dirWalk.m_strParent.Win32Assign(rbuffPath));
    dirWalk.m_strParent.RemoveTrailingPathSeparators();
    IFW32FALSE_EXIT(dirWalk.Walk());

    FN_EPILOG
}



inline BOOL
SxspGenerateInstallationInfo(
    IN OUT CAssemblyRecoveryInfo &rRecovery,
    IN const CBaseStringBuffer &rbuffManifestSourcePath,
    IN const CBaseStringBuffer &rbuffRelativeCodebasePath,
    IN PCSXS_INSTALL_SOURCE_INFO pInstallInfo,
    IN PCWSTR pcwszAssemblyRoot,
    IN SIZE_T cchAssemblyRoot,
    IN const ASSEMBLY *pAssemblyInfo,
    OUT CCodebaseInformation &rCodebaseInfo
    )
{
    FN_PROLOG_WIN32

    BOOL fHasCatalog = FALSE;
    CStringBuffer buffAssemblyDirName;
    CMediumStringBuffer buffFinalCodebase;
    CMediumStringBuffer buffFilePath;
    BOOL fIsPolicy;
    BOOL fInstalledbySetup = FALSE;
    SxsWFPResolveCodebase CodebaseType = CODEBASE_RESOLVED_URLHEAD_UNKNOWN;

    PARAMETER_CHECK(pInstallInfo != NULL);

    // We either need a codebase or this had better be a darwin install
    PARAMETER_CHECK(
        ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_HAS_CODEBASE) != 0) ||
        ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_INSTALL_BY_DARWIN) != 0));

    PARAMETER_CHECK(pAssemblyInfo != NULL);

    IFW32FALSE_EXIT(rCodebaseInfo.Initialize());

    //
    // None of the installation context information actually contains the
    // unparsed name of the assembly.  As such, we re-generate the installation
    // path and then use it later.
    //
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(pAssemblyInfo->GetAssemblyIdentity(), fIsPolicy));

    // x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95 (w/o version) or
    // x86_dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_d51541cb    (w version)
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | (fIsPolicy ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0),
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            pcwszAssemblyRoot,
            cchAssemblyRoot,
            pAssemblyInfo->GetAssemblyIdentity(),
            buffAssemblyDirName));

    //
    // Blindly add this registration information to the registry.  We really should
    // try to validate that it's a valid manifest/catalog pair (with strong name
    // and everything) before doing this, but it's happened several times before
    // (in theory) if we're being called during setup. Since setup/install are our
    // only clients as of yet, we can be reasonably sure that there won't be a
    // "rogue" call through here to install bogus assembly information.
    //
    fHasCatalog = ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_HAS_CATALOG) != 0);

    if ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_HAS_CODEBASE) != 0)
    {
        IFW32FALSE_EXIT(buffFinalCodebase.Win32Assign(pInstallInfo->pcwszCodebaseName, ::wcslen(pInstallInfo->pcwszCodebaseName)));
        IFW32FALSE_EXIT(buffFinalCodebase.Win32Append(rbuffRelativeCodebasePath));
    }

    if (buffFinalCodebase.Cch() == 0)
    {
        // eg: darwin, for which we don't write codebases to the registry
        CodebaseType = CODEBASE_RESOLVED_URLHEAD_UNKNOWN;
    }
    else
    {
        IFW32FALSE_EXIT(::SxspDetermineCodebaseType(buffFinalCodebase, CodebaseType, &buffFilePath));
    }

    // If this is a file-ish codebase, let's abstract it (e.g. replace cdrom drive info with cdrom: URL,
    // turn mapped drive letters into UNC paths.

    if (CodebaseType == CODEBASE_RESOLVED_URLHEAD_FILE)
    {
        //
        // Now, let's intuit the type of stuff we're supposed to be putting in the
        // registry based on the input path.
        //
        UINT uiDriveType;

        CSmallStringBuffer buffDriveRoot;
        CSmallStringBuffer buffFullManifestSourcePath;

        // Convert the source path to a full path (in case it isn't) so that we can use the length of
        // the found volume root as an index into the full manifest source path.
        IFW32FALSE_EXIT(::SxspGetFullPathName(rbuffManifestSourcePath, buffFullManifestSourcePath, NULL));
        IFW32FALSE_EXIT(::SxspGetVolumePathName(0, buffFullManifestSourcePath, buffDriveRoot));
        uiDriveType = ::GetDriveTypeW(buffDriveRoot);

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s - Decided that drive for path \"%ls\" was \"%ls\" and type is %u\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffManifestSourcePath),
            static_cast<PCWSTR>(buffDriveRoot),
            uiDriveType);

        if (uiDriveType == DRIVE_CDROM)
        {
            // Neat, there's a good amount of work we have to do to get this up and
            // working...  In the interest of not blowing stack with really long buffers
            // here (or CStringBuffer objects), this is a heap-allocated string buffer.
            // Before you complain about heap usage, this path is /rarely/ ever hit.
            CSxsArrayPointer<WCHAR> pcwszVolumeName;
            const static DWORD dwPathChars = MAX_PATH * 2;
            PCWSTR pszPostVolumeRootPath = NULL;

            // Find the name of the media
            IFALLOCFAILED_EXIT(pcwszVolumeName = FUSION_NEW_ARRAY(WCHAR, dwPathChars));

            IFW32FALSE_ORIGINATE_AND_EXIT(
                ::GetVolumeInformationW(
                    buffDriveRoot,
                    pcwszVolumeName,
                    dwPathChars,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    0));

            pszPostVolumeRootPath = static_cast<PCWSTR>(buffFullManifestSourcePath) + buffDriveRoot.Cch();

            // construct the cdrom: URL...
            IFW32FALSE_EXIT(
                buffFinalCodebase.Win32AssignW(
                    6,
                    URLHEAD_CDROM,                  URLHEAD_LENGTH_CDROM,                   //  cdrom:
                    URLHEAD_CDROM_TYPE_VOLUMENAME,  URLHEAD_LENGTH_CDROM_TYPE_VOLUMENAME,   //  volumename
                    L"/",                           1,                                      //  /
                    pcwszVolumeName,                static_cast<int>((pcwszVolumeName != NULL) ? ::wcslen(pcwszVolumeName) : 0),      // <volume-name>
                    L"/",                           1,                                      //  /
                    pszPostVolumeRootPath,          wcslen(pszPostVolumeRootPath)));        //  <rest-of-path>

            // e.g. cdrom:name/AOE/aoesetup.exe

        }
        else if (uiDriveType == DRIVE_UNKNOWN)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetDriveTypeW, ERROR_BAD_PATHNAME);
        }
        else if (uiDriveType == DRIVE_REMOTE)
        {
            //
            // If this is a UNC path, then use it.
            //
            if (SxspDetermineDosPathNameType(rbuffManifestSourcePath) == RtlPathTypeUncAbsolute)
            {
                IFW32FALSE_EXIT(buffFinalCodebase.Win32Assign(rbuffManifestSourcePath));
            }
            else
            {
                // This is a remote drive - figure out what the path was to get connected,
                // the put that into the buffFinalCodebase thing
                IFW32FALSE_EXIT(
                    ::SxspGetRemoteUniversalName(
                        rbuffManifestSourcePath,
                        buffFinalCodebase));
            }
        }
    }

    //
    // Now let's fill out the recovery information object
    //
    IFW32FALSE_EXIT(rRecovery.SetAssemblyIdentity(pAssemblyInfo->GetAssemblyIdentity()));

    if ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_HAS_PROMPT) != 0)
    {
        if (pInstallInfo->pcwszPromptOnRefresh != NULL)
            IFW32FALSE_EXIT(rCodebaseInfo.SetPromptText(
                pInstallInfo->pcwszPromptOnRefresh, 
                ::wcslen(pInstallInfo->pcwszPromptOnRefresh)));
    }
    IFW32FALSE_EXIT(rCodebaseInfo.SetCodebase(buffFinalCodebase));

    FN_EPILOG
}

BOOL
CAssemblyInstall::InstallFile(
    const CBaseStringBuffer &rManifestPath,
    const CBaseStringBuffer &rRelativeCodebasePath
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CProbedAssemblyInformation AssemblyInfo;
    PASSEMBLY Asm = NULL;
    CInstalledItemEntry CurrentInstallEntry;

    IFW32FALSE_EXIT(AssemblyInfo.Initialize());

    IFALLOCFAILED_EXIT(Asm = new ASSEMBLY);

    IFW32FALSE_EXIT(CurrentInstallEntry.m_RecoveryInfo.Initialize());
    IFW32FALSE_EXIT(CurrentInstallEntry.m_RecoveryInfo.GetCodeBaseList().Win32SetSize(1)); // ??
    m_ActCtxGenCtx.m_InstallationContext.SecurityMetaData = &CurrentInstallEntry.m_RecoveryInfo.GetSecurityInformation();

    //
    // The main code deals with the paths that the assembly is
    // being installed from, not where it is being installed to.
    //
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, rManifestPath));
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestLastWriteTime(&m_ActCtxGenCtx));
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestFlags(ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT));
    IFW32FALSE_EXIT(::SxspInitAssembly(Asm, AssemblyInfo));
    IFW32FALSE_EXIT(::SxspIncorporateAssembly(&m_ActCtxGenCtx, Asm));

    //
    // Track the installation data for this assembly
    //
    IFW32FALSE_EXIT(
        ::SxspGenerateInstallationInfo(
            CurrentInstallEntry.m_RecoveryInfo,
            rManifestPath,
            rRelativeCodebasePath,
            m_pInstallInfo,
            m_ActCtxGenCtx.m_AssemblyRootDirectoryBuffer,
            m_ActCtxGenCtx.m_AssemblyRootDirectoryBuffer.Cch(),
            Asm,
            CurrentInstallEntry.m_CodebaseInfo));

    CurrentInstallEntry.m_dwValidItems |= CINSTALLITEM_VALID_RECOVERY;

    //
    // Track the installation reference for this assembly
    //
    if ( m_ActCtxGenCtx.m_ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID )
    {
        IFW32FALSE_EXIT(CurrentInstallEntry.m_InstallReference.Initialize(
            static_cast<PCSXS_INSTALL_REFERENCEW>(m_ActCtxGenCtx.m_InstallationContext.InstallReferenceData)));
        IFW32FALSE_EXIT(CurrentInstallEntry.m_InstallReference.SetIdentity(Asm->GetAssemblyIdentity()));
        CurrentInstallEntry.m_CodebaseInfo.SetReference(CurrentInstallEntry.m_InstallReference.GetGeneratedIdentifier());
        CurrentInstallEntry.m_dwValidItems |= CINSTALLITEM_VALID_REFERENCE;
    }

    //
    // Track the identity that was incorporated
    //
    INTERNAL_ERROR_CHECK(CurrentInstallEntry.m_AssemblyIdentity == NULL);
    IFW32FALSE_EXIT(SxsDuplicateAssemblyIdentity(
        0, 
        Asm->GetAssemblyIdentity(), 
        &CurrentInstallEntry.m_AssemblyIdentity));
    CurrentInstallEntry.m_dwValidItems |= CINSTALLITEM_VALID_IDENTITY;

    //
    // And, if we're logfiling..
    //
    if (m_ActCtxGenCtx.m_ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE)
    {
        IFW32FALSE_EXIT(CurrentInstallEntry.m_buffLogFileName.Win32Assign(
            m_pInstallInfo->pcwszLogFileName,
            m_pInstallInfo->pcwszLogFileName != NULL ? ::wcslen(m_pInstallInfo->pcwszLogFileName) : 0));
        CurrentInstallEntry.m_dwValidItems |= CINSTALLITEM_VALID_LOGFILE;
    }

    IFW32FALSE_EXIT(m_ItemsInstalled.Win32Append(CurrentInstallEntry));

    fSuccess = TRUE;
Exit:
    // We delete the ASSEMBLY here regardless of success vs. failure; the incorporate call above
    // does not actually add the PASSEMBLY to the list of assemblies associated with the activation
    // context.  [mgrier 8/9/2000]
    if (Asm != NULL)
    {
        CSxsPreserveLastError ple;
        Asm->Release();
        ple.Restore();
    }
    
    return fSuccess;
}

BOOL
CAssemblyInstall::InstallAssembly(
    DWORD dwManifestOperationFlags,
    PCWSTR ManifestPath,
    PCSXS_INSTALL_SOURCE_INFO pInstallSourceInfo,
    PCSXS_INSTALL_REFERENCEW pvReference
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD dwManifestOperationFlags_Saved = m_ActCtxGenCtx.m_ManifestOperationFlags;
    CStringBuffer strPath;
    RTL_PATH_TYPE ManifestPathType;
    BOOL fAreWeInSetupMode = FALSE;
    WCHAR wchCodebasePathSeparator = L'/';

    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fAreWeInSetupMode));

    FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS.DLL: %s()\n"
        "   dwManifestOperationFlags = 0x%08lx\n"
        "   ManifestPath = \"%S\"\n"
        "   pInstallSourceInfo = %p\n",
        __FUNCTION__,
        dwManifestOperationFlags,
        ManifestPath,
        pInstallSourceInfo);

    PARAMETER_CHECK(ManifestPath != NULL);
    PARAMETER_CHECK(ManifestPath[0] != L'\0');
    PARAMETER_CHECK(
        (pInstallSourceInfo == NULL) ||
        ((dwManifestOperationFlags & 
            (MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE | 
                MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_DARWIN |
                MANIFEST_OPERATION_INSTALL_FLAG_REFRESH |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
                MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID)) != 0));

    PARAMETER_CHECK((dwManifestOperationFlags & 
        (MANIFEST_OPERATION_INSTALL_FLAG_ABORT | 
        MANIFEST_OPERATION_INSTALL_FLAG_COMMIT)) == 0);

    PARAMETER_CHECK(
        ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE) == 0) ||
        (pInstallSourceInfo != NULL));   

    ManifestPathType = ::SxspDetermineDosPathNameType(ManifestPath);
    PARAMETER_CHECK(
        (ManifestPathType == RtlPathTypeUncAbsolute) ||
        (ManifestPathType == RtlPathTypeLocalDevice) ||
        (ManifestPathType == RtlPathTypeDriveAbsolute) ||
        (ManifestPathType == RtlPathTypeDriveRelative) ||
        (ManifestPathType == RtlPathTypeRelative));

    m_ActCtxGenCtx.m_ManifestOperationFlags |= dwManifestOperationFlags;

    //
    // Expand the input path to a full path that we can use later.
    //
    IFW32FALSE_EXIT(::SxspExpandRelativePathToFull(ManifestPath, ::wcslen(ManifestPath), strPath));

    if (m_ActCtxGenCtx.m_ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT)
        FN_SUCCESSFUL_EXIT();

    DWORD dwFileAttributes;
    IFW32FALSE_EXIT(::SxspGetFileAttributesW(strPath, dwFileAttributes));

    // They can only ask for directory based installation iff the path they pass
    // in is a directory
    PARAMETER_CHECK(
        ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
        ==
        ((dwManifestOperationFlags &
            (MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY |
             MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE)) != 0));


    //
    // If we're expecting to create a logfile, or we want to specify where this
    // assembly can be reloaded from, you'll need to tell us that in the operation
    // flags.
    //
    if (dwManifestOperationFlags & (MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_DARWIN | MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE | MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE))
    {
        //
        // Constness protection: Copy the data to our own structure, then pass along
        // the pointer to ourselves rather than the caller's
        //
        m_CurrentInstallInfoCopy = *pInstallSourceInfo;
        m_pInstallInfo = &m_CurrentInstallInfoCopy;

        m_ActCtxGenCtx.m_InstallationContext.InstallSource = m_pInstallInfo;

        //
        // So is wanting to create a logfile and not actively telling us where to
        // put it.
        //
        if (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE)
        {
            PARAMETER_CHECK(m_pInstallInfo->pcwszLogFileName);
        }

#if DBG
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - m_pInstallInfo->dwFlags : 0x%lx\n",
            __FUNCTION__, m_pInstallInfo->dwFlags);
#endif
    }

    if (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID)
    {
        PARAMETER_CHECK(pvReference->dwFlags == 0);
        PARAMETER_CHECK(pvReference->cbSize >= sizeof(SXS_INSTALL_REFERENCEW));
    
        PARAMETER_CHECK(
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) ||
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING) ||
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY) ||
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_KEYFILE) ||
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY));

        //
        // OS-setup scheme is only valid if we're really doing setup.
        //
        PARAMETER_CHECK((pvReference->guidScheme != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL)
            || fAreWeInSetupMode);

        if ( (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) ||
              (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY))
        {
            PARAMETER_CHECK(pvReference->lpIdentifier == NULL);
        }
        else
        {
            PARAMETER_CHECK((pvReference->lpIdentifier != NULL) && (pvReference->lpIdentifier[0] != UNICODE_NULL));
        }
            
        m_ActCtxGenCtx.m_InstallationContext.InstallReferenceData = pvReference;
    }
    else
        m_ActCtxGenCtx.m_InstallationContext.InstallReferenceData = NULL;

    if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
    {
        IFW32FALSE_EXIT(strPath.Win32EnsureTrailingPathSeparator());
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: Installing directory \"%S\" (installation flags: 0x%08lx)\n",
            static_cast<PCWSTR>(strPath),
            m_ActCtxGenCtx.m_ManifestOperationFlags);
        IFW32FALSE_EXIT(this->InstallDirectory(strPath, m_ActCtxGenCtx.m_ManifestOperationFlags, wchCodebasePathSeparator));
    }
    else
    {
        CTinyStringBuffer buffRelativeCodebase;

        FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: Installing file \"%S\"\n",
            static_cast<PCWSTR>(strPath));
        IFW32FALSE_EXIT(this->InstallFile(strPath, buffRelativeCodebase));
    }

    fSuccess = TRUE;
Exit:
    m_ActCtxGenCtx.m_ManifestOperationFlags = dwManifestOperationFlags_Saved;
    m_bSuccessfulSoFar = m_bSuccessfulSoFar && fSuccess;
    return fSuccess;
}

BOOL
CAssemblyInstall::WriteSingleInstallLog(
    const CInstalledItemEntry &rLogItemEntry,
    BOOL fOverWrite
    )
{
    FN_PROLOG_WIN32
    
    static const WCHAR header[] = { 0xFEFF };
    static const WCHAR eoln[] = L"\r\n";
    CFileStream LogFileStream;
    CStringBuffer buffWritingText;

    //
    // Only call if you've got a log file name, an identity, and a reference.
    //
    PARAMETER_CHECK((rLogItemEntry.m_dwValidItems & 
        (CINSTALLITEM_VALID_LOGFILE | CINSTALLITEM_VALID_IDENTITY | CINSTALLITEM_VALID_REFERENCE)) != 0);

    IFW32FALSE_EXIT(
        LogFileStream.OpenForWrite(
            rLogItemEntry.m_buffLogFileName,
            FILE_SHARE_READ,
            fOverWrite ? CREATE_ALWAYS : OPEN_ALWAYS,
            FILE_FLAG_SEQUENTIAL_SCAN));

    //
    // Not overwriting? Zing to the end instead.
    //
    if ( ! fOverWrite)
    {
        LARGE_INTEGER li;
        li.QuadPart = 0;
        IFCOMFAILED_EXIT(LogFileStream.Seek(li, STREAM_SEEK_END, NULL));
    }

    //
    // Convert the installed identity to something that we can save to disk.
    //
    {
        CStringBufferAccessor sba;
        SIZE_T cbRequestedBytes, cbActualBytes;
        
        IFW32FALSE_EXIT(
            ::SxsComputeAssemblyIdentityEncodedSize(
                0,
                rLogItemEntry.m_AssemblyIdentity,
                NULL,
                SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                &cbRequestedBytes));
        INTERNAL_ERROR_CHECK((cbRequestedBytes % sizeof(WCHAR)) == 0);
        IFW32FALSE_EXIT(buffWritingText.Win32ResizeBuffer(cbRequestedBytes, eDoNotPreserveBufferContents));
        sba.Attach(&buffWritingText);
        IFW32FALSE_EXIT(
            ::SxsEncodeAssemblyIdentity(
                0,
                rLogItemEntry.m_AssemblyIdentity,
                NULL,
                SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL, 
                sba.GetBufferCb(), 
                sba.GetBufferPtr(), 
                &cbActualBytes));
        INTERNAL_ERROR_CHECK(cbActualBytes == cbRequestedBytes);
        (sba.GetBufferPtr())[cbActualBytes / sizeof(WCHAR)] = UNICODE_NULL;
    }

    //
    // Write the assembly identity
    //
    IFW32FALSE_EXIT(buffWritingText.Win32Append(eoln, NUMBER_OF(eoln)-1));
    IFCOMFAILED_EXIT(
        LogFileStream.Write(
            static_cast<PCWSTR>(buffWritingText),
            (ULONG)(buffWritingText.Cch() * sizeof(WCHAR)),
            NULL));

    //
    // And the reference
    //
    IFW32FALSE_EXIT(rLogItemEntry.m_InstallReference.GetIdentifierValue(buffWritingText));
    IFW32FALSE_EXIT(buffWritingText.Win32Append(eoln, NUMBER_OF(eoln)-1));
    IFCOMFAILED_EXIT(LogFileStream.Write(
            static_cast<PCWSTR>(buffWritingText),
            (ULONG)(buffWritingText.Cch() * sizeof(WCHAR)),
            NULL));

    //
    // If we're overwriting, then clip off whatever was left at the
    // end of the stream (if anything.)
    //
    if (fOverWrite)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER liPos;

        li.QuadPart = 0;
        IFCOMFAILED_EXIT(LogFileStream.Seek(li, STREAM_SEEK_CUR, &liPos));
        IFCOMFAILED_EXIT(LogFileStream.SetSize(liPos));
    }

    IFW32FALSE_EXIT(LogFileStream.Close());

    FN_EPILOG
}

BOOL
SxspEnsureInstallReferencePresent(
    DWORD dwFlags,
    IN const CAssemblyInstallReferenceInformation &rcInstRef,
    OUT BOOL &rfWasAdded
    )
/*++

Purpose:

    Ensure that the installation reference given in pAsmIdent and pAsmInstallReference
    is really present in the registry.  If the reference is not present, then it is
    added.  If it's present already, it sets *pfWasPresent and returns.

Parameters:

    dwFlags - Future use, must be zero

    pAsmIdent - Assembly identity to add this reference to

    pAsmInstallReference - Assembly installation reference data, from the calling
        installer application.

--*/
{
    FN_PROLOG_WIN32

    CFusionRegKey       hkAsmInstallInfo;
    CFusionRegKey       hkAsmRefcount;
    CFusionRegKey       hkAllInstallInfo;
    DWORD               dwCreated;
    CStringBuffer       buffAssemblyDirNameInRegistry;
    CSmallStringBuffer  buffRefcountValueName;
    PCASSEMBLY_IDENTITY pAsmIdent;

    rfWasAdded = FALSE;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK((pAsmIdent = rcInstRef.GetIdentity().GetAssemblyIdentity()) != NULL);


    //
    // Open installation data key
    //
    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0, KEY_READ, hkAllInstallInfo));

    //
    // Open the specific assembly name key
    //
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(pAsmIdent, buffAssemblyDirNameInRegistry));
    IFW32FALSE_EXIT(hkAllInstallInfo.OpenOrCreateSubKey(
        hkAsmInstallInfo,
        buffAssemblyDirNameInRegistry,
        KEY_ALL_ACCESS,
        0,
        NULL,
        NULL));

    INTERNAL_ERROR_CHECK(hkAsmInstallInfo != CFusionRegKey::GetInvalidValue());

    //
    // Open the subey for refcounting
    //
    IFW32FALSE_EXIT(hkAsmInstallInfo.OpenOrCreateSubKey(
        hkAsmRefcount,
        WINSXS_INSTALLATION_REFERENCES_SUBKEY,
        KEY_SET_VALUE,
        0,
        &dwCreated,
        NULL));

    INTERNAL_ERROR_CHECK(hkAsmRefcount != CFusionRegKey::GetInvalidValue());

    //
    // Generate the installation data that will be populated here.
    //
    IFW32FALSE_EXIT(rcInstRef.WriteIntoRegistry(hkAsmRefcount));
    rfWasAdded = TRUE;
    
    FN_EPILOG
}




BOOL
CAssemblyInstall::EndAssemblyInstall(
    DWORD dwManifestOperationFlags,
    PVOID
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(
        (dwManifestOperationFlags & ~(
              MANIFEST_OPERATION_INSTALL_FLAG_ABORT
            | MANIFEST_OPERATION_INSTALL_FLAG_COMMIT
            | MANIFEST_OPERATION_INSTALL_FLAG_REFRESH
            )) == 0);

    // one of these but not both must be set
    PARAMETER_CHECK((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT)
        ^ (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_COMMIT));

    //
    // PARAMETER_CHECK above ensures that this only has known bits set.
    // If PARAMETER_CHECK above is expanded to allow more flags, maintain
    // this line appropriately.
    //
    m_ActCtxGenCtx.m_ManifestOperationFlags |= dwManifestOperationFlags;

    //
    // Clear out some metadata in the registry.
    //
    if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT) == 0)
    {
        for (ULONG ul = 0; ul < m_ItemsInstalled.GetSize(); ul++)
        {
            if (m_ItemsInstalled[ul].m_dwValidItems & CINSTALLITEM_VALID_RECOVERY)
            {
                IFW32FALSE_EXIT(m_ItemsInstalled[ul].m_RecoveryInfo.ClearExistingRegistryData());
            }
        }
    }

    IFW32FALSE_EXIT(::SxspFireActCtxGenEnding(&m_ActCtxGenCtx));

    //
    // write register before copy files into winsxs : see bug 316380
    //
    if ( ( dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT ) == 0 )
    {
        BOOL fWasAdded;
        
        //
        // Post installation tidyup
        //
        for (ULONG ul = 0; ul < m_ItemsInstalled.GetSize(); ul++)
        {
            CInstalledItemEntry &Item = m_ItemsInstalled[ul];

            if (Item.m_dwValidItems & CINSTALLITEM_VALID_RECOVERY)
            {
                //
                // Add the codebase for this reference.  If one exists for the ref,
                // update its URL, prompt, etc.
                //
                CCodebaseInformation* pCodebaseInfo = NULL;
                CCodebaseInformationList &rCodebaseList = Item.m_RecoveryInfo.GetCodeBaseList();
                ULONG Flags = 0;
                
                IFW32FALSE_EXIT(rCodebaseList.FindCodebase(
                    Item.m_InstallReference.GetGeneratedIdentifier(),
                    pCodebaseInfo));

                if ( pCodebaseInfo != NULL )
                {
                    IFW32FALSE_EXIT(pCodebaseInfo->Initialize(Item.m_CodebaseInfo));
                }
                else
                {
                    IFW32FALSE_EXIT(rCodebaseList.Win32Append(Item.m_CodebaseInfo));
                }
                
                if (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFRESH)
                {
                    Flags |= SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH;
#if DBG
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
                        "SXS.DLL: %s - propping recovery flag to SxspAddAssemblyInstallationInfo\n",
                        __FUNCTION__);
#endif
                }
                IFW32FALSE_EXIT(::SxspAddAssemblyInstallationInfo(Flags, Item.m_RecoveryInfo, Item.m_CodebaseInfo));
            }

            //
            // Adding a reference? Don't touch references when recovering assembly via wfp/sfc.
            //
            if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFRESH) == 0)
            {
                if (Item.m_dwValidItems & CINSTALLITEM_VALID_REFERENCE)
                {
                    IFW32FALSE_EXIT(::SxspEnsureInstallReferencePresent(0, Item.m_InstallReference, fWasAdded));
                }
            }
            else
            {
#if DBG
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_WFP,
                    "SXS: %s() - not writing reference to registry in recovery/wfp/sfc\n",
                    __FUNCTION__
                    );
#endif
            }

            //
            // Creating a logfile?
            //
            if ((Item.m_dwValidItems & (CINSTALLITEM_VALID_IDENTITY | CINSTALLITEM_VALID_LOGFILE)) &&
                (m_ActCtxGenCtx.m_ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE))
            {
                IFW32FALSE_EXIT(this->WriteSingleInstallLog(Item));
            }
        }
    }
    
    fSuccess = TRUE;
Exit:
    if (!fSuccess)
    {
        CSxsPreserveLastError ple;
        for (ULONG ul = 0; ul < m_ItemsInstalled.GetSize(); ul++)
        {
            m_ItemsInstalled[ul].m_RecoveryInfo.RestorePreviouslyExistingRegistryData();
        }
        ple.Restore();
    }
    m_bSuccessfulSoFar= m_bSuccessfulSoFar && fSuccess;
    return fSuccess;
}

BOOL
WINAPI
SxsBeginAssemblyInstall(
    DWORD Flags,
    PSXS_INSTALLATION_FILE_COPY_CALLBACK InstallationCallback,
    PVOID InstallationContext,
    PSXS_IMPERSONATION_CALLBACK ImpersonationCallback,
    PVOID ImpersonationContext,
    PVOID *ppvInstallCookie
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    DWORD dwManifestOperationFlags = 0;
    CAssemblyInstall* pInstall = NULL;
    CImpersonationData ImpersonationData(ImpersonationCallback, ImpersonationContext);

    if (ppvInstallCookie != NULL)
        *ppvInstallCookie = NULL;

    PARAMETER_CHECK(ppvInstallCookie != NULL);
    PARAMETER_CHECK(
        (Flags & ~(
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_MOVE |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_RESOURCE |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING)) == 0);

#define MAP_FLAG(x) do { if (Flags & SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_ ## x) dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ ## x; } while (0)

    MAP_FLAG(MOVE);
    MAP_FLAG(FROM_RESOURCE);
    MAP_FLAG(FROM_DIRECTORY);
    MAP_FLAG(FROM_DIRECTORY_RECURSIVE);
    MAP_FLAG(NOT_TRANSACTIONAL);
    MAP_FLAG(NO_VERIFY);
    MAP_FLAG(REPLACE_EXISTING);

#undef MAP_FLAG

    IFALLOCFAILED_EXIT(pInstall = new CAssemblyInstall);
    IFW32FALSE_EXIT(pInstall->BeginAssemblyInstall(dwManifestOperationFlags, InstallationCallback, InstallationContext, ImpersonationData));

    *ppvInstallCookie = pInstall;
    pInstall = NULL;

    fSuccess = TRUE;
Exit:
    FUSION_DELETE_SINGLETON(pInstall);
    return fSuccess;
}

BOOL
SxsInstallW(
    PSXS_INSTALLW lpInstallIn
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SXS_INSTALL_SOURCE_INFO sisi;
    PSXS_INSTALL_SOURCE_INFO psisi = NULL;
    CAssemblyInstall* pInstall = NULL;
    CAssemblyInstall defaultAssemblyInstall;
    CImpersonationData ImpersonationData;
    DWORD dwManifestOperationFlags = 0;
    WCHAR rgbFilenameBuffer[MAX_PATH];
    SXS_INSTALL_REFERENCEW BlankReference;
    BOOL fAreWeInOSSetupMode = FALSE;
    SXS_INSTALLW InstallCopy = { sizeof(SXS_INSTALLW) };
    CSmallStringBuffer buffConstructedCodebaseBuffer;

    PARAMETER_CHECK(
        (lpInstallIn != NULL) &&
        RTL_CONTAINS_FIELD(lpInstallIn, lpInstallIn->cbSize, lpManifestPath));

    PARAMETER_CHECK((lpInstallIn->lpManifestPath != NULL) && (lpInstallIn->lpManifestPath[0] != L'\0'));

    PARAMETER_CHECK(
        (lpInstallIn->dwFlags & ~(
            SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
            SXS_INSTALL_FLAG_MOVE |
            SXS_INSTALL_FLAG_FROM_RESOURCE |
            SXS_INSTALL_FLAG_FROM_DIRECTORY |
            SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
            SXS_INSTALL_FLAG_NOT_TRANSACTIONAL |
            SXS_INSTALL_FLAG_NO_VERIFY |
            SXS_INSTALL_FLAG_REPLACE_EXISTING |
            SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID |
            SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN |
            SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
            SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
            SXS_INSTALL_FLAG_REFERENCE_VALID |
            SXS_INSTALL_FLAG_REFRESH |
            SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID)) == 0);

#define FLAG_FIELD_CHECK(_flagname, _fieldname) PARAMETER_CHECK(((lpInstallIn->dwFlags & _flagname) == 0) || (RTL_CONTAINS_FIELD(lpInstallIn, lpInstallIn->cbSize, _fieldname)))

    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_CODEBASE_URL_VALID, lpCodebaseURL);
    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID, pvInstallCookie);
    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID, lpRefreshPrompt);
    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID, lpLogFileName);
    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_REFERENCE_VALID, lpReference);

#undef FLAG_FIELD_CHECK

    // If they said they have a codebase, they need to really have one.
    PARAMETER_CHECK(
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID) == 0) ||
        ((lpInstallIn->lpCodebaseURL != NULL) &&
         (lpInstallIn->lpCodebaseURL[0] != L'\0')));

#if DBG
    if (lpInstallIn != NULL)
    {
#define X(x,y,z) if ((lpInstallIn->dwFlags & x) != 0) \
                     Y(y,z)
#define   Y(y,z)     ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION, "SXS: %s() lpInstallIn->" #y " : " z "\n", __FUNCTION__, lpInstallIn->y)
        X(SXS_INSTALL_FLAG_CODEBASE_URL_VALID,   lpCodebaseURL, "  %ls");
        X(SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID, pvInstallCookie, "%p");
        X(SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID, lpRefreshPrompt, "%ls");
        X(SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID,  lpLogFileName, "  %ls");
        X(SXS_INSTALL_FLAG_REFERENCE_VALID,      lpReference, "    %p");
        Y(                lpManifestPath, " %ls");
        Y(                dwFlags, "        0x%lx");
#undef Y
#undef X
    }
#endif

    // If they say they have a valid cookie, make sure it is.
    PARAMETER_CHECK(
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID) == 0) ||
        (lpInstallIn->pvInstallCookie != NULL));

    // Darwin installs have implied codebases, so don't let both flags be set.
    PARAMETER_CHECK(
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN) == 0) ||
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID) == 0));

    // OS Setup only makes sense with from-directory-recursive.  Otherwise we
    // can't figure out the magic x-ms-windows-source: url to put into the codebase.
    PARAMETER_CHECK(
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP) == 0) ||
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE) != 0));

    // PARAMETER CHECKING IS DONE!  Let's copy the fields that don't have flags to
    // indicate that they're (optionally) set and start applying defaults.

    InstallCopy.dwFlags = lpInstallIn->dwFlags;
    InstallCopy.lpManifestPath = lpInstallIn->lpManifestPath;

    // Copy fields that the caller supplied and indicated were valid:

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID)
        InstallCopy.pvInstallCookie = lpInstallIn->pvInstallCookie;
    else
        InstallCopy.pvInstallCookie = NULL;

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID)
        InstallCopy.lpCodebaseURL = lpInstallIn->lpCodebaseURL;
    else
        InstallCopy.lpCodebaseURL = NULL;

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID)
        InstallCopy.lpRefreshPrompt = lpInstallIn->lpRefreshPrompt;
    else
        InstallCopy.lpRefreshPrompt = NULL;

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID)
        InstallCopy.lpLogFileName = lpInstallIn->lpLogFileName;
    else
        InstallCopy.lpLogFileName = NULL;

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_REFERENCE_VALID)
        InstallCopy.lpReference = lpInstallIn->lpReference;
    else
        InstallCopy.lpReference = NULL;

    // APPLY DEFAULTS

    //
    // Fix up blank reference for non-darwin installations to at least indicate the
    // executable which performed the installation.
    //
    if (((InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN) == 0) &&
        ((InstallCopy.dwFlags & SXS_INSTALL_FLAG_REFERENCE_VALID) == 0))
    {
        ZeroMemory(&BlankReference, sizeof(BlankReference));

        BlankReference.cbSize = sizeof(BlankReference);
        BlankReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY;
        BlankReference.lpIdentifier = NULL;

        IFW32FALSE_EXIT(::GetModuleFileNameW(NULL, rgbFilenameBuffer, NUMBER_OF(rgbFilenameBuffer)));
        BlankReference.lpNonCanonicalData = rgbFilenameBuffer;

        InstallCopy.lpReference = &BlankReference;
        InstallCopy.dwFlags |= SXS_INSTALL_FLAG_REFERENCE_VALID;
    }

    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode));

    // If this is an OS install and a codebase was not passed, we'll fill in the magical
    // one that says to look under the os setup information key.  Since the are-we-in-
    // ossetup flag always overrides, ensure that the "are we in os setup" flag is set
    // in the structure as well.
    if (
        ((InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP) != 0)
#if DBG
        || fAreWeInOSSetupMode
#endif
        )
    {
        InstallCopy.lpCodebaseURL = URLHEAD_WINSOURCE;
        InstallCopy.dwFlags |= SXS_INSTALL_FLAG_CODEBASE_URL_VALID | SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP;
    }

    // If there's no codebase (and this isn't an MSI install);
    // we'll assume that the manifest path is a sufficient codebase.
    if (((InstallCopy.dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID) == 0) &&
        ((InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN) == 0))
    {
        InstallCopy.lpCodebaseURL = InstallCopy.lpManifestPath;
        InstallCopy.dwFlags |= SXS_INSTALL_FLAG_CODEBASE_URL_VALID;
    }

#define MAP_FLAG(x) do { if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_ ## x) dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ ## x; } while (0)

    MAP_FLAG(MOVE);
    MAP_FLAG(FROM_RESOURCE);
    MAP_FLAG(NO_VERIFY);
    MAP_FLAG(NOT_TRANSACTIONAL);
    MAP_FLAG(REPLACE_EXISTING);
    MAP_FLAG(FROM_DIRECTORY);
    MAP_FLAG(FROM_DIRECTORY_RECURSIVE);
    MAP_FLAG(INSTALLED_BY_DARWIN);    
    MAP_FLAG(INSTALLED_BY_OSSETUP);    
    MAP_FLAG(REFERENCE_VALID);
    MAP_FLAG(REFRESH);    

#undef MAP_FLAG

    // Because we didn't have time to go through and get rid of the SXS_INSTALL_SOURCE_INFO struct
    // usage, we have to now map the SXS_INSTALLW to a legacy SXS_INSTALL_SOURCE_INFO.

    memset(&sisi, 0, sizeof(sisi));
    sisi.cbSize = sizeof(sisi);

    //
    // We could do this above, but that makes things 'messy' - a smart compiler
    // might merge the two..
    //
    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID)
    {
        sisi.pcwszCodebaseName = InstallCopy.lpCodebaseURL;
        sisi.dwFlags |= SXSINSTALLSOURCE_HAS_CODEBASE;
        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID)
    {
        sisi.pcwszPromptOnRefresh = InstallCopy.lpRefreshPrompt;
        sisi.dwFlags |= SXSINSTALLSOURCE_HAS_PROMPT;
        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID)
    {
        dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE;
        sisi.pcwszLogFileName = InstallCopy.lpLogFileName;
        sisi.dwFlags |= SXSINSTALLSOURCE_CREATE_LOGFILE;
        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN)
    {
        sisi.dwFlags |= SXSINSTALLSOURCE_INSTALL_BY_DARWIN;
        psisi = &sisi;
    }

    if (
        (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP)
#if DBG
        || fAreWeInOSSetupMode
#endif
        )
    {
        sisi.dwFlags |= SXSINSTALLSOURCE_INSTALL_BY_OSSETUP;
        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID)
        pInstall = reinterpret_cast<CAssemblyInstall*>(InstallCopy.pvInstallCookie);
    else
    {
        IFW32FALSE_EXIT(defaultAssemblyInstall.BeginAssemblyInstall(dwManifestOperationFlags, NULL, NULL, ImpersonationData));
        pInstall = &defaultAssemblyInstall;
    }

    //
    // If psisi is non-null, we've filled out some about the codebase information,
    // so set the manifest operation flag.
    //
    if (psisi != NULL)
    {
        dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE;
    }

    fSuccess = pInstall->InstallAssembly(
        dwManifestOperationFlags,
        InstallCopy.lpManifestPath,
        psisi,
        InstallCopy.lpReference);

    if (InstallCopy.pvInstallCookie == NULL)
    {
        DWORD dwError = ::FusionpGetLastWin32Error();
        BOOL fEndStatus = pInstall->EndAssemblyInstall(
            (fSuccess ? MANIFEST_OPERATION_INSTALL_FLAG_COMMIT : MANIFEST_OPERATION_INSTALL_FLAG_ABORT)
            | (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFRESH)
            );

        if (!fEndStatus)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: %s() - Failed call to EndAssemblyInstall, previous winerror was %lu, error after EndAssemblyInstall %lu\n",
                __FUNCTION__,
                dwError,
                ::FusionpGetLastWin32Error());
        }

        //
        // If the install failed but the end succeeded, we want the status of the install, right?
        //
        // I think it should always keep the error status of installation failure no matter whether EndInstall succeed or not.        
        // so I change the code from         
        //      if (bEndStatus && !fSuccess)
        //  to
        //      if (!fSuccess)
        //
        
        if (!fSuccess)
        {
            ::FusionpSetLastWin32Error(dwError);
        }

        fSuccess = (fSuccess && fEndStatus);
    }

Exit:
    // add assembly-install info into setup log file
    {
        CSxsPreserveLastError ple;

        if (fAreWeInOSSetupMode)
        {
            if (fSuccess)
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_SETUPLOG, "SXS Installation Succeed for %S \n", InstallCopy.lpManifestPath);
            else // if the installation fails, we need specify what and why
            {
                ASSERT(ple.LastError()!= 0);
                CHAR rgchLastError[160];
                rgchLastError[0] = 0;
                if (!::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY, NULL, ple.LastError(), 0, rgchLastError, NUMBER_OF(rgchLastError), NULL))
                    sprintf(rgchLastError, "Message not avaiable for display, please refer error# :%d\n", ::FusionpGetLastWin32Error());
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_SETUPLOG | FUSION_DBG_LEVEL_ERROR, "Installation Failed: %S. Error Message : %s\n", InstallCopy.lpManifestPath, rgchLastError);
            }
        }

        ple.Restore();
    }

    return fSuccess;
}



BOOL
SxsInstallAssemblyW(
    PVOID   pvInstallCookie,
    DWORD   Flags,
    PCWSTR  ManifestPath,
    PVOID   Reserved
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS.DLL: SxsInstallAssemblyW() called with:\n"
        "   pvInstallCookie = %p\n"
        "   Flags = 0x%08lx\n"
        "   ManifestPath = \"%ls\"\n"
        "   Reserved = %p\n",
        pvInstallCookie,
        Flags,
        ManifestPath,
        Reserved);

    CAssemblyInstall* pInstall = NULL;
    CAssemblyInstall defaultAssemblyInstall;
    CImpersonationData ImpersonationData;
    DWORD dwManifestOperationFlags = 0;
    SXS_INSTALL_REFERENCEW BlankReference;
    WCHAR rgbFilenameBuffer[MAX_PATH];
    DWORD dwError = NO_ERROR;
    BOOL fAreWeInOSSetupMode = FALSE;

    PARAMETER_CHECK((ManifestPath != NULL) && (ManifestPath[0] != L'\0'));

#define MAP_FLAG(x) do { if (Flags & SXS_INSTALL_ASSEMBLY_FLAG_ ## x) dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ ## x; } while (0)

    MAP_FLAG(MOVE);
    MAP_FLAG(FROM_RESOURCE);
    MAP_FLAG(NO_VERIFY);
    MAP_FLAG(NOT_TRANSACTIONAL);
    MAP_FLAG(REPLACE_EXISTING);
    MAP_FLAG(INCLUDE_CODEBASE);
    MAP_FLAG(FROM_DIRECTORY);
    MAP_FLAG(FROM_DIRECTORY_RECURSIVE);
    MAP_FLAG(INSTALLED_BY_DARWIN);    

#undef MAP_FLAG

    if (pvInstallCookie == NULL)
    {
        PARAMETER_CHECK(
            (Flags & ~(
                SXS_INSTALL_ASSEMBLY_FLAG_MOVE |
                SXS_INSTALL_ASSEMBLY_FLAG_FROM_RESOURCE |
                SXS_INSTALL_ASSEMBLY_FLAG_NO_VERIFY |
                SXS_INSTALL_ASSEMBLY_FLAG_NOT_TRANSACTIONAL |
                SXS_INSTALL_ASSEMBLY_FLAG_REPLACE_EXISTING |
                SXS_INSTALL_ASSEMBLY_FLAG_INCLUDE_CODEBASE |
                SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY |
                SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY_RECURSIVE |
                SXS_INSTALL_ASSEMBLY_FLAG_INSTALLED_BY_DARWIN |                
                SXS_INSTALL_ASSEMBLY_FLAG_CREATE_LOGFILE)) == 0);

        pInstall = &defaultAssemblyInstall;
        IFW32FALSE_EXIT(pInstall->BeginAssemblyInstall(dwManifestOperationFlags, NULL, NULL, ImpersonationData));
    }
    else
    {
        PARAMETER_CHECK(
            (Flags & ~(
                SXS_INSTALL_ASSEMBLY_FLAG_MOVE |
                SXS_INSTALL_ASSEMBLY_FLAG_FROM_RESOURCE |
                SXS_INSTALL_ASSEMBLY_FLAG_NO_VERIFY |
                SXS_INSTALL_ASSEMBLY_FLAG_NOT_TRANSACTIONAL |
                SXS_INSTALL_ASSEMBLY_FLAG_REPLACE_EXISTING |
                SXS_INSTALL_ASSEMBLY_FLAG_INCLUDE_CODEBASE |
                SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY |
                SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY_RECURSIVE |
                SXS_INSTALL_ASSEMBLY_FLAG_INSTALLED_BY_DARWIN |                
                SXS_INSTALL_ASSEMBLY_FLAG_CREATE_LOGFILE)) == 0);
        pInstall = reinterpret_cast<CAssemblyInstall*>(pvInstallCookie);
    }

    //
    // Set up the blank reference to fake this installation so it will be frozen
    // into the cache until such time as the user forcably removes it.
    //
    ZeroMemory(&BlankReference, sizeof(BlankReference));
    BlankReference.cbSize = sizeof(BlankReference);
    BlankReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY;
    dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID;
    if (GetModuleFileNameW(GetModuleHandle(NULL), rgbFilenameBuffer, NUMBER_OF(rgbFilenameBuffer)))
    {
        BlankReference.lpNonCanonicalData = rgbFilenameBuffer;
    }

    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode));

    fSuccess = pInstall->InstallAssembly(dwManifestOperationFlags, ManifestPath, reinterpret_cast<PCSXS_INSTALL_SOURCE_INFO>(Reserved), &BlankReference);
    dwError = ::FusionpGetLastWin32Error();
    ASSERT(HeapValidate(FUSION_DEFAULT_PROCESS_HEAP(), 0, NULL));
    if (pvInstallCookie == NULL)
    {
        BOOL bEndStatus = pInstall->EndAssemblyInstall(fSuccess ? MANIFEST_OPERATION_INSTALL_FLAG_COMMIT : MANIFEST_OPERATION_INSTALL_FLAG_ABORT);

#if DBG
        if (!bEndStatus)
        {
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                "SXS: %s() - Failed call to EndAssemblyInstall, previous winerror was %ld, error after EndAssemblyInstall %ld\n",
                __FUNCTION__,
                dwError,
                ::FusionpGetLastWin32Error());
        }
#endif

        //
        // If the install failed but the end succeeded, we want the status of the install, right?
        //
        // I think it should always keep the error status of installation failure no matter whether EndInstall succeed or not.        
        // so I change the code from         
        //      if (bEndStatus && !fSuccess)
        //  to
        //      if (!fSuccess)
        //
        
        if (!fSuccess)
        {
            ::FusionpSetLastWin32Error(dwError);
        }

        fSuccess = (fSuccess && bEndStatus);
    }

Exit:
    // add assembly-install info into setup log file
    {
        CSxsPreserveLastError ple;

        if (fAreWeInOSSetupMode)
        {
            if (fSuccess)
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_SETUPLOG, "SXS Installation Succeed for %S \n",ManifestPath);
            else // if the installation fails, we need specify what and why
            {
                ASSERT(ple.LastError()!= 0);
                CHAR rgchLastError[160];
                rgchLastError[0] = 0;
                if (!::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY, NULL, ple.LastError(), 0, rgchLastError, NUMBER_OF(rgchLastError), NULL))
                    sprintf(rgchLastError, "Message not avaiable for display, please refer error# :%d\n", ::FusionpGetLastWin32Error());
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_SETUPLOG | FUSION_DBG_LEVEL_ERROR, "SXS Installation Failed: %S. Error Message : %s\n",ManifestPath, rgchLastError);
            }
        }

        ple.Restore();
    }

    return fSuccess;
}


BOOL
WINAPI
SxsEndAssemblyInstall(
    PVOID   pvInstallCookie,
    DWORD   dwFlags,
    PVOID   pvReserved
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CAssemblyInstall* pInstall = NULL;
    DWORD dwManifestOperationFlags = 0;

    if ((dwFlags & SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS) && pvReserved)
        *(PBOOL)pvReserved = FALSE;

    PARAMETER_CHECK(pvInstallCookie != NULL);
    PARAMETER_CHECK(
        (dwFlags & ~(
            SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT |
            SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT |
            SXS_END_ASSEMBLY_INSTALL_FLAG_NO_VERIFY |
            SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS)) == 0);

#define X SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT
#define Y SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT
    PARAMETER_CHECK(((dwFlags & (X | Y)) == X)
        || ((dwFlags & (X | Y)) == Y));
#undef X
#undef Y

    //
    // Want the install status?  Don't forget to tell us where to put it.
    //
    PARAMETER_CHECK(!(
        (dwFlags & SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS) &&
        (pvReserved != NULL)));

#define MAP_FLAG(x) do { if (dwFlags & SXS_END_ASSEMBLY_INSTALL_FLAG_ ## x) dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ ## x; } while (0)
    MAP_FLAG(COMMIT);
    MAP_FLAG(ABORT);
    MAP_FLAG(NO_VERIFY);
#undef MAP_FLAG

    pInstall = reinterpret_cast<CAssemblyInstall*>(pvInstallCookie);
    IFW32FALSE_EXIT(pInstall->EndAssemblyInstall(dwManifestOperationFlags));
    if (dwFlags & SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS)
    {
        *(PBOOL)pvReserved = pInstall->m_bSuccessfulSoFar;
    }
    
    fSuccess = TRUE;
Exit:
    CSxsPreserveLastError ple;
    FUSION_DELETE_SINGLETON(pInstall); // no matter failed or succeed, delete it
    ple.Restore();

    return fSuccess;
}

/*-----------------------------------------------------------------------------
predefined setup callbacks
-----------------------------------------------------------------------------*/

static BOOL WINAPI
SxspInstallCallbackSetupCopyQueueEx(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS parameters2 = reinterpret_cast<PSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS>(parameters->pvContext);
    ASSERT(parameters->cbSize == sizeof(*parameters));
    ASSERT(parameters2->cbSize == sizeof(*parameters2));

    CSetupCopyQueuePathParameters setupCopyQueueParameters;

    IFW32FALSE_EXIT(setupCopyQueueParameters.Initialize(parameters->pSourceFile, parameters->pDestinationFile));

    IFW32FALSE_EXIT(
        ::SetupQueueCopyW(
            parameters2->hSetupCopyQueue,
            setupCopyQueueParameters.m_sourceRoot,
            setupCopyQueueParameters.m_sourcePath,
            setupCopyQueueParameters.m_sourceName,
            parameters2->pszSourceDescription,
            NULL, // tag file
            setupCopyQueueParameters.m_destinationDirectory,
            setupCopyQueueParameters.m_destinationName,
            parameters2->dwCopyStyle));

    parameters->nDisposition = SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_QUEUED;
    fSuccess = TRUE;

Exit:
    ASSERT(HeapValidate(FUSION_DEFAULT_PROCESS_HEAP(), 0, NULL));
    return fSuccess;
}

static BOOL WINAPI
SxspInstallCallbackSetupCopyQueue(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ASSERT(parameters->cbSize == sizeof(*parameters));
    HSPFILEQ hSetupCopyQueue = reinterpret_cast<HSPFILEQ>(parameters->pvContext);

    SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS parameters2 = {sizeof(parameters2)};
    parameters2.hSetupCopyQueue = hSetupCopyQueue;
    parameters2.pszSourceDescription = NULL;
    parameters2.dwCopyStyle = 0;

    // copy to not violate const
    SXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters3 = *parameters;
    parameters3.pvContext = &parameters2;

    IFW32FALSE_EXIT(::SxspInstallCallbackSetupCopyQueueEx(&parameters3));

    parameters->nDisposition = parameters3.nDisposition;
    fSuccess = TRUE;

Exit:
    ASSERT(HeapValidate(FUSION_DEFAULT_PROCESS_HEAP(), 0, NULL));
    return fSuccess;
}

VOID CALLBACK
SxsRunDllInstallAssemblyW(HWND hwnd, HINSTANCE hinst, PWSTR lpszCmdLine, int nCmdShow)
{
    FN_PROLOG_VOID

    SXS_INSTALLW Install = { sizeof(SXS_INSTALLW) };
    SXS_INSTALL_REFERENCEW Reference = { sizeof(SXS_INSTALL_REFERENCEW) };
    CSmallStringBuffer FullPath;
#if DBG && defined(FUSION_WIN)
    CSmallStringBuffer ExePath;
    CSmallStringBuffer ExeName;
#endif

    IFW32FALSE_EXIT(::SxspExpandRelativePathToFull(lpszCmdLine, ::wcslen(lpszCmdLine), FullPath));

    Install.dwFlags = SXS_INSTALL_FLAG_REPLACE_EXISTING | 
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID;
    Install.lpManifestPath = FullPath;
    Install.lpCodebaseURL = FullPath;
    Install.lpReference = &Reference;

    Reference.dwFlags = 0;
    Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;

//
// In order to facilitate generating multiple actual references/codebases, under DBG
// use the .exe name instead of rundll32. Then, make differently named copies
// of rundll32.exe to generate difference references/codebases.
//
#if DBG && defined(FUSION_WIN)
    IFW32FALSE_EXIT(ExePath.Win32Assign(&NtCurrentPeb()->ProcessParameters->ImagePathName));
    IFW32FALSE_EXIT(ExePath.Win32GetLastPathElement(ExeName));
    IFW32FALSE_EXIT(ExeName.Win32ClearPathExtension());

    Reference.lpIdentifier = ExeName;
#else
    Reference.lpIdentifier = L"RunDll32";
#endif

    ::SxsInstallW(&Install);

    FN_EPILOG
}

VOID CALLBACK
SxsRunDllInstallAssembly(HWND hwnd, HINSTANCE hinst, PSTR lpszCmdLine, int nCmdShow)
{
    FN_TRACE_SMART_TLS();

    CStringBuffer buffer;
    if (buffer.Win32Assign(lpszCmdLine, ::strlen(lpszCmdLine)))
    {
        ::SxsRunDllInstallAssemblyW(hwnd, hinst, const_cast<PWSTR>(static_cast<PCWSTR>(buffer)), nCmdShow);
    }
}

BOOL
CAssemblyInstallReferenceInformation::WriteIntoRegistry(
    const CFusionRegKey &rhkTargetKey
    ) const
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(this->m_fIdentityStuffReady);

    IFW32FALSE_EXIT(
        rhkTargetKey.SetValue(
            m_buffGeneratedIdentifier,
            this->GetCanonicalData()));
    
    FN_EPILOG
}

CAssemblyInstallReferenceInformation::CAssemblyInstallReferenceInformation()
    : m_SchemeGuid(GUID_NULL), m_fIdentityStuffReady(FALSE), m_dwFlags(0)
{
}

BOOL
CAssemblyInstallReferenceInformation::GenerateFileReference(
    IN const CBaseStringBuffer &buffKeyfileName,
    OUT CBaseStringBuffer &buffDrivePath,
    OUT CBaseStringBuffer &buffFilePart,
    OUT DWORD &dwDriveSerial
    )
{
    FN_PROLOG_WIN32

    CStringBuffer buffWorking;
    CSmallStringBuffer buffTemp;
    bool fIsUncPath = false;

    dwDriveSerial = 0;

    // The key file must either start with "\\" or "x:\" to be valid.
    PARAMETER_CHECK(buffKeyfileName.Cch() >= 3);
    PARAMETER_CHECK(
        ((::FusionpIsPathSeparator(buffKeyfileName[0]) &&
          ::FusionpIsPathSeparator(buffKeyfileName[1])) ||
         (::FusionpIsDriveLetter(buffKeyfileName[0]) &&
          (buffKeyfileName[1] == L':') &&
          ::FusionpIsPathSeparator(buffKeyfileName[2]))));

    //
    // Steps:
    // - Strip potential file name from buffKeyfileName.
    // - Call GetVolumePathName on buffKeyfileName, store that
    //   in buffDrivePath
    // - Call GetVolumeNameForVolumeMountPoint on buffDrivePath,
    //   store into some temporary
    // - Call GetVolumeInformation on the temporary to
    //   obtain the serial number.
    // - Call GetDriveType on the temporary to see what kind of 
    //   drive type the key is on.
    //   - If it's on a network, call SxspGetUniversalName to get
    //     the network path (call on buffDrivePath)
    //
    IFW32FALSE_EXIT(::SxspGetFullPathName(buffKeyfileName, buffWorking));
    IFW32FALSE_EXIT(::SxspGetVolumePathName(0, buffWorking, buffDrivePath));
    IFW32FALSE_EXIT(buffFilePart.Win32Assign(buffWorking));

    // If the user pointed us to something that is a volume path but did not include the
    // trailing path separator, we'll actually end up with a buffDrivePath like "c:\mountpoint\"
    // but the buffFilePart will be "c:\mountpoint".  we'll explicitly handle
    // this situation; there does not seem to be a generalization.  -mgrier 6/26/2001
    if ((buffDrivePath.Cch() == (buffFilePart.Cch() + 1)) &&
        buffDrivePath.HasTrailingPathSeparator() &&
        !buffFilePart.HasTrailingPathSeparator())
    {
        buffFilePart.Clear();
    }
    else
    {
        INTERNAL_ERROR_CHECK(buffFilePart.Cch() >= buffDrivePath.Cch());
        buffFilePart.Right(buffFilePart.Cch() - buffDrivePath.Cch());
    }

    fIsUncPath = false;

    if (::FusionpIsPathSeparator(buffDrivePath[0]))
    {
        if (::FusionpIsPathSeparator(buffDrivePath[1]))
        {
            if (buffDrivePath[2] == L'?')
            {
                if (::FusionpIsPathSeparator(buffDrivePath[3]))
                {
                    //  "\\?\"; now look for "unc"
                    if (((buffDrivePath[4] == L'u') || (buffDrivePath[4] == L'U')) &&
                        ((buffDrivePath[5] == L'n') || (buffDrivePath[5] == L'N')) &&
                        ((buffDrivePath[6] == L'c') || (buffDrivePath[6] == L'C')) &&
                        ::FusionpIsPathSeparator(buffDrivePath[7]))
                        fIsUncPath = true;
                }
            }
            else
                fIsUncPath = true;
        }
    }

    if ((::GetDriveTypeW(buffDrivePath) == DRIVE_REMOTE) && !fIsUncPath)
    {
        IFW32FALSE_EXIT(::SxspGetRemoteUniversalName(buffDrivePath, buffTemp));
        IFW32FALSE_EXIT(buffDrivePath.Win32Assign(buffTemp));

        // This seems gross, but the drive letter can be mapped to \\server\share\dir, so we'll
        // trim it down to the volume path name, and anything that's after that we'll shift over
        // to the file part.
        //
        // Luckily the string always seems to be of the form \\server\share\path1\path2\ (note
        // the trailing slash), and GetVolumePathName() should always return "\\server\share\"
        // so relatively simple string manipulation should clean this up.
        IFW32FALSE_EXIT(::SxspGetVolumePathName(0, buffDrivePath, buffTemp));

        INTERNAL_ERROR_CHECK(buffTemp.Cch() <= buffDrivePath.Cch());

        if (buffTemp.Cch() != buffDrivePath.Cch())
        {
            IFW32FALSE_EXIT(buffFilePart.Win32Prepend(buffDrivePath + buffTemp.Cch(), buffDrivePath.Cch() - buffTemp.Cch()));
            IFW32FALSE_EXIT(buffDrivePath.Win32Assign(buffTemp));
        }
    }

    if (!::GetVolumeInformationW(
			buffDrivePath,
			NULL,
			0,
			&dwDriveSerial,
			NULL,
			NULL,
			NULL,
			0))
    {
        const DWORD Error = ::FusionpGetLastWin32Error();
#if DBG
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: GetVolumeInformationW(%ls) Error %lu\n",
            static_cast<PCWSTR>(buffDrivePath),
            Error);
#endif
        ORIGINATE_WIN32_FAILURE_AND_EXIT(GetVolumeInformationW, Error);
    }

    if (::FusionpIsPathSeparator(buffDrivePath[0]) &&
        ::FusionpIsPathSeparator(buffDrivePath[1]) &&
        (buffDrivePath[2] == L'?') &&
        ::FusionpIsPathSeparator(buffDrivePath[3]))
    {
        //  "\\?\"; now look for "unc"
        if (((buffDrivePath[4] == L'u') || (buffDrivePath[4] == L'U')) &&
            ((buffDrivePath[5] == L'n') || (buffDrivePath[5] == L'N')) &&
            ((buffDrivePath[6] == L'c') || (buffDrivePath[6] == L'C')) &&
            ::FusionpIsPathSeparator(buffDrivePath[7]))
        {
            // "\\?\UNC\"
            buffDrivePath.Right(buffDrivePath.Cch() - 7);
            IFW32FALSE_EXIT(buffDrivePath.Win32Prepend(L'\\'));
        }
        else
        {
            buffDrivePath.Right(buffDrivePath.Cch() - 4);
        }
    }


    FN_EPILOG
}



BOOL
pMapSchemeGuidToString(
    IN  const GUID &rcGuid,
    OUT CBaseStringBuffer &rbuffIdentifier
    )
{
    FN_PROLOG_WIN32

    static struct {
        const GUID* pguid;
        PCWSTR pcwsz;
        SIZE_T cch;
    } gds[] = {
        { &SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL, L"OS", 2 },
        { &SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY, L"SIAW", 4 },
        { &SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY, L"U", 1 },
        { &SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING, L"S", 1 },
        { &SXS_INSTALL_REFERENCE_SCHEME_KEYFILE, L"F", 1 },
    };
    ULONG ul;

    for ( ul = 0; ul < NUMBER_OF(gds); ul++ )
    {
        if ( *(gds[ul].pguid) == rcGuid )
        {
            IFW32FALSE_EXIT(rbuffIdentifier.Win32Assign(gds[ul].pcwsz, gds[ul].cch));
            break;
        }
    }
    if ( ul == NUMBER_OF(gds) )
    {
        IFW32FALSE_EXIT(::SxspFormatGUID(rcGuid, rbuffIdentifier));
    }
    
    FN_EPILOG
}



BOOL
CAssemblyInstallReferenceInformation::GenerateIdentifierValue(
    OUT CBaseStringBuffer *pbuffTarget
    )
{
    FN_PROLOG_WIN32

    if ( pbuffTarget != NULL )
        pbuffTarget->Clear();

    if (m_fIdentityStuffReady)
    {
        if (pbuffTarget != NULL)
            IFW32FALSE_EXIT(pbuffTarget->Win32Assign(m_buffGeneratedIdentifier));
    }
    else
    {
        const GUID& SchemeGuid = this->GetSchemeGuid();
    
        IFW32FALSE_EXIT(::pMapSchemeGuidToString(SchemeGuid, m_buffGeneratedIdentifier));

        if ((SchemeGuid != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) &&
            (SchemeGuid != SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY))
        {
            IFW32FALSE_EXIT(m_buffGeneratedIdentifier.Win32Append(
                SXS_REFERENCE_CHUNK_SEPERATOR,
                SXS_REFERENCE_CHUNK_SEPERATOR_CCH));
                
            if ((SchemeGuid == SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING) ||
                 (SchemeGuid == SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY))
            {
                //
                // Both of these just use the value in the lpIdentifier member.  It was
                // validated above, so it's OK to use here directly
                //
                IFW32FALSE_EXIT(m_buffGeneratedIdentifier.Win32Append(this->GetIdentifier()));
            }
            else if (SchemeGuid == SXS_INSTALL_REFERENCE_SCHEME_KEYFILE)
            {
                CSmallStringBuffer buffDrivePath;
                CSmallStringBuffer buffFilePart;
                DWORD dwDriveSerialNumber;
                
                IFW32FALSE_EXIT(this->GenerateFileReference(
                    this->GetIdentifier(),
                    buffDrivePath,
                    buffFilePart,
                    dwDriveSerialNumber));

                //
                // Now form up the value stuff.
                //
                IFW32FALSE_EXIT(buffDrivePath.Win32EnsureTrailingPathSeparator());
                buffFilePart.RemoveLeadingPathSeparators();
                IFW32FALSE_EXIT(m_buffGeneratedIdentifier.Win32FormatAppend(
                    L"%ls;%08lx;%ls",
                    static_cast<PCWSTR>(buffDrivePath),
                    dwDriveSerialNumber,
                    static_cast<PCWSTR>(buffFilePart)));
            }

        }

        this->m_fIdentityStuffReady = TRUE;
        if ( pbuffTarget != NULL )
        {
            IFW32FALSE_EXIT(pbuffTarget->Win32Assign(m_buffGeneratedIdentifier));
        }
    }

    FN_EPILOG
}

BOOL
CAssemblyInstallReferenceInformation::Initialize(
    PCSXS_INSTALL_REFERENCEW pRefData
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(pRefData != NULL);

    // 
    // One of our good GUIDs
    //
    PARAMETER_CHECK(
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) ||
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING) ||
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY) ||
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_KEYFILE) ||
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY));

    //
    // If this is not the OS-install scheme, or the SxsInstallAssemblyW legacy API,
    // then ensure that there's at least the identifier data present.
    //
    if ((pRefData->guidScheme != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) && 
        (pRefData->guidScheme != SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY))
    {
        PARAMETER_CHECK((pRefData->lpIdentifier != NULL) && (pRefData->lpIdentifier[0] != UNICODE_NULL));
    }
        
    this->m_fIdentityStuffReady = FALSE;
    this->m_dwFlags = pRefData->dwFlags;
    this->m_SchemeGuid = pRefData->guidScheme;

    if ( pRefData->lpIdentifier != NULL)
    {
        IFW32FALSE_EXIT(this->m_buffIdentifier.Win32Assign( 
            pRefData->lpIdentifier, 
            ::wcslen(pRefData->lpIdentifier)));
    }
    
    if ( pRefData->lpNonCanonicalData != NULL )
    {
        IFW32FALSE_EXIT(this->m_buffNonCanonicalData.Win32Assign(
            pRefData->lpNonCanonicalData,
            ::wcslen(pRefData->lpNonCanonicalData)));
    }

    IFW32FALSE_EXIT(this->GenerateIdentifierValue());

    FN_EPILOG
}


BOOL 
CAssemblyInstallReferenceInformation::AcquireContents( 
    const CAssemblyInstallReferenceInformation& rcOther
    )
{
    FN_PROLOG_WIN32

    if (m_IdentityReference.IsInitialized())
        IFW32FALSE_EXIT(m_IdentityReference.Assign(rcOther.m_IdentityReference));
    else
        IFW32FALSE_EXIT(m_IdentityReference.TakeValue(rcOther.m_IdentityReference));
        
    IFW32FALSE_EXIT(m_buffGeneratedIdentifier.Win32Assign(rcOther.m_buffGeneratedIdentifier));
    IFW32FALSE_EXIT(m_buffIdentifier.Win32Assign(rcOther.m_buffIdentifier));
    IFW32FALSE_EXIT(m_buffNonCanonicalData.Win32Assign(rcOther.m_buffNonCanonicalData));
    m_dwFlags = rcOther.m_dwFlags;
    m_fIdentityStuffReady = rcOther.m_fIdentityStuffReady;
    m_SchemeGuid = rcOther.m_SchemeGuid;

    FN_EPILOG
}


BOOL 
CAssemblyInstallReferenceInformation::IsReferencePresentIn( 
    const CFusionRegKey &rhkQueryKey,
    BOOL &rfPresent,
    BOOL *pfNonCanonicalDataMatches
    ) const
{
    FN_PROLOG_WIN32

    CStringBuffer buffData;
    DWORD dwError;

    if ( pfNonCanonicalDataMatches )
        *pfNonCanonicalDataMatches = FALSE;

    INTERNAL_ERROR_CHECK(this->m_fIdentityStuffReady);

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            0,
            rhkQueryKey,
            this->m_buffGeneratedIdentifier,
            buffData,
            dwError,
            2,
            ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND));

    rfPresent = (dwError == ERROR_SUCCESS);

    if (pfNonCanonicalDataMatches)
    {
        bool fMatchesTemp;
        IFW32FALSE_EXIT(this->m_buffNonCanonicalData.Win32Equals(buffData, fMatchesTemp, true));
        rfPresent = fMatchesTemp;
    }

    FN_EPILOG
}

BOOL 
CAssemblyInstallReferenceInformation::DeleteReferenceFrom( 
    const CFusionRegKey &rhkQueryKey,
    BOOL &rfWasDeleted
    ) const
{
    FN_PROLOG_WIN32

    DWORD dwWin32Error;

    rfWasDeleted = FALSE;

    INTERNAL_ERROR_CHECK(this->m_fIdentityStuffReady);

    IFW32FALSE_EXIT(
        rhkQueryKey.DeleteValue(
            m_buffGeneratedIdentifier,
            dwWin32Error,
            2,
            ERROR_FILE_NOT_FOUND,
            ERROR_PATH_NOT_FOUND));

    rfWasDeleted = (dwWin32Error == ERROR_SUCCESS);

    FN_EPILOG
}


SMARTTYPE(CAssemblyInstallReferenceInformation);

BOOL 
CInstalledItemEntry::AcquireContents( 
    const CInstalledItemEntry &other 
    )
{
    FN_PROLOG_WIN32

    m_dwValidItems = other.m_dwValidItems;
    
    if ( m_dwValidItems & CINSTALLITEM_VALID_REFERENCE )
    {
        IFW32FALSE_EXIT(m_InstallReference.AcquireContents(other.m_InstallReference));
    }

    if ( m_dwValidItems & CINSTALLITEM_VALID_RECOVERY )
    {
        IFW32FALSE_EXIT(m_RecoveryInfo.CopyValue(other.m_RecoveryInfo));
        IFW32FALSE_EXIT(m_CodebaseInfo.Initialize(other.m_CodebaseInfo));
    }

    if ( m_dwValidItems & CINSTALLITEM_VALID_LOGFILE )
    {
        IFW32FALSE_EXIT(m_buffLogFileName.Win32Assign(other.m_buffLogFileName));
    }

    if ( m_dwValidItems & CINSTALLITEM_VALID_IDENTITY )
    {
        if ( m_AssemblyIdentity != NULL )
        {
            SxsDestroyAssemblyIdentity(m_AssemblyIdentity);
            m_AssemblyIdentity = NULL;
        }

        IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(
            0, 
            other.m_AssemblyIdentity, 
            &m_AssemblyIdentity));
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsp.h ===
#if !defined(_FUSION_DLL_WHISTLER_SXSP_H_INCLUDED_)
#define _FUSION_DLL_WHISTLER_SXSP_H_INCLUDED_

/*-----------------------------------------------------------------------------
Side X ("by") Side Private
-----------------------------------------------------------------------------*/
#pragma once

#include <stddef.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "setupapi.h"
#include "preprocessor.h"
#include "forwarddeclarations.h"
#include "enumbitoperations.h"
#include "sxstypes.h"
#include "policystatement.h"

// #include "comdef.h"
// comdef arbitrarily turns this off...
#pragma warning(error: 4244)

#include "sxsapi.h"
#include "fusion.h"
#include "fusionhash.h"
#include "fusionhandle.h"
typedef CRegKey CFusionRegKey; // need to change this when using ATL in ManifestTool.exe.
#include "processorarchitecture.h"
#include "debmacro.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "xmlns.h"
#include "sxsasmname.h"
#include "sxsexceptionhandling.h"
#include "filestream.h"

typedef struct _ACTCTXGENCTX ACTCTXGENCTX, *PACTCTXGENCTX;
typedef const struct _ACTCTXGENCTX *PCACTCTXGENCTX;

#include <objbase.h>

//
// This definition controls whether or not we allow fallback probing to the MS published
// assemblies.  Defining SXS_NO_MORE_MR_NICE_GUY_ABOUT_MISSING_MS_PKTS prints a message
// on an attached debugger regarding a missing (ms pubkey token), while
// SXS_NO_MORE_FALLBACK_PROBING_PERIOD turns off even the warning output and probing check
// (perf optimization.)
//
// #undef    SXS_NO_MORE_MR_NICE_GUY_ABOUT_MISSING_MS_PKTS
#define    SXS_NO_MORE_MR_NICE_GUY_ABOUT_MISSING_MS_PKTS        ( TRUE )
#undef    SXS_NO_MORE_FALLBACK_PROBING_PERIOD
//#define    SXS_NO_MORE_FALLBACK_PROBING_PERIOD                        ( TRUE )

//
// Here we define the minimal number of bits that a catalog signer must have
// to allow installation.  NOTE: The length of any key will be lied about by
// CPublicKeyInformation.GetPublicKeyBitLength if the test root certificate is
// installed.  If so, then it always returns SXS_MINIMAL_SIGNING_KEY_LENGTH!
//
#define SXS_MINIMAL_SIGNING_KEY_LENGTH    ( 2048 )


extern "C"
BOOL
WINAPI
SxsDllMain(
    HINSTANCE hInst,
    DWORD dwReason,
    PVOID pvReserved
    );

// Due to dependencies, the rest of the includes are later in the file.

#ifndef INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW
#define INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW ( 0x8000000 )
#endif

#define SXS_DEFAULT_ASSEMBLY_NAMESPACE          L""
#define SXS_DEFAULT_ASSEMBLY_NAMESPACE_CCH      0

typedef struct _name_length_pair_ {
    PCWSTR  string;
    ULONG length;
} SXS_NAME_LENGTH_PAIR;

#define SXS_UNINSTALL_ASSEMBLY_FLAG_USING_TEXTUAL_STRING      (0x00000001)
#define SXS_UNINSTALL_ASSEMBLY_FLAG_USING_INSTALL_LOGFILE     (0x00000002)

//
//  Legend for decoding probing strings:
//
//  First, we walk the string from beginning to end.  Normally, characters are copied to the
//  probe string literally.
//
//  If $ is found, the character after $ is an identifier for a replacement token.
//
//  Replacement tokens (note that case is sensitive and $ followed by an illegal character results in an internal error reported):
//
//      M - "%systemroot%\winsxs\manifests\"
//      . - Application root (including trailing slash)
//      L - langauge
//      N - full assembly text name
//      C - combined name (e.g. x86_foo.bar.baz_strong-name_language_version_hash)
//


#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_ROOT_SYSTEM_MANIFEST_STORE (1)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_ROOT_APPLICATION_DIRECTORY (2)

#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_NONE (0)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_ASSEMBLY_TEXT_NAME (1)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_ASSEMBLY_TEXT_SHORTENED_NAME (2)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_ASSEMBLY_TEXT_NAME_FINAL_SEGMENT (3)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_ASSEMBLY_DIRECTORY_NAME (4)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_LANGUAGE (5)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_VERSION (6)

#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_MANIFEST_FILE_TYPE_INVALID (0)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_MANIFEST_FILE_TYPE_FINAL_SEGMENT (1)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_MANIFEST_FILE_TYPE_SHORTENED_NAME (2)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_MANIFEST_FILE_TYPE_NAME (3)

typedef struct _SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR
{
    ULONG Root;
    const WCHAR *SubDirectory;
    SIZE_T CchSubDirectory;
    ULONG FileType; // Only used for private probing to control order of .manifest vs. .dll probing
    const WCHAR *Extension;
    SIZE_T CchExtension;
    ULONG IdentityInclusionArray[8];
} SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR, *PSXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR;

typedef const SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR *PCSXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR;

#define UNCHECKED_DOWNCAST static_cast

#define ASSEMBLY_PRIVATE_MANIFEST            (0x10)
#define ASSEMBLY_PRIVATE_MANIFEST_MASK       (0xF0)

typedef enum _SXS_POLICY_SOURCE
{
    SXS_POLICY_UNSPECIFIED,
    SXS_POLICY_SYSTEM_POLICY,
    SXS_POLICY_ROOT_POLICY,
    SXS_POLICY_REDMOND_POLICY
} SXS_POLICY_SOURCE;

#define ACTCTXDATA_ALIGNMENT_BITS (2)
#define ACTCTXDATA_ALIGNMENT (1 << ACTCTXDATA_ALIGNMENT_BITS)
#define ROUND_ACTCTXDATA_SIZE(_cb) (((_cb) + ACTCTXDATA_ALIGNMENT - 1) & (~(ACTCTXDATA_ALIGNMENT - 1)))
#define ALIGN_ACTCTXDATA_POINTER(_ptr, _type) ((_type) ROUND_ACTCTXDATA_SIZE(((ULONG_PTR) (_ptr))))

#include "fusionheap.h"
#include "util.h"
#include "comclsidmap.h"
#include "actctxgenctxctb.h"
#include "impersonationdata.h"
#include "fusionbuffer.h"
#include "fileoper.h"
// Due to dependencies, the rest of the includes are later in the file.

/*-----------------------------------------------------------------------------
This is useful like so:
    DbgPrint("something happened in %s", __FUNCTION__);
approx:
    LogError(L"something happened in %1", LFUNCTION);
but the string is actually in a message file and the extra parameters must
be passed as const UNICODE_STRING&, so more like:
    LogError(MSG_SXS_SOMETHING_HAPPENED, CUnicodeString(LFUNCTION));
-----------------------------------------------------------------------------*/
#define LFUNCTION   PASTE(L, __FUNCTION__)
#define LFILE       PASTE(L, __FILE__)

#if DBG
#define IF_DBG(x) x
#else
#define IF_DBG(x) /* nothing */
#endif

// This global is used for testing/debugging to set the assembly store root
// to something other than %windir%\winsxs
extern PCWSTR g_AlternateAssemblyStoreRoot;

/*-----------------------------------------------------------------------------
copied from \\jayk1\g\vs\src\vsee\lib
Usage

If you say

OutputDebugStringA(PREPEND_FILE_LINE("foo"))
or

CStringBuffer msg;
msg.Format(PREPEND_FILE_LINE("foo%bar%x"), ...)
OutputDebugStringA(msg)
or

pragma message (PREPEND_FILE_LINE("foo"))

you can F4 through the output in VC's output window.

Don't checkin #pragma messages though.
-----------------------------------------------------------------------------*/
#define PREPEND_FILE_LINE(msg) __FILE__ "(" STRINGIZE(__LINE__) ") : " msg
#define PREPEND_FILE_LINE_W(msg) LFILE L"(" STRINGIZEW(__LINE__) L") : " msg

/*-----------------------------------------------------------------------------
Length = 0
MaximumLength = 0
Buffer = L""
-----------------------------------------------------------------------------*/
extern const UNICODE_STRING g_strEmptyUnicodeString;

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) ((sizeof(x)) / sizeof((x)[0]))
#endif

#define MANIFEST_ROOT_DIRECTORY_NAME                            L"Manifests"
#define POLICY_ROOT_DIRECTORY_NAME                              L"Policies"

#define ASSEMBLY_TYPE_WIN32                                     L"win32"
#define REGISTRY_BACKUP_ROOT_DIRECTORY_NAME                     L"Recovery"
#define ASSEMBLY_TYPE_WIN32_CCH                                 (NUMBER_OF(ASSEMBLY_TYPE_WIN32) - 1)

#define ASSEMBLY_TYPE_WIN32_POLICY                              L"win32-policy"
#define ASSEMBLY_TYPE_WIN32_POLICY_CCH                          (NUMBER_OF(ASSEMBLY_TYPE_WIN32_POLICY) - 1)
#define REGISTRY_BACKUP_ROOT_DIRECTORY_NAME_CCH                 (NUMBER_OF(REGISTRY_BACKUP_ROOT_DIRECTORY_NAME)-1)

#define ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX                      L".Manifest"
#define ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_DLL                  L".Dll"
#define ASSEMBLY_POLICY_FILE_NAME_SUFFIX                        L".Policy"

#define ASSEMBLY_LONGEST_MANIFEST_FILE_NAME_SUFFIX              L".Manifest"
/* term is either L"\0" or , */
#define ASSEMBLY_MANIFEST_FILE_NAME_SUFFIXES(term)              L".Manifest" term L".Dll" term L".Policy" term
#define INSTALL_MANIFEST_FILE_NAME_SUFFIXES(term)  L".Man" term L".Manifest" term L".Dll" term L".Policy" term

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE L"no-public-key"

//
// This is the all-powerful public key token (in hex-string format) that is the
// Microsoft Windows Whistler Win32 Fusion public key token.  Don't change this
// unless a) you get a new key b) you update all the manifests that contain this
// string c) you really really really want a headache.
//
#define SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT ( L"6595b64144ccf1df" )
#define SXS_MS_PUBLIC_KEY_DEFAULT ( \
    L"002400000480000014010000060200000024000052534131" \
    L"0008000001000100d5938fed940a72fe45232d867d252f87" \
    L"0097e0039ffbf647ebd8817bbeaefbbbf68ce55e2542769e" \
    L"8a43e5880daa307ff50783d3b157ac9fc3d5410259bd0111" \
    L"56d60bcd4c10d2ace51445e825ef6b1929d187360b08c7e1" \
    L"bc73a2c6f78434729eb58e481bb3635ecfdfcb683119dc61" \
    L"f5d29226e8c9d7ac415d53992ca9714722abfcfd88efd3e3" \
    L"46ef02b83b4dbbf429e026b1889a6ba228fdb5709be852e1" \
    L"e81c011a6a18055f898863ccd4902041543c6cf10efb038b" \
    L"5ab34f1bfa18d3affa01d4980a979606abd3b7ccdae2e0ae" \
    L"a0d875c2d4df5509a234d9dd840ef7be91fe362799b18ba4" \
    L"dfcf2a110052b5d63cb69014448bdb2ffb0832418c054695" \
)

#define ASSEMBLY_REGISTRY_ROOT L"Software\\Microsoft\\Windows\\CurrentVersion\\SideBySide\\"

#define ASSEMBLY_INSTALL_TEMP_DIR_NAME ( L"InstallTemp" )

interface IXMLNodeSource;

typedef enum _SXS_NODE_TYPE
    {   SXS_ELEMENT = 1,
    SXS_ATTRIBUTE   = SXS_ELEMENT + 1,
    SXS_PI  = SXS_ATTRIBUTE + 1,
    SXS_XMLDECL = SXS_PI + 1,
    SXS_DOCTYPE = SXS_XMLDECL + 1,
    SXS_DTDATTRIBUTE    = SXS_DOCTYPE + 1,
    SXS_ENTITYDECL  = SXS_DTDATTRIBUTE + 1,
    SXS_ELEMENTDECL = SXS_ENTITYDECL + 1,
    SXS_ATTLISTDECL = SXS_ELEMENTDECL + 1,
    SXS_NOTATION    = SXS_ATTLISTDECL + 1,
    SXS_GROUP   = SXS_NOTATION + 1,
    SXS_INCLUDESECT = SXS_GROUP + 1,
    SXS_PCDATA  = SXS_INCLUDESECT + 1,
    SXS_CDATA   = SXS_PCDATA + 1,
    SXS_IGNORESECT  = SXS_CDATA + 1,
    SXS_COMMENT = SXS_IGNORESECT + 1,
    SXS_ENTITYREF   = SXS_COMMENT + 1,
    SXS_WHITESPACE  = SXS_ENTITYREF + 1,
    SXS_NAME    = SXS_WHITESPACE + 1,
    SXS_NMTOKEN = SXS_NAME + 1,
    SXS_STRING  = SXS_NMTOKEN + 1,
    SXS_PEREF   = SXS_STRING + 1,
    SXS_MODEL   = SXS_PEREF + 1,
    SXS_ATTDEF  = SXS_MODEL + 1,
    SXS_ATTTYPE = SXS_ATTDEF + 1,
    SXS_ATTPRESENCE = SXS_ATTTYPE + 1,
    SXS_DTDSUBSET   = SXS_ATTPRESENCE + 1,
    SXS_LASTNODETYPE    = SXS_DTDSUBSET + 1
    }   SXS_NODE_TYPE;

typedef struct _SXS_NODE_INFO {
    _SXS_NODE_INFO() { }
    ULONG Size;
    ULONG Type;
    CSmallStringBuffer NamespaceStringBuf;
    const WCHAR *pszText;       // this could be an attribute name or value string of an attribute
    SIZE_T cchText;
private:
    _SXS_NODE_INFO(const _SXS_NODE_INFO &);
    void operator =(const _SXS_NODE_INFO &);

} SXS_NODE_INFO, *PSXS_NODE_INFO;

typedef const SXS_NODE_INFO *PCSXS_NODE_INFO;

/*-----------------------------------------------------------------------------
This returns a pointer to statically allocated memory. Don't free it.
In free builds, it just returns an empty string.
-----------------------------------------------------------------------------*/
const WCHAR* SxspInstallDispositionToStringW(ULONG);

typedef const struct _ATTRIBUTE_NAME_DESCRIPTOR *PCATTRIBUTE_NAME_DESCRIPTOR;

typedef VOID (WINAPI * SXS_REPORT_PARSE_ERROR_MISSING_REQUIRED_ATTRIBUTE_CALLBACK)(
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    );

typedef VOID (WINAPI * SXS_REPORT_PARSE_ERROR_ATTRIBUTE_NOT_ALLOWED)(
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    );

typedef VOID (WINAPI * SXS_REPORT_PARSE_ERROR_INVALID_ATTRIBUTE_VALUE)(
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    );

class ACTCTXCTB_INSTALLATION_CONTEXT
{
public:
    ACTCTXCTB_INSTALLATION_CONTEXT() : Callback(NULL), Context(NULL), InstallSource(NULL), SecurityMetaData(NULL) { }

    PSXS_INSTALLATION_FILE_COPY_CALLBACK Callback;
    PVOID                           Context;
    PVOID                           InstallSource;
    PVOID                           SecurityMetaData;
    const void *                    InstallReferenceData;
};

typedef const ACTCTXCTB_INSTALLATION_CONTEXT *PCACTCTXCTB_INSTALLATION_CONTEXT;

typedef struct _ACTCTXCTB_CLSIDMAPPING_CONTEXT {
    CClsidMap *Map;
} ACTCTXCTB_CLSIDMAPPING_CONTEXT, *PACTCTXCTB_CLSIDMAPPING_CONTEXT;

typedef const ACTCTXCTB_CLSIDMAPPING_CONTEXT *PCACTCTXCTB_CLSIDMAPPING_CONTEXT;

#define MANIFEST_OPERATION_INVALID (0)
#define MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT (1)
#define MANIFEST_OPERATION_VALIDATE_SYNTAX (2)
#define MANIFEST_OPERATION_INSTALL (3)

#define MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL           (0x00000001)
#define MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY                   (0x00000002)
#define MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING            (0x00000004)
#define MANIFEST_OPERATION_INSTALL_FLAG_ABORT                       (0x00000008)
#define MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY              (0x00000010)
#define MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE    (0x00000020)
#define MANIFEST_OPERATION_INSTALL_FLAG_MOVE                        (0x00000040)
#define MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE            (0x00000080)
#define MANIFEST_OPERATION_INSTALL_FLAG_FROM_RESOURCE               (0x00000800)
#define MANIFEST_OPERATION_INSTALL_FLAG_COMMIT                      (0x00001000)
#define MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE              (0x00002000)
#define MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_DARWIN         (0x00004000)
#define MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID             (0x00008000)
#define MANIFEST_OPERATION_INSTALL_FLAG_REFRESH                     (0x00010000)
#define MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP        (0x00020000)

#define ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT (  0)
#define ASSEMBLY_MANIFEST_FILETYPE_FILE        (  1)
#define ASSEMBLY_MANIFEST_FILETYPE_RESOURCE    (  2)
#define ASSEMBLY_MANIFEST_FILETYPE_STREAM      (  3)
#define ASSEMBLY_MANIFEST_FILETYPE_MASK        (0xF)

#define ASSEMBLY_POLICY_FILETYPE_STREAM      (  3)
#define ASSEMBLY_POLICY_FILETYPE_MASK        (0xF)

#define SXS_POLICY_KEY_NAME L"SOFTWARE\\Policies\\Microsoft\\Windows\\SideBySide\\AssemblyReplacementPolicies"
#define SXS_POLICY_PUBLICATION_DATE_VALUE_NAME L"PublicationDate"
#define SXS_POLICY_REDIRECTION_VALUE_NAME L"ReplacedBy"

#include "assemblyreference.h"
#include "probedassemblyinformation.h"
#include "fusionheap.h"
#include "comclsidmap.h"
#include "actctxgenctxctb.h"
#include "assemblyreference.h"
#include "impersonationdata.h"
#include "fusionbuffer.h"

//
//  Notes on heap allocation by contributors:
//
//  Heap allocations associated with processing an installation, parsing a
//    or generating an activation context should be done on the
//  heap passed in the Heap member of the callback header.
//
//  This heap is destroyed when the operation is complete, and any leaks
//  by contributors are reported and may constitute a BVT break.
//
//  The heap for the _INIT callback is guaranteed to stay alive until the
//  _UNINT callback is fired.  It is absolutely not guaranteed to survive
//  any longer, and leaks are build breaks.
//
//  In debug builds, contributors may be given private heaps so that leaks
//  can be tracked per-contributor.
//

typedef struct _ACTCTXCTB_CBHEADER {
    ULONG Reason;
    ULONG ManifestOperation;
    DWORD ManifestOperationFlags;
    DWORD Flags; // these are the same flags as ACTCTXGENCTX::m_Flags
    const GUID *ExtensionGuid;
    ULONG SectionId;
    PVOID ContributorContext;
    PVOID ActCtxGenContext;
    PVOID ManifestParseContext;
    PCACTCTXCTB_INSTALLATION_CONTEXT InstallationContext; // valid only if ACTCTXCTB_INSTALLING is set
    PCACTCTXCTB_CLSIDMAPPING_CONTEXT ClsidMappingContext; // Not valid if ACTCTXCTB_GENERATE_CONTEXT not set
    PACTCTXGENCTX pOriginalActCtxGenCtx;
} ACTCTXCTB_CBHEADER, *PACTCTXCTB_CBHEADER;

BOOL operator==(const ACTCTXCTB_CBHEADER&, const ACTCTXCTB_CBHEADER&);
BOOL operator!=(const ACTCTXCTB_CBHEADER&, const ACTCTXCTB_CBHEADER&);

#define ACTCTXCTB_CBREASON_INIT                 (1)
#define ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING   (2)
#define ACTCTXCTB_CBREASON_PARSEBEGINNING       (3)
#define ACTCTXCTB_CBREASON_IDENTITYDETERMINED   (4)
#define ACTCTXCTB_CBREASON_BEGINCHILDREN        (5)
#define ACTCTXCTB_CBREASON_ENDCHILDREN          (6)
#define ACTCTXCTB_CBREASON_ELEMENTPARSED        (7)
#define ACTCTXCTB_CBREASON_PCDATAPARSED         (8)
#define ACTCTXCTB_CBREASON_CDATAPARSED          (9)
#define ACTCTXCTB_CBREASON_PARSEENDING          (10)
#define ACTCTXCTB_CBREASON_PARSEENDED           (11)
#define ACTCTXCTB_CBREASON_ALLPARSINGDONE       (12)
#define ACTCTXCTB_CBREASON_GETSECTIONSIZE       (13)
#define ACTCTXCTB_CBREASON_GETSECTIONDATA       (14)
#define ACTCTXCTB_CBREASON_ACTCTXGENENDING      (15)
#define ACTCTXCTB_CBREASON_ACTCTXGENENDED       (16)
#define ACTCTXCTB_CBREASON_UNINIT               (17)

/*-----------------------------------------------------------------------------
This returns a pointer to statically allocated memory. Don't free it.
In free builds, it just returns an empty string.

ACTCTXCTB_CBREASON_INIT => "INIT"
ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING => "GENBEGINNING"
etc.
-----------------------------------------------------------------------------*/
PCSTR SxspActivationContextCallbackReasonToString(ULONG);

//
//  Basics of the callback order:
//
//  The ACTCTXCTB_CBREASON_INIT callback will always be issued first to allow
//  the contributor to set up some global state.
//
//  The ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING callback will be fired before any
//  parse callbacks (_BEGINCHILDREN, _ENDCHILDREN, _ELEMENTPARSED, _PARSEDONE,
//  _GETSECTIONDATA, _PARSEENDING) so that the contributor may set up per-parse
//  context.
//
//  The ACTCTXCTB_CBREASON_PARSEENDING callback may be fired any time after the
//  _ACTCTXGENBEGINNING callback.  The contributor should tear down any per-parse
//  state during this callback.  After the _PARSEENDING callback is fired, only
//  the _ACTCTXGENBEGINNING and _UNINIT callbacks may be called.
//
//  The ACTCTXCTB_CBREASON_ALLPARSINGDONE callback will be fired prior to the
//  _GETSECTIONSIZE or _GETSECTIONDATA callbacks.  It's an opportunity for the
//  contributor to stabilize their data structures for generation; no further
//  _PARSEBEGINNING, _ELEMENTPARSED, _BEGINCHILDREN, _ENDCHILDREN or _PARSEENDING
//  callbacks are issued.
//
//  The ACTCTXCTB_CBREASON_GETSECTIONSIZE callback will be fired prior to the
//  _GETSECTIONDATA callback.  The section size reported by the _GETSECTIONSIZE
//  must be exact.
//
//  The ACTCTXCTB_CBREASON_GETSECTIONDATA callback must fill in the data for the
//  activation context section.  It may not write more bytes to the section than
//  were requested in the response to _PARSEDONE.
//
//  The ACTCTXCTB_CBREASON_UNINIT callback should be used to tear down any global
//  state for the contributor.  The contributor DLL may be unloaded, or another
//  _INIT callback may be issued after the _UNINIT.
//

// Used with ACTCTXCTB_CBREASON_INIT
typedef struct _ACTCTXCTB_CBINIT {
    ACTCTXCTB_CBHEADER Header;
} ACTCTXCTB_CBINIT, *PACTCTXCTB_CBINIT;

BOOL operator==(const ACTCTXCTB_CBINIT&, const ACTCTXCTB_CBINIT&);

// Used with ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING
typedef struct _ACTCTXCTB_CBACTCTXGENBEGINNING {
    ACTCTXCTB_CBHEADER Header;
    PCWSTR ApplicationDirectory;
    SIZE_T ApplicationDirectoryCch;
    ULONG ApplicationDirectoryPathType;
    BOOL Success;
} ACTCTXCTB_CBACTCTXGENBEGINNING, *PACTCTXCTB_CBACTCTXGENBEGINNING;

BOOL operator==(const ACTCTXCTB_CBACTCTXGENBEGINNING&, const ACTCTXCTB_CBACTCTXGENBEGINNING&);

#define ACTCTXCTB_CBPARSEBEGINNING_FILEFLAGS_PRECOMPILED (0x00000001)

#define XML_FILE_TYPE_MANIFEST (1)
#define XML_FILE_TYPE_COMPONENT_CONFIGURATION (2)
#define XML_FILE_TYPE_APPLICATION_CONFIGURATION (3)

#define ACTCTXCTB_ASSEMBLY_CONTEXT_ASSEMBLY_POLICY_APPLIED  (0x00000001)
#define ACTCTXCTB_ASSEMBLY_CONTEXT_ROOT_POLICY_APPLIED      (0x00000002)
#define ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY         (0x00000004)
#define ACTCTXCTB_ASSEMBLY_CONTEXT_IS_PRIVATE_ASSEMBLY      (0x00000008)
// in system-policy installation
#define ACTCTXCTB_ASSEMBLY_CONTEXT_IS_SYSTEM_POLICY_INSTALLATION    (0x00000010)

/*-----------------------------------------------------------------------------
This is the public ASSEMBLY that contributor callbacks see.
It is generated from the private ASSEMBLY struct.
-----------------------------------------------------------------------------*/
typedef struct _ACTCTXCTB_ASSEMBLY_CONTEXT {
    ULONG Flags;                    // Various indicators include what kind of policy was used etc.
    ULONG AssemblyRosterIndex;
    ULONG ManifestPathType;
    PCWSTR ManifestPath;            // not necessarily null terminated; respect ManifestPathCch!
    SIZE_T ManifestPathCch;
    ULONG PolicyPathType;
    PCWSTR PolicyPath;              // not necessarily null terminated; respect PolicyPathCch!
    SIZE_T PolicyPathCch;
    PCASSEMBLY_IDENTITY AssemblyIdentity;
    PVOID  TeeStreamForManifestInstall; // REVIEW hack/backdoor.. we might as well give the contributors the activation context
    PVOID  pcmWriterStream; // same comment as TeeStreamForManifestInstall
    PVOID  InstallationInfo; // ibid.
    PVOID  AssemblySecurityContext;
    PVOID  SecurityMetaData;
    const VOID *InstallReferenceData;

    PCWSTR TextuallyEncodedIdentity;    // always null terminated
    SIZE_T TextuallyEncodedIdentityCch;  // does not include trailing null character

    _ACTCTXCTB_ASSEMBLY_CONTEXT() 
        : AssemblyIdentity(NULL), 
          Flags(0),
          AssemblyRosterIndex(0),
          ManifestPathType(0),
          ManifestPathCch(0),
          ManifestPath(NULL),
          PolicyPathType(0),
          PolicyPath(NULL),
          PolicyPathCch(0),
          TeeStreamForManifestInstall(NULL),
          pcmWriterStream(NULL),
          InstallationInfo(NULL),
          InstallReferenceData(NULL),
          AssemblySecurityContext(NULL),
          TextuallyEncodedIdentity(NULL), 
          TextuallyEncodedIdentityCch(0),
          SecurityMetaData(NULL) { }
    ~_ACTCTXCTB_ASSEMBLY_CONTEXT()
    {
        if (AssemblyIdentity != NULL)
        {
            CSxsPreserveLastError ple;
            ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(AssemblyIdentity));
            AssemblyIdentity = NULL;
            ple.Restore();
        }
    }

} ACTCTXCTB_ASSEMBLY_CONTEXT, *PACTCTXCTB_ASSEMBLY_CONTEXT;
typedef const ACTCTXCTB_ASSEMBLY_CONTEXT *PCACTCTXCTB_ASSEMBLY_CONTEXT;

typedef struct _ACTCTXCTB_ERROR_CALLBACKS {
    SXS_REPORT_PARSE_ERROR_MISSING_REQUIRED_ATTRIBUTE_CALLBACK MissingRequiredAttribute;
    SXS_REPORT_PARSE_ERROR_ATTRIBUTE_NOT_ALLOWED AttributeNotAllowed;
    SXS_REPORT_PARSE_ERROR_INVALID_ATTRIBUTE_VALUE InvalidAttributeValue;
} ACTCTXCTB_ERROR_CALLBACK, *PACTCTXCTB_ERROR_CALLBACKS;

typedef const struct _ACTCTXCTB_ERROR_CALLBACKS *PCACTCTXCTB_ERROR_CALLBACKS;

typedef struct _ACTCTXCTB_PARSE_CONTEXT {
    PCWSTR ElementPath;     // passed to callback - null terminated but ElementPathCch is also valid
    SIZE_T ElementPathCch;  // passed to callback
    PCWSTR ElementName;
    SIZE_T ElementNameCch;
    ULONG ElementHash;      // passed to callback
    ULONG XMLElementDepth;  // passed to callback
    ULONG SourceFilePathType; // passed to callback
    PCWSTR SourceFile;      // passed to callback - null terminated
    SIZE_T SourceFileCch;   // passed to callback
    FILETIME SourceFileLastWriteTime; // passed to callback
    ULONG LineNumber;       // passed to callback
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;   // passed to callback
    ACTCTXCTB_ERROR_CALLBACK ErrorCallbacks;        // passed to callback
} ACTCTXCTB_PARSE_CONTEXT;

// Used with ACTCTXCTB_CBREASON_PARSEBEGINNING
typedef struct _ACTCTXCTB_CBPARSEBEGINNING {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    ULONG ParseType;                // passed to callback
    ULONG FileFlags;                // passed to callback
    ULONG FilePathType;
    PCWSTR FilePath;                // passed to callback
    SIZE_T FilePathCch;             // passed to callback
    FILETIME FileLastWriteTime;     // passed to callback
    ULONG FileFormatVersionMajor;     // passed to callback
    ULONG FileFormatVersionMinor;     // passed to callback
    ULONG MetadataSatelliteRosterIndex; // passed to callback
    BOOL NoMoreCallbacksThisFile;   // returned from callback
    BOOL Success;
} ACTCTXCTB_CBPARSEBEGINNING, *PACTCTXCTB_CBPARSEBEGINNING;

BOOL operator==(const FILETIME&, const FILETIME&);
BOOL operator!=(const FILETIME&, const FILETIME&);
BOOL operator==(const ACTCTXCTB_CBPARSEBEGINNING&, const ACTCTXCTB_CBPARSEBEGINNING&);

// Used with ACTCTXCTB_CBREASON_BEGINCHILDREN
typedef struct _ACTCTXCTB_CBBEGINCHILDREN {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    PCSXS_NODE_INFO NodeInfo;    // passed to callback
    BOOL Success;
} ACTCTXCTB_CBBEGINCHILDREN, *PACTCTXCTB_CBBEGINCHILDREN;

BOOL operator==(const ACTCTXCTB_CBBEGINCHILDREN&, const ACTCTXCTB_CBBEGINCHILDREN&);

// Used with ACTCTXCTB_CBREASON_ENDCHILDREN
typedef struct _ACTCTXCTB_CBENDCHILDREN {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    BOOL Empty;                 // passed to callback
    PCSXS_NODE_INFO NodeInfo;    // passed to callback
    BOOL Success;
} ACTCTXCTB_CBENDCHILDREN, *PACTCTXCTB_CBENDCHILDREN;

BOOL operator==(const ACTCTXCTB_CBENDCHILDREN&, const ACTCTXCTB_CBENDCHILDREN&);

// Used with ACTCTXCTB_CBREASON_IDENTITYDETERMINED
typedef struct _ACTCTXCTB_CBIDENTITYDETERMINED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    PCASSEMBLY_IDENTITY AssemblyIdentity;
    BOOL Success;
} ACTCTXCTB_CBIDENTITYDETERMINED, *PACTCTXCTB_CBIDENTITYDETERMINED;

typedef const ACTCTXCTB_CBIDENTITYDETERMINED *PCACTCTXCTB_CBIDENTITYDETERMINED;

BOOL operator==(const ACTCTXCTB_CBIDENTITYDETERMINED&, const ACTCTXCTB_CBIDENTITYDETERMINED&);

// Used with ACTCTXCTB_CBREASON_ELEMENTPARSED
typedef struct _ACTCTXCTB_CBELEMENTPARSED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    ULONG NodeCount;            // passed to callback
    PCSXS_NODE_INFO NodeInfo;   // passed to callback
    BOOL Success;
} ACTCTXCTB_CBELEMENTPARSED, *PACTCTXCTB_CBELEMENTPARSED;

typedef const ACTCTXCTB_CBELEMENTPARSED *PCACTCTXCTB_CBELEMENTPARSED;

BOOL operator==(const ACTCTXCTB_CBELEMENTPARSED&, const ACTCTXCTB_CBELEMENTPARSED&);

// Used with ACTCTXCTB_CBREASON_PCDATAPARSED
typedef struct _ACTCTXCTB_CBPCDATAPARSED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    const WCHAR *Text;
    ULONG TextCch;
    BOOL Success;
} ACTCTXCTB_CBPCDATAPARSED, *PACTCTXCTB_CBPCDATAPARSED;

typedef const ACTCTXCTB_CBPCDATAPARSED *PCACTCTXCTB_CBPCDATAPARSED;

BOOL operator==(const ACTCTXCTB_CBPCDATAPARSED&, const ACTCTXCTB_CBPCDATAPARSED&);

// Used with ACTCTXCTB_CBREASON_CDATAPARSED
typedef struct _ACTCTXCTB_CBCDATAPARSED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    const WCHAR *Text;
    ULONG TextCch;
    BOOL Success;
} ACTCTXCTB_CBCDATAPARSED, *PACTCTXCTB_CBCDATAPARSED;

typedef const ACTCTXCTB_CBCDATAPARSED *PCACTCTXCTB_CBCDATAPARSED;

BOOL operator==(const ACTCTXCTB_CBCDATAPARSED&, const ACTCTXCTB_CBCDATAPARSED&);

// Used with ACTCTXCTB_CBREASON_ALLPARSINGDONE
typedef struct _ACTCTXCTB_CBALLPARSINGDONE {
    ACTCTXCTB_CBHEADER Header;
    BOOL Success;
} ACTCTXCTB_CBALLPARSINGDONE, *PACTCTXCTB_CBALLPARSINGDONE;

BOOL operator==(const ACTCTXCTB_CBALLPARSINGDONE&, const ACTCTXCTB_CBALLPARSINGDONE&);

// Used with ACTCTXCTB_CBREASON_GETSECTIONSIZE
typedef struct _ACTCTXCTB_CBGETSECTIONSIZE {
    ACTCTXCTB_CBHEADER Header;
    SIZE_T SectionSize;          // filled in by callback
    BOOL Success;
} ACTCTXCTB_CBGETSECTIONSIZE, *PACTCTXCTB_CBGETSECTIONSIZE;

BOOL operator==(const ACTCTXCTB_CBGETSECTIONSIZE&, const ACTCTXCTB_CBGETSECTIONSIZE&);

// Used with ACTCTXCTB_CBREASON_GETSECTIONDATA
typedef struct _ACTCTXCTB_CBGETSECTIONDATA {
    ACTCTXCTB_CBHEADER Header;
    SIZE_T SectionSize;          // passed to callback
    PVOID SectionDataStart;     // passed to callback
    BOOL Success;
} ACTCTXCTB_CBGETSECTIONDATA, *PACTCTXCTB_CBGETSECTIONDATA;

BOOL operator==(const ACTCTXCTB_CBGETSECTIONDATA&, const ACTCTXCTB_CBGETSECTIONDATA&);

// Used with ACTCTXCTB_CBREASON_PARSEENDING
typedef struct _ACTCTXCTB_CBPARSEENDING {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    BOOL Success;
} ACTCTXCTB_CBPARSEENDING, *PACTCTXCTB_CBPARSEENDING;

BOOL operator==(const ACTCTXCTB_CBPARSEENDING&, const ACTCTXCTB_CBPARSEENDING&);

// Used with ACTCTXCTB_CBREASON_PARSEENDED
typedef struct _ACTCTXCTB_CBPARSEENDED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
} ACTCTXCTB_CBPARSEENDED, *PACTCTXCTB_CBPARSEENDED;

BOOL operator==(const ACTCTXCTB_CBPARSEENDED&, const ACTCTXCTB_CBPARSEENDED&);

// Used with ACTCTXCTB_CBREASON_ACTCTXGENENDING
typedef struct _ACTCTXCTB_CBACTCTXGENENDING {
    ACTCTXCTB_CBHEADER Header;
    BOOL Success;
} ACTCTXCTB_CBACTCTXGENENDING, *PACTCTXCTB_CBACTCTXGENENDING;

BOOL operator==(const ACTCTXCTB_CBACTCTXGENENDING&, const ACTCTXCTB_CBACTCTXGENENDING&);

// Used with ACTCTXCTB_CBREASON_ACTCTXGENENDED
typedef struct _ACTCTXCTB_CBACTCTXGENENDED {
    ACTCTXCTB_CBHEADER Header;
    BOOL Success;
} ACTCTXCTB_CBACTCTXGENENDED, *PACTCTXCTB_CBACTCTXGENENDED;

BOOL operator==(const ACTCTXCTB_CBACTCTXGENENDED&, const ACTCTXCTB_CBACTCTXGENENDED&);

// Used with ACTCTXCTB_CBREASON_UNINIT
typedef struct _ACTCTXCTB_CBUNINIT {
    ACTCTXCTB_CBHEADER Header;
    PVOID ContribContext;       // passed to callback
} ACTCTXCTB_CBUNINIT, *PACTCTXCTB_CBUNINIT;

BOOL operator==(const ACTCTXCTB_CBUNINIT&, const ACTCTXCTB_CBUNINIT&);

typedef union _ACTCTXCTB_CALLBACK_DATA {
    ACTCTXCTB_CBHEADER Header;
    ACTCTXCTB_CBINIT Init;
    ACTCTXCTB_CBACTCTXGENBEGINNING GenBeginning;
    ACTCTXCTB_CBPARSEBEGINNING ParseBeginning;
    ACTCTXCTB_CBBEGINCHILDREN BeginChildren;
    ACTCTXCTB_CBENDCHILDREN EndChildren;
    ACTCTXCTB_CBELEMENTPARSED ElementParsed;
    ACTCTXCTB_CBPCDATAPARSED PCDATAParsed;
    ACTCTXCTB_CBCDATAPARSED CDATAParsed;
    ACTCTXCTB_CBPARSEENDING ParseEnding;
    ACTCTXCTB_CBALLPARSINGDONE AllParsingDone;
    ACTCTXCTB_CBGETSECTIONSIZE GetSectionSize;
    ACTCTXCTB_CBGETSECTIONDATA GetSectionData;
    ACTCTXCTB_CBACTCTXGENENDING GenEnding;
    ACTCTXCTB_CBUNINIT Uninit;
    ACTCTXCTB_CBPARSEENDED ParseEnded;
} ACTCTXCTB_CALLBACK_DATA, *PACTCTXCTB_CALLBACK_DATA;
typedef const ACTCTXCTB_CALLBACK_DATA* PCACTCTXCTB_CALLBACK_DATA;

typedef VOID (WINAPI * ACTCTXCTB_CALLBACK_FUNCTION)(
    IN OUT PACTCTXCTB_CALLBACK_DATA Data
    );

#define ACTCTXCTB_MAX_PREFIX_LENGTH (32)

typedef struct _ACTCTXCTB
{
    friend BOOL SxspAddActCtxContributor(
        PCWSTR DllName,
        PCSTR Prefix,
        SIZE_T PrefixCch,
        const GUID *ExtensionGuid,
        ULONG SectionId,
        ULONG Format,
        PCWSTR ContributorName
        );

    friend BOOL SxspAddBuiltinActCtxContributor(
        IN ACTCTXCTB_CALLBACK_FUNCTION CallbackFunction,
        const GUID *ExtensionGuid,
        ULONG SectionId,
        ULONG Format,
        PCWSTR ContributorName
        );

    _ACTCTXCTB() :
        m_RefCount(0),
        m_Next(NULL),
        m_ExtensionGuid(GUID_NULL),
        m_SectionId(0),
        m_Format(ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN),
        m_ContributorContext(NULL),
        m_CallbackFunction(NULL),
        m_BuiltinContributor(false),
        m_IsExtendedSection(false),
        m_PrefixCch(0)
        {
        }

    const GUID *GetExtensionGuidPtr() const
    {
        if (m_IsExtendedSection)
            return &m_ExtensionGuid;
        return NULL;
    }

    void AddRef() { ::InterlockedIncrement(&m_RefCount); }
    void Release() { ULONG ulRefCount; ulRefCount = ::InterlockedDecrement(&m_RefCount); if (ulRefCount == 0) { FUSION_DELETE_SINGLETON(this); } }

    LONG m_RefCount;
    struct _ACTCTXCTB *m_Next;
    GUID m_ExtensionGuid;
    ULONG m_SectionId;
#if SXS_EXTENSIBLE_CONTRIBUTORS
    CDynamicLinkLibrary m_DllHandle;
#endif
    PVOID m_ContributorContext;
    ACTCTXCTB_CALLBACK_FUNCTION m_CallbackFunction;
    ULONG m_Format;
    bool m_BuiltinContributor;  // For built-in contributors who aren't called through the extensibility
                                // interface.  This currently includes the cache coherency section and
                                // the assembly metadata section.
    bool m_IsExtendedSection;
    CStringBuffer m_ContributorNameBuffer;
    CStringBuffer m_DllNameBuffer;
    CANSIStringBuffer m_PrefixBuffer;
    SIZE_T m_PrefixCch;

    ~_ACTCTXCTB() { ASSERT_NTC(m_RefCount == 0); }
    SMARTTYPEDEF(_ACTCTXCTB);

private:
    _ACTCTXCTB(const _ACTCTXCTB &);
    void operator =(const _ACTCTXCTB &);
} ACTCTXCTB, *PACTCTXCTB;


SMARTTYPE(_ACTCTXCTB);

/*-----------------------------------------------------------------------------
This is the private ASSEMBLY struct.
Contributor callbacks do not see this; they instead see
ASSEMBLY_CONTEXT which is very similar, but for example CStringBuffers
are replaced by .dll-boundary-crossing-politically-correct PCWSTR.
-----------------------------------------------------------------------------*/
typedef struct _ASSEMBLY
{
    _ASSEMBLY() : m_AssemblyRosterIndex(0), m_MetadataSatelliteRosterIndex(0), m_nRefs(1) { }

    CDequeLinkage m_Linkage;
    CProbedAssemblyInformation m_Information;
    BOOL m_Incorporated;
    ULONG m_ManifestVersionMajor;
    ULONG m_ManifestVersionMinor;
    ULONG m_AssemblyRosterIndex;
    ULONG m_MetadataSatelliteRosterIndex;

    void AddRef() { ::InterlockedIncrement(&m_nRefs); }
    void Release() { if (::InterlockedDecrement(&m_nRefs) == 0) { CSxsPreserveLastError ple; delete this; ple.Restore(); } }

    PCASSEMBLY_IDENTITY GetAssemblyIdentity() const { return m_Information.GetAssemblyIdentity(); };
    BOOL GetAssemblyName(PCWSTR *AssemblyName, SIZE_T *Cch) const { return m_Information.GetAssemblyName(AssemblyName, Cch); }
    BOOL GetManifestPath(PCWSTR *ManifestPath, SIZE_T *Cch) const { return m_Information.GetManifestPath(ManifestPath, Cch); }
    ULONG GetManifestPathType() const { return m_Information.GetManifestPathType(); }
    BOOL GetPolicyPath(PCWSTR &rManifestFilePath, SIZE_T &rCch) const { return m_Information.GetPolicyPath(rManifestFilePath, rCch); }
    ULONG GetPolicyPathType() const { return m_Information.GetPolicyPathType(); }
    const FILETIME &GetPolicyLastWriteTime() const { return m_Information.GetPolicyLastWriteTime(); }
    const FILETIME &GetManifestLastWriteTime() const { return m_Information.GetManifestLastWriteTime(); }


    BOOL IsRoot() const { return m_AssemblyRosterIndex == 1; }
    BOOL IsPrivateAssembly() const { return m_Information.IsPrivateAssembly(); }

private:
    ~_ASSEMBLY() { }

    LONG m_nRefs;

    _ASSEMBLY(const _ASSEMBLY &);
    void operator =(const _ASSEMBLY &);
} ASSEMBLY, *PASSEMBLY;
typedef const ASSEMBLY* PCASSEMBLY;

class CAssemblyTableHelper : public CCaseInsensitiveUnicodeStringPtrTableHelper<ASSEMBLY>
{
public:
    static BOOL InitializeValue(ASSEMBLY *vin, ASSEMBLY *&rvstored) { rvstored = vin; if (vin != NULL) vin->AddRef(); return TRUE; }
    static BOOL UpdateValue(ASSEMBLY *vin, ASSEMBLY *&rvstored) { if (vin != NULL) vin->AddRef(); if (rvstored != NULL) { rvstored->Release(); } rvstored = vin; return TRUE; }
    static VOID FinalizeValue(ASSEMBLY *&rvstored) { if (rvstored != NULL) { rvstored->Release(); rvstored = NULL; } }
};

extern CCriticalSectionNoConstructor g_ActCtxCtbListCritSec;

// The contributor list is a singly linked list
extern PACTCTXCTB g_ActCtxCtbListHead;
extern ULONG g_ActCtxCtbListCount;

BOOL
SxspCreateManifestFileNameFromTextualString(
    DWORD dwFlags,
    ULONG PathType,
    const CBaseStringBuffer &AssemblyDirectory,
    PCWSTR pwszTextualAssemblyIdentityString,
    CBaseStringBuffer &sbPathName
    );

BOOL
SxspGenerateActivationContext(
    PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters,
    CFileStream &SystemDefaultManifestFileStream
    );

BOOL
SxspInitActCtxContributors(
    );

VOID
SxspUninitActCtxContributors(
    VOID
    );

BOOL
SxspAddActCtxContributor(
    IN PCWSTR DllName,
    IN PCSTR Prefix OPTIONAL,
    IN SIZE_T PrefixCch OPTIONAL,
    IN const GUID *ExtensionGuid OPTIONAL,
    IN ULONG SectionId,
    IN ULONG Format,
    IN PCWSTR ContributorName
    );

BOOL
SxspAddBuiltinActCtxContributor(
    IN ACTCTXCTB_CALLBACK_FUNCTION CallbackFunction,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    ULONG Format,
    PCWSTR ContributorName
    );

BOOL
SxspPrepareContributor(
    PACTCTXCTB Contrib
    );

VOID
WINAPI
SxspAssemblyMetadataContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

VOID
WINAPI
SxspComProgIdRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

VOID
WINAPI
SxspComTypeLibRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

VOID
WINAPI
SxspComInterfaceRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
SxspGetXMLParser(
    REFIID riid,
    LPVOID *ppvObj
    );

#define SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_PARSE_ONLY                  (1)
#define SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_GENERATE_ACTIVATION_CONTEXT (2)
#define SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_INSTALL                     (3)

BOOL
SxspInitActCtxGenCtx(
    OUT PACTCTXGENCTX pActCtxGenCtx,
    IN ULONG ulOperation,
    IN DWORD dwFlags, // from ACTCTXCTB_* set
    IN DWORD dwOperationSpecificFlags,
    IN const CImpersonationData &ImpersonationData,
    IN USHORT ProcessorArchitecture,
    IN LANGID LangId,
    IN ULONG ApplicationDirectoryPathType,
    IN SIZE_T ApplicationDirectoryCch,
    IN PCWSTR ApplicationDirectory
    );

BOOL
SxspFireActCtxGenEnding(
    IN PACTCTXGENCTX pActCtxGenCtx
    );

BOOL
SxspAddRootManifestToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    PCSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    );

BOOL
SxspAddManifestToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    CProbedAssemblyInformation &ProbedInformation, // arbitrarily valueless on exit
    PASSEMBLY *AssemblyOut
    );

BOOL
SxspAddAssemblyToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    PCWSTR AssemblyName,
    PCASSEMBLY_VERSION Version
    );

BOOL
SxspEnqueueAssemblyReference(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY SourceAssembly,
    PCASSEMBLY_IDENTITY Identity,
    bool Optional,
    bool MetadataSatellite
    );

/*-----------------------------------------------------------------------------
given an assembly name and optional version, but no langid, or processor, and
its referring generation context, this function looks in the "assembly store"
(file system) for an assembly with that name that matches the generation
context, first by exact match, then some ordered weaker forms, like language
neutral, processor unknown, etc. If a match is found, some information
about it is returned. The out parameters are clobbered upon errors as well.
-----------------------------------------------------------------------------*/

#define SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL (0x00000001)
#define SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_SKIP_WORLDWIDE (0x00000002)


BOOL
SxspResolvePartialReference(
    DWORD Flags,
    PCASSEMBLY ParsingAssemblyContext,
    PACTCTXGENCTX pActCtxGenCtx,
    const CAssemblyReference &PartialReference,
    CProbedAssemblyInformation &ProbedAssemblyInformation,
    bool &rfFound
    );

BOOL
SxspCloseManifestGraph(
    PACTCTXGENCTX pActCtxGenCtx
    );

BOOL
SxspBuildActCtxData(
    PACTCTXGENCTX pActCtxGenCtx,
    PHANDLE SectionHandle
    );

BOOL
SxspGetAssemblyRootDirectoryHelper(
    IN SIZE_T CchBuffer,
    OUT WCHAR Buffer[],
    OUT SIZE_T *CchWritten OPTIONAL
    );

BOOL
SxspGetAssemblyRootDirectory(
    IN OUT CBaseStringBuffer &rRootDirectory
    );

BOOL 
SxspGetNDPGacRootDirectory(
    OUT CBaseStringBuffer &rRootDirectory
    );

// x86, Alpha, IA64, Data, Alpha64
#define MAXIMUM_PROCESSOR_ARCHITECTURE_NAME_LENGTH (sizeof("Alpha64")-1)

BOOL
SxspFormatGUID(
    IN const GUID &rGuid,
    IN OUT CBaseStringBuffer &rBuffer
    );

//
#define SXSP_PARSE_GUID_FLAG_FAIL_ON_INVALID (0x00000001)

BOOL
SxspParseGUID(
    IN PCWSTR pszGuid,
    IN SIZE_T cchGuid,
    OUT GUID &rGuid
    );

BOOL
SxspParseThreadingModel(
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT PULONG ThreadingModel
    );

BOOL
SxspFormatThreadingModel(
    IN ULONG ThreadingModel,
    IN OUT CBaseStringBuffer &Buffer
    );

BOOL
SxspParseUSHORT(
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT PUSHORT Value
    );

ULONG
SxspSetLastNTError(
    LONG Status
    );

/*-----------------------------------------------------------------------------
private above
public below
-----------------------------------------------------------------------------*/

extern "C"
{

typedef struct _STRING_SECTION_GENERATION_CONTEXT_ENTRY
{
    struct _STRING_SECTION_GENERATION_CONTEXT_ENTRY *Next;

    PCWSTR String;
    SIZE_T Cch;
    ULONG PseudoKey;
    PVOID DataContext;
    SIZE_T DataSize;
} STRING_SECTION_GENERATION_CONTEXT_ENTRY, *PSTRING_SECTION_GENERATION_CONTEXT_ENTRY;

#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE     (1)
#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA         (2)
#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED    (3)
#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE (4)
#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA     (5)

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE
{
    PVOID DataContext;  // DataContext passed in to SxsAddStringToStringSectionGenerationContext()
    SIZE_T DataSize;     // filled in by callback function
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE;

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA
{
    PVOID SectionHeader;
    PVOID DataContext;  // DataContext passed in to SxsAddStringToStringSectionGenerationContext()
    SIZE_T BufferSize;   // callback function may read but not modify
    PVOID Buffer;       // Callback function may not modify this pointer but may modify BufferSize
                        // bytes starting at this address
    SIZE_T BytesWritten; // Actual number of bytes written to buffer.  May not differ from DataSize
                        // returned from the _GETDATASIZE callback.
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA;

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED
{
    PVOID DataContext;  // DataContext passed in to SxsAddStringToStringSectionGenerationContext()
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED;

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE
{
    SIZE_T DataSize;     // filled in by callback function
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE;

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA
{
    PVOID SectionHeader;
    SIZE_T BufferSize;   // callback function may read but not modify
    PVOID Buffer;       // Callback function may not modify this pointer but may modify BufferSize
                        // bytes starting at this address
    SIZE_T BytesWritten; // Actual number of bytes written to buffer.  May not differ from DataSize
                        // returned from the _GETUSERDATASIZE callback.
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA;

typedef BOOL (WINAPI * STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION)(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

typedef struct _STRING_SECTION_GENERATION_CONTEXT *PSTRING_SECTION_GENERATION_CONTEXT;

BOOL
WINAPI
SxsQueryAssemblyInfo(
    DWORD dwFlags,
    PCWSTR pwzTextualAssembly,
    ASSEMBLY_INFO *pAsmInfo);

BOOL
WINAPI
SxsInitStringSectionGenerationContext(
    OUT PSTRING_SECTION_GENERATION_CONTEXT *SSGenContext,
    IN ULONG DataFormatVersion,
    IN BOOL CaseInSensitive,
    IN STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    IN LPVOID CallbackContext
    );

PVOID
WINAPI
SxsGetStringSectionGenerationContextCallbackContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    );

VOID
WINAPI
SxsDestroyStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    );

BOOL
WINAPI
SxsAddStringToStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN PCWSTR String,
    IN SIZE_T Cch,
    IN PVOID DataContext,
    IN ULONG AssemblyRosterIndex,
    IN DWORD DuplicateErrorCode // GetLastError() returns this if the GUID is a duplicate
    );

BOOL
WINAPI
SxsFindStringInStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT PVOID *DataContext,
    OUT BOOL *Found
    );

BOOL
WINAPI
SxsDoneModifyingStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    );

BOOL
WINAPI
SxsGetStringSectionGenerationContextSectionSize(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    OUT PSIZE_T DataSize
    );

BOOL
WINAPI
SxsGetStringSectionGenerationContextSectionData(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT PSIZE_T BytesWritten OPTIONAL
    );

typedef struct _GUID_SECTION_GENERATION_CONTEXT_ENTRY
{
    struct _GUID_SECTION_GENERATION_CONTEXT_ENTRY *Next;

    GUID Guid;
    PVOID DataContext;
    SIZE_T DataSize;
} GUID_SECTION_GENERATION_CONTEXT_ENTRY, *PGUID_SECTION_GENERATION_CONTEXT_ENTRY;

#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE (1)
#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA (2)
#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED (3)
#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE (4)
#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA (5)

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE
{
    PVOID DataContext;  // DataContext passed in to SxsAddStringToGuidSectionGenerationContext()
    SIZE_T DataSize;     // filled in by callback function
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE;

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA
{
    PVOID SectionHeader;
    PVOID DataContext;  // DataContext passed in to SxsAddStringToGuidSectionGenerationContext()
    SIZE_T BufferSize;   // callback function may read but not modify
    PVOID Buffer;       // Callback function may not modify this pointer but may modify BufferSize
                        // bytes starting at this address
    SIZE_T BytesWritten; // Actual number of bytes written to buffer.  May not differ from DataSize
                        // returned from the _GETDATASIZE callback.
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA;

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED
{
    PVOID DataContext;  // DataContext passed in to SxsAddStringToGuidSectionGenerationContext()
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED;

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE
{
    SIZE_T DataSize;     // filled in by callback function
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE;

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA
{
    PVOID SectionHeader;
    SIZE_T BufferSize;   // callback function may read but not modify
    PVOID Buffer;       // Callback function may not modify this pointer but may modify BufferSize
                        // bytes starting at this address
    SIZE_T BytesWritten; // Actual number of bytes written to buffer.  May not differ from DataSize
                        // returned from the _GETUSERDATASIZE callback.
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA;

typedef BOOL (WINAPI * GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION)(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

typedef struct _GUID_SECTION_GENERATION_CONTEXT *PGUID_SECTION_GENERATION_CONTEXT;

BOOL
WINAPI
SxsInitGuidSectionGenerationContext(
    OUT PGUID_SECTION_GENERATION_CONTEXT *SSGenContext,
    IN ULONG DataFormatVersion,
    IN GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    IN LPVOID CallbackContext
    );

PVOID
WINAPI
SxsGetGuidSectionGenerationContextCallbackContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext
    );

VOID
WINAPI
SxsDestroyGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext
    );

BOOL
WINAPI
SxsAddGuidToGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN const GUID *Guid,
    IN PVOID DataContext,
    IN ULONG AssemblyRosterIndex,
    IN DWORD DuplicateErrorCode // GetLastError() returns this if the GUID is a duplicate
    );

BOOL
WINAPI
SxsFindGuidInGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN const GUID *Guid,
    OUT PVOID *DataContext
    );

BOOL
WINAPI
SxsGetGuidSectionGenerationContextSectionSize(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    OUT PSIZE_T DataSize
    );

BOOL
WINAPI
SxsGetGuidSectionGenerationContextSectionData(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT PSIZE_T BytesWritten OPTIONAL
    );


#define SXS_COMMA_STRING L"&#x2c;"
#define SXS_QUOT_STRING  L"&#x22;"
#define SXS_FUSION_TO_MSI_ATTRIBUTE_VALUE_CONVERSION_COMMA  0
#define SXS_FUSION_TO_MSI_ATTRIBUTE_VALUE_CONVERSION_QUOT    1

BOOL
SxspCreateAssemblyIdentityFromTextualString(
    IN PCWSTR pszTextualAssemblyIdentityString,
    OUT PASSEMBLY_IDENTITY *ppAssemblyIdentity
    );


/*-----------------------------------------------------------------------------
side by side installation functions
-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
public above
private below
-----------------------------------------------------------------------------*/

typedef
BOOL
(__stdcall*
SXSP_DEBUG_FUNCTION)(
    ULONG iOperation,
    DWORD dwFlags,
    PCWSTR pszParameter1,
    PVOID pvParameter2);

#define SXSP_DEBUG_ORDINAL (1)

BOOL
__stdcall
SxspDebug(
    ULONG iOperation,
    DWORD dwFlags,
    PCWSTR pszParameter1,
    PVOID pvParameter2);

} // extern "C"

/*-----------------------------------------------------------------------------*/
BOOL
SxspGetFileAttributesW(
   PCWSTR lpFileName,
   DWORD &rdwFileAttributes
   );

BOOL
SxspGetFileAttributesW(
   PCWSTR lpFileName,
   DWORD &rdwFileAttributes,
   DWORD &rdwWin32Error,
   SIZE_T cExceptionalWin32Errors,
   ...
   );

BOOL
SxspDuplicateString(
    PCWSTR StringIn,
    SIZE_T cch,
    PWSTR *StringOut
    );

BOOL
SxspHashString(
    PCWSTR String,
    SIZE_T Cch,
    PULONG HashValue,
    bool CaseInsensitive
    );

ULONG
SxspGetHashAlgorithm(
    VOID
    );

BOOL
WINAPI
SxspAssemblyMetadataStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

VOID
WINAPI
SxspDllRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
WINAPI
SxspDllRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

VOID
WINAPI
SxspWindowClassRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
WINAPI
SxspWindowClassRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

VOID
WINAPI
SxspComClassRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
WINAPI
SxspComClassRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );


VOID
WINAPI
SxspClrInteropContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
WINAPI
SxspClrInteropGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );


BOOL
SxspVerifyPublicKeyAndStrongName(
    const WCHAR *pszPublicKey,
    SIZE_T CchPublicKey,
    const WCHAR *pszStrongName,
    SIZE_T CchStrongName,
    BOOL &fValid
    );

#define SXS_INSTALLATION_MOVE_FILE                 (0)
#define SXS_INSTALLATION_MOVE_DIRECTORY            (1)
#define SXS_INSTALLATION_MOVE_DIRECTORY_IF_EXIST_MOVE_FILES_AND_SUBDIR (2)

#define SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED    (0x00000001)
#define SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS                (0x00000002)
#define SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_PRIVATE_ASSEMBLIES              (0x00000004)

BOOL
SxspGenerateManifestPathForProbing(
    IN DWORD dwLocationIndex,
    IN DWORD dwFlags,
    IN PCWSTR AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCchIn OPTIONAL,
    IN ULONG ApplicationDirectoryPathType OPTIONAL,
    IN PCWSTR ApplicationDirectory OPTIONAL,
    IN SIZE_T ApplicationDirectoryCchIn OPTIONAL,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT CBaseStringBuffer &PathBuffer,
    BOOL *pfPrivateAssemblyFlag,
    bool &rfDone
    );

#define SXSP_GENERATE_SXS_PATH_PATHTYPE_INVALID         (0)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST        (1)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY        (2)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY          (3)

#define SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT       (0x00000001)
#define SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH    (0x00000002)
#define SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION    (0x00000004)

BOOL
SxspGenerateSxsPath(
    IN DWORD Flags,
    IN ULONG PathType,
    IN PCWSTR AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch OPTIONAL,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    OUT CBaseStringBuffer &PathBuffer
    );

//
//  I tried to roll this into SxspGenerateSxsPath but the logic was
//  way too convoluted. -mgrier 11/29/2001
//
BOOL
SxspGenerateNdpGACPath(
    IN DWORD dwFlags,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    OUT CBaseStringBuffer &rPathBuffer
    );

//
//  Note that SxspGetAttributeValue() does not fail if the
//  attribute is not found; *Found is set to TRUE/FALSE based on whether
//  the attribute is found.
//

typedef struct _ATTRIBUTE_NAME_DESCRIPTOR
{
    PCWSTR Namespace;
    SIZE_T NamespaceCch;
    PCWSTR Name;
    SIZE_T NameCch;
} ATTRIBUTE_NAME_DESCRIPTOR, *PATTRIBUTE_NAME_DESCRIPTOR;

#define DECLARE_ATTRIBUTE_NAME_DESCRIPTOR(_AttributeNamespace, _AttributeName) \
static const WCHAR __AttributeName_ ## _AttributeName [] = L ## #_AttributeName; \
static const ATTRIBUTE_NAME_DESCRIPTOR s_AttributeName_ ## _AttributeName = { _AttributeNamespace, sizeof(_AttributeNamespace) / sizeof(_AttributeNamespace[0]) - 1, __AttributeName_ ## _AttributeName, sizeof(#_AttributeName) / sizeof(#_AttributeName [0]) - 1 }

#define DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(_AttributeName) \
static const WCHAR __AttributeName_ ## _AttributeName [] = L ## #_AttributeName; \
static const ATTRIBUTE_NAME_DESCRIPTOR s_AttributeName_ ## _AttributeName = { NULL, 0, __AttributeName_ ## _AttributeName, sizeof(#_AttributeName) / sizeof(#_AttributeName [0]) - 1 }

//
//  For those writing validation routines:
//
//  Only if the validation routine fails because of environmental conditions
//  (e.g. it is not able to validate it rather than the validation fails)
//  should it return false.
//
//  If the validation fails, you should return a Win32 error code in the
//  *pdwValidationStatus value.  If you're at a loss for the error code
//  to use, when in doubt use ERROR_SXS_MANIFEST_PARSE_ERROR.  Any other
//  code is reported in log files and the error log but is translated
//  into ERROR_SXS_MANIFEST_PARSE_ERROR in higher layers anyways.
//

typedef BOOL (*SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE)(
    IN DWORD ValidationFlags,
    IN const CBaseStringBuffer &rBuffer,
    OUT bool &rfValid,
    IN SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    OUT SIZE_T &OutputBytesWritten
    );

//
//  If the ValidationRoutine is omitted, no validation is done on the string
//  and OutputBufferSize must be sizeof(CStringBuffer) and OutputBuffer must
//  point to a constructed CStringBuffer instance.
//

#define SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE (0x00000001)

BOOL
SxspGetAttributeValue(
    IN DWORD dwFlags,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName,
    IN PCSXS_NODE_INFO NodeInfo,
    IN SIZE_T NodeCount,
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    OUT bool &rfFound,
    IN SIZE_T OutputBufferSize,
    OUT PVOID OutputBuffer,
    OUT SIZE_T &OutputBytesWritten,
    IN SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE ValidationRoutine OPTIONAL,
    IN DWORD ValidationRoutineFlags OPTIONAL
    );

BOOL
SxspGetAttributeValue(
    IN DWORD dwFlags,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName,
    IN PCACTCTXCTB_CBELEMENTPARSED ElementParsed,
    OUT bool &rfFound,
    IN SIZE_T OutputBufferSize,
    OUT PVOID OutputBuffer,
    OUT SIZE_T &OutputBytesWritten,
    IN SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE ValidationRoutine OPTIONAL,
    IN DWORD ValidationRoutineFlags OPTIONAL
    );

BOOL
SxspValidateBoolAttribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

BOOL
SxspValidateUnsigned64Attribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

BOOL
SxspValidateGuidAttribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

#define SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED (0x00000001)

BOOL
SxspValidateProcessorArchitectureAttribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

#define SXSP_VALIDATE_LANGUAGE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED (0x00000001)

BOOL
SxspValidateLanguageAttribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

VOID
SxspDbgPrintActivationContextData(
    ULONG Level,
    PCACTIVATION_CONTEXT_DATA Data,
    CBaseStringBuffer &rbuffPerLinePrefix
    );

BOOL
SxspFormatFileTime(
    LARGE_INTEGER ft,
    CBaseStringBuffer &rBuffer
    );

BOOL
SxspIsRightXMLTag(
    PACTCTXCTB_CBELEMENTPARSED CBData,
    ULONG ExpectedDepth,
    PCWSTR ParentTagPath,
    PCWSTR ChildTag
    );

BOOL
SxspFindLastSegmentOfAssemblyName(
    IN PCWSTR AssemblyName,
    IN SIZE_T AssemblyNameCch OPTIONAL,
    OUT PCWSTR *LastSegment,
    OUT SIZE_T *LastSegmentCch
    );

typedef struct _ELEMENT_PATH_MAP_ENTRY {
    ULONG ElementDepth;
    PCWSTR ElementPath;
    SIZE_T ElementPathCch;
    ULONG MappedValue;
} ELEMENT_PATH_MAP_ENTRY, *PELEMENT_PATH_MAP_ENTRY;

typedef const ELEMENT_PATH_MAP_ENTRY *PCELEMENT_PATH_MAP_ENTRY;

BOOL
SxspProcessElementPathMap(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    PCELEMENT_PATH_MAP_ENTRY MapEntries,
    SIZE_T MapEntryCount,
    ULONG &MappedValue,
    bool &Found
    );

HRESULT
SxspLogLastParseError(
    IXMLNodeSource *pSource,
    PCACTCTXCTB_PARSE_CONTEXT pParseContext
    );

// Merge this with util\io.cpp\FusionpCreateDirectories.
BOOL
SxspCreateMultiLevelDirectory(
    PCWSTR CurrentDirectory,
    PCWSTR pwszNewDirs
    );

#define SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED    (0x00000001)
#define SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED (0x00000008)

BOOL
SxspValidateIdentity(
    DWORD Flags,
    ULONG Type,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    );

typedef enum _SXS_DEBUG_OPERATION
{
    SXS_DEBUG_XML_PARSER,
    SXS_DEBUG_CREAT_MULTILEVEL_DIRECTORY,
    SXS_DEBUG_PROBE_MANIFST,
    SXS_DEBUG_CHECK_MANIFEST_SCHEMA,
    SXS_DEBUG_SET_ASSEMBLY_STORE_ROOT,
    SXS_DEBUG_PRECOMPILED_MANIFEST,
    SXS_DEBUG_TIME_PCM,
    SXS_DEBUG_FORCE_LEAK,
    SXS_DEBUG_PROBE_ASSEMBLY,
    SXS_DEBUG_DLL_REDIRECTION,
    SXS_DEBUG_FUSION_ARRAY,
    SXS_DEBUG_FOLDERNAME_FROM_ASSEMBLYIDENTITY_GENERATION,
    SXS_DEBUG_ASSEMBLYNAME_CONVERSION,
    SXS_DEBUG_DIRECTORY_WATCHER,
    SXS_DEBUG_SFC_SCANNER,
    SXS_DEBUG_GET_STRONGNAME,
    SXS_DEBUG_FUSION_REPARSEPOINT,
    SXS_DEBUG_ASSEMBLY_IDENTITY_HASH,
    SXS_DEBUG_CATALOG_SIGNER_CHECK,
    SXS_DEBUG_SYSTEM_DEFAULT_ACTCTX_GENERATION,
    SXS_DEBUG_SFC_UI_TEST,
    SXS_DEBUG_EXIT_PROCESS,
    SXS_DEBUG_TERMINATE_PROCESS
} SXS_DEBUG_OPERATION;

/*-----------------------------------------------------------------------------
FALSE / GetLastError upon error
will use GetFileAttributesEx instead of FindFirstFile when available
-----------------------------------------------------------------------------*/
#define SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE (0x00000001)
#define SXSP_GET_FILE_SIZE_FLAG_GET_COMPRESSED_SOURCE_SIZE (0x00000002)

BOOL
SxspGetFileSize(
    DWORD dwFlags,
    PCWSTR pszFileName,
    ULONGLONG &rullSize
    );

#define SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE (0x00000001)
#define SXSP_DOES_FILE_EXIST_INCLUDE_NETWORK_ERRORS (0x00000002)

BOOL
SxspDoesFileExist(
    DWORD dwFlags,
    PCWSTR pszFileName,
    bool &rfExists
    );

BOOL
SxspInitAssembly(
    PASSEMBLY Asm,
    CProbedAssemblyInformation &AssemblyInformation
    );

/*-----------------------------------------------------------------------------
These let you avoid casting.
-----------------------------------------------------------------------------*/
 LONG SxspInterlockedIncrement(LONG*);
ULONG SxspInterlockedIncrement(ULONG*);
 LONG SxspInterlockedDecrement(LONG*);
ULONG SxspInterlockedDecrement(ULONG*);
 LONG SxspInterlockedExchange(LONG*, LONG);
ULONG SxspInterlockedExchange(ULONG*, ULONG);
 LONG SxspInterlockedCompareExchange(LONG*, LONG, LONG);
ULONG SxspInterlockedCompareExchange(ULONG*, ULONG, ULONG);
 LONG SxspInterlockedExchangeAdd(LONG*, LONG, LONG);
ULONG SxspInterlockedExchangeAdd(ULONG*, ULONG, ULONG);

/*
#if defined(_WIN64)
unsigned __int64 SxspInterlockedExchange(unsigned __int64* pi, unsigned __int64 x);
unsigned __int64 SxspInterlockedCompareExchange(unsigned __int64* pi, unsigned __int64 x, unsigned __int64 y);
#endif
*/

template <typename T> T* SxspInterlockedExchange(T** pp, T* p1);
template <typename T> T* SxspInterlockedCompareExchange(T** pp, T* p1, T* p2);

BOOL
SxspIncorporateAssembly(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm
    );

/*-----------------------------------------------------------------------------
impersonate in constructor, unimpersonate in destructor, but we use
explicit unimpersonation in order to progagate its error
-----------------------------------------------------------------------------*/

class CImpersonate
{
public:
    CImpersonate(const CImpersonationData &ImpersonationData) : m_ImpersonationData(ImpersonationData), m_Impersonating(FALSE) { }
    ~CImpersonate()
    {
        if (m_Impersonating)
        {
            CSxsPreserveLastError ple;

            //
            // removed SOFT_VERIFY2 because
            // 1) this line has never been seen to fail
            // 2) SOFT_VERIFY2 or somesuch seemed to cause problems in the past
            //
            m_ImpersonationData.Call(CImpersonationData::eCallTypeUnimpersonate);

            ple.Restore();
        }
    }

    BOOL Impersonate()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        INTERNAL_ERROR_CHECK(!m_Impersonating);
        IFW32FALSE_EXIT(m_ImpersonationData.Call(CImpersonationData::eCallTypeImpersonate));
        m_Impersonating = TRUE;
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    enum UnimpersonateWhenNotImpersonatingBehavior
    {
        eUnimpersonateFailsIfNotImpersonating,
        eUnimpersonateSucceedsIfNotImpersonating
    };

    BOOL Unimpersonate(UnimpersonateWhenNotImpersonatingBehavior e = eUnimpersonateFailsIfNotImpersonating)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        PARAMETER_CHECK((e == eUnimpersonateFailsIfNotImpersonating) || (e == eUnimpersonateSucceedsIfNotImpersonating));

        if (e == eUnimpersonateFailsIfNotImpersonating)
            INTERNAL_ERROR_CHECK(m_Impersonating);

        if (m_Impersonating)
        {
            m_Impersonating = FALSE;
            IFW32FALSE_EXIT(m_ImpersonationData.Call(CImpersonationData::eCallTypeUnimpersonate));
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

private:
    CImpersonationData m_ImpersonationData;
    BOOL m_Impersonating;
};

/*-----------------------------------------------------------------------------
deletes recursively, including readonly files, continues after errors,
but returns if there were any
-----------------------------------------------------------------------------*/

BOOL
SxspDeleteDirectory(
    const CBaseStringBuffer &rdir
    );

#define SXSP_MOVE_FILE_FLAG_COMPRESSION_AWARE 1

BOOL
SxspMoveFilesUnderDir(
    DWORD dwFlags,
    CStringBuffer & sbSourceDir, 
    CStringBuffer & sbDestDir, 
    DWORD dwMoveFileFlags
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

typedef enum _SXSP_LUID_TYPE
{
    esxspLuid,
    esxspGuid
} SXS_LUID_TYPE;

typedef struct _SXSP_LOCALLY_UNIQUE_ID
{
    SXS_LUID_TYPE Type;
    union
    {
        LUID Luid;
        GUID Guid;
    };
} SXSP_LOCALLY_UNIQUE_ID, *PSXSP_LOCALLY_UNIQUE_ID;
typedef const SXSP_LOCALLY_UNIQUE_ID* PCSXSP_LOCALLY_UNIQUE_ID;

BOOL
SxspCreateLocallyUniqueId(
    OUT PSXSP_LOCALLY_UNIQUE_ID
    );

BOOL
SxspFormatLocallyUniqueId(
    IN const SXSP_LOCALLY_UNIQUE_ID &rluid,
    OUT CBaseStringBuffer &rBuffer
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

VOID
SxspInitializeSListHead(
    IN PSLIST_HEADER ListHead
    );

PSINGLE_LIST_ENTRY
SxspInterlockedPopEntrySList(
    IN PSLIST_HEADER ListHead
    );

PSINGLE_LIST_ENTRY
SxspPopEntrySList(
    IN PSLIST_HEADER ListHead
    );

PSINGLE_LIST_ENTRY
SxspInterlockedPushEntrySList(
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

class __declspec(align(16)) CAlignedSingleListEntry : public SINGLE_LIST_ENTRY { };

class CCleanupBase : public CAlignedSingleListEntry
{
public:
    CCleanupBase() : m_fInAtExitList(false) { }

    virtual VOID DeleteYourself() = 0;

    bool m_fInAtExitList;

protected:
    virtual ~CCleanupBase() = 0 { }

};

BOOL
SxspAtExit(
    CCleanupBase* pCleanup
    );

BOOL
SxspTryCancelAtExit(
    CCleanupBase* pCleanup
    );

BOOL 
SxspInstallDecompressOrCopyFileW(    
    PCWSTR lpSource, 
    PCWSTR lpDest, 
    BOOL bFailIfExists);

BOOL
SxspInstallMoveFileExW(
    CBaseStringBuffer &moveOrigination,
    CBaseStringBuffer &moveDestination,
    DWORD             dwFlags,
    BOOL              fAwareNonCompressed = FALSE
    );

BOOL SxspInstallDecompressAndMoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags,
    BOOL fAwareNonCompressed = FALSE
    );

/*-----------------------------------------------------------------------------
create a unique temp directory under %windir%\WinSxs
-----------------------------------------------------------------------------*/
BOOL
SxspCreateWinSxsTempDirectory(
    OUT CBaseStringBuffer &rbuffTemp,
    OUT SIZE_T * pcch OPTIONAL = NULL,
    OUT CBaseStringBuffer *pBuffUniquePart OPTIONAL = NULL, // good to pass to CRunOnceDeleteDirectory::Initialize
    OUT SIZE_T * pcchUniquePart OPTIONAL = NULL
    );

#define SXSP_CREATE_ASSEMBLY_IDENTITY_FROM_IDENTITY_TAG_FLAG_VERIFY_PUBLIC_KEY_IF_PRESENT (0x00000001)

BOOL
SxspCreateAssemblyIdentityFromIdentityElement(
    DWORD Flags,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    DWORD cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    );

/*-----------------------------------------------------------------------------
this must be heap allocated
the C-api enforces that
-----------------------------------------------------------------------------*/

class CRunOnceDeleteDirectory : public CCleanupBase
{
public:
    CRunOnceDeleteDirectory() { }

    BOOL
    Initialize(
        IN const CBaseStringBuffer &rbuffDirectoryToDelete,
        IN const CBaseStringBuffer *pstrUniqueKey OPTIONAL = NULL
        );

    BOOL Cancel();

    // very unusual.. this is noncrashing, but
    // leaves the stuff in the registry
    BOOL Close();

    VOID DeleteYourself() { FUSION_DELETE_SINGLETON(this); }

    ~CRunOnceDeleteDirectory();
protected:

    CFusionRegKey       m_hKey;
    CStringBuffer   m_strValueName;

private:
    CRunOnceDeleteDirectory(const CRunOnceDeleteDirectory &);
    void operator =(const CRunOnceDeleteDirectory &);
};

/*-----------------------------------------------------------------------------
C-like API over the above
-----------------------------------------------------------------------------*/

BOOL
SxspCreateRunOnceDeleteDirectory(
    IN const CBaseStringBuffer &rbuffDirectoryToDelete,
    IN const CBaseStringBuffer *pbuffUniqueKey OPTIONAL,
    OUT PVOID* cookie
    );

BOOL
SxspCancelRunOnceDeleteDirectory(
    PVOID cookie
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

USHORT
SxspGetSystemProcessorArchitecture();

/*-----------------------------------------------------------------------------*/

RTL_PATH_TYPE
SxspDetermineDosPathNameType(
    PCWSTR DosFileName
    );

/*-----------------------------------------------------------------------------*/

interface IAssemblyName;

typedef
HRESULT
(STDAPICALLTYPE*
PFNCreateAssemblyNameObject)(
    OUT IAssemblyName** ppAssemblyName,
    IN LPCOLESTR        szAssemblyName,
    IN DWORD            dwFlags,
    LPVOID              pvReserved
    );

typedef HRESULT (WINAPI * PFNCreateAssemblyCache)(
    OUT IAssemblyCache **ppAsmCache,
    IN  DWORD dwReserved
    );

typedef HRESULT (WINAPI * PFNCreateAssemblyCacheItem)(
    OUT IAssemblyCacheItem** ppAsmItem,
    IN  IAssemblyName *pName,
    IN  PCWSTR pwzCodebase,
    IN  FILETIME *pftLastMod,
    IN  DWORD dwInstaller,
    IN  DWORD dwReserved
    );

/*-----------------------------------------------------------------------------*/

//
//  Private APIs used by OLEAUT32 to invoke isolation:
//

EXTERN_C HRESULT STDAPICALLTYPE SxsOleAut32MapReferenceClsidToConfiguredClsid(
    REFCLSID rclsidIn,
    CLSID *pclsidOut
    );

EXTERN_C HRESULT STDAPICALLTYPE SxsOleAut32RedirectTypeLibrary(
    LPCOLESTR szGuid,
    WORD wMaj,
    WORD wMin,
    LCID lcid,
    BOOL fHighest,
    SIZE_T *pcchFileName,
    LPOLESTR rgFileName
    );

/*-----------------------------------------------------------------------------*/

BOOL
SxspDoesPathCrossReparsePointVa(
    PCWSTR BasePath,
    SIZE_T cchBasePath,
    PCWSTR Path,
    SIZE_T  cchPath,
    BOOL &CrossesReparsePoint,
    DWORD &dwLastError,
    SIZE_T cOkErrors,
    va_list vaOkErrors
    );
    


inline BOOL
SxspDoesPathCrossReparsePoint(
    PCWSTR BasePath,
    SIZE_T cchBasePath,
    PCWSTR Path,
    SIZE_T  cchPath,
    BOOL &CrossesReparsePoint,
    DWORD &dwLastError,
    SIZE_T cOkErrors,
    ...
    )
{
    va_list va;
    va_start(va, cOkErrors);
    return SxspDoesPathCrossReparsePointVa(BasePath, cchBasePath, Path, cchPath, CrossesReparsePoint, dwLastError, cOkErrors, va);
}


inline BOOL
SxspDoesPathCrossReparsePoint(
    PCWSTR BasePath,
    SIZE_T cchBasePath,
    PCWSTR Path,
    SIZE_T  cchPath,
    BOOL &CrossesReparsePoint
    )
{
    DWORD dwError;
    return SxspDoesPathCrossReparsePoint(BasePath, cchBasePath, Path, cchPath, CrossesReparsePoint, dwError, 0);
}

inline BOOL
SxspDoesPathCrossReparsePoint(
    PCWSTR  Path,
    SIZE_T  Start,
    BOOL &CrossesReparsePoint
    )
{
    const SIZE_T PathLength = StringLength(Path);
    return SxspDoesPathCrossReparsePoint(
        Path,
        PathLength,
        Path + Start,
        PathLength - Start,
        CrossesReparsePoint);
}


/*-----------------------------------------------------------------------------
inline implementations
-----------------------------------------------------------------------------*/

#include "SxsNtRtl.inl"

inline USHORT
SxspGetSystemProcessorArchitecture()
{
    SYSTEM_INFO systemInfo;
    systemInfo.wProcessorArchitecture = DEFAULT_ARCHITECTURE;

    GetSystemInfo(&systemInfo);

    return systemInfo.wProcessorArchitecture;
}

#define SXS_REALLY_PRIVATE_INTERLOCKED1(SxsFunction, Win32Function, SxsT, Win32T) \
    inline SxsT Sxsp##SxsFunction(SxsT* p) { return (SxsT)Win32Function((Win32T*)p); }
#define SXS_REALLY_PRIVATE_INTERLOCKED2(SxsFunction, Win32Function, SxsT, Win32T) \
    inline SxsT Sxsp##SxsFunction(SxsT* p, SxsT x) { return (SxsT)Win32Function((Win32T*)p, (Win32T)x); }
#define SXS_REALLY_PRIVATE_INTERLOCKED3(SxsFunction, Win32Function, SxsT, Win32T) \
    inline SxsT Sxsp##SxsFunction(SxsT* p, SxsT x, SxsT y) { return (SxsT)Win32Function((Win32T*)p, (Win32T)x, (Win32T)y); }

SXS_REALLY_PRIVATE_INTERLOCKED1(InterlockedIncrement, InterlockedIncrement, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED1(InterlockedIncrement, InterlockedIncrement, ULONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED1(InterlockedDecrement, InterlockedDecrement, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED1(InterlockedDecrement, InterlockedDecrement, ULONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchange, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchange, ULONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchange, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchange, ULONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchangeAdd, InterlockedExchangeAdd, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchangeAdd, InterlockedExchangeAdd, ULONG, LONG)

#if defined(_WIN64)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchangePointer, __int64, PVOID)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchangePointer, unsigned __int64, PVOID)
SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchangePointer, __int64, PVOID)
SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchangePointer, unsigned __int64, PVOID)
#endif

template <typename U> SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchangePointer, U*, PVOID)
template <typename U> SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchangePointer, U*, PVOID)

#undef SXS_REALLY_PRIVATE_INTERLOCKED1
#undef SXS_REALLY_PRIVATE_INTERLOCKED2
#undef SXS_REALLY_PRIVATE_INTERLOCKED3

inline BOOL operator==(const FILETIME& ft1, const FILETIME& ft2)
{
    BOOL fResult = (
        ft1.dwLowDateTime == ft2.dwLowDateTime
        && ft1.dwHighDateTime == ft2.dwHighDateTime);
    return fResult;
}

inline BOOL operator!=(const FILETIME& ft1, const FILETIME& ft2)
{
    return !(ft1 == ft2);
}

inline BOOL operator==(const FILETIME& ft, __int64 i)
{
    LARGE_INTEGER lift;
    LARGE_INTEGER lii;

    lii.QuadPart = i;
    lift.LowPart = ft.dwLowDateTime;
    lift.HighPart = ft.dwHighDateTime;

    return (lii.QuadPart == lift.QuadPart);
}

inline BOOL operator!=(const FILETIME& ft, __int64 i)
{
    return !(ft == i);
}

//
// Some helpful strings, centralized
//
#define FILE_EXTENSION_CATALOG          ( L"cat" )
#define FILE_EXTENSION_CATALOG_CCH      ( NUMBER_OF( FILE_EXTENSION_CATALOG ) - 1 )
#define FILE_EXTENSION_MANIFEST         ( L"manifest" )
#define FILE_EXTENSION_MANIFEST_CCH     ( NUMBER_OF( FILE_EXTENSION_MANIFEST ) - 1 )
#define FILE_EXTENSION_MAN              ( L"man" )
#define FILE_EXTENSION_MAN_CCH          ( NUMBER_OF( FILE_EXTENSION_MAN ) - 1 )

int  SxspHexDigitToValue(WCHAR wch);
bool SxspIsHexDigit(WCHAR wch);

BOOL
SxspExpandRelativePathToFull(
    IN PCWSTR wszString,
    IN SIZE_T cchString,
    OUT CBaseStringBuffer &rbuffDestination
    );

BOOL
SxspParseComponentPolicy(
    DWORD Flags,
    PACTCTXGENCTX pActCtxGenCtx,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement
    );

BOOL
SxspParseApplicationPolicy(
    DWORD Flags,
    PACTCTXGENCTX pActCtxGenCtx,
    ULONG ulPolicyPathType,
    PCWSTR pszPolicyPath,
    SIZE_T cchPolicyPath,
    IStream *pIStream
    );

BOOL
SxspParseNdpGacComponentPolicy(
    ULONG Flags,
    PACTCTXGENCTX pGenContext,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement
    );

#define POLICY_PATH_FLAG_POLICY_IDENTITY_TEXTUAL_FORMAT     0 
#define POLICY_PATH_FLAG_FULL_QUALIFIED_POLICIES_DIR        1
#define POLICY_PATH_FLAG_FULL_QUALIFIED_POLICY_FILE_NAME    2


//
// Generate the shortened name version of this path string
//
BOOL
SxspGetShortPathName(
    IN const CBaseStringBuffer &rcbuffLongPathName,
    OUT CBaseStringBuffer &rbuffShortenedVersion
    );

BOOL
SxspGetShortPathName(
    IN const CBaseStringBuffer &rcbuffLongPathName,
    OUT CBaseStringBuffer &rbuffShortenedVersion,
    DWORD &rdwWin32Error,
    SIZE_T cExceptionalWin32Errors,
    ...
    );

BOOL 
SxspLoadString( 
    HINSTANCE hSource, 
    UINT uiStringIdent, 
    OUT CBaseStringBuffer &rbuffOutput 
    );

BOOL
SxspFormatString( 
    DWORD dwFlags, 
    LPCVOID pvSource, 
    DWORD dwId, 
    DWORD dwLangId, 
    OUT CBaseStringBuffer &rbuffOutput, 
    va_list* pvalArguments 
    );

BOOL
SxspSaveAssemblyRegistryData(
    DWORD Flags,
    IN PCASSEMBLY_IDENTITY pcAssemblyIdentity
    );

#define FILE_OR_PATH_NOT_FOUND(x) (((x) == ERROR_FILE_NOT_FOUND) || ((x) == ERROR_PATH_NOT_FOUND))


class CTokenPrivilegeAdjuster
{
    bool m_fAdjusted;
    CFusionArray<LUID> m_Privileges;
    CFusionArray<BYTE> m_PreviousPrivileges;
    DWORD m_dwReturnedSize;

    CTokenPrivilegeAdjuster(const CTokenPrivilegeAdjuster&);
    CTokenPrivilegeAdjuster& operator=(const CTokenPrivilegeAdjuster&);
    
public:
    CTokenPrivilegeAdjuster() : m_fAdjusted(false) {}
    ~CTokenPrivilegeAdjuster() { if ( m_fAdjusted ) { this->DisablePrivileges(); } }

    BOOL AddPrivilege(
        const PCWSTR PrivilegeName
        )
    {
        FN_PROLOG_WIN32
        LUID PrivLuid;

        INTERNAL_ERROR_CHECK(!m_fAdjusted);
        
        IFW32FALSE_EXIT(LookupPrivilegeValueW( NULL, PrivilegeName, &PrivLuid ));
        IFW32FALSE_EXIT(this->m_Privileges.Win32Append( PrivLuid ));
        
        FN_EPILOG
    }
    
    BOOL Initialize() {
        FN_PROLOG_WIN32
        IFW32FALSE_EXIT(this->m_Privileges.Win32Initialize());
        IFW32FALSE_EXIT(this->m_PreviousPrivileges.Win32Initialize());
        FN_EPILOG
    }

    BOOL EnablePrivileges();
    BOOL DisablePrivileges();
};

#define PRIVATIZE_COPY_CONSTRUCTORS( obj ) obj( const obj& ); obj& operator=(const obj&);

BOOL
SxspGenerateAssemblyNameInRegistry(
    IN PCASSEMBLY_IDENTITY pcAsmIdent,
    OUT CBaseStringBuffer &rbuffRegistryName
    );

BOOL
SxspGenerateAssemblyNameInRegistry(
    IN const CBaseStringBuffer &rcbuffTextualString,
    OUT CBaseStringBuffer &rbuffRegistryName
    );

BOOL
SxspGetRemoteUniversalName(
    IN PCWSTR pcszPathName,
    OUT CBaseStringBuffer &rbuffUniversalName
    );

#define SXS_GET_VOLUME_PATH_NAME_NO_FULLPATH    (0x00000001)

BOOL
SxspGetVolumePathName(
    IN DWORD dwFlags,
    IN PCWSTR pcwszVolumePath,
    OUT CBaseStringBuffer &buffVolumePathName
    );

BOOL
SxspGetFullPathName(
    IN  PCWSTR pcwszPathName,
    OUT CBaseStringBuffer &rbuffPathName,
    OUT CBaseStringBuffer *pbuffFilePart = NULL
    );

BOOL
SxspGetVolumeNameForVolumeMountPoint(
    IN PCWSTR pcwsMountPoint,
    OUT CBaseStringBuffer &rbuffMountPoint
    );

BOOL
SxspExpandEnvironmentStrings(
    IN PCWSTR pcwszSource,
    OUT CBaseStringBuffer &buffTarget
    );

BOOL
SxspDoesMSIStillNeedAssembly(
    IN  PCWSTR pcAsmName,
    OUT BOOL &rfNeedsAssembly
    );

    
#endif // !defined(_FUSION_DLL_WHISTLER_SXSP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsprobe.cpp ===
#include "stdinc.h"
#include "windows.h"
#include "stdlib.h"
#include "sxsp.h"
#include "util.h"
#include "FusionHandle.h"
#include "fusionhash.h"
#include "comdef.h"
#pragma warning(error: 4244)

#define ASMPROBE_DOT		(L".")
#define ASMPROBE_WILDCARD	(L"*")

BOOL
SxsProbeAssemblyInstallation(
	DWORD dwFlags,
	PCWSTR lpIdentity,
	PDWORD lpDisposition
    )
{
    FN_PROLOG_WIN32;

    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, ::SxsDestroyAssemblyIdentity> pAssemblyIdentity;
    CStringBuffer AssemblyPathBuffer, AssemblyRoot, ManifestPathBuffer;
    DWORD dwDisposition = 0;
    BOOL fIsPolicy;
    DWORD dwAttributes, dwLastError;

    if (lpDisposition != NULL)
        *lpDisposition = 0;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(lpIdentity != NULL);
    PARAMETER_CHECK(lpDisposition != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(AssemblyRoot));

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromTextualString(
            lpIdentity,
            &pAssemblyIdentity));

    IFW32FALSE_EXIT(
        ::SxspValidateIdentity(
            SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            pAssemblyIdentity));

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(pAssemblyIdentity, fIsPolicy));

    // AssemblyIdentity is created, now generate the path
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            0,
            (fIsPolicy ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST),
            AssemblyRoot,
            AssemblyRoot.Cch(),
            pAssemblyIdentity,
            ManifestPathBuffer));

    //
    // See if the file is there.
    //
    IFW32FALSE_EXIT(
        ::SxspGetFileAttributesW(
            ManifestPathBuffer, 
            dwAttributes, 
            dwLastError, 
            2, 
            ERROR_FILE_NOT_FOUND, 
            ERROR_PATH_NOT_FOUND));

    //
    // Path not found or file not found means The assembly can't possibly be installed or resident.
    //
    if (dwLastError != ERROR_SUCCESS)
    {
        dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_NOT_INSTALLED;
        goto DoneLooking;
    }
    //
    // Otherwise, the manifest or policy file was present, so the assembly is installed.
    //
    else
    {
        dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_INSTALLED;
    }



    //
    // If this assembly is policy, we need to not look to see if it's resident -
    // it's always resident, and we can quit looking.
    //
    if (fIsPolicy)
    {
        dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT;
        goto DoneLooking;
    }
    //
    // Otherwise, we should look to see if the directory for the assembly is present -
    // if it is, then the assembly is "resident".
    //
    else
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                AssemblyRoot,
                AssemblyRoot.Cch(),
                pAssemblyIdentity,
                AssemblyPathBuffer));

        IFW32FALSE_EXIT(
            ::SxspGetFileAttributesW(
                AssemblyPathBuffer,
                dwAttributes,
                dwLastError,
                2,
                ERROR_FILE_NOT_FOUND,
                ERROR_PATH_NOT_FOUND));

        //
        // We found the path, and it's a directory!
        //
        if ((dwLastError == ERROR_SUCCESS) && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT;
        }
        //
        // Hmm... failed to find the directory, looks like we have to see if there were
        // any actual files in the assembly before we say that it's not resident.
        //
        else
        {
            SXS_MANIFEST_INFORMATION_BASIC ManifestInfo;
            SIZE_T cbRequired;

            IFW32FALSE_EXIT(
                ::SxsQueryManifestInformation(
                    0, 
                    ManifestPathBuffer, 
                    SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC,
                    SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY |
                    SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME,
                    sizeof(ManifestInfo),
                    (PVOID)&ManifestInfo,
                    &cbRequired));
                    

            if (ManifestInfo.ulFileCount == 0)
            {
                dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT;
            }
        }
    }


DoneLooking:
    *lpDisposition = dwDisposition;

    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxspath.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SxsPath.h

Abstract:

    popular cousin of "String.h" and "Wheel.h"

Author:

    Jay Krell (a-JayK) April 2000

Revision History:

--*/
#pragma once
#include "FusionString.h"

/*
See also

If you find yourself scanning strings with for loops, stop, and
learn to use:
FusionString.h
    StringReverseSpan
    StringReverseComplementSpan

<string.h> / <wchar.h>
    wcschr
    wcsrchr
    wcsspn
    wcscspn
    wcsstr

StringBuffer.h
    Member functions with "Path" in their name.
*/

/*-----------------------------------------------------------------------------
Split a path into

root, path, base, extension

the full path is roughly root + "\\" + path + "\\" + base + "." + extension
but path, base, and extension can be empty (but not all three) and root
might end in a slash, so you shouldn't do that blindly.

Forward and backward slashes are accepted.
Runs of slashes are accepted and mean the same thing as individual slashes
    (a run is sort of special case at the start to indicate UNC, but other than
    the call out to ntdll.dll, that doesn't effect the logic here)

This class has no path length limitations (ntdll.dll?)

The output of this class is its public member data.
-----------------------------------------------------------------------------*/
template <typename PCWSTRorPWSTR = PCWSTR>
class CFullPathSplitPointersTemplate
{
public:
    CFullPathSplitPointersTemplate();

    BOOL Initialize(PCWSTR full)
    {
        return GenericInitialize(full);
    }

    BOOL Initialize(PWSTR full)
    {
        return GenericInitialize(full);
    }

protected:
    BOOL GenericInitialize(PCWSTRorPWSTR full);

public:

    BOOL IsBaseEmpty() const;
    BOOL IsBaseEqual(const CFullPathSplitPointersTemplate&) const;

    //
    // This public data is the output of this class.
    // none of these have trailing slashes except possibly "c:\"
    // all "end" values are "one past the end", STL style
    // extension doesn't include the dot, but you can be paranoid
    // and check for that (it'll be NULL or point to nul if there's no extension)
    // path must be "well formed", full, Win32 drive letter or UNC,
    // and not end in a slash, otherwise Initialize will return false
    //
    // These are not in general nul terminated.
    // m_extensionEnd usually does point to a nul.
    //
    // Generally, you yourself put stick a nul over m_*end,
    // because generally none of the pieces overlap, but a
    // root of c:\ is a common exception. CSetupCopyQueuePathParameters
    // sticks in nuls, and allows for this exception.
    //
    // The length of any element is m_*end - m_*, as is the STL iterator way.
    //
    PCWSTRorPWSTR m_root;         // never NULL or ""
    PCWSTRorPWSTR m_rootEnd;      // never == m_root
    PCWSTRorPWSTR m_path;         // NULL or "" in case of c:\foo.txt
    PCWSTRorPWSTR m_pathEnd;      // == m_path in case of c:\foo.txt
    PCWSTRorPWSTR m_base;         // NULL or "" in case of c:\.foo
    PCWSTRorPWSTR m_baseEnd;      // == m_base in case of c:\.foo
    PCWSTRorPWSTR m_extension;    // NULL or "" in case c:\foo
    PCWSTRorPWSTR m_extensionEnd; // == fullEnd if there is no extension

    // if the file has a base, this points to it
    //      followed by dot and extension if it has one
    // if the file has no base, this points to the extension, including the dot
    // this is always nul terminated
    // this is never null, and shouldn't be empty either
    PCWSTRorPWSTR m_name;
};

typedef CFullPathSplitPointersTemplate<>       CFullPathSplitPointers;
typedef CFullPathSplitPointersTemplate<PWSTR>  CMutableFullPathSplitPointers;

/*-----------------------------------------------------------------------------
Building on CFullPathSplitPointers, take two strings and split them up
exactly as SetupCopyQueue wants them, into
source root, root path, source name (base + extension)
destination directory (root + path), destination name (base + extension)

The output of this class is its public member data.
-----------------------------------------------------------------------------*/
class CSetupCopyQueuePathParameters
{
public:
    CSetupCopyQueuePathParameters();

    BOOL
    Initialize(
        PCWSTR pszSource,
        PCWSTR pszDestination
        );

    // rather than copy each substring into its own buffer, put nuls
    // in place, over the delimiting slashes (and dot), BUT watch out
    // for c:\foo, so if the root is three characters, copy it
    // into a seperate buffer.
public:
    //
    // These are null terminated.
    //
    PCWSTR m_sourceRoot;
    PCWSTR m_sourcePath;
    PCWSTR m_sourceName; // base and extension

    PCWSTR m_destinationDirectory; // root and path
    PCWSTR m_destinationName; // base and extension
protected:
    WCHAR                         m_sourceRootStorage[4];
    CStringBuffer                 m_sourceBuffer;
    CMutableFullPathSplitPointers m_sourceSplit;

    WCHAR                         m_destinationDirectoryStorage[4]; // root and path, if path is empty
    CStringBuffer                 m_destinationBuffer;
    CMutableFullPathSplitPointers m_destinationSplit;

private:
    CSetupCopyQueuePathParameters(const CSetupCopyQueuePathParameters &);
    void operator =(const CSetupCopyQueuePathParameters &);
};

/*-----------------------------------------------------------------------------
inline implementation of CFullPathSplitPointersTemplate,
because it is a template
-----------------------------------------------------------------------------*/
template <typename T>
inline CFullPathSplitPointersTemplate<T>::CFullPathSplitPointersTemplate()
:
    m_root(NULL),
    m_rootEnd(NULL),
    m_path(NULL),
    m_pathEnd(NULL),
    m_base(NULL),
    m_baseEnd(NULL),
    m_extension(NULL),
    m_extensionEnd(NULL),
    m_name(L"")
{
}

template <typename T>
inline BOOL
CFullPathSplitPointersTemplate<T>::GenericInitialize(T full)
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    RTL_PATH_TYPE pathType;

    pathType = SxspDetermineDosPathNameType(full);

    PARAMETER_CHECK(
        (pathType == RtlPathTypeUncAbsolute) ||
        (pathType == RtlPathTypeLocalDevice) ||
        (pathType == RtlPathTypeDriveAbsolute));

    T fullEnd;
    fullEnd = full + StringLength(full);
    m_root = full;
    if (m_root[1] == ':')
    {
        m_path  = m_root + 3;
        m_rootEnd = m_path;
        m_path += wcsspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip path separators
    }
    else
    {
        m_path = m_root;
        m_path +=  wcsspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\"
        m_path += wcscspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\computer"
        m_path +=  wcsspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\computer\"
        m_path += wcscspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\computer\share"
        m_rootEnd = m_path;
        m_path +=  wcsspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\computer\share\"
    }

    //
    // now work from the right
    // first find the last dot and last slash, and determine
    // where the base and extension are, if any
    //
    INT nameExtLength;
    INT extLength;
    nameExtLength = ::StringReverseComplementSpan(m_path, fullEnd, CUnicodeCharTraits::PathSeparators());
    extLength = ::StringReverseComplementSpan(m_path, fullEnd, L".");

    //
    // determine the extension
    //
    if (extLength > nameExtLength)
    {
        // no extension on leaf, but one on a parent, slightly unusual
        // c:\foo.bar\abc
        m_extension = NULL;
        m_extensionEnd = NULL;
    }
    else
    {
        // c:\foo\abc.txt or c:\foo.bar\abc.txt (or c:\foo\.txt or some others)
        m_extension  = fullEnd - extLength;
        m_extensionEnd = fullEnd;
    }

    //
    // determine the base
    //
    if (extLength + 1 == nameExtLength)
    {
        // unusual case, extension but no base
        // c:\.foo or c:\abc\.foo
        m_base = NULL;
        m_baseEnd = NULL;
    }
    else
    {
        m_base = fullEnd - nameExtLength;
        if (m_extension != NULL)
        {
            // normal case, base.extension
            m_baseEnd = m_extension - 1;
        }
        else
        {
            // no extension
            m_baseEnd = fullEnd;
        }
    }

    //
    // determine the path
    //
    if (m_base != NULL)
    {
        if (m_path == m_base)
        {
            // no path c:\foo.txt
            m_path = NULL;
            m_pathEnd = NULL;
        }
        else
        {
            // normal case of path ends at base c:\abc\def.txt
            m_pathEnd = m_base - 1;
        }
    }
    else if (m_extension != NULL)
    {
        // no base, but an extension
        // c:\.txt or c:\abc\.txt
        if (m_path + 1 == m_extension)
        {
            // no path c:\.txt
            m_path = NULL;
            m_pathEnd = NULL;
        }
        else
        {
            // path ends at extension c:\abc\.txt
            m_pathEnd = m_extension - 2;
        }
    }
    else
    {
        // no path and no extension
        // this probably happens when we have a terminal slash
        // we've already filtered out empty strings
        m_pathEnd = fullEnd - ::StringReverseSpan(m_path, fullEnd, CUnicodeCharTraits::PathSeparators());
    }

    // there is always a root (paths are always full)
    ASSERT(m_root != NULL && m_rootEnd != NULL);

    // there is always a base or an extension (or both)
    ASSERT(m_base != NULL || m_extension != NULL);

    // if there's a start, there's an end
    ASSERT((m_base != NULL) == (m_baseEnd != NULL));
    ASSERT((m_extension != NULL) == (m_extensionEnd != NULL));

    m_name = (m_base != NULL) ? m_base : (m_extension - 1);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

template <typename T>
inline BOOL
CFullPathSplitPointersTemplate<T>::IsBaseEmpty(
    ) const
{
    return (m_base == m_baseEnd);
}

template <typename T>
inline BOOL
CFullPathSplitPointersTemplate<T>::IsBaseEqual(
    const CFullPathSplitPointersTemplate& other
    ) const
{
    BOOL fEqual = FALSE;
    const INT length1 = static_cast<INT>(m_baseEnd - m_base);
    const INT length2 = static_cast<INT>(other.m_baseEnd - other.m_base);
    if (length1 != length2)
        goto Exit;
    fEqual = (FusionpCompareStrings(m_base, length1, other.m_base, length1, true) == 0);
Exit:
    return fEqual;
}

/*-----------------------------------------------------------------------------
inline implementation of CSetupCopyQueuePathParameters
-----------------------------------------------------------------------------*/
inline CSetupCopyQueuePathParameters::CSetupCopyQueuePathParameters()
:
    m_sourcePath(NULL),
    m_sourceName(NULL),
    m_destinationDirectory(NULL),
    m_destinationName(NULL)
{
    m_sourceRootStorage[0] = 0;
    m_destinationDirectoryStorage[0] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxspath.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SxsPath.cpp

Abstract:

    popular cousin of "String.cpp" and "Wheel.cpp"

Author:

    Jay Krell (a-JayK) April 2000

Revision History:

--*/
#include "stdinc.h"
#include "fusiontrace.h"
#include "fusionbuffer.h"
#include "sxsntrtl.inl"
#include "sxspath.h"

/*-----------------------------------------------------------------------------
Building on CFullPathSplitPointers, take two strings and split them up
exactly as the SetupCopyQueue API wants them, into
source root, root path, source name (base + extension)
destination directory (root + path), destination name (base + extension)

The output of this class is its public member data.
-----------------------------------------------------------------------------*/

BOOL
CSetupCopyQueuePathParameters::Initialize(
    PCWSTR pszSource,
    PCWSTR pszDestination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CStringBufferAccessor Accessor;

    IFW32FALSE_EXIT(m_sourceBuffer.Win32Assign(pszSource, (pszSource != NULL) ? ::wcslen(pszSource) : 0));
    IFW32FALSE_EXIT(m_destinationBuffer.Win32Assign(pszDestination, (pszDestination != NULL) ? ::wcslen(pszDestination) : 0));

    Accessor.Attach(&m_sourceBuffer);
    IFW32FALSE_EXIT(m_sourceSplit.Initialize(Accessor.GetBufferPtr()));
    Accessor.Detach();

    Accessor.Attach(&m_destinationBuffer);
    IFW32FALSE_EXIT(m_destinationSplit.Initialize(Accessor.GetBufferPtr()));
    Accessor.Detach();

    if (m_sourceSplit.m_rootEnd - m_sourceSplit.m_root == 3)
    {
        m_sourceRootStorage[0] = m_sourceBuffer[0];
        m_sourceRootStorage[1] = ':';
        m_sourceRootStorage[2] = CUnicodeCharTraits::PreferredPathSeparator();
        m_sourceRootStorage[3] = 0;
        m_sourceSplit.m_root = m_sourceRootStorage;
        m_sourceSplit.m_rootEnd = m_sourceRootStorage + 3;
        m_sourceRoot = m_sourceRootStorage;
    }
    else
    {
        ASSERT(::FusionpIsPathSeparator(*m_sourceSplit.m_rootEnd));
        *m_sourceSplit.m_rootEnd = 0;
        m_sourceRoot = m_sourceSplit.m_root;
    }
    if (m_sourceSplit.m_pathEnd != NULL)
    {
        *m_sourceSplit.m_pathEnd = 0;
    }

    if (m_sourceSplit.m_path != NULL)
    {
        m_sourcePath = m_sourceSplit.m_path;
        *m_sourceSplit.m_pathEnd = 0;
    }
    else
    {
        m_sourcePath = L"";
    }

    if (m_sourceSplit.m_base != NULL)
    {
        m_sourceName = m_sourceSplit.m_base;
    }
    else
    {
        m_sourceName = m_sourceSplit.m_extension - 1;
    }
    // sourceName runs to end of original string, so no terminal nul needs to be stored

    // destination is simpler, not as much worth all the splitting work.
    // again though, we don't want to write a nul over the slash in c:\ if
    // that string stands alone; we don't need a root here, so it's less likely,
    // but the case of returning the root+path of a file at the root..
    if (
            (m_destinationSplit.m_base != NULL
                && m_destinationSplit.m_base - m_destinationSplit.m_root == 3) // c:\foo.txt
        || (m_destinationSplit.m_extension != NULL
                && m_destinationSplit.m_extension - m_destinationSplit.m_root == 4) // c:\.txt
        )
    {
        ASSERT(m_destinationSplit.m_path == NULL);
        m_destinationDirectoryStorage[0] = m_destinationBuffer[0];
        m_destinationDirectoryStorage[1] = ':';
        m_destinationDirectoryStorage[2] = CUnicodeCharTraits::PreferredPathSeparator();
        m_destinationDirectoryStorage[3] = 0;

        m_destinationSplit.m_root = m_destinationDirectoryStorage;
        m_destinationSplit.m_rootEnd = m_destinationDirectoryStorage + 3;
        m_destinationDirectory = m_destinationDirectoryStorage;
    }
    else
    {
        m_destinationDirectory = m_destinationBuffer; // == m_destinationSplit.m_root
    }
    PWSTR destinationName; // temporarily mutable
    if (m_destinationSplit.m_base != NULL)
    {
        destinationName = m_destinationSplit.m_base;
    }
    else
    {
        // c:\.foo
        destinationName = m_destinationSplit.m_extension - 1;
    }
    ASSERT(::FusionpIsPathSeparator(*(destinationName - 1)));
    *(destinationName - 1) = 0;
    m_destinationName = destinationName; // now const

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsprotect.cpp ===
#include "stdinc.h"
#include "util.h"
#include "xmlparser.hxx"
#include "FusionEventLog.h"
#include "parsing.h"
#include "hashfile.h"
#include "recover.h"
#include "filestream.h"
#include "CAssemblyRecoveryInfo.h"
#include "sxsprotect.h"
#include "strongname.h"
#include "SxsExceptionHandling.h"
#include "sxssfcscan.h"

#define MANIFEST_FILE_EXTENSION     (L".manifest")
#define FILE_ELEMENT_NAME           (L"file")

#define HASH_ATTRIB_NAME            (L"hash")
#define FILE_ATTRIB_NAME            (L"name")
#define HASHALG_ATTRIB_NAME         (L"hashalg")

class CProtectionRequestList;
static CProtectionRequestList* g_ProtectionRequestList = NULL;
HANDLE g_hSxsLoginEvent = NULL;
static BOOL s_fIsSfcAcceptingNotifications = TRUE;

#if DBG
#define SXS_SFC_EXCEPTION_SETTING (SXSP_EXCEPTION_FILTER())
#else
#define SXS_SFC_EXCEPTION_SETTING (EXCEPTION_EXECUTE_HANDLER)
#endif

BOOL
CRecoveryJobTableEntry::Initialize()
{
    FN_PROLOG_WIN32

    //
    // Creates an event that other callers should wait on - manual reset, not
    // currently signalled.
    //
    m_Subscriber = 0;
    m_fSuccessValue = FALSE;
    IFW32NULL_EXIT(m_EventInstallingAssemblyComplete = ::CreateEventW(NULL, TRUE, FALSE, NULL));

    FN_EPILOG
}

BOOL
CRecoveryJobTableEntry::StartInstallation()
{
    FN_PROLOG_WIN32

    //
    // Clear the event (if it wasn't already cleared.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(::ResetEvent(m_EventInstallingAssemblyComplete));

    FN_EPILOG
}


BOOL
SxspEnsureCatalogStillPresentForManifest(
    IN const CBaseStringBuffer& buffManifestPath,
    OUT BOOL &rfStillPresent
    )
{
    FN_PROLOG_WIN32

    rfStillPresent = FALSE;

    CStringBuffer buffCatalogPath;

    IFW32FALSE_EXIT(buffCatalogPath.Win32Assign(buffManifestPath));

    IFW32FALSE_EXIT(
        buffCatalogPath.Win32ChangePathExtension(
            FILE_EXTENSION_CATALOG,
            FILE_EXTENSION_CATALOG_CCH,
            eAddIfNoExtension));

    const DWORD dwCatalogAttribs = ::GetFileAttributesW(buffCatalogPath);
    if (dwCatalogAttribs != INVALID_FILE_ATTRIBUTES)
    {
        rfStillPresent = TRUE;
    }
    else
    {
        const DWORD dwLastError = ::FusionpGetLastWin32Error();

        switch (dwLastError)
        {
        default:
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributesW, dwLastError);

        case ERROR_PATH_NOT_FOUND:
        case ERROR_FILE_NOT_FOUND:
        case ERROR_BAD_NET_NAME:
        case ERROR_BAD_NETPATH:
            ;
        }
    }

    FN_EPILOG
}

BOOL
CRecoveryJobTableEntry::InstallationComplete(
    BOOL bDoneOk,
    SxsRecoveryResult Result,
    DWORD dwRecoveryLastError
    )
{
    FN_PROLOG_WIN32

    m_Result = Result;
    m_fSuccessValue = bDoneOk;
    m_dwLastError = dwRecoveryLastError;

    //
    // This will tell all the people waiting that we're done and that they
    // should capture the exit code and exit out.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(::SetEvent(m_EventInstallingAssemblyComplete));

    //
    // We wait for all our subscribers to go away (ie: for them to capture an
    // install code and success value.)
    //
    while (m_Subscriber)
    {
        Sleep(50);
    }

    FN_EPILOG
}


BOOL
CRecoveryJobTableEntry::WaitUntilCompleted(
    SxsRecoveryResult &rResult,
    BOOL &rbSucceededValue,
    DWORD &rdwErrorResult
    )
{
    FN_PROLOG_WIN32

    DWORD WaitResult;

    //
    // Here we join up to the existing installation routine. We up the number
    // of people waiting before entering the wait.  I wish there was a better
    // way of doing this, something like a built-in kernel object that we can
    // raise a count on (like a semaphore), and have another thread lower a
    // count on, and someone can wait on the internal count being zero.  Yes,
    // I could implement this by hand using something with another event or
    // two, but that's not the point.
    //
    ::SxspInterlockedIncrement(&m_Subscriber);

    //
    // Hang about forever until another thread is done installing
    //
    IFW32FALSE_ORIGINATE_AND_EXIT((WaitResult = ::WaitForSingleObject(m_EventInstallingAssemblyComplete, INFINITE)) != WAIT_FAILED);

    //
    // Capture values once the installation is done, return them to the caller.
    //
    rResult = m_Result;
    rdwErrorResult = m_dwLastError;
    rbSucceededValue = m_fSuccessValue;

    //
    // And indicate that we're complete.
    //
    ::SxspInterlockedDecrement(&m_Subscriber);

    FN_EPILOG
}

CRecoveryJobTableEntry::~CRecoveryJobTableEntry()
{
    //
    // We're done with the event, so close it (release refcount, we don't want lots of these
    // just sitting around.)
    //
    if ((m_EventInstallingAssemblyComplete != NULL) &&
        (m_EventInstallingAssemblyComplete != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(m_EventInstallingAssemblyComplete);
        m_EventInstallingAssemblyComplete = INVALID_HANDLE_VALUE;
    }
}


//
// This is our holy grail of sxs protection lists.  Don't fidget with
// this listing.  Note that we've also got only one.  This is because
// right now, there's only one entry to be had (a), and (b) because we
// will fill in the sxs directory on the fly at runtime.
//
SXS_PROTECT_DIRECTORY s_SxsProtectionList[] =
{
    {
        {0},
        0,
        SXS_PROTECT_RECURSIVE,
        SXS_PROTECT_FILTER_DEFAULT
    }
};

const SIZE_T s_SxsProtectionListCount = NUMBER_OF(s_SxsProtectionList);


BOOL SxspConstructProtectionList();


BOOL WINAPI
SxsProtectionGatherEntriesW(
    PCSXS_PROTECT_DIRECTORY *prgpProtectListing,
    SIZE_T *pcProtectEntries
    )
/*++
    This is called by Sfc to gather the entries that we want them to watch.
    At the moment, it's a 'proprietary' listing of all the directories and
    flags we want them to set on their call to the directory-change watcher.
    Mayhaps we should work with them to find out exactly what they want us
    to pass (probably the name plus a PVOID, which is fine) and then go from
    there.
--*/
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer sbTemp;


    if (prgpProtectListing) *prgpProtectListing = NULL;
    if (pcProtectEntries) *pcProtectEntries = 0;

    PARAMETER_CHECK(prgpProtectListing);
    PARAMETER_CHECK(pcProtectEntries);

    //
    // This is try/caught because we don't want something here to
    // cause WinLogon to bugcheck the system when it AV's.
    //
	IFW32FALSE_EXIT(::SxspConstructProtectionList());

    //
    // We really have only one entry, so let's go and edit the first entry to
    // be the main sxs store directory.
    //
    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(sbTemp));
    wcsncpy(
        s_SxsProtectionList[0].pwszDirectory,
        sbTemp,
        NUMBER_OF(s_SxsProtectionList[0].pwszDirectory));
    //
    // Zero out the last character, just in case wcsncpy didn't do it for us
    //
    s_SxsProtectionList[0].pwszDirectory[NUMBER_OF(s_SxsProtectionList[0].pwszDirectory) - 1] = L'\0';

    //
    // Shh, don't tell anyone, but the cookie is actually this structure!
    //
    for (DWORD dw = 0; dw < s_SxsProtectionListCount; dw++)
    {
        s_SxsProtectionList[dw].pvCookie = &(s_SxsProtectionList[dw]);
    }

    *prgpProtectListing = s_SxsProtectionList;
    *pcProtectEntries = s_SxsProtectionListCount;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}








inline BOOL
SxspExpandLongPath(
    IN OUT CBaseStringBuffer &rbuffPathToLong
    )
/*++

Takes in a short path (c:\foo\bar\bloben~1.zot) and sends back out the
full path (c:\foo\bar\blobenheisen.zotamax) if possible.  Returns FALSE if
the path could not be expanded (most likely because the path on-disk is
no longer available.)

--*/
{
    FN_PROLOG_WIN32

    CStringBuffer           buffPathName;
    CStringBufferAccessor   buffAccess;
    SIZE_T                  cchNeededChars;

    IFW32ZERO_EXIT(
        cchNeededChars = ::GetLongPathNameW(
            static_cast<PCWSTR>(rbuffPathToLong),
            NULL,
            0));

    IFW32FALSE_EXIT(buffPathName.Win32ResizeBuffer(cchNeededChars, eDoNotPreserveBufferContents));
    buffAccess.Attach(&buffPathName);

    IFW32ZERO_EXIT(
        cchNeededChars = ::GetLongPathNameW(
            rbuffPathToLong,
            buffAccess,
            static_cast<DWORD>(buffAccess.GetBufferCch())));

    INTERNAL_ERROR_CHECK(cchNeededChars <= buffAccess.GetBufferCch());

    IFW32FALSE_EXIT(rbuffPathToLong.Win32Assign(buffPathName));

    FN_EPILOG
}

BOOL
SxspResolveAssemblyManifestPath(
    const CBaseStringBuffer &rbuffAssemblyDirectoryName,
    CBaseStringBuffer &rbuffManifestPath
    )
{
    FN_PROLOG_WIN32
    CStringBuffer   buffAssemblyRootDir;
    BOOL            fLooksLikeAssemblyName = FALSE;

    rbuffManifestPath.Clear();

    //
    // If the string doesn't look like an assembly name, then it's an
    // invalid parameter.  This is somewhat heavy-handed, as the caller(s)
    // to this function will be entirely hosed if they haven't checked to
    // see if the string is really an assembly name.  Make sure that all
    // clients of this,
    //
    IFW32FALSE_EXIT(::SxspLooksLikeAssemblyDirectoryName(rbuffAssemblyDirectoryName, fLooksLikeAssemblyName));
    PARAMETER_CHECK(fLooksLikeAssemblyName);

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffAssemblyRootDir));
    IFW32FALSE_EXIT(rbuffManifestPath.Win32Format(
        L"%ls\\Manifests\\%ls.%ls",
        static_cast<PCWSTR>(buffAssemblyRootDir),
        static_cast<PCWSTR>(rbuffAssemblyDirectoryName),
        FILE_EXTENSION_MANIFEST));

    FN_EPILOG
}




CProtectionRequestRecord::CProtectionRequestRecord()
    : m_dwAction(0), m_pvProtection(NULL), m_ulInRecoveryMode(0),
      m_pParent(NULL),
      m_bIsManPathResolved(FALSE),
      m_bInitialized(FALSE)
{
}

BOOL
CProtectionRequestRecord::GetManifestPath(
    CBaseStringBuffer &rsbManPath
    )
{
    BOOL bOk = FALSE;
    FN_TRACE_WIN32(bOk);

    rsbManPath.Clear();

    if (!m_bIsManPathResolved)
    {
        m_bIsManPathResolved =
            ::SxspResolveAssemblyManifestPath(
                m_sbAssemblyDirectoryName,
                m_sbManifestPath);
    }

    if (m_bIsManPathResolved)
    {
        IFW32FALSE_EXIT(rsbManPath.Win32Assign(m_sbManifestPath));
    }
    else
    {
        goto Exit;
    }

    bOk = TRUE;
Exit:
    return bOk;
}

inline BOOL
CProtectionRequestRecord::GetManifestContent(CSecurityMetaData *&pMetaData)
{
    FN_PROLOG_WIN32
    FN_EPILOG
}

//
// Close down this request record.
//
CProtectionRequestRecord::~CProtectionRequestRecord()
{
    if (m_bInitialized)
    {
        ClearList();
        m_bInitialized = FALSE;
    }
}

inline VOID
CProtectionRequestRecord::ClearList()
{
    CStringListEntry *pTop;

    while (pTop = (CStringListEntry*)SxspInterlockedPopEntrySList(&m_ListHeader))
    {
        FUSION_DELETE_SINGLETON(pTop);
    }
}

inline BOOL
CProtectionRequestRecord::AddSubFile(
    const CBaseStringBuffer &rbuffRelChange
    )
{
    CStringListEntry *pairing = NULL;
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    if (!SxspInterlockedCompareExchange(&m_ulInRecoveryMode, 0, 0))
    {
        IFALLOCFAILED_EXIT(pairing = new CStringListEntry);
        IFW32FALSE_EXIT(pairing->m_sbText.Win32Assign(rbuffRelChange));

        //
        // Add it to the list (atomically, to boot!)
        //
        ::SxspInterlockedPushEntrySList(&m_ListHeader, pairing);
        pairing = NULL;
    }

    fSuccess = TRUE;
Exit:
    if (pairing)
    {
        //
        // The setup or something like that failed - release it here.
        //
        FUSION_DELETE_SINGLETON(pairing);
    }
    return fSuccess;
}


inline BOOL
CProtectionRequestRecord::Initialize(
    const CBaseStringBuffer &rsbAssemblyDirectoryName,
    const CBaseStringBuffer &rsbKeyString,
    CProtectionRequestList* ParentList,
    PVOID                   pvRequestRecord,
    DWORD                   dwAction
    )
{
    BOOL    fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    m_sbAssemblyDirectoryName.Clear();
    m_sbKeyValue.Clear();
    m_sbManifestPath.Clear();
    SxspInitializeSListHead(&m_ListHeader);

    PARAMETER_CHECK(ParentList != NULL);
    PARAMETER_CHECK(pvRequestRecord != NULL);

    m_pParent               = ParentList;
    m_dwAction              = dwAction;
    m_pvProtection          = (PSXS_PROTECT_DIRECTORY)pvRequestRecord;

    IFW32FALSE_EXIT(m_sbAssemblyStore.Win32Assign(m_pvProtection->pwszDirectory, (m_pvProtection->pwszDirectory != NULL) ? ::wcslen(m_pvProtection->pwszDirectory) : 0));
    IFW32FALSE_EXIT(m_sbAssemblyDirectoryName.Win32Assign(rsbAssemblyDirectoryName));
    IFW32FALSE_EXIT(m_sbKeyValue.Win32Assign(rsbKeyString));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}



//
// Bad form: This returns a BOOL to indicate whether or not this class
// was able to pop something off the list.  It's no good to ask "is the
// list empty," since that's not provided with this list class.
//
inline BOOL
CProtectionRequestRecord::PopNextFileChange(CBaseStringBuffer &Dest)
{
    BOOL fFound = FALSE;
    CStringListEntry *pPairing;

    Dest.Clear();
    pPairing = (CStringListEntry*)SxspInterlockedPopEntrySList(&m_ListHeader);

    if (pPairing)
    {
        Dest.Win32Assign(pPairing->m_sbText);
        FUSION_DELETE_SINGLETON(pPairing);
        fFound = TRUE;
    }

    return fFound;
}


//
// "If a thread dies in winlogon, and no kernel debugger is attached, does it
// bugcheck the system?" - From 'The Zen of Dodgy Code'
//
DWORD
CProtectionRequestList::ProtectionNormalThreadProc(PVOID pvParam)
{
    BOOL    fSuccess = FALSE;
    CProtectionRequestRecord *pRequestRecord = NULL;
    CProtectionRequestList *pThis = NULL;

    __try
    {
        pRequestRecord = static_cast<CProtectionRequestRecord*>(pvParam);
        if (pRequestRecord)
        {
            pThis = pRequestRecord->GetParent();
        }
        if (pThis)
        {
            fSuccess = pThis->ProtectionNormalThreadProcWrapped(pRequestRecord);
        }
    }
    __except(SXS_SFC_EXCEPTION_SETTING)
    {
        // Don't take down winlogon...
    }

    return static_cast<DWORD>(fSuccess);
}

BOOL
CProtectionRequestList::Initialize()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ASSERT(m_pInternalList == NULL);

    ::InitializeCriticalSectionAndSpinCount(&m_cSection, INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW);
    ::InitializeCriticalSectionAndSpinCount(&m_cInstallerCriticalSection, INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW);
    IFW32FALSE_EXIT(::SxspAtExit(this));

    IFALLOCFAILED_EXIT(m_pInternalList = new COurInternalTable);
    IFW32FALSE_EXIT(m_pInternalList->Initialize());

    IFALLOCFAILED_EXIT(m_pInstallsTable = new CInstallsInProgressTable);
    IFW32FALSE_EXIT(m_pInstallsTable->Initialize());

    //
    // Manifest protection stuff
    //
    ::SxspInitializeSListHead(&m_ManifestEditList);

    m_hManifestEditHappened = ::CreateEventW(NULL, TRUE, FALSE, NULL);
    if (m_hManifestEditHappened == NULL)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(CreateEventW);
        goto Exit;
    }

    ASSERT(m_pInternalList != NULL);
    ASSERT(m_pInstallsTable != NULL);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

CProtectionRequestList::CProtectionRequestList()
    : m_pInternalList(NULL), m_pInstallsTable(NULL),
      m_hManifestEditHappened(INVALID_HANDLE_VALUE),
      m_ulIsAThreadServicingManifests(0)

{
}


CProtectionRequestList::~CProtectionRequestList()
{
    ::DeleteCriticalSection(&m_cSection);
    ::DeleteCriticalSection(&m_cInstallerCriticalSection);

    COurInternalTable *pTempListing = m_pInternalList;
    CInstallsInProgressTable *pInstalls = m_pInstallsTable;

    m_pInternalList = NULL;
    m_pInternalList = NULL;

    if (pTempListing != NULL)
    {
        pTempListing->Clear(this, &CProtectionRequestList::ClearProtectionItems);
        FUSION_DELETE_SINGLETON(pTempListing);
    }

    if (pInstalls != NULL)
    {
        pInstalls->ClearNoCallback();
        FUSION_DELETE_SINGLETON(pInstalls);
    }

}

BOOL
CProtectionRequestList::IsSfcIgnoredStoreSubdir(PCWSTR wsz)
{
    FN_TRACE();

    ASSERT(m_arrIgnorableSubdirs);

    for (SIZE_T i = 0; i < m_cIgnorableSubdirs; i++)
    {
        if (!::FusionpStrCmpI(m_arrIgnorableSubdirs[i], wsz))
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CProtectionRequestList::AttemptRemoveItem(CProtectionRequestRecord *AttemptRemoval)
{
    //
    // This quickly indicates that the progress is complete and just returns to
    // the caller.
    //
    const CBaseStringBuffer &sbKey = AttemptRemoval->GetChangeBasePath();
    BOOL fSuccess = FALSE;
    CSxsLockCriticalSection lock(m_cSection);

    FN_TRACE_WIN32(fSuccess);
    PARAMETER_CHECK(AttemptRemoval != NULL);

    IFW32FALSE_EXIT(lock.Lock());
    //
    // This item is no longer in service.  Please check the item and
    // try your call again.  The nice thing is that Remove on CStringPtrTable
    // knows to delete the value lickety-split before returning.  This isn't
    // such a bad thing, but it's ... different.
    //
    m_pInternalList->Remove(sbKey, NULL);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProtectionRequestList::AddRequest(
    PSXS_PROTECT_DIRECTORY pProtect,
    PCWSTR pcwszDirName,
    SIZE_T cchName,
    DWORD dwAction
    )
{
    BOOL fSuccess = FALSE;
    bool fIsManifestEdit = false;
    BOOL fIsIgnorable;    
    BOOL fNewAddition = FALSE;
    CSmallStringBuffer sbTemp;
    CSmallStringBuffer sbAssemblyDirectoryName;
    CSmallStringBuffer sbRequestText;
    CSmallStringBuffer buffManifestsDirectoryName;
    CSmallStringBuffer buffManifestsShortDirectoryName;
    CProtectionRequestRecord *pRecord = NULL;
    CProtectionRequestRecord *ppFoundInTable = NULL;
    CSxsLockCriticalSection lock(m_cSection);

    FN_TRACE_WIN32(fSuccess);

    //
    // The key here is the first characters (up to the first slash) in the
    // notification name.  If there's no slash in the notification name, then
    // we can ignore this change request, since nothing important happened.
    //
    IFW32FALSE_EXIT(sbTemp.Win32Assign(pProtect->pwszDirectory, (pProtect->pwszDirectory != NULL) ? ::wcslen(pProtect->pwszDirectory) : 0));
    IFW32FALSE_EXIT(sbRequestText.Win32Assign(pcwszDirName, cchName));
    IFW32FALSE_EXIT(sbRequestText.Win32GetFirstPathElement(sbAssemblyDirectoryName));

    fIsIgnorable = IsSfcIgnoredStoreSubdir(sbAssemblyDirectoryName);

    fIsManifestEdit = !::FusionpStrCmpI(sbAssemblyDirectoryName, MANIFEST_ROOT_DIRECTORY_NAME);

    if (!fIsManifestEdit)
    {
        DWORD dwTemp;
        CStringBufferAccessor acc;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffManifestsDirectoryName));
        IFW32FALSE_EXIT(buffManifestsDirectoryName.Win32AppendPathElement(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));

        acc.Attach(&buffManifestsShortDirectoryName);
        IFW32ZERO_ORIGINATE_AND_EXIT(dwTemp = ::GetShortPathNameW(buffManifestsDirectoryName, acc.GetBufferPtr(), acc.GetBufferCchAsDWORD()));
        while (dwTemp >= acc.GetBufferCchAsDWORD())
        {
            acc.Detach();
            IFW32FALSE_EXIT(buffManifestsShortDirectoryName.Win32ResizeBuffer(dwTemp, eDoNotPreserveBufferContents));
            acc.Attach(&buffManifestsShortDirectoryName);
            IFW32ZERO_ORIGINATE_AND_EXIT(dwTemp = ::GetShortPathNameW(buffManifestsDirectoryName, acc.GetBufferPtr(), acc.GetBufferCchAsDWORD()));
        }

        acc.Detach();

        // Ok all that work and now we finally have the manifests directory name as a short string.  Let's abuse buffManifestsShortDirectoryName
        // to just hold the short name of the manifests directory.

        IFW32FALSE_EXIT(buffManifestsShortDirectoryName.Win32GetLastPathElement(buffManifestsDirectoryName));

        if (::FusionpCompareStrings(
                buffManifestsDirectoryName,
                sbAssemblyDirectoryName,
                true) == 0)
        {
            // Convert the directory name to its proper long form
            IFW32FALSE_EXIT(sbAssemblyDirectoryName.Win32Assign(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));
            fIsManifestEdit = true;
        }
    }

    if ((fIsIgnorable) && (!fIsManifestEdit))
    {
#if DBG
        //
        // We get a lot of these.
        //
        if (::FusionpStrCmpI(sbAssemblyDirectoryName, L"InstallTemp") != 0)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS.DLL: %s() - %ls is ignorable (%d)\n",
                __FUNCTION__,
                static_cast<PCWSTR>(sbAssemblyDirectoryName),
                fIsIgnorable
                );
        }
#endif
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // The "key" value here is the full path to the assembly that we're protecting.
    // This is what we'll store in the table.
    //
    IFW32FALSE_EXIT(sbTemp.Win32AppendPathElement(sbAssemblyDirectoryName));


    if (fIsManifestEdit)
    {
        CStringListEntry *pEntry = NULL;
        ULONG ulWasSomeoneServicing = 0;

        //
        // Create a new manifest edit slot, add it to the list of items that are being
        // serviced.
        //
        IFALLOCFAILED_EXIT(pEntry = new CStringListEntry);
        if (!pEntry->m_sbText.Win32Assign(sbRequestText))
        {
            TRACE_WIN32_FAILURE(m_sbText.Win32Assign);
            FUSION_DELETE_SINGLETON(pEntry);
            pEntry = NULL;
            goto Exit;
        }
        SxspInterlockedPushEntrySList(&m_ManifestEditList, pEntry);
        pEntry = NULL;

        //
        // Tell anyone that's listening that we have a new manifest edit here
        //
        SetEvent(m_hManifestEditHappened);

        //
        // See if someone is servicing the queue at the moment
        //
        ulWasSomeoneServicing = SxspInterlockedCompareExchange(&m_ulIsAThreadServicingManifests, 1, 0);

        if (!ulWasSomeoneServicing)
        {
            QueueUserWorkItem(ProtectionManifestThreadProc, (PVOID)this, WT_EXECUTEDEFAULT);
        }

        fSuccess = TRUE;
        goto Exit;
    }

    //
    // At this point, we need to see if the chunk that we identified is currently
    // in the list of things to be validated.  If not, it gets added and a thread
    // is spun off to work on it.  Otherwise, an entry may already exist in a
    // thread that's being serviced, and so it needs to be deleted.
    //
    IFW32FALSE_EXIT(lock.Lock());
    m_pInternalList->Find(sbTemp, ppFoundInTable);

    if (!ppFoundInTable)
    {
        IFALLOCFAILED_EXIT(pRecord = new CProtectionRequestRecord);
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: %s() - Creating protection record for %ls:\n"
            "\tKey              = %ls\n"
            "\tManifest?        = %d\n"
            "\tProtectionRecord = %p\n"
            "\tAction           = %d\n",
            __FUNCTION__,
            static_cast<PCWSTR>(sbAssemblyDirectoryName),
            static_cast<PCWSTR>(sbTemp),
            fIsManifestEdit,
            pProtect,
            dwAction);
#endif
        IFW32FALSE_EXIT(pRecord->Initialize(
            sbAssemblyDirectoryName,
            sbTemp,
            this,
            pProtect,
            dwAction));

        //
        // Add this first request to be serviced, then spin a thread to start it.
        //
        m_pInternalList->Insert(sbTemp, pRecord);
        fNewAddition = TRUE;

        //
        // A little bookkeeping ... so we don't accidentally use it later.
        //
        ppFoundInTable = pRecord;
        pRecord = NULL;
    }

    //
    // If we actually got something into the table...
    //
    if (ppFoundInTable)
    {
        ppFoundInTable->AddSubFile(sbRequestText);

        //
        // If this is a new thing in the table (ie: we inserted it ourselves)
        // then we should go and spin up a thread for it.
        //
        if (fNewAddition)
        {
            QueueUserWorkItem(ProtectionNormalThreadProc, (PVOID)ppFoundInTable, WT_EXECUTEDEFAULT);
        }
    }

    fSuccess = TRUE;

Exit:
    DWORD dwLastError = ::FusionpGetLastWin32Error();
    if (pRecord)
    {
        //
        // If this is still set, something bad happened in the process of trying to
        // create/find this object.  Delete it here.
        //
        FUSION_DELETE_SINGLETON(pRecord);
        pRecord = NULL;
    }
    ::FusionpSetLastWin32Error(dwLastError);
    return fSuccess;
}

static BYTE p_bProtectionListBuffer[ sizeof(CProtectionRequestList) * 2 ];
PCWSTR CProtectionRequestList::m_arrIgnorableSubdirs[] = 
{ 
    ASSEMBLY_INSTALL_TEMP_DIR_NAME, 
    POLICY_ROOT_DIRECTORY_NAME,   
    REGISTRY_BACKUP_ROOT_DIRECTORY_NAME
};
SIZE_T CProtectionRequestList::m_cIgnorableSubdirs =
    NUMBER_OF(CProtectionRequestList::m_arrIgnorableSubdirs);

BOOL
SxspIsSfcIgnoredStoreSubdir(PCWSTR pwsz)
{
    return CProtectionRequestList::IsSfcIgnoredStoreSubdir(pwsz);
}

BOOL
SxspConstructProtectionList()
{
    CProtectionRequestList *pTemp = NULL;
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    //
    // This only gets called once, if they know what's good for them.
    //
    ASSERT(!g_ProtectionRequestList);

    //
    // Construct - this should never fail, but if it does, there's trouble.
    //
    pTemp = new (&p_bProtectionListBuffer) CProtectionRequestList;
    if (!pTemp)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS: %s() - Failed placement new of CProtectionRequestList????\n", __FUNCTION__);
        ::FusionpSetLastWin32Error(FUSION_WIN32_ALLOCFAILED_ERROR);
        TRACE_WIN32_FAILURE_ORIGINATION(new(CProtectionRequestList));
        goto Exit;
    }
    IFW32FALSE_EXIT(pTemp->Initialize());

    g_ProtectionRequestList = pTemp;
    pTemp = NULL;

    //
    // Create our logon event.
    //
    IFW32NULL_EXIT(g_hSxsLoginEvent = CreateEventW(NULL, TRUE, FALSE, NULL));

    fSuccess = TRUE;
Exit:

    if (pTemp)
    {
        //
        // If this is still set, then something failed somewhere in the construction
        // code for the protection system.  We don't want to delete it, per-se, but
        // we need to just null out everything.
        //
        g_ProtectionRequestList = NULL;
        pTemp = NULL;
        g_hSxsLoginEvent = NULL;
    }

    return fSuccess;
}



BOOL WINAPI
SxsProtectionNotifyW(
    PVOID   pvCookie,
    PCWSTR  wsChangeText,
    SIZE_T  cchChangeText,
    DWORD   dwChangeAction
    )
{
    BOOL fSuccess;

#if YOU_ARE_HAVING_ANY_WIERDNESS_WITH_SFC_AND_SXS
    fSuccess = TRUE;
    return TRUE;
#else

    if (::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_FILECHANGENOT))
    {
        const USHORT Length = (cchChangeText > UNICODE_STRING_MAX_CHARS) ? UNICODE_STRING_MAX_BYTES : ((USHORT) (cchChangeText * sizeof(WCHAR)));
        const UNICODE_STRING u = { Length, Length, const_cast<PWSTR>(wsChangeText) };

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_FILECHANGENOT,
            "[%lx.%lx: %wZ] SXS FCN (cookie, action, text): %p, %lu, \"%wZ\"\n",
            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
            HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
            &NtCurrentPeb()->ProcessParameters->ImagePathName,
            pvCookie,
            dwChangeAction,
            &u);
    }

    //
    // If we're not accepting notifications, then quit out immediately.
    //
    if (!s_fIsSfcAcceptingNotifications)
    {
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // Having done this in the wrong order is also a Bad Bad Thing
    //
    ASSERT2_NTC(g_ProtectionRequestList != NULL, "SXS.DLL: Protection - Check order of operations, g_ProtectionRequestList is invalid!!\n");

    //
    // Let's not take down winlogon, shall we?
    //
    __try
    {
        fSuccess = g_ProtectionRequestList->AddRequest(
            (PSXS_PROTECT_DIRECTORY)pvCookie,
            wsChangeText,
            cchChangeText,
            dwChangeAction);
    }
    __except(SXS_SFC_EXCEPTION_SETTING)
    {
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
#endif
}

BOOL
CProtectionRequestList::ProtectionManifestThreadProcNoSEH(LPVOID pvParam)
{
    BOOL fSuccess = FALSE;
    CProtectionRequestList *pThis;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(pvParam != NULL);

    pThis = reinterpret_cast<CProtectionRequestList*>(pvParam);
    IFW32FALSE_EXIT(pThis->ProtectionManifestThreadProcWrapped());
    fSuccess = TRUE;
Exit:
    return fSuccess;
}


DWORD
CProtectionRequestList::ProtectionManifestThreadProc(LPVOID pvParam)
{
    BOOL fSuccess = FALSE;
    __try
    {
        fSuccess = ProtectionManifestThreadProcNoSEH(pvParam);
    }
    __except(SXS_SFC_EXCEPTION_SETTING)
    {
        //
        // Whoops..
        //
    }

    return static_cast<DWORD>(fSuccess);
}


BOOL
CProtectionRequestList::ProtectionManifestSingleManifestWorker(
    const CStringListEntry *pEntry
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer       sbAssemblyDirectoryName;
    CStringBuffer       sbManifestPath;
    CAssemblyRecoveryInfo RecoverInfo;
    SxsRecoveryResult RecoverResult;
    HashValidateResult HashValidResult;
    BOOL fCatalogPresent = FALSE;
	bool fNoAssembly;

    PARAMETER_CHECK(pEntry);

    //
    // Calculate the name of the assembly based on the middling part of
    // the string
    //
    IFW32FALSE_EXIT(sbAssemblyDirectoryName.Win32Assign(pEntry->m_sbText));
    IFW32FALSE_EXIT(sbAssemblyDirectoryName.Win32RemoveFirstPathElement());
    IFW32FALSE_EXIT(sbAssemblyDirectoryName.Win32ClearPathExtension());

    if (sbAssemblyDirectoryName.Cch() == 0)
        FN_SUCCESSFUL_EXIT();

    //
    // Try mashing this into an assembly name/recovery info
    //
	IFW32FALSE_EXIT(RecoverInfo.AssociateWithAssembly(sbAssemblyDirectoryName, fNoAssembly));

	// If we couldn't figure out what this was for, we have to ignore it.
	if (fNoAssembly)
	{
#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: %s() - File \"%ls\" in the manifest directory modified, but could not be mapped to an assembly.  IGNORING.\n",
            __FUNCTION__,
            static_cast<PCWSTR>(pEntry->m_sbText));
#endif

        FN_SUCCESSFUL_EXIT();
    }

    //
    // Now that we have the recovery info..
    //
    if (!RecoverInfo.GetHasCatalog())
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: %s() - Assembly %ls was in the registry, but without a catalog so we aren't protecting it\n",
            __FUNCTION__,
            static_cast<PCWSTR>(sbAssemblyDirectoryName));
#endif

		FN_SUCCESSFUL_EXIT();
    }

    //
    // Resolve the manifest path, then validate
    //
    IFW32FALSE_EXIT(::SxspResolveAssemblyManifestPath(sbAssemblyDirectoryName, sbManifestPath));

    IFW32FALSE_EXIT(
        ::SxspVerifyFileHash(
            SVFH_RETRY_LOGIC_SIMPLE,
            sbManifestPath,
            RecoverInfo.GetSecurityInformation().GetManifestHash(),
            CALG_SHA1,
            HashValidResult));
    
    IFW32FALSE_EXIT(::SxspEnsureCatalogStillPresentForManifest(sbManifestPath, fCatalogPresent));

    //
    // Reinstall needed?
    //
    if ((HashValidResult != HashValidate_Matches) || !fCatalogPresent)
        IFW32FALSE_EXIT(this->PerformRecoveryOfAssembly(RecoverInfo, NULL, RecoverResult));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
CProtectionRequestList::ProtectionManifestThreadProcWrapped()
{

    BOOL                fSuccess = FALSE;
    BOOL                bFoundItemsThisTimeAround;
    CStringListEntry    *pNextItem = NULL;
    DWORD               dwWaitResult;

    FN_TRACE_WIN32(fSuccess);

    bFoundItemsThisTimeAround = FALSE;

    do
    {
        //
        // Yes, mother, we hear you.
        //
        ResetEvent(m_hManifestEditHappened);

        //
        // Pull the next thing off the list and service it.
        //
        while (pNextItem = (CStringListEntry*)SxspInterlockedPopEntrySList(&m_ManifestEditList))
        {
            bFoundItemsThisTimeAround = TRUE;

            if (!this->ProtectionManifestSingleManifestWorker(pNextItem))
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - Processing work item %p failed\n", __FUNCTION__, pNextItem);

            FUSION_DELETE_SINGLETON(pNextItem);
        }

        //
        // Loaf about for a bit and see if anyone else has stuff for us to do
        //
        dwWaitResult = ::WaitForSingleObject(m_hManifestEditHappened, 3000);
        if (dwWaitResult == WAIT_TIMEOUT)
        {
            ::SxspInterlockedExchange(&m_ulIsAThreadServicingManifests, 0);
            break;
        }
        else if (dwWaitResult == WAIT_OBJECT_0)
        {
            continue;
        }
        else
        {
            TRACE_WIN32_FAILURE_ORIGINATION(WaitForSingleObject);
            goto Exit;
        }

    }
    while (true);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}




BOOL
CProtectionRequestList::ProtectionNormalThreadProcWrapped(
    CProtectionRequestRecord *pRequestRecord
    )
{
    BOOL                        fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CProtectionRequestRecord    &rRequest = *pRequestRecord;
    CProtectionRequestList      *pRequestList = rRequest.GetParent();

    BOOL                        fNeedsReinstall = FALSE;
    BOOL                        fAssemblyNotFound = FALSE;

    DWORD                       dwAsmPathAttribs;

    SxsRecoveryResult           RecoverResult;

    CSmallStringBuffer          buffFullPathOfChange;
    CSmallStringBuffer          buffAssemblyStore;
    CSmallStringBuffer          buffAssemblyRelativeChange;

    bool fNoAssembly;


    //
    // The request's key value contains the full path of the assembly that
    // is being modified, in theory.  So, we can just use it locally.
    //
    CStringBuffer rbuffAssemblyDirectoryName;  
    const CBaseStringBuffer &rbuffAssemblyPath = rRequest.GetChangeBasePath();
    CAssemblyRecoveryInfo &rRecoveryInfo = rRequest.GetRecoveryInfo();
    CSecurityMetaData &rSecurityMetaData = rRecoveryInfo.GetSecurityInformation();

    //
    // this name could be changes because the assemblyName in the request could be a short name,
    // in this case, we need reset the AssemblyName in rRequest
    //
    IFW32FALSE_EXIT(rbuffAssemblyDirectoryName.Win32Assign(rRequest.GetAssemblyDirectoryName()));
   
    //
    // This value should not change at all during this function.  Save it here.
    //
    IFW32FALSE_EXIT(rRequest.GetAssemblyStore(buffAssemblyStore));

    //
    // The big question of the day - find out the recovery information for this
    // assembly.  See if there was a catalog at installation time (a) or find out
    // whether or not there is a catalog for it right now.
    //
    IFW32FALSE_EXIT(rRecoveryInfo.AssociateWithAssembly(rbuffAssemblyDirectoryName, fNoAssembly));

    // If we couldn't figure out what assembly this was for, we ignore it.
    if (fNoAssembly)
        FN_SUCCESSFUL_EXIT();

    //
    // if rbuffAssemblyName is different from the assemblyname from rRequest, 
    // it must be a short name, we must reset the AssemblyName in rRequest
    //
    StringComparisonResult scr;
    IFW32FALSE_EXIT(rbuffAssemblyDirectoryName.Win32Compare(rRequest.GetAssemblyDirectoryName(), rRequest.GetAssemblyDirectoryName().Cch(), scr, NORM_IGNORECASE));
    if (scr != eEquals)
        IFW32FALSE_EXIT(rRequest.SetAssemblyDirectoryName(rbuffAssemblyDirectoryName));

	if (rRecoveryInfo.GetInfoPrepared() == FALSE)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(RecoveryInfoCouldNotBePrepared, ERROR_PATH_NOT_FOUND);

    if (!rRecoveryInfo.GetHasCatalog())
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INFO,
            "SXS.DLL: %s - Assembly %ls not registered with catalog, WFP ignoring it.\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffAssemblyDirectoryName));
#endif
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // See if it still exists...
    //
    dwAsmPathAttribs = ::GetFileAttributesW(rbuffAssemblyPath);
    if (dwAsmPathAttribs == INVALID_FILE_ATTRIBUTES)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: WFP reinstalling assembly because GetFileAttributesW(\"%ls\") failed with win32 error %ld\n",
            static_cast<PCWSTR>(rbuffAssemblyPath),
            ::FusionpGetLastWin32Error());

        fNeedsReinstall = TRUE;
        goto DoReinstall;
    }
    //
    // Otherwise, is it maybe not a directory for one reason or another?
    //
    else if (!(dwAsmPathAttribs & FILE_ATTRIBUTE_DIRECTORY))
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL:%s - %ws isn't a directory, we should attempt to remove it?\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffAssemblyPath));
#endif
        FN_SUCCESSFUL_EXIT();
    }


    //
    // Find out whether or not the file is still OK by checking against the manifest
    //
    {
        HashValidateResult HashValid;
        CStringBuffer      buffManifestFullPath;
        BOOL               fPresent;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory( buffFullPathOfChange ) );
        IFW32FALSE_EXIT(::SxspCreateManifestFileNameFromTextualString(
            0,
            SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
            buffFullPathOfChange,
            rSecurityMetaData.GetTextualIdentity(),
            buffManifestFullPath) );

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_WFP,
            "SXS.DLL:%s - Checking to see if manifest %ls is OK\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffManifestFullPath));
#endif

        IFW32FALSE_EXIT(::SxspVerifyFileHash(
            SVFH_RETRY_LOGIC_SIMPLE,
            buffManifestFullPath,
            rSecurityMetaData.GetManifestHash(),
            CALG_SHA1,
            HashValid));

#if DBG
        FusionpDbgPrintEx( FUSION_DBG_LEVEL_WFP,
            "SXS.DLL:%s - Manifest %ls checks %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffManifestFullPath),
            SxspHashValidateResultToString(HashValid) );
#endif

        if ( HashValid != HashValidate_Matches )
        {
            fNeedsReinstall = TRUE;
            goto DoReinstall;
        }

        //
        // Let's just ensure the catalog is there - it's not necessary anymore
        // for the protection pass, but it should be there if someone wants to
        // repackage the assembly for distribution.
        //
        IFW32FALSE_EXIT(::SxspEnsureCatalogStillPresentForManifest(buffManifestFullPath, fPresent));
        if ( !fPresent )
        {
            fNeedsReinstall = TRUE;
            goto DoReinstall;
        }
    }


    //
    // Now we can loop through the items in our list of things to be evaluated and
    // see if any of them are bad (or missing, or whatever.)
    //
    // Start out by touching the thing that indicates the last time we spun through
    // here and looked at the file list.
    //
    while (!fNeedsReinstall)
    {
        const CMetaDataFileElement* pFileDataElement = NULL;
        HashValidateResult Valid = HashValidate_OtherProblems;
        BOOL fFileNotFound;

        if (!rRequest.PopNextFileChange(buffAssemblyRelativeChange))
        {
            break;
        }

        IFW32FALSE_EXIT(buffAssemblyRelativeChange.Win32RemoveFirstPathElement());

        //
        // The change here is really to the top level directory - don't
        // bother doing anything in this case.  Maybe we should catch
        // this beforehand so we don't do the work of parsing?
        //
        if (buffAssemblyRelativeChange.Cch() == 0)
        {
            continue;
        }


        //
        // Acquire the security data
        //
        IFW32FALSE_EXIT( rSecurityMetaData.GetFileMetaData(
            buffAssemblyRelativeChange,
            pFileDataElement ) );

        //
        // There wasn't any data for this file?  Means we don't know about the file, so we
        // probably should do /something/ about it.  For now, however, with the agreeance of
        // the backup team, we let sleeping files lie.
        if ( pFileDataElement == NULL )
        {
            // 
            // because short-filename is not stored in registry, so for a filename, which might be long-pathname
            // or a short pathname, if we try out all entries in the Registry and still can not find it, 
            // we assume it is a short filename. In this case, we would verify the assembly, if it is not intact, 
            // do reinstall for the assembly....
            //

            DWORD dwResult;           

            IFW32FALSE_EXIT(::SxspValidateEntireAssembly(
                SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING, 
                rRecoveryInfo,
                dwResult));

            fNeedsReinstall = ( dwResult != SXS_VALIDATE_ASM_FLAG_VALID_PERFECT );
            goto DoReinstall;
        }

        //
        // And build the full path of the change via:
        //
        // sbAssemblyPath + \ + buffAssemblyRelativeChange
        //
        IFW32FALSE_EXIT(buffFullPathOfChange.Win32Assign(rbuffAssemblyPath));
        IFW32FALSE_EXIT(buffFullPathOfChange.Win32AppendPathElement(buffAssemblyRelativeChange));

        //
        // We really should check the return value here, but the
        // function is smart enough to set Valid to something useful
        // before returning.  A failure here should NOT be an IFW32FALSE_EXIT
        // call, mostly because we don't want to stop protecting this
        // assembly just because it failed with a FILE_NOT_FOUND or other
        // such.
        //
        IFW32FALSE_EXIT_UNLESS(::SxspValidateAllFileHashes(
            *pFileDataElement,
            buffFullPathOfChange,
            Valid ),
            FILE_OR_PATH_NOT_FOUND(::FusionpGetLastWin32Error()),
            fFileNotFound );

        if ( ( Valid != HashValidate_Matches ) || fFileNotFound )
        {
            fNeedsReinstall = TRUE;
            goto DoReinstall;
        }

    } /* while */



DoReinstall:
    //
    // If somewhere along the line we were supposed to reinstall, then we
    // do so.
    //
    if (fNeedsReinstall)
    {
        //
        // We have to indicate that all changes from point A to point B need
        // to be ignored.
        //
        rRequest.MarkInRecoveryMode(TRUE);
        PerformRecoveryOfAssembly(rRecoveryInfo, NULL, RecoverResult);
        rRequest.ClearList();
        rRequest.MarkInRecoveryMode(FALSE);

        //
        // HACKHACK jonwis 1/20/2001 - Stop failing assertions because lasterror
        // is set wrong by one of the above.
        //
        ::FusionpSetLastWin32Error(0);
    }

    fSuccess = TRUE;
Exit:
    const DWORD dwLastErrorSaved = ::FusionpGetLastWin32Error();

    //
    // We are done - this always succeeds.  The explanation is hairy.
    //
    if (pRequestList->AttemptRemoveItem(&rRequest))
    {
        ::FusionpSetLastWin32Error(dwLastErrorSaved);
    }
    else
    {
        if (!fSuccess)
        {
            // This seems bad that we're losing the original failure; let's at least spew it.
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s() losing original win32 error code of %d; replaced with %d from CProtectionRequestList::AttemptRemoveItem() call.\n",
                __FUNCTION__,
                dwLastErrorSaved,
                ::FusionpGetLastWin32Error());
        }

        fSuccess = FALSE;
    }

    return fSuccess;
}


BOOL WINAPI
SxsProtectionUserLogonEvent()
{
    return SetEvent(g_hSxsLoginEvent);
}

BOOL WINAPI
SxsProtectionUserLogoffEvent()
{
    return ResetEvent(g_hSxsLoginEvent);
}



BOOL
CProtectionRequestList::PerformRecoveryOfAssembly(
    const CAssemblyRecoveryInfo &RecoverInfo,
    CRecoveryCopyQueue *pvPotentialQueue,
    SxsRecoveryResult &ResultOut
    )
{
	BOOL fSuccess = FALSE;
	FN_TRACE_WIN32(fSuccess);

    BOOL                    fFound = FALSE;
    CRecoveryJobTableEntry  *pNewEntry, **pExistingEntry;
	DWORD dwRecoveryLastError = ERROR_SUCCESS;

    IFALLOCFAILED_EXIT(pNewEntry = new CRecoveryJobTableEntry);
    IFW32FALSE_EXIT(pNewEntry->Initialize());

    {
        CSxsLockCriticalSection lock(m_cInstallerCriticalSection);
        IFW32FALSE_EXIT(lock.Lock());
        IFW32FALSE_EXIT(
            m_pInstallsTable->FindOrInsertIfNotPresent(
                RecoverInfo.GetAssemblyDirectoryName(),
                pNewEntry,
                &pExistingEntry,
                &fFound));
    }

    //
    // Great, it was either inserted or it was already there - if not already there,
    // then we'll take care if it.
    //
    if (!fFound)
    {
        BOOL fSuccess = FALSE;

        IFW32FALSE_EXIT(pNewEntry->StartInstallation());

        //
        // Perform the recovery.
        //
        fSuccess = ::SxspRecoverAssembly(RecoverInfo, pvPotentialQueue, ResultOut);

		if (!fSuccess)
			dwRecoveryLastError = ::FusionpGetLastWin32Error();

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_WFP,
            "SXS: %s() - RecoverAssembly returned Result = %ls, fSuccess = %s, LastError = 0x%08x\n",
            __FUNCTION__,
            SxspRecoveryResultToString(ResultOut),
            fSuccess ? "true" : "false",
            dwRecoveryLastError);
#endif

        //
        // Tell this entry that it's all done.  This releases the other people
        // that were waiting on the event to get done as well.
        //
        IFW32FALSE_EXIT(pNewEntry->InstallationComplete(fSuccess, ResultOut, dwRecoveryLastError));

        //
        // And now delete the item from the list.
        //
        {
            CSxsLockCriticalSection lock2(m_cInstallerCriticalSection);
            IFW32FALSE_EXIT(lock2.Lock());
            IFW32FALSE_EXIT(m_pInstallsTable->Remove(RecoverInfo.GetAssemblyDirectoryName()));
        }
    }
    else
    {
        DWORD dwLastError;
        IFW32FALSE_EXIT((*pExistingEntry)->WaitUntilCompleted(ResultOut, fSuccess, dwLastError));

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_WFP,
            "SXS: %s() - WaitUntilCompleted returned Result = %ls, fInstalledOk = %s, LastError = 0x%08x\n",
            __FUNCTION__,
            ::SxspRecoveryResultToString(ResultOut),
            fSuccess ? "true" : "false",
            dwLastError);
#endif

		dwRecoveryLastError = dwLastError;
    }

	if (dwRecoveryLastError != ERROR_SUCCESS)
		ORIGINATE_WIN32_FAILURE_AND_EXIT(RecoveryFailed, dwRecoveryLastError);

	fSuccess = TRUE;
Exit:
    return fSuccess;
}


VOID WINAPI
SxsProtectionEnableProcessing(BOOL fActivityEnabled)
{
    s_fIsSfcAcceptingNotifications = fActivityEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsoleaut.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsoleaut.cpp

Abstract:

    Implementation of helper functions called by oleaut32.dll to
    get type library and clsid isolation.

Author:

    Michael J. Grier (MGrier) 19-May-2000

Revision History:

  Jay Krell (JayKrell) November 2001
    fixed typelibrary redirection
    key typelibraries by guid only, then verify language

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "fusionhandle.h"

typedef const GUID * PCGUID;

extern "C"
{
extern const CLSID CLSID_PSDispatch;
extern const CLSID CLSID_PSAutomation;
};

HRESULT
FusionpWin32GetAssemblyDirectory(
    PCACTCTX_SECTION_KEYED_DATA askd,
    CBaseStringBuffer &         rbuf
    );

HRESULT
HrFusionpWin32GetAssemblyDirectory(
    PCACTCTX_SECTION_KEYED_DATA askd,
    CBaseStringBuffer &         rbuff
    );

BOOL
FusionpHasAssemblyDirectory(
    PCACTCTX_SECTION_KEYED_DATA askd
    );

inline
HRESULT
HrFusionpOleaut_CopyString(
    PWSTR       Buffer,
    SIZE_T *    BufferSize,
    PCWSTR      String,
    SIZE_T      Length
    )
{
    HRESULT hr;

    if (*BufferSize >= (Length + 1))
    {
        ::memcpy(Buffer, String, (Length * sizeof(WCHAR)));
        Buffer[Length] = L'\0';
        *BufferSize = Length;
        hr = NOERROR;
    }
    else
    {
        // Need ... more .... room!
        *BufferSize = (Length + 1);
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }
Exit:
    return hr;
}

inline
HRESULT
HrFusionpOleaut_GetTypeLibraryName(
    PCACTCTX_SECTION_KEYED_DATA askd,
    PCWSTR *                    ppsz,
    SIZE_T *                    pcch
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);
    ULONG cch;
    PCWSTR psz;

    if (ppsz != NULL)
        *ppsz = NULL;
    if (pcch != NULL)
        *pcch = 0;
    INTERNAL_ERROR_CHECK(askd != NULL);
    INTERNAL_ERROR_CHECK(ppsz != NULL);
    INTERNAL_ERROR_CHECK(pcch != NULL);

    PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION  Data = reinterpret_cast<PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION>(askd->lpData);

    if (Data->NameOffset == 0)
    {
        psz = NULL;
        cch = 0;
    }
    else
    {
        psz = reinterpret_cast<PCWSTR>(reinterpret_cast<ULONG_PTR>(askd->lpSectionBase) + Data->NameOffset);
        cch = Data->NameLength / sizeof(WCHAR);
        if (cch != 0 && psz[cch - 1] == 0)
            cch -= 1;
    }
    *ppsz = psz;
    *pcch = cch;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
HrFusionpOleaut_GetTypeLibraryFullPath(
    PCACTCTX_SECTION_KEYED_DATA askd,
    CBaseStringBuffer &         rbuff
    )
{
    FN_PROLOG_HR;
    PCWSTR TypeLibraryName = NULL;
    SIZE_T TypeLibraryNameLength = 0;
    HANDLE ActivationContextHandle = NULL;

    IFCOMFAILED_EXIT(HrFusionpOleaut_GetTypeLibraryName(askd, &TypeLibraryName, &TypeLibraryNameLength));
    IFW32FALSE_EXIT(FusionpGetActivationContextFromFindResult(askd, &ActivationContextHandle));
    IFW32FALSE_EXIT(FusionpSearchPath(
        FUSIONP_SEARCH_PATH_ACTCTX,
        NULL, // path to search
        TypeLibraryName,
        NULL, // extension
        rbuff,
        NULL, // offset to file part
        ActivationContextHandle
        ));

    FN_EPILOG;
}


#define FUSIONP_OLEAUT_HANDLE_FIND_ERROR() \
    do { \
        const DWORD dwLastError = ::FusionpGetLastWin32Error(); \
\
        if ((dwLastError == ERROR_SXS_KEY_NOT_FOUND) || (dwLastError == ERROR_SXS_SECTION_NOT_FOUND)) \
        { \
            hr = S_FALSE; \
            goto Exit; \
        } \
\
        hr = HRESULT_FROM_WIN32(dwLastError); \
        goto Exit; \
    } while(0)

EXTERN_C
HRESULT
STDAPICALLTYPE
SxsOleAut32MapReferenceClsidToConfiguredClsid(
    REFCLSID rclsidIn,
    CLSID *pclsidOut
    )
{
    HRESULT hr = NOERROR;
    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Data = NULL;

    askd.cbSize = sizeof(askd);

    if (!::FindActCtxSectionGuid(
            0,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
            &rclsidIn,
            &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }

    Data = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION) askd.lpData;

    if ((askd.ulDataFormatVersion != ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER) ||
        (askd.ulLength < sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)) ||
        (Data->Size < sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_SXS_INVALID_ACTCTXDATA_FORMAT);
        goto Exit;
    }

    // We should be clear to go now.
    if (pclsidOut != NULL)
        *pclsidOut = Data->ConfiguredClsid;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
SxspOleAut32RedirectTypeLibrary(
    LPCOLESTR szGuid,
    WORD wMaj,
    WORD wMin,
    LANGID langid,
    SIZE_T *pcchFileName,
    LPOLESTR rgFileName
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);

    GUID               Guid;
    CSmallStringBuffer buff;
    CFusionActCtxHandle ActCtxHandle;

    PARAMETER_CHECK(szGuid != NULL);
    PARAMETER_CHECK(pcchFileName != NULL);
    PARAMETER_CHECK((rgFileName != NULL) || (*pcchFileName));

    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION Data = NULL;

    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY  AssemblyRosterEntry = NULL;

    askd.cbSize = sizeof(askd);
    askd.hActCtx = NULL;

    IFW32FALSE_EXIT(SxspParseGUID(szGuid, ::wcslen(szGuid), Guid));
    if (!::FindActCtxSectionGuid(
        FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX
        | FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS
        | FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA,
        NULL,
        ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION,
        &Guid,
        &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }
    ActCtxHandle = askd.hActCtx; // ReleaseActCtx in destructor

    Data = (PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION) askd.lpData;

    if ((askd.ulDataFormatVersion != ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_FORMAT_WHISTLER) ||
        (askd.ulLength < sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION)) ||
        (Data->Size < sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_SXS_INVALID_ACTCTXDATA_FORMAT);
        goto Exit;
    }

    if (langid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
    {
        ULONG  LanguageLength = 0;
        PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemblyInformation = NULL;

        AssemblyInformation = reinterpret_cast<PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION>(askd.AssemblyMetadata.lpInformation);

        LanguageLength = (AssemblyInformation->LanguageLength / sizeof(WCHAR));
        if (LanguageLength != 0)
        {
            CSmallStringBuffer Cultures[2];
            PCWSTR LanguageString = NULL;

            // we should do bounds checking here against AssemblyMetadata.ulSectionLength
            LanguageString = reinterpret_cast<PCWSTR>(AssemblyInformation->LanguageOffset + reinterpret_cast<PCBYTE>(askd.AssemblyMetadata.lpSectionBase));

            IFW32FALSE_EXIT(SxspMapLANGIDToCultures(langid, Cultures[0], Cultures[1]));

            if (LanguageLength != 0 && LanguageString[LanguageLength - 1] == 0)
               LanguageLength -= 1;
            if (   !FusionpEqualStrings(LanguageString, LanguageLength, Cultures[0], Cultures[0].Cch(), true)
                && !FusionpEqualStrings(LanguageString, LanguageLength, Cultures[1], Cultures[1].Cch(), true)
                )
            {
               hr = S_FALSE;
               goto Exit;
            }
        }
    }
    if (wMaj != 0 || wMin != 0)
    {
        if (wMaj != Data->Version.Major)
        {
            hr = S_FALSE;
            goto Exit;
        }
        if (wMin > Data->Version.Minor)
        {
            hr = S_FALSE;
            goto Exit;
        }
    }

    IFCOMFAILED_EXIT(HrFusionpOleaut_GetTypeLibraryFullPath(&askd, buff));

    IFCOMFAILED_EXIT(
        HrFusionpOleaut_CopyString(
            rgFileName,
            pcchFileName,
            static_cast<PCWSTR>(buff),
            buff.Cch()
            ));
    hr = NOERROR;
Exit:
    return hr;
}

LANGID
FusionpLanguageIdFromLocaleId(
    LCID lcid
    )
{
    //
    // LANGIDFROMLCID does not actually remove non default sort.
    //
    LANGID Language = LANGIDFROMLCID(lcid);
    ULONG PrimaryLanguage = PRIMARYLANGID(Language);
    ULONG SubLanguage = SUBLANGID(Language);
    Language = MAKELANGID(PrimaryLanguage, SubLanguage);
    return Language;
}

EXTERN_C
HRESULT
STDAPICALLTYPE
SxsOleAut32RedirectTypeLibrary(
    LPCOLESTR szGuid,
    WORD wMaj,
    WORD wMin,
    LCID lcid,
    BOOL /*fHighest*/,
    SIZE_T *pcchFileName,
    LPOLESTR rgFileName
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);

    IFCOMFAILED_EXIT(hr = ::SxspOleAut32RedirectTypeLibrary(szGuid, wMaj, wMin, FusionpLanguageIdFromLocaleId(lcid), pcchFileName, rgFileName));
Exit:
    return hr;
}


HRESULT
HrFusionpOleaut_MapIIDToTLBID(
    REFIID  riid,
    PCGUID* ppctlbid
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);

    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Data;

    PARAMETER_CHECK(&riid != NULL);
    PARAMETER_CHECK(ppctlbid != NULL);

    *ppctlbid = NULL;
    askd.cbSize = sizeof(askd);

    if (!::FindActCtxSectionGuid(
            0,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
            &riid,
            &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }
    Data = reinterpret_cast<PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION>(askd.lpData);
    *ppctlbid = &Data->TypeLibraryId;

    hr = NOERROR;
Exit:
    return hr;
}

EXTERN_C
HRESULT
STDAPICALLTYPE
SxsOleAut32MapIIDToTLBPath(
    REFIID riid,
    SIZE_T cchBuffer,
    WCHAR *pBuffer,
    SIZE_T *pcchWrittenOrRequired
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);
    ACTCTX_SECTION_KEYED_DATA askd;
    PCGUID pctlbid = NULL;
    CSmallStringBuffer buff;
    CFusionActCtxHandle ActCtxHandle;

    PARAMETER_CHECK(&riid != NULL);
    PARAMETER_CHECK(pBuffer != NULL);
    PARAMETER_CHECK(pcchWrittenOrRequired != NULL);
    PARAMETER_CHECK(cchBuffer != 0);

    IFCOMFAILED_EXIT(hr = HrFusionpOleaut_MapIIDToTLBID(riid, &pctlbid));
    if (hr == S_FALSE)
    {
        goto Exit;
    }
    askd.cbSize = sizeof(askd);
    if (!::FindActCtxSectionGuid(
            FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX
            | FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION,
            pctlbid,
            &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }
    ActCtxHandle = askd.hActCtx; // ReleaseActCtx in destructor

    IFCOMFAILED_EXIT(HrFusionpOleaut_GetTypeLibraryFullPath(&askd, buff));

    //
    // We do not care about version or language in this case.
    //
    IFCOMFAILED_EXIT(
        HrFusionpOleaut_CopyString(
            pBuffer,
            pcchWrittenOrRequired,
            static_cast<PCWSTR>(buff),
            buff.Cch()
            ));

    hr = NOERROR;
Exit:
    return hr;
}

EXTERN_C
HRESULT
STDAPICALLTYPE
SxsOleAut32MapIIDToProxyStubCLSID(
    REFIID  riid,
    CLSID * pclsidOut
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);

    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Data;

    if (pclsidOut != NULL)
        *pclsidOut = GUID_NULL;
    PARAMETER_CHECK(&riid != NULL);
    PARAMETER_CHECK(pclsidOut != NULL);

    askd.cbSize = sizeof(askd);
    if (!::FindActCtxSectionGuid(
            0,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
            &riid,
            &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }
    Data = reinterpret_cast<PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION>(askd.lpData);

    *pclsidOut = Data->ProxyStubClsid32;

    //
    // There are only USUALLY two acceptable answers here.
    // (but there is one bit of code in oleaut32.dll that is
    // actually look for anything but these two.)
    //
    // CLSID_PSDispatch     {00020424-0000-0000-C000-000000000046}
    // CLSID_PSAutomation   {00020420-0000-0000-C000-000000000046}
    //
#if DBG
    {
        ULONG i;
        const static struct
        {
            const GUID * Guid;
            STRING       Name;
        } GuidNameMap[] = 
        {
            { NULL,                 RTL_CONSTANT_STRING("unknown") },
            { &CLSID_PSDispatch,    RTL_CONSTANT_STRING("CLSID_PSDispatch") },
            { &CLSID_PSAutomation,  RTL_CONSTANT_STRING("CLSID_PSAutomation") }
        };
        for (i = 1 ; i != RTL_NUMBER_OF(GuidNameMap) ; ++i)
            if (Data->ProxyStubClsid32 == *GuidNameMap[i].Guid)
                break;
        if (i == RTL_NUMBER_OF(GuidNameMap))
            i = 0;

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_VERBOSE | FUSION_DBG_LEVEL_INFO,
            "SXS: %s returning %Z\n",
            __FUNCTION__,
            &GuidNameMap[i].Name
            );
    }
#endif

    hr = NOERROR;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxssfcscan.cpp ===
#include "stdinc.h"
#include "windows.h"
#include "sxsapi.h"
#include "sxsprotect.h"
#include "sxssfcscan.h"
#include "wintrust.h"
#include "softpub.h"
#include "strongname.h"
#include "recover.h"

static GUID WintrustVerifyProviderV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;



BOOL
SxspValidateEntireAssembly(
    DWORD dwFlags,
    const CAssemblyRecoveryInfo &RecoverInfo,
    DWORD &dwResult
    )
{
    BOOL                        bSuccess = FALSE;
    const CSecurityMetaData     &rSecurityData = RecoverInfo.GetSecurityInformation();
    FN_TRACE_WIN32(bSuccess);

#define CHECKSHOULDSTOPFAIL { if (dwFlags & SXS_VALIDATE_ASM_FLAG_MODE_STOP_ON_FAIL) { bSuccess = TRUE; goto Exit; } }
#define ADDFLAG(result, test, flag) { if (test) { (result) |= (flag); } else CHECKSHOULDSTOPFAIL }

    ManifestValidationResult    ManifestValidity;
    CSecurityMetaData           SecurityMetaData;
    CStringBuffer               sbManifestPath;

    dwResult = 0;

    if (dwFlags == 0)
    {
        dwFlags = SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING;
        dwFlags |= (SXS_VALIDATE_ASM_FLAG_MODE_STOP_ON_FAIL);
    }

    IFINVALID_FLAGS_EXIT_WIN32(dwFlags,
        SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG |
        SXS_VALIDATE_ASM_FLAG_CHECK_FILES |
        SXS_VALIDATE_ASM_FLAG_CHECK_STRONGNAME |
        SXS_VALIDATE_ASM_FLAG_CHECK_CAT_STRONGNAME |
        SXS_VALIDATE_ASM_FLAG_MODE_STOP_ON_FAIL);

    //
    // Asking us to check the catalog when there's no catalog on the assembly
    // is a Bad Thing.  Perhaps this should just return TRUE with a missing catalog?
    //
    PARAMETER_CHECK(dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG);
    PARAMETER_CHECK(RecoverInfo.GetHasCatalog());

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS.DLL: %s() - Beginning protection scan of %ls, flags 0x%08x\n",
        __FUNCTION__,
        static_cast<PCWSTR>(RecoverInfo.GetAssemblyDirectoryName()),
        dwFlags);
#endif

    IFW32FALSE_EXIT(::SxspResolveAssemblyManifestPath(RecoverInfo.GetAssemblyDirectoryName(), sbManifestPath));

    //
    // If we're checking the catalog, then do it.  If the catalog is bad or
    // otherwise doesn't match the actual assembly, then we need to mark
    // ourselves as successful, then exit.
    //
    if (dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG)
    {
		IFW32FALSE_EXIT(::SxspValidateManifestAgainstCatalog(
            sbManifestPath,
            ManifestValidity,
            0));

#if DBG
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL:    Manifest Validity = %ls\n",
            SxspManifestValidationResultToString(ManifestValidity));
#endif

        ADDFLAG(
            dwResult,
            ManifestValidity == ManifestValidate_IsIntact,
            SXS_VALIDATE_ASM_FLAG_VALID_CATALOG);
    }


    //TODO: Problems - make sure that we validate the manifest against what's in the
    // registry.  Maybe we need a special mode of incorporating assemblies (over a manifest)
    // that will just fill out the security data and nothing else...
   
    //
    // Validate the strong name of the assembly first.
    //
    if (dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_STRONGNAME)
    {
        //
        // JW 3/19/2001 - Public keys are NO LONGER IN THE BUILD, and as such
        // this check is moot.
        //
        ADDFLAG(dwResult, TRUE, SXS_VALIDATE_ASM_FLAG_VALID_STRONGNAME);
    }

    //
    // Let's open the catalog and scour through it certificate-wise
    // looking for a strong name that matches up.
    //
    if (dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_CAT_STRONGNAME)
    {
        CStringBuffer sbCatalogName;
        CSmallStringBuffer sbTheorheticalStrongName;
        const CFusionByteArray &rbaSignerPublicKey = rSecurityData.GetSignerPublicKeyTokenBits();
        CPublicKeyInformation PublicKeyInfo;
        BOOL bStrongNameFoundInCatalog;

        IFW32FALSE_EXIT(sbCatalogName.Win32Assign(sbManifestPath));
        IFW32FALSE_EXIT(sbCatalogName.Win32ChangePathExtension(
            FILE_EXTENSION_CATALOG,
            FILE_EXTENSION_CATALOG_CCH,
            eAddIfNoExtension));

        if (!PublicKeyInfo.Initialize(sbCatalogName))
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            if ((dwLastError != ERROR_PATH_NOT_FOUND) &&
                 (dwLastError != ERROR_FILE_NOT_FOUND))
                 goto Exit;
        }

        IFW32FALSE_EXIT(
			::SxspHashBytesToString(
				rbaSignerPublicKey.GetArrayPtr(),
				rbaSignerPublicKey.GetSize(),
				sbTheorheticalStrongName));

        IFW32FALSE_EXIT(
			PublicKeyInfo.DoesStrongNameMatchSigner(
				sbTheorheticalStrongName,
				bStrongNameFoundInCatalog));

        ADDFLAG(dwResult, bStrongNameFoundInCatalog, SXS_VALIDATE_ASM_FLAG_VALID_CAT_STRONGNAME);
    }

    //
    // Now, scan through all the files that are listed in the manifest and
    // ensure that they're all OK.
    //
    if (dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_FILES)
    {
        CStringBuffer sbTempScanPath;
        CStringBuffer sbAsmRootDir;
        const CBaseStringBuffer &sbAssemblyName = RecoverInfo.GetAssemblyDirectoryName();
        CFileInformationTableIter ContentTableIter(const_cast<CFileInformationTable&>(rSecurityData.GetFileDataTable()));

        HashValidateResult hvResult;
        BOOL bAllFilesMatch = TRUE;
        BOOL fTempBoolean;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(sbAsmRootDir));

        for (ContentTableIter.Reset();
              ContentTableIter.More();
              ContentTableIter.Next())
        {
            //
            // Cobble together a path to scan for the file in, based on the
            // assembly root directory, the 'name' of the assembly (note:
            // we can't use this to go backwards to get an identity,
            // unfortunately), and the name of the file to be validated.
            //
            PCWSTR wsString = ContentTableIter.GetKey();
            CMetaDataFileElement &HashEntry = ContentTableIter.GetValue();

            IFW32FALSE_EXIT(sbTempScanPath.Win32Format( L"%ls\\%ls\\%ls",
                static_cast<PCWSTR>(sbAsmRootDir),
                static_cast<PCWSTR>(sbAssemblyName),
                wsString));

            IFW32FALSE_EXIT_UNLESS( ::SxspValidateAllFileHashes( 
                HashEntry, 
                sbTempScanPath,
                hvResult ),
                FILE_OR_PATH_NOT_FOUND(::FusionpGetLastWin32Error()),
                fTempBoolean );

            if ( ( hvResult != HashValidate_Matches ) || ( fTempBoolean ) )
            {
                bAllFilesMatch = FALSE;
            }

        }

        ADDFLAG(dwResult, bAllFilesMatch, SXS_VALIDATE_ASM_FLAG_VALID_FILES);
    }

    //
    // Phew - should be done doing everything the user wanted us to.
    //
    bSuccess = TRUE;
Exit:
#if DBG
    FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS.DLL: Done validating, result = 0x%08x, success = %d\n",
        dwResult,
        bSuccess);
#endif

    return bSuccess;

#undef CHECKSHOULDSTOPFAIL
}



//
// Single-shot scanning
//
BOOL
SxsProtectionPerformScanNowNoSEH(
    HWND hwProgressWindow,
    BOOL bValidate,
    BOOL bUIAllowed
    )
{
    BOOL                bSuccess = TRUE;
    FN_TRACE_WIN32(bSuccess);

    CFusionRegKey       hkInstallRoot;
    WCHAR               wcKeyNameBuffer[MAX_PATH];
    DWORD               cchKeyName;
    ULONG               ulRegOp;
    DWORD               dwKeyIndex;

    CStringBuffer       sbTemp;
    CStringBuffer       sbAssemblyDirectory, sbManifestPath;

    //
    // If we're scanning, then we don't want to bother sxs-sfc with changes,
    // now do we?
    //
    // REVIEW: Handy way to get around sfc-sxs... start a series of scans, and
    // insert 'bad' files into assemblies while we're scanning.
    //
    SxsProtectionEnableProcessing(FALSE);

    bSuccess = TRUE;

    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey( 0, KEY_READ, hkInstallRoot ));

    dwKeyIndex = 0;
    while (true)
    {
        ulRegOp = ::RegEnumKeyExW(
            hkInstallRoot,
            dwKeyIndex++,
            wcKeyNameBuffer,
            &(cchKeyName = NUMBER_OF(wcKeyNameBuffer)),
            NULL,
            NULL,
            NULL,
            NULL);

        ::FusionpSetLastWin32Error(ulRegOp);

        if (ulRegOp == ERROR_NO_MORE_ITEMS)
            break;
        else if (ulRegOp != ERROR_SUCCESS)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(RegEnumKeyExW, ulRegOp);
        else
        {
            CAssemblyRecoveryInfo ri;
            bool fHasAssociatedAssembly;

            IFW32FALSE_EXIT(sbTemp.Win32Assign(wcKeyNameBuffer, cchKeyName));
            IFW32FALSE_EXIT(ri.AssociateWithAssembly(sbTemp, fHasAssociatedAssembly));

            if (!fHasAssociatedAssembly)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS.DLL: %s() - We found the assembly %ls in the registry, but were not able to associate it with an assembly\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(sbTemp));
            }
            else if (!ri.GetHasCatalog())
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS.DLL: %s() - Assembly %ls in registry, no catalog, not validating.\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(sbTemp));
            }
            else
            {
                DWORD dwValidateMode, dwResult;
                SxsRecoveryResult RecoverResult;

                dwValidateMode = SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING;

                IFW32FALSE_EXIT(::SxspValidateEntireAssembly(
                    dwValidateMode,
                    ri,
                    dwResult));

                if (dwResult != SXS_VALIDATE_ASM_FLAG_VALID_PERFECT)
                {
#if DBG
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL:  %s() - Scan of %ls failed one or more, flagset 0x%08x\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(sbTemp),
                        dwResult);
#endif

                    IFW32FALSE_EXIT(
                        ::SxspRecoverAssembly(
                            ri,
                            NULL,
                            RecoverResult));

#if DBG
                    if (RecoverResult != Recover_OK)
                    {
                        FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_ERROR,
                            "SXS.DLL: %s() - Reinstallation of assembly %ls failed, status %ls\n",
                            static_cast<PCWSTR>(sbTemp),
                            SxspRecoveryResultToString(RecoverResult));
                    }
#endif
                }

            }
        }
    }

    bSuccess = TRUE;
Exit:
    return bSuccess;
}

BOOL
SxsProtectionPerformScanNow(
    HWND hwProgressWindow,
    BOOL bValidate,
    BOOL bUIAllowed
    )
{
    BOOL                bSuccess = TRUE;
    __try
    {
        bSuccess = ::SxsProtectionPerformScanNowNoSEH(hwProgressWindow, bValidate, bUIAllowed);
    }
    __except(SXSP_EXCEPTION_FILTER())
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: " __FUNCTION__ "(): Aborting scan, returning false - Exception!");
    }

    //
    // Always reenable sfc notifications!
    //
    ::SxsProtectionEnableProcessing(TRUE);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsprotect.h ===
#pragma once

#include "Sxsp.h"

//
// Turn this off to fail all manifests without catalogs during the parse!
//
#define SXS_LAX_MANIFEST_VALIDATION

//
// Warning - leaving this defined will --DISABLE-- WFP-SXS.
// Define it as FALSE if you want to turn it back on.
//
#define YOU_ARE_HAVING_ANY_WIERDNESS_WITH_SFC_AND_SXS FALSE
//
// For this checkin (11/23ish/2000), we'll be leaving it turned OFF
//
// #define YOU_ARE_HAVING_ANY_WIERDNESS_WITH_SFC_AND_SXS TRUE


//
// This stuff is private!
//
#include "hashfile.h"
#include "CAssemblyRecoveryInfo.h"
#include "recover.h"

BOOL
SxspResolveAssemblyManifestPath(
    const CBaseStringBuffer &rAsmDirectoryName,
    CBaseStringBuffer &rbsManifestPath
    );

BOOL
SxspIsSfcIgnoredStoreSubdir(
    PCWSTR pwszDir
    );


class CProtectionRequestList;
class CStringListEntry;
class CProtectionRequestRecord;

#include "HashFile.h"
#include "FusionHash.h"

class CStringListEntry : public CAlignedSingleListEntry
{
public:
    CStringListEntry() { }

    CStringBuffer   m_sbText;
private:
    CStringListEntry(const CStringListEntry &);
    void operator =(const CStringListEntry &);
};

#pragma warning(disable:4327)  // indirection alignment of LHS (16) is greater than RHS (8)
#pragma warning(disable:4328)  // indirection alignment of formal parameter 2 (16) is greater than the actual argument alignment (8)

class CProtectionRequestRecord
{
private:
    CStringBuffer                   m_sbAssemblyDirectoryName;
    CStringBuffer                   m_sbManifestPath;
    CStringBuffer                   m_sbAssemblyStore;
    CStringBuffer                   m_sbKeyValue;
    DWORD                           m_dwAction;
    PSXS_PROTECT_DIRECTORY          m_pvProtection;
    ULONG                           m_ulInRecoveryMode;
    CProtectionRequestList          *m_pParent;
    __declspec(align(16))
    SLIST_HEADER                    m_ListHeader;
    BOOL                            m_bIsManPathResolved;
    BOOL                            m_bInitialized;
    CAssemblyRecoveryInfo           m_RecoverInfo;

public:

    CProtectionRequestRecord();


    inline CProtectionRequestList *GetParent() const { return m_pParent; }
    inline CAssemblyRecoveryInfo &GetRecoveryInfo() { return m_RecoverInfo; }
    inline const CAssemblyRecoveryInfo &GetRecoveryInfo() const { return m_RecoverInfo; }
    inline const CBaseStringBuffer &GetAssemblyDirectoryName() const { return m_sbAssemblyDirectoryName; }
    inline const CBaseStringBuffer &GetChangeBasePath() const { return m_sbKeyValue; }

    inline VOID SetParent(CProtectionRequestList *pParent) { m_pParent = pParent; };
    inline VOID MarkInRecoveryMode(BOOL inRecovery) { ::SxspInterlockedExchange( &m_ulInRecoveryMode, ( inRecovery ? 1 : 0 ) ); }
    inline VOID ClearList();

    inline BOOL GetManifestContent(CSecurityMetaData *&pSecurityData);
    inline BOOL SetAssemblyDirectoryName(const CBaseStringBuffer &rsbNewname) { return m_sbAssemblyDirectoryName.Win32Assign(rsbNewname); }
    inline BOOL GetManifestPath(CBaseStringBuffer &sbManPath);
    inline BOOL AddSubFile(const CBaseStringBuffer &sbThing);
    inline BOOL PopNextFileChange(CBaseStringBuffer &Dest);
    inline BOOL GetAssemblyStore(CBaseStringBuffer &Dest) { return Dest.Win32Assign(m_sbAssemblyStore); }

    inline BOOL Initialize(
        const CBaseStringBuffer &sbAssemblyName,
        const CBaseStringBuffer &sbKeyString,
        CProtectionRequestList* ParentList,
        PVOID                   pvRequestRecord,
        DWORD                   dwAction
        );

    ~CProtectionRequestRecord();

private:
    CProtectionRequestRecord(const CProtectionRequestRecord &);
    void operator =(const CProtectionRequestRecord &);
};

class CRecoveryJobTableEntry
{
public:
    CRecoveryJobTableEntry()
        : m_Result(Recover_Unknown), m_dwLastError(ERROR_SUCCESS),  m_fSuccessValue(TRUE),
          m_Subscriber(0), m_EventInstallingAssemblyComplete(INVALID_HANDLE_VALUE)
    { }

    SxsRecoveryResult   m_Result;
    DWORD               m_dwLastError;
    BOOL                m_fSuccessValue;
    ULONG               m_Subscriber;
    HANDLE              m_EventInstallingAssemblyComplete;

    BOOL Initialize();
    BOOL StartInstallation();
    BOOL InstallationComplete( BOOL bDoneOk, SxsRecoveryResult Result, DWORD dwLastError );

    BOOL WaitUntilCompleted( SxsRecoveryResult &rResult, BOOL &rbSucceededValue, DWORD &rdwErrorResult );

    ~CRecoveryJobTableEntry();
private:
    CRecoveryJobTableEntry(const CRecoveryJobTableEntry &);
    void operator =(const CRecoveryJobTableEntry &);
};

class CProtectionRequestList : public CCleanupBase
{
private:
    typedef CCaseInsensitiveUnicodeStringPtrTable<CProtectionRequestRecord> COurInternalTable;
    typedef CCaseInsensitiveUnicodeStringPtrTableIter<CProtectionRequestRecord> COurInternalTableIter;
    typedef CCaseInsensitiveUnicodeStringPtrTable<CRecoveryJobTableEntry> CInstallsInProgressTable;

    CRITICAL_SECTION    m_cSection;
    CRITICAL_SECTION    m_cInstallerCriticalSection;
    COurInternalTable   *m_pInternalList;
    CInstallsInProgressTable *m_pInstallsTable;

    //
    // Manifest edits are trickier, they get their own system of being handled.
    //
    __declspec(align(16))    
    SLIST_HEADER        m_ManifestEditList;
    HANDLE              m_hManifestEditHappened;
    ULONG               m_ulIsAThreadServicingManifests;
    PVOID               m_Padding;  // Required for win64 win S-Lists are 16 byte aligned

    static DWORD ProtectionNormalThreadProc( PVOID pvParam );
    static DWORD ProtectionManifestThreadProc( PVOID pvParam );
    static BOOL  ProtectionManifestThreadProcNoSEH( PVOID pvParam );

    inline BOOL ProtectionNormalThreadProcWrapped( CProtectionRequestRecord *pProtectionRequest );
    inline BOOL ProtectionManifestThreadProcWrapped();
    inline BOOL ProtectionManifestSingleManifestWorker( const CStringListEntry *pEntry );

    static PCWSTR m_arrIgnorableSubdirs[];
    static SIZE_T m_cIgnorableSubdirs;

    friend BOOL SxspConstructProtectionList();

    BOOL Initialize();

    CProtectionRequestList();

    BOOL PerformRecoveryOfAssembly(
        const CAssemblyRecoveryInfo &RecoverInfo,
        CRecoveryCopyQueue* pvPotentialQueue,
        SxsRecoveryResult &Result
        );

    ~CProtectionRequestList();

public:
    static BOOL IsSfcIgnoredStoreSubdir( PCWSTR wsz );
    void DeleteYourself() { this->~CProtectionRequestList(); }
    VOID ClearProtectionItems(CProtectionRequestRecord *Asm) { FUSION_DELETE_SINGLETON( Asm ); }

    BOOL AttemptRemoveItem( CProtectionRequestRecord *AttemptRemoval );
    BOOL AddRequest( PSXS_PROTECT_DIRECTORY pProtect, PCWSTR pcwszDirName, SIZE_T cchName, DWORD dwAction );

private:
    CProtectionRequestList(const CProtectionRequestList &);
    void operator =(const CProtectionRequestList &);
};

VOID
SxsProtectionEnableProcessing(
    BOOL bActivityEnabled
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsuninstall.h ===
asdfasdf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxssfcscan.h ===
#pragma once


#define SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG         ( 0x00000001 )
#define SXS_VALIDATE_ASM_FLAG_CHECK_FILES           ( 0x00000002 )
#define SXS_VALIDATE_ASM_FLAG_CHECK_STRONGNAME      ( 0x00000004 )
#define SXS_VALIDATE_ASM_FLAG_CHECK_CAT_STRONGNAME  ( 0x00000008 )
#define SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING      ( 0x0000000F )

#define SXS_VALIDATE_ASM_FLAG_MODE_STOP_ON_FAIL     ( 0x00000100 )

#define SXS_VALIDATE_ASM_FLAG_VALID_CATALOG         SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG
#define SXS_VALIDATE_ASM_FLAG_VALID_FILES           SXS_VALIDATE_ASM_FLAG_CHECK_FILES
#define SXS_VALIDATE_ASM_FLAG_VALID_STRONGNAME      SXS_VALIDATE_ASM_FLAG_CHECK_STRONGNAME
#define SXS_VALIDATE_ASM_FLAG_VALID_CAT_STRONGNAME  SXS_VALIDATE_ASM_FLAG_CHECK_CAT_STRONGNAME
#define SXS_VALIDATE_ASM_FLAG_VALID_PERFECT         SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING

BOOL
SxspValidateEntireAssembly(
    DWORD dwFlags,
    const CAssemblyRecoveryInfo &RecoverInfo,
    DWORD &dwResult
    );

//
// Single-shot scanning
//
BOOL
SxsProtectionPerformScanNow(
    HWND hwProgressWindow,
    BOOL bValidate,
    BOOL bUIAllowed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsuninstall.cpp ===
#include "stdinc.h"
#include "sxsapi.h"
#include "recover.h"
#include "sxsinstall.h"

BOOL
pDeleteFileOrDirectoryHelper(
    IN const CBaseStringBuffer &rcbuffFileName
    )
/*++

Purpose:

    When you need a filesystem object gone, call us.

Parameters:

    The absolute name of the thing being killed.

Returns:

    TRUE if the object was deleted, false if it (or any subobjects) wasn't.

--*/
{
    //
    // Maybe this is a directory.  Trying this won't hurt.
    //
    if ( !SxspDeleteDirectory(rcbuffFileName) )
    {
        //
        // Clear the attributes
        //
        SetFileAttributesW(rcbuffFileName, FILE_ATTRIBUTE_NORMAL);
        return DeleteFileW(rcbuffFileName);
    }
    else
    {
        return TRUE;
    }
}


BOOL
pRemovePotentiallyEmptyDirectory(
    IN const CBaseStringBuffer &buffDirName
    )
{
    FN_PROLOG_WIN32
    
    DWORD dwAttribs = ::GetFileAttributesW(buffDirName);

    if (dwAttribs == INVALID_FILE_ATTRIBUTES)
    {
        DWORD dwLastError = ::FusionpGetLastWin32Error();

        switch (dwLastError)
        {
        case ERROR_SUCCESS:
            dwLastError = ERROR_INTERNAL_ERROR; // bogus?!?
            break;

        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
            dwLastError = ERROR_SUCCESS;
            break;
        }

        if (dwLastError != ERROR_SUCCESS)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributesW, dwLastError);

        dwAttribs = 0;
    }

    //
    // Were we able to find this directory?
    //
    if (dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
    {
        BOOL fDumpBoolean;

        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS(
            ::SetFileAttributesW(
                buffDirName,
                FILE_ATTRIBUTE_NORMAL),
            FILE_OR_PATH_NOT_FOUND(::FusionpGetLastWin32Error()),
            fDumpBoolean);

        if (!fDumpBoolean)
        {
            IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS2(
                ::RemoveDirectoryW(buffDirName),
                LIST_4(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_DIR_NOT_EMPTY, ERROR_SHARING_VIOLATION),
                fDumpBoolean);
        }            
    }

    FN_EPILOG
}



BOOL
pCleanUpAssemblyData(
    IN  const PCASSEMBLY_IDENTITY pcAsmIdent, 
    OUT BOOL  &rfWasRemovedProperly
    )
/*++

Purpose:

    Deletes registry and filesystem information about the assembly indicated.
    Removes installation data from the registry first, so as to avoid SFP
    interactions.

Parameters:

    pcAsmIdent          - Identity of the assembly to be destroyed

    rfWasRemovedProperly- Flag to indicate whether or not all the assembly
                          data was actually removed.


Returns:

    FALSE if "anything bad" happened while deleting registry data.  See
    rfWasRemovedProperly for actual status.

--*/
{
    FN_PROLOG_WIN32

    BOOL                fDumpBoolean;
    BOOL                fPolicy;
    CSmallStringBuffer  buffSxsStore;
    CStringBuffer       buffScratchSpace;
    CFusionRegKey       hkAsmInstallInfo;
    CFusionRegKey       hkSingleAsmInfo;

    //
    // Cleanup happens in two phases:
    //
    // 1 - The registry data is whacked from rhkAsmInstallInfo.  Since we're
    //     uninstalling an assembly, there's no reason to keep anything in it,
    //     especially because it's got no references.  Use DestroyKeyTree and
    //     then DeleteKey to remove it.
    //
    // 2 - Delete as many of the on-disk files as possible, esp. the manifest
    //     and catalog.
    //

    PARAMETER_CHECK(pcAsmIdent != NULL);

    //
    // Start this out at true, we'll call it false later on.
    //
    rfWasRemovedProperly = TRUE;

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(pcAsmIdent, fPolicy));
    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffSxsStore));

    //
    // Bye-bye to the registry first
    //
    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0 , KEY_ALL_ACCESS, hkAsmInstallInfo));
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(pcAsmIdent, buffScratchSpace));
    IFW32FALSE_EXIT(hkAsmInstallInfo.OpenSubKey(hkSingleAsmInfo, buffScratchSpace, KEY_ALL_ACCESS, 0));
    if ( hkSingleAsmInfo != CFusionRegKey::GetInvalidValue() )
    {
        //
        // Failure here isn't so bad...
        //
        IFW32FALSE_EXIT_UNLESS2(
            hkSingleAsmInfo.DestroyKeyTree(),
            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
            fDumpBoolean);

        if ( !fDumpBoolean )
        {
            IFW32FALSE_EXIT_UNLESS2(
                hkAsmInstallInfo.DeleteKey(buffScratchSpace),
                LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                fDumpBoolean);
        }

    }

    //
    // Both policies and normal assemblies have a manifest and catalog.
    //
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            0,
            fPolicy ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
            buffSxsStore,
            buffSxsStore.Cch(),
            pcAsmIdent,
            buffScratchSpace));

    rfWasRemovedProperly = rfWasRemovedProperly && ::pDeleteFileOrDirectoryHelper(buffScratchSpace);

    IFW32FALSE_EXIT(buffScratchSpace.Win32ChangePathExtension(
        FILE_EXTENSION_CATALOG,
        FILE_EXTENSION_CATALOG_CCH,
        eErrorIfNoExtension));

    rfWasRemovedProperly = rfWasRemovedProperly && pDeleteFileOrDirectoryHelper(buffScratchSpace);

    //
    // Clean up data
    //
    if (!fPolicy)
    {
        //
        // This just poofs the assembly member files.
        // If the delete fails, we'll try to rename the directory to something else.
        //
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                buffSxsStore,
                buffSxsStore.Cch(),
                pcAsmIdent,
                buffScratchSpace));

        rfWasRemovedProperly = rfWasRemovedProperly && ::pDeleteFileOrDirectoryHelper(buffScratchSpace);
    }
    else
    {
        //
        // The policy file above should already have been deleted, so we should
        // attempt to remove the actual policy directory if it's empty.  The
        // directory name is still in buffScratchSpace, if we just yank off the
        // last path element.
        //
        buffScratchSpace.RemoveLastPathElement();
        rfWasRemovedProperly = rfWasRemovedProperly && ::pRemovePotentiallyEmptyDirectory(buffScratchSpace);

    }


    //
    // Once we've killed all the assembly information, if the Manifests or the
    // Policies directory is left empty, go clean them up as well.
    //
    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffScratchSpace));
    IFW32FALSE_EXIT(buffScratchSpace.Win32AppendPathElement(
        (fPolicy? POLICY_ROOT_DIRECTORY_NAME : MANIFEST_ROOT_DIRECTORY_NAME),
        (fPolicy? NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1 : NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1)));
    IFW32FALSE_EXIT(::pRemovePotentiallyEmptyDirectory(buffScratchSpace));

    FN_EPILOG
}


static inline bool IsCharacterNulOrInSet(WCHAR ch, PCWSTR set)
{
    return (ch == 0 || wcschr(set, ch) != NULL);
}

BOOL
pAnalyzeLogfileForUninstall(
    PCWSTR lpcwszLogFileName
    )
{
    FN_PROLOG_WIN32

    CFusionFile         File;
    CFileMapping        FileMapping;
    CMappedViewOfFile   MappedViewOfFile;
    PCWSTR              pCursor = NULL;
    ULONGLONG           ullFileSize, ullFileCharacters, ullCursorPos;
    const static WCHAR  wchLineDividers[] = { L'\r', L'\n', 0xFEFF, 0 };
    CStringBuffer       buffAssemblyIdentity, buffAssemblyReference;
    ULONG               ullPairsEncountered = 0;

    IFW32FALSE_EXIT(File.Win32CreateFile(lpcwszLogFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING));
    IFW32FALSE_EXIT(File.Win32GetSize(ullFileSize));
    ASSERT(ullFileSize % sizeof(WCHAR) == 0);
    ullFileCharacters = ullFileSize / sizeof(WCHAR);
    IFW32FALSE_EXIT(FileMapping.Win32CreateFileMapping(File, PAGE_READONLY));
    IFW32FALSE_EXIT(MappedViewOfFile.Win32MapViewOfFile(FileMapping, FILE_MAP_READ));
    pCursor = reinterpret_cast<PCWSTR>(static_cast<const VOID*>(MappedViewOfFile));

#define SKIP_BREAKERS while ((ullCursorPos < ullFileCharacters) && IsCharacterNulOrInSet(pCursor[ullCursorPos], wchLineDividers)) ullCursorPos++;
#define FIND_NEXT_BREAKER while ((ullCursorPos < ullFileCharacters) && !IsCharacterNulOrInSet(pCursor[ullCursorPos], wchLineDividers)) ullCursorPos++;
#define ENSURE_NOT_EOF if (ullCursorPos >= ullFileCharacters) break;
    
    for ( ullCursorPos = 0; ullCursorPos < ullFileCharacters; ++ullCursorPos )
    {
        PCWSTR pcwszIdentityStart, pcwszIdentityEnd, pcwszReferenceStart, pcwszReferenceEnd;
        SXS_UNINSTALLW Uninstall;
        CSmallStringBuffer buffIdentity, buffReference;

        SKIP_BREAKERS
        ENSURE_NOT_EOF
        
        pcwszIdentityStart = pCursor + ullCursorPos;
        
        FIND_NEXT_BREAKER
        ENSURE_NOT_EOF

        pcwszIdentityEnd = pCursor + ullCursorPos;

        SKIP_BREAKERS
        ENSURE_NOT_EOF

        pcwszReferenceStart = pCursor + ullCursorPos;

        FIND_NEXT_BREAKER
        ENSURE_NOT_EOF

        pcwszReferenceEnd = pCursor + ullCursorPos;

        ullPairsEncountered++;

        IFW32FALSE_EXIT(buffIdentity.Win32Assign(
            pcwszIdentityStart,
            pcwszIdentityEnd - pcwszIdentityStart));
        IFW32FALSE_EXIT(buffReference.Win32Assign(
            pcwszReferenceStart,
            pcwszReferenceEnd - pcwszReferenceStart));

        ZeroMemory(&Uninstall, sizeof(Uninstall));
        Uninstall.cbSize = sizeof(Uninstall);
        Uninstall.dwFlags = SXS_UNINSTALL_FLAG_REFERENCE_VALID | SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED;
        Uninstall.lpAssemblyIdentity = buffIdentity;
        Uninstall.lpInstallReference = reinterpret_cast<PCSXS_INSTALL_REFERENCEW>(static_cast<PCWSTR>(buffReference));
        IFW32FALSE_EXIT(::SxsUninstallW(&Uninstall, NULL));
    }

    PARAMETER_CHECK(ullPairsEncountered != 0);

    FN_EPILOG
    
}



BOOL
WINAPI
SxsUninstallW(
    IN  PCSXS_UNINSTALLW pcUnInstallData,
    OUT DWORD *pdwDisposition
    )
/*++

Parameters:

    pcUnInstallData - Contains uninstallation data about the assembly being
        removed from the system, including the calling application's reference
        to the assembly.

        cbSize      - Size, in bytes, of the structure pointed to by
                      pcUnInstallData

        dwFlags     - Indicates the state of the members of this reference,
                      showing which of the following fields are valid.
                      Allowed bitflags are:

                      SXS_UNINSTALL_FLAG_REFERENCE_VALID
                      SXS_UNINSTALL_FLAG_FORCE_DELETE

        lpAssemblyIdentity - Textual representation of the assembly's identity
                      as installed by the application.

        lpInstallReference - Pointer to a SXS_INSTALL_REFERENCEW structure
                      that contains the reference information for this
                      application.

    pdwDisposition  - Points to a DWORD that will return status about what was
                      done to the assembly; whether it was uninstalled or not,
                      and whether the reference given was removed.

Returns:

    TRUE if the assembly was able to be uninstalled, FALSE otherwise.  If the
    uninstall failed, lasterror is set to the probable cause.
    
--*/
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PCWSTR                      pcwszUninstallIdentity = NULL;
    PCSXS_INSTALL_REFERENCEW    pcInstallReference = NULL;
    CFusionRegKey               hkAllInstallInfo;
    CFusionRegKey               hkAsmInstallInfo;
    CFusionRegKey               hkReferences;
    CStringBuffer               buffAsmNameInRegistry;
    BOOL                        fDoRemoveActualBits = FALSE;

    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> AssemblyIdentity;

    if (pdwDisposition != NULL)
        *pdwDisposition = 0;

    //
    // The parameter must be non-null, and must have at least dwFlags and the 
    // assemblyidentity.  
    //
    PARAMETER_CHECK(pcUnInstallData != NULL);
    PARAMETER_CHECK(RTL_CONTAINS_FIELD(pcUnInstallData, pcUnInstallData->cbSize, dwFlags) &&    
        RTL_CONTAINS_FIELD(pcUnInstallData, pcUnInstallData->cbSize, lpAssemblyIdentity));

    //
    // Check flags
    //
    PARAMETER_CHECK((pcUnInstallData->dwFlags & 
        ~(SXS_UNINSTALL_FLAG_FORCE_DELETE | 
            SXS_UNINSTALL_FLAG_REFERENCE_VALID | 
            SXS_UNINSTALL_FLAG_USE_INSTALL_LOG | 
            SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED)) == 0);

    //
    // If you specify the uninstall log, then that's the only thing that can be set.  XOR
    // them together, so only one of the two will be set.
    //
    PARAMETER_CHECK(
        ((pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_USE_INSTALL_LOG) == 0) ||
        ((pcUnInstallData->dwFlags & (SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED|SXS_UNINSTALL_FLAG_REFERENCE_VALID|SXS_UNINSTALL_FLAG_FORCE_DELETE)) == 0));

    //
    // If the reference flag was set, then the member has to be present, and 
    // non-null as well.
    //
    PARAMETER_CHECK(((pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_VALID) == 0) ||
        (RTL_CONTAINS_FIELD(pcUnInstallData, pcUnInstallData->cbSize, lpInstallReference) &&
         (pcUnInstallData->lpInstallReference != NULL)));

    //
    // If the log file is not present, the assembly identity can't be a zero-length string, and it can't be null - it's
    // required.
    //
    
    
    PARAMETER_CHECK((pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_USE_INSTALL_LOG) || ((pcUnInstallData->lpAssemblyIdentity != NULL) && (pcUnInstallData->lpAssemblyIdentity[0] != UNICODE_NULL)));

    //
    // If the install log flag was set, then the member needs to be set and non-null
    //
    PARAMETER_CHECK(((pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_USE_INSTALL_LOG) == 0) ||
        (RTL_CONTAINS_FIELD(pcUnInstallData, pcUnInstallData->cbSize, lpInstallLogFile) &&
         ((pcUnInstallData->lpInstallLogFile != NULL) && (pcUnInstallData->lpInstallLogFile[0] != UNICODE_NULL))));

    if ( pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_USE_INSTALL_LOG )
    {
        IFW32FALSE_EXIT(pAnalyzeLogfileForUninstall(pcUnInstallData->lpInstallLogFile));
    }
    else
    {

        //
        // And the reference scheme must not be SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL,
        // as you can't "uninstall" OS-installed assemblies!
        //
        if (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_VALID)
        {
            if (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED)
            {
                PCWSTR pcwszReferenceString;
                PCWSTR pcwszEndOfString;
                GUID gTheGuid;
                
                pcwszReferenceString = reinterpret_cast<PCWSTR>(pcUnInstallData->lpInstallReference);

                //
                // Non-null, non-zero-length
                //
                PARAMETER_CHECK((pcwszReferenceString != NULL) && (pcwszReferenceString[0] != L'\0'));

                //
                // Parse the displayed guid.  If there's no _, then ensure that the guid
                // is not the os-installed guid.
                //
                pcwszEndOfString = wcschr(pcwszReferenceString, SXS_REFERENCE_CHUNK_SEPERATOR[0]);
                if ( pcwszEndOfString == NULL )
                {
                    pcwszEndOfString = pcwszReferenceString + ::wcslen(pcwszReferenceString);
                    IFW32FALSE_EXIT(
                        ::SxspParseGUID(
                            pcwszReferenceString,
                            pcwszEndOfString - pcwszReferenceString,
                            gTheGuid));
                    PARAMETER_CHECK(gTheGuid != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL);
                }
                
            }
            else
            {
                PARAMETER_CHECK(pcUnInstallData->lpInstallReference->guidScheme != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL);
            }                
        }

        //
        // Let's turn the identity back into a real identity object
        //
        IFW32FALSE_EXIT(
            ::SxspCreateAssemblyIdentityFromTextualString(
                pcUnInstallData->lpAssemblyIdentity,
                &AssemblyIdentity));

        IFW32FALSE_EXIT(
            ::SxspValidateIdentity(
                    SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED,
                ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                AssemblyIdentity));

        //
        // And go open the registry key that corresponds to it
        //
        IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(
            0, 
            KEY_ALL_ACCESS, 
            hkAllInstallInfo));
        IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(
            AssemblyIdentity, 
            buffAsmNameInRegistry));
        IFW32FALSE_EXIT(hkAllInstallInfo.OpenSubKey( 
            hkAsmInstallInfo, 
            buffAsmNameInRegistry,
            KEY_ALL_ACCESS,
            0));

        //
        // If the assembly didn't have registry data, then obviously nobody cares
        // about it at all.  Delete it with great vigor.
        //
        if (hkAsmInstallInfo == CFusionRegKey::GetInvalidValue())
        {
            fDoRemoveActualBits = TRUE;
        }
        else 
        {
            DWORD dwReferenceCount;
            BOOL fTempFlag = FALSE;

            //
            // We're going to need the references key in just a second...
            //
            IFW32FALSE_EXIT(
                hkAsmInstallInfo.OpenOrCreateSubKey(
                    hkReferences,
                    WINSXS_INSTALLATION_REFERENCES_SUBKEY,
                    KEY_ALL_ACCESS,
                    0, NULL, NULL));

            //
            // If we were given an uninstall reference, then attempt to remove it.
            //
            if (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_VALID)
            {
                SMARTPTR(CAssemblyInstallReferenceInformation) AssemblyReference;
                BOOL fWasDeleted = FALSE;

                //
                // Opened the references key OK?
                //
                if (hkReferences != CFusionRegKey::GetInvalidValue())
                {
                    IFW32FALSE_EXIT(AssemblyReference.Win32Allocate(__FILE__, __LINE__));

                    //
                    // Did the user precompute the reference string?
                    //
                    if (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED)
                        IFW32FALSE_EXIT(AssemblyReference->ForceReferenceData(reinterpret_cast<PCWSTR>(pcUnInstallData->lpInstallReference)));
                    else
                        IFW32FALSE_EXIT(AssemblyReference->Initialize(pcUnInstallData->lpInstallReference));

                    IFW32FALSE_EXIT(AssemblyReference->DeleteReferenceFrom(hkReferences, fWasDeleted));
                }

                if (fWasDeleted)
                {
                    //
                    // and delete the codebase
                    //
                    CFusionRegKey CodeBases;
                    CFusionRegKey ThisCodeBase;
                    DWORD         Win32Error = NO_ERROR;

                    IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(
                        hkAsmInstallInfo.OpenSubKey( 
                            CodeBases, 
                            CSMD_TOPLEVEL_CODEBASES,
                            KEY_ALL_ACCESS,
                            0),
                        LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                        Win32Error);

                    if (Win32Error == NO_ERROR)
                    {
                        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(
                            CodeBases.OpenSubKey( 
                                ThisCodeBase, 
                                AssemblyReference->GetGeneratedIdentifier(),
                                KEY_ALL_ACCESS,
                                0),
                            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                            Win32Error);
                    }
                    if (Win32Error == NO_ERROR)
                    {
                        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(
                            ThisCodeBase.DestroyKeyTree(),
                            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                            Win32Error);
                    }
                    if (Win32Error == NO_ERROR)
                    {
                        IFW32FALSE_ORIGINATE_AND_EXIT(ThisCodeBase.Win32Close());
                        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(
                            CodeBases.DeleteKey(AssemblyReference->GetGeneratedIdentifier()),
                            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                            Win32Error);
                    }

                    //
                    // If the assembly reference was removed, tell our caller.
                    //
                    if (pdwDisposition != NULL)
                    {
                        *pdwDisposition |= SXS_UNINSTALL_DISPOSITION_REMOVED_REFERENCE;
                    }
                }
            }

            //
            // Now see if there are any references left at all.
            //
            IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2(
                ::RegQueryInfoKeyW(
                    hkReferences,
                    NULL, NULL, NULL, NULL, NULL, NULL,
                    &dwReferenceCount,
                    NULL, NULL, NULL, NULL),
                LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                fTempFlag);

            //
            // If getting the key information succeeded and there were no more references,
            // then pow - make it go away.
            //
            if ((!fTempFlag) && (dwReferenceCount == 0))
                fDoRemoveActualBits = TRUE;

        }

        //
        // Now, if the "force delete" flag was set, set the "nuke this data anyhow"
        // flag.  MSI still gets to veto the uninstall, so make sure that's done last.
        //
        if ((!fDoRemoveActualBits) && (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_FORCE_DELETE))
            fDoRemoveActualBits = TRUE;

        //
        // One last chance - we're about to remove the assembly from the system.  Does Darwin
        // know about it?
        //
        if ( fDoRemoveActualBits )
        {
            IFW32FALSE_EXIT(
                ::SxspDoesMSIStillNeedAssembly(
                    pcUnInstallData->lpAssemblyIdentity,
                    fDoRemoveActualBits));

            fDoRemoveActualBits = !fDoRemoveActualBits;
        }

        if ( fDoRemoveActualBits && (hkReferences != CFusionRegKey::GetInvalidValue()))
        {
            //
            // One last check - is the assembly referenced by the OS?  They get absolute
            // trump over all the other checks.
            //
            CAssemblyInstallReferenceInformation Ref;
            SXS_INSTALL_REFERENCEW Reference = { sizeof(Reference) };

            ZeroMemory(&Reference, sizeof(Reference));
            Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL;

            IFW32FALSE_EXIT(Ref.Initialize(&Reference));
            IFW32FALSE_EXIT(Ref.IsReferencePresentIn(hkReferences, fDoRemoveActualBits));

            //
            // If it was present, then don't remove!
            //
            fDoRemoveActualBits = !fDoRemoveActualBits;
            
        }

        //
        // Now, if we're still supposed to delete the assembly, go yank it out of the
        // registry and the filesystem; pCleanupAssemblyData knows how to do that.
        //
        if (fDoRemoveActualBits)
        {
            BOOL fWasRemovedProperly;
            
            IFW32FALSE_EXIT(::pCleanUpAssemblyData(AssemblyIdentity, fWasRemovedProperly));

            if (fWasRemovedProperly && (pdwDisposition != NULL))
                *pdwDisposition |= SXS_UNINSTALL_DISPOSITION_REMOVED_ASSEMBLY;
        }
    }
    
    fSuccess = TRUE;
Exit:
#if DBG
    if (!fSuccess && pcUnInstallData != NULL && pcUnInstallData->lpAssemblyIdentity != NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(%ls) failed\n",
            __FUNCTION__,
            pcUnInstallData->lpAssemblyIdentity
            );
    }
#endif
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsxmltree.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsxmltree.h

Abstract:
    Create a XML DOM tree during push-mode parsing

Author:

    Xiaoyu Wu (xiaoyuw) Aug 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_XMLTREE_H_INCLUDED_)
#define _FUSION_SXS_XMLTREE_H_INCLUDED_

#pragma once

#include "stdinc.h"
#include "xmlparser.h"
#include "FusionHeap.h"

// allocatememory for this element, and all its attributes once
struct _SXS_XMLATTRIBUTE{
    PWSTR m_wszName;
    ULONG m_ulPrefixLen;
    PWSTR m_wszValue;
};

typedef struct _SXS_XMLATTRIBUTE SXS_XMLATTRIBUTE;

class SXS_XMLTreeNode{
public:
    friend VOID PrintTreeFromRoot(SXS_XMLTreeNode * Root);
    friend class SXS_XMLDOMTree;
    SXS_XMLTreeNode() :
        m_AttributeList(NULL),
        m_cAttributes(0),
        m_pwszStr(NULL),
        m_ulPrefixLen(0),
        m_pSiblingNode(NULL),
        m_pParentNode(NULL),
        m_pFirstChild(NULL),
        m_pMemoryPool(NULL) { }

    VOID DeleteSelf() { FUSION_DELETE_SINGLETON(this); }
    ~SXS_XMLTreeNode() {
        CSxsPreserveLastError ple;
        if (m_pMemoryPool != NULL)
        {
            FUSION_DELETE_ARRAY(m_pMemoryPool);
            m_pMemoryPool = NULL;
        }

        ple.Restore();
    }

    HRESULT CreateTreeNode(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo);
    VOID PrintSelf();

private:
    HRESULT ComputeBlockSize(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo, DWORD * dwBlockSizeInBytes);

    // for each node, allocate memory once : compute the total spaces need for prefix, localname, and value,
    ULONG m_ulPrefixLen;
    PWSTR m_pwszStr; // Can be a name for ELEMENT, a value for a PCDATA
    SXS_XMLATTRIBUTE *m_AttributeList;
    USHORT            m_cAttributes;
    SXS_XMLTreeNode  *m_pSiblingNode;
    SXS_XMLTreeNode  *m_pParentNode;
    SXS_XMLTreeNode  *m_pFirstChild;
    BYTE             *m_pMemoryPool;  // memory for attribs array, name-value pairs and name-value for the node
};

class SXS_XMLDOMTree{
public:
    HRESULT AddNode(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo); // CreateNode calls this func to add node into the Tree,
    VOID ReturnToParent();      // EndChildren calls this func if "fEmpty=FALSE"
    VOID SetChildCreation();    // BeginChildren calls this func
    /*
    VOID TurnOffFirstChildFlag();
    */

    SXS_XMLDOMTree():
        m_fBeginChildCreation(FALSE),
        m_Root(NULL),
        m_pCurrentNode(NULL)
        { }

    VOID DeleteTreeBranch(SXS_XMLTreeNode * pNode);

    ~SXS_XMLDOMTree(){
        CSxsPreserveLastError ple;
        this->DeleteTreeBranch(m_Root); // do not delete its siblings
        ple.Restore();
    }
    VOID PrintTreeFromRoot(SXS_XMLTreeNode * Root);

    SXS_XMLTreeNode * GetRoot() {
        return m_Root;
    }


private :
    BOOL m_fBeginChildCreation; // everytime, when BeginChild is called, it is set, once it is checked, set it to be FALSE
    SXS_XMLTreeNode * m_Root;
    SXS_XMLTreeNode * m_pCurrentNode;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\sxsxmltree.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsxmltree.cpp

Abstract:
    Create a XML DOM tree during push-mode parsing

Author:

    Xiaoyu Wu (xiaoyuw) Aug 2000

Revision History:

--*/
#include "stdinc.h"
#include "ole2.h"
#include "sxsxmltree.h"
#include "fusiontrace.h"
#include "fusionheap.h"
#include "simplefp.h"

//////////////////////////////////////////////////////////////////////////////////////
//
// SXS_XMLDOMTree
//
//////////////////////////////////////////////////////////////////////////////////////
VOID SXS_XMLDOMTree::DeleteTreeBranch(SXS_XMLTreeNode * pNode)
{
//    SXS_XMLTreeNode * pParent = NULL;
    SXS_XMLTreeNode * pChild = NULL;
    SXS_XMLTreeNode * pNext = NULL;

    if (pNode == NULL)
        return;

    pChild = pNode->m_pFirstChild;
    while(pChild){
        pNext = pChild->m_pSiblingNode;
        this->DeleteTreeBranch(pChild);
        pChild = pNext;
    }
    pNode->DeleteSelf();
}

//
// CreateNode calls this func to add node into the Tree,
//
HRESULT SXS_XMLDOMTree::AddNode(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    SXS_XMLTreeNode * pNewTreeNode= NULL ;

    if ((apNodeInfo == NULL) || (cNumRecs <= 0)){
        hr = E_INVALIDARG;
        goto Exit;
    }
    if (!((apNodeInfo[0]->dwType == XML_ELEMENT) ||(apNodeInfo[0]->dwType == XML_PCDATA))){// ignore nodes other than ELEMENT and PCDATA
        hr = NOERROR;
        goto Exit;
    }
    IFALLOCFAILED_EXIT(pNewTreeNode = new SXS_XMLTreeNode);

    IFCOMFAILED_EXIT(pNewTreeNode->CreateTreeNode(cNumRecs, apNodeInfo));

    if (m_fBeginChildCreation) {
        m_pCurrentNode->m_pFirstChild = pNewTreeNode;
        pNewTreeNode->m_pParentNode = m_pCurrentNode;
        m_pCurrentNode = pNewTreeNode;
        m_fBeginChildCreation = FALSE;
    }
    else{
        if (m_pCurrentNode){
            m_pCurrentNode->m_pSiblingNode = pNewTreeNode;
            pNewTreeNode->m_pParentNode = m_pCurrentNode->m_pParentNode;
        }
        m_pCurrentNode = pNewTreeNode;
    }
    if (m_Root == NULL) // root has not been setup
        m_Root = m_pCurrentNode;

    pNewTreeNode = NULL;
    hr = NOERROR;

Exit:
    if (pNewTreeNode){
        pNewTreeNode->DeleteSelf();
        pNewTreeNode = NULL;
    }

    return hr;
}

//
// EndChildren is called with "fEmpty=FALSE", go to parent node
//
VOID SXS_XMLDOMTree::ReturnToParent()
{
    if (m_pCurrentNode)
        m_pCurrentNode = m_pCurrentNode->m_pParentNode;
    return;
}

// BeginChildren calls this func
VOID SXS_XMLDOMTree::SetChildCreation()
{
    m_fBeginChildCreation = TRUE;
}
/*
VOID SXS_XMLDOMTree::TurnOffFirstChildFlag()
{
    m_fBeginChildCreation = FALSE;
}
*/

//////////////////////////////////////////////////////////////////////////////////////
//
// SXS_XMLTreeNode
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT SXS_XMLTreeNode::ComputeBlockSize(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo, ULONG * pulBlockSizeInBytes)
{
    HRESULT hr = NOERROR;
    ULONG ulBlockSizeInBytes = 0;
    USHORT i;
    USHORT cAttributes;

    FN_TRACE_HR(hr);
    if (pulBlockSizeInBytes)
        *pulBlockSizeInBytes = 0 ;
    else {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if ((apNodeInfo == NULL) || (cNumRecs <= 0)){
        hr = E_INVALIDARG;
        goto Exit;
    }
    ulBlockSizeInBytes = 0;

    for ( i = 0; i< cNumRecs; i ++ ) {
        ulBlockSizeInBytes += apNodeInfo[i]->ulLen * sizeof(WCHAR);
        ulBlockSizeInBytes +=  sizeof(WCHAR); //trailing '\0'
    }

    // if attributes present, add size of attribute array
    cAttributes = (cNumRecs - 1) >> 1 ; // name:value pair
    if (cAttributes > 0)
        ulBlockSizeInBytes += cAttributes * sizeof(SXS_XMLATTRIBUTE);

    * pulBlockSizeInBytes = ulBlockSizeInBytes;
    hr = NOERROR;

Exit:
    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////
HRESULT SXS_XMLTreeNode::CreateTreeNode(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo)
{
    HRESULT hr = NOERROR;
    DWORD dwBlockSizeInBytes;
    PBYTE Cursor = NULL;
    USHORT i;

    FN_TRACE_HR(hr);

    PARAMETER_CHECK((apNodeInfo != NULL) || (cNumRecs == 0));

    IFCOMFAILED_EXIT(this->ComputeBlockSize(cNumRecs, apNodeInfo, &dwBlockSizeInBytes));
    IFALLOCFAILED_EXIT(m_pMemoryPool = FUSION_NEW_ARRAY(BYTE, dwBlockSizeInBytes));
    m_AttributeList = (SXS_XMLATTRIBUTE *)m_pMemoryPool;
    m_cAttributes = (cNumRecs - 1) >> 1;
    Cursor = m_pMemoryPool + m_cAttributes*(sizeof(SXS_XMLATTRIBUTE));

    // set Name(Element) or Value(PCData)
    m_pwszStr = (PWSTR)Cursor;
    wcsncpy((WCHAR*)Cursor, apNodeInfo[0]->pwcText, apNodeInfo[0]->ulLen); //ulLen is # of WCHAR or BYTE?
    Cursor += apNodeInfo[0]->ulLen * sizeof(WCHAR);
    *(WCHAR *)Cursor = L'\0';
    Cursor += sizeof(WCHAR); // '\0'

    for ( i=0 ;i<m_cAttributes ;i++) {
        // copy name
        m_AttributeList[i].m_wszName = (PWSTR)Cursor;
        wcsncpy((WCHAR*)Cursor, apNodeInfo[1+2*i]->pwcText, apNodeInfo[1+2*i]->ulLen); //ulLen is # of WCHAR or BYTE?
        Cursor += apNodeInfo[1+2*i]->ulLen * sizeof(WCHAR);
        *(WCHAR *)Cursor = L'\0';
        Cursor += sizeof(WCHAR); // '\0'

        //copy value
        m_AttributeList[i].m_wszValue = (PWSTR)Cursor;
        wcsncpy((PWSTR)Cursor, apNodeInfo[1 + 2*i + 1]->pwcText, apNodeInfo[1 + 2*i + 1]->ulLen); //ulLen is # of WCHAR or BYTE?
        Cursor += apNodeInfo[1 + 2*i + 1]->ulLen * sizeof(WCHAR);
        *(WCHAR *)Cursor = L'\0';
        Cursor += sizeof(WCHAR); // '\0'

        m_AttributeList[i].m_ulPrefixLen = apNodeInfo[1+2*i]->ulNsPrefixLen;
    }


Exit:
    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////

VOID SXS_XMLTreeNode::PrintSelf()
{
    USHORT i;

    CSimpleFileStream::printf(L"CreateNode\n");
    CSimpleFileStream::printf(L"NodeName = %s\n", m_pwszStr);
    if ( m_cAttributes > 0){
        CSimpleFileStream::printf(L"Attributes :\n");
        for ( i = 0; i < m_cAttributes; i++) {
            CSimpleFileStream::printf(L"\t%s = %s\n", m_AttributeList[i].m_wszName, m_AttributeList[i].m_wszValue);
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\util.cpp ===
#include "stdinc.h"
#include <windows.h>
#include "fusionstring.h"
#include "sxsp.h"
#include <stdio.h>
#include "FusionHandle.h"
#include "sxspath.h"
#include "sxsapi.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "strongname.h"
#include "fusiontrace.h"
#include "CAssemblyRecoveryInfo.h"
#include "recover.h"
#include "sxsinstall.h"
#include "msi.h"

// diff shrinkers to be propated and removed..
#define IsHexDigit      SxspIsHexDigit
#define HexDigitToValue SxspHexDigitToValue

#define ASSEMBLY_NAME_VALID_SPECIAL_CHARACTERS  L".-"
#define ASSEMBLY_NAME_INVALID_CHARACTERS        L"_\/:?*"
#define ASSEMBLY_NAME_VALID_SEPARATORS          L"."
#define ASSEMBLY_NAME_TRIM_INDICATOR            L".."
#define ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH     2
#define ASSEMBLY_NAME_PRIM_MAX_LENGTH           64
#define ASSEMBLY_STRONG_NAME_LENGTH             16

#define ULONG_STRING_FORMAT                     L"%08lx"
#define ULONG_STRING_LENGTH                     8


#define MSI_PROVIDEASSEMBLY_NAME        ("MsiProvideAssemblyW")
#define MSI_DLL_NAME_W                  (L"msi.dll")
#ifndef INSTALLMODE_NODETECTION_ANY
#define INSTALLMODE_NODETECTION_ANY (INSTALLMODE)-4
#endif


// Honest, we exist - Including all of sxsprotect.h is too much in this case.
BOOL SxspIsSfcIgnoredStoreSubdir(PCWSTR pwszDir);

#define PRINTABLE(_ch) (isprint((_ch)) ? (_ch) : '.')

// deliberately no surrounding parens or trailing comma
#define STRING_AND_LENGTH(x) (x), (NUMBER_OF(x) - 1)

/*-----------------------------------------------------------------------------
this makes the temp install be %windir%\WinSxs\InstallTemp\uid
instead of %windir%\WinSxs\uid
-----------------------------------------------------------------------------*/
#define SXSP_SEMIREADABLE_INSTALL_TEMP 1

const static HKEY  hKeyRunOnceRoot = HKEY_LOCAL_MACHINE;
const static WCHAR rgchRunOnceSubKey[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
const static WCHAR rgchRunOnceValueNameBase[] = L"WinSideBySideSetupCleanup ";

/*-----------------------------------------------------------------------------
append the directory name to this and put it in RunOnce in the registry
to cleanup crashed installs upon login
-----------------------------------------------------------------------------*/
const static WCHAR rgchRunOnePrefix[]  = L"rundll32 sxs.dll,SxspRunDllDeleteDirectory ";

#define SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY  (0x00000001)
#define SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY         (0x00000002)
#define SXSP_PROBING_CANDIDATE_FLAG_IS_NDP_GAC                  (0x00000004)

static const struct _SXSP_PROBING_CANDIDATE
{
    PCWSTR Pattern;
    DWORD Flags;
} s_rgProbingCandidates[] =
{
    { L"$M", 0 },
    { L"$G\\$N.DLL", SXSP_PROBING_CANDIDATE_FLAG_IS_NDP_GAC },
    { L"$.$L$N.DLL", SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY | SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY },
    { L"$.$L$N.MANIFEST", SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY | SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY },
    { L"$.$L$N\\$N.DLL", SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY | SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY },
    { L"$.$L$N\\$N.MANIFEST", SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY | SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY },
};

const static struct
{
    ULONG ThreadingModel;
    WCHAR String[10];
    SIZE_T Cch;
} gs_rgTMMap[] =
{
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT, STRING_AND_LENGTH(L"Apartment") },
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE, STRING_AND_LENGTH(L"Free") },
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE, STRING_AND_LENGTH(L"Single") },
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH, STRING_AND_LENGTH(L"Both") },
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL, STRING_AND_LENGTH(L"Neutral") },
};

PCSTR SxspActivationContextCallbackReasonToString(ULONG activationContextCallbackReason)
{
#if DBG
static const CHAR rgs[][16] =
{
    "",
    "INIT",
    "GENBEGINNING",
    "PARSEBEGINNING",
    "BEGINCHILDREN",
    "ENDCHILDREN",
    "ELEMENTPARSED",
    "PARSEENDING",
    "ALLPARSINGDONE",
    "GETSECTIONSIZE",
    "GETSECTIONDATA",
    "GENENDING",
    "UNINIT"
};
    if (activationContextCallbackReason > 0 && activationContextCallbackReason <= NUMBER_OF(rgs))
    {
        return rgs[activationContextCallbackReason-1];
    }
    return rgs[0];
#else
    return "";
#endif
}

PCWSTR SxspInstallDispositionToStringW(ULONG installDisposition)
{
#if DBG
static const WCHAR rgs[][12] =
{
    L"",
    L"COPIED",
    L"QUEUED",
    L"PLEASE_COPY",
};
    if (installDisposition > 0 && installDisposition <= NUMBER_OF(rgs))
    {
        return rgs[installDisposition-1];
    }
    return rgs[0];
#else
    return L"";
#endif
}

BOOL
SxspParseThreadingModel(
    PCWSTR String,
    SIZE_T Cch,
    ULONG *ThreadingModel
    )
{
    ULONG i;
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    // We'll let ProcessorArchitecture be NULL if the caller just wants to
    // test whether there is a match.

    for (i=0; i<NUMBER_OF(gs_rgTMMap); i++)
    {
        if (::FusionpCompareStrings(
                gs_rgTMMap[i].String,
                gs_rgTMMap[i].Cch,
                String,
                Cch,
                true) == 0)
        {
            if (ThreadingModel != NULL)
                *ThreadingModel = gs_rgTMMap[i].ThreadingModel;

            break;
        }
    }

    if (i == NUMBER_OF(gs_rgTMMap))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Invalid threading model string\n");

        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFormatThreadingModel(
    ULONG ThreadingModel,
    CBaseStringBuffer &Buffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    for (i=0; i<NUMBER_OF(gs_rgTMMap); i++)
    {
        if (gs_rgTMMap[i].ThreadingModel == ThreadingModel)
            break;
    }

    PARAMETER_CHECK(i != NUMBER_OF(gs_rgTMMap));
    IFW32FALSE_EXIT(Buffer.Win32Assign(gs_rgTMMap[i].String, gs_rgTMMap[i].Cch));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

static
SIZE_T
CchForUSHORT(USHORT us)
{
    if (us > 9999)
        return 5;
    else if (us > 999)
        return 4;
    else if (us > 99)
        return 3;
    else if (us > 9)
        return 2;

    return 1;
}

BOOL
SxspAllocateString(
    SIZE_T cch,
    PWSTR *StringOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ASSERT(StringOut != NULL);

    if (StringOut != NULL)
        *StringOut = NULL;

    PARAMETER_CHECK(StringOut != NULL);
    PARAMETER_CHECK(cch != 0);
    IFALLOCFAILED_EXIT(*StringOut = NEW(WCHAR[cch]));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
//
//For deallocation of the output string, use "delete[] StringOut" xiaoyuw@08/31/00
//
BOOL
SxspDuplicateString(
    PCWSTR StringIn,
    SIZE_T cch,
    PWSTR *StringOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (StringOut != NULL)
        *StringOut = NULL;

    PARAMETER_CHECK(StringOut != NULL);
    PARAMETER_CHECK((StringIn != NULL) || (cch == 0));

    if (cch == 0)
        *StringOut = NULL;
    else
    {
        cch++;
        IFW32FALSE_EXIT(::SxspAllocateString(cch, StringOut));
        memcpy(*StringOut, StringIn, cch * sizeof(WCHAR));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#define COMMA ,
extern const WCHAR sxspAssemblyManifestFileNameSuffixes[4][10] =  { L"", ASSEMBLY_MANIFEST_FILE_NAME_SUFFIXES(COMMA) };
#undef COMMA

// format an input ULONG to be a string in HEX format
BOOL
SxspFormatULONG(
    ULONG ul,
    SIZE_T CchBuffer,
    WCHAR Buffer[],
    SIZE_T *CchWrittenOrRequired
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    int cch;

    if (CchWrittenOrRequired != NULL)
        *CchWrittenOrRequired = 0;

    PARAMETER_CHECK(Buffer != NULL);

    if (CchBuffer < (ULONG_STRING_LENGTH + 1))
    {
        if (CchWrittenOrRequired != NULL)
            *CchWrittenOrRequired = ULONG_STRING_LENGTH + 1;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(BufferTooSmall, ERROR_INSUFFICIENT_BUFFER);
    }

    cch = _snwprintf(Buffer, CchBuffer, ULONG_STRING_FORMAT, ul);
    INTERNAL_ERROR_CHECK(cch > 0);

    if (CchWrittenOrRequired != NULL)
        *CchWrittenOrRequired = cch;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

// besides these specials, the NORMAL CHAR is in [A-Z] or [a-z] or [0-9]
BOOL
IsValidAssemblyNameCharacter(WCHAR ch)
{
    if (((ch >= L'A') && (ch <= L'Z')) ||
         ((ch >= L'a') && (ch <= L'z')) ||
         ((ch >= L'0') && (ch <= L'9')) ||
         (wcschr(ASSEMBLY_NAME_VALID_SPECIAL_CHARACTERS, ch)!= NULL))
    {
        return TRUE;
    } else
        return FALSE;
/*
    if (wcschr(ASSEMBLY_NAME_VALID_SPECIAL_CHARACTERS, ch))
        return FALSE;
    else
        return TRUE;
*/
}

BOOL
SxspGenerateAssemblyNamePrimeFromName(
    PCWSTR pszAssemblyName,
    SIZE_T CchAssemblyName,
    CBaseStringBuffer *Buffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PWSTR pStart = NULL, pEnd = NULL;
    PWSTR qEnd = NULL, pszBuffer = NULL;
    ULONG i, j, len, ulSpaceLeft;
    ULONG cch;
    PWSTR pLeftEnd = NULL, pRightStart = NULL, PureNameEnd = NULL, PureNameStart = NULL;
    CStringBuffer buffTemp;
    CStringBufferAccessor accessor;

    PARAMETER_CHECK(pszAssemblyName != NULL);
    PARAMETER_CHECK(Buffer != NULL);

    // See how many characters we need max in the temporary buffer.
    cch = 0;

    for (i=0; i<CchAssemblyName; i++)
    {
        if (::IsValidAssemblyNameCharacter(pszAssemblyName[i]))
            cch++;
    }

    IFW32FALSE_EXIT(buffTemp.Win32ResizeBuffer(cch + 1, eDoNotPreserveBufferContents));

    accessor.Attach(&buffTemp);

    pszBuffer = accessor.GetBufferPtr();

    j = 0;
    for (i=0; i<CchAssemblyName; i++)
    {
        if (::IsValidAssemblyNameCharacter(pszAssemblyName[i]))
        {
            pszBuffer[j] = pszAssemblyName[i];
            j++;
        }
    }

    ASSERT(j == cch);

    pszBuffer[j] = L'\0';

    // if the name is not too long, just return ;
    if (j < ASSEMBLY_NAME_PRIM_MAX_LENGTH)
    { // less or equal 64
        IFW32FALSE_EXIT(Buffer->Win32Assign(pszBuffer, cch));
    }
    else
    {
        // name is too long, have to trim a little bit
        ulSpaceLeft = ASSEMBLY_NAME_PRIM_MAX_LENGTH;

        PureNameStart = pszBuffer;
        PureNameEnd = pszBuffer + j;
        pLeftEnd = PureNameStart;
        pRightStart = PureNameEnd;

        while (PureNameStart < PureNameEnd)
        {
            // left end
            pStart = PureNameStart;
            i = 0;
            while ((wcschr(ASSEMBLY_NAME_VALID_SEPARATORS, pStart[i]) == 0) && (pStart+i != pRightStart)) // not a separator character
                i++;

            pEnd = pStart + i ;
            len = i;  // it should be length of WCHAR! not BYTE!!!

            if (len >= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH)  {// because we use ".." if trim happen
                pLeftEnd += (ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH);
                break;
            }
            ulSpaceLeft -=  len;
            pLeftEnd = pEnd; // "abc.xxxxxxx" pointing to "c"

            // right end
            qEnd = PureNameEnd;
            i = 0 ;
            while ((qEnd+i != pLeftEnd) && (wcschr(ASSEMBLY_NAME_VALID_SEPARATORS, qEnd[i]) == 0))
                i--;

            len = 0 - i;
            if (len >= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH)  {// because we use ".." if trim happen
                pRightStart -= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH;
                break;
            }
            ulSpaceLeft -=  len;
            PureNameStart = pLeftEnd + 1;
            PureNameEnd = pRightStart - 1;
        } // end of while

        IFW32FALSE_EXIT(Buffer->Win32Assign(pszBuffer, pLeftEnd-pszBuffer));
        IFW32FALSE_EXIT(Buffer->Win32Append(ASSEMBLY_NAME_TRIM_INDICATOR, NUMBER_OF(ASSEMBLY_NAME_TRIM_INDICATOR) - 1));
        IFW32FALSE_EXIT(Buffer->Win32Append(pRightStart, ::wcslen(pRightStart)));  // till end of the buffer
    }

    fSuccess = TRUE;

Exit:

    return fSuccess;
}

// not implemented : assume Jon has this API
BOOL
SxspVerifyPublicKeyAndStrongName(
    const WCHAR *pszPublicKey,
    SIZE_T CchPublicKey,
    const WCHAR *pszStrongName,
    SIZE_T CchStrongName,
    BOOL & fValid)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSmallStringBuffer buf1;
    CSmallStringBuffer buf2;

    IFW32FALSE_EXIT(buf1.Win32Assign(pszPublicKey, CchPublicKey));
    IFW32FALSE_EXIT(buf2.Win32Assign(pszStrongName, CchStrongName));
    IFW32FALSE_EXIT(::SxspDoesStrongNameMatchKey(buf1, buf2, fValid));
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspGenerateSxsPath(
    IN DWORD Flags,
    IN ULONG PathType,
    IN const WCHAR *AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT CBaseStringBuffer &PathBuffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SIZE_T  cch = 0;
    PCWSTR  pszAssemblyName=NULL, pszVersion=NULL, pszProcessorArchitecture=NULL, pszLanguage=NULL, pszPolicyFileNameWithoutExt = NULL;
    PCWSTR  pszAssemblyStrongName=NULL;
    SIZE_T  AssemblyNameCch = 0, AssemblyStrongNameCch=0, VersionCch=0, ProcessorArchitectureCch=0, LanguageCch=0;
    SIZE_T  PolicyFileNameWithoutExtCch=0;
    BOOL    fNeedSlashAfterRoot = FALSE;
    ULONG   IdentityHash;
    BOOL    fOmitRoot     = ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT) != 0);
    BOOL    fPartialPath  = ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH) != 0);

    WCHAR HashBuffer[ULONG_STRING_LENGTH + 1];
    SIZE_T  HashBufferCch;

    CSmallStringBuffer NamePrimeBuffer;

#if DBG_SXS
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: Entered %s()\n"
        "   Flags = 0x%08lx\n"
        "   AssemblyRootDirectory = %p\n"
        "   AssemblyRootDirectoryCch = %lu\n"
        "   PathBuffer = %p\n",
        __FUNCTION__,
        Flags,
        AssemblyRootDirectory,
        AssemblyRootDirectoryCch,
        &PathBuffer);
#endif // DBG_SXS

    PARAMETER_CHECK(
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY) ||
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ||
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY));
    PARAMETER_CHECK(pAssemblyIdentity != NULL);
    PARAMETER_CHECK((Flags & ~(SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION | SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH)) == 0);
    // Not supplying the assembly root is only legal if you're asking for it to be left out...
    PARAMETER_CHECK((AssemblyRootDirectoryCch != 0) || (Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT));

    // You can't combine SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH with anything else...
    PARAMETER_CHECK(
        ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH) == 0) ||
        ((Flags & ~(SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH)) == 0));

    // get AssemblyName
    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, pAssemblyIdentity, &s_IdentityAttribute_name, &pszAssemblyName, &AssemblyNameCch));
    INTERNAL_ERROR_CHECK((pszAssemblyName != NULL) && (AssemblyNameCch != 0));

    // get AssemblyName' based on AssemblyName
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNamePrimeFromName(pszAssemblyName, AssemblyNameCch, &NamePrimeBuffer));

    // get Assembly Version
    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
        SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, // for policy_lookup, no version is used
        pAssemblyIdentity,
        &s_IdentityAttribute_version,
        &pszVersion,
        &VersionCch));

    if ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION) || (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY))
    {
        // for policy file, version of the policy file is used as policy filename
        pszPolicyFileNameWithoutExt = pszVersion;
        PolicyFileNameWithoutExtCch = VersionCch;
        pszVersion = NULL;
        VersionCch = 0;
    }
    else
    {
        PARAMETER_CHECK((pszVersion != NULL) && (VersionCch != 0));
    }

    // get Assembly Langage
    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
        SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, 
        pAssemblyIdentity, 
        &s_IdentityAttribute_language, 
        &pszLanguage, 
        &LanguageCch));

    if (pszLanguage == NULL)
    {
        pszLanguage = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE;
        LanguageCch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE) - 1;
    }

    // get Assembly ProcessorArchitecture
    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pAssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            &pszProcessorArchitecture,
            &ProcessorArchitectureCch));

    if (pszProcessorArchitecture == NULL)
    {
        pszProcessorArchitecture = L"data";
        ProcessorArchitectureCch = 4;
    }

    // get Assembly StrongName
    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pAssemblyIdentity,
            &s_IdentityAttribute_publicKeyToken,
            &pszAssemblyStrongName,
            &AssemblyStrongNameCch));
    
    if (pszAssemblyStrongName == NULL)
    {
        pszAssemblyStrongName = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE;
        AssemblyStrongNameCch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1;
    }

    //get Assembly Hash String
    if ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY) || (Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION))
    {
        IFW32FALSE_EXIT(::SxspHashAssemblyIdentityForPolicy(0, pAssemblyIdentity, IdentityHash));
    }
    else
    {
        IFW32FALSE_EXIT(::SxsHashAssemblyIdentity(0, pAssemblyIdentity, &IdentityHash));
    }

    IFW32FALSE_EXIT(::SxspFormatULONG(IdentityHash, NUMBER_OF(HashBuffer), HashBuffer, &HashBufferCch));
    INTERNAL_ERROR_CHECK(HashBufferCch == ULONG_STRING_LENGTH);

    if (!fOmitRoot)
    {
        // If the assembly root was not passed in, get it.
        fNeedSlashAfterRoot = (! ::FusionpIsPathSeparator(AssemblyRootDirectory[AssemblyRootDirectoryCch-1]));
    }
    else
    {
        // If we don't want to include the root, then don't account for it below...
        AssemblyRootDirectoryCch = 0;
        fNeedSlashAfterRoot = FALSE;
    }

    // this computation can be off by one or a few, it's an optimization
    // to pregrow a string buffer
    cch =
            AssemblyRootDirectoryCch +                                          // "C:\WINNT\WinSxS\"
            (fNeedSlashAfterRoot ? 1 : 0);

    switch (PathType)
    {
    case SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST:
        // Wacky parens and ... - 1) + 1) to reinforce that it's the number of
        // characters in the string not including the null and then an extra separator.
        cch += (NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1) + 1;
        break;

    case SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY:
        // Wacky parens and ... - 1) + 1) to reinforce that it's the number of
        // characters in the string not including the null and then an extra separator.
        cch += (NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1) + 1;
        break;        
    }

    cch++;

    // fPartialPath means that we don't actually want to take the assembly's identity into
    // account; the caller just wants the path to the manifests or policies directories.
    if (!fPartialPath)
    {
        cch +=
                ProcessorArchitectureCch +                                      // "x86"
                1 +                                                             // "_"
                NamePrimeBuffer.Cch() +                                         // "FooBar"
                1 +                                                             // "_"
                AssemblyStrongNameCch +                                         // StrongName
                1 +                                                             // "_"
                VersionCch +                                                    // "5.6.2900.42"
                1 +                                                             // "_"
                LanguageCch +                                                   // "0409"
                1 +                                                             // "_"
                HashBufferCch;

        if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)
        {
            cch += NUMBER_OF(ASSEMBLY_LONGEST_MANIFEST_FILE_NAME_SUFFIX);        // ".manifest\0"
        }
        else if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)
        {
            // "_" has already reserve space for "\"
            cch += PolicyFileNameWithoutExtCch;
            cch += NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX);          // ".policy\0"
        }
        else {  // pathType must be SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY

            // if (!fOmitRoot)
            //    cch++;
            cch++; // trailing null character
        }
    }

    // We try to ensure that the buffer is big enough up front so that we don't have to do any
    // dynamic reallocation during the actual process.
    IFW32FALSE_EXIT(PathBuffer.Win32ResizeBuffer(cch, eDoNotPreserveBufferContents));


    // Note that since when GENERATE_ASSEMBLY_PATH_OMIT_ROOT is set, we force AssemblyRootDirectoryCch to zero
    // and fNeedSlashAfterRoot to FALSE, so the first two entries in this concatenation actually don't
    // contribute anything to the string constructed.
    if (fPartialPath)
    {
        IFW32FALSE_EXIT(PathBuffer.Win32AssignW(5,
                        AssemblyRootDirectory, static_cast<INT>(AssemblyRootDirectoryCch),  // "C:\WINNT\WINSXS"
                        L"\\", (fNeedSlashAfterRoot ? 1 : 0),                               // optional '\'
                        // manifests subdir
                        MANIFEST_ROOT_DIRECTORY_NAME, ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ? NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) -1 : 0), // "manifests"
                        // policies subdir
                        POLICY_ROOT_DIRECTORY_NAME, ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)? NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1 : 0),      // "policies"
                        L"\\", (((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) || (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)) ? 1 : 0)
                       ));                                                                 // optional '\'
    }
    else
    {
        //
        // create one of below
        //  (1) fully-qualified manifest filename,
        //          eg, [C:\WINNT\WinSxS\]Manifests\X86_DynamicDll_6595b64144ccf1df_2.0.0.0_en-us_2f433926.Manifest
        //  (2) fully-qualified policy filename,
        //          eg, [C:\WINNT\WinSxS\]Policies\x86_policy.1.0.DynamicDll_b54bc117ce08a1e8_en-us_d51541cb\1.1.0.0.cat
        //  (3) fully-qulified assembly name (w. or w/o a version)
        //          eg, [C:\WINNT\WinSxS\]x86_DynamicDll_6595b64144ccf1df_6.0.0.0_x-ww_ff9986d7
        //
        IFW32FALSE_EXIT(
            PathBuffer.Win32AssignW(17,
                AssemblyRootDirectory, static_cast<INT>(AssemblyRootDirectoryCch),  // "C:\WINNT\WINSXS"
                L"\\", (fNeedSlashAfterRoot ? 1 : 0),                               // optional '\'
                MANIFEST_ROOT_DIRECTORY_NAME, ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ? NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1 : 0),
                POLICY_ROOT_DIRECTORY_NAME,   ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY) ? NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1 : 0),
                L"\\", (((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) || (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)) ? 1 : 0),   // optional '\'
                pszProcessorArchitecture, static_cast<INT>(ProcessorArchitectureCch),
                L"_", 1,
                static_cast<PCWSTR>(NamePrimeBuffer), static_cast<INT>(NamePrimeBuffer.Cch()),
                L"_", 1,
                pszAssemblyStrongName, static_cast<INT>(AssemblyStrongNameCch),
                L"_", (VersionCch != 0) ? 1 : 0,
                pszVersion, static_cast<INT>(VersionCch),
                L"_", 1,
                pszLanguage, static_cast<INT>(LanguageCch),
                L"_", 1,
                static_cast<PCWSTR>(HashBuffer), static_cast<INT>(HashBufferCch),
                L"\\", ((fOmitRoot ||(PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)) ? 0 : 1)));

        if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)
            IFW32FALSE_EXIT(PathBuffer.Win32Append(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX, NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX) - 1));
        else if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)
        {
            if ((pszPolicyFileNameWithoutExt != NULL) && (PolicyFileNameWithoutExtCch >0))
            {
                IFW32FALSE_EXIT(PathBuffer.Win32Append(pszPolicyFileNameWithoutExt, PolicyFileNameWithoutExtCch));
                IFW32FALSE_EXIT(PathBuffer.Win32Append(ASSEMBLY_POLICY_FILE_NAME_SUFFIX, NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX) - 1));
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGenerateManifestPathForProbing(
    ULONG dwLocationIndex,
    DWORD dwFlags,
    IN PCWSTR AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch OPTIONAL,
    IN ULONG ApplicationDirectoryPathType OPTIONAL,
    IN PCWSTR ApplicationDirectory OPTIONAL,
    IN SIZE_T ApplicationDirectoryCch OPTIONAL,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT CBaseStringBuffer &PathBuffer,
    BOOL  *pfPrivateAssembly,
    bool &rfDone
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL fIsPrivate = FALSE;

    rfDone = false;

    if (pfPrivateAssembly != NULL) // init
        *pfPrivateAssembly = FALSE;

    PathBuffer.Clear();

    PARAMETER_CHECK(pAssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyRootDirectory != NULL);
    PARAMETER_CHECK(AssemblyRootDirectoryCch != 0);
    PARAMETER_CHECK((dwFlags & ~(SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED |
                                 SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS |
                                 SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_PRIVATE_ASSEMBLIES)) == 0);
    PARAMETER_CHECK((dwLocationIndex == 0) || (dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED) || (ApplicationDirectory != NULL));
    PARAMETER_CHECK((dwLocationIndex == 0) || (dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED) || (ApplicationDirectoryCch != 0));
    PARAMETER_CHECK(::FusionpIsPathSeparator(AssemblyRootDirectory[AssemblyRootDirectoryCch - 1]));
    PARAMETER_CHECK((ApplicationDirectory == NULL) || (ApplicationDirectory[0] == L'\0') || ::FusionpIsPathSeparator(ApplicationDirectory[ApplicationDirectoryCch - 1]));
    PARAMETER_CHECK((ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_NONE) ||
                    (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE) ||
                    (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_URL));
    PARAMETER_CHECK((ApplicationDirectoryCch != 0) || (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_NONE));

    INTERNAL_ERROR_CHECK(dwLocationIndex <= NUMBER_OF(s_rgProbingCandidates));
    if (dwLocationIndex >= NUMBER_OF(s_rgProbingCandidates))
    {
        rfDone = true;
    }
    else
    {
        PCWSTR Candidate = s_rgProbingCandidates[dwLocationIndex].Pattern;
        WCHAR wch;
        SIZE_T iPosition = 0; // Used to track that $M and $. only appear first

        if ((dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS) &&
            (s_rgProbingCandidates[dwLocationIndex].Flags & SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY))
        {
            // No probing for languages I guess!
            fSuccess = TRUE;
            goto Exit;
        }

        if ((dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_PRIVATE_ASSEMBLIES) &&
            (s_rgProbingCandidates[dwLocationIndex].Flags & SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY))
        {
            fSuccess = TRUE;
            goto Exit;
        }

        while ((wch = *Candidate++) != L'\0')
        {
            switch (wch)
            {
            default:
                IFW32FALSE_EXIT(PathBuffer.Win32Append(&wch, 1));
                break;

            case L'$':
                wch = *Candidate++;

                switch (wch)
                {
                default:
                    // Bad macro expansion...
                    INTERNAL_ERROR_CHECK(FALSE);
                    break; // extraneous since there was effectively an unconditional goto in the internal error check...

                case L'M':
                    // $M is only allowed as the first element.
                    INTERNAL_ERROR_CHECK(iPosition == 0);
                    IFW32FALSE_EXIT(
                        ::SxspGenerateSxsPath(// "winnt\winsxs\manifests\x86_bar_1000_0409.manifest
                            0,
                            SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
                            AssemblyRootDirectory,
                            AssemblyRootDirectoryCch,
                            pAssemblyIdentity,
                            PathBuffer));

                    // and it has to be the only element
                    INTERNAL_ERROR_CHECK(*Candidate == L'\0');
                    break;

                case L'G':
                    IFW32FALSE_EXIT(::SxspGenerateNdpGACPath(0, pAssemblyIdentity, PathBuffer));
                    break;

                case L'.':
                    // $. is only allowed as the first element
                    INTERNAL_ERROR_CHECK(iPosition == 0);

                    if (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_NONE)
                    {
                        // No local probing...
                        fSuccess = TRUE;
                        goto Exit;
                    }

                    IFW32FALSE_EXIT(PathBuffer.Win32Append(ApplicationDirectory, ApplicationDirectoryCch));
                    fIsPrivate = TRUE;
                    break;

                case L'L': // language
                    {
                        PCWSTR Language = NULL;
                        SIZE_T CchLanguage = 0;

                        INTERNAL_ERROR_CHECK((dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS) == 0);

                        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, pAssemblyIdentity, &s_IdentityAttribute_language, &Language, &CchLanguage));

                        if (CchLanguage != 0)
                        {
                            IFW32FALSE_EXIT(PathBuffer.Win32Append(Language, CchLanguage));
                            IFW32FALSE_EXIT(PathBuffer.Win32Append(PathBuffer.PreferredPathSeparatorString(), 1));
                        }

                        break;
                    }

                case L'N': // full assembly name
                    {
                        PCWSTR AssemblyName = NULL;
                        SIZE_T CchAssemblyName = 0;
                        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, pAssemblyIdentity, &s_IdentityAttribute_name, &AssemblyName, &CchAssemblyName));
                        INTERNAL_ERROR_CHECK(CchAssemblyName != 0);
                        IFW32FALSE_EXIT(PathBuffer.Win32Append(AssemblyName, CchAssemblyName));
                        break;
                    }

                case L'n': // final segment of assembly name
                    {
                        PCWSTR AssemblyName = NULL;
                        SIZE_T CchAssemblyName = 0;
                        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, pAssemblyIdentity, &s_IdentityAttribute_name, &AssemblyName, &CchAssemblyName));
                        INTERNAL_ERROR_CHECK(CchAssemblyName != 0);
                        IFW32FALSE_EXIT(::SxspFindLastSegmentOfAssemblyName(AssemblyName, CchAssemblyName, &AssemblyName, &CchAssemblyName));
                        IFW32FALSE_EXIT(PathBuffer.Win32Append(AssemblyName, CchAssemblyName));
                        break;
                    }

                case L'P': // P for Prime because in discussions we always called this "name prime" (vs. "name")
                    {
                        // Get the assembly name, munge it and then try to use it.
                        PCWSTR AssemblyName = NULL;
                        SIZE_T CchAssemblyName = 0;
                        CSmallStringBuffer buffShortenedAssemblyName;

                        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, pAssemblyIdentity, &s_IdentityAttribute_name, &AssemblyName, &CchAssemblyName));
                        INTERNAL_ERROR_CHECK(CchAssemblyName != 0);
                        IFW32FALSE_EXIT(::SxspGenerateAssemblyNamePrimeFromName(AssemblyName, CchAssemblyName, &buffShortenedAssemblyName));
                        IFW32FALSE_EXIT(PathBuffer.Win32Append(buffShortenedAssemblyName, buffShortenedAssemblyName.Cch()));
                        break;
                    }
                }

                break;
            }

            iPosition++;
        }

    }

    if (pfPrivateAssembly != NULL)
        *pfPrivateAssembly = fIsPrivate;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGetAttributeValue(
    IN DWORD dwFlags,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeNameDescriptor,
    IN PCSXS_NODE_INFO NodeInfo,
    IN SIZE_T NodeCount,
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    OUT bool &rfFound,
    IN SIZE_T OutputBufferSize,
    OUT PVOID OutputBuffer,
    OUT SIZE_T &rcbOutputBytesWritten,
    IN SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE ValidationRoutine OPTIONAL,
    IN DWORD ValidationRoutineFlags OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;
    PCWSTR AttributeName, AttributeNamespace;
    SIZE_T AttributeNameCch, AttributeNamespaceCch;
    CStringBuffer buffValue;
    BOOL fSmallStringBuffer = FALSE;

    rfFound = false;
    rcbOutputBytesWritten = 0;

    PARAMETER_CHECK((dwFlags & ~(SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE)) == 0);
    PARAMETER_CHECK(AttributeNameDescriptor != NULL);
    PARAMETER_CHECK((NodeInfo != NULL) || (NodeCount == 0));
    PARAMETER_CHECK((OutputBuffer != NULL) || (OutputBufferSize == 0));
    PARAMETER_CHECK((ValidationRoutine != NULL) || (ValidationRoutineFlags == 0));
    PARAMETER_CHECK((ValidationRoutine != NULL) ||
                (OutputBufferSize == 0) || (OutputBufferSize == sizeof(CSmallStringBuffer)) || (OutputBufferSize == sizeof(CStringBuffer)));
    if (OutputBufferSize != sizeof(CStringBuffer))
        fSmallStringBuffer = TRUE;

    AttributeName = AttributeNameDescriptor->Name;
    AttributeNameCch = AttributeNameDescriptor->NameCch;
    AttributeNamespace = AttributeNameDescriptor->Namespace;
    AttributeNamespaceCch = AttributeNameDescriptor->NamespaceCch;

    for (i=0; i<NodeCount; i++)
    {
        if ((NodeInfo[i].Type == SXS_ATTRIBUTE) &&
            (::FusionpCompareStrings(// compare name
                NodeInfo[i].pszText,
                NodeInfo[i].cchText,
                AttributeName,
                AttributeNameCch,
                false) == 0))
        {
            //compare namespace
            if (((NodeInfo[i].NamespaceStringBuf.Cch() == 0) && (AttributeNamespaceCch==0)) ||
                (::FusionpCompareStrings(// compare namespace string
                    NodeInfo[i].NamespaceStringBuf,
                    NodeInfo[i].NamespaceStringBuf.Cch(),
                    AttributeNamespace,
                    AttributeNamespaceCch,
                    false) == 0))
            {
                // We found the attribute.  Now we need to start accumulating the parts of the value;
                // entity references (e.g. &amp;) show up as separate nodes.
                while ((++i < NodeCount) &&
                       (NodeInfo[i].Type == SXS_PCDATA))
                    IFW32FALSE_EXIT(buffValue.Win32Append(NodeInfo[i].pszText, NodeInfo[i].cchText));

                if (ValidationRoutine == NULL)
                {
                    if (OutputBuffer != NULL)
                    {
                        // Have the caller's buffer take over ours
                        CBaseStringBuffer *pCallersBuffer = (CBaseStringBuffer *) OutputBuffer;
                        IFW32FALSE_EXIT(pCallersBuffer->Win32Assign(buffValue));
                        rcbOutputBytesWritten = pCallersBuffer->Cch() * sizeof(WCHAR);
                    }
                }
                else
                {
                    bool fValid = false;

                    IFW32FALSE_EXIT(
                        (*ValidationRoutine)(
                            ValidationRoutineFlags,
                            buffValue,
                            fValid,
                            OutputBufferSize,
                            OutputBuffer,
                            rcbOutputBytesWritten));

                    if (!fValid)
                    {
                        (*ParseContext->ErrorCallbacks.InvalidAttributeValue)(
                            ParseContext,
                            AttributeNameDescriptor);

                        ORIGINATE_WIN32_FAILURE_AND_EXIT(AttributeValidation, ERROR_SXS_MANIFEST_PARSE_ERROR);
                    }
                }

                rfFound = true;

                break;
            }
        }
    }

    if ((dwFlags & SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE) && (!rfFound))
    {
        (*ParseContext->ErrorCallbacks.MissingRequiredAttribute)(
            ParseContext,
            AttributeNameDescriptor);

        ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingRequiredAttribute, ERROR_SXS_MANIFEST_PARSE_ERROR);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGetAttributeValue(
    IN DWORD dwFlags,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeNameDescriptor,
    IN PCACTCTXCTB_CBELEMENTPARSED ElementParsed,
    OUT bool &rfFound,
    IN SIZE_T OutputBufferSize,
    OUT PVOID OutputBuffer,
    OUT SIZE_T &rcbOutputBytesWritten,
    IN SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE ValidationRoutine OPTIONAL,
    IN DWORD ValidationRoutineFlags OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    // Since we're doing some parameter validation here, we need to initialize our output parameters
    rfFound = false;
    rcbOutputBytesWritten = 0;

    PARAMETER_CHECK(ElementParsed != NULL);

    // We're going to depend on the other function to do the rest of the parameter validation
    // a little sleazy but what the heck

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            dwFlags,
            AttributeNameDescriptor,
            ElementParsed->NodeInfo,
            ElementParsed->NodeCount,
            ElementParsed->ParseContext,
            rfFound,
            OutputBufferSize,
            OutputBuffer,
            rcbOutputBytesWritten,
            ValidationRoutine,
            ValidationRoutineFlags));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFormatGUID(
    const GUID &rGuid,
    CBaseStringBuffer &rBuffer
    )
{
    FN_PROLOG_WIN32

    // It would seem nice to use RtlStringFromGUID(), but it does a dynamic allocation, which we do not
    // want.  Instead, we'll just format it ourselves; it's pretty trivial...
    //
    //  {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //  00000000011111111112222222222333333333
    //  12345678901234567890123456789012345678
    //
    // 128 bits / 4 bits per digit = 32 digits
    // + 4 dashes + 2 braces = 38
#define CCH_GUID (38)

    IFW32FALSE_EXIT(rBuffer.Win32ResizeBuffer(CCH_GUID + 1, eDoNotPreserveBufferContents));

    // It's still unbelievably slow to use swprintf() here, but this is a good opportunity for someone
    // to optimize in the future if it ever is a perf issue.

    IFW32FALSE_EXIT(
        rBuffer.Win32Format(
            L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
            rGuid.Data1, rGuid.Data2, rGuid.Data3, rGuid.Data4[0], rGuid.Data4[1], rGuid.Data4[2], rGuid.Data4[3], rGuid.Data4[4], rGuid.Data4[5], rGuid.Data4[6], rGuid.Data4[7]));

    INTERNAL_ERROR_CHECK(rBuffer.Cch() == CCH_GUID);

    FN_EPILOG
}

BOOL
SxspParseGUID(
    PCWSTR String,
    SIZE_T Cch,
    GUID &rGuid
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T ich;
    ULONG i;
    ULONG acc;

    if (Cch != CCH_GUID)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() caller passed in GUID that is %d characters long; GUIDs must be exactly 38 characters long.\n", Cch);
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    ich = 1;

    if (*String++ != L'{')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() caller pass in GUID that does not begin with a left brace ('{')\n");

        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    ich++;

    // Parse the first segment...
    acc = 0;
    for (i=0; i<8; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() given GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data1 = acc;

    // Look for the dash...
    if (*String++ != L'-')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not a dash.\n", ich);
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }
    ich++;

    acc = 0;
    for (i=0; i<4; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() given GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data2 = static_cast<USHORT>(acc);

    // Look for the dash...
    if (*String++ != L'-')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not a dash.\n", ich);
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }
    ich++;

    acc = 0;
    for (i=0; i<4; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() given GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data3 = static_cast<USHORT>(acc);

    // Look for the dash...
    if (*String++ != L'-')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not a dash.\n", ich);
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }
    ich++;

    for (i=0; i<8; i++)
    {
        WCHAR wch1, wch2;

        wch1 = *String++;
        if (!::IsHexDigit(wch1))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
        ich++;

        wch2 = *String++;
        if (!::IsHexDigit(wch2))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
        ich++;

        rGuid.Data4[i] = static_cast<unsigned char>((::HexDigitToValue(wch1) << 4) | ::HexDigitToValue(wch2));

        // There's a dash after the 2nd byte
        if (i == 1)
        {
            if (*String++ != L'-')
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not a dash.\n", ich);
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
            ich++;
        }
    }

    // This replacement should be made.
    //INTERNAL_ERROR_CHECK(ich == CCH_GUID);
    ASSERT(ich == CCH_GUID);

    if (*String != L'}')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() passed in GUID which does not terminate with a closing brace ('}')\n");
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFormatFileTime(
    LARGE_INTEGER ft,
    CBaseStringBuffer &rBuffer
    )
{
    FN_PROLOG_WIN32

    SIZE_T Cch = 0;
    CStringBufferAccessor acc;

    if (ft.QuadPart == 0)
    {
        IFW32FALSE_EXIT(rBuffer.Win32Assign(L"n/a", 3));
        Cch = 3;
    }
    else
    {
        SYSTEMTIME st;
        int iResult;
        int cchDate = 0;
        int cchTime = 0;

        IFW32FALSE_ORIGINATE_AND_EXIT(::FileTimeToSystemTime((FILETIME *) &ft, &st));

        IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::GetDateFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            NULL,
                            0));

        cchDate = iResult - 1;

        IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::GetTimeFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            NULL,
                            0));

        cchTime = iResult - 1;

        IFW32FALSE_EXIT(rBuffer.Win32ResizeBuffer(cchDate + 1 + cchTime + 1, eDoNotPreserveBufferContents));

        acc.Attach(&rBuffer);
        IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::GetDateFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            acc.GetBufferPtr(),
                            cchDate + 1));

        // This replacement should be made.
        //INTERNAL_ERROR_CHECK(iResult == (cchDate + 1));
        ASSERT(iResult == (cchDate + 1));

        acc.GetBufferPtr()[cchDate] = L' ';

        IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::GetTimeFormatW(
                        LOCALE_USER_DEFAULT,
                        LOCALE_USE_CP_ACP,
                        &st,
                        NULL,
                        acc.GetBufferPtr() + cchDate + 1,
                        cchTime + 1));

        // This replacement should be made.
        //INTERNAL_ERROR_CHECK(iResult == (cchTime + 1));
        ASSERT(iResult == (cchTime + 1));

        Cch = (cchDate + 1 + cchTime);
        acc.Detach();
    }

    FN_EPILOG
}



BOOL 
SxspGetNDPGacRootDirectory(
    OUT CBaseStringBuffer &rRootDirectory
    )
{
    FN_PROLOG_WIN32;
    static const WCHAR GacDirectory[] = L"\\Assembly\\GAC";

    //
    // BUGBUG CAUTION: This doesn't know anything about relocating GACs at the moment!
    //
    IFW32FALSE_EXIT(rRootDirectory.Win32Assign(
        USER_SHARED_DATA->NtSystemRoot,
        ::wcslen(USER_SHARED_DATA->NtSystemRoot)));
    IFW32FALSE_EXIT(rRootDirectory.Win32AppendPathElement(
        GacDirectory,
        NUMBER_OF(GacDirectory) - 1));            
    
    FN_EPILOG;
}



BOOL
SxspGetAssemblyRootDirectory(
    CBaseStringBuffer &rBuffer
    )
{
    FN_PROLOG_WIN32

    CStringBufferAccessor acc;

    acc.Attach(&rBuffer);

    if (!::SxspGetAssemblyRootDirectoryHelper(acc.GetBufferCch(), acc.GetBufferPtr(), NULL))
    {
        DWORD dwLastError = ::FusionpGetLastWin32Error();

        if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
            goto Exit;

        SIZE_T CchRequired = 0;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectoryHelper(0, NULL, &CchRequired));
        IFW32FALSE_EXIT(rBuffer.Win32ResizeBuffer(CchRequired + 1, eDoNotPreserveBufferContents));
        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectoryHelper(acc.GetBufferCch(), acc.GetBufferPtr(), NULL));
    }

    acc.Detach();

    FN_EPILOG
}

BOOL
SxspFindLastSegmentOfAssemblyName(
    PCWSTR AssemblyName,
    SIZE_T AssemblyNameCch,
    PCWSTR *LastSegment,
    SIZE_T *LastSegmentCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (LastSegment != NULL)
        *LastSegment = NULL;

    if (LastSegmentCch != NULL)
        *LastSegmentCch = 0;

    PARAMETER_CHECK(LastSegment != NULL);
    PARAMETER_CHECK((AssemblyName != NULL) || (AssemblyNameCch == 0));

    if (AssemblyNameCch != 0)
    {
        PCWSTR LastPartOfAssemblyName = AssemblyName + AssemblyNameCch - 1;
        SIZE_T LastPartOfAssemblyNameCch = 1;

        while (LastPartOfAssemblyName != AssemblyName)
        {
            const WCHAR wch = *LastPartOfAssemblyName;

            if ((wch == L'.') || (wch == L'\\') || (wch == L'/'))
            {
                LastPartOfAssemblyName++;
                LastPartOfAssemblyNameCch--;
                break;
            }

            LastPartOfAssemblyName--;
            LastPartOfAssemblyNameCch++;
        }

        *LastSegment = LastPartOfAssemblyName;
        if (LastSegmentCch != NULL)
            *LastSegmentCch = LastPartOfAssemblyNameCch;
    }
    else
    {
        *LastSegment = NULL;
        if (LastSegmentCch != NULL)
            *LastSegmentCch = 0;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspProcessElementPathMap(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    PCELEMENT_PATH_MAP_ENTRY MapEntries,
    SIZE_T MapEntryCount,
    ULONG &MappedValue,
    bool &Found
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG XMLElementDepth;
    PCWSTR ElementPath;
    SIZE_T ElementPathCch;
    SIZE_T i;

    PARAMETER_CHECK(ParseContext != NULL);
    PARAMETER_CHECK((MapEntries != NULL) || (MapEntryCount == 0));

    XMLElementDepth = ParseContext->XMLElementDepth;
    ElementPath = ParseContext->ElementPath;
    ElementPathCch = ParseContext->ElementPathCch;

    MappedValue = 0;
    Found = false;

    for (i=0; i<MapEntryCount; i++)
    {
        if ((MapEntries[i].ElementDepth == XMLElementDepth) &&
            (MapEntries[i].ElementPathCch == ElementPathCch) &&
            (::FusionpCompareStrings(
                    ElementPath,
                    ElementPathCch,
                    MapEntries[i].ElementPath,
                    ElementPathCch,
                    false) == 0))
        {
            MappedValue = MapEntries[i].MappedValue;
            Found = true;
            break;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspParseUSHORT(
    PCWSTR String,
    SIZE_T Cch,
    USHORT *Value
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    USHORT Temp = 0;

    PARAMETER_CHECK((String != NULL) || (Cch == 0));

    while (Cch != 0)
    {
        WCHAR wch = *String++;

        if ((wch < L'0') || (wch > L'9'))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Error parsing 16-bit unsigned short integer; character other than 0-9 found\n");
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        Temp = (Temp * 10) + (wch - L'0');

        Cch--;
    }

    if (Value != NULL)
        *Value = Temp;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


/*-----------------------------------------------------------------------------
helper function to reduce recursive stack size
-----------------------------------------------------------------------------*/

static VOID
SxspDeleteDirectoryHelper(
    CBaseStringBuffer &dir,
    WIN32_FIND_DATAW &wfd,
    DWORD &dwFirstError
    )
{
    //
    // the reason to add this call here is that if installation ends successfully, the directory
    // would be 
    //    C:\WINDOWS\WINSXS\INSTALLTEMP\15349016
    //                                      +---Manifests
    //
    // and they are "empty" directories (no files). Manifests is a SH dir so set it to be 
    // FILE_ATTRIBUTE_NORMAL be more efficient.
    //
    //                 

    SetFileAttributesW(dir, FILE_ATTRIBUTE_NORMAL);
    if (RemoveDirectoryW(dir)) // empty dir
        return;        

    //
    // this is the *only* "valid" reason for DeleteDirectory fail
    // but I am not sure about "only"
    //
    DWORD dwLastError = ::FusionpGetLastWin32Error(); 
    if ( dwLastError != ERROR_DIR_NOT_EMPTY)
    {
        if (dwFirstError == 0)
            dwFirstError = dwLastError;
        return;
    }

    const static WCHAR SlashStar[] = L"\\*";
    SIZE_T length = dir.Cch();
    CFindFile findFile;

    if (!dir.Win32Append(SlashStar, NUMBER_OF(SlashStar) - 1))
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();
        goto Exit;
    }

    if (!findFile.Win32FindFirstFile(dir, &wfd))
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();
        goto Exit;
    }

    do
    {
        if (FusionpIsDotOrDotDot(wfd.cFileName))
            continue;

        DWORD dwFileAttributes = wfd.dwFileAttributes;

        // Trim back to the slash...
        dir.Left(length + 1);

        if (dir.Win32Append(wfd.cFileName, ::wcslen(wfd.cFileName)))
        {
            if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // recurse
                SxspDeleteDirectoryHelper(dir, wfd, dwFirstError); 
            }
            else
            {
                if (!DeleteFileW(dir))
                {
                    SetFileAttributesW(dir, FILE_ATTRIBUTE_NORMAL);
                    if (!DeleteFileW(dir))
                    {
                        if (dwFirstError == NO_ERROR)
                        {
                            //
                            // continue even in delete file ( delete files as much as possible)
                            // and record the errorCode for first failure
                            //
                            dwFirstError = ::FusionpGetLastWin32Error();
                        }
                    }
                }
            }
        }
    } while (::FindNextFileW(findFile, &wfd));
    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();
    }
Exit:
    if (!findFile.Win32Close()) // otherwise RemoveDirectory fails
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();

    dir.Left(length);

    if (!RemoveDirectoryW(dir)) // the dir must be empty and NORMAL_ATTRIBUTE : ready to delete
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();
    }
}

/*-----------------------------------------------------------------------------
delete a directory recursively, continues upon errors, but returns
FALSE if there were any.
-----------------------------------------------------------------------------*/
BOOL
SxspDeleteDirectory(
    const CBaseStringBuffer &dir
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer mutableDir;

    WIN32_FIND_DATAW wfd = {0};
    DWORD dwFirstError = ERROR_SUCCESS;

    IFW32FALSE_EXIT(mutableDir.Win32Assign(dir));

    mutableDir.RemoveTrailingPathSeparators();

    ::SxspDeleteDirectoryHelper(
        mutableDir,
        wfd,
        dwFirstError);

    //
    // Set wFirstError to Teb->LastWin32Error
    //
    if (dwFirstError != ERROR_SUCCESS)
        goto Exit;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspDeleteDirectory(
    PCWSTR dir,
    ULONG len
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer mutableDir;
    IFW32FALSE_EXIT(mutableDir.Win32Assign(dir, len));    
    IFW32FALSE_EXIT(SxspDeleteDirectory(mutableDir));
    FN_EPILOG
  
}

/*-----------------------------------------------------------------------------
create a unique temp directory under %windir%\WinSxs
-----------------------------------------------------------------------------*/
BOOL
SxspCreateWinSxsTempDirectory(
    OUT CBaseStringBuffer &rbuffTemp,
    OUT SIZE_T *pcch OPTIONAL,
    OUT CBaseStringBuffer *pbuffUniquePart OPTIONAL,
    OUT SIZE_T *pcchUniquePart OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    INT     iTries = 0;
    CSmallStringBuffer uidBuffer;
    CBaseStringBuffer *puidBuffer = (pbuffUniquePart != NULL) ? pbuffUniquePart : &uidBuffer;

    INTERNAL_ERROR_CHECK(rbuffTemp.IsEmpty());
    INTERNAL_ERROR_CHECK(pbuffUniquePart->IsEmpty());

    for (iTries = 0 ; rbuffTemp.IsEmpty() && iTries < 2 ; ++iTries)
    {
        SXSP_LOCALLY_UNIQUE_ID luid;
        IFW32FALSE_EXIT(::SxspCreateLocallyUniqueId(&luid));
        IFW32FALSE_EXIT(::SxspFormatLocallyUniqueId(luid, *puidBuffer));
        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(rbuffTemp));

        rbuffTemp.RemoveTrailingPathSeparators(); // CreateDirectory doesn't like them

        // create \winnt\WinSxs, must not delete even on failure
        if (::CreateDirectoryW(rbuffTemp, NULL))
        {
            // We don't care if this fails.
            ::SetFileAttributesW(rbuffTemp, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
        }
        else if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
        {
            TRACE_WIN32_FAILURE_ORIGINATION(CreateDirectoryW);
            goto Exit;
        }
        // create \winnt\winsxs\manifests, must not delete even on failure

        IFW32FALSE_EXIT(rbuffTemp.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(rbuffTemp.Win32Append(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));
        if (::CreateDirectoryW(rbuffTemp, NULL))
        {
            ::SetFileAttributesW(rbuffTemp, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
        }
        else if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
        {
            TRACE_WIN32_FAILURE_ORIGINATION(CreateDirectoryW);
            goto Exit;
        }
        // restore to be "\winnt\winsxs\"
        rbuffTemp.RemoveLastPathElement(); // void func

#if SXSP_SEMIREADABLE_INSTALL_TEMP
        // create \winnt\WinSxs\InstallTemp, must not delete even on failure
        ASSERT(::SxspIsSfcIgnoredStoreSubdir(ASSEMBLY_INSTALL_TEMP_DIR_NAME));
        IFW32FALSE_EXIT(rbuffTemp.Win32AppendPathElement(ASSEMBLY_INSTALL_TEMP_DIR_NAME, NUMBER_OF(ASSEMBLY_INSTALL_TEMP_DIR_NAME) - 1));
        IFW32FALSE_ORIGINATE_AND_EXIT(::CreateDirectoryW(rbuffTemp, NULL) || ::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS);
#endif
        IFW32FALSE_EXIT(rbuffTemp.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(rbuffTemp.Win32Append(*puidBuffer, puidBuffer->Cch()));

        if (!::CreateDirectoryW(rbuffTemp, NULL))
        {
            rbuffTemp.Clear();
            if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
            {
                TRACE_WIN32_FAILURE_ORIGINATION(CreateDirectoryW);
                goto Exit;
            }
        }
    }

    INTERNAL_ERROR_CHECK(!rbuffTemp.IsEmpty());

    if (pcch != NULL)
        *pcch = rbuffTemp.Cch();

    if (pcchUniquePart != NULL)
        *pcchUniquePart = pbuffUniquePart->Cch();

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspCreateRunOnceDeleteDirectory(
    IN const CBaseStringBuffer &rbuffDirectoryToDelete,
    IN const CBaseStringBuffer *pbuffUniqueKey OPTIONAL,
    OUT PVOID* cookie
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CRunOnceDeleteDirectory* p = NULL;

    IFALLOCFAILED_EXIT(p = new CRunOnceDeleteDirectory);
    IFW32FALSE_EXIT(p->Initialize(rbuffDirectoryToDelete, pbuffUniqueKey));

    *cookie = p;
    p = NULL;
    fSuccess = TRUE;
Exit:
    FUSION_DELETE_SINGLETON(p);
    return fSuccess;
}

BOOL
SxspCancelRunOnceDeleteDirectory(
    PVOID cookie
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CRunOnceDeleteDirectory* p = reinterpret_cast<CRunOnceDeleteDirectory*>(cookie);

    IFW32FALSE_EXIT(p->Cancel());

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CRunOnceDeleteDirectory::Initialize(
    IN const CBaseStringBuffer &rbuffDirectoryToDelete,
    IN const CBaseStringBuffer *pbuffUniqueKey OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmallStringBuffer buffUniqueKey;
    HKEY hKey;
    DWORD dwRegDisposition = 0;
    LONG lReg = 0;
    CStringBuffer buffValue;

    if (!::SxspAtExit(this))
    {
        TRACE_WIN32_FAILURE(SxspAtExit);
        FUSION_DELETE_SINGLETON(this);
        goto Exit;
    }

    if (pbuffUniqueKey == NULL)
    {
        SXSP_LOCALLY_UNIQUE_ID luid;

        IFW32FALSE_EXIT(::SxspCreateLocallyUniqueId(&luid));
        IFW32FALSE_EXIT(::SxspFormatLocallyUniqueId(luid, buffUniqueKey));

        pbuffUniqueKey = &buffUniqueKey;
    }

    IFREGFAILED_ORIGINATE_AND_EXIT(
        lReg =
            ::RegCreateKeyExW(
                hKeyRunOnceRoot,
                rgchRunOnceSubKey,
                0, // reserved
                NULL, // class
                REG_OPTION_NON_VOLATILE,
                KEY_SET_VALUE | FUSIONP_KEY_WOW64_64KEY,
                NULL, // security
                &hKey,
                &dwRegDisposition));

    m_hKey = hKey;

    IFW32FALSE_EXIT(m_strValueName.Win32Assign(rgchRunOnceValueNameBase, ::wcslen(rgchRunOnceValueNameBase)));
    IFW32FALSE_EXIT(m_strValueName.Win32Append(*pbuffUniqueKey));
    IFW32FALSE_EXIT(buffValue.Win32Assign(rgchRunOnePrefix, ::wcslen(rgchRunOnePrefix)));
    IFW32FALSE_EXIT(buffValue.Win32Append(rbuffDirectoryToDelete));

    IFREGFAILED_ORIGINATE_AND_EXIT(
        lReg =
            ::RegSetValueExW(
                hKey,
                m_strValueName,
                0, // reserved
                REG_SZ,
                reinterpret_cast<const BYTE*>(static_cast<PCWSTR>(buffValue)),
                static_cast<ULONG>((buffValue.Cch() + 1) * sizeof(WCHAR))));

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

CRunOnceDeleteDirectory::~CRunOnceDeleteDirectory(
    )
{
    CSxsPreserveLastError ple;
    this->Cancel();
    ple.Restore();
}

BOOL
CRunOnceDeleteDirectory::Close(
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    // very unusual.. this is noncrashing, but
    // leaves the stuff in the registry
    m_strValueName.Clear();
    IFW32FALSE_EXIT(m_hKey.Win32Close());
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CRunOnceDeleteDirectory::Cancel(
    )
{
    BOOL fSuccess = TRUE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_strValueName.IsEmpty())
    {
        LONG lReg = ::RegDeleteValueW(m_hKey, m_strValueName);
        if (lReg != ERROR_SUCCESS)
        {
            fSuccess = FALSE;
            ::FusionpSetLastWin32Error(lReg);
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): RegDeleteValueW(RunOnce,%ls) failed:%ld\n",
                __FUNCTION__,
                static_cast<PCWSTR>(m_strValueName),
                lReg);
        }
    }
    if (!m_hKey.Win32Close())
    {
        fSuccess = FALSE;
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(): RegCloseKey(RunOnce) failed:%ld\n",
            __FUNCTION__,
            ::FusionpGetLastWin32Error()
           );
    }
    m_strValueName.Clear();

    if (fSuccess && ::SxspTryCancelAtExit(this))
        FUSION_DELETE_SINGLETON(this);

    return fSuccess;
}

/* ///////////////////////////////////////////////////////////////////////////////////////
 CurrentDirectory
        is fully qualified directory path, for example, "c:\tmp"
   pwszNewDirs
        is a string such as "a\b\c\d",  this function would create "c:\tmp\a", "c:\tmp\a\b",
        "c:\tmp\a\b\c", and "c:\tmp\a\b\c\d"
Merge this with util\io.cpp\FusionpCreateDirectories.
///////////////////////////////////////////////////////////////////////////////////////// */
BOOL SxspCreateMultiLevelDirectory(PCWSTR CurrentDirectory, PCWSTR pwszNewDirs)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR p = NULL, p2 = NULL;
    CStringBuffer FullPathSubDirBuf;
    WCHAR ch ;

    PARAMETER_CHECK(pwszNewDirs != NULL);

    p = pwszNewDirs;
    ch = *p ;
    IFW32FALSE_EXIT(FullPathSubDirBuf.Win32Assign(CurrentDirectory, ::wcslen(CurrentDirectory)));

    while (ch)
    {
        p2 = p ;
        while(ch)
        {
            if ((ch == L'\\') || (ch == L'/') || (ch == L'\0'))
                break;

            p ++;
            ch = *p;
        }

        if (ch == L'\0')
            break;

        IFW32FALSE_EXIT(FullPathSubDirBuf.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(FullPathSubDirBuf.Win32Append(p2, p - p2));
        IFW32FALSE_ORIGINATE_AND_EXIT(::CreateDirectoryW(FullPathSubDirBuf, NULL) || ::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS);  // subidrectory created

        p++; // skip '\' or '/'
        ch = *p ;
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}


BOOL SxspInstallDecompressOrCopyFileW(PCWSTR lpSource, PCWSTR lpDest, BOOL bFailIfExists)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    DWORD dwAttrib = GetFileAttributesW(lpDest);

    if (dwAttrib != DWORD(-1))
    {
        if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
        {
            ::SetLastError(ERROR_ACCESS_DENIED);
            goto Exit;
        } 
        
        if (bFailIfExists == FALSE) // fReplaceExist == TRUE
        {
            IFW32FALSE_EXIT(::SetFileAttributesW(lpDest, FILE_ATTRIBUTE_NORMAL));
            IFW32FALSE_EXIT(::DeleteFileW(lpDest));
        }
    }
  
    DWORD err = ::SetupDecompressOrCopyFileW(lpSource, lpDest, NULL);
    if ( err != ERROR_SUCCESS)
    {
        ::SetLastError(err);
        goto Exit;
    }
    
    FN_EPILOG
}

//
// Function : 
//  For files, it try to decompress a compressed file before move,
//  for firectories, it would work as MoveFileExW, fail if the dirs are on different
//  volumns
//
BOOL SxspInstallDecompressAndMoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags,
    BOOL fAwareNonCompressed)
{
    BOOL    fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD   dwTemp1,dwTemp2;
    UINT    uiCompressType;
    PWSTR   pszCompressedFileName = NULL;    

    // 
    // make sure that the source file exists, based on SetupGetFileCompressionInfo() in MSDN :
    //  Because SetupGetFileCompressionInfo determines the compression by referencing the physical file, your setup application 
    //  should ensure that the file is present before calling SetupGetFileCompressionInfo. 
    //   
    dwTemp1 = ::GetFileAttributesW(lpExistingFileName);
    if (dwTemp1 == (DWORD)(-1))
    {
        if (fAwareNonCompressed)
        {
            goto Exit;
        }
        // it is possible that the file existed is named as a.dl_, while the input file name is a.dll, in this case, we 
        // assume that lpExistingFileName is a filename of compressed file, so just go ahead to call SetupDecompressOrCopyFile

        IFW32FALSE_EXIT(::SxspInstallDecompressOrCopyFileW(lpExistingFileName, lpNewFileName, !(dwFlags & MOVEFILE_REPLACE_EXISTING)));

        //
        // try to find the "realname" of the file, which is in compression-format, so that we could delete it
        // because the compressed file is named in a way we do not know, such as a.dl_ or a.dl$, 
       
        if (::SetupGetFileCompressionInfoW(lpExistingFileName, &pszCompressedFileName, &dwTemp1, &dwTemp2, &uiCompressType) != NO_ERROR)
        {
            goto Exit;
        }
       
        IFW32FALSE_EXIT(::SetFileAttributesW(pszCompressedFileName, FILE_ATTRIBUTE_NORMAL));
        IFW32FALSE_EXIT(::DeleteFileW(pszCompressedFileName));
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // for a file which may or maynot be compressed
    //
    if (!(dwTemp1 & FILE_ATTRIBUTE_DIRECTORY))
    {
        //
        // this file is named in normal way, such as "a.dll" but it is also possible that it is compressed
        //
        if (dwFlags & MOVEFILE_REPLACE_EXISTING)
        {
            dwTemp1 = ::GetFileAttributesW(lpNewFileName);
            if ( dwTemp1 != (DWORD) -1)
            {
                IFW32FALSE_EXIT(::SetFileAttributesW(lpNewFileName, FILE_ATTRIBUTE_NORMAL));
                IFW32FALSE_EXIT(::DeleteFileW(lpNewFileName));
            }
        }
        if (! fAwareNonCompressed)
        {
            if (::SetupGetFileCompressionInfoW(lpExistingFileName, &pszCompressedFileName, &dwTemp1, &dwTemp2, &uiCompressType) != NO_ERROR)
            {
                goto Exit;
            }
    
            LocalFree(pszCompressedFileName);
            pszCompressedFileName = NULL;

            if ((dwTemp1 == dwTemp2) && (uiCompressType == FILE_COMPRESSION_NONE ))
            {
                //BUGBUG:
                // this only mean the compress algo is not recognized, may or maynot be compressed
                //
                IFW32FALSE_EXIT(::MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
            }else
            {
                IFW32FALSE_EXIT(::SxspInstallDecompressOrCopyFileW(lpExistingFileName, lpNewFileName, !(dwFlags & MOVEFILE_REPLACE_EXISTING)));

                //
                // try to delete the original file after copy it into destination
                //
                IFW32FALSE_EXIT(::SetFileAttributesW(lpExistingFileName, FILE_ATTRIBUTE_NORMAL));
                IFW32FALSE_EXIT(::DeleteFileW(lpExistingFileName));
            }
        }else
        {
            // already know that the file is non-compressed, move directly
            IFW32FALSE_EXIT(::MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
        }
    }else
    {
        // move a directory, it would just fail as MoveFileExW if the destination is on a different volumn from the source
        IFW32FALSE_EXIT(::MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
    }

    fSuccess = TRUE;
Exit:
    if (pszCompressedFileName != NULL)
        LocalFree(pszCompressedFileName);

    return fSuccess;
}

//
// Function:
//  same as MoveFileExW except
//  (1) if the source is compressed, this func would decompress the file before move
//  (2) if the destination has existed, compare the source and destination in "our" way, if the comparison result is EQUAL
//      exit with TRUE
//
// Note: for directories on different Volumn, it would just fail, as MoveFileExW
BOOL
SxspInstallMoveFileExW(
    CBaseStringBuffer   &moveOrigination,
    CBaseStringBuffer   &moveDestination,
    DWORD               dwFlags,
    BOOL                fAwareNonCompressed
    )
{
    BOOL    fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD   dwLastError;
    CFusionDirectoryDifference directoryDifference;

    if (::SxspInstallDecompressAndMoveFileExW(moveOrigination, moveDestination, dwFlags, fAwareNonCompressed) == 0) // MoveFileExW failed
    {
        //
        // MoveFileExW failed, but if the existing destination is the "same" as the source, the failure is acceptable
        //
        dwLastError = ::FusionpGetLastWin32Error();

        DWORD dwFileAttributes = ::GetFileAttributesW(moveDestination);
#if DBG
        const DWORD dwGetFileAttributesError = ::FusionpGetLastWin32Error();
#endif
        ::FusionpSetLastWin32Error(dwLastError);
        if (dwFileAttributes == INVALID_FILE_ATTRIBUTES)
        {
#if DBG
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): MoveFile(%ls,%ls,%s) failed %lu\n",
                __FUNCTION__,
                static_cast<PCWSTR>(moveOrigination),
                static_cast<PCWSTR>(moveDestination),
                (dwFlags & MOVEFILE_REPLACE_EXISTING) ? "MOVEFILE_REPLACE_EXISTING" : "0",
                dwLastError
                );
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): GetFileAttributes(%ls) failed %lu\n",
                __FUNCTION__,
                static_cast<PCWSTR>(moveDestination),
                dwGetFileAttributesError
                );
#endif
            ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
        }
        if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            //
            // if the destination file has already been there but the error is not ERROR_ALREADY_EXISTS,
            // we give up, otherwise, we would compare the two files later
            //
            if (dwLastError != ERROR_ALREADY_EXISTS)
                /*
                && dwLastError != ERROR_USER_MAPPED_FILE
                && dwLastError != ERROR_ACCESS_DENIED
                && dwLastError != ERROR_SHARING_VIOLATION
                )*/
            {
                ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
            }
        }
        else
        {   
            if (dwLastError != ERROR_ACCESS_DENIED
                && dwLastError != ERROR_ALREADY_EXISTS)
                ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
        }

        //
        // We could delete the file if fReplaceExisting, but that doesn't feel safe.
        //

        //
        // in case there is a preexisting directory, that's probably why the move failed
        //
        if (dwFlags & MOVEFILE_REPLACE_EXISTING)
        {            
            CStringBuffer          tempDirForRenameExistingAway;
            CSmallStringBuffer     uidBuffer;
            CFullPathSplitPointers splitExistingDir;
            BOOL                   fHaveTempDir = FALSE;
            
            //
            // try a directory swap,
            // if that fails, say because some of the files are in use, we'll try other
            // things; though some failures we must bail on (like out of memory)
            //
            IFW32FALSE_EXIT(splitExistingDir.Initialize(moveDestination));
            IFW32FALSE_EXIT(::SxspCreateWinSxsTempDirectory(tempDirForRenameExistingAway, NULL, &uidBuffer, NULL));

            fHaveTempDir = TRUE;

            IFW32FALSE_EXIT(
                tempDirForRenameExistingAway.Win32AppendPathElement(
                    splitExistingDir.m_name,
                    (splitExistingDir.m_name != NULL) ? ::wcslen(splitExistingDir.m_name) : 0));

            //
            // move file into temporary directory, so we do not need worry about Compressed file
            //
            if (!::MoveFileExW(moveDestination, tempDirForRenameExistingAway, FALSE)) // no decompress needed
            {
                dwLastError = ::FusionpGetLastWin32Error();
                if ((dwLastError == ERROR_SHARING_VIOLATION) ||
                    (dwLastError == ERROR_USER_MAPPED_FILE))
                {
                    goto TryMovingFiles;
                }

                ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
            }

            //
            // try again after move the existing dest file into tempDirectory,
            // use DecompressAndMove instead of move because we are trying to copy file into Destination
            //            
            if (!::SxspInstallDecompressAndMoveFileExW(moveOrigination, moveDestination, FALSE, fAwareNonCompressed))
            {
                dwLastError = ::FusionpGetLastWin32Error();
                
                // rollback from temporaray to dest                
                if (!::MoveFileExW(tempDirForRenameExistingAway, moveDestination, FALSE)) // no decompress needed
                {
                    // uh oh, rollback failed, very bad, call in SQL Server..
                    // so much for transactional + replace existing..
                }

                ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
            }

            // success, now just cleanup, do we care about failure here?
            // \winnt\winsxs\installtemp\1234\x86_comctl_6.0
            // -> \winnt\winsxs\installtemp\1234
            tempDirForRenameExistingAway.RemoveLastPathElement();

            SOFT_VERIFY2(::SxspDeleteDirectory(tempDirForRenameExistingAway), "deleted swapped away directory (replace existing)");
            /*
            if (!::SxspDeleteDirectory(tempDirForRenameExistingAway))
            {
                CRunOnceDeleteDirectory runOnceDeleteRenameExistingAwayDirectory;
                runOnceDeleteRenameExistingAwayDirectory.Initialize(tempDirForRenameExistingAway, NULL);
                runOnceDeleteRenameExistingAwayDirectory.Close(); // leave the data in the registry
            }
            */
            goto TryMoveFilesEnd;
TryMovingFiles:
            // need parallel directory walk class (we actually do this in SxspMoveFilesAndSubdirUnderDirectory)
            // otherwise punt
            goto Exit;
            //ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
TryMoveFilesEnd:;
        }
        else // !fReplaceExisting
        {
            // compare them
            // DbgPrint if they vary
            // fail if they vary
            // succeed if they do not vary
            if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!::FusionpCompareDirectoriesSizewiseRecursively(&directoryDifference, moveOrigination, moveDestination))
                {
                    const DWORD Error = ::FusionpGetLastWin32Error();
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: %s(): FusionpCompareDirectoriesSizewiseRecursively(%ls,%ls) failed:%ld\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(moveOrigination),
                        static_cast<PCWSTR>(moveDestination),
                        Error);
                    goto Exit;
                    //ORIGINATE_WIN32_FAILURE_AND_EXIT(FusionpCompareDirectoriesSizewiseRecursively, Error);
                }
                if (directoryDifference.m_e != CFusionDirectoryDifference::eEqual)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: %s(): MoveFile(%ls,%ls) failed, UNequal duplicate assembly : ERROR_ALREADY_EXISTS\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(moveOrigination),
                        static_cast<PCWSTR>(moveDestination));
                    directoryDifference.DbgPrint(moveOrigination, moveDestination);
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(DifferentAssemblyWithSameIdentityAlreadyInstalledAndNotReplaceExisting, ERROR_ALREADY_EXISTS);
                }
                else
                {
                    // They're equal so the installation is effectively done.
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_INFO | FUSION_DBG_LEVEL_INSTALLATION,
                        "SXS.DLL: %s(): MoveFile(%ls,%ls) failed, equal duplicate assembly ignored\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(moveOrigination),
                        static_cast<PCWSTR>(moveDestination));
                    // fall through, no goto Exit
                }
            }
            else // move files
            { 
                // At least let's see if they have the same size.
                WIN32_FILE_ATTRIBUTE_DATA wfadOrigination;
                WIN32_FILE_ATTRIBUTE_DATA wfadDestination;

                IFW32FALSE_EXIT(
                    ::GetFileAttributesExW(
                        moveOrigination,
                        GetFileExInfoStandard,
                        &wfadOrigination));

                IFW32FALSE_EXIT(
                    ::GetFileAttributesExW(
                        moveDestination,
                        GetFileExInfoStandard,
                        &wfadDestination));

                if ((wfadOrigination.nFileSizeHigh == wfadDestination.nFileSizeHigh) &&
                    (wfadOrigination.nFileSizeLow == wfadDestination.nFileSizeLow))
                {
                    // let's call it even

                    // We should use SxspCompareFiles here.
#if DBG
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_INSTALLATION,
                        "SXS: %s - move %ls -> %ls claimed success because files have same size\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(moveOrigination),
                        static_cast<PCWSTR>(moveDestination)
                        );
#endif
                }
                else
                {
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(SxspInstallMoveFileExW, dwLastError);
                }
            }//end of if (dwFlags == SXS_INSTALLATION_MOVE_DIRECTORY)
        } // end of if  (fReplaceFiles)
    } // end of if (MoveFileX())

    fSuccess = TRUE;
Exit:
#if DBG
    if (!fSuccess)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s(0x%lx, %ls, %ls, %s) failing %lu\n",
            __FUNCTION__, dwFlags, static_cast<PCWSTR>(moveOrigination), static_cast<PCWSTR>(moveDestination),
            (dwFlags & MOVEFILE_REPLACE_EXISTING)? "replace_existing" : "do_not_replace_existing", ::FusionpGetLastWin32Error());
    }
#endif
    return fSuccess;
}

inline
bool IsErrorInErrorList(
    DWORD dwError,
    SIZE_T cErrors,
    va_list Errors
    )
{
    for (cErrors; cErrors > 0; cErrors--)
    {
        if (dwError == va_arg(Errors, DWORD))
            return true;
    }

    return false;
}


BOOL
SxspDoesPathCrossReparsePointVa(
    IN PCWSTR pcwszBasePathBuffer,
    IN SIZE_T cchBasePathBuffer,
    IN PCWSTR pcwszTotalPathBuffer,
    IN SIZE_T cchTotalPathBuffer,
    OUT BOOL &CrossesReparsePoint,
    OUT DWORD &rdwLastError,
    SIZE_T cErrors,
    va_list vaOkErrors
    )
{
    FN_PROLOG_WIN32

    CStringBuffer PathWorker;
    CStringBuffer PathRemainder;

    CrossesReparsePoint = FALSE;
    rdwLastError = ERROR_SUCCESS;

    // If the base path is non-null, then great.  Otherwise, the length
    // has to be zero as well.
    PARAMETER_CHECK(
        (pcwszBasePathBuffer != NULL) || 
        ((pcwszBasePathBuffer == NULL) && (cchBasePathBuffer == 0)));
    PARAMETER_CHECK(pcwszTotalPathBuffer != NULL);

    //
    // The base path must start the total path.  It might be easier to allow users
    // to specify a base path and then subdirectories, bu then for the 90% case of
    // people having both a root and a total, they'd have to do the work below to
    // seperate the two.
    //
    if (pcwszBasePathBuffer != NULL)
    {
        PARAMETER_CHECK( ::FusionpCompareStrings(
                pcwszBasePathBuffer,
                cchBasePathBuffer,
                pcwszTotalPathBuffer,
                cchBasePathBuffer,
                true ) == 0 );
    }
    
    //
    // PathWorker will be the path we'll be checking subthings on. Start it off
    // at the base path we were given.
    //
    // PathRemainder is what's left to process.
    //
    IFW32FALSE_EXIT(PathWorker.Win32Assign(pcwszBasePathBuffer, cchBasePathBuffer));
    IFW32FALSE_EXIT(PathRemainder.Win32Assign(pcwszTotalPathBuffer + cchBasePathBuffer,
        cchTotalPathBuffer - cchBasePathBuffer));
    PathRemainder.RemoveLeadingPathSeparators();

    while ( PathRemainder.Cch() && !CrossesReparsePoint )
    {
        CSmallStringBuffer buffSingleChunk;
        DWORD dwAttributes;
        
        IFW32FALSE_EXIT(PathRemainder.Win32GetFirstPathElement(buffSingleChunk, TRUE));
        if (PathWorker.Cch() == 0)
        {
            IFW32FALSE_EXIT(PathWorker.Win32Assign(buffSingleChunk));
        }
        else
        {
            IFW32FALSE_EXIT(PathWorker.Win32AppendPathElement(buffSingleChunk));
        }
        
        dwAttributes = ::GetFileAttributesW(PathWorker);

        if ( dwAttributes == INVALID_FILE_ATTRIBUTES )
        {
            const DWORD dwError = ::FusionpGetLastWin32Error();
            if (!IsErrorInErrorList(dwError, cErrors, vaOkErrors))
                ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributesW, ::FusionpGetLastWin32Error());
            else
            {
                rdwLastError = dwError;
                FN_SUCCESSFUL_EXIT();
            }
                
        }
        else if ( dwAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
        {
            CrossesReparsePoint = TRUE;
        }
    }
    
    FN_EPILOG
}

BOOL
SxspGetFileAttributesW(
   PCWSTR lpFileName,
   DWORD &rdwFileAttributes,
   DWORD &rdwWin32Error,
   SIZE_T cExceptionalWin32Errors,
   ...
   )
{
    FN_PROLOG_WIN32

    rdwWin32Error = ERROR_SUCCESS;

    if ((rdwFileAttributes = ::GetFileAttributesW(lpFileName)) == ((DWORD) -1))
    {
        SIZE_T i;
        va_list ap;
        const DWORD dwLastError = ::FusionpGetLastWin32Error();

        va_start(ap, cExceptionalWin32Errors);

        for (i=0; i<cExceptionalWin32Errors; i++)
        {
            if (dwLastError == va_arg(ap, DWORD))
            {
                rdwWin32Error = dwLastError;
                break;
            }
        }

        va_end(ap);

        if (i == cExceptionalWin32Errors)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT_EX(dwLastError, ("%s(%ls)", "GetFileAttributesW", lpFileName));
        }
    }

    FN_EPILOG
}

BOOL
SxspGetFileAttributesW(
   PCWSTR lpFileName,
   DWORD &rdwFileAttributes
   )
{
    DWORD dw;
    return ::SxspGetFileAttributesW(lpFileName, rdwFileAttributes, dw, 0);
}

BOOL s_fAreWeInOSSetupMode;
HKEY s_hkeySystemSetup;
#if DBG
EXTERN_C BOOL g_fForceInOsSetupMode = FALSE;
#endif

BOOL WINAPI
FusionpAreWeInOSSetupModeMain(
    HINSTANCE Module,
    DWORD Reason,
    PVOID Reserved
    )
{
    BOOL            fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);    
    LONG            lRegOp;

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH: 
        {
        BOOL fOpenKeyFail=FALSE;               
        IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2( 
            ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, KEY_READ | FUSIONP_KEY_WOW64_64KEY, &s_hkeySystemSetup),
            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_ACCESS_DENIED),
            fOpenKeyFail);
        }
        break;        

    case DLL_PROCESS_DETACH:
        if (s_hkeySystemSetup != NULL)
        {
            if ((lRegOp = RegCloseKey(s_hkeySystemSetup)) != ERROR_SUCCESS)
            {
                ::FusionpSetLastWin32Error(lRegOp);
                TRACE_WIN32_FAILURE(RegCloseKey);
                // but eat the error
            }
            s_hkeySystemSetup = NULL;
        }
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
FusionpAreWeInOSSetupMode(
    BOOL* pfIsInSetup
    )
{
    //
    // Queries to see if we're currently in OS-setup mode.  This is required to avoid
    // some trickiness in the SFC protection system, where we don't want to validate
    // hashes and catalogs during setup.  We just assume that whoever is installing us
    // is really a nice guy and won't muck up the assemblies.
    //
    BOOL    fSuccess = FALSE;
    LONG    lRegOp = ERROR_SUCCESS;
    FN_TRACE_WIN32(fSuccess);
    DWORD   dwType;
    DWORD   dwData = 0;
    DWORD   cbData;

    PARAMETER_CHECK(pfIsInSetup != NULL);

    if (s_hkeySystemSetup == NULL)
    {
        *pfIsInSetup = FALSE;
        fSuccess = TRUE;
        lRegOp = ERROR_SUCCESS;
        goto Exit;
    }
#if DBG
    if (g_fForceInOsSetupMode)
    {
        *pfIsInSetup = TRUE;
        fSuccess = TRUE;
        lRegOp = ERROR_SUCCESS;
        goto Exit;
    }
#endif

    *pfIsInSetup = FALSE;

    cbData = sizeof(dwData);
    IFW32FALSE_EXIT(
        (lRegOp = ::RegQueryValueExW(
                        s_hkeySystemSetup,
                        L"SystemSetupInProgress",
                        NULL,
                        &dwType,
                        reinterpret_cast<PBYTE>(&dwData),
                        &cbData
                        ))
                  == ERROR_SUCCESS
        || lRegOp == ERROR_FILE_NOT_FOUND
        );
    if (lRegOp == ERROR_FILE_NOT_FOUND)
    {
        lRegOp = ERROR_SUCCESS;
        fSuccess = TRUE;
        goto Exit;
    }
    if (dwType != REG_DWORD)
    {
        lRegOp = ERROR_DATATYPE_MISMATCH;
        ::FusionpSetLastWin32Error(lRegOp);
        TRACE_WIN32_FAILURE_ORIGINATION(RegQueryValueExW);
        goto Exit;
    }

    if (dwData != 0)
        *pfIsInSetup = TRUE;

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_VERBOSE,
        "SXS.DLL: Are we in setup mode? %d\n",
        *pfIsInSetup);
#endif

    lRegOp = ERROR_SUCCESS;
    fSuccess = TRUE;
Exit:
    if (lRegOp != ERROR_SUCCESS)
        ::FusionpSetLastWin32Error(lRegOp);
    return fSuccess;
}

BOOL
SxspValidateBoolAttribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    bool fValid = false;
    StringComparisonResult scr;
    bool fValue = false;

    rfValid = false;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize == sizeof(bool)));

    if (rbuff.Cch() == 2)
    {
        IFW32FALSE_EXIT(rbuff.Win32Compare(L"no", 2, scr, NORM_IGNORECASE));
        if (scr == eEquals)
        {
            fValid = true;
            fValue = false;
        }
    }
    else if (rbuff.Cch() == 3)
    {
        IFW32FALSE_EXIT(rbuff.Win32Compare(L"yes", 3, scr, NORM_IGNORECASE));
        if (scr == eEquals)
        {
            fValid = true;
            fValue = true;
        }
    }
    
    if (fValid)
    {
        if (OutputBuffer != NULL)
            *((bool *) OutputBuffer) = fValue;

        OutputBytesWritten = sizeof(bool);
        rfValid = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateUnsigned64Attribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    bool fValid = false;
    bool fBadChar = false;
    bool fOverflow = false;
    ULONGLONG ullOldValue = 0;
    ULONGLONG ullNewValue = 0;
    SIZE_T i, cch;
    PCWSTR psz;

    rfValid = false;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize == sizeof(ULONGLONG)));

    OutputBytesWritten = 0;

    cch = rbuff.Cch();
    psz = rbuff;

    for (i=0; i<cch; i++)
    {
        const WCHAR wch = *psz++;

        if ((wch < L'0') || (wch > L'9'))
        {
            fBadChar = true;
            break;
        }

        ullNewValue = (ullOldValue * 10);

        if (ullNewValue < ullOldValue)
        {
            fOverflow = true;
            break;
        }

        ullOldValue = ullNewValue;
        ullNewValue += (wch - L'0');
        if (ullNewValue < ullOldValue)
        {
            fOverflow = true;
            break;
        }

        ullOldValue = ullNewValue;
    }

    if ((cch != 0) && (!fBadChar) && (!fOverflow))
        fValid = true;

    if (fValid && (OutputBuffer != NULL))
    {
        *((ULONGLONG *) OutputBuffer) = ullNewValue;
        OutputBytesWritten = sizeof(ULONGLONG);
    }

    rfValid = fValid;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateGuidAttribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    GUID *pGuid = (GUID *) OutputBuffer;
    GUID guidWorkaround;

    rfValid = false;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize == sizeof(GUID)));

    if (pGuid == NULL)
        pGuid = &guidWorkaround;

    IFW32FALSE_EXIT(::SxspParseGUID(rbuff, rbuff.Cch(), *pGuid));

    rfValid = true;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateProcessorArchitectureAttribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    USHORT *pPA = (USHORT *) OutputBuffer;

    rfValid = false;

    PARAMETER_CHECK((dwFlags & ~(SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED)) == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize == sizeof(USHORT)));

    if (dwFlags & SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED)
    {
        if (rbuff.Cch() == 1)
        {
            if (rbuff[0] == L'*')
                rfValid = true;
        }
    }

    if (!rfValid)
        IFW32FALSE_EXIT(::FusionpParseProcessorArchitecture(rbuff, rbuff.Cch(), pPA, rfValid));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateLanguageAttribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CBaseStringBuffer *pbuffOut = (CBaseStringBuffer *) OutputBuffer;
    bool fValid = false;

    rfValid = false;

    PARAMETER_CHECK((dwFlags & ~(SXSP_VALIDATE_LANGUAGE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED)) == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize >= sizeof(CBaseStringBuffer)));

    if (dwFlags & SXSP_VALIDATE_LANGUAGE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED)
    {
        if (rbuff.Cch() == 1)
        {
            if (rbuff[0] == L'*')
                fValid = true;
        }
    }

    if (!fValid)
    {
        PCWSTR Cursor = rbuff;
        bool fDashSeen = false;
        WCHAR wch;

        while ((wch = *Cursor++) != L'\0')
        {
            if (wch == '-')
            {
                if (fDashSeen)
                {
                    fValid = false;
                    break;
                }

                fDashSeen = true;
            }
            else if (
                ((wch >= L'a') && (wch <= L'z')) ||
                ((wch >= L'A') && (wch <= L'Z')))
            {
                fValid = true;
            }
            else
            {
                fValid = false;
                break;
            }
        }
    }

    rfValid = fValid;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#define SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_COMMA  0
#define SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_QUOT   1

#if ACTIVATE_NEVER_CALLED_FUNCTION
// ---------------------------------------------------------------------------
// Convert function for Assembly-Attribute-Value :
//        1. for value of assembly-Name, change comma into L"&#x2c;"
//        2. for value of other assembly-identity-attribute, change quotinto L"&#x22;"
// ---------------------------------------------------------------------------
HRESULT SxspConvertAssemblyNameFromFusionToMSInstaller(
    /*in*/        DWORD    dwFlags,
    /*in*/        PCWSTR    pszAssemblyNameFromFusion,
    /*in*/        SIZE_T    CchAssemblyNameFromFusion,
    /*out*/       PWSTR    pszAssemblyNameToDarwin,
    /*in,out*/    SIZE_T    *pCchBuffer)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    SIZE_T  oldt, t=0;
    DWORD    cSpecialChar = 0; // counter for special character, such as comma or quot
    SIZE_T  indexForFusionString , indexForDarwinString , CchSizeRequired = 0;
    PWSTR    pszSpecialCharReplacementString = NULL;
    SIZE_T  CchSpecialCharReplacementString;  // in bytes
    PCWSTR  pszSpecialChar = L"";

    if (((dwFlags != SXS_FUSION_TO_MSI_ATTRIBUTE_VALUE_CONVERSION_COMMA) && (dwFlags != SXS_FUSION_TO_MSI_ATTRIBUTE_VALUE_CONVERSION_QUOT)) ||
        (!pszAssemblyNameFromFusion) || (!pCchBuffer))  // no inout or no output
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (dwFlags == SXS_FUSION_TO_MSI_ATTRIBUTE_VALUE_CONVERSION_COMMA)
    {
        pszSpecialCharReplacementString = SXS_COMMA_STRING;
        CchSpecialCharReplacementString = NUMBER_OF(SXS_COMMA_STRING) - 1;
        pszSpecialChar = L",";
    }
    else
    {
        pszSpecialCharReplacementString  = SXS_QUOT_STRING;
        CchSpecialCharReplacementString = NUMBER_OF(SXS_QUOT_STRING) - 1;
        pszSpecialChar = L"\"";
    }

    if (pszAssemblyNameToDarwin == NULL) // get the length
        *pCchBuffer = 0;

    // get size needed first
    // replace , with &#x2c;  additional 5 characters are needed
    t = wcscspn(pszAssemblyNameFromFusion, pszSpecialChar);
    cSpecialChar = 0 ;
    while (t < CchAssemblyNameFromFusion)
    {
        cSpecialChar ++;
        oldt = t + 1 ;
        t = wcscspn(pszAssemblyNameFromFusion + oldt, pszSpecialChar);
        t = t + oldt;
    }
    CchSizeRequired = cSpecialChar * 5 + CchAssemblyNameFromFusion;
    CchSizeRequired ++; // add one more for trailing NULL

    if (CchSizeRequired > *pCchBuffer)
    {
        *pCchBuffer = CchSizeRequired;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    // begin convert
    indexForFusionString = 0 ;
    indexForDarwinString = 0 ;
    while (indexForFusionString < CchAssemblyNameFromFusion)
    {
        t = wcscspn(pszAssemblyNameFromFusion + indexForFusionString, pszSpecialChar);
        memcpy(pszAssemblyNameToDarwin + indexForDarwinString, pszAssemblyNameFromFusion + indexForFusionString, t*sizeof(WCHAR));
        indexForDarwinString += t;
        indexForFusionString += t;

        if (indexForFusionString < CchAssemblyNameFromFusion) { // a Comma is found, replace it with "&#x22;"
            memcpy(pszAssemblyNameToDarwin+indexForDarwinString,  pszSpecialCharReplacementString, CchSpecialCharReplacementString*sizeof(WCHAR));
            indexForFusionString ++;                                    // skip ","
            indexForDarwinString += CchSpecialCharReplacementString;    //skip "&#x22;"
        }
    }
    pszAssemblyNameToDarwin[indexForDarwinString] = L'\0';

    if (pCchBuffer)
        *pCchBuffer = CchSizeRequired;

    hr = NOERROR;

Exit:
    return hr;
}
#endif
// ---------------------------------------------------------------------------------
// Convert function for Assembly-Attribute-Value :
//        1. for value of assembly-Name, replace L"&#x2c;" by comma
//        2. for value of other assembly-identity-attribute, replace L"&#x22;" by quot
// no new space is allocate, use the old space
// ---------------------------------------------------------------------------------
BOOL SxspConvertAssemblyNameFromMSInstallerToFusion(
    DWORD   dwFlags,                /* in */
    PWSTR   pszAssemblyStringInOut, /*in, out*/
    SIZE_T  CchAssemblyStringIn,    /*in */
    SIZE_T* pCchAssemblyStringOut   /*out */
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PWSTR pCursor = NULL;
    PWSTR pSpecialSubString= NULL;
    WCHAR pSpecialSubStringReplacement;
    SIZE_T index, border;
    SIZE_T CchSpecialSubString;

    PARAMETER_CHECK((dwFlags == SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_COMMA) ||
                          (dwFlags == SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_QUOT));
    PARAMETER_CHECK(pszAssemblyStringInOut != NULL);
    PARAMETER_CHECK(pCchAssemblyStringOut != NULL);

    if (dwFlags == SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_COMMA)
    {
        pSpecialSubStringReplacement= L',';
        pSpecialSubString = SXS_COMMA_STRING;
        CchSpecialSubString = NUMBER_OF(SXS_COMMA_STRING) - 1;
    }
    else
    {
        pSpecialSubStringReplacement = L'"';
        pSpecialSubString = SXS_QUOT_STRING;
        CchSpecialSubString = NUMBER_OF(SXS_QUOT_STRING) - 1;
    }

    index = 0 ;
    border = CchAssemblyStringIn;
    while (index < border)
    {
        pCursor = wcsstr(pszAssemblyStringInOut, pSpecialSubString);
        if (pCursor == NULL)
            break;
        index = pCursor - pszAssemblyStringInOut;
        if (index < border) {
            *pCursor = pSpecialSubStringReplacement;
            index ++;  // skip the special character
            for (SIZE_T i=index; i<border; i++)
            { // reset the input string
                pszAssemblyStringInOut[i] = pszAssemblyStringInOut[i + CchSpecialSubString - 1];
            }
            pCursor ++;
             border -= CchSpecialSubString - 1;
        }
        else
            break;
    }
    *pCchAssemblyStringOut = border;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspDequoteString(
    IN PCWSTR pcwszString,
    IN SIZE_T cchString,
    OUT CBaseStringBuffer &buffDequotedString
    )
{
    FN_PROLOG_WIN32

    SIZE_T cchQuotedString = 0;
    BOOL fNotEnoughBuffer = FALSE;
    
    // 
    // the output string *must* be always shorter than input string because of the logic of the replacement.
    // but it would not a very big difference in the real case. By allocating memory at very beginning it would cut 
    // the loop below. In very rare case, when the input is "plain" and very long, the loop would not help if we do not 
    // allocate space beforehand(bug 360177).
    //
    //
    if (cchString > buffDequotedString.GetBufferCch())
        IFW32FALSE_EXIT(buffDequotedString.Win32ResizeBuffer(cchString + 1, eDoNotPreserveBufferContents));

    for (;;)
    {
        cchQuotedString = buffDequotedString.GetBufferCch();

        CStringBufferAccessor sba;
        sba.Attach(&buffDequotedString);       
        IFW32FALSE_EXIT_UNLESS(
            ::SxspDequoteString(
                0,
                pcwszString,
                cchString,
                sba.GetBufferPtr(),
                &cchQuotedString),
                (::GetLastError() == ERROR_INSUFFICIENT_BUFFER),
                fNotEnoughBuffer );
        

        if ( fNotEnoughBuffer )
        {
            sba.Detach();
            IFW32FALSE_EXIT(buffDequotedString.Win32ResizeBuffer(cchQuotedString, eDoNotPreserveBufferContents));
        }
        else break;
    }

    FN_EPILOG
}

BOOL
SxspCreateAssemblyIdentityFromTextualString(
    PCWSTR pszTextualAssemblyIdentityString,
    PASSEMBLY_IDENTITY *ppAssemblyIdentity
    )
{
    FN_PROLOG_WIN32

    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> pAssemblyIdentity;
    SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference;

    CSmallStringBuffer buffTextualAttributeValue;
    CSmallStringBuffer buffWorkingString;
    CSmallStringBuffer buffNamespaceTwiddle;

    if (ppAssemblyIdentity != NULL)
        *ppAssemblyIdentity = NULL;

    PARAMETER_CHECK(pszTextualAssemblyIdentityString != NULL);
    PARAMETER_CHECK(*pszTextualAssemblyIdentityString != L'\0');
    PARAMETER_CHECK(ppAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &pAssemblyIdentity, 0, NULL));
    IFW32FALSE_EXIT(buffWorkingString.Win32Assign(pszTextualAssemblyIdentityString, ::wcslen(pszTextualAssemblyIdentityString)));

    PCWSTR pcwszIdentityCursor = buffWorkingString;
    PCWSTR pcwszIdentityEndpoint = pcwszIdentityCursor + buffWorkingString.Cch();
    SIZE_T CchAssemblyName = ::StringComplimentSpan(pcwszIdentityCursor, pcwszIdentityEndpoint, L",");

    // Generate the name of the assembly from the first non-comma'd piece of the string
    IFW32FALSE_EXIT(
        ::SxspDequoteString(
            pcwszIdentityCursor,
            CchAssemblyName,
            buffTextualAttributeValue));

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            0,
            pAssemblyIdentity,
            &s_IdentityAttribute_name,
            buffTextualAttributeValue,
            buffTextualAttributeValue.Cch()));

    // Skip the name and the following comma
    pcwszIdentityCursor += ( CchAssemblyName + 1 );

    // Find the namespace:name=value pieces
    while (pcwszIdentityCursor < pcwszIdentityEndpoint)
    {
        SIZE_T cchAttribName = ::StringComplimentSpan(pcwszIdentityCursor, pcwszIdentityEndpoint, L"=");
        PCWSTR pcwszAttribName;

        SIZE_T cchNamespace = ::StringComplimentSpan(pcwszIdentityCursor, pcwszIdentityCursor + cchAttribName, L":" );
        PCWSTR pcwszNamespace;

        SIZE_T cchValue;
        PCWSTR pcwszValue;

        // No namespace
        if (cchNamespace == cchAttribName)
        {
            pcwszNamespace = NULL;
            cchNamespace = 0;
            pcwszAttribName = pcwszIdentityCursor;
        }
        else
        {
            pcwszNamespace = pcwszIdentityCursor;
            // the attribute name is past the namespace and the colon
            pcwszAttribName = pcwszNamespace + cchNamespace + 1;
            cchAttribName -= (cchNamespace + 1);
        }

        // The value is one past the = sign in the chunklet
        pcwszValue = pcwszAttribName + ( cchAttribName + 1);

        // Then a quote, then the string...
        PARAMETER_CHECK((pcwszValue < pcwszIdentityEndpoint) && (pcwszValue[0] == L'"'));
        pcwszValue++;
        cchValue = ::StringComplimentSpan(pcwszValue, pcwszIdentityEndpoint, L"\"");

        {
            PCWSTR pcwszChunkEndpoint = pcwszValue + cchValue;
            PARAMETER_CHECK((pcwszChunkEndpoint < pcwszIdentityEndpoint) && (pcwszChunkEndpoint[0] == L'\"'));
        }

        IFW32FALSE_EXIT(
            ::SxspDequoteString(
                pcwszValue,
                cchValue,
                buffTextualAttributeValue));

        if (cchNamespace != 0)
        {
            IFW32FALSE_EXIT(buffNamespaceTwiddle.Win32Assign(pcwszNamespace, cchNamespace));
            IFW32FALSE_EXIT(
                ::SxspDequoteString(
                    pcwszNamespace,
                    cchNamespace,
                    buffNamespaceTwiddle));

            AttributeReference.Namespace = buffNamespaceTwiddle;
            AttributeReference.NamespaceCch = buffNamespaceTwiddle.Cch();
        }
        else
        {
            AttributeReference.Namespace = NULL;
            AttributeReference.NamespaceCch = 0;
        }

        AttributeReference.Name = pcwszAttribName;
        AttributeReference.NameCch = cchAttribName;

//
#if 0
// Putting in this code is the fix for NT5.1 bug #249047 which was postponed to NT6.0.
        //
        // ignore publicKey if it appears in assembly identity,
        // so we generate hashes consistent with identities produced
        // by SxspCreateAssemblyIdentityFromIdentityElement.
        //
        if ((AttributeReference.NamespaceCch == 0) &&
            (::FusionpCompareStrings(
                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY,
                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_CCH,
                AttributeReference.Name,
                AttributeReference.NameCch,
                false) == 0))
        {
            // do nothing; it's publicKey="foo"
        }
        else
#endif
        {
            IFW32FALSE_EXIT(
                ::SxspSetAssemblyIdentityAttributeValue(
                    0,
                    pAssemblyIdentity,
                    &AttributeReference,
                    buffTextualAttributeValue,
                    buffTextualAttributeValue.Cch()));
        }

        pcwszIdentityCursor = pcwszValue + cchValue + 1;
        if (pcwszIdentityCursor == pcwszIdentityEndpoint)
        {
            PARAMETER_CHECK(pcwszIdentityCursor[0] == L'\0');
        }
        else if (pcwszIdentityCursor < pcwszIdentityEndpoint)
        {
            PARAMETER_CHECK(pcwszIdentityCursor[0] == L',');
            pcwszIdentityCursor++;
        }
        else
            ORIGINATE_WIN32_FAILURE_AND_EXIT(BadIdentityString, ERROR_INVALID_PARAMETER);
    }

    *ppAssemblyIdentity  = pAssemblyIdentity.Detach();

    FN_EPILOG
}

BOOL
SxspCreateManifestFileNameFromTextualString(
    DWORD           dwFlags,
    ULONG           PathType,
    const CBaseStringBuffer &AssemblyDirectory,
    PCWSTR          pwszTextualAssemblyIdentityString,
    CBaseStringBuffer &sbPathName
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;

    PARAMETER_CHECK(pwszTextualAssemblyIdentityString != NULL);

    IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(pwszTextualAssemblyIdentityString, &pAssemblyIdentity));

    //
    // generate a FULLY PATH for manifest, such as I:\WINDOWS\WinSxS\Manifests\x86_xxxxxxxxxxxxx_6.0.0.0_en-us_cd4c0d12.Manifest
    //
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            dwFlags,
            PathType,
            AssemblyDirectory,
            AssemblyDirectory.Cch(),
            pAssemblyIdentity,
            sbPathName));

    fSuccess = TRUE;

Exit:
    if (pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return fSuccess ;
}

bool IsCharacterNulOrInSet(WCHAR ch, PCWSTR set)
{
    return (ch == 0 || wcschr(set, ch) != NULL);
}

BOOL
SxsQueryAssemblyInfo(
    DWORD dwFlags,
    PCWSTR pwzTextualAssembly,
    ASSEMBLY_INFO *pAsmInfo
    )
{
    CSmartRef<CAssemblyName> pName;
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL fInstalled = FALSE;

    PARAMETER_CHECK((dwFlags == 0) && (pwzTextualAssembly != NULL));

    IFCOMFAILED_EXIT(::CreateAssemblyNameObject((LPASSEMBLYNAME *)&pName, pwzTextualAssembly, CANOF_PARSE_DISPLAY_NAME, NULL));
    IFCOMFAILED_EXIT(pName->IsAssemblyInstalled(fInstalled));
    if (pAsmInfo == NULL)
    {
        if (fInstalled)
            FN_SUCCESSFUL_EXIT();

        // the error value "doesn't matter", Darwin compares against S_OK for equality
        ORIGINATE_WIN32_FAILURE_AND_EXIT(AssemblyNotFound, ERROR_NOT_FOUND);
    }

    if (!fInstalled)
    {
        // pAsmInfo->dwAssemblyFlags |= ASSEMBLYINFO_FLAG_NOT_INSTALLED;
        //
        // Darwin wants FAIL instead of FLAG setting
        //
        ORIGINATE_WIN32_FAILURE_AND_EXIT(AssemblyNotInstalled, ERROR_NOT_FOUND);
    }
    else
    {
        CStringBuffer buffAssemblyPath;        
        PCWSTR pszInstalledPath = NULL;
        DWORD CchInstalledPath = 0 ;
        BOOL fIsPolicy;
        CStringBuffer sbManifestFullPathFileName;

       
        pAsmInfo->dwAssemblyFlags |= ASSEMBLYINFO_FLAG_INSTALLED;
        IFCOMFAILED_EXIT(pName->DetermineAssemblyType(fIsPolicy));

        if (!fIsPolicy)
        {
            //
            // check whether the assembly has a manifest ONLY
            //
            IFCOMFAILED_EXIT(pName->GetInstalledAssemblyName(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                buffAssemblyPath));
            DWORD attrib = ::GetFileAttributesW(buffAssemblyPath);

            if (attrib == DWORD (-1))
            {
                if (::GetLastError() != ERROR_FILE_NOT_FOUND)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributesW, ::GetLastError());
                else
                {
                    IFCOMFAILED_EXIT(
                        pName->GetInstalledAssemblyName(
                            0,
                            SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
                            sbManifestFullPathFileName));
                    pszInstalledPath = sbManifestFullPathFileName;
                    CchInstalledPath = sbManifestFullPathFileName.GetCchAsDWORD();
                }
            }
            else
            {
                pszInstalledPath = buffAssemblyPath;
                CchInstalledPath = buffAssemblyPath.GetCchAsDWORD();
            }
        }
        else // if (fIsPolicy)// it must be a policy
        {   
            IFCOMFAILED_EXIT(
                pName->GetInstalledAssemblyName(
                    SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION,
                    SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY,
                    sbManifestFullPathFileName));

            pszInstalledPath = sbManifestFullPathFileName;
            CchInstalledPath = sbManifestFullPathFileName.GetCchAsDWORD();
        }
        
        if(pAsmInfo->cchBuf >= 1 + CchInstalledPath) // adding 1 for trailing NULL
        {
            memcpy(pAsmInfo->pszCurrentAssemblyPathBuf, pszInstalledPath, CchInstalledPath * sizeof(WCHAR));
            pAsmInfo->pszCurrentAssemblyPathBuf[CchInstalledPath] = L'\0';
        }
        else
        {
            // HACK!  It's too late to fix this but Darwin sometimes doesn't want to get the path at all;
            // there's no way for them to indicate this today but we'll take the convention that if
            // the buffer length is 0 and the buffer pointer is NULL, we'll not fail with ERROR_INSUFFICENT_BUFFER.
            // mgrier 6/21/2001

            if ((pAsmInfo->cchBuf != 0) ||
                (pAsmInfo->pszCurrentAssemblyPathBuf != NULL))
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_INFO,
                    "SXS: %s - insufficient buffer passed in.  cchBuf passed in: %u; cchPath computed: %u\n",
                    __FUNCTION__,
                    pAsmInfo->cchBuf,
                    CchInstalledPath + 1
                    );

                pAsmInfo->cchBuf = 1 + CchInstalledPath;

                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxspExpandRelativePathToFull(
    IN PCWSTR wszString,
    IN SIZE_T cchString,
    OUT CBaseStringBuffer &rsbDestination
    )
{
    BOOL bSuccess = FALSE;
    DWORD dwNeededChars = 0;
    CStringBufferAccessor access;

    FN_TRACE_WIN32(bSuccess);

    access.Attach(&rsbDestination);

    //
    // Try to get the path expansion into our own buffer to start with.
    //
    IFW32ZERO_EXIT(dwNeededChars = ::GetFullPathNameW(wszString, (DWORD)access.GetBufferCch(), access.GetBufferPtr(), NULL));

    //
    // Did we need more characters?
    //
    if (dwNeededChars > access.GetBufferCch())
    {
        //
        // Expand out the buffer to be big enough, then try again.  If it fails again,
        // we're just hosed.
        //
        access.Detach();
        IFW32FALSE_EXIT(rsbDestination.Win32ResizeBuffer(dwNeededChars, eDoNotPreserveBufferContents));
        access.Attach(&rsbDestination);
        IFW32ZERO_EXIT(dwNeededChars = ::GetFullPathNameW(wszString, (DWORD)access.GetBufferCch(), access.GetBufferPtr(), NULL));
        if (dwNeededChars > access.GetBufferCch())
        {
            TRACE_WIN32_FAILURE_ORIGINATION(GetFullPathNameW);
            goto Exit;
        }
    }

    FN_EPILOG
}


BOOL
SxspGetShortPathName(
    IN const CBaseStringBuffer &rcbuffLongPathName,
    OUT CBaseStringBuffer &rbuffShortenedVersion
    )
{
    DWORD dw;
    return ::SxspGetShortPathName(rcbuffLongPathName, rbuffShortenedVersion, dw, 0);
}

BOOL
SxspGetShortPathName(
    IN const CBaseStringBuffer &rcbuffLongPathName,
    OUT CBaseStringBuffer &rbuffShortenedVersion,
    DWORD &rdwWin32Error,
    SIZE_T cExceptionalWin32Errors,
    ...
    )
{
    FN_PROLOG_WIN32

    va_list ap;

    rdwWin32Error = ERROR_SUCCESS;

    for (;;)
    {
        DWORD dwRequired;
        CStringBufferAccessor sba;

        sba.Attach(&rbuffShortenedVersion);

        dwRequired = ::GetShortPathNameW(
            rcbuffLongPathName,
            sba.GetBufferPtr(),
            sba.GetBufferCchAsDWORD());

        if (dwRequired == 0)
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            SIZE_T i;

            va_start(ap, cExceptionalWin32Errors);

            for (i=0; i<cExceptionalWin32Errors; i++)
            {
                if (va_arg(ap, DWORD) == dwLastError)
                {
                    rdwWin32Error = dwLastError;
                    break;
                }
            }

            va_end(ap);

            if (rdwWin32Error != ERROR_SUCCESS)
                FN_SUCCESSFUL_EXIT();
#if DBG
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: GetShortPathNameW(%ls) : %lu\n",
                static_cast<PCWSTR>(rcbuffLongPathName),
                dwLastError
                );
#endif
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetShortPathNameW, dwLastError);
        }
        else if (dwRequired >= sba.GetBufferCch())
        {
            sba.Detach();
            IFW32FALSE_EXIT(
                rbuffShortenedVersion.Win32ResizeBuffer(
                    dwRequired + 1,
                    eDoNotPreserveBufferContents));
        }
        else
        {
            break;
        }
    }

    FN_EPILOG
}


BOOL
SxspValidateIdentity(
    DWORD Flags,
    ULONG Type,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR pszTemp = NULL;
    SIZE_T cchTemp = 0;
    bool fSyntaxValid = false;
    bool fError = false;
    bool fMissingRequiredAttributes = false;
    bool fInvalidAttributeValues = false;

    PARAMETER_CHECK((Flags & ~(
                            SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED |
                            SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED)) == 0);
    PARAMETER_CHECK((Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) || (Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE));
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    //
    // only one of these flags is allowed
    //
    PARAMETER_CHECK(
        (Flags & (SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED | SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED)) !=
                 (SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED | SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED));

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_name,
            &pszTemp,
            &cchTemp));

    if (cchTemp == 0)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            &pszTemp,
            &cchTemp));

    if (cchTemp == 0)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_version,
            &pszTemp,
            &cchTemp));

    if (cchTemp != 0)
    {
        ASSEMBLY_VERSION av;

        IFW32FALSE_EXIT(CFusionParser::ParseVersion(av, pszTemp, cchTemp, fSyntaxValid));

        if (!fSyntaxValid)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE);
    }

    if ((Flags & (SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED | SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED)) != 0)
    {
        if (((Flags & SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED) != 0) && (cchTemp != 0))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE);
        else if (((Flags & SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED) != 0) && (cchTemp == 0))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
    
BOOL CTokenPrivilegeAdjuster::EnablePrivileges()
{
    FN_PROLOG_WIN32
    
    HANDLE hToken;
    CFusionArray<BYTE> bTempBuffer;
    TOKEN_PRIVILEGES *Privs;
    SIZE_T cbSpaceRequired;

    INTERNAL_ERROR_CHECK(!m_fAdjusted);

    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::OpenProcessToken(
            GetCurrentProcess(), 
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
            &hToken));

    //
    // Allocate space, get a pointer to it.
    //
    cbSpaceRequired = sizeof(TOKEN_PRIVILEGES)
        + (sizeof(LUID_AND_ATTRIBUTES) * this->m_Privileges.GetSize());
        
    if (bTempBuffer.GetSize() != cbSpaceRequired)
        IFW32FALSE_EXIT(bTempBuffer.Win32SetSize(cbSpaceRequired));

    if (m_PreviousPrivileges.GetSize() != cbSpaceRequired)
        IFW32FALSE_EXIT(m_PreviousPrivileges.Win32SetSize(cbSpaceRequired));

    Privs = (TOKEN_PRIVILEGES*) bTempBuffer.GetArrayPtr();

    //
    // Set the values
    //
    Privs->PrivilegeCount = m_Privileges.GetSizeAsULONG();

    for (ULONG i = 0; i < Privs->PrivilegeCount; i++)
    {
        Privs->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
        Privs->Privileges[i].Luid = m_Privileges[i];
    }
    
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::AdjustTokenPrivileges(
            hToken,
            FALSE,
            Privs,
            static_cast<ULONG>(cbSpaceRequired),
            (PTOKEN_PRIVILEGES) this->m_PreviousPrivileges.GetArrayPtr(),
            &m_dwReturnedSize));
        //NULL,NULL));

    m_fAdjusted = true;

    FN_EPILOG
}
    
BOOL CTokenPrivilegeAdjuster::DisablePrivileges() {
    FN_PROLOG_WIN32
    
    HANDLE hToken;

    INTERNAL_ERROR_CHECK(m_fAdjusted);

    IFW32FALSE_EXIT(OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken));
    IFW32FALSE_EXIT(AdjustTokenPrivileges(
        hToken,
        FALSE,
        (PTOKEN_PRIVILEGES)m_PreviousPrivileges.GetArrayPtr(),
        0,
        NULL,
        NULL));

    m_fAdjusted = false;
    
    FN_EPILOG
}

BOOL
SxspGenerateAssemblyNameInRegistry(
    IN PCASSEMBLY_IDENTITY pcAsmIdent,
    OUT CBaseStringBuffer &rbuffRegistryName
    )
{
    FN_PROLOG_WIN32

    //BOOL fIsWin32, fIsPolicy;
    //
    // the policies for the same Dll would be stored in reg separately. So, the RegKeyName needs the version in it, 
    // that is, generate the keyName just like assembly manifest
    // See bug 422195
    //
    //IFW32FALSE_EXIT(SxspDetermineAssemblyType( pcAsmIdent, fIsWin32, fIsPolicy));

    IFW32FALSE_EXIT(::SxspGenerateSxsPath(
        //SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | ( fIsPolicy ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0 ),
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT, 
        SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
        NULL,
        0,
        pcAsmIdent,
        rbuffRegistryName));
    
    FN_EPILOG
}

BOOL
SxspGenerateAssemblyNameInRegistry(
    IN const CBaseStringBuffer &rcbuffTextualString,
    OUT CBaseStringBuffer &rbuffRegistryName
    )
{
    FN_PROLOG_WIN32

    CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> pAsmIdent;

    IFW32FALSE_EXIT(SxspCreateAssemblyIdentityFromTextualString(rcbuffTextualString, &pAsmIdent));
    IFW32FALSE_EXIT(SxspGenerateAssemblyNameInRegistry(pAsmIdent, rbuffRegistryName));

    FN_EPILOG
}

BOOL
SxspGetFullPathName(
    IN  PCWSTR pcwszPathName,
    OUT CBaseStringBuffer &rbuffPathName,
    OUT CBaseStringBuffer *pbuffFilePart
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(pcwszPathName != NULL);

    rbuffPathName.Clear();
    if ( pbuffFilePart ) pbuffFilePart->Clear();

    do
    {
        CStringBufferAccessor sba;
        DWORD dwRequired;
        PWSTR pcwszFileChunk = NULL;

        sba.Attach(&rbuffPathName);
        
        dwRequired = ::GetFullPathNameW( 
            pcwszPathName, 
            sba.GetBufferCchAsDWORD(), 
            sba.GetBufferPtr(), 
            &pcwszFileChunk );

        if ( dwRequired == 0 )
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFullPathNameW, ::FusionpGetLastWin32Error());
        }
        else if (dwRequired >= sba.GetBufferCch())
        {
            sba.Detach();
            IFW32FALSE_EXIT(rbuffPathName.Win32ResizeBuffer(dwRequired+1, eDoNotPreserveBufferContents));
        }
        else
        {
            if ( pcwszFileChunk && pbuffFilePart )
            {
                IFW32FALSE_EXIT(pbuffFilePart->Win32Assign(pcwszFileChunk, ::wcslen(pcwszFileChunk)));
            }
            break;
        }
    
    }
    while ( true );
    
    FN_EPILOG
}


#define MPR_DLL_NAME        (L"mpr.dll")

BOOL
SxspGetRemoteUniversalName(
    IN PCWSTR pcszPathName,
    OUT CBaseStringBuffer &rbuffUniversalName
    )
{
    FN_PROLOG_WIN32

    CFusionArray<BYTE> baBufferData;
    REMOTE_NAME_INFOW *pRemoteInfoData;
    DWORD dwRetVal;
    CDynamicLinkLibrary dllMpr;
    DWORD (APIENTRY * pfnWNetGetUniversalNameW)(
        LPCWSTR lpLocalPath,
        DWORD    dwInfoLevel,
        LPVOID   lpBuffer,
        LPDWORD  lpBufferSize
        );

    IFW32FALSE_EXIT(dllMpr.Win32LoadLibrary(MPR_DLL_NAME));
    IFW32FALSE_EXIT(dllMpr.Win32GetProcAddress("WNetGetUniversalNameW", &pfnWNetGetUniversalNameW));

    IFW32FALSE_EXIT(baBufferData.Win32SetSize( MAX_PATH * 2, CFusionArray<BYTE>::eSetSizeModeExact));

    for (;;)
    {
        DWORD dwDataUsed = baBufferData.GetSizeAsDWORD();
        
        dwRetVal = (*pfnWNetGetUniversalNameW)(
            pcszPathName, 
            UNIVERSAL_NAME_INFO_LEVEL,
            (PVOID)baBufferData.GetArrayPtr(),
            &dwDataUsed );

        if ( dwRetVal == WN_MORE_DATA )
        {
            IFW32FALSE_EXIT(baBufferData.Win32SetSize( 
                dwDataUsed, 
                CFusionArray<BYTE>::eSetSizeModeExact )) ;
        }
        else if ( dwRetVal == WN_SUCCESS )
        {
            break;
        }
        else
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NPGetUniversalName, dwRetVal);
        }
    }

    pRemoteInfoData = (REMOTE_NAME_INFOW*)baBufferData.GetArrayPtr();
    ASSERT( pRemoteInfoData != NULL );

    IFW32FALSE_EXIT( rbuffUniversalName.Win32Assign(
        pRemoteInfoData->lpUniversalName,
        lstrlenW(pRemoteInfoData->lpUniversalName)));

    FN_EPILOG
}



BOOL
SxspGetVolumePathName(
    IN DWORD dwFlags,
    IN PCWSTR pcwszVolumePath,
    OUT CBaseStringBuffer &buffVolumePathName
    )
{
    FN_PROLOG_WIN32

    CStringBuffer buffTempPathName;
    CStringBufferAccessor sba;

    PARAMETER_CHECK((dwFlags & ~SXS_GET_VOLUME_PATH_NAME_NO_FULLPATH) == 0);

    IFW32FALSE_EXIT(::SxspGetFullPathName(pcwszVolumePath, buffTempPathName));
    IFW32FALSE_EXIT(
        buffVolumePathName.Win32ResizeBuffer(
            buffTempPathName.Cch() + 1, 
            eDoNotPreserveBufferContents));
    buffVolumePathName.Clear();

    //
    // The documentation for this is somewhat suspect.  It says that the
    // data size required from GetVolumePathNameW will be /less than/
    // the length of the full path of the path name passed in, hence the
    // call to getfullpath above. (This pattern is suggested by MSDN)
    //    
    sba.Attach(&buffVolumePathName);
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::GetVolumePathNameW(
            buffTempPathName,
            sba.GetBufferPtr(),
            sba.GetBufferCchAsDWORD()));
    sba.Detach();

    FN_EPILOG
}


BOOL
SxspGetVolumeNameForVolumeMountPoint(
    IN PCWSTR pcwszMountPoint,
    OUT CBaseStringBuffer &rbuffMountPoint
    )
{
    FN_PROLOG_WIN32

    CStringBufferAccessor sba;

    IFW32FALSE_EXIT(rbuffMountPoint.Win32ResizeBuffer(55, eDoNotPreserveBufferContents));
    rbuffMountPoint.Clear();

    sba.Attach(&rbuffMountPoint);
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::GetVolumeNameForVolumeMountPointW(
            pcwszMountPoint,
            sba.GetBufferPtr(),
            sba.GetBufferCchAsDWORD()));
    sba.Detach();
    
    FN_EPILOG
}


BOOL
SxspExpandEnvironmentStrings(
    IN PCWSTR pcwszSource,
    OUT CBaseStringBuffer &buffTarget
    )
{
    FN_PROLOG_WIN32

    // be wary about about subtracting one from unsigned zero
    PARAMETER_CHECK(buffTarget.GetBufferCch() != 0);

    //
    // ExpandEnvironmentStrings is very rude and doesn't put the trailing NULL
    // into the target if the buffer isn't big enough. This causes the accessor
    // detach to record a size == to the number of characters in the buffer,
    // which fails the integrity check later on.
    //
    do
    {
        CStringBufferAccessor sba;
        sba.Attach(&buffTarget);

        DWORD dwNecessary =
            ::ExpandEnvironmentStringsW(
                pcwszSource, 
                sba.GetBufferPtr(), 
                sba.GetBufferCchAsDWORD() - 1);

        if ( dwNecessary == 0 )
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(ExpandEnvironmentStringsW, ::FusionpGetLastWin32Error());
        }
        else if ( dwNecessary >= (sba.GetBufferCch() - 1) )
        {
            (sba.GetBufferPtr())[sba.GetBufferCch()-1] = UNICODE_NULL;
            sba.Detach();
            IFW32FALSE_EXIT(buffTarget.Win32ResizeBuffer(dwNecessary+1, eDoNotPreserveBufferContents));
        }
        else
        {
            break;
        }
       
    }
    while ( true );

    FN_EPILOG
}




BOOL
SxspDoesMSIStillNeedAssembly(
    IN  PCWSTR pcAsmName,
    OUT BOOL &rfNeedsAssembly
    )
/*++

Purpose:

    Determines whether or not an assembly is still required, according to 
    Darwin.  Since Darwin doesn't pass in an assembly reference to the
    installer API's, we have no way of determining whether or not some
    MSI-installed application actually contains a reference to an
    assembly.

Parameters:

    pcAsmIdent      - Identity of the assembly to be checked in text

    rfNeedsAssembly - OUT flag indicating whether or not the assembly is 
                      still wanted, according to Darwin.  This function
                      errs on the side of caution, and will send back "true"
                      if this information was unavailable, as well as if the
                      assembly was really necessary.

Returns:

    TRUE if there was no error
    FALSE if there was an error.

--*/
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CDynamicLinkLibrary dllMSI;
    CSmallStringBuffer  buffAssemblyName;
    UINT (WINAPI *pfMsiProvideAssemblyW)( LPCWSTR, LPCWSTR, DWORD, DWORD, LPWSTR, DWORD* );
    UINT uiError = 0;

    rfNeedsAssembly = TRUE; // err toward caution in the even of an error

    PARAMETER_CHECK(pcAsmName != NULL);

    IFW32FALSE_EXIT(dllMSI.Win32LoadLibrary(MSI_DLL_NAME_W, 0));
    IFW32FALSE_EXIT(dllMSI.Win32GetProcAddress(MSI_PROVIDEASSEMBLY_NAME, &pfMsiProvideAssemblyW));

    //
    // This is based on a detailed reading of the Darwin code.
    //
    uiError = (*pfMsiProvideAssemblyW)(
        pcAsmName,                              // assembly name
        NULL,                                   // full path to .cfg file
        static_cast<DWORD>(INSTALLMODE_NODETECTION_ANY), // install/reinstall mode
        MSIASSEMBLYINFO_WIN32ASSEMBLY,          // dwAssemblyInfo
        NULL,                                   // returned path buffer
        0);                                     // in/out returned path character count
    switch (uiError)
    {
    default:
    case ERROR_BAD_CONFIGURATION:
    case ERROR_INVALID_PARAMETER:
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MsiProvideAssemblyW, uiError);
        break;
    case ERROR_UNKNOWN_COMPONENT:
        rfNeedsAssembly = FALSE;
        fSuccess = TRUE;
        goto Exit;
    case NO_ERROR:
        rfNeedsAssembly = TRUE;
        fSuccess = TRUE;
        goto Exit;
    }
    fSuccess = FALSE; // unusual
Exit:
    return fSuccess;
}

BOOL
SxspMoveFilesUnderDir(DWORD dwFlags, CStringBuffer & sbSourceDir, CStringBuffer & sbDestDir, DWORD dwMoveFileFlags)
{
    FN_PROLOG_WIN32

    DWORD CchDestDir, CchSourceDir;
    CFindFile findFile;
    WIN32_FIND_DATAW findData;

    PARAMETER_CHECK((dwFlags == 0 ) || (dwFlags == SXSP_MOVE_FILE_FLAG_COMPRESSION_AWARE));

    IFW32FALSE_EXIT(sbSourceDir.Win32EnsureTrailingPathSeparator());
    IFW32FALSE_EXIT(sbDestDir.Win32EnsureTrailingPathSeparator());

    CchDestDir = sbDestDir.GetCchAsDWORD();
    CchSourceDir = sbSourceDir.GetCchAsDWORD();

    IFW32FALSE_EXIT(sbSourceDir.Win32Append(L"*",1));

    IFW32FALSE_EXIT(findFile.Win32FindFirstFile(sbSourceDir, &findData));

    do {
        // skip . and ..
        if (FusionpIsDotOrDotDot(findData.cFileName))
            continue;
        // there shouldn't be any directories, skip them
         
        sbDestDir.Left(CchDestDir);
        sbSourceDir.Left(CchSourceDir);

        IFW32FALSE_EXIT(sbDestDir.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
        IFW32FALSE_EXIT(sbSourceDir.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));

        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            //
            // call itself recursively
            //
            IFW32FALSE_EXIT(::SxspMoveFilesUnderDir(dwFlags, sbSourceDir, sbDestDir, dwMoveFileFlags));
        }

        if ( dwFlags == SXSP_MOVE_FILE_FLAG_COMPRESSION_AWARE)
            IFW32FALSE_EXIT(::SxspInstallMoveFileExW(sbSourceDir, sbDestDir, dwMoveFileFlags));
        else
            IFW32FALSE_EXIT(::MoveFileExW(sbSourceDir, sbDestDir, dwMoveFileFlags));

    } while (::FindNextFileW(findFile, &findData));
    
    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(): FindNextFile() failed:%ld\n",
            __FUNCTION__,
            ::FusionpGetLastWin32Error());
        goto Exit;
    }
    
    if (!findFile.Win32Close())
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(): FindClose() failed:%ld\n",
            __FUNCTION__,
            ::FusionpGetLastWin32Error());
        goto Exit;
    }

    FN_EPILOG;
}

BOOL
SxspGenerateNdpGACPath(
    IN DWORD dwFlags,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    OUT CBaseStringBuffer &rPathBuffer
    )
/*++

Description:

    SxspGenerateNdpGACPath

    Generate a path into the NDP GAC for a given assembly identity.

Parameters:

    dwFlags
        Flags to modify function behavior.  All undefined bits must be zero.

    pAssemblyIdentity
        Pointer to assembly identity for which to generate a path.

    rPathBuffer
        Reference to string buffer to fill in.

--*/
{
    FN_PROLOG_WIN32

    SIZE_T cchName, cchLanguage, cchPublicKeyToken, cchVersion;
    PCWSTR pszName, pszLanguage, pszPublicKeyToken, pszVersion;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(pAssemblyIdentity != NULL);

    rPathBuffer.Clear();

#define GET(x, y, z) \
    do { \
        IFW32FALSE_EXIT( \
            ::SxspGetAssemblyIdentityAttributeValue( \
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, \
            pAssemblyIdentity, \
            &s_IdentityAttribute_ ## x, \
            &psz ## y, \
            &cch ## y)); \
    } while (0)

    GET(name, Name, NAME);
    GET(language, Language, LANGUAGE);
    GET(publicKeyToken, PublicKeyToken, PUBLIC_KEY_TOKEN);
    GET(version, Version, VERSION);

#undef GET

    IFW32FALSE_EXIT(
        rPathBuffer.Win32AssignW(
            9,
            USER_SHARED_DATA->NtSystemRoot, -1,
            L"\\assembly\\GAC\\", -1,
            pszName, static_cast<INT>(cchName),
            L"\\", 1,
            pszVersion, static_cast<INT>(cchVersion),
            L"_", 1,
            pszLanguage, static_cast<INT>(cchLanguage),
            L"_", 1,
            pszPublicKeyToken, static_cast<INT>(cchPublicKeyToken)));

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\drain\drain.cpp ===
void fDrain() { } // just here to have something to compile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\windowclass.cpp ===
#include "stdinc.h"
#include "Sxsp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(versioned);

typedef struct _WINDOW_CLASS_CONTEXT
{
    _WINDOW_CLASS_CONTEXT() { }

    CStringBuffer m_FileNameBuffer;
    bool m_Versioned;
private:
    _WINDOW_CLASS_CONTEXT(const _WINDOW_CLASS_CONTEXT &);
    void operator =(const _WINDOW_CLASS_CONTEXT &);

} WINDOW_CLASS_CONTEXT, *PWINDOW_CLASS_CONTEXT;

typedef struct _WINDOW_CLASS_ENTRY
{
    _WINDOW_CLASS_ENTRY() { }

    CStringBuffer m_FileNameBuffer;
    CStringBuffer m_VersionSpecificWindowClassNameBuffer;

private:
    _WINDOW_CLASS_ENTRY(const _WINDOW_CLASS_ENTRY &);
    void operator =(const _WINDOW_CLASS_ENTRY &);
} WINDOW_CLASS_ENTRY, *PWINDOW_CLASS_ENTRY;

VOID
SxspWindowClassRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();
    PSTRING_SECTION_GENERATION_CONTEXT SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    PWINDOW_CLASS_CONTEXT WindowClassContext = NULL;
    PWINDOW_CLASS_ENTRY Entry = NULL; // deleted on exit if not NULL

    if (SSGenContext != NULL)
        WindowClassContext = (PWINDOW_CLASS_CONTEXT) ::SxsGetStringSectionGenerationContextCallbackContext(SSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        {
            Data->GenBeginning.Success = FALSE;

            INTERNAL_ERROR_CHECK(WindowClassContext == NULL);

            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                IFALLOCFAILED_EXIT(WindowClassContext = new WINDOW_CLASS_CONTEXT);

                if (!::SxsInitStringSectionGenerationContext(
                        &SSGenContext,
                        ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION_FORMAT_WHISTLER,
                        TRUE,
                        &::SxspWindowClassRedirectionStringSectionGenerationCallback,
                        WindowClassContext))
                {
                    FUSION_DELETE_SINGLETON(WindowClassContext);
                    WindowClassContext = NULL;
                    goto Exit;
                }

                Data->Header.ActCtxGenContext = SSGenContext;
            }

            Data->GenBeginning.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (SSGenContext != NULL)
            ::SxsDestroyStringSectionGenerationContext(SSGenContext);
        FUSION_DELETE_SINGLETON(WindowClassContext);
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        {
            Data->AllParsingDone.Success = FALSE;
            if (SSGenContext != NULL)
                IFW32FALSE_EXIT(::SxsDoneModifyingStringSectionGenerationContext(SSGenContext));
            Data->AllParsingDone.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        {
            Data->GetSectionSize.Success = FALSE;
            INTERNAL_ERROR_CHECK( SSGenContext );
            IFW32FALSE_EXIT(::SxsGetStringSectionGenerationContextSectionSize(SSGenContext, &Data->GetSectionSize.SectionSize));
            Data->GetSectionSize.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_PCDATAPARSED:
        {
            Data->PCDATAParsed.Success = FALSE;

            if ((Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT) &&
                (Data->PCDATAParsed.ParseContext->XMLElementDepth == 3) &&
                (::FusionpCompareStrings(
                    Data->PCDATAParsed.ParseContext->ElementPath,
                    Data->PCDATAParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^windowClass",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^windowClass") - 1,
                    false) == 0))
            {
                SIZE_T VersionCch;
                PCWSTR pwszVersion = NULL;

                INTERNAL_ERROR_CHECK2(
                    WindowClassContext != NULL,
                    "Window class context NULL while processing windowClass element");

                IFALLOCFAILED_EXIT(Entry = new WINDOW_CLASS_ENTRY);

                IFW32FALSE_EXIT(Entry->m_FileNameBuffer.Win32Assign(WindowClassContext->m_FileNameBuffer));

                IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, Data->ElementParsed.AssemblyContext->AssemblyIdentity, &s_IdentityAttribute_version, &pwszVersion, &VersionCch));

                if (WindowClassContext->m_Versioned)
                {
                    IFW32FALSE_EXIT(Entry->m_VersionSpecificWindowClassNameBuffer.Win32Assign(pwszVersion, VersionCch));
                    IFW32FALSE_EXIT(Entry->m_VersionSpecificWindowClassNameBuffer.Win32Append(L"!", 1));
                }

                IFW32FALSE_EXIT(Entry->m_VersionSpecificWindowClassNameBuffer.Win32Append(Data->PCDATAParsed.Text, Data->PCDATAParsed.TextCch));

                IFW32FALSE_EXIT(
                    ::SxsAddStringToStringSectionGenerationContext(
                        (PSTRING_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext,
                        Data->PCDATAParsed.Text,
                        Data->PCDATAParsed.TextCch,
                        Entry,
                        Data->PCDATAParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME));

                // Prevent deletion in exit path...
                Entry = NULL;
            }

            // Everything's groovy!
            Data->PCDATAParsed.Success = TRUE;
            break;
        }


    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        {
            Data->ElementParsed.Success = FALSE;

            if ((Data->ElementParsed.ParseContext->XMLElementDepth == 2) &&
                (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file") - 1,
                    false) == 0))
            {
                CStringBuffer FileNameBuffer;
                bool fFound = false;
                SIZE_T cb;

                // capture the name of the file we're parsing...

                IFW32FALSE_EXIT(
                    ::SxspGetAttributeValue(
                        0,
                        &s_AttributeName_name,
                        &Data->ElementParsed,
                        fFound,
                        sizeof(FileNameBuffer),
                        &FileNameBuffer,
                        cb,
                        NULL,
                        0));

                // If there's no NAME attribute, someone else will puke; we'll handle it
                // gracefully.
                if (fFound)
                {
                    if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                    {
                        INTERNAL_ERROR_CHECK(WindowClassContext != NULL);
                        IFW32FALSE_EXIT(WindowClassContext->m_FileNameBuffer.Win32Assign(FileNameBuffer));
                    }
                }
            }
            else if ((Data->ElementParsed.ParseContext->XMLElementDepth == 3) &&
                (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^windowClass",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^windowClass") - 1,
                    false) == 0))
            {
                bool fVersioned = true;
                bool fFound = false;
                SIZE_T cbBytesWritten;

                IFW32FALSE_EXIT(
                    ::SxspGetAttributeValue(
                        0,
                        &s_AttributeName_versioned,
                        &Data->ElementParsed,
                        fFound,
                        sizeof(fVersioned),
                        &fVersioned,
                        cbBytesWritten,
                        &::SxspValidateBoolAttribute,
                        0));

                if (!fFound)
                    fVersioned = true;

                if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                {
                    INTERNAL_ERROR_CHECK(WindowClassContext != NULL);
                    WindowClassContext->m_Versioned = fVersioned;
                }

            }

            // Everything's groovy!
            Data->ElementParsed.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;
        INTERNAL_ERROR_CHECK(SSGenContext != NULL);
        IFW32FALSE_EXIT(
            ::SxsGetStringSectionGenerationContextSectionData(
                SSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));
        Data->GetSectionData.Success = TRUE;
        break;
    }

Exit:
    ;
}

BOOL
SxspWindowClassRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    switch (Reason)
    {
    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PWINDOW_CLASS_ENTRY Entry = (PWINDOW_CLASS_ENTRY) CBData->DataContext;
            FUSION_DELETE_SINGLETON(Entry);
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PWINDOW_CLASS_ENTRY Entry = (PWINDOW_CLASS_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION);
            CBData->DataSize += ((Entry->m_FileNameBuffer.Cch() + 1 +
                                  Entry->m_VersionSpecificWindowClassNameBuffer.Cch() + 1) * sizeof(WCHAR));
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PWINDOW_CLASS_ENTRY Entry = (PWINDOW_CLASS_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Info;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;
            PWSTR Cursor;

            Info = (PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION) CBData->Buffer;
            Cursor = (PWSTR) (Info + 1);

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION);
            Info->Flags = 0;

            IFW32FALSE_EXIT(Entry->m_VersionSpecificWindowClassNameBuffer.Win32CopyIntoBuffer(
                &Cursor,
                &BytesLeft,
                &BytesWritten,
                Info,
                &Info->VersionSpecificClassNameOffset,
                &Info->VersionSpecificClassNameLength));

            IFW32FALSE_EXIT(Entry->m_FileNameBuffer.Win32CopyIntoBuffer(
                &Cursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->DllNameOffset,
                &Info->DllNameLength));

            CBData->BytesWritten = BytesWritten;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxsmain\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

SOURCES_USED=$(SOURCES_USED) ..\sources.inc

TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)
TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)sxsmain

INCLUDES= \
 ..; \
 $(FUSION_PATH)\sxs; \
 $(FUSION_INC_PATH); \
 $(FUSION_PATH)\xmlparser; \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\eventlog\$(FUSION_BUILD_LEAF_DIRECTORY)\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(INCLUDES); \
 $(COM_INC_PATH); \
 $(ADMIN_INC_PATH)

SOURCES=\
 ..\sxsmain.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\jonwis\fastsha1\fastsha1.h ===
#pragma once

typedef DWORD SHA_WORD;
#define SHA1_MESSAGE_BYTE_LENGTH        ( 512/8 )

typedef struct _tagFASTSHA1_STATE
{
    DWORD           cbStruct;
    BOOL            bIsSha1Locked;
    SHA_WORD        dwHValues[5];
    BYTE            bLatestMessage[SHA1_MESSAGE_BYTE_LENGTH];
    DWORD           bLatestMessageSize;
    LARGE_INTEGER   cbTotalMessageSizeInBytes;
}
FASTSHA1_STATE, *PFASTSHA1_STATE;

#ifdef __cplusplus
extern "C" {
#endif

BOOL
InitializeFastSHA1State(
    DWORD dwFlags,
    PFASTSHA1_STATE pState
);


BOOL
FinalizeFastSHA1State(
    DWORD dwFlags,
    PFASTSHA1_STATE pState
);



BOOL
GetFastSHA1Result(
    PFASTSHA1_STATE pState,
    PBYTE pdwDestination,
    PSIZE_T cbDestination
);


BOOL
HashMoreFastSHA1Data(
    PFASTSHA1_STATE pState,
    PBYTE pbData,
    SIZE_T cbData
);

BOOL
CompareFashSHA1Hashes(
    PFASTSHA1_STATE pStateLeft,
    PFASTSHA1_STATE pStateRight,
    BOOL *pbComparesEqual
);

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\jonwis\catalogs\catalogs.cpp ===
#pragma warning(disable : 4512 4511 )

#include "windows.h"
#include "wincrypt.h"
#include <iostream>
#include <xstring>
#include <map>
#include <vector>
#include "stdlib.h"
using namespace std;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PCCERT_CONTEXT GetSignersCert(
    CMSG_SIGNER_INFO const *pSignerInfo,
    HCERTSTORE hExtraStore
    )
{
    PCCERT_CONTEXT  pCertContext = NULL;
    CERT_INFO       certInfo;

    memset(&certInfo, 0, sizeof(CERT_INFO));
    certInfo.SerialNumber = pSignerInfo->SerialNumber;
    certInfo.Issuer = pSignerInfo->Issuer;

    pCertContext = CertGetSubjectCertificateFromStore(
                                    hExtraStore,
                                    X509_ASN_ENCODING,
                                    &certInfo);

    return(pCertContext);

}


static PCMSG_SIGNER_INFO GetSignerInfo(HCRYPTMSG hMsg, DWORD index)
{

    DWORD               cbEncodedSigner = 0;
    BYTE                *pbEncodedSigner = NULL;
    PCMSG_SIGNER_INFO   pSignerInfo = NULL;
    DWORD               cbSignerInfo = 0;

    //
    // get the encoded signer BLOB
    //
    CryptMsgGetParam(hMsg,
                     CMSG_ENCODED_SIGNER,
                     index,
                     NULL,
                     &cbEncodedSigner);

    if (cbEncodedSigner == 0)
    {
        return NULL;
    }

    if (NULL == (pbEncodedSigner = (PBYTE) malloc(cbEncodedSigner)))
    {
        return NULL;
    }

    if (!CryptMsgGetParam(hMsg,
                          CMSG_ENCODED_SIGNER,
                          index,
                          pbEncodedSigner,
                          &cbEncodedSigner))
    {
        free(pbEncodedSigner);
        return NULL;
    }

    //
    // decode the EncodedSigner info
    //
    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
                        PKCS7_SIGNER_INFO,
                        pbEncodedSigner,
                        cbEncodedSigner,
                        0,
                        NULL,
                        &cbSignerInfo))
    {
        free(pbEncodedSigner);
        return NULL;
    }


    if (NULL == (pSignerInfo = (PCMSG_SIGNER_INFO) malloc(cbSignerInfo)))
    {
        free(pbEncodedSigner);
        return NULL;
    }

    if (!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
                        PKCS7_SIGNER_INFO,
                        pbEncodedSigner,
                        cbEncodedSigner,
                        0,
                        pSignerInfo,
                        &cbSignerInfo))
    {
        free(pbEncodedSigner);
        free(pSignerInfo);
        return NULL;
    }

    free(pbEncodedSigner);
    return(pSignerInfo);
}



extern "C" int __cdecl wmain( int argc, WCHAR **argv )
{
    HANDLE hUpdateHandle;
    HANDLE hBlobToReplace;
    DWORD dwByteBlobSize;
    vector<BYTE> ByteBlob;

    hUpdateHandle = BeginUpdateResource( argv[1], FALSE );

    if ( ( hUpdateHandle == NULL ) || ( hUpdateHandle == INVALID_HANDLE_VALUE ) )
    {
        wcerr << L"Unable to open the file " << argv[1] << L" for resource updating" << ::GetLastError() << endl;
        return 1;
    }

    hBlobToReplace = CreateFile(
        argv[2],
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if ( hBlobToReplace == INVALID_HANDLE_VALUE )
    {
        wcerr << L"Unable to open replacement resource file" << argv[2] << L" for reading, " << ::GetLastError() << endl;
        return 2;
    }

    ByteBlob.resize( GetFileSize( hBlobToReplace, NULL ) );

    if ( !ReadFile( hBlobToReplace, &ByteBlob.front(), ByteBlob.size(), &dwByteBlobSize, NULL ) )
    {
        wcerr << L"Unable to read the entire replacement resource, " << ::GetLastError() << endl;
        return 3;
    }

    if ( !UpdateResource (
        hUpdateHandle,
        RT_MANIFEST,
        MAKEINTRESOURCE(_wtoi(argv[3])),
        MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),
        &ByteBlob.front(),
        dwByteBlobSize
    ) )
    {
        wcerr << L"Unable to update the resource " << _wtoi(argv[3]) << " because " << ::GetLastError() << endl;
        return 4;
    }


    if ( !EndUpdateResource( hUpdateHandle, FALSE ) )
    {
        wcerr << L"Unable to write the changed resource back to the file, " << GetLastError() << endl;
        return 5;
    }

    CloseHandle( hBlobToReplace );


#if 0

    PCCTL_CONTEXT   pCtlContext = NULL;
    HANDLE          hCatalogFile = NULL;
    HANDLE          hFileMapping = NULL;
    PVOID            pbFileMapping;
    DWORD            cbFileMappingSize;

    hCatalogFile = CreateFileW(
        argv[1],
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    cbFileMappingSize = GetFileSize( hCatalogFile, NULL );


    if ( ( hCatalogFile == NULL ) || ( hCatalogFile == INVALID_HANDLE_VALUE ) )
    {
        wcerr << L"Unable to open the file " << argv[1] << L", " << GetLastError() << endl;
        return 2;
    }

    hFileMapping = CreateFileMappingW(
        hCatalogFile,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL
    );

    if ( hFileMapping == NULL )
    {
        wcerr << L"Unable to map from the file handle " << hex << hCatalogFile << endl;
        return 3;
    }

    pbFileMapping = MapViewOfFile(
        hFileMapping,
        FILE_MAP_READ,
        0,
        0,
        0
    );


    pCtlContext = (PCCTL_CONTEXT)CertCreateCTLContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        (const BYTE*)pbFileMapping,
        cbFileMappingSize
    );

    if ( pCtlContext == NULL )
    {
        //
        // Urgh..
        //
        wcerr << L"Unable to open the file " << argv[1] << L" as a CTL - " << hex << GetLastError() << endl;
        return 1;
    }

    PCCERT_CONTEXT    pSignerContext = NULL;
    DWORD            dwWhichSignerSigned = 0;
    HCERTSTORE        hCertStore2 = pCtlContext->hCertStore;
    if ( !CryptMsgGetAndVerifySigner(
        pCtlContext->hCryptMsg,
        0,
        &hCertStore2,
        0,
        &pSignerContext,
        &dwWhichSignerSigned
    ) )
    {
        wcerr << L"Unable to validate the signer of this message: " << hex << GetLastError() << endl;
        return 4;
    }

    vector<WCHAR> wchFriendlyString;
    wchFriendlyString.resize( CertGetNameStringW(
        pSignerContext,
        CERT_NAME_FRIENDLY_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0
    ) );

    CertGetNameStringW(
        pSignerContext,
        CERT_NAME_FRIENDLY_DISPLAY_TYPE,
        0,
        NULL,
        &wchFriendlyString.front(),
        wchFriendlyString.size()
    );

    wcerr << L"Signed by " << wstring( wchFriendlyString.begin(), wchFriendlyString.end() ).data() << endl;

#endif
#if 0
    HCERTSTORE hCertStore = NULL;
    HCRYPTMSG hMsgInfo = NULL;

    //
    // What kind of object is this?
    //
    if ( !CryptQueryObject(
            CERT_QUERY_OBJECT_FILE,
            argv[1],
            CERT_QUERY_CONTENT_FLAG_ALL,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0,
            NULL,
            NULL,
            NULL,
            &( hCertStore = NULL ),
            &( hMsgInfo = NULL ),
            NULL
    ) )
    {
        wcerr << L"Error opening " << argv[1] << L" 0x" << hex << GetLastError() << endl;
        return 1;
    }

    //
    // Now that we have a message, we can ask who all has signed it
    //
    PCMSG_SIGNER_INFO pSignerObject = NULL;

    if ( hCertStore == NULL )
    {
        hCertStore = CertOpenStore(
            CERT_STORE_PROV_MSG,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            NULL,
            NULL,
            (const void*)hMsgInfo
        );
    }

    if ( ( hCertStore == INVALID_HANDLE_VALUE ) || ( hCertStore == NULL ) )
    {
        wcerr << L"Error opening the in-message certificate store to look up the signer's certificate." << endl;
        return 2;
    }

    if ( pSignerObject = GetSignerInfo( hMsgInfo, 0 ) )
    {
        PCCERT_CONTEXT pSignerContext = NULL;

        pSignerContext = GetSignersCert( pSignerObject, hCertStore );

    }
#endif

#if 0
    HANDLE  hCatalog;
    HANDLE  hMapping;
    PVOID   pbFileData;
    DWORD   dwFileSize;

    hCatalog = CreateFile( args[0].data(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if ( hCatalog == INVALID_HANDLE_VALUE )
    {
        wcerr << L"Can't open " << args[0].data() << L", " << ::GetLastError() << endl;
        return 1;
    }

    hMapping = CreateFileMappingW(
        hCatalog,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL
    );
    if ( hMapping == NULL )
    {
        wcerr << L"Unable to map " << args[0].data() << L", " << ::GetLastError() << endl;
        return 2;
    }

    pbFileData = MapViewOfFile( hMapping, FILE_MAP_READ, 0, 0, 0 );
    if ( pbFileData == NULL )
    {
        wcerr << L"Mapping view of file failed, " << ::GetLastError() << endl;
        return 3;
    }

    //
    // Tricky:
    //
    PCCTL_CONTEXT pContext = (PCCTL_CONTEXT)CertCreateContex(
        CERT_STORE_CTL_CONTEXT,
        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
        pbFileData,
        cbFileData,
        CERT_CREATE_CONTEXT_NOCOPY_FLAG,
        NULL
    );

    //
    // Whoops
    //
    if ( pContext == NULL )
    {
        wcerr << L"Failed opening the catalog like it's a cert context CTL list." << endl;
        return 4;
    }

    //
    // Let's look at the hMessage member of the cert context created to see
    //
    // CMSG_SIGNER_CERT_INFO_PARAM
    CryptMsgGetParam(
        pContext->hCryptMsg,
        CMSG_SIGNER_CERT_INFO_PARAM,

#endif
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxsmain\sxsmain.cpp ===
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "fusioneventlog.h"
#include "fusiontrace.h"
#include "fusionsha1.h"

extern CRITICAL_SECTION g_csHashFile;

//
// This typedef of a function represents a dll-main startup function.  These are
// called during a DLL_PROCESS_ATTACH call to SxsDllMain in the order they're listed.
//
typedef BOOL (WINAPI *pfnStartupPointer)(
    HINSTANCE hDllInstnace,
    DWORD dwReason,
    PVOID pvReason
   );

/*
MEMORY_BASIC_INFORMATION g_SxsDllMemoryBasicInformation = { 0 };
*/

BOOL WINAPI DllStartup_CrtInit(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI FusionpEventLogMain(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_HeapSetup(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_ActCtxContributors(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_CryptoContext(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_AtExitList(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_AlternateAssemblyStoreRoot(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_SetupLog(HINSTANCE Module, DWORD Reason, PVOID Reserved);
BOOL WINAPI DllStartup_FileHashCriticalSectionInitialization(HINSTANCE Module, DWORD Reason, PVOID Reserved);
BOOL WINAPI FusionpAreWeInOSSetupModeMain(HINSTANCE Module, DWORD Reason, PVOID Reserved);

#define MAKE_STARTUP_RECORD(f) { &f, L#f }

#define SXSP_DLLMAIN_ATTACHED 0x01

const struct StartupFunctionRecord {
    pfnStartupPointer Handler;
    PCWSTR Name;
} g_SxspDllMainStartupPointers[] = {
#if FUSION_WIN
    MAKE_STARTUP_RECORD(DllStartup_CrtInit),
#endif // FUSION_WIN
    MAKE_STARTUP_RECORD(DllStartup_HeapSetup),
    MAKE_STARTUP_RECORD(FusionpEventLogMain),
    MAKE_STARTUP_RECORD(DllStartup_AtExitList),
    MAKE_STARTUP_RECORD(DllStartup_AlternateAssemblyStoreRoot),
    MAKE_STARTUP_RECORD(DllStartup_ActCtxContributors),
    MAKE_STARTUP_RECORD(DllStartup_CryptoContext),
    MAKE_STARTUP_RECORD(DllStartup_SetupLog),
    MAKE_STARTUP_RECORD(DllStartup_FileHashCriticalSectionInitialization),
    MAKE_STARTUP_RECORD(FusionpAreWeInOSSetupModeMain)
};

BYTE g_SxspDllMainStartupStatus[NUMBER_OF(g_SxspDllMainStartupPointers)];

HINSTANCE g_hInstance = NULL;

static SLIST_HEADER sxspAtExitList;

PCWSTR g_AlternateAssemblyStoreRoot = NULL;

#if DBG
PCSTR
FusionpDllMainReasonToString(DWORD Reason)
{
    PCSTR String;

    String =
        (Reason ==  DLL_THREAD_ATTACH) ?  "DLL_THREAD_ATTACH" :
        (Reason ==  DLL_THREAD_DETACH) ?  "DLL_THREAD_DETACH" :
        (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH" :
        (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH" :
        "";

    return String;
}
#endif

extern "C"
BOOL
WINAPI
SxsDllMain(
    HINSTANCE hInst,
    DWORD dwReason,
    PVOID pvReserved
    )
//
// We do not call DisableThreadLibraryCalls
// because some/all versions of the CRT do work in the thread calls,
// allocation and free of the per thread data.
//
{
    //
    // Several "oca" (online crash analysis) bugs show
    // Sxs.dll in various places in DllMain(process_detach) in hung apps.
    // We load in many processes for oleaut/typelibrary support.
    //
    // When ExitProcess is called, it is impossible to leak memory and kernel handles,
    // so it is sufficient and preferrable to do nothing quickly than to go through
    // and free each individual resource.
    //
    // The pvReserved parameter is actually documented as having a meaning.
    // Its NULLness indicates if we are in FreeLibrary or ExitProcess.
    //
    if (dwReason == DLL_PROCESS_DETACH && pvReserved != NULL)
    {
        // For ExitProcess, do nothing quickly.
        return TRUE;
    }

    BOOL    fResult = FALSE;
    SIZE_T  nCounter = 0;

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_VERBOSE,
        "SXS: 0x%lx.0x%lx, %s() %s\n",
        GetCurrentProcessId(),
        GetCurrentThreadId(),
        __FUNCTION__,
        FusionpDllMainReasonToString(dwReason));
#endif

    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        if (!g_SxspDllMainStartupPointers[0].Handler(hInst, dwReason, pvReserved))
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: %s - %ls(DLL_THREAD_ATTACH) failed. Last WinError 0x%08x (%d).\n",
                __FUNCTION__,
                g_SxspDllMainStartupPointers[0].Name,
                dwLastError,
                dwLastError);

            ::SxsDllMain(hInst, DLL_THREAD_DETACH, pvReserved);

            ::FusionpSetLastWin32Error(dwLastError);
            goto Exit;
        }
        break;
    case DLL_THREAD_DETACH:
        if (!g_SxspDllMainStartupPointers[0].Handler(hInst, dwReason, pvReserved))
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: %s - %ls(DLL_THREAD_ATTACH) failed. Last WinError 0x%08x (%d).\n",
                __FUNCTION__,
                g_SxspDllMainStartupPointers[0].Name,
                dwLastError,
                dwLastError);
            // Eat the error, the loader ignores it.
        }
        break;

    case DLL_PROCESS_ATTACH:
        ASSERT_NTC(hInst);
        g_hInstance = hInst;
/*
        if (!VirtualQueryEx(
            GetCurrentProcess(),
            hInst,
            &g_SxsDllMemoryBasicInformation,
            sizeof(g_SxsDllMemoryBasicInformation)))
        {
            FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: %s - Failed querying for the dll's memory boundaries: 0x%08x\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }
*/
        for (nCounter = 0; nCounter != NUMBER_OF(g_SxspDllMainStartupPointers) ; ++nCounter)
        {
            const SIZE_T nIndex = nCounter;
            if (g_SxspDllMainStartupPointers[nIndex].Handler(hInst, dwReason, pvReserved))
            {
                g_SxspDllMainStartupStatus[nIndex] |= SXSP_DLLMAIN_ATTACHED;
            }
            else
            {
                const DWORD dwLastError = ::FusionpGetLastWin32Error();
                //
                // It's a little iffy to set the bit even upon failure, but
                // we do this because we assume individual functions do not handle
                // rollback internally upon attach failure.
                //
                g_SxspDllMainStartupStatus[nIndex] |= SXSP_DLLMAIN_ATTACHED;

                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS: %s - %ls(DLL_PROCESS_ATTACH) failed. Last WinError 0x%08x (%d).\n",
                    __FUNCTION__,
                    g_SxspDllMainStartupPointers[nIndex].Name,
                    dwLastError,
                    dwLastError);

                // pvReserved has approximately the same defined meaning for attach and detach
                ::SxsDllMain(hInst, DLL_PROCESS_DETACH, pvReserved);

                ::FusionpSetLastWin32Error(dwLastError);
                goto Exit;
            }
        }
        break;
    case DLL_PROCESS_DETACH:
        //
        // We always succeed DLL_PROCESS_DETACH, and we do not
        // short circuit it upon failure. The loader in fact
        // ignores what we return.
        //
        for (nCounter = NUMBER_OF(g_SxspDllMainStartupPointers) ; nCounter != 0 ; --nCounter)
        {
            const SIZE_T nIndex = nCounter - 1;
            if ((g_SxspDllMainStartupStatus[nIndex] & SXSP_DLLMAIN_ATTACHED) != 0)
            {
                g_SxspDllMainStartupStatus[nIndex] &= ~SXSP_DLLMAIN_ATTACHED;
                if (!g_SxspDllMainStartupPointers[nIndex].Handler(hInst, dwReason, pvReserved))
                {
                    const DWORD dwLastError = ::FusionpGetLastWin32Error();

                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS: %s - %ls(DLL_PROCESS_DETACH) failed. Last WinError 0x%08x (%d).\n",
                        __FUNCTION__,
                        g_SxspDllMainStartupPointers[nIndex].Name,
                        dwLastError,
                        dwLastError);
                }
            }
        }
        break;
    }
    fResult = TRUE;
Exit:
    return fResult;
}

BOOL
SxspAtExit(
    CCleanupBase* pCleanup
    )
{
    if (!pCleanup->m_fInAtExitList)
    {
        SxspInterlockedPushEntrySList(&sxspAtExitList, pCleanup);
        pCleanup->m_fInAtExitList = true;
    }
    return TRUE;
}

BOOL
SxspTryCancelAtExit(
    CCleanupBase* pCleanup
    )
{
    if (!pCleanup->m_fInAtExitList)
        return FALSE;

    if (::SxspIsSListEmpty(&sxspAtExitList))
    {
        pCleanup->m_fInAtExitList = false;
        return FALSE;
    }

    PSINGLE_LIST_ENTRY pTop = ::SxspInterlockedPopEntrySList(&sxspAtExitList);
    if (pTop == pCleanup)
    {
        pCleanup->m_fInAtExitList = false;
        return TRUE;
    }

    if (pTop != NULL)
        ::SxspInterlockedPushEntrySList(&sxspAtExitList, pTop);
    return FALSE;
}

#define COMMON_HANDLER_PROLOG(dwReason) \
    {  \
        ASSERT_NTC(\
            (dwReason == DLL_PROCESS_ATTACH) || \
            (dwReason == DLL_PROCESS_DETACH) \
       ); \
        if (!(\
            (dwReason == DLL_PROCESS_ATTACH) || \
            (dwReason == DLL_PROCESS_DETACH) \
       )) goto Exit; \
    }

BOOL WINAPI
DllStartup_CryptoContext(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_DETACH:
        fSuccess = SxspReleaseGlobalCryptContext();
        break;
    case DLL_PROCESS_ATTACH:
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}


BOOL WINAPI
DllStartup_AtExitList(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_DETACH:
        {
            CCleanupBase *pCleanup = NULL;
            while (pCleanup = UNCHECKED_DOWNCAST<CCleanupBase*>(SxspPopEntrySList(&sxspAtExitList)))
            {
                pCleanup->m_fInAtExitList = false;
                pCleanup->DeleteYourself();
            }

            fSuccess = TRUE;
        }
        break;

    case DLL_PROCESS_ATTACH:
        ::SxspInitializeSListHead(&sxspAtExitList);
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}

extern "C"
{

BOOL g_fInCrtInit;

//
// This is the internal CRT routine that does the bulk of
// the initialization and uninitialization.
//
BOOL
WINAPI
_CRT_INIT(
    HINSTANCE hDllInstnace,
    DWORD dwReason,
    PVOID pvReason
    );

void
SxspCrtRaiseExit(
    PCSTR    pszCaller,
    int      crtError
    )
//
// all the various CRT functions that end up calling ExitProcess end up here
// see crt0dat.c
//
{
    const static struct
    {
        NTSTATUS ntstatus;
        PCSTR    psz;
    } rgErrors[] =
    {
        { STATUS_FATAL_APP_EXIT, "STATUS_FATAL_APP_EXIT" },
        { STATUS_DLL_INIT_FAILED, "STATUS_DLL_INIT_FAILED" },
    };
    const ULONG nInCrtInit = g_fInCrtInit ? 1 : 0;

    //
    // if (!g_fInCrtInit), then throwing STATUS_DLL_INIT_FAILED is dubious,
    // but there no clearly good answer, maybe STATUS_NO_MEMORY, maybe introduce
    // an NTSTATUS facility to wrap the values in.
    //
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS: [0x%lx.0x%lx] %s(crtError:%d, g_fInCrtInit:%s) calling RaiseException(%08lx %s)\n",
        GetCurrentProcessId(),
        GetCurrentThreadId(),
        pszCaller,
        crtError,
        nInCrtInit ? "true" : "false",
        rgErrors[nInCrtInit].ntstatus,
        rgErrors[nInCrtInit].psz
        );
    ::RaiseException(
        static_cast<DWORD>(rgErrors[nInCrtInit].ntstatus),
        0, // flags
        0, // number of extra parameters
        NULL); // extra parameters
    //
    // RaiseException returns void, and generally doesn't return, though it
    // can if you intervene in a debugger.
    //
}

extern void (__cdecl * _aexit_rtn)(int);

void
__cdecl
SxsCrtAExitRoutine(
    int crtError
    )
//
// This is our replacement for an internal CRT routine that otherwise
// calls ExitProcess.
//
{
    SxspCrtRaiseExit(__FUNCTION__, crtError);
}

}

#if FUSION_WIN
BOOL WINAPI
DllStartup_CrtInit(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
/*
This mess is because
 we need destructors to run, even if there is an exception
 the startup code in msvcrt.dll and libcmt.lib is not very good
   it tends to call MessageBox and/or ExitProcess upon out of memory
   we need it to simply propagate an error
*/
{
    BOOL fSuccess = FALSE;
    DWORD dwExceptionCode;

    __try
    {
        __try
        {
            g_fInCrtInit = TRUE;
            if (dwReason == DLL_PROCESS_ATTACH)
            {
                _aexit_rtn = SxsCrtAExitRoutine;
                //
                // __app_type and __error_mode determine if
                // _CRT_INIT calls MessageBox or WriteFile(GetStdHandle()) upon errors.
                // MessageBox is a big nono in csrss.
                // WriteFile we expect to fail, but that's ok, and they don't check
                // the return value.
                //
                // It should be sufficient to set __error_mode.
                //
                _set_error_mode(_OUT_TO_STDERR);
            }
            fSuccess = _CRT_INIT(hInstance, dwReason, pvReserved);
        }
        __finally
        {
            g_fInCrtInit = FALSE;
        }
    }
    __except(
            (   (dwExceptionCode = GetExceptionCode()) == STATUS_DLL_INIT_FAILED
              || dwExceptionCode == STATUS_FATAL_APP_EXIT
            )
            ? EXCEPTION_EXECUTE_HANDLER
            : EXCEPTION_CONTINUE_SEARCH)
    {
    }
    return fSuccess;
}
#endif // FUSION_WIN

BOOL WINAPI
DllStartup_HeapSetup(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        fSuccess = FusionpInitializeHeap(hInstance);
        break;
    case DLL_PROCESS_DETACH:
#if defined(FUSION_DEBUG_HEAP)
        ::FusionpDumpHeap(L"");
#endif
        ::FusionpUninitializeHeap();
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}



BOOL WINAPI
DllStartup_ActCtxContributors(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        fSuccess = SxspInitActCtxContributors();
        break;
    case DLL_PROCESS_DETACH:
        SxspUninitActCtxContributors();
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}


BOOL
WINAPI
DllStartup_AlternateAssemblyStoreRoot(HINSTANCE, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    //
    // Yes, Virginia, there is a fall-through.
    //
    case DLL_PROCESS_DETACH:
        if (g_AlternateAssemblyStoreRoot != NULL)
        {
            CSxsPreserveLastError ple;
            delete[] const_cast<PWSTR>(g_AlternateAssemblyStoreRoot);
            ple.Restore();
        }

    case DLL_PROCESS_ATTACH:
        g_AlternateAssemblyStoreRoot = NULL;
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}

BOOL
WINAPI
DllStartup_FileHashCriticalSectionInitialization(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pvReserved
    )
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_DETACH:
        ::DeleteCriticalSection(&g_csHashFile);
        fSuccess = TRUE;
        break;

    case DLL_PROCESS_ATTACH:
        ::InitializeCriticalSection(&g_csHashFile);
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\jonwis\fastsha1\fastsha1.c ===
#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "fastsha1.h"

//
// Note - these numbers are from the FIPS-180-1 standard documentation.
// Don't change them, period.
//
#define FASTSHA1_STATE_INITIAL_H0       (0x67452301)
#define FASTSHA1_STATE_INITIAL_H1       (0xEFCDAB89)
#define FASTSHA1_STATE_INITIAL_H2       (0x98BADCFE)
#define FASTSHA1_STATE_INITIAL_H3       (0x10325476)
#define FASTSHA1_STATE_INITIAL_H4       (0xC3D2E1F0)
#define FASTSHA1_FINALIZATION_BYTE        (0x80)

#define HVALUE( state, which ) ( (state).dwHValues[which] )

#define SHA1STATE_A(state) (HVALUE(state, 0))
#define SHA1STATE_B(state) (HVALUE(state, 1))
#define SHA1STATE_C(state) (HVALUE(state, 2))
#define SHA1STATE_D(state) (HVALUE(state, 3))
#define SHA1STATE_E(state) (HVALUE(state, 4))

#define BLOCK_WORD_LENGTH               ( 16 )
#define SHA1_HASH_RESULT_SIZE           ( 20 )
#define BITS_PER_BYTE                   ( 8 )

static SHA_WORD __fastcall swap_order( SHA_WORD w )
{
    return  ( ( ( (w) >> 24 ) & 0x000000FFL ) |
              ( ( (w) >>  8 ) & 0x0000FF00L ) |
              ( ( (w) <<  8 ) & 0x00FF0000L ) |
              ( ( (w) << 24 ) & 0xFF000000L ) );
}

/*
    b   c   d   b&c ~b  ~b&d    (b&c)|(~b&d)
    0   0   0   0   1   0       0
    0   0   1   0   1   1       1
    0   1   0   0   1   0       0
    0   1   1   0   1   1       1
    1   0   0   0   0   0       0
    1   0   1   0   0   0       0
    1   1   0   1   0   0       1
    1   1   1   1   0   0       1
*/
#define F_00( b, c, d )     ( ( (b) & (c) ) | ( ~(b) & (d) ) )


/*
    b   c   d   b^c     b^c^d
    0   0   0   0       0
    0   0   1   0       1
    0   1   0   1       1
    0   1   1   1       0
    1   0   0   1       1
    1   0   1   1       0
    1   1   0   0       0
    1   1   1   0       1

*/
#define F_01( b, c, d )     ( (b) ^ (c) ^ (d) )


/*
    b   c   d   b&c b&d c&d |
    0   0   0   0   0   0   0
    0   0   1   0   0   0   0
    0   1   0   0   0   0   0
    0   1   1   0   0   1   1
    1   0   0   0   0   0   0
    1   0   1   0   1   0   1
    1   1   0   1   0   0   1
    1   1   1   1   1   1   1

    c&d | (b&(c|d))
*/
//#define F_02( b, c, d )     ( ( (b) & (c) ) | ( (b) & (d) ) | ( (c) & (d) ) )
#define F_02( b, c, d )     ( ( (c) & (d) ) | ( (b) & ( (c) | (d) ) ) )
#define F_03( b, c, d )     ( (b) ^ (c) ^ (d) )

static
BOOL
__FastSHA1HashPreparedMessage(
    PFASTSHA1_STATE pState,
    SHA_WORD* pdwMessage
);


BOOL
InitializeFastSHA1State(
    DWORD dwFlags,
    PFASTSHA1_STATE pState
    )
{
    BOOL bOk = FALSE;

    if ( ( !pState ) ||
         ( pState->cbStruct < sizeof( FASTSHA1_STATE ) ) ||
         ( dwFlags != 0 ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    pState->bIsSha1Locked = FALSE;
    ZeroMemory( pState->bLatestMessage, sizeof( pState->bLatestMessage ) );
    pState->bLatestMessageSize = 0;
    pState->cbTotalMessageSizeInBytes.QuadPart = 0;

    HVALUE( *pState, 0 )  = FASTSHA1_STATE_INITIAL_H0;
    HVALUE( *pState, 1 )  = FASTSHA1_STATE_INITIAL_H1;
    HVALUE( *pState, 2 )  = FASTSHA1_STATE_INITIAL_H2;
    HVALUE( *pState, 3 )  = FASTSHA1_STATE_INITIAL_H3;
    HVALUE( *pState, 4 )  = FASTSHA1_STATE_INITIAL_H4;

    bOk = TRUE;
Exit:
    return bOk;
}


BOOL
FinalizeFastSHA1State(
    DWORD dwFlags,
    PFASTSHA1_STATE pState
    )
/*++

Finalizing a SHA1 hash locks the hash state so its value can be queried.
It also ensures that the right padding is done w.r.t. the total bit length
and whatnot required by the SHA1 hash spec.

1 - This should have been called right after a HashMoreFastSHA1Data, so either
    the buffer is entirely empty, or it's got at least eight bits left.

2 - Figure out what the last byte in the message is (easy enough).  The next
    byte should be set to 0x80 - 10000000b.

3 - If this buffer has less than

--*/
{
    BOOL bOk = FALSE;
    LARGE_INTEGER TotalBitsInMessage;
    LARGE_INTEGER *pMsgSizeLocation;

    if ( ( !pState ) ||
         ( pState->cbStruct < sizeof(FASTSHA1_STATE ) ) ||
         ( pState->bIsSha1Locked ) ||
         ( dwFlags != 0 ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }


    //
    // Finalize the SHA1 state data.  This is annoying, but not difficult..
    //

    //
    // When we're in this state, we should have at least one byte of data left over to
    // or in our final flag.  If not, something bad happened at some point along the
    // line.
    //
    if ( ( pState->bLatestMessageSize - SHA1_MESSAGE_BYTE_LENGTH ) < 1 )
    {
        SetLastError( ERROR_INTERNAL_ERROR );
        goto Exit;
    }

    //
    // Into the byte right after the last one we have seen so far, inject a high-bit
    // one.  This translates to 0x80 (see the #define above), since we don't deal in
    // non-integral-byte-numbers of bits.  This bit does NOT change the total number of
    // bits in the message!
    //
    pState->bLatestMessage[pState->bLatestMessageSize++] = FASTSHA1_FINALIZATION_BYTE;

    //
    // We need some space to put the bit count to this point.  If we don't have at least
    // two sha-words (64 bits) in the end of the message, then we need to add this blob
    // of bits to the resulting hash so far.
    //
    if ( ( SHA1_MESSAGE_BYTE_LENGTH - pState->bLatestMessageSize ) < ( sizeof(SHA_WORD) * 2 ) )
    {
        __FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pState->bLatestMessage );
        ZeroMemory( pState->bLatestMessage, sizeof(pState->bLatestMessage) );
        pState->bLatestMessageSize = 0;
    }

    //
    // Now stick the byte count at the end of the blob
    //
    TotalBitsInMessage.QuadPart = pState->cbTotalMessageSizeInBytes.QuadPart * BITS_PER_BYTE;

    //
    // Point our size thing at the right place
    //
    pMsgSizeLocation = (LARGE_INTEGER*)(pState->bLatestMessage + (SHA1_MESSAGE_BYTE_LENGTH - (sizeof(SHA_WORD)*2)));

    //
    // This bit of a mess actually puts the length bits in the right order.
    //
    pMsgSizeLocation->LowPart = swap_order( TotalBitsInMessage.HighPart );
    pMsgSizeLocation->HighPart = swap_order( TotalBitsInMessage.LowPart );

    //
    // And run the hash over this final blob
    //
    __FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pState->bLatestMessage );

    //
    // Rotate our bits around.  This has the unintended side-effect of locking
    // the blob of H-values by messing with their byte order.  All the modifying functions
    // (except initialize) will choke if you try and do something like hash more data
    // with a locked state.
    //
    pState->dwHValues[0] = swap_order( pState->dwHValues[0] );
    pState->dwHValues[1] = swap_order( pState->dwHValues[1] );
    pState->dwHValues[2] = swap_order( pState->dwHValues[2] );
    pState->dwHValues[3] = swap_order( pState->dwHValues[3] );
    pState->dwHValues[4] = swap_order( pState->dwHValues[4] );

    //
    // We're done!
    //
    pState->bIsSha1Locked = TRUE;

    bOk = TRUE;
Exit:
    return bOk;
}





BOOL
GetFastSHA1Result( PFASTSHA1_STATE pState, PBYTE pdwDestination, PSIZE_T cbDestination )
{
    BOOL bOk = FALSE;
    SHA_WORD *pSrc, *pDst;

    //
    // If you are seeing this, something bad has happened with the sizes of things.
    //
    C_ASSERT( SHA1_HASH_RESULT_SIZE == 20 );
    C_ASSERT( SHA1_HASH_RESULT_SIZE == sizeof(pState->dwHValues) );

    if ( !pState || !cbDestination )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    //
    // No fair getting the internal state until you're done with the sha1.
    // IE: Call FinalizeFastSHA1Hash() before requesting the result.
    //
    if ( !pState->bIsSha1Locked )
    {
        SetLastError( ERROR_INVALID_STATE );
        goto Exit;
    }


    //
    // If there's no destination specified, then we'll need to tell them how big
    // the data really is.
    //
    if ( !pdwDestination )
    {
        *cbDestination = SHA1_HASH_RESULT_SIZE;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        goto Exit;
    }


    //
    // Otherwise, copy the state out of the state object and into the desination
    //
    pSrc = pState->dwHValues;
    pDst = (SHA_WORD*)pdwDestination;

    pDst[0] = pSrc[0];
    pDst[1] = pSrc[1];
    pDst[2] = pSrc[2];
    pDst[3] = pSrc[3];
    pDst[4] = pSrc[4];

    bOk = TRUE;
Exit:
    return bOk;
}




//
// These define the core functions of the bit-twiddling in the SHA1 hash
// routine.  If you want optimization, try these first.
// RotateBitsLeft could probably get a boost if we used rol/ror on x86.
//
#define RotateBitsLeft( w, sh ) ( ( w << sh ) | ( w >> ( 32 - sh ) ) )

#define fidgetcore( f, cnst, i ) \
        Temp = cnst + E + WorkBuffer[i] + f( B, C, D ) + RotateBitsLeft( A, 5 ); \
        E = D; \
        D = C;  \
        C = RotateBitsLeft( B, 30 ); \
        B = A; \
        A = Temp;

static void
__SecondaryTwiddle00to19( SHA_WORD *state, SHA_WORD *WorkBuffer )
{
    register A, B, C, D, E, Temp;

    A = state[0];
    B = state[1];
    C = state[2];
    D = state[3];
    E = state[4];

    {
        Temp = RotateBitsLeft( A, 5 ) + E + WorkBuffer[i] + F_00( B, C, D ) + 0x5a827999;
        E = D;
        D = C;
        C = RotateBitsLeft( B, 30 );
        B = A;
        A = Temp;
    }

}


static void
__fastcall __FastSHA1TwiddleBitsCore( SHA_WORD *state, SHA_WORD *WorkBuffer )
{
    register SHA_WORD A, B, C, D, E, Temp;
    register SHA_WORD i;

    A = state[0];
    B = state[1];
    C = state[2];
    D = state[3];
    E = state[4];
/*
    for ( i = 0; i < 80; i++ )
    {
        Temp = RotateBitsLeft( A, 5 ) + E + WorkBuffer[i];

        if ( i <= 19 )      Temp += F_00( B, C, D ) + 0x5a827999;
        else if ( i <= 39 ) Temp += F_01( B, C, D ) + 0x6ed9eba1;
        else if ( i <= 59 ) Temp += F_02( B, C, D ) + 0x8f1bbcdc;
        else Temp += F_03( B, C, D ) + 0xca62c1d6;

        E = D;
        D = C;
        C = RotateBitsLeft( B, 30 );
        B = A;
        A = Temp;
    }

#if 0
    Temp = RBL( A[n-1], 5 ) + E[n-1] + WorkBuffer[t] + F_00( B[n-1], C[n-1], D[n-1] ) + Const
    E = D[n-1];
    D = C[n-1];
    C = RBL( B[n-1], 30 );
    B = A[n-1];
    A = Temp;

    Temp = RBL( Temp, 5 ) + D[n-1] + WorkBuffer[t+1] + F_00( A[n-1], RBL(B[n-1],30), C[n-1]) + Const
    E = C[n-1];
    D = RBL( B[n-1], 30 );
    C = RBL( A[n-1], 30 );
    B = Temp[n-1];
    A = Temp;
#endif


*/
    i = 0;
    {
        // Temp = RotateBitsLeft( A, 5 ) + E + WorkBuffer[i] + F_00(B,C,D) + 0x5a827999;
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
    }

    {
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
    }

    {
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
    }

    {
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
    }

    state[0] += A;
    state[1] += B;
    state[2] += C;
    state[3] += D;
    state[4] += E;

}



static
BOOL
__FastSHA1HashPreparedMessage(
    PFASTSHA1_STATE pState,
    SHA_WORD* pdwMessage
    )
{
    BOOL bOk = FALSE;

    //
    // This function makes a few assumptions.  First, it assumes that pdwMessage really
    // is 16 sha-words long.  If that's not the case, prepare yourself for some
    // ugly errors.  That's why this is static inline - don't be calling this except
    // via HashMoreFastSHA1Data.
    //
    SHA_WORD WorkBuffer[80];
    register SHA_WORD A, B, C, D, E;
    register SHA_WORD Temp;
    register int t;

    if ( !pdwMessage || !pState )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    if ( pState->bIsSha1Locked )
    {
        SetLastError( ERROR_INVALID_STATE );
        goto Exit;
    }

    // Loop unrolling seemed to help a little
#if 1
    {
        register SHA_WORD *pWB = WorkBuffer;
        register SHA_WORD *pMSG = pdwMessage;
        t = 16;

        while ( t ) {
            *(pWB+0) = swap_order( *(pMSG+0) );
            *(pWB+1) = swap_order( *(pMSG+1) );
            *(pWB+2) = swap_order( *(pMSG+2) );
            *(pWB+3) = swap_order( *(pMSG+3) );
            pWB+=4;
            pMSG+=4;
            t-=4;
        }
    }
#else
#define setbuf( n ) WorkBuffer[n] = swap_order(pdwMessage[n])
        setbuf( 0 );    setbuf( 1 );    setbuf( 2 );    setbuf( 3 );
        setbuf( 4 );    setbuf( 5 );    setbuf( 6 );    setbuf( 7 );
        setbuf( 8 );    setbuf( 9 );    setbuf( 10 );   setbuf( 11 );
        setbuf( 12 );   setbuf( 13 );   setbuf( 14 );   setbuf( 15 );
#undef setbuf
#endif

#if 1
    {
        register SHA_WORD *pWB = WorkBuffer+16;
        register SHA_WORD *pWBm3 = pWB-3;
        register SHA_WORD *pWBm8 = pWB-8;
        register SHA_WORD *pWBm14 = pWB-14;
        register SHA_WORD *pWBm16 = pWB-16;
        register DWORD i = 80 - 16;

        while ( i ) {
            *(pWB+0) = *(pWBm3+0) ^ *(pWBm8+0) ^ *(pWBm14+0) ^ *(pWBm16+0);
            *(pWB+1) = *(pWBm3+1) ^ *(pWBm8+1) ^ *(pWBm14+1) ^ *(pWBm16+1);
            *(pWB+2) = *(pWBm3+2) ^ *(pWBm8+2) ^ *(pWBm14+2) ^ *(pWBm16+2);
            *(pWB+3) = *(pWBm3+3) ^ *(pWBm8+3) ^ *(pWBm14+3) ^ *(pWBm16+3);
            *(pWB+4) = *(pWBm3+4) ^ *(pWBm8+4) ^ *(pWBm14+4) ^ *(pWBm16+4);
            *(pWB+5) = *(pWBm3+5) ^ *(pWBm8+5) ^ *(pWBm14+5) ^ *(pWBm16+5);
            *(pWB+6) = *(pWBm3+6) ^ *(pWBm8+6) ^ *(pWBm14+6) ^ *(pWBm16+6);
            *(pWB+7) = *(pWBm3+7) ^ *(pWBm8+7) ^ *(pWBm14+7) ^ *(pWBm16+7);
            pWB += 8;
            i -= 8;
        }
    }


#else
#define xor_update_buf( wb, t, tmp ) \
    tmp = wb[t-3] ^ wb[t-8] ^ wb[t-14] ^ wb[t-16]; \
    wb[t] = RotateBitsLeft( tmp, 1 );

    //
    // Part b - fidget the upper words of workbuffer
    //
    // For t = 16 to 79, let W_t = S^1 ( W_(t-3) xor W_(t-8) xor W_(t-14) xor W_(t-16) )
    //
/*    for (t = 16; t < 80; t++ )
    {
        register SHA_WORD swTemp = WorkBuffer[t-3] ^ WorkBuffer[t-8] ^ WorkBuffer[t-14] ^ WorkBuffer[t-16];
        WorkBuffer[t] = RotateBitsLeft( swTemp, 1 );
    }
  */
    {
        register SHA_WORD swTemp;

        xor_update_buf( WorkBuffer, 16, swTemp );
        xor_update_buf( WorkBuffer, 17, swTemp );
        xor_update_buf( WorkBuffer, 18, swTemp );
        xor_update_buf( WorkBuffer, 19, swTemp );

        xor_update_buf( WorkBuffer, 20, swTemp );
        xor_update_buf( WorkBuffer, 21, swTemp );
        xor_update_buf( WorkBuffer, 22, swTemp );
        xor_update_buf( WorkBuffer, 23, swTemp );
        xor_update_buf( WorkBuffer, 24, swTemp );
        xor_update_buf( WorkBuffer, 25, swTemp );
        xor_update_buf( WorkBuffer, 26, swTemp );
        xor_update_buf( WorkBuffer, 27, swTemp );
        xor_update_buf( WorkBuffer, 28, swTemp );
        xor_update_buf( WorkBuffer, 29, swTemp );

        xor_update_buf( WorkBuffer, 30, swTemp );
        xor_update_buf( WorkBuffer, 31, swTemp );
        xor_update_buf( WorkBuffer, 32, swTemp );
        xor_update_buf( WorkBuffer, 33, swTemp );
        xor_update_buf( WorkBuffer, 34, swTemp );
        xor_update_buf( WorkBuffer, 35, swTemp );
        xor_update_buf( WorkBuffer, 36, swTemp );
        xor_update_buf( WorkBuffer, 37, swTemp );
        xor_update_buf( WorkBuffer, 38, swTemp );
        xor_update_buf( WorkBuffer, 39, swTemp );

        xor_update_buf( WorkBuffer, 40, swTemp );
        xor_update_buf( WorkBuffer, 41, swTemp );
        xor_update_buf( WorkBuffer, 42, swTemp );
        xor_update_buf( WorkBuffer, 43, swTemp );
        xor_update_buf( WorkBuffer, 44, swTemp );
        xor_update_buf( WorkBuffer, 45, swTemp );
        xor_update_buf( WorkBuffer, 46, swTemp );
        xor_update_buf( WorkBuffer, 47, swTemp );
        xor_update_buf( WorkBuffer, 48, swTemp );
        xor_update_buf( WorkBuffer, 49, swTemp );

        xor_update_buf( WorkBuffer, 50, swTemp );
        xor_update_buf( WorkBuffer, 51, swTemp );
        xor_update_buf( WorkBuffer, 52, swTemp );
        xor_update_buf( WorkBuffer, 53, swTemp );
        xor_update_buf( WorkBuffer, 54, swTemp );
        xor_update_buf( WorkBuffer, 55, swTemp );
        xor_update_buf( WorkBuffer, 56, swTemp );
        xor_update_buf( WorkBuffer, 57, swTemp );
        xor_update_buf( WorkBuffer, 58, swTemp );
        xor_update_buf( WorkBuffer, 59, swTemp );

        xor_update_buf( WorkBuffer, 60, swTemp );
        xor_update_buf( WorkBuffer, 61, swTemp );
        xor_update_buf( WorkBuffer, 62, swTemp );
        xor_update_buf( WorkBuffer, 63, swTemp );
        xor_update_buf( WorkBuffer, 64, swTemp );
        xor_update_buf( WorkBuffer, 65, swTemp );
        xor_update_buf( WorkBuffer, 66, swTemp );
        xor_update_buf( WorkBuffer, 67, swTemp );
        xor_update_buf( WorkBuffer, 68, swTemp );
        xor_update_buf( WorkBuffer, 69, swTemp );

        xor_update_buf( WorkBuffer, 70, swTemp );
        xor_update_buf( WorkBuffer, 71, swTemp );
        xor_update_buf( WorkBuffer, 72, swTemp );
        xor_update_buf( WorkBuffer, 73, swTemp );
        xor_update_buf( WorkBuffer, 74, swTemp );
        xor_update_buf( WorkBuffer, 75, swTemp );
        xor_update_buf( WorkBuffer, 76, swTemp );
        xor_update_buf( WorkBuffer, 77, swTemp );
        xor_update_buf( WorkBuffer, 78, swTemp );
        xor_update_buf( WorkBuffer, 79, swTemp );
    }
#endif
    //
    // Part c - Start off the A-F values
    //
    // A = H_0, B = H_1, C = H_2, D = H_3, E = H_4
    //
    __FastSHA1TwiddleBitsCore( pState->dwHValues, WorkBuffer );

    bOk = TRUE;
Exit:
    return bOk;
}


void __fastcall
__ZeroFastSHA1Message( PFASTSHA1_STATE pState )
{
    SHA_WORD *pStateData = (SHA_WORD*)pState->bLatestMessage;
    pState->bLatestMessageSize = 0;

    pStateData[0x0] = 0x0;
    pStateData[0x1] = 0;
    pStateData[0x2] = 0;
    pStateData[0x3] = 0;
    pStateData[0x4] = 0;
    pStateData[0x5] = 0;
    pStateData[0x6] = 0;
    pStateData[0x7] = 0;
    pStateData[0x8] = 0;
    pStateData[0x9] = 0;
    pStateData[0xa] = 0;
    pStateData[0xb] = 0;
    pStateData[0xc] = 0;
    pStateData[0xd] = 0;
    pStateData[0xe] = 0;
    pStateData[0xf] = 0;

}





BOOL
HashMoreFastSHA1Data( PFASTSHA1_STATE pState, PBYTE pbData, SIZE_T cbData )
{
    BOOL bOk = FALSE;
    ULONG cbStreamBlocksThisRound, cbStreamBytesLeftAtEnd;

    if ( !pState || !pbData )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    if ( pState->bIsSha1Locked )
    {
        SetLastError( ERROR_INVALID_STATE );
        goto Exit;
    }

	pState->cbTotalMessageSizeInBytes.QuadPart += cbData;

    //
    // Start off by filling in the pending message buffer block if we can.
    //
    if ( pState->bLatestMessageSize != 0 )
    {
        //
        // Copy into our internal state buffer, then hash what we found.
        //
        SIZE_T cbFiller = sizeof(pState->bLatestMessage) - pState->bLatestMessageSize;
        cbFiller = ( cbFiller > cbData ? cbData : cbFiller );
        memcpy( pState->bLatestMessage + pState->bLatestMessageSize, pbData, cbFiller );

        //
        // Bookkeeping
        //
        cbData -= cbFiller;
        pbData += cbFiller;
        pState->bLatestMessageSize += cbFiller;

        //
        // If that got us up to a full message, then update state.
        //
        if ( pState->bLatestMessageSize == SHA1_MESSAGE_BYTE_LENGTH )
        {
            __FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pState->bLatestMessage );
            __ZeroFastSHA1Message( pState );
        }
        //
        // Otherwise, we still don't have enough to fill up a single buffer, so don't
        // bother doing anything else here.
        //
        else
        {
            bOk = TRUE;
            goto Exit;
        }
    }

    //
    // Now that we've aligned our buffer, find out how many blocks we can process in
    // this input stream.
    //
    cbStreamBlocksThisRound = cbData / SHA1_MESSAGE_BYTE_LENGTH;
    cbStreamBytesLeftAtEnd = cbData % SHA1_MESSAGE_BYTE_LENGTH;

    //
    // Spin through all the full blocks
    //
	if ( cbStreamBlocksThisRound )
	{
		while ( cbStreamBlocksThisRound-- )
		{
			__FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pbData );
			pbData += SHA1_MESSAGE_BYTE_LENGTH;
		}
		__ZeroFastSHA1Message( pState );
	}

    //
    // And account for leftovers
    //
    if ( cbStreamBytesLeftAtEnd )
    {
        pState->bLatestMessageSize = cbStreamBytesLeftAtEnd;
        memcpy( pState->bLatestMessage, pbData, cbStreamBytesLeftAtEnd );
        ZeroMemory( pState->bLatestMessage + cbStreamBytesLeftAtEnd, SHA1_MESSAGE_BYTE_LENGTH - cbStreamBytesLeftAtEnd );
    }


#if 0
    //
    // Until there's no more data to be hashed...
    //
    while ( cbData )
    {
        //
        // Find out how many bytes to copy into the buffer
        //
        SIZE_T cbToCopy = sizeof(pState->bLatestMessage) - pState->bLatestMessageSize;
        cbToCopy = ( cbToCopy > cbData ? cbData : cbToCopy );

        //
        // Do we have at least a full block in the input stream, but we have data left
        // over from previous messages? Then fill up the buffer, hash what's in there,
        // and go again - next time through, we might have what's left over to make
        // a single-pass update.
        //
        if ( cbToCopy != sizeof(pState->bLatestMessage ) )
        {
            memcpy( pState->bLatestMessage + pState->bLatestMessageSize, pbData, cbToCopy );
            if (
            __FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pState->bLatestMessage );
        }
        if ( ( cbToCopy >= SHA1_MESSAGE_BYTE_LENGTH ) && ( pState->bLatestMessageSize == 0 ) )
        {
            //
            // Woo! We have a full block and nothing in the 'latest message' buffer -
            // we can just run the hash updater on this block as it is.
            //
            __FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pbData );
        }
        else if (
        {
            memcpy( pState
        }

        //
        // Spam from the pbData buffer into the latest message buffer
        //
        memcpy(
            pState->bLatestMessage + pState->bLatestMessageSize,
            pbData,
            cbToCopy
        );

        //
        // We're filling up the buffer and moving the buffer pointer toward
        // the end of the buffer, and decrementing the amount of data in the
        // input buffer.
        //
        pState->bLatestMessageSize += cbToCopy;
        pState->cbTotalMessageSizeInBytes.QuadPart += cbToCopy;
        pbData += cbToCopy;
        cbData -= cbToCopy;

        //
        // If we've filled up an input 'message' buffer, then we should go and update
        // the internal structure
        //
        if ( pState->bLatestMessageSize == SHA1_MESSAGE_BYTE_LENGTH )
        {
            if ( !__FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pState->bLatestMessage ) )
            {
                goto Exit;
            }

            //
            // Now that we're done with a block, make it go away
            //
            __ZeroFastSHA1Message( pState );
        }
    }
#endif
    bOk = TRUE;
Exit:
    return bOk;
}

BOOL
CompareFashSHA1Hashes(
    PFASTSHA1_STATE pStateLeft,
    PFASTSHA1_STATE pStateRight,
    BOOL *pbComparesEqual
    )
{
    BOOL bOk = FALSE;

    if ( pbComparesEqual ) *pbComparesEqual = FALSE;

    if ( !pStateLeft || !pStateRight || !pbComparesEqual )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    if ( !pStateLeft->bIsSha1Locked || !pStateRight->bIsSha1Locked )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    //
    // Easy way out: compare the two blobs of H's to see if they're equal.
    //
    *pbComparesEqual = ( memcmp(
            pStateLeft->dwHValues,
            pStateRight->dwHValues,
            sizeof(SHA_WORD)*5 ) == 0 );

    bOk = TRUE;
Exit:
    return bOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\jonwis\interop\interops.cpp ===
#include "stdinc.h"
#include "fusionbuffer.h"
#include "sxstypes.h"
#include "sxsapi.h"

#ifndef NUMBER_OF
#define NUMBER_OF(x) (sizeof(x)/sizeof(*x))
#endif

class CActivateActCtx
{
    HANDLE &m_hActCtx;
    ULONG_PTR ulpCookie;
    CActivateActCtx(const CActivateActCtx&);
    void operator=(const CActivateActCtx&);
public:
    CActivateActCtx(HANDLE &hctx) : m_hActCtx(hctx), ulpCookie(0)
    {
        ActivateActCtx(hctx, &ulpCookie);
    }

    ~CActivateActCtx() {
        DeactivateActCtx(0, ulpCookie);
    }
};

class CActiveOutputLog
{
protected:
    virtual void OutputString(PCWSTR pcwsz, SIZE_T cch) = 0;
    WCHAR wchBuffer[4096];

    CActiveOutputLog(const CActiveOutputLog&);
    void operator=(const CActiveOutputLog&);

    CActiveOutputLog() { }
    
public:
    void Output(PCWSTR pcwszText, ...)
    {
        va_list val;
        va_start(val, pcwszText);
        this->OutputVa(pcwszText, val);
        va_end(val);
        
    }
    void OutputVa(PCWSTR pcwszText, va_list val)
    {
        int iPrinted = _vsnwprintf(wchBuffer, NUMBER_OF(wchBuffer), pcwszText, val);
        wchBuffer[iPrinted] = UNICODE_NULL;
        OutputString(wchBuffer, iPrinted);
    }

    void Error(PCWSTR pcwszText, ...)
    {
        va_list val;
        va_start(val, pcwszText);
        this->ErrorVa(pcwszText, val);
        va_end(val);
        
    }
    void ErrorVa(PCWSTR pcwszText, va_list val)
    {
        int iPrinted = _vsnwprintf(wchBuffer, NUMBER_OF(wchBuffer), pcwszText, val);
        wchBuffer[iPrinted] = UNICODE_NULL;
        OutputString(wchBuffer, iPrinted);
    }

};


class CConsoleOutput : public CActiveOutputLog
{
    CConsoleOutput(const CConsoleOutput&);
    void operator=(const CConsoleOutput&);
protected:

    virtual void OutputString(PCWSTR pcwsz, SIZE_T cch)
    {
        wprintf(L"%.*ls", cch, pcwsz);
    }
    
public:
    CConsoleOutput() { }    
};


BOOL GetAssemblyIdentityFromIndex(
    HANDLE hActCtx,
    ULONG ulRosterIndex,
    CBaseStringBuffer &AssemblyName
    )
{
    SIZE_T cbRequired;
    BYTE wchBuffer[512];
    SIZE_T cbTarget = sizeof(wchBuffer);
    PVOID pvTarget = wchBuffer;
    PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION pInformation;
    BOOL fSuccess = FALSE;

    AssemblyName.Clear();

    fSuccess = QueryActCtxW(
        0, 
        hActCtx, 
        &ulRosterIndex, 
        AssemblyDetailedInformationInActivationContxt, 
        pvTarget,
        cbTarget,
        &cbRequired);

    if (!fSuccess && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {        
        cbTarget = cbRequired;
        pvTarget = HeapAlloc(GetProcessHeap(), 0, cbRequired);

        fSuccess = QueryActCtxW(
            0, 
            hActCtx, 
            &ulRosterIndex, 
            AssemblyDetailedInformationInActivationContext, 
            pvTarget, 
            cbTarget, 
            &cbRequired);
    }

    if (!fSuccess)
    {
        goto Exit;
    }


    //
    // Gather the assembly identity out of the thing we got back
    //
    pInformation = (PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)pvTarget;
    
    if (!AssemblyName.Win32Assign(
        pInformation->lpAssemblyEncodedAssemblyIdentity,
        pInformation->ulEncodedAssemblyIdentityLength)) {
        goto Exit;
    }
    
Exit:
    if (pvTarget && (pvTarget != wchBuffer)) {
        HeapFree(GetProcessHeap(), 0, pvTarget);
        pvTarget = NULL;
    }
    
    return fSuccess;
}

HANDLE
CreateNewActCtx(PCWSTR pcwszManifest)
{
    ACTCTXW MyActCtx = {sizeof(MyActCtx)};
    MyActCtx.lpSource = pcwszManifest;
    return CreateActCtxW(&MyActCtx);
}


BOOL
DisplayComServerRedirect(
    HANDLE hActCtx,
    PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION pKeyedData,
    CActiveOutputLog &OutputLog
    )
{
    return TRUE;
}





BOOL
SimpleQueryGuid(
    HANDLE hActCtx,
    PCWSTR pcwszSectionTitle,
    PCWSTR pcwszGuid,
    CActiveOutputLog &OutputLog
    )
{
    ULONG ulSection = _wtol(pcwszSectionTitle);
    PCWSTR pcwszValue = pcwszGuid;
    GUID GuidValue;
    ACTCTX_SECTION_KEYED_DATA KeyedData = {sizeof(KeyedData)};
    UNICODE_STRING str = { (USHORT)(wcslen(pcwszValue) * sizeof(WCHAR)), 0, const_cast<PWSTR>(pcwszValue) };
    BOOL fSuccess = FALSE;

    CActivateActCtx Activator(hActCtx);

    if (!NT_SUCCESS(RtlGUIDFromString(&str, &GuidValue))) {
        OutputLog.Error(L"Error, '%ls' isn't parseable as a GUID\n", pcwszValue);
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }
        
    
    if (FindActCtxSectionGuid(0, NULL, ulSection, &GuidValue, &KeyedData)) {

        CStringBuffer AssemblyName;
        if (!GetAssemblyIdentityFromIndex(hActCtx, KeyedData.ulAssemblyRosterIndex, AssemblyName)) {
            AssemblyName.Win32Assign(L"<can't get assembly identity>", NUMBER_OF(L"<can't get assembly identity>") - 1);

        }

        OutputLog.Output(L"Success, found guid '%ls' in assembly %ld (%ls), data format version %ld",
            pcwszValue,
            KeyedData.ulAssemblyRosterIndex,
            static_cast<PCWSTR>(AssemblyName),
            KeyedData.ulDataFormatVersion);
        
    }
    else {
        const DWORD dwLastError = ::GetLastError();
        OutputLog.Error(L"Error 0x%08lx searching for guid '%ls' in section %ld", dwLastError, pcwszValue, ulSection);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}




BOOL
SimpleQueryString(
    HANDLE hActCtx,
    PCWSTR pcwszSection,
    PCWSTR pcwszString,
    CActiveOutputLog &OutputLog
    )
{
    ULONG ulSection = _wtol(pcwszSection);
    CActivateActCtx Activator(hActCtx);
    ACTCTX_SECTION_KEYED_DATA KeyedData = {sizeof(KeyedData)};
    BOOL fSuccess = FALSE;

    if (FindActCtxSectionStringW(0, NULL, ulSection, pcwszString, &KeyedData)) {

        CStringBuffer AssemblyName;
        if (!GetAssemblyIdentityFromIndex(hActCtx, KeyedData.ulAssemblyRosterIndex, AssemblyName)) {
            AssemblyName.Win32Assign(L"<can't get assembly identity>", NUMBER_OF(L"<can't get assembly identity>") - 1);

        }
        
        OutputLog.Output(
            L"Success, found string '%ls' in assembly %ld (%ls), data format version %ld",
            pcwszString,
            KeyedData.ulAssemblyRosterIndex,
            static_cast<PCWSTR>(AssemblyName),
            KeyedData.ulDataFormatVersion);

        fSuccess = TRUE;
    }
    else {
        const DWORD dwError = ::GetLastError();
        OutputLog.Error(L"Error 0x%08lx finding string '%ls' in section %ld\n", dwError, pcwszString, ulSection);
    }

    return fSuccess;
}

UNICODE_STRING UnknownAssemblyIdentity = RTL_CONSTANT_STRING(L"<unable to get identity>");




BOOL
LookupClrClass(
    HANDLE hActCtx,
    PCWSTR pcwszClassName,
    CActiveOutputLog &OutputLog
    )
{
    GUID ParsedGuid;
    UNICODE_STRING GuidString;
    BOOL fSuccess = FALSE;
    ACTCTX_SECTION_KEYED_DATA KeyedData;
    PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION pComServer = NULL;
    CActivateActCtx Activator(hActCtx);

    RtlInitUnicodeString(&GuidString, pcwszClassName);

    //
    // If this fails, then we have to look it up in the progid section - it might be
    // a progid that's been remapped
    //
    if (!NT_SUCCESS(RtlGUIDFromString(&GuidString, &ParsedGuid))) {

        PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION pProgId = NULL;
        UNICODE_STRING FoundGuidString;

        RtlZeroMemory(&KeyedData, sizeof(KeyedData));
        KeyedData.cbSize = sizeof(KeyedData);
        
        if (!FindActCtxSectionStringW(0, NULL, ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, pcwszClassName, &KeyedData)) {
            OutputLog.Error(L"Error 0x%08lx looking up '%ls' in the progid redirection section\n",
                ::GetLastError(),
                pcwszClassName);
            goto Exit;
        }

        pProgId = (PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION)KeyedData.lpData;
        ParsedGuid = *(GUID*)(((ULONG_PTR)KeyedData.lpSectionBase) + pProgId->ConfiguredClsidOffset);

        if (NT_SUCCESS(RtlStringFromGUID(ParsedGuid, &FoundGuidString))) {
            OutputLog.Output(L"Converted progid %ls into guid %wZ\n", pcwszClassName, &FoundGuidString);
            RtlFreeUnicodeString(&FoundGuidString);
        }            
    }

    //
    // Now let's go look up the GUID in the COM server redirection table(s)
    //
    RtlZeroMemory(&KeyedData, sizeof(KeyedData));
    KeyedData.cbSize = sizeof(KeyedData);
    if (!FindActCtxSectionGuid(0, NULL, ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION, &ParsedGuid, &KeyedData)) {
        const DWORD dwLastError = ::GetLastError();
        UNICODE_STRING ReconvertedGuidString;

        if (NT_SUCCESS(RtlStringFromGUID(ParsedGuid, &ReconvertedGuidString)))   {
            OutputLog.Error(L"Error 0x%08lx looking up guid %wZ as a COM server\n", dwLastError, &ReconvertedGuidString);
            RtlFreeUnicodeString(&ReconvertedGuidString);
        }
        else {
            OutputLog.Error(L"Error 0x%08lx looking up string %ls as a COM server\n", dwLastError, pcwszClassName);
        }
        
        goto Exit;            
    }

    pComServer = (PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)KeyedData.lpData;
    
    //
    // Say that we found it
    //
    {
        UNICODE_STRING AbsoluteGuid;
        RtlStringFromGUID(pComServer->ReferenceClsid, &AbsoluteGuid);
        CStringBuffer AssemblyName;

        if (!GetAssemblyIdentityFromIndex(hActCtx, KeyedData.ulAssemblyRosterIndex, AssemblyName)) {
            AssemblyName.Win32Assign(&UnknownAssemblyIdentity);
        }
        
        OutputLog.Output(L"Found GUID %wZ in assembly %ld (%ls)\n",
            &AbsoluteGuid,
            KeyedData.ulAssemblyRosterIndex,
            static_cast<PCWSTR>(AssemblyName));
    }

    //
    // See what we can find about this COM class
    //
    if (pComServer->ShimDataOffset != 0)
    {
        UNICODE_STRING usTypeName = {0};
        UNICODE_STRING usShimVersion = {0};
        
        PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM pShimData = NULL;
        pShimData = (PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM)(((ULONG_PTR)KeyedData.lpData) + pComServer->ShimDataOffset);

        if (pShimData->TypeOffset != 0) {
            usTypeName.Length = usTypeName.MaximumLength = (USHORT)pShimData->TypeLength;
            usTypeName.Buffer = (PWSTR)(((ULONG_PTR)pShimData) + pShimData->TypeOffset);
        }

        if (pShimData->ShimVersionOffset != 0) {
            usShimVersion.Length = usShimVersion.MaximumLength = (USHORT)pShimData->ShimVersionLength;
            usShimVersion.Buffer = (PWSTR)(((ULONG_PTR)pShimData) + pShimData->ShimVersionOffset);
        }

        OutputLog.Output(L"- Found CLR shim type %ls: Type {%wZ}, version {%wZ}\n",
            ((pShimData->Type == ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER)
                ? L"other"
                : ((pShimData->Type == ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_CLR_CLASS)
                    ? L"clr"
                    : L"unknown")),
            &usTypeName,
            &usShimVersion);        
    }
    

    fSuccess = TRUE;
Exit:
    return fSuccess;
    
}





BOOL
LookupClrSurrogate(
    HANDLE hActCtx,
    PCWSTR pcwszSurrogateGuid,
    CActiveOutputLog &OutputLog
    )
{
    GUID ParsedGuid;
    UNICODE_STRING GuidString;
    BOOL fSuccess = FALSE;
    ACTCTX_SECTION_KEYED_DATA KeyedData = {sizeof(KeyedData)};
    PACTIVATION_CONTEXT_DATA_CLR_SURROGATE pSurrogate = NULL;
    CStringBuffer AssemblyIdentity;
    UNICODE_STRING usSurrogateName = {0}, usVersionString = {0};
    CActivateActCtx Activator(hActCtx);
    
    RtlInitUnicodeString(&GuidString, pcwszSurrogateGuid);

    // If this wasn't a guid, then it's an invalid parameter.
    if (!NT_SUCCESS(RtlGUIDFromString(&GuidString, &ParsedGuid))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (!FindActCtxSectionGuid(0, NULL, ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES, &ParsedGuid, &KeyedData)) {
        OutputLog.Error(L"Error 0x%08lx looking for clr surrogate '%ls'\n", ::GetLastError(), pcwszSurrogateGuid);
        goto Exit;
    }

    if (!GetAssemblyIdentityFromIndex(hActCtx, KeyedData.ulAssemblyRosterIndex, AssemblyIdentity)) {
        AssemblyIdentity.Win32Assign(&UnknownAssemblyIdentity);
    }

    pSurrogate = (PACTIVATION_CONTEXT_DATA_CLR_SURROGATE)KeyedData.lpData;

    if (pSurrogate->VersionOffset != 0) {
        usVersionString.Length = usVersionString.MaximumLength = (USHORT)pSurrogate->VersionLength;
        usVersionString.Buffer = (PWSTR)(((ULONG_PTR)pSurrogate) + pSurrogate->VersionOffset);
    }

    if (pSurrogate->TypeNameOffset != 0) {
        usSurrogateName.Length = usSurrogateName.MaximumLength = (USHORT)pSurrogate->TypeNameLength;
        usSurrogateName.Buffer = (PWSTR)(((ULONG_PTR)pSurrogate) + pSurrogate->TypeNameOffset);
    }
    
    OutputLog.Output(
        L"Found surrogate {%wZ} (version {%wZ}) from assembly %ld (%ls)",
        &usSurrogateName,
        &usVersionString,
        KeyedData.ulAssemblyRosterIndex,
        static_cast<PCWSTR>(AssemblyIdentity));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}



BOOL
SimpleLookupSurrogate(
    HANDLE hActCtx,
    PCWSTR pcwszGuid,
    CActiveOutputLog &OutputLog
    )
{
    GUID ParsedGuid;
    BOOL fSuccess = FALSE;
    UNICODE_STRING OriginalGuid;
    PFN_SXS_FIND_CLR_SURROGATE_INFO pfnLookup = NULL;
    HMODULE hm = NULL;
    DWORD dwSearchFlags = SXS_FIND_CLR_SURROGATE_USE_ACTCTX | SXS_FIND_CLR_SURROGATE_GET_ALL;
    PVOID pvSearchData = NULL;
    BYTE bStackBuffer[256];
    SIZE_T cbBuffer = sizeof(bStackBuffer);
    PVOID pvBuffer = bStackBuffer;
    SIZE_T cbRequired;
    PCSXS_CLR_SURROGATE_INFORMATION pSurrogateInfo = NULL;

    //
    // This has to be a GUID
    //
    RtlInitUnicodeString(&OriginalGuid, pcwszGuid);
    if (NT_SUCCESS(RtlGUIDFromString(&OriginalGuid, &ParsedGuid))) {
        pvSearchData = (PVOID)&ParsedGuid;
    }
    else {
        OutputLog.Error(L"Error, %ls isn't a GUID\n", pcwszGuid);
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    // Load sxs.dll and the function to call
    //
    if (NULL == (hm = LoadLibraryW(L"sxs.dll")))
        goto Exit;
    
    if (NULL == (pfnLookup = (PFN_SXS_FIND_CLR_SURROGATE_INFO)GetProcAddress(hm, SXS_FIND_CLR_SURROGATE_INFO)))
        goto Exit;

    fSuccess = pfnLookup(dwSearchFlags, &ParsedGuid, hActCtx, pvBuffer, cbBuffer, &cbRequired);
    if (!fSuccess) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            OutputLog.Error(L"Error 0x%08lx looking up %ls\n", GetLastError(), pcwszGuid);
            goto Exit;
        }

        if (NULL == (pvBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired))) {
            OutputLog.Error(L"Failed allocating %ul bytes\n", cbRequired);
            goto Exit;
        }
        cbBuffer = cbRequired;

        if (!pfnLookup(dwSearchFlags, &ParsedGuid, hActCtx, pvBuffer, cbBuffer, &cbRequired)) {
            OutputLog.Error(L"Error 0x%08lx in second lookup.\n", GetLastError());
            goto Exit;
        }
    }

    pSurrogateInfo = (PCSXS_CLR_SURROGATE_INFORMATION)pvBuffer;
    OutputLog.Output(
        L"Found CLR surrogate for %ls:\n\t- Assembly %ls\n\t- Typename %ls\n\t- Runtime %ls\n\t",
        pcwszGuid,
        pSurrogateInfo->pcwszImplementingAssembly,
        pSurrogateInfo->pcwszSurrogateType,
        pSurrogateInfo->pcwszRuntimeVersion);

    fSuccess = TRUE;
Exit:
    if (pvBuffer && (pvBuffer != bStackBuffer)) {
        const DWORD dwLastError = GetLastError();
        HeapFree(GetProcessHeap(), 0, pvBuffer);
        pvBuffer = NULL;
        SetLastError(dwLastError);
    }
    
    return fSuccess;
}




BOOL
SimpleLookupGuid(
    HANDLE hActCtx,
    PCWSTR pcwszGuid,
    CActiveOutputLog &OutputLog
    )
{
    GUID ParsedGuid;
    BOOL fSuccess = FALSE;
    UNICODE_STRING OriginalGuid;
    PFN_SXS_LOOKUP_CLR_GUID pfnLookup = NULL;
    HMODULE hm = NULL;
    DWORD dwSearchFlags = SXS_LOOKUP_CLR_GUID_FIND_ANY | SXS_LOOKUP_CLR_GUID_USE_ACTCTX;
    PVOID pvSearchData = NULL;
    BYTE bStackBuffer[256];
    SIZE_T cbBuffer = sizeof(bStackBuffer);
    PVOID pvBuffer = bStackBuffer;
    SIZE_T cbRequired;
    PCSXS_GUID_INFORMATION_CLR pGuidInfo = NULL;

    //
    // This has to be a GUID
    //
    RtlInitUnicodeString(&OriginalGuid, pcwszGuid);
    if (NT_SUCCESS(RtlGUIDFromString(&OriginalGuid, &ParsedGuid))) {
        pvSearchData = (PVOID)&ParsedGuid;
    }
    else {
        OutputLog.Error(L"Error, %ls isn't a GUID\n", pcwszGuid);
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    // Load sxs.dll and the function to call
    //
    if (NULL == (hm = LoadLibraryW(L"sxs.dll")))
        goto Exit;
    
    if (NULL == (pfnLookup = (PFN_SXS_LOOKUP_CLR_GUID)GetProcAddress(hm, SXS_LOOKUP_CLR_GUID)))
        goto Exit;

    fSuccess = pfnLookup(dwSearchFlags, &ParsedGuid, hActCtx, pvBuffer, cbBuffer, &cbRequired);
    if (!fSuccess) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            OutputLog.Error(L"Error 0x%08lx looking up %ls\n", GetLastError(), pcwszGuid);
            goto Exit;
        }

        if (NULL == (pvBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired))) {
            OutputLog.Error(L"Failed allocating %ul bytes\n", cbRequired);
            goto Exit;
        }
        cbBuffer = cbRequired;

        if (!pfnLookup(dwSearchFlags, &ParsedGuid, hActCtx, pvBuffer, cbBuffer, &cbRequired)) {
            OutputLog.Error(L"Error 0x%08lx in second lookup.\n", GetLastError());
            goto Exit;
        }
    }

    pGuidInfo = (PCSXS_GUID_INFORMATION_CLR)pvBuffer;
    OutputLog.Output(
        L"Found CLR entry for %ls:\n\t- Thing is a %ls\n\t- Assembly %ls\n\t- Typename %ls\n\t- Runtime %ls\n\t",
        pcwszGuid,
        ((pGuidInfo->dwFlags & SXS_GUID_INFORMATION_CLR_FLAG_IS_SURROGATE) 
            ? L"surrogate" 
            : ((pGuidInfo->dwFlags & SXS_GUID_INFORMATION_CLR_FLAG_IS_CLASS) 
                ? L"class"
                : L"unknown thing?")),
        pGuidInfo->pcwszAssemblyIdentity,
        pGuidInfo->pcwszTypeName,
        pGuidInfo->pcwszRuntimeVersion);

    fSuccess = TRUE;
Exit:
    if (pvBuffer && (pvBuffer != bStackBuffer)) {
        const DWORD dwLastError = GetLastError();
        HeapFree(GetProcessHeap(), 0, pvBuffer);
        pvBuffer = NULL;
        SetLastError(dwLastError);
    }
    
    return fSuccess;
}




BOOL
SimpleLookupClass(
    HANDLE hActCtx,
    PCWSTR pcwszGuid,
    CActiveOutputLog &OutputLog
    )
{
    GUID ParsedGuid;
    BOOL fSuccess = FALSE;
    UNICODE_STRING OriginalGuid;
    PFN_SXS_FIND_CLR_CLASS_INFO pfnLookup = NULL;
    HMODULE hm = NULL;
    DWORD dwSearchFlags = SXS_FIND_CLR_CLASS_ACTIVATE_ACTCTX | SXS_FIND_CLR_CLASS_GET_ALL;
    PVOID pvSearchData = NULL;
    BYTE bStackBuffer[256];
    SIZE_T cbBuffer = sizeof(bStackBuffer);
    PVOID pvBuffer = bStackBuffer;
    SIZE_T cbRequired;
    PCSXS_CLR_CLASS_INFORMATION pClassInfo = NULL;

    //
    // Determine whether or not we're searching for a GUID or a progid
    //
    RtlInitUnicodeString(&OriginalGuid, pcwszGuid);
    if (NT_SUCCESS(RtlGUIDFromString(&OriginalGuid, &ParsedGuid))) {
        dwSearchFlags |= SXS_FIND_CLR_CLASS_SEARCH_GUID;
        pvSearchData = (PVOID)&ParsedGuid;
    }
    else {
        dwSearchFlags |= SXS_FIND_CLR_CLASS_SEARCH_PROGID;
        pvSearchData = (PVOID)pcwszGuid;
    }

    //
    // Load sxs.dll and the function to call
    //
    if (NULL == (hm = LoadLibraryW(L"sxs.dll")))
        goto Exit;
    
    if (NULL == (pfnLookup = (PFN_SXS_FIND_CLR_CLASS_INFO)GetProcAddress(hm, SXS_FIND_CLR_CLASS_INFO)))
        goto Exit;

    fSuccess = pfnLookup(dwSearchFlags, pvSearchData, hActCtx, pvBuffer, cbBuffer, &cbRequired);
    if (!fSuccess) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            OutputLog.Error(L"Error 0x%08lx looking up %ls\n", GetLastError(), pcwszGuid);
            goto Exit;
        }

        if (NULL == (pvBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired))) {
            OutputLog.Error(L"Failed allocating %ul bytes\n", cbRequired);
            goto Exit;
        }
        cbBuffer = cbRequired;

        if (!pfnLookup(dwSearchFlags, pvSearchData, hActCtx, pvBuffer, cbBuffer, &cbRequired)) {
            OutputLog.Error(L"Error 0x%08lx in second lookup.\n", GetLastError());
            goto Exit;
        }
    }

    pClassInfo = (PCSXS_CLR_CLASS_INFORMATION)pvBuffer;
    OutputLog.Output(
        L"Found CLR class for %ls:\n\t- Assembly %ls\n\t- Typename %ls\n\t- Progid %ls\n\t- Runtime %ls\n\t",
        pcwszGuid,
        pClassInfo->pcwszImplementingAssembly,
        pClassInfo->pcwszTypeName,
        pClassInfo->pcwszProgId,
        pClassInfo->pcwszRuntimeVersion);

    fSuccess = TRUE;
Exit:
    if (pvBuffer && (pvBuffer != bStackBuffer)) {
        const DWORD dwLastError = GetLastError();
        HeapFree(GetProcessHeap(), 0, pvBuffer);
        pvBuffer = NULL;
        SetLastError(dwLastError);
    }
    
    return fSuccess;
}
    



int __cdecl wmain(INT argc, WCHAR** argv)
{
    HANDLE hActCtx = INVALID_HANDLE_VALUE;
    GUID uid = GUID_NULL;
    INT i = 0;
    CStringBuffer ManifestFileName;
    CConsoleOutput ConsoleOutput;
    CActiveOutputLog &OutputLog = ConsoleOutput;
    bool fVerboseDumping = false;

    for (i = 1; i < argc; i++)
    {
        if (lstrcmpiW(argv[i], L"-manifest") == 0) {

            OutputLog.Output(L"Loading manifest %ls\n", argv[i+1]);
            
            if (hActCtx != INVALID_HANDLE_VALUE) {
                ReleaseActCtx(hActCtx);
                hActCtx = INVALID_HANDLE_VALUE;
            }

            hActCtx = CreateNewActCtx(argv[++i]);
        }
        else if (lstrcmpiW(argv[i], L"-verbose") == 0) {
            fVerboseDumping = true;
        }
        //
        // Just look for a guid
        //
        else if (lstrcmpiW(argv[i], L"-querystring") == 0) {
            if (!SimpleQueryString(hActCtx, argv[i+1], argv[i+2], OutputLog))
                return GetLastError();
            i += 2;
        }
        //
        // Let's look just for a guid in a section
        //
        else if (lstrcmpiW(argv[i], L"-queryguid") == 0) {
            if (!SimpleQueryGuid(hActCtx, argv[i+1], argv[i+2], OutputLog))
                return GetLastError();
        }
        //
        // Specifically find out about a CLR class
        //
        else if (lstrcmpiW(argv[i], L"-clrclass") == 0) {
            if (!LookupClrClass(hActCtx, argv[i+1], OutputLog))
                return GetLastError();
            i++;
        }
        //
        // Look for a surrogate, print some reasonable information about it
        //
        else if (lstrcmpiW(argv[i], L"-clrsurrogate") == 0) {
            if (!LookupClrSurrogate(hActCtx, argv[i+1], OutputLog))
                return GetLastError();
            i++;
        }
        //
        // Use the simple query for a clr class
        //
        else if (lstrcmpiW(argv[i], L"-simpleclass") == 0) {
            if (!SimpleLookupClass(hActCtx, argv[i+1], OutputLog))
                return GetLastError();
            i++;
        }
        //
        // Simple query for a clr surrogate
        //
        else if (lstrcmpiW(argv[i], L"-simplesurrogate") == 0) {
            if (!SimpleLookupSurrogate(hActCtx, argv[i+1], OutputLog))
                return GetLastError();
            i++;
        }
        //
        // Simple query for a clr guid of either type
        //
        else if (lstrcmpiW(argv[i], L"-simpleguid") == 0) {
            if (!SimpleLookupGuid(hActCtx, argv[i+1], OutputLog))
                return GetLastError();
            i++;
        }
        
    }

    if (hActCtx != INVALID_HANDLE_VALUE)
    {
        ReleaseActCtx(hActCtx);
        hActCtx = INVALID_HANDLE_VALUE;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\jonwis\fastsha1\harness.cpp ===
#define FUSION_PROFILING 1
#define DBG 1

#include "windows.h"
#include "wincrypt.h"
#include "stdlib.h"
#include "stdio.h"
#include "fastsha1.h"
#include "fusionbuffer.h"
#include "perfclocking.h"

FASTSHA1_STATE ShaState;
#define ASM_CPUID { __asm cpuid }
#define ASM_RDTSC { __asm rdtsc }
#define NUMBER_OF( n ) ( sizeof(n) / sizeof(*n) )
#define INPUT_BLOCK_SIZE ( 4096*4 )

inline VOID GetCpuIdLag( LARGE_INTEGER *ref )
{
LARGE_INTEGER temp, temp2;
#if !defined(_WIN64)
_asm
{
cpuid
cpuid
cpuid
cpuid
cpuid
rdtsc
mov temp.LowPart, eax
mov temp.HighPart, edx
cpuid
rdtsc
mov temp2.LowPart, eax
mov temp2.HighPart, edx
}

ref->QuadPart = temp2.QuadPart - temp.QuadPart;
#else
ref->QuadPart = 0;
#endif
}

LARGE_INTEGER CpuIdLag;

BYTE TestCase1[] = { 0x61, 0x62, 0x63 };
BYTE TestCase2[] = {
	0x61, 0x62, 0x63, 0x64,
	0x62, 0x63, 0x64, 0x65,
	0x63, 0x64, 0x65, 0x66,
	0x64, 0x65, 0x66, 0x67,
	0x65, 0x66, 0x67, 0x68,
	0x66, 0x67, 0x68, 0x69,
	0x67, 0x68, 0x69, 0x6A,
	0x68, 0x69, 0x6A, 0x6B,
	0x69, 0x6A, 0x6B, 0x6C,
	0x6A, 0x6B, 0x6C, 0x6D,
	0x6B, 0x6C, 0x6D, 0x6E,
	0x6C, 0x6D, 0x6E, 0x6F,
	0x6D, 0x6E, 0x6F, 0x70,
	0x6E, 0x6F, 0x70, 0x71
};

HCRYPTPROV hProvider;
#define CHECKFAIL( f ) do { if ( !(f) ) return FALSE; } while ( 0 )

BOOL ObtainFastSHA1OfFile( PBYTE pvBase, SIZE_T cbSize, BYTE bShaHashData[20], PSIZE_T pcbSize )
{
	FUSION_PERF_INFO InfoSlots[4];
	FASTSHA1_STATE State;
	
	State.cbStruct = sizeof( State );
	
	PERFINFOTIME( &InfoSlots[0], CHECKFAIL( InitializeFastSHA1State( 0, &State ) ) );
	while ( cbSize )
	{
		DWORD dwThisSize = ( cbSize > INPUT_BLOCK_SIZE ) ? INPUT_BLOCK_SIZE : cbSize;

		PERFINFOTIME( &InfoSlots[1], CHECKFAIL( HashMoreFastSHA1Data( 
			&State, 
			pvBase, 
			dwThisSize
		) ) );
		pvBase += dwThisSize;
		cbSize -= dwThisSize;
	}
	PERFINFOTIME( &InfoSlots[2], CHECKFAIL( FinalizeFastSHA1State( 0, &State ) ) );
	PERFINFOTIME( &InfoSlots[3], CHECKFAIL( GetFastSHA1Result( &State, bShaHashData, pcbSize ) ) );
	FusionpReportPerfInfo( 
		FUSIONPERF_DUMP_TO_STDOUT |
		FUSIONPERF_DUMP_ALL_STATISTICS |
		FUSIONPERF_DUMP_ALL_SOURCEINFO,
		InfoSlots,
		NUMBER_OF( InfoSlots )
	);
	printf("\n\n");
	return TRUE;
}

BOOL ObtainReferenceSHA1Hash( PBYTE pvBase, SIZE_T cbSize, BYTE bShaHashData[20], PDWORD pdwData )
{
	FUSION_PERF_INFO InfoSlots[4];
	FASTSHA1_STATE State;
	DWORD dwDump;
	HCRYPTHASH hHash;

	PERFINFOTIME( &InfoSlots[0], CHECKFAIL( CryptCreateHash( hProvider, CALG_SHA1, NULL, 0, &hHash ) ) );
	while ( cbSize )
	{
		DWORD dwThisSize = ( cbSize > INPUT_BLOCK_SIZE ) ? INPUT_BLOCK_SIZE : cbSize;
		PERFINFOTIME( &InfoSlots[1], CHECKFAIL( CryptHashData( hHash, pvBase, dwThisSize, 0 ) ) );
		cbSize -= dwThisSize;
		pvBase += dwThisSize;
	}
	PERFINFOTIME( &InfoSlots[2], CHECKFAIL( CryptGetHashParam( 
		hHash,
		HP_HASHVAL,
		bShaHashData,
		pdwData,
		0
	) ) );
	PERFINFOTIME( &InfoSlots[3], CHECKFAIL( CryptDestroyHash( hHash ) ) );

	FusionpReportPerfInfo( 
		FUSIONPERF_DUMP_TO_STDOUT |
		FUSIONPERF_DUMP_ALL_STATISTICS |
		FUSIONPERF_DUMP_ALL_SOURCEINFO,
		InfoSlots,
		NUMBER_OF( InfoSlots )
	);

	printf("\n\n");
	return TRUE;
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
	BYTE bDestination[20];
	SIZE_T cbDestination;
	int i = 0;

ShaState.cbStruct = sizeof( ShaState );
InitializeFastSHA1State( 0, &ShaState );
HashMoreFastSHA1Data( &ShaState, TestCase1, sizeof( TestCase1 ) );
FinalizeFastSHA1State( 0, &ShaState );



	GetCpuIdLag( &CpuIdLag );
	CryptAcquireContextW( &hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_SILENT | CRYPT_VERIFYCONTEXT );

	BYTE bReferenceHash[20], bFastHash[20];
	SIZE_T cbReferenceHash, cbFastHash;
	HANDLE hFile, hFileMapping;
	PBYTE pbFileContents;
	DWORD dwFileContents;

	if ( GetFileAttributesW( argv[1] ) & FILE_ATTRIBUTE_DIRECTORY )
	{
		printf( "dir  : %ls\n", argv[1] );
		return 0;
	}

	hFile = CreateFile( argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( hFile == INVALID_HANDLE_VALUE ) goto ErrorPath;
	
	hFileMapping = CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, 0, NULL );
	if ( ( hFileMapping == NULL ) || ( hFileMapping == INVALID_HANDLE_VALUE ) ) goto ErrorPath;

	pbFileContents = (PBYTE)MapViewOfFile( hFileMapping, FILE_MAP_READ, 0, 0, 0 );
	if ( pbFileContents == NULL ) goto ErrorPath;

	dwFileContents = GetFileSize( hFile, NULL );

	if ( !ObtainReferenceSHA1Hash( 
		pbFileContents, 
		dwFileContents, 
		bReferenceHash, 
		&(cbReferenceHash = sizeof(bReferenceHash))
	) )
	{
		printf("(Reference failed) ");
		goto ErrorPath;
	}

	if ( !ObtainFastSHA1OfFile( 
		pbFileContents, 
		dwFileContents, 
		bFastHash, 
		&(cbFastHash = sizeof(bFastHash))
	) )
	{
		printf( "(fastsha1 failed) " );
		goto ErrorPath;
	}

	if ( memcmp( bFastHash, bReferenceHash, 20 ) == 0 )
	{
		printf( "match: %ls\n", argv[1] );
	}
	else
	{
		printf( "fails: %ls\n", argv[1] );
	}
	
	CryptReleaseContext( hProvider, 0 );
return 0;   

ErrorPath:
	printf( "Failure: 0x%08x on file %ls\n", GetLastError(), argv[1] );
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\lib\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\testdata\buildmultifileassembly\empty.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\peb.h ===
PEB_MEMBER(InheritedAddressSpace)
PEB_MEMBER(ReadImageFileExecOptions)
PEB_MEMBER(BeingDebugged)
PEB_MEMBER(SpareBool)
PEB_MEMBER(Mutant)
PEB_MEMBER(ImageBaseAddress)
PEB_MEMBER(Ldr)
PEB_MEMBER(ProcessParameters)
PEB_MEMBER(SubSystemData)
PEB_MEMBER(ProcessHeap)
PEB_MEMBER(FastPebLock)
PEB_MEMBER(FastPebLockRoutine)
PEB_MEMBER(FastPebUnlockRoutine)
PEB_MEMBER(EnvironmentUpdateCount)
PEB_MEMBER(KernelCallbackTable)
PEB_MEMBER(SystemReserved)
PEB_MEMBER(FreeList)
PEB_MEMBER(TlsExpansionCounter)
PEB_MEMBER(TlsBitmap)
PEB_MEMBER(TlsBitmapBits)
PEB_MEMBER(ReadOnlySharedMemoryBase)
PEB_MEMBER(ReadOnlySharedMemoryHeap)
PEB_MEMBER(ReadOnlyStaticServerData)
PEB_MEMBER(AnsiCodePageData)
PEB_MEMBER(OemCodePageData)
PEB_MEMBER(UnicodeCaseTableData)
PEB_MEMBER(NumberOfProcessors)
PEB_MEMBER(NtGlobalFlag)
PEB_MEMBER(CriticalSectionTimeout)
PEB_MEMBER(HeapSegmentReserve)
PEB_MEMBER(HeapSegmentCommit)
PEB_MEMBER(HeapDeCommitTotalFreeThreshold)
PEB_MEMBER(HeapDeCommitFreeBlockThreshold)
PEB_MEMBER(NumberOfHeaps)
PEB_MEMBER(MaximumNumberOfHeaps)
PEB_MEMBER(ProcessHeaps)
PEB_MEMBER(GdiSharedHandleTable)
PEB_MEMBER(ProcessStarterHelper)
PEB_MEMBER(GdiDCAttributeList)
PEB_MEMBER(LoaderLock)
PEB_MEMBER(OSMajorVersion)
PEB_MEMBER(OSMinorVersion)
PEB_MEMBER(OSBuildNumber)
PEB_MEMBER(OSCSDVersion)
PEB_MEMBER(OSPlatformId)
PEB_MEMBER(ImageSubsystem)
PEB_MEMBER(ImageSubsystemMajorVersion)
PEB_MEMBER(ImageSubsystemMinorVersion)
PEB_MEMBER(ImageProcessAffinityMask)
PEB_MEMBER(GdiHandleBuffer)
PEB_MEMBER(PostProcessInitRoutine)
PEB_MEMBER(TlsExpansionBitmap)
PEB_MEMBER(TlsExpansionBitmapBits)
PEB_MEMBER(SessionId)
PEB_MEMBER(AppCompatFlags)
PEB_MEMBER(pShimData)
PEB_MEMBER(AppCompatInfo)
PEB_MEMBER(CSDVersion)
PEB_MEMBER(ActivationContextData)
PEB_MEMBER(ProcessAssemblyStorageMap)
PEB_MEMBER(SystemDefaultActivationContextData)
PEB_MEMBER(SystemAssemblyStorageMap)
#if defined(SD_BRANCH_LAB01_FUSION) || defined(PEB)
PEB_MEMBER(MinimumStackCommit)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\makefile.inc ===
# We don't want all that SXS_MANIFEST_IN_RESOURCES implies.
# This doesn't work completely, we still get extra rc_temp files, but their contents
# are ok.
!if "$(NUMBER_OF_MANIFESTS)" != "0" && "$(NUMBER_OF_MANIFESTS)" != "1"
!undef RC_FORCE_INCLUDE_STRING
!undef RC_FORCE_INCLUDE_FILES
RC_FORCE_INCLUDE_FILES_CMD=echo.
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\whistler\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\teb.h ===
TEB_MEMBER(NtTib)
TEB_MEMBER(EnvironmentPointer)
TEB_MEMBER(ClientId)
TEB_MEMBER(ActiveRpcHandle)
TEB_MEMBER(ThreadLocalStoragePointer)
TEB_MEMBER(ProcessEnvironmentBlock)
TEB_MEMBER(LastErrorValue)
TEB_MEMBER(CountOfOwnedCriticalSections)
TEB_MEMBER(CsrClientThread)
TEB_MEMBER(Win32ThreadInfo)
#if defined(TEB64) && defined(SD_BRANCH_LAB01_N)
TEB_MEMBER(User64Reserved)
#else
TEB_MEMBER(User32Reserved)
#endif
TEB_MEMBER(UserReserved)
#if defined(TEB64) && defined(SD_BRANCH_LAB01_N)
TEB_MEMBER(WOW64Reserved)
#else
TEB_MEMBER(WOW32Reserved)
#endif
TEB_MEMBER(CurrentLocale)
TEB_MEMBER(FpSoftwareStatusRegister)
TEB_MEMBER(SystemReserved1)
TEB_MEMBER(ExceptionCode)
TEB_MEMBER(ActivationContextStack)
TEB_MEMBER(SpareBytes1)
TEB_MEMBER(GdiTebBatch)
TEB_MEMBER(RealClientId)
TEB_MEMBER(GdiCachedProcessHandle)
TEB_MEMBER(GdiClientPID)
TEB_MEMBER(GdiClientTID)
TEB_MEMBER(GdiThreadLocalInfo)
TEB_MEMBER(Win32ClientInfo)
TEB_MEMBER(glDispatchTable)
TEB_MEMBER(glReserved1)
TEB_MEMBER(glReserved2)
TEB_MEMBER(glSectionInfo)
TEB_MEMBER(glSection)
TEB_MEMBER(glTable)
TEB_MEMBER(glCurrentRC)
TEB_MEMBER(glContext)
TEB_MEMBER(LastStatusValue)
TEB_MEMBER(StaticUnicodeString)
TEB_MEMBER(StaticUnicodeBuffer)
TEB_MEMBER(DeallocationStack)
TEB_MEMBER(TlsSlots)
TEB_MEMBER(TlsLinks)
TEB_MEMBER(Vdm)
TEB_MEMBER(ReservedForNtRpc)
TEB_MEMBER(DbgSsReserved)
TEB_MEMBER(HardErrorsAreDisabled)
TEB_MEMBER(Instrumentation)
TEB_MEMBER(WinSockData)
TEB_MEMBER(GdiBatchCount)
TEB_MEMBER(InDbgPrint)
TEB_MEMBER(FreeStackOnTermination)
TEB_MEMBER(HasFiberData)
TEB_MEMBER(IdealProcessor)
TEB_MEMBER(Spare3)
TEB_MEMBER(ReservedForPerf)
TEB_MEMBER(ReservedForOle)
TEB_MEMBER(WaitingOnLoaderLock)
TEB_MEMBER(Wx86Thread)
TEB_MEMBER(TlsExpansionSlots)
TEB_MEMBER_IA64(DeallocationBStore)
TEB_MEMBER_IA64(BStoreLimit)
TEB_MEMBER(ImpersonationLocale)
TEB_MEMBER(IsImpersonating)
TEB_MEMBER(NlsCache)
TEB_MEMBER(pShimData)
#if defined(SD_BRANCH_LAB01_FUSION) || defined(TEB)
TEB_MEMBER(HeapVirtualAffinity)
#endif
#if defined(SD_BRANCH_LAB01_FUSION)
TEB_MEMBER(ActiveFrame)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\sxstest.cpp ===
#include "stdinc.h" // actually from dll\whistler directory
/*-----------------------------------------------------------------------------
Side X ("by") Side Test
-----------------------------------------------------------------------------*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#pragma warning(disable: 4663)
#include <yvals.h>
#pragma warning(disable: 4663)
#include <string>
#include <deque>
#include <vector>
#pragma warning(pop)
#include "FusionBuffer.h"
#include "fusion.h"
#include "sxsasmname.h"
#include "util.h"
#include "filestream.cpp"
#include "sxsapi.h"
#include "fusiontrace.h"
#include "cresourcestream.cpp"
#include "cmemorystream.cpp"
#include "wintrust.h"
#include "softpub.h"
#include "perfclocking.h"
#include "strongname.h"
#include "fusionversion.h"
#include <setupapi.h>
#include <string>
#include "commctrl.h"
#include <algorithm>
#include "fusionsha1.h"
#include "cguid.h"
#include "winbasep.h"
#undef LoadLibraryA
#undef LoadLibraryW
#undef LoadLibraryExA
#undef LoadLibraryExW
#undef InitCommonControls

BOOL IamExe;
BOOL IamDll;
extern "C" { void (__cdecl * _aexit_rtn)(int); }

void __cdecl Trace(const char* FormatString, ...)
{
    char buffer[2000];
    va_list args;

    va_start(args, FormatString);
    _vsnprintf(buffer, RTL_NUMBER_OF(buffer), FormatString, args);
    buffer[RTL_NUMBER_OF(buffer) - 1] = 0;
    for (PSTR s = buffer ; *s != 0 ; )
    {
        PSTR t = strchr(s, '\n');

        if (t != NULL)
            *t = 0;

                    printf("stdout  : %s\n", s);
        OutputDebugStringA("debugger: ");
        OutputDebugStringA(s);
        OutputDebugStringA("\n");

        if (t != NULL)
            s = t + 1;
    }
    va_end(args);
}

typedef BOOL (WINAPI * PSXSPGENERATEMANIFESTPATHONASSEMBLYIDENTITY)(
    PWSTR str,         // input string, must have name, version, langid and processorarchitecture
    PWSTR psz,         // output string, like x86_cards_strongname,.......
    SIZE_T * pCch,     // IN : length of psz, OUT : used
    PASSEMBLY_IDENTITY *ppAssemblyIdentity  // could be NULL
   );

/*-----------------------------------------------------------------------------
work around the fact that SxsHeap doesn't let us use a non debug operator new
-----------------------------------------------------------------------------*/
template <typename T>
class Allocator : public std::allocator<T>
{
public:
    pointer allocate(size_type n, const void*)
    {
        return reinterpret_cast<pointer>(malloc(n * sizeof(T)));
    }

    char* _Charalloc(size_type n)
    {
        return reinterpret_cast<char*>(malloc(n));
    }

    void deallocate(void* p, size_type)
    {
        free(p);
    }
};

#define SXSTEST_BEGIN_INSTALL          (0x4000000000000000i64)
#define SXSTEST_INSTALL                (0x2000000000000000i64)
#define SXSTEST_END_INSTALL            (0x1000000000000000i64)
#define SXSTEST_INSTALL_MY_QUEUE       (0x0800000000000000i64)
#define SXSTEST_INSTALL_SETUPAPI_QUEUE (0x0400000000000000i64)
#define SXSTEST_END_OF_FLAGS           (0x0200000000000000i64)
#define SXSTEST_THREADS                (0x0100000000000000i64)
#define SXSTEST_CREATEPROCESS          (0x0080000000000000i64)

inline int PRINTABLE(int ch) { return isprint(ch) ? ch : '.'; }

void PrintIfAnyCriticalSectionsHeld(const char* file, int line, const char* function)
#define PrintIfAnyCriticalSectionsHeld() PrintIfAnyCriticalSectionsHeld(__FILE__, __LINE__, __FUNCTION__)
{
    const DWORD dwLastError = ::GetLastError();
    PTEB teb;
    teb = NtCurrentTeb();
    if (teb->CountOfOwnedCriticalSections != 0)
    {
        DbgPrint("%s(%d):%s teb->CountOfOwnedCriticalSections %d\n", file, line, function, teb->CountOfOwnedCriticalSections);
    }
    SetLastError(dwLastError);
}

static
VOID
PrintBlob(
    FILE *pf,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
   );

BOOL TestLeakMemory(DWORD Amount);
BOOL TestAssemblyProbing(int argc, wchar_t **argv, int *piNext);
BOOL TestDirectoryChangeWatcher(int argc, wchar_t **argv, int *piNext);
BOOL TestXMLParsing(int argc, wchar_t **argv, int *piNext);
BOOL TestMultiAct(int argc, wchar_t **argv);
BOOL TestManifestSchema(int argc, wchar_t **argv, int *piNext);
BOOL TestDirect(int argc, wchar_t **argv, int *piNext);
void TestWin32(wchar_t** argv);
BOOL TestAct(int argc, wchar_t **argv, int *piNext);
BOOL TestInstall(PCWSTR manifest, __int64 flags, DWORD beginInstallFlags, DWORD installFlags, DWORD endInstallFlags);
int  TestDiffDir(PCWSTR dir1, PCWSTR dir2);
BOOL TestSearchPath(int argc, wchar_t** argv, int* piNext);
BOOL TestMSIInstall(int argc, wchar_t** argv, int* piNext);
int  TestDirWalk(PCWSTR root, PWSTR filter);
BOOL TestLoadLibrary(int argc, wchar_t** argv, int* piNext);
int  TestAssemblyName(VOID);
int  TestPrecomiledManifest(PCWSTR szFileName);
int  TestPCMTime(PCWSTR manifestFilename);
int  TestCreateProcess(wchar_t** argv);
int  TestCreateProcess2(wchar_t** argv);
BOOL TestInstallPrivateAssembly(int argc, wchar_t** argv, int* piNext);
BOOL TestManifestProbing(int argc, wchar_t** argv, int* piNext);
int  TestCreateMultiLevelDirectory(PCWSTR dirs);
BOOL TestXMLDOM(PCWSTR xmlfilename);
BOOL TestFusionArray(PCWSTR, PCWSTR);
BOOL TestGeneratePathFromIdentityAttributeString(PCWSTR str);
BOOL TestRefreshAssembly(PCWSTR wsAssembly);
BOOL TestInstallWithInstallInfo(PCWSTR wsAssemblyManifest, PCWSTR wsReference);
BOOL TestOpeningStuff(PCWSTR wsSourceName, PCWSTR wsType, PCWSTR wsCount);
BOOL TestVerifyFileSignature(PCWSTR wsFilename);
BOOL TestInstallLikeWindowsSetup(PCWSTR szDirectory, PCWSTR szCodebase);
BOOL TestDumpContainedManifests(PCWSTR wsFilename);
BOOL TestGenerateStringWithIdenticalHash(WCHAR iString[33]);
BOOL TestAssemblyIdentityHash();
void TestInherit();
void TestNoInherit();
void TestEmpty();
BOOL TestMessagePerf(int argc, wchar_t **arg, int *piNext);
LRESULT CALLBACK TestMessagePerfWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void TestTrickyMultipleAssemblyCacheItems(PCWSTR);
void TestSfcScanKickoff();
void GenerateStrongNameAndPublicKey(PCWSTR wsCertificate);
VOID TestCreateActctxLeakHandles(DWORD num);
BOOL TestSystemDefaultActivationContextGeneration();
BOOL TestAsyncIO(int argc, wchar_t **argv, int *piNext);
void TestRefCount();
void TestGuidSort();
void TestStringSort();
BOOL TestNewCatalogSignerThingy(PCWSTR pcwszCatalog);
void TestExeDll();
int TestThreadInheritLeak();
BOOL TestSxsSfcUI();
void TestGetModuleHandleEx();
void TestGetFullPathName(PCWSTR);
void TestCreateFile(PCWSTR);
void TestGetPathBaseName(LPCWSTR Path);
PCSTR PrintPathToString(RTL_PATH_TYPE);
void TestPathType(PCWSTR*);
void TestVersion();
void TestGetProcessImageFileName();
void TestErrorInfra();
void TestQueryActCtx();
void TestQueryActCtx2();
void Test64k();
void TestDotLocalSingleInstancing();
void TestCreateActCtx(int nCreations, wchar_t **rgCreations);
void TestCreateActctxLikeCreateProcess();
void TestCreateActctxAdminOverride();
void TestQueryManifestInformationBasic(PCWSTR pszManifest);
void TestCreateActctxWindowsShellManifest();
void TestCreateGlobalEvent();
void TestHandleLeaks(void);
void TestCRuntimeAsms(void);
BOOL TestMfcCreateAndMarshal(void);
void TestAtlCreate(void);
void TestAlignment(void);
BOOL TestPrivateSha1Impl(PCWSTR pcwszDirName);
BOOL TestNewSxsInstallAPI(PCWSTR pcwszManifest);
void TestImage(void);
void TestInterlockedAlignment(void);
void TestCreateActCtx_PE_flags0(void);
void TestUninstall(PCWSTR ManifestPath, PCWSTR ReferenceString);
PCWSTR GetLastErrorMessage();
BOOL SimpleTestFindAndUseSurrogateInformation(PCWSTR filename, PCWSTR GuidToDisplay);
BOOL TestSxsExportedSurrogateStuff(PCWSTR pcwszManifest, PCWSTR pcwszWhat, PCWSTR pcwszData);


DWORD LastError;

static void LoadSxs();
static int Main(int argc, wchar_t** argv);
static void SetLastOperation(const wchar_t* format, ...);
static const wchar_t* GetLastOperation(const wchar_t* format, ...);
static int Usage(const char* argv0);
template <typename PFN> void GetSxsProc(PCSTR name, PFN* ppfn);
template <typename PFN> void GetSxsProc(int name, PFN* ppfn);

SXSP_DEBUG_FUNCTION pfnSxspDebug = NULL;

BOOL ParseProcessorArchitecture(int argc, wchar_t** argv, int* piCurrent);
BOOL ParseLangId(int argc, wchar_t** argv, int* piCurrent);

PCWSTR FusionpThreadUnsafeGetLastWin32ErrorMessageW()
{
    CSxsPreserveLastError ple;
    static WCHAR LastErrorMessage[4096];

    LastErrorMessage[0] = 0;

    ::FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        ::FusionpGetLastWin32Error(),
        0,
        LastErrorMessage,
        RTL_NUMBER_OF(LastErrorMessage),
        NULL);
    if (LastErrorMessage[0] != 0)
    {
        PWSTR p = LastErrorMessage + ::StringLength(LastErrorMessage) - 1;
        while (p != LastErrorMessage && (*p == '\n' || *p == '\r' || *p == ' ' || *p == '\t'))
        {
            *p-- = 0;
        }
    }
    ple.Restore();
    return LastErrorMessage;
}


void __stdcall ThrowLastError(DWORD error = ::GetLastError())
{
    RaiseException(error, 0, 0, NULL);
    //throw HRESULT_FROM_WIN32(error);
}

void __stdcall ThrowWin32(ULONG_PTR error = ::GetLastError())
{
    ThrowLastError(static_cast<DWORD>(error));
}

void __stdcall CheckHresult(HRESULT hr)
{
    if (FAILED(hr))
        throw hr;
}

void SetDllBitInPeImage(PCWSTR Path)
/*++
.exes and .dlls are the same format except one bit in the headers distinguishes them.
--*/
{
    CFusionFile File;
    CFileMapping FileMapping;
    CMappedViewOfFile MappedViewOfFile;

    if (!File.Win32CreateFile(Path, GENERIC_READ | GENERIC_WRITE, 0, OPEN_EXISTING))
        ThrowLastError();
    if (!FileMapping.Win32CreateFileMapping(File, PAGE_READWRITE))
        ThrowLastError();
    if (!MappedViewOfFile.Win32MapViewOfFile(FileMapping, FILE_MAP_WRITE))
        ThrowLastError();

    PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(static_cast<PVOID>(MappedViewOfFile));
    if (NtHeaders == NULL)
        ThrowLastError(ERROR_BAD_EXE_FORMAT);

    // This is correct for PE32 or PE32+.
    NtHeaders->FileHeader.Characteristics |= IMAGE_FILE_DLL;

    if (!MappedViewOfFile.Win32Close())
        ThrowLastError();
    if (!FileMapping.Win32Close())
        ThrowLastError();
    if (!File.Win32Close())
        ThrowLastError();
}

PCSTR PrintPathToString(RTL_PATH_TYPE PathType)
{
    switch (PathType)
    {
#define X(x) case x: return #x;
        X(RtlPathTypeUnknown)
        X(RtlPathTypeUncAbsolute)
        X(RtlPathTypeDriveAbsolute)
        X(RtlPathTypeDriveRelative)
        X(RtlPathTypeRooted)
        X(RtlPathTypeRelative)
        X(RtlPathTypeLocalDevice)
        X(RtlPathTypeRootLocalDevice)
#undef X
    default:
        return "unknown";
    }
}

void TestPathType(const PCWSTR* argv)
{
    if (*argv != NULL)
    {
        while (*argv != NULL)
        {
            RTL_PATH_TYPE PathType = SxspDetermineDosPathNameType(*argv);
            printf("%ls -> %s\n", *argv, PrintPathToString(PathType));
            argv += 1;
        }
    }
    else
    {
        const static PCWSTR args[] =
        {
            L"a",
            L"\\a",
            L"\\\\a",
            L"\\\\\\a",
            L"a:",
            L"a:\\",
            L"\\?",
            L"\\.",
            L"\\\\?",
            L"\\\\.",
            L"\\\\?\\",
            L"\\\\.\\",
            L"\\\\?\\a",
            L"\\\\.\\a",
            L"\\\\?\\a:",
            L"\\\\.\\a:",
            L"\\\\?\\a:\\",
            L"\\\\.\\a:\\",
            L"\\\\?\\unc",
            L"\\\\.\\unc",
            L"\\\\?\\unc\\",
            L"\\\\.\\unc\\",
            NULL
        };
        TestPathType(args);
    }
}

class CUnknown : public IUnknown
{
public:
    virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv)
    {
        return E_NOINTERFACE;
    }
    virtual ULONG __stdcall AddRef()
    {
        return 1;
    }
    virtual ULONG __stdcall Release()
    {
        return 1;
    }
};

struct G
{
    HINSTANCE sxsDll;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    HANDLE MainThread;
    INT    NumberOfThreads;
    HANDLE Threads[MAXIMUM_WAIT_OBJECTS];
    HANDLE ThreadExitEvent;
    wchar_t lastOperation[256];
    CUnknown unknown;

    CSmartRef<IGlobalInterfaceTable> GlobalInterfaceTable;

    //
    // the start of some automation / record keeping..
    //
    ULONG Failures;
    ULONG Successes;
} g;

const static struct
{
    DWORD  (WINAPI* GetModuleFileNameW)(HMODULE, LPWSTR, DWORD);
    SIZE_T (WINAPI* VirtualQuery)(LPCVOID, PMEMORY_BASIC_INFORMATION, SIZE_T);
}
Kernel32 =
{
    GetModuleFileNameW,
    VirtualQuery
};

const static struct
{
    HRESULT (WINAPI* IIDFromString)(LPOLESTR, LPIID);
    HRESULT (WINAPI* CLSIDFromString)(LPOLESTR, LPIID);
    HRESULT (WINAPI* CoCreateInstance)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID*);
    HRESULT (WINAPI* CoInitialize)(LPVOID);
    void (WINAPI* CoUninitialize)();
}
Ole32 =
{
    IIDFromString,
    CLSIDFromString,
    CoCreateInstance,
    CoInitialize,
    CoUninitialize
};

void
ManifestStringToTempFile(
    PCWSTR ManifestString,
    CBaseStringBuffer &rTempFilePath
    )
{
    CFusionFile File;
    WCHAR xTempFilePath[MAX_PATH];
    WCHAR TempDirectory[MAX_PATH];
    const static WCHAR NativeUnicodeByteOrderMark = 0xfeff;
    DWORD BytesWritten;

    //if (!::GetTempPathW(NUMBER_OF(TempDirectory), TempDirectory))
    //   ThrowLastError();

    ::GetModuleFileNameW(NULL, TempDirectory, NUMBER_OF(TempDirectory));
    *wcsrchr(TempDirectory, '\\') = 0;
    ::Trace("TempDirectory:%ls\n", TempDirectory);
	
    if (!::GetTempFileNameW(TempDirectory, L"", 0, xTempFilePath))
        ::ThrowLastError();
    rTempFilePath.Win32Assign(xTempFilePath, wcslen(xTempFilePath));

    ::Trace("xTempFilePath:%ls\n", xTempFilePath);
    ::Trace("TempFilePath:%ls\n", static_cast<PCWSTR>(xTempFilePath));

    if (!File.Win32CreateFile(rTempFilePath, GENERIC_WRITE, 0, CREATE_ALWAYS))
        ::ThrowLastError();

    if (!::WriteFile(File, &NativeUnicodeByteOrderMark, sizeof(NativeUnicodeByteOrderMark), &BytesWritten, NULL))
        ::ThrowLastError();

    if (!::WriteFile(File, ManifestString, static_cast<DWORD>(sizeof(*ManifestString) * StringLength(ManifestString)), &BytesWritten, NULL))
        ::ThrowLastError();
}

HANDLE
CreateActivationContextFromStringW(
    PCWSTR ManifestString
    )
{
    CStringBuffer TempFilePath;

    ::ManifestStringToTempFile(ManifestString, TempFilePath);

    ACTCTXW ActivationContextCreate = { sizeof(ActivationContextCreate) };
    ActivationContextCreate.lpSource = TempFilePath;
    HANDLE ActivationContextHandle = ::CreateActCtxW(&ActivationContextCreate);
    DWORD Error = ::GetLastError();
    ::DeleteFileW(TempFilePath);
    if (ActivationContextHandle == INVALID_HANDLE_VALUE)
        ::ThrowLastError(Error);
    return ActivationContextHandle;
}

int Usage(const wchar_t* argv0)
{
    std::wstring strargv0 = argv0;
    fprintf(stderr,
        "%ls",
        (
        L"Usage: \n"
        L"   " + strargv0 + L" [install-flags] manifest-or-image-with-manifest-resource-path\n"
        L"   " + strargv0 + L" [-pa processor-architecture] [-langid langid] -d manifest-path ...\n"
        L"   " + strargv0 + L" [-pa processor-architecture] [-langid langid] -p manifest-path ...\n"
        L"   " + strargv0 + L" [-pa processor-architecture] [-langid langid] -w32 manifest-path ...\n"
        L"   " + strargv0 + L" [-pa processor-architecture] [-langid langid] -msi msi-script...\n"
        L"   " + strargv0 + L" -tcreateprocess ...\n"
        L"   " + strargv0 + L" -tsearchpath ...\n"
        L"   " + strargv0 + L" -tcreateprocess ...\n"
        L"   " + strargv0 + L" -tempty test pushing a special empty context ...\n"
        L"   " + strargv0 + L" -tinherit test the usual default inheritance ...\n"
        L"   " + strargv0 + L" -tnoinherit test the noinherit bit ...\n"
        L"   " + strargv0 + L" [-threads n] create n threads for some tests ...\n"
        L"   " + strargv0 + L" probably other choices, use the source\n"
        L"\n"
        L"install-flags:\n"
        L"   -i\n"
        L"   -install\n"
        L"   -install-my-queue\n"
        L"   -install-setupapi-queue\n"
        L"   -install-from-resource\n"
        L"   -install-move\n"
        L"   -install-my-queue\n"
        L"   -install-setupapi-queue [requires debugger]\n"
        L"   -install-from-resource\n"
        ).c_str()
        );

    return EXIT_FAILURE;
}

const wchar_t* GetLastOperation()
{
    return g.lastOperation;
}

void SetLastOperation(const wchar_t* format, ...)
{
    va_list args;

    g.lastOperation[0] = 0;
    g.lastOperation[NUMBER_OF(g.lastOperation) - 1] = 0;

    va_start(args, format);
    _vsnwprintf(g.lastOperation, NUMBER_OF(g.lastOperation) - 1, format, args);
    va_end(args);
}

HANDLE DuplicateHandle(HANDLE handle)
{
    HANDLE newHandle = NULL;
    if (!DuplicateHandle(GetCurrentProcess(), handle, GetCurrentProcess(), &newHandle, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        ThrowLastError();
    }
    return newHandle;
}

__int64 IsFlag(PCWSTR arg)
{
const static struct
{
    WCHAR   name[32];
    __int64 value;
} flags[] =
{
    { L"i",                              SXSTEST_BEGIN_INSTALL},
    { L"install",                        SXSTEST_BEGIN_INSTALL},

    { L"install-my-queue",               SXSTEST_INSTALL_MY_QUEUE },
    { L"install-setupapi-queue",         SXSTEST_INSTALL_SETUPAPI_QUEUE },

    { L"install-from-resource",          SXS_INSTALL_ASSEMBLY_FLAG_FROM_RESOURCE            | SXSTEST_INSTALL},
    { L"install-move",                   SXS_INSTALL_ASSEMBLY_FLAG_MOVE                     | SXSTEST_INSTALL },
    { L"install-dir",                    SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY           | SXSTEST_INSTALL},
    { L"install-dir-recursive",          SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY_RECURSIVE | SXSTEST_INSTALL},
    { L"install-no-verify",              SXS_INSTALL_ASSEMBLY_FLAG_NO_VERIFY                | SXSTEST_INSTALL},
    { L"install-no-transact",            SXS_INSTALL_ASSEMBLY_FLAG_NOT_TRANSACTIONAL        | SXSTEST_INSTALL},
    { L"install-replace-existing",       SXS_INSTALL_ASSEMBLY_FLAG_REPLACE_EXISTING         | SXSTEST_INSTALL},

    { L"begin-install-replace-existing", SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING   | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-from-resource",    SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_RESOURCE      | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-move",             SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_MOVE               | SXSTEST_BEGIN_INSTALL },
    { L"begin-install-dir",              SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY     | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-dir-recursive",    SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-no-verify",        SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY          | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-no-transact",      SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL  | SXSTEST_BEGIN_INSTALL},

    { L"end-install-no-verify",          SXS_END_ASSEMBLY_INSTALL_FLAG_NO_VERIFY            | SXSTEST_END_INSTALL},

    { L"threads",                        SXSTEST_THREADS },

    { L"-",                              SXSTEST_END_OF_FLAGS }
};
    if (*arg == '-')
    {
        arg += 1;
        for (ULONG i = 0 ; i != NUMBER_OF(flags) ; ++i)
        {
            if (_wcsicmp(flags[i].name, arg) == 0)
                return flags[i].value;
        }
    }
    return 0;
}

DWORD __stdcall ThreadMain(PVOID)
{
//
// We run stuff in other threads via QueueUserAPC.
//
    __try
    {
        WaitForSingleObjectEx(g.ThreadExitEvent, INFINITE, TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG
        if (IsDebuggerPresent())
        {
            FUSION_DEBUG_BREAK();
        }
#endif
        QueueUserAPC(ThrowWin32, g.MainThread, GetExceptionCode());
    }
    return 0;
}

void CreateThreads()
{
    INT i;
    g.MainThread = DuplicateHandle(GetCurrentThread());
    g.ThreadExitEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (g.ThreadExitEvent == NULL)
    {
        ThrowLastError();
    }
    for (i = 0 ; i < g.NumberOfThreads ; i++)
    {
        g.Threads[i] = CreateThread(NULL, 0, ThreadMain, NULL, 0, NULL);
        if (g.Threads[i] == NULL)
        {
            int error = ::GetLastError();
            if (i > 2)
            {
                fprintf(stderr, "Only able to created %d threads, error=%d, continuing\n", i, error);
                g.NumberOfThreads = i;
                break;
            }
            fprintf(stderr, "Unable to create threads, error=%d, terminating\n", error);
            ThrowWin32(error);
        }
    }
}

void
GetFlags(
    wchar_t**& argv,
    __int64& flags,
    DWORD& beginInstallFlags,
    DWORD& installFlags,
    DWORD& endInstallFlags
    )
{
    __int64 flag;
    while (flag = IsFlag(argv[1]))
    {
        ++argv;
        if (flag & SXSTEST_END_OF_FLAGS)
        {
            break;
        }
        else if (flag & SXSTEST_BEGIN_INSTALL)
        {
            beginInstallFlags |= flag;
        }
        else if (flag & SXSTEST_INSTALL)
        {
            installFlags |= flag;
        }
        else if (flag & SXSTEST_END_INSTALL)
        {
            endInstallFlags |= flag;
        }
        else if (flag & SXSTEST_THREADS)
        {
            g.NumberOfThreads = _wtoi(*++argv);
            if (g.NumberOfThreads > NUMBER_OF(g.Threads))
            {
                g.NumberOfThreads = NUMBER_OF(g.Threads);
            }
        }

        // always set flags because normal installation is 0 now
        flags |= flag;
   }
}

VOID
FusionpSetSystemSetupInProgress(bool f)
{
    CFusionRegKey Regkey;
    CFusionRegKey RegkeyLocalMachine(HKEY_LOCAL_MACHINE);

    if (!RegkeyLocalMachine.OpenSubKey(Regkey, L"System\\Setup", KEY_ALL_ACCESS))
        return;
    Regkey.SetValue(L"SystemSetupInProgress", f ? 1 : 0);
}

extern "C"
BOOL
WINAPI
SxsDllMain(
    HINSTANCE hInst,
    DWORD dwReason,
    PVOID pvReserved
    );

int Main(int argc, wchar_t** argv)
{
    int i = 0;
    __int64 flags = 0;
    //__int64 flag  = 0;
    DWORD beginInstallFlags = 0;
    DWORD installFlags = 0;
    DWORD endInstallFlags = 0;
    wchar_t* argv0 = argv[0];

    g.wProcessorArchitecture = SxspGetSystemProcessorArchitecture();
    g.wLangId = ::GetUserDefaultLangID();
    if (argc > 1)
    {
        FusionpSetSystemSetupInProgress(false);
        __try
        {
        __try
        {
            if (!SxsDllMain(GetModuleHandle(NULL), DLL_PROCESS_ATTACH, NULL))
                ThrowLastError();
            GetFlags(argv, flags, beginInstallFlags, installFlags, endInstallFlags);

            i = 1;

            // consume global flags...
            for (;;)
            {
                if (::FusionpStrCmpI(argv[i], L"-pa") == 0)
                {
                    if (!ParseProcessorArchitecture(argc, argv, &i))
                        goto Exit;
                }
                else if (::FusionpStrCmpI(argv[i], L"-langid") == 0)
                {
                    if (!ParseLangId(argc, argv, &i))
                        goto Exit;
                }
                else
                    break;
            }

            if (false) { }
            else if (::FusionpStrCmpI(argv[i], L"-id") == 0)
            {
                DWORD index = 0;
                if (argv[3]){ // have an index present
                    index = argv[3][0] - L'0';
                }
                i = TestGeneratePathFromIdentityAttributeString(argv[2]);
            }
            else if (::FusionpStrCmpI(argv[i], L"-tPathType") == 0)
            {
                TestPathType(argv + i + 1);
            }
            else if (::FusionpStrCmpI(argv[i], L"-systemdefault") == 0)
            {
                i = TestSystemDefaultActivationContextGeneration();
            }
            else if (::FusionpStrCmpI(argv[i], L"-dom") == 0)
            {
                i = TestXMLDOM(argv[2]);
            }
            else if (::FusionpStrCmpI(argv[i], L"-hash") == 0)
            {
                i = TestGenerateStringWithIdenticalHash(argv[2]);
            }
            else if (::FusionpStrCmpI(argv[i], L"-tasyncio") == 0)
            {
                i++;
                i = TestAsyncIO(argc, argv, &i);
            }
            else if (::FusionpStrCmpI(argv[i], L"-assemblyidentityhash") == 0)
            {
                i = TestAssemblyIdentityHash();
            }
            else if (::FusionpStrCmpI(argv[i], L"-array") == 0)
            {
                i = TestFusionArray(argv[2], argv[3]);
            }
            else if (::FusionpStrCmpI(argv[i], L"-diffdir") == 0)
            {
                i = TestDiffDir(argv[i + 1], argv[i + 2]);
            }
            else if (::FusionpStrCmpI(argv[1], L"-pcm") == 0)
            {
                i = TestPrecomiledManifest(argv[2]);
            }
            else if (::FusionpStrCmpI(argv[1], L"-testpcm") == 0)
            {
                i = TestPCMTime(argv[2]);
            }
            else if (::FusionpStrCmpI(argv[1], L"-cd") == 0)
            {
                i = TestCreateMultiLevelDirectory(argv[2]);
            }
            else if (!::FusionpStrCmpI(argv[i], L"-manifests"))
            {
                TestDumpContainedManifests(argv[++i]);
            }
            else if (::FusionpStrCmpI(argv[1], L"-dirwalk") == 0)
            {
                i = TestDirWalk(argv[i + 1], argv[i + 2]);
            }
            else if (::FusionpStrCmpI(argv[1], L"-tmultiact") == 0)
            {
                i = TestMultiAct(argc, argv);
            }
            else if (flags)
            {
                PrintIfAnyCriticalSectionsHeld();
                i = TestInstall(argv[i], flags, beginInstallFlags, installFlags, endInstallFlags);
                PrintIfAnyCriticalSectionsHeld();
            }
            else if (!::FusionpStrCmpI(argv[i], L"-sfcui"))
            {
                if ( !TestSxsSfcUI() )
                    goto Exit;
                i++;
            }
            else if ( !FusionpStrCmpI( argv[i], L"-installwithinfo" ) )
            {
                TestInstallWithInstallInfo(
                    ( i + 1 < argc ) ? argv[i + 1] : NULL,
                    ( i + 2 < argc ) ? argv[i+2] : NULL);
                i += 2;
            }
            else if (!::FusionpStrCmpI(argv[i], L"-multicache"))
            {
                TestTrickyMultipleAssemblyCacheItems(argv[i + 1]);
                i++;
            }
            else if (::FusionpStrCmpI(argv[i], L"-d") == 0)
            {
                if (!TestDirect(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-probe") == 0)
            {
                i++;
                argv[i] = L"foo,type=\"win32\",processorArchitecture=\"x86\",version=\"6.0.0.0\",publicKeyToken=\"6595b64144ccf1df\"";
                if (!TestAssemblyProbing(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-dirchanges") == 0)
            {
                if (!TestDirectoryChangeWatcher(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-newinstall") == 0)
            {
                if (!TestNewSxsInstallAPI(argv[++i]))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-tuninstall") == 0
                  || ::FusionpStrCmpI(argv[i], L"-uninstall") == 0)
            {
                TestUninstall(argv[i + 1], argv[i + 2]);
                goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-probemanifest") == 0)
            {
                if (!TestManifestProbing(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-p") == 0)
            {
                if (!TestXMLParsing(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-w32") == 0)
            {
                TestWin32(argv + i + 1);
            }
            else if (::FusionpStrCmpI(argv[i], L"-msi") == 0)
            {
                if (!TestMSIInstall(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-mp") == 0)
            {
                if (!TestManifestSchema(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-act") == 0)
            {
                if (!TestAct(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-shatest") == 0)
            {
                if (!TestPrivateSha1Impl(argv[++i]))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[1], L"-am") == 0)
            {
                i = TestAssemblyName();
            }
            else if (::FusionpStrCmpI(argv[i], L"-tsurrogates") == 0)
            {
                if (!SimpleTestFindAndUseSurrogateInformation(argv[i+1], argv[i+2]))
                    goto Exit;
                i += 2;
            }
            else if (::FusionpStrCmpI(argv[i], L"-clrhelpers") == 0)
            {
                if (!TestSxsExportedSurrogateStuff(argv[i+1], argv[i+2], argv[i+3]))
                    goto Exit;
                i += 3;
            }            
            else if (::FusionpStrCmpI(argv[i], L"-tsearchpath") == 0)
            {
                if (!TestSearchPath(argc, argv, &i))
                    goto Exit;
            }
            else if (!::FusionpStrCmpI(argv[i], L"-testmapping"))
            {
                if (!TestOpeningStuff(argv[i+1], argv[i+2], argv[i+3]))
                    goto Exit;
                i += 3;
            }
            else if (!::FusionpStrCmpI(argv[i], L"-validatefile"))
            {
                if (!TestVerifyFileSignature(argv[++i]))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-tloadlibrary") == 0)
            {
                if (!TestLoadLibrary(argc, argv, &i))
                    goto Exit;
            }
            else if (!::FusionpStrCmpI(argv[i], L"-refresh"))
            {
                if (!TestRefreshAssembly(argv[i+1]))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-leak") == 0)
            {
                //
                // We dump a little bit of memory
                //
                UINT iAmount = 0;
                iAmount = _wtoi(argv[++i]);
                if (!TestLeakMemory(iAmount))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-tcreateprocess") == 0)
            {
                if (!TestCreateProcess(argv + i + 1))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-tcreateprocess2") == 0)
            {
                if (!TestCreateProcess2(argv + i + 1))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-tinherit") == 0)
            {
                TestInherit();
            }
            else if (::FusionpStrCmpI(argv[i], L"-tnoinherit") == 0)
            {
                TestNoInherit();
            }
            else if (::FusionpStrCmpI(argv[i], L"-tempty") == 0)
            {
                TestEmpty();
            }
            else if (::FusionpStrCmpI(argv[i], L"-ttsappcmp") == 0)
            {
                TestCreateGlobalEvent();
            }
            else if (::FusionpStrCmpI(argv[i], L"-tmsgperf") == 0)
            {
                i++;
                if (!TestMessagePerf(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpStrCmpI(argv[i], L"-twinsetup") == 0)
            {
                FusionpSetSystemSetupInProgress(true);
                if (!TestInstallLikeWindowsSetup(argv[i + 1], (argv[i + 2] != NULL) ? argv[i + 2] : argv[i + 1]))
                    goto Exit;
                i += 3;
            }
            else if (!::FusionpStrCmpI(argv[i], L"-sfcscan"))
            {
                TestSfcScanKickoff();
            }
            else if (!::FusionpStrCmpI(argv[i], L"-certinfo"))
            {
                GenerateStrongNameAndPublicKey(argv[++i]);
            }
            else if (::FusionpStrCmpI(argv[i], L"-thandle") == 0)
            {
                DWORD iAmount = 0;
                iAmount = _wtoi(argv[++i]);

                TestCreateActctxLeakHandles(iAmount);
            }
            else if (::FusionpStrCmpI(argv[i], L"-catsigner") == 0)
            {
                TestNewCatalogSignerThingy(argv[++i]);
            }
            else if (::FusionpStrCmpI(argv[i], L"-trefcount") == 0)
            {
                TestRefCount();
            }
            else if (::FusionpStrCmpI(argv[i], L"-ttileak") == 0)
            {
                TestThreadInheritLeak();
            }
            else if (::FusionpStrCmpI(argv[i], L"-tguidsort") == 0)
            {
                TestGuidSort();
            }
            else if (::FusionpStrCmpI(argv[i], L"-tstringsort") == 0)
            {
                TestStringSort();
            }
            else if (::FusionpStrCmpI(argv[i], L"-tExeDll") == 0)
            {
                TestExeDll();
            }
            else if (FusionpStrCmpI(argv[i], L"-tExitProcess") == 0)
            {
                LoadSxs();
                GetSxsProc(SXSP_DEBUG_ORDINAL, &pfnSxspDebug);
                pfnSxspDebug(SXS_DEBUG_EXIT_PROCESS, 0, 0, NULL);
            }
            else if (FusionpStrCmpI(argv[i], L"-tTerminateProcess") == 0)
            {
                LoadSxs();
                GetSxsProc(SXSP_DEBUG_ORDINAL, &pfnSxspDebug);
                pfnSxspDebug(SXS_DEBUG_TERMINATE_PROCESS, 0, 0, NULL);
            }
            else if (FusionpStrCmpI(argv[i], L"-tLastError") == 0)
            {
                ::SetLastError(123);
                printf("%lu\n", FusionpGetLastWin32Error());
                printf("%lu\n", ::GetLastError());
                ::FusionpSetLastWin32Error(456);
                printf("%lu\n", FusionpGetLastWin32Error());
                printf("%lu\n", ::GetLastError());
            }
            else if (FusionpStrCmpI(argv[i], L"-tGetModuleHandleEx") == 0)
            {
                TestGetModuleHandleEx();
            }
            else if (FusionpStrCmpI(argv[i], L"-tGetFullPathName") == 0)
            {
                TestGetFullPathName(argv[i + 1]);
            }
            else if (FusionpStrCmpI(argv[i], L"-tCreateFile") == 0)
            {
                TestCreateFile(argv[i + 1]);
            }
            else if (FusionpStrCmpI(argv[i], L"-tGetPathBaseName") == 0)
            {
                TestGetPathBaseName(argv[i + 1]);
            }
            else if (FusionpStrCmpI(argv[i], L"-tVersion") == 0)
            {
                TestVersion();
            }
            else if (FusionpStrCmpI(argv[i], L"-tGetProcessImageFileName") == 0)
            {
                TestGetProcessImageFileName();
            }
            else if (FusionpStrCmpI(argv[i], L"-tErrorInfra") == 0)
            {
                TestErrorInfra();
            }
            else if (FusionpStrCmpI(argv[i], L"-tQueryActCtx") == 0)
                TestQueryActCtx();
            else if (FusionpStrCmpI(argv[i], L"-tQueryActCtx2") == 0)
                TestQueryActCtx2();
            else if (FusionpStrCmpI(argv[i], L"-tqmib") == 0)
            {
                TestQueryManifestInformationBasic(argv[i+1]);
            }
            else if (FusionpStrCmpI(argv[i], L"-t64k") == 0)
            {
                Test64k();
            }
            else if (FusionpStrCmpI(argv[i], L"-tcreateactctx") == 0)
            {
                TestCreateActCtx(argc - (i + 1), &argv[i+1]);
            }
            else if (FusionpStrCmpI(argv[i], L"-TestCreateActCtx_PE_flags0") == 0)
            {
                TestCreateActCtx_PE_flags0();
            }
            else if (FusionpStrCmpI(argv[i], L"-tDotLocalSingleInstancing") == 0)
            {
                TestDotLocalSingleInstancing();
            }
            else if (FusionpStrCmpI(argv[i], L"-tCreateActctxLikeCreateProcess") == 0)
            {
                TestCreateActctxLikeCreateProcess();
            }
            else if (FusionpStrCmpI(argv[i], L"-tCreateActctxLikeCreateProcess") == 0)
            {
                TestCreateActctxLikeCreateProcess();
            }
            else if (FusionpStrCmpI(argv[i], L"-tCreateActctxAdminOverride") == 0)
            {
                TestCreateActctxAdminOverride();
            }
            else if (FusionpStrCmpI(argv[i], L"-tCreateActctxWindowsShellManifest") == 0)
            {
                TestCreateActctxWindowsShellManifest();
            }
            else if (FusionpStrCmpI(argv[i], L"-tHandleLeak") == 0)
            {
                //for (ULONG i = 0 ; i != 5 ; i += 1)
                    TestHandleLeaks();
            }
            else if (FusionpStrCmpI(argv[i], L"-tMfcCreateAndMarshal") == 0)
            {
                TestMfcCreateAndMarshal();
            }
            else if (FusionpStrCmpI(argv[i], L"-tAtlCreate") == 0)
            {
                TestAtlCreate();
            }
            else if (FusionpStrCmpI(argv[i], L"-TestAlignment") == 0)
            {
                TestAlignment();
            }
            else if (FusionpStrCmpI(argv[i], L"-DoNothingJustSeeIfItRuns") == 0)
            {
                printf("%wZ ran successfully\n", &NtCurrentPeb()->ProcessParameters->ImagePathName);
            }
            else if (FusionpStrCmpI(argv[i], L"-TestImage") == 0)
            {
                TestImage();
            }
            else if (FusionpStrCmpI(argv[i], L"-TestInterlockedAlignment") == 0)
            {
                TestInterlockedAlignment();
            }
            else
            {
                i = Usage(argv0);
            }
            if (g.ThreadExitEvent)
            {
                SetEvent(g.ThreadExitEvent);
                WaitForMultipleObjectsEx(g.NumberOfThreads, g.Threads, TRUE, INFINITE, TRUE);
            }
            if (g.sxsDll != NULL)
            {
                FreeLibrary(g.sxsDll);
            }
        }
        __finally
        {
            FusionpSetSystemSetupInProgress(false);
        }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
#if DBG
            if (IsDebuggerPresent())
            {
                FUSION_DEBUG_BREAK();
            }
#endif
            i = GetExceptionCode();
            WCHAR message[128];
            DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM;
            FormatMessageW(flags, NULL, i, 0, message, NUMBER_OF(message), NULL);
            PWSTR end = message + wcslen(message);
            while (end != message && isspace(*(end - 1)))
            {
                --end;
            }
            *end = 0;
            ::Trace("%ls failed, %d, %#x, %ls", g.lastOperation, i, i, message);
        }
        PTEB teb;
        teb = NtCurrentTeb();
        if (teb->CountOfOwnedCriticalSections != 0)
        {
            DbgPrint("teb->CountOfOwnedCriticalSections %d\n", teb->CountOfOwnedCriticalSections);
            //ASSERT(teb->CountOfOwnedCriticalSections == 0);
        }

        return i ? EXIT_SUCCESS : EXIT_FAILURE;
    }
    return Usage(argv[0]);

Exit:
    return ::GetLastError();
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
//  NtCurrentTeb()->CountOfOwnedCriticalSections = 0;
    PrintIfAnyCriticalSectionsHeld();
    int i = Main(argc, argv);
    PrintIfAnyCriticalSectionsHeld();
    return i;
}

int TestDiffDir(PCWSTR dir1, PCWSTR dir2)
{
    CFusionDirectoryDifference diff;
    CStringBuffer buf1;
    CStringBuffer buf2;
    BOOL fSuccess = FALSE;

    if (!buf1.Win32Assign(dir1, ::wcslen(dir1)))
        goto Exit;
    if (!buf2.Win32Assign(dir2, ::wcslen(dir2)))
        goto Exit;

    if (!::FusionpCompareDirectoriesSizewiseRecursively(&diff, buf1, buf2))
        goto Exit;

    diff.DbgPrint(buf1, buf2);

    fSuccess = TRUE;
Exit:
    return fSuccess ? EXIT_SUCCESS : EXIT_FAILURE;
}

PCWSTR GetUser()
{
    static bool fInited;
    static WCHAR userName[MAX_PATH];
    if (!fInited)
    {
        DWORD size = NUMBER_OF(userName);
        userName[0] = 0;
        userName[1] = 0;
        GetUserNameW(userName, &size);
        if (userName[1] == '-')
        {
            wmemcpy(userName, 2+userName, 1+wcslen(2+userName));
        }
        fInited = true;
    }
    return userName;
}

void UserBreakPoint(PCWSTR user)
{
    if (::IsDebuggerPresent() && _wcsicmp(GetUser(), user) == 0)
    {
        ASSERT2_NTC(FALSE, __FUNCTION__);
    }
}

void LoadSxs()
{
    WCHAR ExePath[MAX_PATH];
    if (g.sxsDll == NULL)
    {
        SetLastOperation(L"LoadLibrary(SXS.DLL)");
    // sxstest is often run from nt\base\win32\fusion\tests\sxstest\whistler\obj\i386\sxstest.exe; try loading sxs.dll
    // via a relative path first
        g.sxsDll = ::LoadLibraryW(L"..\\..\\..\\..\\..\\dll\\whistler\\obj\\i386\\SXS.DLL");
        if (g.sxsDll == NULL)
        {
            GetModuleFileNameW(NULL, ExePath, NUMBER_OF(ExePath));
            wcscpy(1 + wcsrchr(ExePath, '\\'), L"SXS.DLL");
            g.sxsDll = ::LoadLibraryW(ExePath);
        }
        if (g.sxsDll == NULL)
            g.sxsDll = ::LoadLibraryW(L"SXS.DLL");
        if (g.sxsDll == NULL)
            ThrowLastError();
        UserBreakPoint(L"JayKrell");
    }
}

template <typename PFN>
void GetSxsProc(int name, PFN* ppfn)
{
    SetLastOperation(L"GetProcAddress(#%d)", name);
    if (!(*ppfn = reinterpret_cast<PFN>(GetProcAddress(g.sxsDll, reinterpret_cast<PCSTR>(IntToPtr(name))))))
    {
        ThrowLastError();
    }
}

template <typename PFN>
void GetSxsProc(PCSTR name, PFN* ppfn)
{
    SetLastOperation(L"GetProcAddress(%hs)", name);
    if (!(*ppfn = reinterpret_cast<PFN>(GetProcAddress(g.sxsDll, name))))
    {
        ThrowLastError();
    }
}

class CCopyQueueElement : public std::pair<std::wstring, std::wstring>
{
    typedef std::pair<std::wstring, std::wstring> Base;
public:
    CCopyQueueElement() { }

    CCopyQueueElement(const first_type& source, const second_type& target)
        :
    Base(source, target)
    {
    }

          first_type& Source()       { return first; }
    const first_type& Source() const { return first; }
          second_type& Target()       { return second; }
    const second_type& Target() const { return second; }
};

template <typename T> class StdDeque : public std::deque<T, Allocator<T> > { };
template <typename T> class StdVector : public std::vector<T, Allocator<T> > { };

class CCopyQueue : public StdDeque<CCopyQueueElement>
{
    typedef StdDeque<CCopyQueueElement> Base;
public:
    BOOL Callback(
        PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters
        )
    {
        push_back(value_type(parameters->pSourceFile, parameters->pDestinationFile));

        parameters->nDisposition = SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_QUEUED;
        return TRUE;
    }

    static BOOL WINAPI StaticCallback(
        PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters
        )
    {
        CCopyQueue* pThis = reinterpret_cast<CCopyQueue*>(parameters->pvContext);
        BOOL fResult = pThis->Callback(parameters);
        return fResult;
    }

    BOOL Flush()
    {
        BOOL fSuccess = FALSE;
        for (; !empty() ; pop_back())
        {
            const std::wstring& target = back().Target();
            const std::wstring targetDir = target.substr(0, target.find_last_of('\\'));
            FusionpCreateDirectories(targetDir.c_str(), ::wcslen(targetDir.c_str()));
            if (!CopyFileW(back().Source().c_str(), target.c_str(), TRUE))
            {
                goto Exit;
            }
        }
        fSuccess = TRUE;
Exit:
        return fSuccess;
    }
};

int
TestInstall(
    PCWSTR manifest,
    __int64 flags,
    DWORD beginInstallFlags,
    DWORD installFlags,
    DWORD endInstallFlags
    )
{
    PrintIfAnyCriticalSectionsHeld();

    BOOL                        fSuccess = FALSE;
    PVOID                       installCookie = NULL;
    PSXS_BEGIN_ASSEMBLY_INSTALL sxsBeginAssemblyInstall = NULL;
    PSXS_INSTALL_ASSEMBLY_W     sxsInstallAssemblyW = NULL;
    PSXS_END_ASSEMBLY_INSTALL   sxsEndAssemblyInstall = NULL;
    CCopyQueue                  copyQueue;
    BOOL                        fCleanup = FALSE;
    SXS_INSTALL_SOURCE_INFO     SxsInstallInfo = {0};


    PSXS_INSTALLATION_FILE_COPY_CALLBACK    callback = NULL;
    PVOID                                   context = NULL;
    HSPFILEQ                                hSetupCopyQueue = INVALID_HANDLE_VALUE;
    PVOID                                   pDefaultSetupCopyQueueContext = NULL;
    
    LoadSxs();
    GetSxsProc("SxsBeginAssemblyInstall",   &sxsBeginAssemblyInstall);
    GetSxsProc("SxsInstallAssemblyW",       &sxsInstallAssemblyW);
    GetSxsProc("SxsEndAssemblyInstall",     &sxsEndAssemblyInstall);

    if (flags & SXSTEST_INSTALL_MY_QUEUE)
    {
        callback = &CCopyQueue::StaticCallback;
        context = &copyQueue;
    }
    else if (flags & SXSTEST_INSTALL_SETUPAPI_QUEUE)
    {
        callback = SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE;
        if (INVALID_HANDLE_VALUE == (hSetupCopyQueue = SetupOpenFileQueue()))
        {
            goto Exit;
        }
        context = hSetupCopyQueue; // random non NULL, step through, then stop debugging
#if DBG
        FUSION_DEBUG_BREAK();
#endif
    }

    PrintIfAnyCriticalSectionsHeld();

    if (!(*sxsBeginAssemblyInstall)(
        beginInstallFlags,
        callback,
        context,
        NULL, // ImpersonationCallback,
        NULL, // ImpersonationContext,
        &installCookie))
    {
        goto Exit;
    }
    fCleanup = TRUE;

    PrintIfAnyCriticalSectionsHeld();

    memset(&SxsInstallInfo, 0, sizeof(SxsInstallInfo));
    SxsInstallInfo.cbSize = sizeof(SxsInstallInfo);
    SxsInstallInfo.dwFlags = SXSINSTALLSOURCE_INSTALLING_SETUP | SXSINSTALLSOURCE_HAS_CODEBASE;
    SxsInstallInfo.pcwszCodebaseName = manifest;

    fSuccess = sxsInstallAssemblyW(
        installCookie,
        installFlags | SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY_RECURSIVE | SXS_INSTALL_ASSEMBLY_FLAG_INCLUDE_CODEBASE,
        manifest,
        &SxsInstallInfo);

    PrintIfAnyCriticalSectionsHeld();

    fSuccess = copyQueue.Flush();
Exit:
    if (fCleanup)
    {
        if (flags & SXSTEST_INSTALL_SETUPAPI_QUEUE)
        {
            if (!(pDefaultSetupCopyQueueContext = ::SetupInitDefaultQueueCallback(NULL)))
            {
                fSuccess = FALSE;
            }
            if (fSuccess && !::SetupCommitFileQueue(NULL,
                    hSetupCopyQueue,
                    SetupDefaultQueueCallback,
                    pDefaultSetupCopyQueueContext))
            {
                fSuccess = FALSE;
            }
            if (hSetupCopyQueue != INVALID_HANDLE_VALUE)
            {
                ::SetupCloseFileQueue(hSetupCopyQueue);
                hSetupCopyQueue = NULL;
            }
        }

        sxsEndAssemblyInstall(installCookie, endInstallFlags | (fSuccess ? SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT : SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT), NULL);
    }

    PrintIfAnyCriticalSectionsHeld();

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

BOOL
TestManifestSchema(
    int argc,
    wchar_t** argv,
    int* piNext
    )
{
    SXSP_DEBUG_FUNCTION& pfn = pfnSxspDebug;
    BOOL fSuccess = FALSE;

    int i = (*piNext) + 1;

    if (i >= argc)
    {
        fprintf(stderr, "%S: Missing parameter after \"%S\"\n", argv[0], argv[i-1]);
        goto Exit;
    }

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_CHECK_MANIFEST_SCHEMA, 0, argv[i++], NULL);

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        goto Exit;
    }

    *piNext = i;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
TestXMLParsing(
    int argc,
    wchar_t** argv,
    int* piNext)
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;
    int i = (*piNext) + 1;

    if (i >= argc)
    {
        fprintf(stderr, "%S: missing parameter after \"%S\"\n", argv[0], argv[i-1]);
        goto Exit;
    }

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_XML_PARSER, 0, argv[i], NULL);

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        goto Exit;
    }

    *piNext = i + 1;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
TestDirect(
    int argc,
    wchar_t** argv,
    int* piNext)
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;
    int i = (*piNext) + 1;

    if (i >= argc)
    {
        fprintf(stderr, "%S: missing parameter after \"%S\"\n", argv[0], argv[i-1]);
        goto Exit;
    }

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_DLL_REDIRECTION, 0, argv[i], NULL);

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        goto Exit;
    }

    *piNext = i + 1;
    fSuccess = TRUE;
Exit:
    return fSuccess;

}

VOID
PrintBlob(
    FILE *pf,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
    )
{
    ULONG Offset = 0;

    if (PerLinePrefix == NULL)
        PerLinePrefix = L"";

    // we'll output in 8-byte chunks as shown:
    //
    //  [prefix]Binary section %p (%d bytes)
    //  [prefix]   00000000: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //  [prefix]   00000008: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //  [prefix]   00000010: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //

    while (Length >= 8)
    {
        BYTE *pb = (BYTE *) (((ULONG_PTR) Data) + Offset);

        fprintf(
            pf,
            "%S   %08lx: %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x (%c%c%c%c%c%c%c%c)\n",
            PerLinePrefix,
            Offset,
            pb[0], pb[1], pb[2], pb[3], pb[4], pb[5], pb[6], pb[7],
            PRINTABLE(pb[0]),
            PRINTABLE(pb[1]),
            PRINTABLE(pb[2]),
            PRINTABLE(pb[3]),
            PRINTABLE(pb[4]),
            PRINTABLE(pb[5]),
            PRINTABLE(pb[6]),
            PRINTABLE(pb[7]));

        Offset += 8;
        Length -= 8;
    }

    if (Length != 0)
    {
        CStringBuffer buffTemp;
        bool First = true;
        ULONG i;
        BYTE *pb = (BYTE *) (((ULONG_PTR) Data) + Offset);

        buffTemp.Win32ResizeBuffer(48, eDoNotPreserveBufferContents);

        buffTemp.Win32Format(L"   %08lx: ", Offset);

        for (i=0; i<8; i++)
        {
            if (Length > 0)
            {
                if (!First)
                    buffTemp.Win32Append("-", 1);
                else
                    First = false;

                buffTemp.Win32FormatAppend(L"%02x", pb[i]);

                Length--;
            }
            else
            {
                buffTemp.Win32Append("   ", 3);
            }
        }

        buffTemp.Win32Append(" (", 2);

        i = 0;

        while (Length != 0)
        {
            CHAR chTemp = static_cast<CHAR>(PRINTABLE(pb[i]));
            i++;
            buffTemp.Win32Append(&chTemp, 1);
            Length--;
        }

        buffTemp.Win32Append(L")", 1);

        fprintf(
            pf,
            "%S%S\n",
            PerLinePrefix,
            static_cast<PCWSTR>(buffTemp));
    }
}

void __stdcall TestWin32Apc(ULONG_PTR arg)
{
    ACTCTXW ac = {sizeof(ac)};
    int     error = 0;
    PWSTR   source = reinterpret_cast<PWSTR>(arg);
    HANDLE  hActCtx = NULL;
    BOOL    fSuccess = FALSE;

    ac.lpSource = source;
    PWSTR pound = wcschr(source, '#');
    if (pound != NULL)
    {
        *pound = 0;
        ac.lpResourceName = pound + 1;
        ac.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
    }
    ac.wProcessorArchitecture = g.wProcessorArchitecture;
    ac.wLangId = g.wLangId;
    hActCtx = ::CreateActCtxW(&ac);
    if (hActCtx == INVALID_HANDLE_VALUE)
    {
        error = ::GetLastError();
        fwprintf(stderr, L"CreateActCtxW(%ls) failed; ::GetLastError() = %d\n", source, error);
        goto Exit;
    }
    //fSuccess = ::ReleaseActCtx(hActCtx);
    fSuccess = TRUE;
    hActCtx = NULL;
    if (!fSuccess)
    {
        error = ::GetLastError();
        goto Exit;
    }
Exit:
    if (error)
        ThrowWin32(error);
}

void
TestWin32(
    wchar_t** argv
    )
{
    CreateThreads();
    int i = 0;

    for (i = 0 ; argv[i] ; ++i)
    {
        if (g.NumberOfThreads)
        {
            if (!QueueUserAPC(TestWin32Apc, g.Threads[i % g.NumberOfThreads], reinterpret_cast<ULONG_PTR>(argv[i])))
            {
                fprintf(stderr, "QueueUserAPC() failed\n");
                ThrowWin32(((ULONG_PTR) (LONG_PTR) -1));
            }
        }
        else
        {
            TestWin32Apc(reinterpret_cast<ULONG_PTR>(argv[i]));
        }
    }
}
#if BETA1
const static WCHAR InheritManifest[] =
L"<assembly manifestversion=\"1.0\" name=\"InheritManifest\">"
L"<dependency assemblyname=\"Microsoft-Visual-CPlusPlus-Runtime-Libraries\" version=\"6.0.0.0\" language=\"0000\"/>"
L"</assembly>"
;
#else   // suppose to be BETA2 or later
const static WCHAR InheritManifest[] =
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Windows.SystemCompatibleAssembly\" version=\"1.0.0.0\" processorArchitecture=\"x86\" />"
L"<description>System Compatible Default</description> "
L"<dependency> <dependentAssembly>"
L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Tools.VisualCPlusPlus.Runtime-Libraries\" version=\"6.0.0.0\" language=\"*\" processorArchitecture=\"x86\" publicKeyToken=\"6595b64144ccf1df\" />"
L"</dependentAssembly> </dependency></assembly>"
;
#endif


const static WCHAR NoInheritManifest[] =
L"<assembly manifestversion=\"1.0\" name=\"InheritManifest\">"
L"<dependency assemblyname=\"Microsoft-Visual-CPlusPlus-Runtime-Libraries\" version=\"6.0.0.0\" language=\"0000\"/>"
L"<noinherit/>"
L"</assembly>"
;

const static WCHAR RefCountManifest[] =
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Windows.SxsTest.RefCount\" version=\"1.0.0.0\" processorArchitecture=\"x86\" />"
L"<description>blah</description> "
L"<dependency><dependentAssembly>"
//L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Windows.SxsTest1\" version=\"1.0.0.0\" language=\"*\" processorArchitecture=\"x86\" publicKeyToken=\"6595b64144ccf1df\" />"
L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Tools.VisualCPlusPlus.Runtime-Libraries\" version=\"6.0.0.0\" language=\"*\" processorArchitecture=\"x86\" publicKeyToken=\"6595b64144ccf1df\" />"
L"</dependentAssembly> </dependency></assembly>"
;

// to test the empty actctx, we push this, probe, push empty, probe
const static PCWSTR DependentOnMsvc6Manifest = InheritManifest;

WCHAR SearchPathResult[MAX_PATH];

void ProbeContext(const char* Function, PCWSTR Dll = L"msvcrt.dll")
{
    SearchPathResult[0] = 0;
    SearchPathW(NULL, Dll, NULL, NUMBER_OF(SearchPathResult), SearchPathResult, NULL);

    DbgPrint("%s %ls\n", Function, SearchPathResult);
}

DWORD CALLBACK InheritThreadMain(VOID*)
{
    ProbeContext(__FUNCTION__);
    return 0;
}

DWORD CALLBACK NoinheritThreadMain(VOID*)
{
    ProbeContext(__FUNCTION__);
    return 0;
}

void TestInherit()
{
    ProbeContext(__FUNCTION__);
    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(InheritManifest);
    ULONG_PTR Cookie;
    ActivateActCtx(ActivationContextHandle, &Cookie);
    ProbeContext(__FUNCTION__);
    DWORD ThreadId;
    WaitForSingleObject(CreateThread(NULL, 0, InheritThreadMain, NULL, 0, &ThreadId), INFINITE);
}

void TestNoInherit()
{
    ProbeContext(__FUNCTION__);
    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(NoInheritManifest);
    ULONG_PTR Cookie;
    ActivateActCtx(ActivationContextHandle, &Cookie);
    ProbeContext(__FUNCTION__);
    DWORD ThreadId;
    WaitForSingleObject(CreateThread(NULL, 0, NoinheritThreadMain, NULL, 0, &ThreadId), INFINITE);
}

void TestEmpty()
{
    ProbeContext(__FUNCTION__);
    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(DependentOnMsvc6Manifest);
    ULONG_PTR Cookie1, Cookie2;
    ActivateActCtx(ActivationContextHandle, &Cookie1);
    ProbeContext(__FUNCTION__);
    ActivateActCtx(ACTCTX_EMPTY, &Cookie2);
    ProbeContext(__FUNCTION__);
    DeactivateActCtx(0, Cookie2);
    ProbeContext(__FUNCTION__);
    DeactivateActCtx(0, Cookie1);
    ProbeContext(__FUNCTION__);
}

#if 0

#define SXSTEST_NTOPENFILE_RET  NTSTATUS
#define SXSTEST_NTOPENFILE_CALL NTAPI
#define SXSTEST_NTOPENFILE_ARG_NAMES_TYPES \
 (\
    OUT PHANDLE FileHandle, \
    IN ACCESS_MASK DesiredAccess, \
    IN POBJECT_ATTRIBUTES ObjectAttributes, \
    OUT PIO_STATUS_BLOCK IoStatusBlock, \
    IN ULONG ShareAccess, \
    IN ULONG OpenOptions \
)

#define SXSTEST_NTCREATEFILE_RET  NTSTATUS
#define SXSTEST_NTCREATEFILE_CALL NTAPI
#define SXSTEST_NTCREATEFILE_ARG_NAMES_TYPES \
 (\
    OUT PHANDLE FileHandle, \
    IN ACCESS_MASK DesiredAccess, \
    IN POBJECT_ATTRIBUTES ObjectAttributes, \
    OUT PIO_STATUS_BLOCK IoStatusBlock, \
    IN PLARGE_INTEGER AllocationSize OPTIONAL, \
    IN ULONG FileAttributes, \
    IN ULONG ShareAccess, \
    IN ULONG CreateDisposition, \
    IN ULONG CreateOptions, \
    IN PVOID EaBuffer OPTIONAL, \
    IN ULONG EaLength \
)

SXSTEST_NTCREATEFILE_RET (SXSTEST_NTCREATEFILE_CALL* SxsTestDynamicNtCreateFileTrampoline)(...);

SXSTEST_NTCREATEFILE_RET
DETOUR_TRAMPOLINE(
    SXSTEST_NTCREATEFILE_RET SXSTEST_NTCREATEFILE_CALL SxsTestNtCreateFileTrampoline SXSTEST_NTCREATEFILE_ARG_NAMES_TYPES,
    NtCreateFile
    );

DETOUR_TRAMPOLINE(
    SXSTEST_NTOPENFILE_RET SXSTEST_NTOPENFILE_CALL SxsTestNtOpenFileTrampoline SXSTEST_NTCREATEFILE_ARG_NAMES_TYPES,
    NtOpenFile
    );

#endif

void TestRefCount()
{
    //
    // 1) newly created actctx has refcount==1
    // 2) activated actctx has refcount==1
    // 3) load a library with no deps with actctx, refcount==2
    // 4) freelibrary, refcount==1
    //    directory of library is closed
    // 5) release actctx refcount==0
    //
    // First order, just step through the code to look at the refcount.
    // Second order, "detour" like crazy and look at the memory
    //  (including detouring away RtlFreeHeap, NtUnmapViewOfSection)
    //

    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(RefCountManifest);
    ULONG_PTR Cookie1;
    ActivateActCtx(ActivationContextHandle, &Cookie1);
    FreeLibrary(LoadLibraryW(L"msvcrt.dll"));
    DeactivateActCtx(0, Cookie1);
    ReleaseActCtx(ActivationContextHandle);

#if 0
    WCHAR RenameDirectorySource[MAX_PATH];
    WCHAR RenameDirectoryDestination[MAX_PATH];

    //
    // Try to rename the directory.
    //
    DbgPrint("dll was loaded from %ls, now see if we can rename that directory\n", SearchPathResult);

    wcscpy(RenameDirectorySource, SearchPathResult);
    *wcsrchr(SearchPathResult, '\\') = 0;
    wcscpy(RenameDirectoryDestination, RenameDirectorySource);
    wcscpy(wcsrchr(RenameDirectoryDestination, '\\'), L"blah");

    BOOL Success = MoveFileW(RenameDirectorySource, RenameDirectoryDestination);
    int Error = ::GetLastError();
    DbgPrint("MoveFile(%ls -> %ls) %s, Error=%d\n",
        RenameDirectorySource, RenameDirectoryDestination, Success ? "succeeded" : "failed", Error);
#endif
}

GUID Guids[100];
WCHAR GuidStrings[100][64];

void FormatGuid(WCHAR* String, const GUID& Guid)
{
    swprintf(
        String,
        L"%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        Guid.Data1,
        Guid.Data2,
        Guid.Data3,
        Guid.Data4[0], Guid.Data4[1], Guid.Data4[2], Guid.Data4[3],
        Guid.Data4[4], Guid.Data4[5], Guid.Data4[6], Guid.Data4[7]);
}

extern "C" HRESULT __stdcall
DllGetClassObject(
    REFCLSID rclsid,  //CLSID for the class object
    REFIID riid,      //Reference to the identifier of the interface
                    // that communicates with the class object
    LPVOID * ppv      //Address of output variable that receives the
                    // interface pointer requested in riid
    )
{
    WCHAR GuidString[64];

    FormatGuid(GuidString, rclsid);
    printf("%s : {%ls}\n", __FUNCTION__, GuidString);

    if (riid == IID_IUnknown)
    {
        *ppv = &g.unknown;
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

void TestGuidSort()
{
    const int MAX = 100;
    FN_TRACE_SMART_TLS();

    CStringBuffer Manifest;
    int i = 0;

    Ole32.CoInitialize(NULL);

    Manifest.Win32ResizeBuffer(1 << 15, eDoNotPreserveBufferContents);
    Manifest.Win32Format(
        L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\"> \
                <assemblyIdentity \
                    type=\"win32\" \
                    name=\"Microsoft.Windows.SxsTest.GuidSort\" \
                    version=\"1.0.0.0\" \
                    processorArchitecture=\"x86\" \
                    publicKeyToken=\"6595b64144ccf1df\" \
                /> \
            <file name=\"sxstest.exe\">");

    for (i = 0 ; i < MAX ; ++i)
    {
        GUID& Guid = Guids[i];
        CoCreateGuid(&Guid);

        FormatGuid(GuidStrings[i], Guid);
        if (!Manifest.Win32FormatAppend(
            L"\n<comClass description=\"a%d\" clsid=\"{%ls}\"/>",
            i,
            static_cast<PCWSTR>(GuidStrings[i])))
            ThrowLastError();
    }

    if (!Manifest.Win32FormatAppend(L"\n</file>\n</assembly>"))
        ThrowLastError();

    //LoadSxs();
    //GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);
    //fSuccess = (*pfn)(SXS_DEBUG_DLL_REDIRECTION, 0, argv[i], NULL);

    printf("%ls\n", static_cast<PCWSTR>(Manifest));

    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(Manifest);
    ULONG_PTR Cookie1;
    ActivateActCtx(ActivationContextHandle, &Cookie1);
    for (i = 0 ; i < MAX ; ++i)
    {
        HRESULT hr;
        PVOID   pv = NULL;

        hr = Ole32.CoCreateInstance(Guids[i], NULL, CLSCTX_INPROC, IID_IUnknown, &pv);
        printf("CoCreateInstance({%ls}): %08lx%s%s%s\n",

            GuidStrings[i],

            static_cast<unsigned long>(hr),

            ( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            || hr == REGDB_E_CLASSNOTREG
            || (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
            || (hr == E_NOINTERFACE)
           ) ? "(" : "",

            (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                ? "ERROR_FILE_NOT_FOUND"
                : (hr == REGDB_E_CLASSNOTREG)
                ? "REGDB_E_CLASSNOTREG"
                : (hr == ERROR_INVALID_PARAMETER)
                ? "ERROR_INVALID_PARAMETER"
                : (hr == E_NOINTERFACE)
                ? "E_NOINTERFACE (ok)"
                : "",

            ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
            || hr == REGDB_E_CLASSNOTREG
            || hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
            || hr == E_NOINTERFACE
            ? ")" : "");
    }
    DeactivateActCtx(0, Cookie1);
    ReleaseActCtx(ActivationContextHandle);
}

void TestStringSort()
{
    /*
    Mike says this takes between 2 and 7 to visit the code.
    */
    const int MAX = 50;
    FN_TRACE_SMART_TLS();
    WCHAR ExePath[MAX_PATH];
    CStringBuffer DllPaths[MAX];

    CStringBuffer Manifest;
    int i = 0;

    if (!Kernel32.GetModuleFileNameW(NULL, ExePath, RTL_NUMBER_OF(ExePath)))
        ThrowLastError();

    if (!Manifest.Win32ResizeBuffer(1 << 15, eDoNotPreserveBufferContents))
        ThrowLastError();
    if (!Manifest.Win32Format(
        L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\"> \
                <assemblyIdentity \
                    type=\"win32\" \
                    name=\"Microsoft.Windows.SxsTest.StringSort\" \
                    version=\"1.0.0.0\" \
                    processorArchitecture=\"x86\" \
                    publicKeyToken=\"6595b64144ccf1df\" \
                /> \
            <file name=\"sxstest.exe\"/>"))
        ThrowLastError();
    for (i = 0 ; i < MAX ; ++i)
    {
        if (!DllPaths[i].Win32Format(L"%ls.%d.dll", ExePath, i))
            ThrowLastError();

        if (!::CopyFileW(ExePath, DllPaths[i], FALSE))
            ThrowLastError();

        SetDllBitInPeImage(DllPaths[i]);

        if (!Manifest.Win32FormatAppend(L"\n<file name=\"%ls\"/>\n", 1 + wcsrchr(static_cast<PCWSTR>(DllPaths[i]), '\\')))
            ThrowLastError();
    }
    if (!Manifest.Win32FormatAppend(L"\n</assembly>"))
        ThrowLastError();

    //LoadSxs();
    //GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);
    //fSuccess = (*pfn)(SXS_DEBUG_DLL_REDIRECTION, 0, argv[i], NULL);

    printf("%ls\n", static_cast<PCWSTR>(Manifest));

    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(Manifest);
    ULONG_PTR Cookie1;
    ActivateActCtx(ActivationContextHandle, &Cookie1);
    for (i = 0 ; i < MAX ; ++i)
    {
        HMODULE h;
        PCWSTR DllName = 1 + wcsrchr(DllPaths[i], '\\');

        h = ::LoadLibraryW(DllName);
        printf("LoadLibrary(%ls):%p, LastError=%d\n",
            DllName,
            h,
            ::GetLastError());
        //FreeLibrary(h);
        ::DeleteFileW(DllPaths[i]);
    }
    DeactivateActCtx(0, Cookie1);
    ReleaseActCtx(ActivationContextHandle);
}

int
TestSearchPathHelper1(
    PCSTR RunId,
    PCWSTR Path,
    PCWSTR File,
    PCWSTR Extension,
    bool GetFilePart,
    ULONG cch
    )
{
    WCHAR Buffer[65536]; // we know that the underlying code can never use a buffer this big
    PWSTR FilePart = NULL;
    PWSTR *lpFilePart = (GetFilePart ? &FilePart : NULL);
    SetLastError(ERROR_GEN_FAILURE);
    ULONG Result = ::SearchPathW(
        Path,
        File,
        Extension,
        0,
        NULL,
        lpFilePart);

    printf("SearchPath() RunId = %s (Path %s; File %s; Extension %s; GetFilePart %s; cch = %lu; buffer=null) result = %lu ::GetLastError() = %u; FilePart = %s %u\n",
        RunId,
        Path ? "present" : "null",
        File ? "present" : "null",
        Extension ? "present" : "null",
        GetFilePart ? "true" : "false",
        0,
        Result,
        ::GetLastError(),
        FilePart ? "present" : "null",
        FilePart ? (FilePart - Buffer) : 0);

    SetLastError(ERROR_GEN_FAILURE);
    FilePart = NULL;
    ULONG NewResult = ::SearchPathW(
        Path,
        File,
        Extension,
        Result,
        Buffer,
        lpFilePart);

    printf("SearchPath() RunId = %s (Path %s; File %s; Extension %s; GetFilePart %s; cch = %lu) result = %lu ::GetLastError() = %u; FilePart = %s %u\n",
        RunId,
        Path ? "present" : "null",
        File ? "present" : "null",
        Extension ? "present" : "null",
        GetFilePart ? "true" : "false",
        Result,
        NewResult,
        ::GetLastError(),
        FilePart ? "present" : "null",
        FilePart ? (FilePart - Buffer) : 0);

    SetLastError(ERROR_GEN_FAILURE);
    FilePart = NULL;
    Result = ::SearchPathW(
        Path,
        File,
        Extension,
        cch,
        Buffer,
        lpFilePart);

    printf("SearchPath() RunId = %s (Path %s; File %s; Extension %s; GetFilePart %s; cch = %lu) result = %lu ::GetLastError() = %u; FilePart = %s %u\n",
        RunId,
        Path ? "present" : "null",
        File ? "present" : "null",
        Extension ? "present" : "null",
        GetFilePart ? "true" : "false",
        cch,
        Result,
        ::GetLastError(),
        FilePart ? "present" : "null",
        FilePart ? (FilePart - Buffer) : 0);

    return EXIT_SUCCESS;
}

int
TestSearchPathHelper2(
    PCSTR RunId,
    PCWSTR Path,
    PCWSTR File,
    PCWSTR Extension,
    ULONG cch
    )
{
    TestSearchPathHelper1(RunId, NULL, File, NULL, true, cch);
    TestSearchPathHelper1(RunId, NULL, File, NULL, false, cch);
    TestSearchPathHelper1(RunId, Path, File, NULL, true, cch);
    TestSearchPathHelper1(RunId, Path, File, NULL, false, cch);
    TestSearchPathHelper1(RunId, NULL, File, Extension, true, cch);
    TestSearchPathHelper1(RunId, NULL, File, Extension, false, cch);
    TestSearchPathHelper1(RunId, Path, File, Extension, true, cch);
    TestSearchPathHelper1(RunId, Path, File, Extension, false, cch);

    return EXIT_SUCCESS;
}

int
TestSearchPathHelper3(
    PCSTR RunId,
    PCWSTR Path,
    PCWSTR File,
    PCWSTR Extension
    )
{
    ULONG i;

    for (i=0; i<5; i++)
        TestSearchPathHelper2(RunId, Path, File, Extension, i);

    for (i=MAX_PATH-5; i<(MAX_PATH+5); i++)
        TestSearchPathHelper2(RunId, Path, File, Extension, i);

    for (i=32760; i<32770; i++)
        TestSearchPathHelper2(RunId, Path, File, Extension, i);

    return EXIT_SUCCESS;
}

BOOL
TestSearchPath(
    int argc,
    wchar_t** argv,
    int* piNext
    )
{
    ULONG i;
    PWSTR PathToSearch = (PWSTR) malloc(100000* sizeof(WCHAR));
    int iNext = (*piNext) + 1;

    PathToSearch[0] = L'C';
    PathToSearch[1] = L'\\';
    for (i=2; i<60000; i++)
        PathToSearch[i] = L'X';
    wcscpy(&PathToSearch[i], L";C:\\");

    TestSearchPathHelper3("1.0", L"C:\\DirectoryDoesNotExist;C:\\", L"boot.ini", L".ini");
    TestSearchPathHelper3("1.1", L"C:\\DirectoryDoesNotExist;C:\\", L"boot.", L".ini");
    TestSearchPathHelper3("1.2", L"C:\\DirectoryDoesNotExist;C:\\", L"boot", L".ini");
    TestSearchPathHelper3("1.3", L"C:\\DirectoryDoesNotExist;C:\\", L"doesnotexist.doesnotexist", L".ini");
    TestSearchPathHelper3("1.4", L"C:\\DirectoryDoesNotExist;C:\\", L"d:\\readme.txt", L".ini");
    TestSearchPathHelper3("1.5", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32.dll", L".dll");
    TestSearchPathHelper3("1.6", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32.", L".dll");
    TestSearchPathHelper3("1.7", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32", L".dll");
    TestSearchPathHelper3("1.8", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32.dll", L".ini");
    TestSearchPathHelper3("1.9", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32.", L".ini");
    TestSearchPathHelper3("1.10", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32", L".ini");

    TestSearchPathHelper3("2.0", L"C:\\;C:\\DirectoryDoesNotExist", L"boot.ini", L".ini");
    TestSearchPathHelper3("2.1", L"C:\\;C:\\DirectoryDoesNotExist", L"boot.", L".ini");
    TestSearchPathHelper3("2.2", L"C:\\;C:\\DirectoryDoesNotExist", L"boot", L".ini");
    TestSearchPathHelper3("2.3", L"C:\\;C:\\DirectoryDoesNotExist", L"doesnotexist.doesnotexist", L".ini");
    TestSearchPathHelper3("2.4", L"C:\\;C:\\DirectoryDoesNotExist", L"d:\\readme.txt", L".ini");
    TestSearchPathHelper3("2.5", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32.dll", L".dll");
    TestSearchPathHelper3("2.6", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32.", L".dll");
    TestSearchPathHelper3("2.7", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32", L".dll");
    TestSearchPathHelper3("2.8", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32.dll", L".ini");
    TestSearchPathHelper3("2.9", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32.", L".ini");
    TestSearchPathHelper3("2.10", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32", L".ini");

    TestSearchPathHelper3("3.0", PathToSearch, L"boot.ini", L".ini");
    TestSearchPathHelper3("3.1", PathToSearch, L"boot", L".ini");
    TestSearchPathHelper3("3.1", PathToSearch, L"boot.", L".ini");
    TestSearchPathHelper3("3.2", PathToSearch, L"doesnotexist.doesnotexist", L".ini");
    TestSearchPathHelper3("3.3", PathToSearch, L"d:\\readme.txt", L".ini");

    *piNext = iNext;

    return EXIT_SUCCESS;
}

BOOL
TestAct(
    int argc,
    wchar_t** argv,
    int* piNext)
{
    ULONG i, c;
    ULONG_PTR *prgCookies = NULL;
    HANDLE hActCtx = NULL;
    CHAR buffer[1024];
    int iNext = (*piNext + 1);
    BOOL fSuccess = FALSE;

    if (iNext >= argc)
    {
        fprintf(stderr, "%S: missing parameter after \"%S\"\n", argv[0], argv[iNext - 1]);
        goto Exit;
    }

    WideCharToMultiByte(CP_ACP, 0, argv[iNext++], -1, buffer, NUMBER_OF(buffer), NULL, NULL);

    ACTCTXA ac;

    ac.cbSize = sizeof(ac);
    ac.dwFlags = 0;
    ac.lpSource = buffer;
    ac.wProcessorArchitecture = g.wProcessorArchitecture;
    ac.wLangId = g.wLangId;

    hActCtx = ::CreateActCtxA(&ac);
    if (hActCtx == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "CreateActCtxA() failed; ::GetLastError() = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    c = 0;

    if (argc > iNext)
        c = _wtoi(argv[iNext++]);

    if (c == 0)
        c = 100;

    prgCookies = NEW(ULONG_PTR[c]);
    if (prgCookies == NULL)
    {
        fprintf(stderr, "Unable to allocate %lu cookies.\n", c);
        goto Exit;
    }

    for (i=0; i<c; i++)
    {
        if (!ActivateActCtx(hActCtx, &prgCookies[i]))
        {
            fprintf(stderr, "Attempt to activate to depth %lu failed; ::GetLastError() = %d\n", i, ::GetLastError());
            goto Exit;
        }
    }

    for (i=0; i<c; i++)
    {
        ULONG j = (c - i) - 1;
        DeactivateActCtx(0, prgCookies[j]);
    }

    ReleaseActCtx(hActCtx);

    fSuccess = TRUE;
    *piNext = iNext;

Exit:
    delete []prgCookies;

    return fSuccess;
}

HRESULT Helper_WriteStream(CBaseStringBuffer * pFileNameBuf,
                           IStream *pStream)
{
    HRESULT     hr          = NOERROR;
    LPBYTE      pBuf[0x4000];
    DWORD       cbBuf       = 0x4000;
    DWORD       dwWritten   = 0;
    DWORD       cbRead      = 0;
    HANDLE      hf          = INVALID_HANDLE_VALUE;

    hf = ::CreateFileW(static_cast<PCWSTR>(*pFileNameBuf), GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hf == INVALID_HANDLE_VALUE){
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Exit;
    }

    while (::ReadFile(hf, pBuf, cbBuf, &cbRead, NULL) && cbRead){
        hr = pStream->Write(pBuf, cbRead, &dwWritten);
        if (FAILED(hr))
            goto Exit;
    }

    if (! SUCCEEDED(hr =pStream->Commit(0)))
        goto Exit;

    CloseHandle(hf);

Exit:
    return hr;
}

BOOL
TestMSIInstall(
    int argc,
    wchar_t** argv,
    int* piNext
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmartRef<IAssemblyCache>     pCache;
    CSmartRef<IAssemblyCacheItem> ppCacheItem[4];
    CSmartRef<IStream>            pStream;
    PFNCreateAssemblyCache      pCreateAssemblyCache = NULL;
    CStringBuffer               SourceFilePathBuf;
    CStringBuffer               SourceFileNameBuf;

    CHAR                        buf[1024];
    FILE*                       fp = NULL;
    LPSTR                       p1, pbuf ;
    int                         i, cAsm;

    int iArg = (*piNext) + 1;
    if (iArg >= argc)
    {
        fprintf(stderr, "%S: missing parameter after \"%S\"\n", argv[0], argv[iArg-1]);
        goto Exit;
    }

    LoadSxs();
    GetSxsProc("CreateAssemblyCache", &pCreateAssemblyCache);
    IFCOMFAILED_EXIT(pCreateAssemblyCache(&pCache, 0));


    WideCharToMultiByte(CP_ACP, 0, argv[iArg], -1, buf, NUMBER_OF(buf), NULL, NULL);
    fp = fopen(buf, "r");
    if (!fp)  {
        fprintf(stderr, "%S: Error opening script file \"%S\"\n", argv[0], argv[iArg]);
        goto Exit;
    }
    cAsm = 0;
    while (! feof(fp)) {
        if (! fgets(buf, 80, fp)) { // end of file or error
            if (ferror(fp)){ // error occur
                fprintf(stderr, "%S: Error occur while reading the script file\n", argv[0]);
                goto Exit;
            }
            else{ // end of file
                fprintf(stderr, "%S: end of script file\n", argv[0]);
                break;
            }
        }
        // trim the string
        i = 0 ;
        while (buf[i] == ' ') i++; // skip the whitespace at the beginning of the line
        pbuf = buf + i ; // pointer to the first un-whitespace char in the line
        i = 0 ;
        while (pbuf[i] != '\n') i++;
        pbuf[i] = '\0';

        p1 = NULL;
        p1 = strchr(pbuf, ' ');
        if (p1 == NULL) { // instruction line
            if (strcmp(pbuf, "BeginAsmCacheItem") == 0) {
                IFCOMFAILED_EXIT(pCache->CreateAssemblyCacheItem(0, NULL, &ppCacheItem[cAsm], NULL));
            }else
            if (strcmp(pbuf, "EndAsmCacheItem") == 0) {
                IFCOMFAILED_EXIT(ppCacheItem[cAsm]->Commit(0, NULL));
                cAsm ++;
            }
        }
        else
        { // get the first word of the line
            *p1 = '\0';
            p1++; // p1 points to the filename now
            IFW32FALSE_EXIT(SourceFileNameBuf.Win32Assign(p1, ::strlen(p1)));
            if (strcmp(pbuf,"SourceFilePath") == 0) { // fullpath of source files, which would be in a CD
                IFW32FALSE_EXIT(SourceFilePathBuf.Win32Assign(p1, ::strlen(p1)));
                SourceFilePathBuf.Win32EnsureTrailingPathSeparator();
            }else
            if (strcmp(pbuf, "FILE") == 0) {
                IFCOMFAILED_EXIT(ppCacheItem[cAsm]->CreateStream(0, SourceFileNameBuf, STREAM_FORMAT_WIN32_MODULE, 0, &pStream, NULL));
                IFW32FALSE_EXIT(SourceFileNameBuf.Win32Assign(SourceFilePathBuf, ::wcslen(SourceFilePathBuf)));
                IFW32FALSE_EXIT(SourceFileNameBuf.Win32Append(p1, ::strlen(p1))); // containing full-path of the source file
                IFCOMFAILED_EXIT(Helper_WriteStream(&SourceFileNameBuf, pStream));
                pStream.Release(); // stream should be released since writtingfile has been done

            }else
            if (strcmp(pbuf, "MANIFEST") == 0) {
                IFCOMFAILED_EXIT(ppCacheItem[cAsm]->CreateStream(0, SourceFileNameBuf, STREAM_FORMAT_WIN32_MANIFEST, 0, &pStream, NULL));
                IFW32FALSE_EXIT(SourceFileNameBuf.Win32Assign(SourceFilePathBuf, SourceFilePathBuf.Cch())); // containing full-path of the source file
                IFW32FALSE_EXIT(SourceFileNameBuf.Win32Append(p1, ::strlen(p1)));
                IFCOMFAILED_EXIT(Helper_WriteStream(&SourceFileNameBuf, pStream));
                pStream.Release(); // stream should be released since writtingfile has been done
            }
        } // end of else
    }// end of while

    fSuccess = TRUE;
    *piNext = iArg;
Exit:
    fp ? fclose(fp) : 0;
    return fSuccess;
}

CDirWalk::ECallbackResult
DirWalkCallback(
    CDirWalk::ECallbackReason reason,
    CDirWalk*                 dirWalk,
    DWORD                     dwFlags
    )
{
    PCWSTR parent = dirWalk->m_strParent;
    PCWSTR leaf   = dirWalk->m_fileData.cFileName;
    if (reason == CDirWalk::eFile)
        printf("file %lu, %ls, %ls\n", reason, parent, leaf);
    else
        printf("directory %lu, %ls\n", reason, parent);
    return CDirWalk::eKeepWalking;
}

int
TestDirWalk(
    PCWSTR  root,
    PWSTR   filter
    )
{
    CDirWalk dirWalk;
    StdVector<std::wstring> vstrFilter;
    StdVector<PCWSTR> vstrFilter2;
    PWSTR filterTok;

    if (filterTok = wcstok(filter, L";"))
    {
        do
        {
            vstrFilter.push_back(filterTok);
            vstrFilter2.push_back(vstrFilter.back().c_str());
        } while (filterTok = wcstok(NULL, L";"));
    }
    dirWalk.m_fileFiltersBegin = &*vstrFilter2.begin();
    dirWalk.m_fileFiltersEnd = &*vstrFilter2.end();
    dirWalk.m_strParent.Win32Assign(root, ::wcslen(root));
    dirWalk.m_callback = DirWalkCallback;
    dirWalk.Walk();
    return 0;
}

int
TestMultiAct(
    int argc,
    wchar_t **argv
    )
{
    HANDLE h1, h2;
    ACTCTXW acw;

    memset(&acw, 0, sizeof(acw));

    acw.cbSize = sizeof(acw);
    acw.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
    acw.lpSource = argv[2];
    acw.lpResourceName = MAKEINTRESOURCEW(1);

    h1 = ::CreateActCtxW(&acw);
    if (h1 == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "1st CreateActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    h2 = ::CreateActCtxW(&acw);
    if (h2 == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "2nd CreateActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

BOOL
ParseProcessorArchitecture(
    int argc,
    wchar_t** argv,
    int* piCurrent
    )
{
    BOOL fSuccess = FALSE;

    int i = *piCurrent;

    i++;

    if (i >= argc)
    {
        fprintf(stderr, "%S: missing parameter after %S\n", argv[0], argv[i - 1]);
        goto Exit;
    }

    if (::FusionpStrCmpI(argv[i], L"x86") == 0)
        g.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
    else if (::FusionpStrCmpI(argv[i], L"i386") == 0)
        g.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
    else if (::FusionpStrCmpI(argv[i], L"ia64") == 0)
        g.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
    else if (::FusionpStrCmpI(argv[i], L"alpha64") == 0)
        g.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_ALPHA64;
    else
    {
        fprintf(stderr, "%S: invalid -pa value \"%S\"\n", argv[0], argv[i]);
        goto Exit;
    }

    *piCurrent = i + 1;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
ParseLangId(
    int argc,
    wchar_t** argv,
    int* piCurrent
    )
{
    BOOL fSuccess = FALSE;

    int i = *piCurrent;

    i++;

    if (i >= argc)
    {
        fprintf(stderr, "%S: missing parameter after %S\n", argv[0], argv[i - 1]);
        goto Exit;
    }

    swscanf(argv[i], L"%hx", &g.wLangId);

    *piCurrent = i + 1;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
TestLoadLibrary(
    int argc,
    wchar_t** argv,
    int* piNext
    )
{
    int i = (*piNext) + 1;
    HINSTANCE hInstance = NULL;
    BOOL fExpectedToFail = FALSE;
    BOOL fSuccess = FALSE;

    while (i < argc)
    {
        if (::FusionpStrCmpI(argv[i], L"-fail-") == 0)
            fExpectedToFail = TRUE;
        else if (::FusionpStrCmpI(argv[i], L"-succeed-") == 0)
            fExpectedToFail = FALSE;
        else
        {
            hInstance = LoadLibraryW(argv[i]);
            if (hInstance == NULL)
            {
                if (!fExpectedToFail)
                {
                    fprintf(stderr, "%S: Failed to LoadLibraryW(\"%S\"); ::GetLastError() = %d\n", argv[0], argv[i], ::GetLastError());
                }
            }
            else
            {
                if (fExpectedToFail)
                {
                    WCHAR LibraryPath[4096];

                    Kernel32.GetModuleFileNameW(hInstance, LibraryPath, NUMBER_OF(LibraryPath));

                    fprintf(stderr, "%S: LoadLibraryW(\"%S\") was supposed to fail, but instead we got \"%S\"\n", argv[0], argv[i], LibraryPath);
                }

                ::FreeLibrary(hInstance);
                hInstance = NULL;
            }
        }

        i++;
    }

    fSuccess = TRUE;
// Exit:
    return fSuccess;
}

int TestAssemblyName()
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_ASSEMBLYNAME_CONVERSION, 0, NULL, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;

}

int TestPrecomiledManifest(PCWSTR manifestFileName)
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_PRECOMPILED_MANIFEST, 0, manifestFileName, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

int TestPCMTime(PCWSTR manifestFilename)
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_TIME_PCM, 0, manifestFilename, NULL);

    if (! fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

int TestCreateMultiLevelDirectory(PCWSTR dirs)
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_CREAT_MULTILEVEL_DIRECTORY, 0, dirs, NULL);

    if (! fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}


BOOL
TestLeakMemory(
    DWORD dwAmount
    )
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;

    if (dwAmount < 1) {
        fprintf(stderr, "%s got a bad parameter, %d; rectifying to 1.\n", __FUNCTION__, dwAmount);
        dwAmount = 1;
    }

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_FORCE_LEAK, 0, NULL, (PDWORD)&dwAmount);

    if (! fSuccess)
    {
        fprintf(stderr, "%s failed to leak %d bytes of memory!\n", __FUNCTION__, dwAmount);
        return EXIT_FAILURE;
    }
    else
    {
        fprintf(stdout, "%s leaked %d bytes of memory.\n", __FUNCTION__, dwAmount);
        return EXIT_SUCCESS;
    }
}

BOOL
TestManifestProbing(
    int argc,
    wchar_t **argv,
    int *piNext
    )
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;
    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_PROBE_MANIFST, 0, NULL, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;

}

BOOL
TestAssemblyProbing(
    int argc,
    wchar_t **argv,
    int *piNext
    )
{
    PSXS_PROBE_ASSEMBLY_INSTALLATION pfn;
    BOOL fSuccess = FALSE;
    DWORD dwDisposition = 0;

    LoadSxs();
    GetSxsProc(SXS_PROBE_ASSEMBLY_INSTALLATION, &pfn);

    fSuccess = (*pfn)(0, argv[*piNext], &dwDisposition);

    return (fSuccess ? EXIT_SUCCESS : EXIT_FAILURE);
}

int TestCreateProcess2(wchar_t** argv)
{
    STARTUPINFOW StartupInfo = { sizeof(StartupInfo) };
    PROCESS_INFORMATION ProcessInformation = {0};

    *argv += wcsspn(*argv, L" \t\r\n");

    BOOL f = ::CreateProcessW(
        *argv,
        NULL,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation);
    printf("CreateProcess(%S) returned %s\n", *argv, f ? "True" : "False");

    return EXIT_SUCCESS;
}


int TestCreateProcess(wchar_t** argv)
{
    CUnicodeStringBuffer CommandLine;
    STARTUPINFOW StartupInfo = { sizeof(StartupInfo) };
    PROCESS_INFORMATION ProcessInformation = {0};

    while (*argv)
    {
        CommandLine.Win32Append(L" ", 1);
        CommandLine.Win32Append(*argv, ::wcslen(*argv));
        argv++;
    }

    CUnicodeStringBufferAccessor MutableCommandLine(&CommandLine);
    BOOL f = ::CreateProcessW(
        NULL,
        MutableCommandLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation);
    printf("CreateProcess(%S) returned %s\n", static_cast<PCWSTR>(MutableCommandLine), f ? "True" : "False");

    return EXIT_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////
// XMLDOM Helper function:
////////////////////////////////////////////////////////////////////////////
HRESULT XMLDOMHelper_WalkTree(IXMLDOMNode* node, int level)
{
    IXMLDOMNode* pChild, *pNext;
    BSTR nodeName;
    IXMLDOMNamedNodeMap* pattrs;

    node->get_nodeName(&nodeName);
    for (int i = 0; i < level; i++)
        printf(" ");
    printf("%S",nodeName);
    SysFreeString(nodeName);


    if (SUCCEEDED(node->get_attributes(&pattrs)) && pattrs != NULL)
    {
        pattrs->nextNode(&pChild);
        while (pChild)
        {
            BSTR name;
            pChild->get_nodeName(&name);
            printf(" %S='", name);
            ::SysFreeString(name);

            VARIANT value;
            pChild->get_nodeValue(&value);
            if (value.vt == VT_BSTR)
            {
                printf("%S", V_BSTR(&value));
            }
            printf("'");
            VariantClear(&value);
            pChild->Release();
            pattrs->nextNode(&pChild);
        }
        pattrs->Release();
    }
    printf("\n");

    node->get_firstChild(&pChild);
    while (pChild)
    {
        XMLDOMHelper_WalkTree(pChild, level+1);
        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
    }

    return S_OK;
}
////////////////////////////////////////////////////////////////////////////
// XMLDOM Helper function:
////////////////////////////////////////////////////////////////////////////
HRESULT XMLDOMHelper_ReportError(IXMLDOMParseError *pXMLError)
{
    long line, linePos;
    LONG errorCode;
    BSTR pBURL = NULL, pBReason = NULL;
    HRESULT hr;

    hr = pXMLError->get_line(&line);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_linepos(&linePos);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_errorCode(&errorCode);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_url(&pBURL);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_reason(&pBReason);
    if (FAILED(hr))
        goto Exit;


    fprintf(stderr, "%S", pBReason);
    if (line > 0)
    {
        fprintf(stderr, "Error on line %d, position %d in \"%S\".\n",
            line, linePos, pBURL);
    }
    hr= E_FAIL;

Exit:
    SysFreeString(pBURL);
    SysFreeString(pBReason);

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// XMLDOM Helper function: Check load results
////////////////////////////////////////////////////////////////////////////
HRESULT XMLDOMHelper_CheckLoad(IXMLDOMDocument* pDoc)
{
    // And since we don't have the VARIANT_BOOL from load we
    // need to check the parse Error errorCode property to see
    // if everything went ok.
    IXMLDOMParseError  *pXMLError = NULL;
    LONG errorCode;
    HRESULT hr = NOERROR;

    hr = pDoc->get_parseError(&pXMLError);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_errorCode(&errorCode);
    if (FAILED(hr))
        goto Exit;

    if (errorCode != 0){
        hr = XMLDOMHelper_ReportError(pXMLError);
        goto Exit;
    }

     hr = NOERROR;
Exit:
    if (pXMLError)
        pXMLError->Release();

    return hr;
}
////////////////////////////////////////////////////////////////////////////
// XMLDOM Helper function:
////////////////////////////////////////////////////////////////////////////
HRESULT XMLDOMHelper_LoadDocumentSync(IXMLDOMDocument *pDoc, BSTR pBURL)
{
    IXMLDOMParseError  *pXMLError = NULL;
    VARIANT         vURL;
    VARIANT_BOOL    vb;
    HRESULT         hr;

    hr = pDoc->put_async(VARIANT_FALSE);
    if (FAILED(hr))
        goto Exit;

    // Load xml document from the given URL or file path
    VariantInit(&vURL);
    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = pBURL;
    hr = pDoc->load(vURL, &vb);
    if (FAILED(hr))
        goto Exit;

    hr = XMLDOMHelper_CheckLoad(pDoc);
    if (FAILED(hr))
        goto Exit;

    hr = NOERROR;

Exit:
    if (pXMLError)
        pXMLError->Release();

    return hr;
}


BOOL TestXMLDOM(PCWSTR pswzXMLFileName)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument *pDoc = NULL;
    IXMLDOMNode* pNode = NULL;
    BSTR pBURL = NULL;

    Ole32.CoInitialize(NULL);

    // Create an empty XML document
    hr = Ole32.CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                                IID_IXMLDOMDocument, (void**)&pDoc);
    if (FAILED(hr))
        goto Exit;

    pBURL = SysAllocString(pswzXMLFileName);
    hr = XMLDOMHelper_LoadDocumentSync(pDoc, pBURL);
    if (FAILED(hr))
        goto Exit;

    // Now walk the loaded XML document dumping the node names to stdout.
    hr = pDoc->QueryInterface(IID_IXMLDOMNode,(void**)&pNode);
    if (FAILED(hr))
        goto Exit;

    hr = XMLDOMHelper_WalkTree(pNode,0);
    if (FAILED(hr))
        goto Exit;

    hr = NOERROR;

Exit:
    if (pDoc) pDoc->Release();
    SysFreeString(pBURL);
    if (pNode) pNode->Release();

    Ole32.CoUninitialize();

    return hr == 0 ? 0 : 1;

}

BOOL TestFusionArray(PCWSTR dir1, PCWSTR dir2)
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;
    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_FUSION_ARRAY, 0, dir1, (PVOID)dir2);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

BOOL TestGeneratePathFromIdentityAttributeString(PCWSTR str)
{
    PSXSPGENERATEMANIFESTPATHONASSEMBLYIDENTITY pfn = NULL;

    BOOL        fSuccess = FALSE;
    WCHAR       folderName[5000];
    SIZE_T      cch = NUMBER_OF(folderName);

    LoadSxs();

    GetSxsProc("SxspGenerateManifestPathOnAssemblyIdentity", &pfn);

    fSuccess = (*pfn)((PWSTR) str, folderName, &cch, NULL);

    if (! fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
    {
        wprintf(L"Folder name returned is %s\n", folderName);
        return EXIT_SUCCESS;
    }

}

BOOL
TestDirectoryChangeWatcher(
    int argc,
    wchar_t **argv,
    int *piNext
    )
{
    SXSP_DEBUG_FUNCTION pfn;
    BOOL fSuccess;

    LoadSxs();
    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);
    fSuccess = (*pfn)(SXS_DEBUG_DIRECTORY_WATCHER, 0, NULL, NULL);
    return (fSuccess ? EXIT_SUCCESS : EXIT_FAILURE);
}


BOOL
TestRefreshAssembly(
    PCWSTR wsAssemblyManifest
    )
{
    BOOL fSuccess = FALSE;
    PSXS_INSTALL_ASSEMBLY_W     sxsInstallAssemblyW = NULL;

    LoadSxs();
    GetSxsProc("SxsInstallAssemblyW", &sxsInstallAssemblyW);

    if (!sxsInstallAssemblyW(
        NULL,
        SXS_INSTALL_ASSEMBLY_FLAG_REPLACE_EXISTING,
        wsAssemblyManifest,
        NULL))
    {
        fwprintf(
            stderr,
            L"Failed reinstalling assembly '%ls', 0x%08X\n",
            wsAssemblyManifest,
            ::GetLastError());
    }
    else
    {
        fSuccess = TRUE;
    }

    return fSuccess;
}

BOOL
TestInstallWithInstallInfo(
    PCWSTR wsAssemblyManifest,
    PCWSTR wsReferenceString
    )
{
#define SXS_TEST

    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PSXS_INSTALL_W_ROUTINE sxsInstallW = NULL;
    SXS_INSTALLW InstallParameters = {sizeof(InstallParameters)};
    SXS_INSTALL_REFERENCEW InstallReference = {sizeof(InstallReference)};

    LoadSxs();
    GetSxsProc("SxsInstallW",               &sxsInstallW);

    InstallParameters.dwFlags = 
        //SXS_INSTALL_FLAG_MOVE |
        SXS_INSTALL_FLAG_REPLACE_EXISTING |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID;
    InstallParameters.lpCodebaseURL = wsAssemblyManifest;
    InstallParameters.lpManifestPath = wsAssemblyManifest;
    InstallParameters.lpReference = &InstallReference;
    InstallParameters.lpRefreshPrompt = L"boop";

    InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
    InstallReference.lpIdentifier = wsReferenceString ? wsReferenceString : L"TempRef";

    if (!(*sxsInstallW)(&InstallParameters))
    {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

BOOL
TestInstallLikeWindowsSetup(
    PCWSTR wsAssemblyManifest,
    PCWSTR wsCodebase
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PSXS_BEGIN_ASSEMBLY_INSTALL sxsBeginAssemblyInstall = NULL;
    PSXS_INSTALL_W_ROUTINE sxsInstallW = NULL;
    PSXS_END_ASSEMBLY_INSTALL sxsEndAssemblyInstall = NULL;
    SXS_INSTALLW InstallParameters = {sizeof(InstallParameters)};
    SXS_INSTALL_REFERENCEW InstallReference = {sizeof(InstallReference)};

    LoadSxs();
    GetSxsProc("SxsBeginAssemblyInstall",   &sxsBeginAssemblyInstall);
    GetSxsProc("SxsInstallW",               &sxsInstallW);
    GetSxsProc("SxsEndAssemblyInstall",     &sxsEndAssemblyInstall);

    IFW32FALSE_EXIT(
        (*sxsBeginAssemblyInstall)(
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL
            | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY
            | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING,
            NULL,
            NULL,
            NULL,
            NULL,
            &InstallParameters.pvInstallCookie));

    InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL;
    InstallReference.lpNonCanonicalData = L"Foom";
    
    InstallParameters.dwFlags |= SXS_INSTALL_FLAG_CODEBASE_URL_VALID 
                              |  SXS_INSTALL_FLAG_FROM_DIRECTORY
                              |  SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE
                              |  SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID
                              |  SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID
                              |  SXS_INSTALL_FLAG_REFERENCE_VALID
                           ;
    InstallParameters.lpCodebaseURL = wsCodebase;
    InstallParameters.lpRefreshPrompt = L"like..Windows CD..";
    InstallParameters.lpManifestPath = wsAssemblyManifest;
    InstallParameters.lpReference = &InstallReference;

    IFW32FALSE_EXIT((*sxsInstallW)(&InstallParameters));

    IFW32FALSE_EXIT(
        (*sxsEndAssemblyInstall)(
            InstallParameters.pvInstallCookie,
            SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT,
            NULL));
    InstallParameters.pvInstallCookie = NULL;

    fSuccess = TRUE;
Exit:

    if (InstallParameters.pvInstallCookie != NULL)
    {
        CSxsPreserveLastError ple;
        (void) (*sxsEndAssemblyInstall)(InstallParameters.pvInstallCookie, SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT, NULL);
        ple.Restore();
    }

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

//#define ASM_CPUID { __asm __emit 0fh __asm __emit 0a2h }
#define ASM_CPUID { __asm cpuid }
#define ASM_RDTSC { __asm rdtsc }

inline VOID GetCpuIdLag(LARGE_INTEGER *ref)
{
#if !defined(_WIN64)
    LARGE_INTEGER temp, temp2;
    _asm
    {
        cpuid
        cpuid
        cpuid
        cpuid
        cpuid
        rdtsc
        mov temp.LowPart, eax
        mov temp.HighPart, edx
        cpuid
        rdtsc
        mov temp2.LowPart, eax
        mov temp2.HighPart, edx
    }

    ref->QuadPart = temp2.QuadPart - temp.QuadPart;
#else
    ref->QuadPart = 0;
#endif
}




BOOL
TestOpeningStuff(PCWSTR wsSourceName, PCWSTR wsType, PCWSTR wsCount)
{
    BOOL fSuccess = FALSE;
    LARGE_INTEGER llStartCount, llEndCount, llCountsPerSec, llTotalSizeSoFar;
    LARGE_INTEGER CpuIdLag;
    BYTE bBuffer[65536];
    SIZE_T cNumTries = _wtol(wsCount);
    double dCountsPerSecond, dSeconds, dCountsPerIteration, dSecondsPerIteration;
    int iFinalIterationsPerSecond;

    GetCpuIdLag(&CpuIdLag);

    llTotalSizeSoFar.QuadPart = 0;

    {
        FUSION_PERF_INFO PerfInfo[2];
        HANDLE hFile;

        for (int i = 0; i < 5000; i++)
        {
            PERFINFOTIME(&PerfInfo[0], hFile = ::CreateFileW(wsSourceName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL));
            PERFINFOTIME(&PerfInfo[1], ::CloseHandle(hFile));
        }

        FusionpReportPerfInfo(
            FUSIONPERF_DUMP_TO_STDOUT |
            FUSIONPERF_DUMP_ALL_STATISTICS |
            FUSIONPERF_DUMP_ALL_SOURCEINFO,
            PerfInfo,
            NUMBER_OF(PerfInfo));
    }



    //
    // Map the DLL as a resource a few thousand times.
    //
    if ((wsType[0] == L'd') || (wsType[0] == L's'))
    {
        FUSION_PERF_INFO PerfInfo[7];

        HMODULE     hDllModule;
        HRSRC       hManifestResource;
        HGLOBAL     hResource;
        PVOID       pvResourceData;
        SIZE_T      cbResourceSize;

        for (SIZE_T i = 0; i < cNumTries; i++)
        {
            PERFINFOTIME(&PerfInfo[0], hDllModule = ::LoadLibraryExW(wsSourceName, NULL, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE));
            PERFINFOTIME(&PerfInfo[1], hManifestResource = ::FindResourceW(hDllModule, L"#1", MAKEINTRESOURCEW(RT_MANIFEST)));
            PERFINFOTIME(&PerfInfo[2], hResource = ::LoadResource(hDllModule, hManifestResource));
            PERFINFOTIME(&PerfInfo[3], pvResourceData = ::LockResource(hResource));
            PERFINFOTIME(&PerfInfo[4], cbResourceSize = ::SizeofResource(hDllModule, hManifestResource));

            PERFINFOTIME(&PerfInfo[5],
                { for (SIZE_T i2 = 0; i2 < cbResourceSize; i2++)
                bBuffer[i2] = ((PBYTE)pvResourceData)[i2]; }
                );

            PERFINFOTIME(&PerfInfo[6], FreeLibrary(hDllModule))
        }

        FusionpReportPerfInfo(
            FUSIONPERF_DUMP_TO_STDOUT |
            FUSIONPERF_DUMP_ALL_STATISTICS |
            FUSIONPERF_DUMP_ALL_SOURCEINFO,
            PerfInfo,
            NUMBER_OF(PerfInfo));
    }
    else if (wsType[0] == L'x')
    {
        HANDLE  hFile;
        HANDLE  hFileMapping;
        PVOID   pvFileData;
        SIZE_T  cbFileSize;

        FUSION_PERF_INFO PerfInfo[9];

        for (SIZE_T i = 0; i < cNumTries; i++)
        {
            PERFINFOTIME(&PerfInfo[0], hFile = ::CreateFileW(wsSourceName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL));
            PERFINFOTIME(&PerfInfo[1], cbFileSize = ::GetFileSize(hFile, 0));
            PERFINFOTIME(&PerfInfo[2], hFileMapping = ::CreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL));
            PERFINFOTIME(&PerfInfo[3], pvFileData = ::MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0));

            PERFINFOTIME(&PerfInfo[4], { for (SIZE_T i2 = 0; i2 < cbFileSize; i2++)
                PERFINFOTIME(&PerfInfo[8], bBuffer[i2] = ((PBYTE)pvFileData)[i2]); });

            PERFINFOTIME(&PerfInfo[5], ::UnmapViewOfFile(pvFileData));
            PERFINFOTIME(&PerfInfo[6], ::CloseHandle(hFileMapping));
            PERFINFOTIME(&PerfInfo[7], ::CloseHandle(hFile));
        }

        FusionpReportPerfInfo(
            FUSIONPERF_DUMP_TO_STDOUT |
            FUSIONPERF_DUMP_ALL_STATISTICS |
            FUSIONPERF_DUMP_ALL_SOURCEINFO,
            PerfInfo,
            NUMBER_OF(PerfInfo));
    }
    else if (wsType[0] == L'r')
    {
        BYTE bTempBlock[8192];
        ULONG cbReadCount;
        FUSION_PERF_INFO PerfInfo[3];

        for (SIZE_T i = 0; i < cNumTries; i++)
        {
            CResourceStream RStream;

            QueryPerformanceCounter(&llStartCount);

            PERFINFOTIME(&PerfInfo[0], RStream.Initialize(wsSourceName, MAKEINTRESOURCEW(RT_MANIFEST)));
            PERFINFOTIME(&PerfInfo[1], RStream.Read(bTempBlock, sizeof(bTempBlock), &cbReadCount));

            PERFINFOTIME(&PerfInfo[2],
                for (SIZE_T i2 = 0; i2 < cbReadCount; i2++)
                {
                    bBuffer[i2] = bTempBlock[i2];
                }
                );

            wprintf(L"%s", bBuffer);

            QueryPerformanceCounter(&llEndCount);
            llTotalSizeSoFar.QuadPart += llEndCount.QuadPart - llStartCount.QuadPart;
        }

        for (int i = 0; i < NUMBER_OF(PerfInfo); i++)
        {
            FusionpDumpPerfInfo(FUSIONPERF_DUMP_TO_STDOUT, PerfInfo + i);
        }
    }
    else if (wsType[0] == L'f')
    {
        BYTE bTempBlock[8192];
        ULONG cbReadCount;

        for (SIZE_T i = 0; i < cNumTries; i++)
        {
            CFileStream RStream;

            QueryPerformanceCounter(&llStartCount);

            RStream.OpenForRead(
                wsSourceName,
                CImpersonationData(),
                FILE_SHARE_READ,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN);

            RStream.Read(bTempBlock, sizeof(bTempBlock), &cbReadCount);

            for (SIZE_T i2 = 0; i2 < cbReadCount; i2++)
            {
                bBuffer[i2] = bTempBlock[i2];
            }

            QueryPerformanceCounter(&llEndCount);
            llTotalSizeSoFar.QuadPart += llEndCount.QuadPart - llStartCount.QuadPart;
        }
    }

    QueryPerformanceFrequency(&llCountsPerSec);

    dCountsPerIteration = (double)llTotalSizeSoFar.QuadPart / cNumTries;
    dCountsPerSecond = (double)llCountsPerSec.QuadPart;
    dSeconds = (double)llTotalSizeSoFar.QuadPart / dCountsPerSecond;
    dSecondsPerIteration = dCountsPerIteration / dCountsPerSecond;

    iFinalIterationsPerSecond = static_cast<int>(1.0 / dSecondsPerIteration);

    fwprintf(
        stdout,
        L"Completed %d runs: %d attempts per second available\n",
        cNumTries,
        iFinalIterationsPerSecond);

    fSuccess = TRUE;

    return fSuccess;
}


BOOL
TestVerifyFileSignature(PCWSTR wsFilename)
{
    WINTRUST_FILE_INFO  fInfo;
    WINTRUST_DATA       wtData;
    GUID                guidTrustType = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    HRESULT             hResult = E_FAIL;
    PWSTR               pwszMessageText = NULL;

    ZeroMemory(&wtData, sizeof(wtData));
    ZeroMemory(&fInfo, sizeof(fInfo));

    fInfo.cbStruct = sizeof(fInfo);
    fInfo.pcwszFilePath = wsFilename;
    fInfo.hFile = NULL;

    wtData.cbStruct = sizeof(wtData);
    wtData.dwUIChoice = WTD_UI_ALL;
    wtData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
    wtData.dwUnionChoice = WTD_CHOICE_FILE;
    wtData.pFile = &fInfo;

    hResult = WinVerifyTrust(0, &guidTrustType, &wtData);

    if (FAILED(hResult))
    {
        ::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            hResult,
            0,
            (PWSTR)&pwszMessageText,
            500,
            NULL);

        fwprintf(stdout, L"Error: %ls (code 0x%08x)\n", pwszMessageText, hResult);
        LocalFree(pwszMessageText);
    }
    else
    {
        fwprintf(stdout, L"File signature(s) are valid.");
    }

    return TRUE;
}

__inline
ULONGLONG
GetCycleCount(void)
{
#if defined(_X86_)
    __asm {
        RDTSC
    }
#else
    return 0;
#endif // defined(_X86_)
}

BOOL TestMessagePerf(int argc, wchar_t **argv, int *piNext)
{
    ATOM a;
    WNDCLASSEXW wc;
    ULONGLONG cc1, cc2, cc3, cc4;
    ULONG i, t;
    HWND hwnd;
    MSG m;
    ULONG mcount;
    HANDLE hActCtx = NULL;
    ULONG_PTR ulCookie;

    wc.cbSize = sizeof(wc);
    wc.style = 0;
    wc.lpfnWndProc = &TestMessagePerfWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = NULL;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = L"SxsMsgPerfTest";
    wc.hIconSm = NULL;

    printf("Beginning message perf test...\n");

    a = ::RegisterClassExW(&wc);
    if (a == NULL)
    {
        printf("RegisterClassExW() failed; ::GetLastError = %d\n", ::GetLastError());
        return FALSE;
    }

    if (argv[*piNext][0] != L'*')
    {
        ACTCTXW ac;

        ac.cbSize = sizeof(ac);
        ac.dwFlags = 0;
        ac.lpSource = argv[*piNext];
        hActCtx = ::CreateActCtxW(&ac);
        if (hActCtx == INVALID_HANDLE_VALUE)
        {
            printf("CreateActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
            goto ErrorExit;
        }
    }

    if (!ActivateActCtx(hActCtx, &ulCookie))
    {
        printf("ActivateActCtx() failed; ::GetLastError() = %d\n", ::GetLastError());
        goto ErrorExit;
    }

    (*piNext)++;

    hwnd = ::CreateWindowW(
        (LPCWSTR) a,
        L"PerfTestWindow",
        WS_VISIBLE,
        0, // x
        0, // y
        100, // width
        100, // height
        NULL, // hwndParent
        NULL, // hMenu
        NULL, // hInstance
        NULL); // lpParam
    if (hwnd == NULL)
        return FALSE;

    t = _wtoi(argv[*piNext]);
    (*piNext)++;

    mcount = 0;
    cc3 = 0;
    cc4 = 0;

    for (i=0; i<t; i++)
    {
        if (!PostMessageW(hwnd, WM_USER, 0, 0))
        {
            printf("PostMessageW() failed; ::GetLastError() = %d\n", ::GetLastError());
            goto ErrorExit;
        }

        cc1 = GetCycleCount();

        while (::PeekMessage(&m, hwnd, 0, 0, PM_REMOVE))
        {
            mcount++;
            ::TranslateMessage(&m);
            ::DispatchMessage(&m);
        }

        cc2 = GetCycleCount();

        // accumulate the time spend just processing the message...
        cc3 = cc3 + (cc2 - cc1);
    }

    printf("%lu messages in %I64u cycles\n", mcount, cc3);
    printf("   avg cycles/msg: %I64u\n", static_cast<ULONGLONG>((cc3 / static_cast<ULONGLONG>(mcount))));

    return TRUE;

ErrorExit:
    return FALSE;
}

LRESULT CALLBACK TestMessagePerfWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void
TestTrickyMultipleAssemblyCacheItems(PCWSTR pvManifest)
{
    PFNCreateAssemblyCacheItem      pCreateAssemblyCacheItem;
    PFNCreateAssemblyCache          pCreateAssemblyCache;
    CSmartRef<IAssemblyCache>       AssemblyCache;
    CSmartRef<IAssemblyCacheItem>   AssemblyCacheItems[2];
    CStringBuffer                   sbManifestName;
    HRESULT                         hr;

    LoadSxs();
    GetSxsProc("CreateAssemblyCache", &pCreateAssemblyCache);
    GetSxsProc("CreateAssemblyCacheItem", &pCreateAssemblyCacheItem);

    sbManifestName.Win32Assign(pvManifest, wcslen(pvManifest));

    for (int i = 0; i < 2; i++)
    {
        CSmartRef<IStream> pStream;
        CSmartRef<IAssemblyCacheItem> AssemblyItemTemp;
        CStringBuffer TempStreamName;

        hr = pCreateAssemblyCacheItem(
            &AssemblyItemTemp,
            NULL,
            NULL,
            NULL,
            0,
            0);

        //
        // Manifest
        //
        hr = AssemblyItemTemp->CreateStream(0, pvManifest, STREAM_FORMAT_WIN32_MANIFEST, 0, &pStream, NULL);
        TempStreamName.Win32Assign(sbManifestName);
        hr = Helper_WriteStream(&TempStreamName, pStream);
        pStream.Release();

        //
        // Dll
        //
        sbManifestName.Win32ChangePathExtension(L".dll", 4, eAddIfNoExtension);
        hr = AssemblyItemTemp->CreateStream(0, static_cast<PCWSTR>(TempStreamName), STREAM_FORMAT_WIN32_MODULE, 0, &pStream, NULL);
        hr = Helper_WriteStream(&TempStreamName, pStream);
        pStream.Release();

        hr = AssemblyItemTemp->Commit(0, NULL);
        AssemblyCacheItems[i] = AssemblyItemTemp;
    }
    /*
    hr = pCreateAssemblyCache(&AssemblyCache, 0);
    hr = AssemblyCache->MarkAssembliesVisible((IUnknown**)AssemblyCacheItems, 2, 0);
    */
}


void
TestSfcScanKickoff()
{
    SXSP_DEBUG_FUNCTION pfn;
    BOOL fSuccess = FALSE;

    LoadSxs();
    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_SFC_SCANNER, 0, NULL, NULL);
}


void
GenerateStrongNameAndPublicKey(PCWSTR wsCertificate)
{
    BOOL                    bSuccess = FALSE;

    CStringBuffer           sbStrings[3];
    PCCERT_CONTEXT          pContext = NULL;
    SXSP_DEBUG_FUNCTION     pfn;
    HCERTSTORE              hCertStore = NULL;

    hCertStore = CertOpenStore(
        CERT_STORE_PROV_FILENAME,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        NULL,
        CERT_STORE_OPEN_EXISTING_FLAG,
        (void*)wsCertificate);

    LoadSxs();
    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    while (pContext = CertEnumCertificatesInStore(hCertStore, pContext))
    {
        bSuccess = (*pfn)(SXS_DEBUG_GET_STRONGNAME, 0, (PCWSTR)pContext, (PVOID)sbStrings);

        wprintf(L"Signer display name: %ls\n\tPublic Key: %ls\n\tPublic Key Token: %ls\n",
            static_cast<PCWSTR>(sbStrings[0]),
            static_cast<PCWSTR>(sbStrings[1]),
            static_cast<PCWSTR>(sbStrings[2]));

    }

    bSuccess = TRUE;

    if (pContext)     CertFreeCertificateContext(pContext);
    if (hCertStore)   CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
}

BOOL CALLBACK
DumpResourceWorker(
    HMODULE hModule,
    PCWSTR lpszType,
    PWSTR lpszName,
    LONG_PTR lParam
    )
{
    HGLOBAL hGlobal;
    HRSRC hResource;
    PVOID pvData;
    SIZE_T cbResource;

    hResource = ::FindResourceW(hModule, lpszName, lpszType);
    hGlobal = ::LoadResource(hModule, hResource);
    pvData = ::LockResource(hGlobal);

    if (lpszName < (PCWSTR)0xFFFF)
    {
        wprintf(L"----\nResource id: %p\n", lpszName);
    }
    else
    {
        wprintf(L"----\nResource name: %ls\n", lpszName);
    }

    cbResource = ::SizeofResource(hModule, hResource);

    for (SIZE_T i = 0; i < cbResource; i++)
    {
        wprintf(L"%c", ((char*)pvData)[i]);
    }
    wprintf(L"\n");


    return TRUE;
}

BOOL
TestDumpContainedManifests(PCWSTR wsFilename)
{
    HMODULE hThing;

    hThing = ::LoadLibraryExW(wsFilename, NULL, LOAD_LIBRARY_AS_DATAFILE);

    if ((hThing == NULL) || (hThing == INVALID_HANDLE_VALUE))
    {
        wprintf(L"Bad mojo: can't open %ls for enumeration.\n", wsFilename);
        return FALSE;
    }

    if (!::EnumResourceNamesW(hThing, MAKEINTRESOURCEW(RT_MANIFEST), DumpResourceWorker, NULL))
    {
        if (GetLastError() == ERROR_RESOURCE_TYPE_NOT_FOUND)
        {
            wprintf(L"No manifests found in %ls\n", wsFilename);
        }
        else
        {
            wprintf(L"Bad mojo: can't enumerate resources from %ls, error=0x%08x\n",
                wsFilename,
                ::GetLastError());
        }
    }
    ::FreeLibrary(hThing);

    return TRUE;
}

BOOL TestGenerateStringWithIdenticalHash(WCHAR iString[33])
{
#define START_VALUE         1
#define STR_LEN             32
#define HASH_SEED           65599
#define MAGIC_ARRAY         {1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1,-1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, 1} ;

#define UPPER(ch)     if (ch >=L'a' && ch <= L'z') ch = ch- L'a' + L'A';

    WCHAR oString[STR_LEN + 1];
    DWORD i, nLen, a[STR_LEN];
    ULONG hash1, hash2;
    WCHAR ch;

    a[0] = a[1] = START_VALUE;
    nLen = 2;
    while(nLen < STR_LEN) {
            for(i = nLen; i < nLen*2; i++)
                    a[i] = static_cast<ULONG>(-static_cast<LONG>(a[i-nLen]));
            nLen *= 2;
    }

    oString[32] = iString[32] = L'\0';

    // generate the new string
    for (i = 0; i< 32; i++)
        oString[i] = static_cast<WCHAR>(iString[i] + a[i]);

    // verify that these two string have the same hash
    hash1 = 0 ;
    for (i = 0 ; i<STR_LEN; i++) {
        ch = iString[i];
        UPPER(ch);
        hash1 = hash1*HASH_SEED + ch;
    }

    hash2 = 0 ;
    for (i = 0 ; i<STR_LEN; i++){
        ch = oString[i];
        UPPER(ch);
        hash2 = hash2*HASH_SEED + ch;
    }

    return (hash1 == hash2)? TRUE : FALSE;

#undef START_VALUE
#undef STR_LEN
#undef HASH_SEED
}

BOOL TestAssemblyIdentityHash()
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;
    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_ASSEMBLY_IDENTITY_HASH, 0, 0, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

const static WCHAR Beta2Manifest[] =
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"    <assemblyIdentity type=\"win32\" name=\"cards\" version=\"2.0.0.0\" processorArchitecture=\"X86\" language=\"en-us\" />"
L"    <file name=\"cards.dll\"/>"
L"</assembly>;"
;

// check whether the handle counter of csrss has changed dramatically after running this code.....
VOID TestCreateActctxLeakHandles(DWORD dwCallCounter)
{
    int result = -1;
    BOOL fSuccess;    

    for (DWORD i =0 ; i < dwCallCounter ; i ++)
    {
        HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(InheritManifest);
        if (ActivationContextHandle  == INVALID_HANDLE_VALUE) {
            result = i ;
            break;
        }

        ULONG_PTR Cookie;
        ActivateActCtx(ActivationContextHandle, &Cookie);

        HINSTANCE hInstanceKernel32 = ::GetModuleHandleW(L"KERNEL32.DLL");
        PQUERYACTCTXW_FUNC pQueryActCtxW = (PQUERYACTCTXW_FUNC) ::GetProcAddress(hInstanceKernel32, "QueryActCtxW");

        SIZE_T CbWritten;

        if (pQueryActCtxW != NULL)
        {
            for ( ULONG ulInfoClass = ActivationContextBasicInformation; ulInfoClass <= FileInformationInAssemblyOfAssemblyInActivationContext; ulInfoClass ++)
            {
                switch (ulInfoClass) {
                case ActivationContextBasicInformation :
                    break;

                case ActivationContextDetailedInformation :
                    {
                    struct
                    {
                        ACTIVATION_CONTEXT_DETAILED_INFORMATION acdi;
                        WCHAR Buffer[_MAX_PATH * 3]; // manifest, policy and appdir
                    } Data;
                    ULONG index = 0 ; 
                    fSuccess = (*pQueryActCtxW)(0, ActivationContextHandle, &index, ulInfoClass, &Data, sizeof(Data), &CbWritten);
                    fprintf(stderr, "\ncall QueryActCtxW with ActivationContextDetailedInformation\n" );
                    if (fSuccess)
                    {
                        fprintf(stderr, "1st string: %ls\n", Data.acdi.lpAppDirPath);
                        fprintf(stderr, "2nd string: %ls\n", Data.acdi.lpRootManifestPath);
                    }
                    else
                        fprintf(stderr, "QueryActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());

                    }

                    break;

                case AssemblyDetailedInformationInActivationContext: 
                    {
                    struct
                    {
                        ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION acdi;
                        WCHAR Buffer[_MAX_PATH * 4]; 
                    } Data;
                    ULONG AssemblyIndex = 1; 
                    fSuccess = (*pQueryActCtxW)(0, ActivationContextHandle, &AssemblyIndex, ulInfoClass, &Data, sizeof(Data), &CbWritten);

                    fprintf(stderr, "\ncall QueryActCtxW with AssemblyDetailedInformationInActivationContext\n" );
                    if (fSuccess)
                    {
                        fprintf(stderr, "Encoded assembly Identity: %ls\n", Data.acdi.lpAssemblyEncodedAssemblyIdentity);
                        fprintf(stderr, "manifest path: %ls\n", Data.acdi.lpAssemblyManifestPath);
                        fprintf(stderr, "policy path: %ls\n", Data.acdi.lpAssemblyPolicyPath);
                        fprintf(stderr, "Assembly Directory: %ls\n", Data.acdi.lpAssemblyDirectoryName);
                    }
                    else
                        fprintf(stderr, "QueryActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
                    }
                    break;

                case FileInformationInAssemblyOfAssemblyInActivationContext:
                    {
                    struct
                    {
                        ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION acdi;
                        WCHAR Buffer[_MAX_PATH * 2]; 
                    } Data;
                    ACTIVATION_CONTEXT_QUERY_INDEX index;
                    index.ulAssemblyIndex = 1; 
                    index.ulFileIndexInAssembly = 0; 

                    fSuccess = (*pQueryActCtxW)(0, ActivationContextHandle, &index, ulInfoClass, &Data, sizeof(Data), &CbWritten);

                    fprintf(stderr, "\ncall QueryActCtxW with FileInformationInAssemblyOfAssemblyInActivationContext\n" );
                    if (fSuccess)
                    {
                        fprintf(stderr, "file name: %ls\n", Data.acdi.lpFileName);
                        fprintf(stderr, "file path: %ls\n", Data.acdi.lpFilePath);
                    }
                    else
                        fprintf(stderr, "QueryActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
                    }
                } // end of switch

            }// end of for
        }

        DeactivateActCtx(0, Cookie);
        // CloseHandle(ActivationContextHandle);
    }
    return;
}

BOOL TestSystemDefaultActivationContextGeneration()
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_SYSTEM_DEFAULT_ACTCTX_GENERATION, 0, NULL, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

CHAR g_AsyncIOBuffer[16384];

struct AsyncIOBlock
{
    OVERLAPPED ol_input;
    OVERLAPPED ol_output;
    HANDLE hInputFile;
    HANDLE hOutputFile;
} g_AsyncIOBlock;

bool g_AsyncIODone = false;
DWORD g_AsyncIOError = ERROR_SUCCESS;

VOID CALLBACK AsyncReadCompleted(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED ol
    );

VOID CALLBACK AsyncWriteCompleted(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED ol
    );

VOID CALLBACK AsyncReadCompleted(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED ol
    )
{
    if (dwErrorCode != ERROR_SUCCESS)
    {
        fprintf(stderr, "Error passed to AsyncReadCompleted(); error code = %ul; bytes transferred = %ul\n", dwErrorCode, dwBytesTransferred);
        g_AsyncIOError = dwErrorCode;
        g_AsyncIODone = true;
    }
    else
    {
        g_AsyncIOBlock.ol_input.Offset += dwBytesTransferred;
        if (!::WriteFileEx(g_AsyncIOBlock.hOutputFile, g_AsyncIOBuffer, dwBytesTransferred, &g_AsyncIOBlock.ol_output, &AsyncWriteCompleted))
        {
            g_AsyncIOError = ::GetLastError();
            fprintf(stderr, "WriteFileEx() failed; ::GetLastError() = %d\n", g_AsyncIOError);
            g_AsyncIODone = true;
        }
    }
}

VOID CALLBACK AsyncWriteCompleted(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED ol
    )
{
    if (dwErrorCode != ERROR_SUCCESS)
    {
        fprintf(stderr, "Error passed to AsyncWriteCompleted(); error code = %ul; dwBytesTransferred = %ul\n", dwErrorCode, dwBytesTransferred);
        g_AsyncIOError = dwErrorCode;
        g_AsyncIODone = true;
    }
    else
    {
        g_AsyncIOBlock.ol_output.Offset += dwBytesTransferred;
        if (!::ReadFileEx(g_AsyncIOBlock.hInputFile, g_AsyncIOBuffer, sizeof(g_AsyncIOBuffer), &g_AsyncIOBlock.ol_input, &AsyncReadCompleted))
        {
            g_AsyncIOError = ::GetLastError();
            if (g_AsyncIOError != ERROR_HANDLE_EOF)
                fprintf(stderr, "ReadFileEx() failed; ::GetLastError() = %d\n", g_AsyncIOError);
            else
                g_AsyncIOError = ERROR_SUCCESS;
            g_AsyncIODone = true;
        }
    }
}

BOOL
TestAsyncIO(int argc, wchar_t **argv, int *piNext)
{
    HANDLE hFileIn;
    HANDLE hFileOut;
    HANDLE hActCtx = NULL;
    ULONG_PTR cookie = 0;
    PCWSTR pszManifest;
    PCWSTR pszInputFile;
    PCWSTR pszOutputFile;
    ACTCTXW acw;

    pszManifest = argv[(*piNext)++];
    pszInputFile = argv[(*piNext)++];
    pszOutputFile = argv[(*piNext)++];

    if (wcscmp(pszManifest, L"-") != 0)
    {
        acw.cbSize = sizeof(acw);
        acw.dwFlags = 0;
        acw.lpSource = pszManifest;

        hActCtx = ::CreateActCtxW(&acw);
        if (hActCtx == INVALID_HANDLE_VALUE)
        {
            fprintf(stderr, "CreateActCtxW() on %ls failed; ::GetLastError() = %d\n", pszManifest, ::GetLastError());
            return EXIT_FAILURE;
        }
    }

    hFileIn = ::CreateFileW(pszInputFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFileIn == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "CreateFileW() on %ls failed; ::GetLastError() = %d\n", pszInputFile, ::GetLastError());
        return EXIT_FAILURE;
    }

    hFileOut = ::CreateFileW(pszOutputFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL);
    if (hFileOut == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "CreateFileW() on %ls failed; ::GetLastError() = %d\n", pszOutputFile, ::GetLastError());
        return EXIT_FAILURE;
    }

    ActivateActCtx(hActCtx, &cookie);

    g_AsyncIOBlock.ol_input.Offset = 0;
    g_AsyncIOBlock.ol_input.OffsetHigh = 0;
    g_AsyncIOBlock.ol_output.Offset = 0;
    g_AsyncIOBlock.ol_output.OffsetHigh = 0;
    g_AsyncIOBlock.hInputFile = hFileIn;
    g_AsyncIOBlock.hOutputFile = hFileOut;

    if (!::ReadFileEx(hFileIn, &g_AsyncIOBuffer, sizeof(g_AsyncIOBuffer), &g_AsyncIOBlock.ol_input, &AsyncReadCompleted))
    {
        fprintf(stderr, "First ReadFileEx() failed; ::GetLastError() = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    while (!g_AsyncIODone)
    {
        ::SleepEx(1000, TRUE);
    }

    if (g_AsyncIOError != ERROR_SUCCESS)
    {
        fprintf(stderr, "Async IO test failed; win32 error code = %d\n", g_AsyncIOError);
        return EXIT_FAILURE;
    }

    CloseHandle(hFileIn);
    CloseHandle(hFileOut);

    return EXIT_SUCCESS;
}

static
DWORD
WINAPI
TestThreadInheritLeakThreadProc(
    LPVOID lpParameter
    )
{
    // Don't need to do anything...
    return 1;
}

int
TestThreadInheritLeak()
{
    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(InheritManifest);
    DWORD dwThreadId;
    ULONG_PTR ulpCookie;
    HANDLE hThread = NULL;

    ::ActivateActCtx(ActivationContextHandle, &ulpCookie);
    hThread = ::CreateThread(NULL, 0, &TestThreadInheritLeakThreadProc, NULL, 0, &dwThreadId);

    if (hThread == NULL)
    {
        fprintf(stderr, "CreateThread() failed with ::GetLastError = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    WaitForSingleObject(hThread, INFINITE);

    fprintf(stderr, "Created thread %lu\n", dwThreadId);
    ::DeactivateActCtx(0, ulpCookie);
    ::ReleaseActCtx(ActivationContextHandle);

    return EXIT_SUCCESS;
}

BOOL
TestNewCatalogSignerThingy(
    PCWSTR CatalogName
    )
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;

    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_CATALOG_SIGNER_CHECK, 0, CatalogName, NULL);

    return fSuccess;
}

HMODULE MyHandle;
WCHAR MyModuleFullPath[MAX_PATH];
WCHAR MyModuleFullPathWithoutExtension[MAX_PATH];

/*
see \\scratch\scratch\JayK\exedll for a slightly different approach
*/
HANDLE GetExeHandle()
{
    return GetModuleHandle(NULL);
}

extern "C" { extern IMAGE_DOS_HEADER __ImageBase; }

HMODULE GetMyHandle()
{
    //Trace("GetMyHandle():%p\n", &__ImageBase);
    return (HMODULE)&__ImageBase;
}

BOOL AmITheExe()
{
    IamExe = (GetExeHandle() == GetMyHandle());
    IamDll = !IamExe;
    return IamExe;
}

PCWSTR GetMyModuleFullPath()
{
    return
        ((MyModuleFullPath[0]
        || ::GetModuleFileNameW(GetMyHandle(), MyModuleFullPath, RTL_NUMBER_OF(MyModuleFullPath))),
        MyModuleFullPath);
}

PCWSTR GetMyModuleFullPathWithoutExtension()
{
    //
    // not thread safe
    //
    wcscpy(MyModuleFullPathWithoutExtension, GetMyModuleFullPath());
    *wcsrchr(MyModuleFullPathWithoutExtension, '.') = 0;
    return MyModuleFullPathWithoutExtension;
}

void TestExeDll()
{
#if defined(_X86_)
    WCHAR x[MAX_PATH];
    CStringBuffer y;

    Kernel32.GetModuleFileNameW(NULL, x, RTL_NUMBER_OF(x));
    if (!y.Win32Assign(x, StringLength(x)))
        ThrowLastError();

    if (!y.Win32ChangePathExtension(L"dll", 3, eAddIfNoExtension))
        ThrowLastError();

    if (!CopyFileW(x, y, FALSE))
        ThrowLastError();

    SetDllBitInPeImage(y);

    FreeLibrary(LoadLibraryW(y));
#endif
}

void PrintDll()
{
    //Trace("dll %ls\n", GetMyModuleFullPath());
}

void PrintExe()
{
    //Trace("exe %ls\n", GetMyModuleFullPath());
}

extern "C" void __cdecl wmainCRTStartup();
extern "C" BOOL __stdcall _DllMainCRTStartup(HINSTANCE, DWORD, PVOID);

extern "C" BOOL __stdcall DllMain(HINSTANCE DllHandle, DWORD Reason, PVOID SemiReserved)
{
    //Trace("Enter DllMain\n");
    switch (Reason)
    {
    default:
        break;
    case DLL_PROCESS_ATTACH:
        if (
               wcsstr(GetCommandLineW(), L" -tQueryActCtx")
            || wcsstr(GetCommandLineW(), L" -tqueryactctx")
            || wcsstr(GetCommandLineW(), L" /tQueryActCtx")
            || wcsstr(GetCommandLineW(), L" /tqueryactctx")
            )
        {
            TestQueryActCtx();
        }
    }
    //Trace("Exit DllMain\n");
    return TRUE;
}

#if defined(_X86_)

extern "C" void __declspec(naked) Entry()
// This works for .dlls or .exes.
// void ExeMain(void)
// BOOL __stdcall DllMain(HINSTANCE dll, DWORD reason, void* reserved)
{
    static const char* DllReason[] =
    {
        "DllProcessDetach %ls\n",
        "DllProcessAttach %ls\n",
        "DllThreadAttach  %ls\n",
        "DllThreadDetach  %ls\n"
    };
    __asm {
    //int 3
    call AmITheExe
    test eax,eax
    jne  Lexe
//Ldll:
    call GetMyModuleFullPath
    push eax
    mov eax, [esp+12]
    mov eax, DllReason[eax*4]
    push eax
    call Trace
    add esp,8
    jmp _DllMainCRTStartup
Lexe:
    call PrintExe
    jmp  wmainCRTStartup
}
}

#else

extern "C" void Entry()
{
    wmainCRTStartup();
}

#endif


BOOL TestSxsSfcUI()
{
    SXSP_DEBUG_FUNCTION pfn = NULL;
    BOOL fSuccess = FALSE;
    LoadSxs();

    GetSxsProc(SXSP_DEBUG_ORDINAL, &pfn);

    fSuccess = (*pfn)(SXS_DEBUG_SFC_UI_TEST, 0, 0, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;

    return fSuccess;
}

void TestGetModuleHandleEx()
{
    HMODULE p;
    BOOL  f;
    HMODULE q;
    unsigned u;
#define GetModuleHandleExA pfnGetModuleHandleExA
#define GetModuleHandleExW pfnGetModuleHandleExW
    HMODULE kernel32 = GetModuleHandleW(L"Kernel32");
    PGET_MODULE_HANDLE_EXA GetModuleHandleExA = reinterpret_cast<PGET_MODULE_HANDLE_EXA>(GetProcAddress(kernel32, "GetModuleHandleExA"));
    PGET_MODULE_HANDLE_EXW GetModuleHandleExW = reinterpret_cast<PGET_MODULE_HANDLE_EXW>(GetProcAddress(kernel32, "GetModuleHandleExW"));

    if (GetModuleHandleExA == NULL || GetModuleHandleExW == NULL)
    {
        return;
    }

    union
    {
         CHAR BufferA[MAX_PATH];
        WCHAR BufferW[MAX_PATH];
    };
    BufferA[0] = 0;
    GetWindowsDirectoryA(BufferA, MAX_PATH);
    std::string windowsA = BufferA;
    std::string systemA = windowsA + "System32";

    BufferW[0] = 0;
    GetWindowsDirectoryW(BufferW, MAX_PATH);
    std::wstring windowsW = BufferW;
    std::wstring systemW = windowsW + L"System32";

#define PIN GET_MODULE_HANDLE_EX_FLAG_PIN
#define NOCHANGE GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
#define ADDRESS GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS

#define X(x) SetLastError(NO_ERROR); p = x; printf("%s:%p,%d\n", #x, p, ::GetLastError());
#define Y(x) SetLastError(NO_ERROR); f = x; printf("%s:%s,%p,%d\n", #x, "false\0true"+f*6, p, ::GetLastError());
    printf("first some basic GetModuleHandle testing\n\n");
    X(GetModuleHandleA(NULL));
    X(GetModuleHandleW(NULL));
    X(GetModuleHandleA("ntdll.dll"));
    X(GetModuleHandleW(L"ntdll.dll"));
    X(GetModuleHandleA("ntdll"));
    X(GetModuleHandleW(L"ntdll"));
    X(GetModuleHandleA("c:\\ntdll"));
    X(GetModuleHandleW(L"c:\\ntdll"));
    X(GetModuleHandleA((systemA + "\\ntdll").c_str()));
    X(GetModuleHandleW((systemW + L"\\ntdll").c_str()));
    X(GetModuleHandleA((systemA + "\\ntdll.dll").c_str()));
    X(GetModuleHandleW((systemW + L"\\ntdll.dll").c_str()));
    X(GetModuleHandleA("sxs"));
    X(GetModuleHandleW(L"sxs.dll"));

    printf("\n\nnow show that FreeLibrary \"works\", GetModuleHandle honors it\n\n");
    X(LoadLibraryA("Sxs.dll"));
    X(GetModuleHandleA("sxs"));
    X(GetModuleHandleW(L"sxs.dll"));
    Y(FreeLibrary(p = GetModuleHandleA("Sxs.dll")));
    X(GetModuleHandleA("sxs"));
    X(GetModuleHandleW(L"sxs.dll"));
    X(LoadLibraryW(L"Sxs.dll"));
    Y(GetModuleHandleExA(0, NULL, &p));
    Y(GetModuleHandleExW(0, NULL, &p));

    printf("\n\nsome invalid parameters (%d)\n\n", ERROR_INVALID_PARAMETER);

    Y(GetModuleHandleExA(PIN | NOCHANGE, "sxs", &p));
    Y(GetModuleHandleExW(PIN | NOCHANGE, L"sxs", &p));
    Y(GetModuleHandleExA(PIN | NOCHANGE, "ntdll", &p));
    Y(GetModuleHandleExW(PIN | NOCHANGE, L"ntdll", &p));

    printf("\n\nshow NOCHANGE's equiv to regular\n\n");

    Y(GetModuleHandleExA(NOCHANGE, "sxs", &p));
    Y(GetModuleHandleExW(NOCHANGE, L"sxs", &p));
    Y(FreeLibrary(p = GetModuleHandleA("Sxs.dll")));
    Y(GetModuleHandleExA(NOCHANGE, "sxs", &p));
    Y(GetModuleHandleExW(NOCHANGE, L"sxs", &p));

    printf("\n\nshow PIN works\n\n");

    X(LoadLibraryW(L"Sxs.dll"));
    Y(GetModuleHandleExA(PIN, "sxs", &p));
    Y(FreeLibrary(p = GetModuleHandleA("Sxs.dll")));
    Y(GetModuleHandleExW(0, L"sxs", &(q = p)));
    Y(GetModuleHandleExW(0, L"c:\\sxs", &p));

    printf("\n\nshow the VirtualQuery form\n\n");

    Y(GetModuleHandleExA(ADDRESS, "sxs", &p)); // string, actually in .exe
    Y(GetModuleHandleExW(ADDRESS, L"c:\\sxs", &p));

    Y(GetModuleHandleExA(ADDRESS, reinterpret_cast<LPCSTR>(q), &p));
    Y(GetModuleHandleExW(ADDRESS, reinterpret_cast<LPCWSTR>(q), &p));

    printf("\n\nsome more invalid parameters (%d)\n\n", ERROR_INVALID_PARAMETER);

    Y(GetModuleHandleExA(0, NULL, NULL));
    Y(GetModuleHandleExW(0, NULL, NULL));

    printf("\n\nshow that static loads can't be unloaded\n\n");
    for (u = 0 ; u < 4 ; ++u)
    {
        printf("%#x\n", u);
        Y(FreeLibrary(p = GetModuleHandleA("kernel32")));
        Y(FreeLibrary(p = GetModuleHandleW(L"sxstest.exe")));
        Y(FreeLibrary(p = GetModuleHandleA("msvcrt.dll")));
    }

    printf("\n\ntry all flag combinations, including invalids ones\n\n");
    for (u = 0 ; u <= (PIN | ADDRESS | NOCHANGE) ; ++u)
    {
        printf("%#x\n", u);
        p = NULL;
        Y(  GetModuleHandleExA(u, NULL, NULL)); p = NULL;
        Y(  GetModuleHandleExW(u, NULL, NULL)); p = NULL;
        Y(  GetModuleHandleExA(u, NULL, &p)); p = NULL;
        Y(  GetModuleHandleExW(u, NULL, &p)); p = NULL;
        if (u & ADDRESS)
        {
            Y(  GetModuleHandleExA(u, "", NULL)); p = NULL;
            Y(  GetModuleHandleExW(u, reinterpret_cast<LPCWSTR>(GetModuleHandleExA), NULL)); p = NULL;
            Y(  GetModuleHandleExW(u, reinterpret_cast<LPCWSTR>(atexit), NULL)); p = NULL;

            Y(  GetModuleHandleExA(u, "", &p)); p = NULL;
            Y(  GetModuleHandleExW(u, reinterpret_cast<LPCWSTR>(GetModuleHandleExA), &p)); p = NULL;
            Y(  GetModuleHandleExW(u, reinterpret_cast<LPCWSTR>(atexit), &p)); p = NULL;
        }
        else
        {
            Y( GetModuleHandleExA(u, "foo32", NULL)); p = NULL;
            Y( GetModuleHandleExW(u, L"kernel32", NULL)); p = NULL;

            Y( GetModuleHandleExA(u, "foo32", &p)); p = NULL;
            Y( GetModuleHandleExW(u, L"kernel32", &p)); p = NULL;
        }
    }
    printf("\n\ntry all bits of flags, should be mostly invalid (%d)\n\n", ERROR_INVALID_PARAMETER);
    for (u = 0 ; u < RTL_BITS_OF(u) ; ++u)
    {
        printf("%#x\n", u);
        Y(GetModuleHandleExW(1<<u, L"kernel32", &p));
    }

    printf("\n\nPIN | ADDRESS wasn't covered\n\n", ERROR_INVALID_PARAMETER);

    X(GetModuleHandleW(L"shell32"));
    X(q = LoadLibraryA("shell32"));
    Y(FreeLibrary(GetModuleHandleA("shell32")));
    Y(GetModuleHandleExW(PIN | ADDRESS, reinterpret_cast<LPCWSTR>(q), &p));

    X(q = LoadLibraryW(L"shell32"));
    Y(GetModuleHandleExW(PIN | ADDRESS, reinterpret_cast<LPCWSTR>(q) + 100, &p));
    Y(FreeLibrary(q)); Y(FreeLibrary(q)); Y(FreeLibrary(q));
    X(GetModuleHandleW(L"shell32.dll"));
    Y(GetModuleHandleExW(ADDRESS, reinterpret_cast<LPCWSTR>(q) + 1000, &p));

#undef X
#undef Y
#undef PIN
#undef NOCHANGE
#undef ADDRESS
}

void
TestGetFullPathName(
    PCWSTR s
    )
{
    WCHAR FullPath[MAX_PATH * 2];
    PWSTR FilePart = L"";
    DWORD dw;
    DWORD dwError;

    SetLastError(NO_ERROR);
    dw = GetFullPathNameW(s, RTL_NUMBER_OF(FullPath), FullPath, &FilePart);
    dwError = ::GetLastError();
    printf(
        "GetFullPathNameW(%ls):%lu,lastError=%lu,filePart=%ls\n",
        FullPath,
        dw,
        dwError,
        FilePart
        );
}

void
TestCreateFile(
    PCWSTR s
    )
{
    HANDLE handle;
    DWORD dwError;

    SetLastError(NO_ERROR);
    handle = CreateFileW(
        s,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    dwError = ::GetLastError();
    if (handle != INVALID_HANDLE_VALUE)
        CloseHandle(handle);
    printf(
        "CreateFileW(%ls):%p,lastError=%lu\n",
        s,
        handle,
        dwError
        );
}

/*
from base\ntsetup\dll\sxs.c
*/
VOID
SxspGetPathBaseName(
    LPCWSTR Path,
    LPWSTR  Base
    )
{
    LPCWSTR Dot = wcsrchr(Path, '.');
    LPCWSTR Slash = wcsrchr(Path, '\\');
    //
    // beware \foo.txt\bar
    // beware \bar
    // beware bar
    // beware .bar
    // beware \.bar
    //
    *Base = 0;
    if (Slash == NULL)
        Slash = Path;
    else
        Slash += 1;
    if (Dot == NULL || Dot < Slash)
        Dot = Path + StringLength(Path);
    CopyMemory(Base, Slash, (Dot - Slash) * sizeof(*Base));
    Base[Dot - Slash] = 0;
}

VOID
TestGetPathBaseName(
    LPCWSTR Path
    )
{
    WCHAR Base[MAX_PATH];

    SxspGetPathBaseName(Path, Base);
    printf("\"%ls\" -> \"%ls\"\n", Path, Base);

}

void TestVersion()
{
	printf(
        "Windows NT %lu.%lu.%lu\n",
        FusionpGetWindowsNtMajorVersion(),
        FusionpGetWindowsNtMinorVersion(),
        FusionpGetWindowsNtBuildVersion()
        );
}

void TestGetProcessImageFileName()
{
    UNICODE_STRING s;

    FusionpGetProcessImageFileName(&s);
    printf("%wZ\n", &s);
}

BOOL TestErrorInfra1()  { FN_PROLOG_WIN32; IFW32FALSE_ORIGINATE_AND_EXIT(LoadLibraryA("1"));       FN_EPILOG; }
BOOL TestErrorInfra2()  { FN_PROLOG_WIN32; IFW32NULL_EXIT(LoadLibraryA("  2  "));                  FN_EPILOG; }
BOOL TestErrorInfra3()  { FN_PROLOG_WIN32; IFFAILED_CONVERTHR_HRTOWIN32_EXIT_TRACE(E_FAIL | 3);   FN_EPILOG; }
BOOL TestErrorInfra4()  { FN_PROLOG_WIN32; IFCOMFAILED_EXIT(E_FAIL | 4);                          FN_EPILOG; }
BOOL TestErrorInfra5()  { FN_PROLOG_WIN32; IFCOMFAILED_ORIGINATE_AND_EXIT(E_FAIL | 5);            FN_EPILOG; }
BOOL TestErrorInfra6()  { FN_PROLOG_WIN32; IFREGFAILED_EXIT(6);                                   FN_EPILOG; }
BOOL TestErrorInfra7()  { FN_PROLOG_WIN32; IFREGFAILED_ORIGINATE_AND_EXIT(7);                     FN_EPILOG; }

HRESULT TestErrorInfra8()   { FN_PROLOG_HR; IFW32FALSE_ORIGINATE_AND_EXIT(LoadLibraryA("8"));       FN_EPILOG; }
HRESULT TestErrorInfra9()   { FN_PROLOG_HR; IFW32NULL_EXIT(LoadLibraryA("!@#   9  \\"));            FN_EPILOG; }
HRESULT TestErrorInfra10()  { FN_PROLOG_HR; IFFAILED_CONVERTHR_HRTOWIN32_EXIT_TRACE(E_FAIL | 10);  FN_EPILOG; }
HRESULT TestErrorInfra11()  { FN_PROLOG_HR; IFCOMFAILED_EXIT(E_FAIL | 11);                         FN_EPILOG; }
HRESULT TestErrorInfra12()  { FN_PROLOG_HR; IFCOMFAILED_ORIGINATE_AND_EXIT(E_FAIL | 12);           FN_EPILOG; }
HRESULT TestErrorInfra13()  { FN_PROLOG_HR; IFREGFAILED_EXIT(13);                                  FN_EPILOG; }
HRESULT TestErrorInfra14()  { FN_PROLOG_HR; IFREGFAILED_ORIGINATE_AND_EXIT(14);                    FN_EPILOG; }

void TestErrorInfra()
{
#define X(x) DbgPrint("%s\n", #x); x()
    X(TestErrorInfra1);
    X(TestErrorInfra2);
    X(TestErrorInfra3);
    X(TestErrorInfra4);
    X(TestErrorInfra5);
    X(TestErrorInfra7);
    X(TestErrorInfra8);
    X(TestErrorInfra9);
    X(TestErrorInfra10);
    X(TestErrorInfra11);
    X(TestErrorInfra12);
    X(TestErrorInfra13);
    X(TestErrorInfra14);
#undef X
}

void TestQueryActCtx3(
    ULONG Flags,
    HANDLE ActCtxHandle
    )
{
    SIZE_T                                          BytesWrittenOrRequired = 0;
    BYTE                                            QueryBuffer[4][4096];
    ACTIVATION_CONTEXT_QUERY_INDEX                  QueryIndex = { 0 };
    PACTIVATION_CONTEXT_BASIC_INFORMATION           BasicInfo = reinterpret_cast<PACTIVATION_CONTEXT_BASIC_INFORMATION>(&QueryBuffer[0]);
    PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION  DllRedir = reinterpret_cast<PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION>(&QueryBuffer[1]);
    PACTIVATION_CONTEXT_DETAILED_INFORMATION        ContextDetailed = reinterpret_cast<PACTIVATION_CONTEXT_DETAILED_INFORMATION>(&QueryBuffer[2]);
    PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION AssemblyDetailed = reinterpret_cast<PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>(&QueryBuffer[3]);
    CStringBuffer decimalContext;

    RtlZeroMemory(&QueryBuffer, sizeof(QueryBuffer));

    if (IS_SPECIAL_ACTCTX(ActCtxHandle))
        decimalContext.Win32Format(L" (%Id)", reinterpret_cast<LONG_PTR>(ActCtxHandle));

#define QueryFailed(x,n) Trace("%s:%ld:QueryActCtx(%s) failed %lu\n", __FUNCTION__, ULONG(n), x, GetLastError())
    if (!QueryActCtxW(
        Flags,
        ActCtxHandle,
        NULL,
        ActivationContextBasicInformation,
        &QueryBuffer,
        sizeof(QueryBuffer),
        &BytesWrittenOrRequired
        ))
        QueryFailed("ActivationContextBasicInformation", __LINE__ - 1);
    else
    {
        if (IS_SPECIAL_ACTCTX(BasicInfo->hActCtx))
            decimalContext.Win32Format(L" (%Id)", reinterpret_cast<LONG_PTR>(BasicInfo->hActCtx));
        Trace(
            "BytesWrittenOrRequired   : 0x%lx\n"
            "BasicInfo->hActCtx       : %p%ls\n"
            "BasicInfo->Flags         : 0x%lx\n",
            BytesWrittenOrRequired,
            BasicInfo->hActCtx,
            static_cast<PCWSTR>(decimalContext),
            BasicInfo->Flags
            );
    }
    Flags = (Flags & ~QUERY_ACTCTX_FLAG_NO_ADDREF);
    if (!QueryActCtxW(Flags, ActCtxHandle, NULL, ActivationContextDetailedInformation, ContextDetailed, 4096, &BytesWrittenOrRequired))
        QueryFailed("ActivationContextDetailedInformation", __LINE__ - 1);
    else
    {
        Trace(
            "BytesWrittenOrRequired                        : 0x%lx\n"
            "ContextDetailed->dwFlags                      : 0x%lx\n"
            "ContextDetailed->ulFormatVersion              : 0x%lx\n"
            "ContextDetailed->ulAssemblyCount              : 0x%lx\n"
            "ContextDetailed->ulRootManifestPathType       : 0x%lx\n"
            "ContextDetailed->ulRootManifestPathChars      : 0x%lx\n"
            "ContextDetailed->ulRootConfigurationPathType  : 0x%lx\n"
            "ContextDetailed->ulRootConfigurationPathChars : 0x%lx\n"
            "ContextDetailed->ulAppDirPathType             : 0x%lx\n"
            "ContextDetailed->ulAppDirPathChars            : 0x%lx\n"
            "ContextDetailed->lpRootManifestPath           : %ls\n"
            "ContextDetailed->lpRootConfigurationPath      : %ls\n"
            "ContextDetailed->lpAppDirPath                 : %ls\n"
            ,
            BytesWrittenOrRequired,
            ContextDetailed->dwFlags,
            ContextDetailed->ulFormatVersion,
            ContextDetailed->ulAssemblyCount,
            ContextDetailed->ulRootManifestPathType,
            ContextDetailed->ulRootManifestPathChars,
            ContextDetailed->ulRootConfigurationPathType,
            ContextDetailed->ulRootConfigurationPathChars,
            ContextDetailed->ulAppDirPathType,
            ContextDetailed->ulAppDirPathChars,
            ContextDetailed->lpRootManifestPath,
            ContextDetailed->lpRootConfigurationPath,
            ContextDetailed->lpAppDirPath
            );
    }
    {
        ULONG AssemblyIndex = 0;
        ULONG FileInAssemblyIndex = 0;

        //
        // 0 produces ERROR_INTERNAL_ERROR
        //
        for (AssemblyIndex = 0 ; AssemblyIndex <= ContextDetailed->ulAssemblyCount ; AssemblyIndex += 1)
        {
            if (!QueryActCtxW(Flags, ActCtxHandle, &AssemblyIndex, AssemblyDetailedInformationInActivationContext, AssemblyDetailed, 4096, &BytesWrittenOrRequired))
            {
                Trace(
                    "%s(%lu):QueryActCtx(Flags=0x%lx, ActCtxHandle=%p%ls, AssemblyIndex=0x%lx, AssemblyDetailedInformationInActivationContext) LastError=%lu (%ls)\n",
                    __FUNCTION__,
                    __LINE__ - 1,
                    Flags,
                    ActCtxHandle,
                    static_cast<PCWSTR>(decimalContext),
                    AssemblyIndex,
                    ::FusionpGetLastWin32Error(),
                    ::FusionpThreadUnsafeGetLastWin32ErrorMessageW()
                    );
            }
            else
            {
                Trace(
                    "AssemblyIndex                                       : 0x%lx\n"
                    "BytesWrittenOrRequired                              : 0x%lx\n"
                    "AssemblyDetailed->ulFlags                           : 0x%lx\n"
                    "AssemblyDetailed->ulEncodedAssemblyIdentityLength   : 0x%lx\n"
                    "AssemblyDetailed->ulManifestPathType                : 0x%lx\n"
                    "AssemblyDetailed->ulManifestPathLength              : 0x%lx\n"
                    "AssemblyDetailed->liManifestLastWriteTime           : 0x%I64x\n"
                    "AssemblyDetailed->ulPolicyPathType                  : 0x%lx\n"
                    "AssemblyDetailed->ulPolicyPathLength                : 0x%lx\n"
                    "AssemblyDetailed->liPolicyLastWriteTime             : 0x%I64x\n"
                    "AssemblyDetailed->ulMetadataSatelliteRosterIndex    : 0x%lx\n"
                    "AssemblyDetailed->ulManifestVersionMajor            : 0x%lx\n"
                    "AssemblyDetailed->ulManifestVersionMinor            : 0x%lx\n"
                    "AssemblyDetailed->ulPolicyVersionMajor              : 0x%lx\n"
                    "AssemblyDetailed->ulPolicyVersionMinor              : 0x%lx\n"
                    "AssemblyDetailed->ulAssemblyDirectoryNameLength     : 0x%lx\n"
                    "AssemblyDetailed->lpAssemblyEncodedAssemblyIdentity : %ls\n"
                    "AssemblyDetailed->lpAssemblyManifestPath            : %ls\n"
                    "AssemblyDetailed->lpAssemblyPolicyPath              : %ls\n"
                    "AssemblyDetailed->lpAssemblyDirectoryName           : %ls\n"
                    "AssemblyDetailed->ulFileCount                       : 0x%lx\n"
                    ,
                    AssemblyIndex,
                    BytesWrittenOrRequired,
                    AssemblyDetailed->ulFlags,
                    AssemblyDetailed->ulEncodedAssemblyIdentityLength,
                    AssemblyDetailed->ulManifestPathType,
                    AssemblyDetailed->ulManifestPathLength,
                    AssemblyDetailed->liManifestLastWriteTime.QuadPart,
                    AssemblyDetailed->ulPolicyPathType,
                    AssemblyDetailed->ulPolicyPathLength,
                    AssemblyDetailed->liPolicyLastWriteTime.QuadPart,
                    AssemblyDetailed->ulMetadataSatelliteRosterIndex,
                    AssemblyDetailed->ulManifestVersionMajor,
                    AssemblyDetailed->ulManifestVersionMinor,
                    AssemblyDetailed->ulPolicyVersionMajor,
                    AssemblyDetailed->ulPolicyVersionMinor,
                    AssemblyDetailed->ulAssemblyDirectoryNameLength,
                    AssemblyDetailed->lpAssemblyEncodedAssemblyIdentity,
                    AssemblyDetailed->lpAssemblyManifestPath,
                    AssemblyDetailed->lpAssemblyPolicyPath,
                    AssemblyDetailed->lpAssemblyDirectoryName,
                    AssemblyDetailed->ulFileCount
                    );

                QueryIndex.ulAssemblyIndex = AssemblyIndex;
                SetLastError(NO_ERROR);
                if (AssemblyDetailed->ulFileCount == 0)
                {
                    Trace("AssemblyDetailed->ulFileCount is 0, working around bug, setting it to 4.\n");
                    AssemblyDetailed->ulFileCount = 4; // bug workaround
                }
                for (FileInAssemblyIndex = 0 ; FileInAssemblyIndex != AssemblyDetailed->ulFileCount ; FileInAssemblyIndex += 1)
                {
                    QueryIndex.ulFileIndexInAssembly = FileInAssemblyIndex;
                    if (!QueryActCtxW(Flags, ActCtxHandle, &QueryIndex, FileInformationInAssemblyOfAssemblyInActivationContext, DllRedir, 4096, &BytesWrittenOrRequired))
                    {
                        Trace(
                            "%s(%lu):QueryActCtx(Flags=0x%lx, ActCtxHandle=%p%ls, QueryIndex={ulAssemblyIndex=0x%lx, ulFileIndexInAssembly=0x%lx}, FileInformationInAssemblyOfAssemblyInActivationContext) LastError=%lu (%ls)\n",
                            __FUNCTION__,
                            __LINE__,
                            Flags,
                            ActCtxHandle,
                            static_cast<PCWSTR>(decimalContext),
                            QueryIndex.ulAssemblyIndex,
                            QueryIndex.ulFileIndexInAssembly,
                            ::FusionpGetLastWin32Error(),
                            ::FusionpThreadUnsafeGetLastWin32ErrorMessageW()
                            );
                        //break;
                    }
                    else
                    {
                        Trace(
                            "AssemblyIndex                          : 0x%lx\n"
                            "FileIndex                              : 0x%lx\n"
                            "BytesWrittenOrRequired                 : 0x%lx\n"
                            "DllRedir[0x%lx,0x%lx]->ulFlags         : 0x%lx\n"
                            "DllRedir[0x%lx,0x%lx]->ulFilenameLength : 0x%lx\n"
                            "DllRedir[0x%lx,0x%lx]->ulPathLength    : 0x%lx\n"
                            "DllRedir[0x%lx,0x%lx]->lpFileName      : %ls\n"
                            "DllRedir[0x%lx,0x%lx]->lpFilePath      : %ls\n"
                            ,
                            AssemblyIndex,
                            FileInAssemblyIndex,
                            BytesWrittenOrRequired,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->ulFlags,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->ulFilenameLength,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->ulPathLength,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->lpFileName,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->lpFilePath
                            );
                    }
                }
            }
        }
    }
}

void TestQueryActCtx2()
{
    {
        CFusionActCtxHandle LogonuiActCtxHandle;
        {
            WCHAR LogonuiManifest[MAX_PATH * 2];
            ACTCTXW            LogonuiActCtx = {sizeof(LogonuiActCtx)};

            LogonuiManifest[0] = 0;
            GetSystemDirectoryW(LogonuiManifest, MAX_PATH);
            wcscat(LogonuiManifest, L"\\logonui.exe.manifest");
            LogonuiActCtx.lpSource = LogonuiManifest;
            LogonuiActCtxHandle.Win32Create(&LogonuiActCtx);
        }
        {
            CFusionActCtxScope LogonuiActCtxScope;
            LogonuiActCtxScope.Win32Activate(LogonuiActCtxHandle);

            TestQueryActCtx3(QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX | QUERY_ACTCTX_FLAG_NO_ADDREF, NULL);
        }
        TestQueryActCtx3(QUERY_ACTCTX_FLAG_NO_ADDREF, LogonuiActCtxHandle);
    }
    TestQueryActCtx3(QUERY_ACTCTX_FLAG_NO_ADDREF, ACTCTX_EMPTY);
    TestQueryActCtx3(QUERY_ACTCTX_FLAG_NO_ADDREF, ACTCTX_SYSTEM_DEFAULT);
}

void TestQueryActCtx()
{
    WCHAR ExePath[MAX_PATH];
    CStringBuffer DllPath;
    HMODULE hmod = NULL;
    WCHAR buffer[200];

    if (IamExe)
    {
        if (!Kernel32.GetModuleFileNameW(NULL, ExePath, RTL_NUMBER_OF(ExePath)))
            ThrowLastError();
        if (!DllPath.Win32Format(L"%ls.dll", ExePath))
            ThrowLastError();
        ::CopyFileW(ExePath, DllPath, FALSE);
    }

    if (IamDll)
    {
        hmod = NULL;
        hmod = (HMODULE)RtlPcToFileHeader(InitCommonControls, (PVOID*)&hmod);
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from dll static dep: %p %ls\n", hmod, buffer);

#if defined(ISOLATION_AWARE_ENABLED)
        hmod = IsolationAwareLoadLibraryW(L"comctl32.dll");
        LastError = ::GetLastError();
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from dll IsolationAwareLoadLibraryW: %p %ls\n", hmod, buffer);
#endif

        hmod = LoadLibraryW(L"comctl32.dll");
        LastError = ::GetLastError();
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from dll LoadLibraryW: %p %ls\n", hmod, buffer);

        return;
    }

    {
        hmod = NULL;
        hmod = (HMODULE)RtlPcToFileHeader(InitCommonControls, (PVOID*)&hmod);
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from exe static dep: %p %ls\n", hmod, buffer);

#if defined(ISOLATION_AWARE_ENABLED)
        hmod = IsolationAwareLoadLibraryW(L"comctl32.dll");
        LastError = ::GetLastError();
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from exe IsolationAwareLoadLibraryW: %p %ls\n", hmod, buffer);
#endif
        hmod = LoadLibraryW(L"comctl32.dll");
        LastError = ::GetLastError();
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from exe LoadLibraryW: %p %ls\n", hmod, buffer);

    }

    SetDllBitInPeImage(DllPath);
    Trace("Enter LoadLibraryW\n");
    hmod = LoadLibraryW(DllPath);
    LastError = ::GetLastError();
    Trace("Exit LoadLibraryW\n");
    void (*pfn)(void) = reinterpret_cast<void (*)(void)>(GetProcAddress(hmod, "TestQueryActCtx"));
    Trace("Enter non DllMain call to TestQueryActCtx\n");
    pfn();
    Trace("Exit non DllMain call to TestQueryActCtx\n");
    FreeLibrary(hmod);
    DeleteFileW(DllPath);
}

DWORD WINAPI Test64kThreadMain(void* pv)
{
    LONG_PTR i = 0;
    HANDLE h = 0;
    ULONG_PTR cookie = 0;
    LONG_PTR j = reinterpret_cast<LONG_PTR>(pv);

    GetCurrentActCtx(&h);

    ActivateActCtx(h, &cookie);
    printf("%Id ", cookie);
    if (cookie == 0) printf("cookie 0\n");
    ActivateActCtx(h, &cookie);
    printf("%Id ", cookie);
    if (cookie == 0) printf("cookie 0\n");

    __try
    {
        for (i = 0 ; i < j ; ++i)
        {
            if (!ActivateActCtx(h, &cookie))
                printf("activate error %lu\n", ::GetLastError());
            else
            {
                if (cookie == 0) printf("cookie 0\n");
                //printf("%Id ", cookie);
                if (!DeactivateActCtx(0, cookie))
                    printf("deactivate error %lu\n", ::GetLastError());
            }
        }
    }
    __except(printf("exception %lx\n", GetExceptionCode()),EXCEPTION_EXECUTE_HANDLER)
    {
    }
    printf("final cookie value %Id\n", cookie);
    return 0;
}

void Test64k()
{
    HANDLE h = 0;
    ULONG_PTR cookie = 0;
    DWORD threadId = 0;
    LONG_PTR i = 0;
    LONG_PTR j = 0;
    HANDLE thread = 0;

    GetCurrentActCtx(&h);

    ActivateActCtx(h, &cookie);
    if (cookie == 0) printf("cookie 0\n");
    printf("%Id ", cookie);
    ActivateActCtx(h, &cookie);
    if (cookie == 0) printf("cookie 0\n");
    printf("%Id ", cookie);

    for (j = 0 ; j < 0xfff0 ; ++j)
    {
        if (!ActivateActCtx(h, &cookie))
            printf("activate error %lu\n", ::GetLastError());
        else
        {
            if (cookie == 0) printf("cookie 0\n");
            if (!DeactivateActCtx(0, cookie))
                printf("deactivate error %lu\n", ::GetLastError());
        }
    }
    for ( ; j < 0xffff + 0xf ; ++j)
    {
        if (!ActivateActCtx(h, &cookie))
            printf("activate error %lu\n", ::GetLastError());
        printf("%Id ", cookie);
        if (cookie == 0) printf("cookie 0\n");
        thread = CreateThread(NULL, 0, Test64kThreadMain, reinterpret_cast<void*>(j), 0, &threadId);
    }
    WaitForSingleObject(thread, INFINITE);
}

void TestDotLocalSingleInstancing()
{
    FILE* File = 0;
    HMODULE DllHandle = 0;

    {
        WCHAR DotLocal[MAX_PATH];
        if (!Kernel32.GetModuleFileNameW(GetMyHandle(), DotLocal, NUMBER_OF(DotLocal) - sizeof(".local")))
            ThrowLastError();
        wcscat(DotLocal, L".local");
        File = _wfopen(DotLocal, L"w");
        fprintf(File, "\n");
        fclose(File);
    }
    {
        WCHAR System32Mshtml[MAX_PATH];
        WCHAR LocalMshtml[MAX_PATH];
        WCHAR ResultingMshtml[MAX_PATH];

        if (!GetSystemDirectoryW(System32Mshtml, NUMBER_OF(System32Mshtml) - sizeof("\\Mshtml.dll")))
            ThrowLastError();
        wcscat(System32Mshtml, L"\\Mshtml.dll");

        if (!Kernel32.GetModuleFileNameW(GetMyHandle(), LocalMshtml, NUMBER_OF(LocalMshtml) - sizeof("\\Mshtml.dll")))
            ThrowLastError();
        *wcsrchr(LocalMshtml, '\\') = 0;
        wcscat(LocalMshtml, L"\\Mshtml.dll");

        //DllHandle = LoadLibraryW(L"Mshtml.dll");
        //Trace("LoadLibrary(Mshtml): %p\n", DllHandle);

        if (!CopyFileW(System32Mshtml, LocalMshtml, FALSE))
            ThrowLastError();
        Trace("copy %ls -> %ls\n", System32Mshtml, LocalMshtml);

        ULONG i;
        for (i = 0 ; i != 4 ; i += 1)
        {
            DllHandle = LoadLibraryW(System32Mshtml);
            wcscpy(ResultingMshtml, L"FAILED");
            if (DllHandle != NULL)
                Kernel32.GetModuleFileNameW(DllHandle, ResultingMshtml, RTL_NUMBER_OF(ResultingMshtml));
            Trace("LoadLibrary(%ls): %p %ls\n", System32Mshtml, DllHandle, ResultingMshtml);
        }
    }
}

void
TestCreateActCtx(
    int n,
    wchar_t **args
    )
{
    ACTCTXW acw;
    int i;
    WCHAR rgwchSource[MAX_PATH];
    PCWSTR pszResource;
    HANDLE hActCtx;
    DWORD dwLastError;

    for (i=0; i<n; i++)
    {
        PCWSTR arg = args[i];
        PCWSTR semi = wcschr(arg, L';');

        memset(&acw, 0, sizeof(acw));

        acw.cbSize = sizeof(acw);

        if (semi == NULL)
        {
            acw.lpSource = arg;
        }
        else
        {
            int cch = (int) (semi - arg);

            if (cch >= NUMBER_OF(rgwchSource))
                cch = NUMBER_OF(rgwchSource) - 1;

            memcpy(rgwchSource, arg, cch * sizeof(WCHAR));
            rgwchSource[cch] = L'\0';

            if (semi[1] == L'#')
            {
                wchar_t *pszDummy;
                pszResource = MAKEINTRESOURCEW(wcstoul(semi+1, &pszDummy, 10));
            }
            else
            {
                pszResource = semi+1;
            }

            acw.lpSource = rgwchSource;
            acw.lpResourceName = pszResource;
            acw.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
        }

        hActCtx = ::CreateActCtxW(&acw);
        dwLastError = ::GetLastError();
        printf("CreateActCtxW() on \"%ls\" returned %p\n", arg, hActCtx);
        if (hActCtx == INVALID_HANDLE_VALUE)
        {
            printf("   ::GetLastError() = %lu\n", dwLastError);
        }

        ::ReleaseActCtx(hActCtx);
    }
}

const char comctlv6manifest[]=
"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
"<assemblyIdentity"
"    name=\"Microsoft.Windows.Shell.notepad\""
"    processorArchitecture=\"x86\""
"    version=\"5.1.0.0\""
"    type=\"win32\"/>"
"<dependency>"
"    <dependentAssembly>"
"        <assemblyIdentity"
"            type=\"win32\""
"            name=\"Microsoft.Windows.Common-Controls\""
"            version=\"6.0.0.0\""
"            processorArchitecture=\"x86\""
"            publicKeyToken=\"6595b64144ccf1df\""
"            language=\"*\""
"        />"
"    </dependentAssembly>"
"</dependency>"
"</assembly>"
;

const char comctlv5manifest[]=
"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
"<assemblyIdentity"
"    name=\"Microsoft.Windows.Shell.notepad\""
"    processorArchitecture=\"x86\""
"    version=\"5.1.0.0\""
"    type=\"win32\"/>"
"</assembly>"
;

void TestCreateActctxAdminOverride()
{
    WCHAR exe[MAX_PATH];
    WCHAR dll[MAX_PATH];
    WCHAR comctl[MAX_PATH];
    WCHAR manifest[MAX_PATH];
    ACTCTXW Actctx = {sizeof(Actctx)};
    FILE* File = NULL;
    ULONG_PTR ulCookie = 0;
    HMODULE DllHandle = 0;
    HANDLE ActctxHandle;
    GUID Guid = { 0 };

    wcscpy(exe, GetMyModuleFullPath());
    wcscpy(dll, GetMyModuleFullPath());
    wcscat(dll, L".dll");
    CopyFileW(exe, dll, FALSE);
    SetDllBitInPeImage(dll);

#if 0
    wcscpy(String, GetMyModuleFullPath());
    wcscat(String, L".Manifest");
    DeleteFileW(String);
    Trace("DeleteFile(%ls)\n", String);

    wcscpy(String, GetMyModuleFullPath());
    wcscat(String, L".2.Manifest");
    DeleteFileW(String);
    Trace("DeleteFile(%ls)\n", String);

    wcscpy(String, GetMyModuleFullPath());
    wcscat(String, L".3.Manifest");
    DeleteFileW(String);
    Trace("DeleteFile(%ls)\n", String);
#endif

    Actctx.lpSource = dll;
    /*
    ActctxHandle = CreateActCtxW(&Actctx);
    if (ActctxHandle == INVALID_HANDLE_VALUE)
        return;
    Trace("CreateActCtxW succeeded\n");
    */

    //
    // manfile is number to put in the manifest file name, 0 for none
    // good is what the contents of the file are, 0=>bad, 1=>v5, 2=>v6
    // res is what resource id to ask for
    //
    for (int manfile = 0 ; manfile != 4 ; manfile += 1)
    {
        WCHAR Number[RTL_BITS_OF(ULONG_PTR) + 3];
        for (int good = 0 ; good != 3 ; good += 1)
        {
            for (int res = -1 ; res != 4 ; res += 1)
            {
                Trace("---------------------------------------------------------------\n");
                Trace("resourceid is %d%s\n", res, (res != -1) ? "" : " (flag not set)");
                if (res != -1)
                {
                    Actctx.lpResourceName = MAKEINTRESOURCEW(res);
                    Actctx.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
                    Actctx.lpResourceName = MAKEINTRESOURCEW(res);
                }
                else
                {
                    Actctx.dwFlags &= ~ACTCTX_FLAG_RESOURCE_NAME_VALID;
                }
                for (int delman = 0 ; delman != 4 ; delman += 1)
                {
                    Number[0] = 0;
                    if (delman)
                        swprintf(Number, L".%d", delman);
                    swprintf(manifest, L"%ls%ls%ls%ls", GetMyModuleFullPathWithoutExtension(), L".dll", Number, L".Manifest");
                    /*
                    CoCreateGuid(&Guid);
                    swprintf(String3, L"%ls%I64x%I64x", GetMyModuleFullPath(), *reinterpret_cast<__int64*>(&Guid), *(1+reinterpret_cast<__int64*>(&Guid)));
                    if (!MoveFileW(String, String3) && ::GetLastError() != ERROR_FILE_NOT_FOUND)
                        Trace("MoveFile(%ls -> %ls) FAILED %d\n", String, String3, ::GetLastError());
                    else
                        ;//Trace("MoveFile(%ls -> %ls)\n", String, String3);
                    */
                    if (!DeleteFileW(manifest) && ::GetLastError() != ERROR_FILE_NOT_FOUND)
                        Trace("DeleteFile(%ls) FAILED %d\n", manifest, ::GetLastError());
                    else
                        ;//Trace("DeleteFile(%ls)\n", String3);
                }
                Number[0] = 0;
                if (manfile != 0)
                {
                    swprintf(Number, L".%d", manfile);
                }
                swprintf(manifest, L"%ls%ls%ls%ls", GetMyModuleFullPathWithoutExtension(), L".dll", Number, L".Manifest");
                //Trace("fopen(%ls)\n", String);
                File = _wfopen(manifest, L"w+");
                if (File == NULL)
                {
                    perror("fopen");
                }
                switch (good)
                {
                case 0:
                    fprintf(File, "bad");
                    Trace("%ls is bad\n", manifest);
                    break;
                case 1:
                    fprintf(File, "%s", comctlv5manifest);
                    Trace("%ls is comctlv5manifest\n", manifest);
                    break;
                case 2:
                    fprintf(File, "%s", comctlv6manifest);
                    Trace("%ls is comctlv6manifest\n", manifest);
                    break;
                }
                fclose(File);

                ActctxHandle = CreateActCtxW(&Actctx);
                if (ActctxHandle == INVALID_HANDLE_VALUE)
                {
                    Trace("CreateActCtxW failed %d\n", ::GetLastError());
                    ulCookie = 0;
                }
                else
                {
                    Trace("CreateActCtxW succeeded %p\n", ActctxHandle);
                    ActivateActCtx(ActctxHandle, &ulCookie);
                }
                __try
                {
                    PWSTR filePart;
                    comctl[0] = 0;
                    SearchPathW(NULL, L"comctl32.dll", NULL, RTL_NUMBER_OF(comctl), comctl, &filePart);
                }
                __finally
                {
                    if (ActctxHandle != INVALID_HANDLE_VALUE)
                        DeactivateActCtx(0, ulCookie);
                }
                Trace("SearchPathW(comctl32.dll): %ls\n", comctl);
            }
        }
    }
}

void TestCreateActctxLikeCreateProcess()
{
#if defined(ACTCTX_FLAG_LIKE_CREATEPROCESS)
    WCHAR comctl[MAX_PATH];
    WCHAR manifest[MAX_PATH];
    ACTCTXW Actctx = {sizeof(Actctx)};
    FILE* File = NULL;
    ULONG_PTR ulCookie = 0;
    HMODULE DllHandle = 0;
    HANDLE ActctxHandle;
    PWSTR filePart;

    Actctx.lpSource = GetMyModuleFullPath();
    Actctx.dwFlags = ACTCTX_FLAG_LIKE_CREATEPROCESS;

    wcscpy(manifest, GetMyModuleFullPath());
    wcscat(manifest, L".Manifest");
    DeleteFileW(manifest);
    //Trace("DeleteFile(%ls)\n", manifest);

    ActctxHandle = CreateActCtxW(&Actctx);
    if (ActctxHandle == INVALID_HANDLE_VALUE)
    {
        Trace("CreateActCtxW failed %d\n", ::GetLastError());
        ulCookie = 0;
    }
    else
    {
        Trace("CreateActCtxW succeeded %p\n", ActctxHandle);
        ActivateActCtx(ActctxHandle, &ulCookie);
    }
    __try
    {
        comctl[0] = 0;
        SearchPathW(NULL, L"comctl32.dll", NULL, RTL_NUMBER_OF(comctl), comctl, &filePart);
    }
    __finally
    {
        if (ActctxHandle != INVALID_HANDLE_VALUE)
            DeactivateActCtx(0, ulCookie);
    }
    Trace("SearchPathW(comctl32.dll): %ls\n", comctl);

    File = _wfopen(manifest, L"w");
    fprintf(File, "%s", comctlv5manifest);
    fclose(File);
    Trace("%ls == comctlv5manifest\n", manifest);

    ActctxHandle = CreateActCtxW(&Actctx);
    if (ActctxHandle == INVALID_HANDLE_VALUE)
    {
        Trace("CreateActCtxW failed %d\n", ::GetLastError());
        ulCookie = 0;
    }
    else
    {
        Trace("CreateActCtxW succeeded %p\n", ActctxHandle);
        ActivateActCtx(ActctxHandle, &ulCookie);
    }
    __try
    {
        comctl[0] = 0;
        SearchPathW(NULL, L"comctl32.dll", NULL, RTL_NUMBER_OF(comctl), comctl, &filePart);
    }
    __finally
    {
        if (ActctxHandle != INVALID_HANDLE_VALUE)
            DeactivateActCtx(0, ulCookie);
    }
    Trace("SearchPathW(comctl32.dll): %ls\n", comctl);

    File = _wfopen(manifest, L"w");
    fprintf(File, "%ls", comctlv6manifest);
    fclose(File);
    Trace("%ls == comctlv6manifest\n", manifest);

    ActctxHandle = CreateActCtxW(&Actctx);
    if (ActctxHandle == INVALID_HANDLE_VALUE)
    {
        Trace("CreateActCtxW failed %d\n", ::GetLastError());
        ulCookie = 0;
    }
    else
    {
        Trace("CreateActCtxW succeeded %p\n", ActctxHandle);
        ActivateActCtx(ActctxHandle, &ulCookie);
    }
    __try
    {
        comctl[0] = 0;
        SearchPathW(NULL, L"comctl32.dll", NULL, RTL_NUMBER_OF(comctl), comctl, &filePart);
    }
    __finally
    {
        if (ActctxHandle != INVALID_HANDLE_VALUE)
            DeactivateActCtx(0, ulCookie);
    }
    Trace("SearchPathW(comctl32.dll): %ls\n", comctl);
#endif
}

void
TestQueryManifestInformationBasic(
    PCWSTR pszManifest
    )
{
    PSXS_QUERY_MANIFEST_INFORMATION pfn = NULL;
    LoadSxs();
    struct {
        SXS_MANIFEST_INFORMATION_BASIC mib;
        WCHAR rgwchSpaceForIdentity[1024];
        WCHAR rgwchSpaceForDirName[1024];
    } buff;

    GetSxsProc("SxsQueryManifestInformation", &pfn);

    if (!(*pfn)(0, pszManifest, SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC, 0, sizeof(buff), &buff, NULL)) {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
    }
}

void TestImage()
{
    PIMAGE_RESOURCE_DIRECTORY ImageResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)4;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ImageResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)4;;

    printf("ImageResourceDirectory %p\n", ImageResourceDirectory);
    printf("ImageResourceDirectory + 1 %p\n", ImageResourceDirectory + 1);

    printf("ImageResourceDirectoryEntry %p\n", ImageResourceDirectoryEntry);
    printf("ImageResourceDirectoryEntry + 1 %p\n", ImageResourceDirectoryEntry + 1);
}

class CSxsTestCleanup : public CCleanupBase
{
public:
    VOID DeleteYourself() { }
    ~CSxsTestCleanup() { }
};

#define private public
#include "sxsprotect.h"
#undef private

void TestInterlockedAlignment()
{
    __declspec(align(16)) SLIST_HEADER SlistHeader;

    RtlInitializeSListHead(&SlistHeader);

    CSxsTestCleanup* pc = new CSxsTestCleanup();
    printf("%p\n", pc);
    printf("%p\n", static_cast<SINGLE_LIST_ENTRY*>(pc));
    SxspAtExit(pc);

    CProtectionRequestRecord* pr = new CProtectionRequestRecord;
    printf("%p\n", pr);
    printf("%p\n", &pr->m_ListHeader);

    CStringListEntry* psle = new CStringListEntry;
    printf("%p\n", psle);
    printf("%p\n", static_cast<SINGLE_LIST_ENTRY*>(psle));

    RtlInterlockedPushEntrySList(&SlistHeader, pc);
    RtlInterlockedPushEntrySList(&SlistHeader, psle);
    RtlQueryDepthSList(&SlistHeader);
    RtlInterlockedPopEntrySList(&SlistHeader);
    RtlInterlockedFlushSList(&SlistHeader);
    // untested: RtlInterlockedPushListSList

    RtlInterlockedPushEntrySList(&pr->m_ListHeader, pc);
    RtlInterlockedPushEntrySList(&pr->m_ListHeader, psle);
    RtlQueryDepthSList(&pr->m_ListHeader);
    RtlInterlockedPopEntrySList(&pr->m_ListHeader);
    RtlInterlockedFlushSList(&pr->m_ListHeader);
    // untested: RtlInterlockedPushListSList

    printf("success\n");
}

void TestCreateActctxWindowsShellManifest()
{
    WCHAR WindowsShellManifestFileName[MAX_PATH];
    ACTCTXW ActCtx = { sizeof(ActCtx) };
    HANDLE ActCtxHandle = 0;
    WindowsShellManifestFileName[0] = 0;

    GetWindowsDirectoryW(WindowsShellManifestFileName, NUMBER_OF(WindowsShellManifestFileName) - 64);
    wcscat(WindowsShellManifestFileName, L"\\WindowsShell.Manifest");
    ActCtx.lpSource = WindowsShellManifestFileName;

    ActCtxHandle = CreateActCtxW(&ActCtx);
    Trace("TestCreateActctxWindowsShellManifest: %p, %lu\n", ActCtxHandle, ::GetLastError());
    ReleaseActCtx(ActCtxHandle);
}

class CObjectTypes
{
protected:
    std::vector<BYTE> m_ByteBuffer;
    PSYSTEM_OBJECTTYPE_INFORMATION m_TypedBuffer;
public:
};

void TestCreateGlobalEvent()
{
	if (!::CreateEventW(NULL, FALSE, FALSE, L"MGRIER"))
		return;
	Sleep(500000);
}

class CObjectSnapshot
{
protected:
    //
    // This interface is not very good, but it's easy..the entries
    // are of variable size...
    //
    std::vector<BYTE> m_ByteBuffer;
    SIZE_T            m_Size;

    //
    // Some operations, like sorting, require us to move all the string data
    // out of the elements. We do not manage this data in a lossless way.
    //
    // Ultimately, you may benefit from copying/transforming the data completely.
    //
    std::vector<BYTE> m_StringData;
public:

    SIZE_T size() const { return m_Size; }

    class iterator;

    class const_iterator
    {
    protected:
        const SYSTEM_OBJECT_INFORMATION* m_p;
    public:
        ~const_iterator() { }

        void operator=(const const_iterator& x) { m_p = x.m_p; }
        const_iterator(const const_iterator& x) : m_p(x.m_p) { }
        const_iterator(const BYTE* p = NULL) : m_p(reinterpret_cast<const SYSTEM_OBJECT_INFORMATION*>(p)) { }

        //void operator=(const iterator& x);
        //const_iterator(const iterator& x);

        bool operator==(const const_iterator& i) const
        {
            return (m_p == i.m_p);
        }

        bool operator!=(const const_iterator& i) const
        {
            return (m_p != i.m_p);
        }

        const SYSTEM_OBJECT_INFORMATION& operator*() const { return *m_p; }

        void operator++()
        {
            if (m_p != NULL)
            {
                if (m_p->NextEntryOffset != 0)
                    m_p = reinterpret_cast<const SYSTEM_OBJECT_INFORMATION*>(reinterpret_cast<const BYTE*>(m_p) + m_p->NextEntryOffset);
                else
                    m_p = NULL; // end
            }
        }

        const_iterator operator++(int)
        {
            const_iterator tmp = *this;
            ++*this;;
            return tmp;
        }
    };

    class iterator : public const_iterator
    {
    private:
        void operator=(const const_iterator&);
    public:
        ~iterator() { }
        iterator(BYTE* p = NULL) : const_iterator(p) { }

        SYSTEM_OBJECT_INFORMATION& operator*() { return const_cast<SYSTEM_OBJECT_INFORMATION&>(*m_p); }
    };

    const_iterator begin() const { return const_iterator(&m_ByteBuffer[0]); }
          iterator begin()       { return iterator(&m_ByteBuffer[0]); }
    const_iterator end() const   { return const_iterator(); }
          iterator end()         { return iterator(); }

    void swap(CObjectSnapshot& x)
    {
        std::swap(m_ByteBuffer, x.m_ByteBuffer);
        std::swap(m_Size, x.m_Size);
    }

    CObjectSnapshot() { }
    ~CObjectSnapshot() { }
};

class CHandleSnapshot
{
protected:
    std::vector<BYTE> m_ByteBuffer;
    PSYSTEM_HANDLE_INFORMATION_EX m_TypedBuffer;
public:

    SIZE_T size() const { return m_TypedBuffer->NumberOfHandles; }

    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* begin() { return &m_TypedBuffer->Handles[0]; }
    const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* begin() const { return &m_TypedBuffer->Handles[0]; }

    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* end() { return begin() + size(); }
    const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* end() const { return begin() + size(); }

    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX& operator[](size_t index) { return *(begin() + index); }
    const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX& operator[](size_t index) const { return *(begin() + index); }

    void reserve(SIZE_T n)
    {
        resize(n); // since there's no constructor..
    }

    void resize(SIZE_T n)
    {
        m_ByteBuffer.resize(sizeof(SYSTEM_HANDLE_INFORMATION_EX) + (n - 1) * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX));
        Resync();
        m_TypedBuffer->NumberOfHandles = n;
    }

    void swap(CHandleSnapshot& x)
    {
        std::swap(m_ByteBuffer, x.m_ByteBuffer);
        x.Resync();
        Resync();
    }

    CHandleSnapshot() : m_TypedBuffer(NULL) { }
    ~CHandleSnapshot() { }

    void GetHandlesForCurrentProcess()
    {
        GetHandlesForProcess(GetCurrentProcessId());
    }

    void GetHandlesForProcess(ULONG_PTR pid)
    {
        GetHandlesForSystem();
        FilterByProcessId(pid);
    }

    void GetHandlesForSystem()
    {
        //
        // the actual needed size can be very large, over 256k
        //
        ULONG Size = 0;

        m_TypedBuffer = NULL;
        m_ByteBuffer.resize(sizeof(SYSTEM_HANDLE_INFORMATION_EX));
        NTSTATUS Status = NtQuerySystemInformation(SystemExtendedHandleInformation, &m_ByteBuffer[0], static_cast<ULONG>(m_ByteBuffer.size()), &Size);
        while (Status == STATUS_INFO_LENGTH_MISMATCH && Size != 0)
        {
            //
            // since it is transient, let's be safe and double it
            //
            m_ByteBuffer.resize(Size * 2);
            Status = NtQuerySystemInformation(SystemExtendedHandleInformation, &m_ByteBuffer[0], static_cast<ULONG>(m_ByteBuffer.size()), &Size);
        }
        if (!NT_SUCCESS(Status))
        {
            Trace("NtQuerySystemInformation failed 0x%lx\n", Status);
            return;
        }
        m_ByteBuffer.resize(Size);
        m_TypedBuffer = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION_EX>(&m_ByteBuffer[0]);
        Trace("%Id total handles system-wide\n", m_TypedBuffer->NumberOfHandles);
    }

    void FilterByProcessId(ULONG_PTR pid)
    {
        SIZE_T Scan = 0;
        SIZE_T Keep = 0;

        for (Scan = 0 ; Scan != m_TypedBuffer->NumberOfHandles ; Scan += 1)
        {
            if (m_TypedBuffer->Handles[Scan].UniqueProcessId == pid)
            {
                if (Keep != Scan)
                    m_TypedBuffer->Handles[Keep] = m_TypedBuffer->Handles[Scan]; // struct copy
                Keep += 1;
            }
        }
        m_TypedBuffer->NumberOfHandles = Keep;
    }

    void Resync()
    {
        m_TypedBuffer = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION_EX>(&m_ByteBuffer[0]);
    }

    CHandleSnapshot(const CHandleSnapshot& x) : m_TypedBuffer(NULL)
    {
        this->m_ByteBuffer = x.m_ByteBuffer;
        Resync();
    }

    void operator=(const CHandleSnapshot& x)
    {
        this->m_ByteBuffer = x.m_ByteBuffer;
        Resync();
    }

    class CHandleValueOperatorLessThan
    {
    public:
        bool operator()(const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX& x, const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX& y)
        {
            return (x.HandleValue < y.HandleValue);
        }
    };

    void SortByHandleValue()
    {
        std::sort(begin(), end(), CHandleValueOperatorLessThan());
    }

    void operator-=(/*const*/CHandleSnapshot& x)
    {
        SortByHandleValue();
        x.SortByHandleValue();
        CHandleSnapshot temp(*this);
        resize(
            std::set_difference(temp.begin(), temp.end(), x.begin(), x.end(), begin(), CHandleValueOperatorLessThan())
            - begin());
    }

    void Dump()
    {
    }
};

class CHandleSnapshots
{
public:
    void Begin() { m_Begin.GetHandlesForCurrentProcess(); }
    void End() { m_End.GetHandlesForCurrentProcess(); m_Diff = m_Begin; m_Diff -= m_End; }

    CHandleSnapshot m_Begin;
    CHandleSnapshot m_End;
    CHandleSnapshot m_Diff;
};

void Pause()
{
    Trace("Press a key to continue\n");
    getchar();
}

void TestHandleLeaks()
{
    WCHAR WindowsDirectory[MAX_PATH];
    ULONG i = 0;
    CFusionFile DevNull;
    //SECURITY_ATTRIBUTES SecurityAttributes = { sizeof(SecurityAttributes), NULL, TRUE};

    WindowsDirectory[0] = 0;

    DevNull = CreateFileW(L"nul:", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL/*&SecurityAttributes*/, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (DevNull == INVALID_HANDLE_VALUE)
        Trace("Open(nul:) failed %ld\n", ::GetLastError());

    GetWindowsDirectoryW(WindowsDirectory, NUMBER_OF(WindowsDirectory) - 64);

    {
        const WCHAR SubFunction[] = L"CreateActCtx";

        CHandleSnapshots handleSnapshots;
        handleSnapshots.Begin();
        Trace("%s Begin %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Begin.size());
        {
            WCHAR WindowsShellManifestFileName[MAX_PATH];
            ACTCTXW ActCtx = { sizeof(ActCtx) };
            HANDLE ActCtxHandle = 0;

            WindowsShellManifestFileName[0] = 0;
            wcscpy(WindowsShellManifestFileName, WindowsDirectory);
            wcscat(WindowsShellManifestFileName, L"\\WindowsShell.Manifest");
            ActCtx.lpSource = WindowsShellManifestFileName;

            for (i = 0 ; i != 100 ; ++i)
            {
                HANDLE ActCtxHandle = CreateActCtxW(&ActCtx);
                if (ActCtxHandle == INVALID_HANDLE_VALUE)
                    Trace("TestCreateActctxWindowsShellManifest: %p, %lu\n", ActCtxHandle, ::GetLastError());
                else
                    ReleaseActCtx(ActCtxHandle);
            }
        }
        handleSnapshots.End();
        Trace("%s End %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_End.size());

        if (handleSnapshots.m_Diff.size() != 0)
        {
            Trace("%s Diff %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Diff.size());
        }
    }

    Pause();
    {
        const WCHAR SubFunction[] = L"CreateActCtx + LoadLibrary(comctl32)";

        CHandleSnapshots handleSnapshots;
        handleSnapshots.Begin();
        Trace("%s Begin %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Begin.size());
        {
            WCHAR WindowsShellManifestFileName[MAX_PATH];
            ACTCTXW ActCtx = { sizeof(ActCtx) };
            HANDLE ActCtxHandle = 0;

            WindowsShellManifestFileName[0] = 0;
            wcscpy(WindowsShellManifestFileName, WindowsDirectory);
            wcscat(WindowsShellManifestFileName, L"\\WindowsShell.Manifest");
            ActCtx.lpSource = WindowsShellManifestFileName;

            for (i = 0 ; i != 100 ; ++i)
            {
                ULONG_PTR ulCookie = 0;

                HANDLE ActCtxHandle = CreateActCtxW(&ActCtx);
                if (ActCtxHandle == INVALID_HANDLE_VALUE)
                    Trace("TestCreateActctxWindowsShellManifest: %p, %lu\n", ActCtxHandle, ::GetLastError());
                else
                {
                    ActivateActCtx(ActCtxHandle, &ulCookie);
                    HMODULE Comctl = LoadLibraryW(L"comctl32.dll");
                    if (i == 1)
                    {
                        CHandleSnapshot handleSnapshot;
                        handleSnapshot.GetHandlesForCurrentProcess();
                        Trace("Comctl32.dll loaded first time %Id\n", handleSnapshot.size());
                        Pause();
                    }
                    FreeLibrary(Comctl);
                    if (i == 1)
                    {
                        CHandleSnapshot handleSnapshot;
                        handleSnapshot.GetHandlesForCurrentProcess();
                        Trace("Comctl32.dll unloaded first time %Id\n", handleSnapshot.size());
                        Pause();
                    }
                    if (ulCookie != 0)
                        DeactivateActCtx(0, ulCookie);
                    ReleaseActCtx(ActCtxHandle);
                    if (i == 1)
                    {
                        CHandleSnapshot handleSnapshot;
                        handleSnapshot.GetHandlesForCurrentProcess();
                        Trace("Comctl32.dll unloaded + ReleaseActCtxfirst time %Id\n", handleSnapshot.size());
                        Pause();
                    }
                }
            }
        }
        handleSnapshots.End();
        Trace("%s End %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_End.size());

        if (handleSnapshots.m_Diff.size() != 0)
        {
            Trace("%s Diff %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Diff.size());
        }
    }

    Pause();
    {
        WCHAR Me[MAX_PATH];
        STARTUPINFOW StartupInfo = {sizeof(StartupInfo)};
        PROCESS_INFORMATION ProcessInfo = {0};
        static const WCHAR SubFunction[] = L"CreateProcess";

        Kernel32.GetModuleFileNameW(NULL, Me, NUMBER_OF(Me));

        CHandleSnapshots handleSnapshots;
        handleSnapshots.Begin();
        Trace("%s Begin %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Begin.size());

        for (i = 0 ; i != 100 ; ++i)
        {
            StartupInfo.hStdOutput = DevNull;
            StartupInfo.hStdError = DevNull;
            StartupInfo.dwFlags = STARTF_USESTDHANDLES;

            if (!CreateProcessW(Me, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInfo))
            {
                Trace("CreateProcess failed %ld\n", ::GetLastError());
            }
            else
            {
                WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
                WaitForSingleObject(ProcessInfo.hThread, INFINITE);
                if (!CloseHandle(ProcessInfo.hProcess))
                    Trace("CloseHandle(Process %p) failed %ld\n", ProcessInfo.hProcess, ::GetLastError());
                if (!CloseHandle(ProcessInfo.hThread))
                    Trace("CloseHandle(Thread %p) failed %ld\n", ProcessInfo.hThread, ::GetLastError());
            }
        }
        handleSnapshots.End();
        Trace("%s End %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_End.size());

        if (handleSnapshots.m_Diff.size() != 0)
        {
            Trace("%s Diff %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Diff.size());
        }
    }
    Pause();
    {
        WCHAR SubFunction[sizeof("LoadLibrary xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")];
        WCHAR DllPath[MAX_PATH];
        ULONG j = 0;

        const static PCWSTR Leaves[] = {
            L"mshtml.dll",
            L"wintrust.dll",
            L"shell32.dll",
            L"crypt32.dll",
            L"msxml.dll",
            L"shdocvw.dll",
            L"msxml2.dll",
            L"msxml3.dll"
            };

        for (j = 0 ; j != NUMBER_OF(Leaves) ; ++j)
        {
            SubFunction[0] = 0;
            wcscat(SubFunction, L"LoadLibrary ");
            wcscat(SubFunction, Leaves[j]);

            DllPath[0] = 0;
            wcscat(DllPath, WindowsDirectory);
            wcscat(DllPath, L"\\system32\\");
            wcscat(DllPath, Leaves[j]);

            CHandleSnapshots handleSnapshots;
            handleSnapshots.Begin();
            Trace("%s Begin %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Begin.size());
            for (i = 0 ; i != 20 ; ++i)
            {
                HMODULE DllHandle;

                if ((DllHandle = LoadLibraryW(DllPath)) != NULL)
                    FreeLibrary(DllHandle);
                else
                    Trace("LoadLibraryW(%ls) failed %ld\n", DllPath, ::GetLastError());
            }
            handleSnapshots.End();
            Trace("%s End %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_End.size());
            if (handleSnapshots.m_Diff.size() != 0)
            {
                Trace("%s Diff %s : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Diff.size());
            }
        }
    }
    Pause();
}

#define YET_ANOTHER_PASTE(x,y) x##y
#define YET_YET_ANOTHER_PASTE(x,y) YET_ANOTHER_PASTE(x,y)
#define LSXS_PROCESSOR_ARCHITECTURE YET_YET_ANOTHER_PASTE(L, SXS_PROCESSOR_ARCHITECTURE)

const WCHAR ToolsCrtManifest[]=
L"<?xml version=\"1.0\" standalone=\"yes\"?>"
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"<assemblyIdentity"
L"    name=\"Microsoft.Windows.SxsTest.ToolsCrtClient\""
L"    processorArchitecture=\"" LSXS_PROCESSOR_ARCHITECTURE L"\"" /* Note that this only actually exists on x86 */
L"    version=\"5.1.0.0\""
L"    type=\"win32\"/>"
L"<dependency>"
L"    <dependentAssembly>"
L"        <assemblyIdentity"
L"            type=\"win32\""
L"            name=\"Microsoft.Tools.VisualCPlusPlus.Runtime-Libraries\""
L"            version=\"6.0.0.0\""
L"            processorArchitecture=\"" LSXS_PROCESSOR_ARCHITECTURE L"\""
L"            publicKeyToken=\"6595b64144ccf1df\""
L"            language=\"*\""
L"        />"
L"    </dependentAssembly>"
L"</dependency>"
L"</assembly>"
;

const WCHAR WindowsCrtManifest[]=
L"<?xml version=\"1.0\" standalone=\"yes\"?>"
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"<assemblyIdentity"
L"    name=\"Microsoft.Windows.SxsTest.WindowsCrtClient\""
L"    processorArchitecture=\"" LSXS_PROCESSOR_ARCHITECTURE L"\""
L"    version=\"5.1.0.0\""
L"    type=\"win32\"/>"
L"<dependency>"
L"    <dependentAssembly>"
L"        <assemblyIdentity"
L"            type=\"win32\""
L"            name=\"Microsoft.Windows.CPlusPlusRuntime\""
L"            version=\"7.0.0.0\""
L"            processorArchitecture=\"" LSXS_PROCESSOR_ARCHITECTURE L"\""
L"            publicKeyToken=\"6595b64144ccf1df\""
L"            language=\"*\""
L"        />"
L"    </dependentAssembly>"
L"</dependency>"
L"</assembly>"
;

void TestCRuntimeAsms()
{
    CFusionActCtxHandle WindowsCrtActCtxHandle;
    CFusionActCtxHandle ToolsCrtActCtxHandle;

    WindowsCrtActCtxHandle = ::CreateActivationContextFromStringW(WindowsCrtManifest);
    if (WindowsCrtActCtxHandle == INVALID_HANDLE_VALUE)
        ::Trace("CreateActCtx(WindowsCrtManifest %p) failed %ld\n", WindowsCrtManifest, ::GetLastError());
    ToolsCrtActCtxHandle = ::CreateActivationContextFromStringW(ToolsCrtManifest);
    if (ToolsCrtActCtxHandle == INVALID_HANDLE_VALUE)
        ::Trace("CreateActCtx(WindowsCrtManifest %p) failed %ld\n", WindowsCrtManifest, ::GetLastError());

    CFusionActCtxScope ToolsCrtActCtxScope;
    CFusionActCtxScope WindowsCrtActCtxScope;

    if (!WindowsCrtActCtxScope.Win32Activate(WindowsCrtActCtxHandle))
        ::Trace("Activate(WindowsCrtActCtxHandle %p) failed %ld\n", WindowsCrtActCtxHandle, ::GetLastError());

    if (!ToolsCrtActCtxScope.Win32Activate(ToolsCrtActCtxHandle))
        ::Trace("Activate(ToolsCrtActCtxHandle %p) failed %ld\n", ToolsCrtActCtxHandle, ::GetLastError());

    CStringBuffer MsvcrtBuffer;
    CStringBuffer AtlBuffer;

    //::SearchPathW();
}

/*
    <comInterfaceExternalProxyStub
        name="IPropertyPage"
        iid="{B196B28D-BAB4-101A-B69C-00AA00341D07}"
        proxyStubClsid32="{B196B286-BAB4-101A-B69C-00AA00341D07}"
        numMethods="14"
        baseInterface="{00000000-0000-0000-C000-000000000046}"
    >

    <comInterfaceExternalProxyStub
        name="IPropertyPage2"
        iid="{01E44665-24AC-101B-84ED-08002B2EC713}"
        proxyStubClsid32="{B196B286-BAB4-101A-B69C-00AA00341D07}"
        numMethods="15"
        baseInterface="{B196B28D-BAB4-101A-B69C-00AA00341D07}"
    >

    <comInterfaceExternalProxyStub
        name="IPropertyNotifySink"
        iid="{9BFBBC02-EFF1-101A-84ED-00AA00341D07}"
        proxyStubClsid32="{B196B286-BAB4-101A-B69C-00AA00341D07}"
        baseInterface="{00000000-0000-0000-C000-00 00 00 00 00 46}"
        numMethods="5"
    >
*/

#if 0
BOOL Win32FormatGuid(
    CBaseStringBuffer& buff
    REFGUID            guid
    )
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT(this->Win32ResizeBuffer(64));
    IFW32FALSE_EXIT(buff.Win32Format(L"{%08lx-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x}",
        guid.Data1,
        guid.Data2,
        guid.Data3,
        guid.Data4[0], guid.Data4[1],
        guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7],
        ));
    FN_EPILOG
}
#endif

BOOL Win32Append(
    CBaseStringBuffer& s,
    PCWSTR             t
    )
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT(s.Win32Append(t, wcslen(t)));
    FN_EPILOG
}

typedef struct _FUSIONTESTP_REG_DATA
{
#define FUSIONTESTP_REG_TYPE_INTERFACE (1)
#define FUSIONTESTP_REG_TYPE_CLASS     (2)
    ULONG  Type;
    PCWSTR Name; // for debugging/tracing purposes (should coincide with InterfaceName)
    PCWSTR Guid;
    union
    {
        struct
        {
            WCHAR  InprocServerFilePath[MAX_PATH];
            WCHAR  ThreadingModel[64];
        };
        struct
        {
            WCHAR  InterfaceName[MAX_PATH];
            WCHAR  NumMethods[64];
            WCHAR  ProxyStubClsid[64];
            //
            // These usually aren't provided.
            //
            // WCHAR BaseInterface[64];
            // WCHAR OLEViewerIViewerCLSID[64];
            //
        };
    };
#define FUSIONTESTP_REG_ROOT_CURRENT_USER  (1)
#define FUSIONTESTP_REG_ROOT_LOCAL_MACHINE (2)
#define FUSIONTESTP_REG_ROOT_CLASSES_ROOT  (3)
    ULONG  Root;

//
// It is perhaps a bit inelegant to put this data here, perhaps not..
// We are deliberately a bit sloppy on the refcounting of these right now.
//
//#define FUSIONTESTP_PLAIN_COM_POINTER(t) CSmartRef<t>
#define FUSIONTESTP_PLAIN_COM_POINTER(t) t*
//#define FUSIONTESTP_PLAIN_COM_POINTER(t) void*
    FUSIONTESTP_PLAIN_COM_POINTER(IUnknown)   CoCreatedObject;
    //FUSIONTESTP_PLAIN_COM_POINTER(IUnknown)   InterfaceIntoObjectInCreatingThread;
    //FUSIONTESTP_PLAIN_COM_POINTER(IUnknown)   InterfaceIntoObjectInAnotherThread;
    //WCHAR                               ModulePathInOtherThread[MAX_PATH]; // expected to be oleaut32.dll, but possibly already unloaded
    //IID                                 InterfaceIdOfObject;
    DWORD                               GlobalInterfaceTableCookie;
} FUSIONTESTP_REG_DATA, *PFUSIONTESTP_REG_DATA;
typedef const FUSIONTESTP_REG_DATA* PCFUSIONTESTP_REG_DATA;

#if 0
//
// In reality, all three MFC classes implement all three interfaces, but let's broaden
// our minds a bit, ok?
//
BOOL
FusionTestpDynamicallyFindAnyInterfaceIntoObjectExceptIUnknown(
    IUnknown*               Object,
    PCFUSIONTESTP_REG_DATA  RegData, // too broad of a type really, but ok
    SIZE_T                  Count,
    FUSIONTESTP_PLAIN_COM_POINTER(IUnknown)& InterfaceIntoObject,
    SIZE_T&                 InterfaceId
    )
{
    BOOL Success = FALSE;
    FN_PROLOG_WIN32(Success);
    IID LocalInterfaceId = { 0 };
    FUSIONTESTP_PLAIN_COM_POINTER(IUnknown) LocalInterfaceIntoObject = NULL;
    SIZE_T InterfaceIndex = 0;

    InterfaceIntoObject = LocalInterfaceIntoObject;
    InterfaceId = LocalInterfaceId;

    for ( LocalInterfaceIndex = 0; LocalInterfaceIndex != Count ; LocalInterfaceIndex += 1)
    {
        FUSIONTESTP_REG_DATA* const p = &RegData[LocalInterfaceIndex];

        IFCOMFAILED_EXIT(hr = Ole32.IIDFromString(const_cast<PWSTR>(p->Guid), &InterfaceId));

        if (InterfaceId == IID_IUnknown) // shouldn't happen, but easy enough to handle
            continue;

        hr = Object->QueryInterface(InterfaceId, reinterpret_cast<void**>(&LocalInterfaceIntoObject));
        if (SUCCEEDED(hr))
        {
            ::Trace("%s found interface %ls\n", __FUNCTION__, p->Name);
            InterfaceIntoObject = LocalInterfaceIntoObject;
            InterfaceId = LocalInterfaceId;
            Success = TRUE;
            goto Exit;
        }
    }
    FN_EPILOG
}
#endif

#define OLEAUT_MARSHALER_CLSID_STRING L"{B196B286-BAB4-101A-B69C-00AA00341D07}"

FUSIONTESTP_REG_DATA FusionTestpMfcRegData[] =
{
    { FUSIONTESTP_REG_TYPE_CLASS, L"Font Property Page", L"{0BE35200-8F91-11CE-9DE3-00AA004BB851}" },
    { FUSIONTESTP_REG_TYPE_CLASS, L"Color Property Page", L"{0BE35201-8F91-11CE-9DE3-00AA004BB851}" },
    { FUSIONTESTP_REG_TYPE_CLASS, L"Picture Property Page", L"{0BE35202-8F91-11CE-9DE3-00AA004BB851}" },
    { FUSIONTESTP_REG_TYPE_INTERFACE, L"IPropertyPage",  L"{B196B28D-BAB4-101A-B69C-00AA00341D07}" },
    { FUSIONTESTP_REG_TYPE_INTERFACE, L"IPropertyPage2", L"{01E44665-24AC-101B-84ED-08002B2EC713}" },
    { FUSIONTESTP_REG_TYPE_INTERFACE, L"IPropertyNotifySink", L"{9BFBBC02-EFF1-101A-84ED-00AA00341D07}" },
    // Leave this registered, since the manifest does not specify a file.
    //{ FUSIONTESTP_REG_TYPE_CLASS,     L"oleaut32 marshaller (PSFactoryBuffer)", OLEAUT_MARSHALER_CLSID_STRING }
};

FUSIONTESTP_REG_DATA FusionTestpAtlRegData[1];

const HKEY FusionTestpHkeyRoots[] = { NULL, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT };
const PCWSTR FusionTestpClassStringRoots[] = { NULL, L"Software\\Classes\\CLSID\\", L"Software\\Classes\\CLSID\\", L"CLSID\\" };
const PCWSTR FusionTestpInterfaceStringRoots[] = { NULL, L"Software\\Classes\\Interface\\", L"Software\\Classes\\Interface\\", L"Interface\\" };
const PCWSTR* FusionTestpStringRoots[] = { NULL, FusionTestpInterfaceStringRoots, FusionTestpClassStringRoots};

#define FUSIONTESTP_REG_DELETE    (1)
#define FUSIONTESTP_REG_RESTORE   (2)
#define FUSIONTESTP_REG_BACKUP    (3)

BOOL FusionTestpEnumerateRegistryData(FUSIONTESTP_REG_DATA* RegData, ULONG Count, ULONG Mode)
{
    BOOL Success = FALSE;
    FN_PROLOG_WIN32(Success);

    for (ULONG i = 0 ; i != Count ; i += 1)
    {
        FUSIONTESTP_REG_DATA* const p = &RegData[i];
        ULONG MinRoot = 0;
        ULONG MaxRoot = 0;
        switch (Mode)
        {
        case FUSIONTESTP_REG_RESTORE:
        case FUSIONTESTP_REG_DELETE:
            MinRoot = p->Root;
            if (MinRoot == 0)
                continue;
            MaxRoot = MinRoot;
            break;
        case FUSIONTESTP_REG_BACKUP:
            MinRoot = 1;
            MaxRoot = 3;
            break;
        }
        //
        // It'd be nice if you could embed the if within a switch..
        //
        for (ULONG root = MinRoot ; root <= MaxRoot ; root += 1)
        {
            CFusionRegKey regKey;
            CFusionRegKey inprocServerKey;
            CStringBuffer stringBuffer;
            CFusionRegKey numMethodsKey;
            CFusionRegKey proxyStubClsidKey;
            DWORD dwSize = 0;
            DWORD dwType = 0;

            CFusionRegKey rootKey(FusionTestpHkeyRoots[root]);

            IFW32FALSE_EXIT(Win32Append(stringBuffer, FusionTestpStringRoots[p->Type][root]));
            IFW32FALSE_EXIT(Win32Append(stringBuffer, p->Guid));
            switch (Mode)
            {
            case FUSIONTESTP_REG_DELETE:
            case FUSIONTESTP_REG_BACKUP:
                rootKey.OpenSubKey(regKey, stringBuffer);
                break;
            case FUSIONTESTP_REG_RESTORE:
                IFW32FALSE_EXIT(rootKey.OpenOrCreateSubKey(regKey, stringBuffer));
                break;
            }
            if (regKey != regKey.GetInvalidValue())
            {
                switch (Mode)
                {
                case FUSIONTESTP_REG_BACKUP:
                    p->Root = root;
                    break;
                case FUSIONTESTP_REG_DELETE:
                case FUSIONTESTP_REG_RESTORE:
                    break;
                }
                switch (p->Type)
                {
                case FUSIONTESTP_REG_TYPE_CLASS:
                    switch (Mode)
                    {
                    case FUSIONTESTP_REG_BACKUP:
#define FusionTestpQueryRegString(hkey, name, value) \
    do { dwSize = sizeof(value); \
         RegQueryValueExW(hkey, name, NULL, &dwType, reinterpret_cast<BYTE*>(value), &dwSize); \
    } while(false)
                        if (regKey.OpenSubKey(inprocServerKey, L"InprocServer32"))
                        {
                            FusionTestpQueryRegString(inprocServerKey, NULL, p->InprocServerFilePath);
                            FusionTestpQueryRegString(inprocServerKey, L"ThreadingModel", p->ThreadingModel);
                        }
                        break;
                    case FUSIONTESTP_REG_RESTORE:
                        if (regKey.OpenOrCreateSubKey(inprocServerKey, L"InprocServer32"))
                        {
#define FusionTestpRegStringSize(x) static_cast<ULONG>(((wcslen(x) + 1)*sizeof((x)[0])))
#define FusionTestpSetRegString(hkey, name, value) \
    do { if (value[0] != 0) \
            RegSetValueExW(hkey, name, NULL, REG_SZ, reinterpret_cast<const BYTE*>(value), FusionTestpRegStringSize(value)); \
    } while(false)
                            FusionTestpSetRegString(inprocServerKey, NULL, p->InprocServerFilePath);
                            FusionTestpSetRegString(inprocServerKey, L"ThreadingModel", p->ThreadingModel);
                        }
                        break;
                    case FUSIONTESTP_REG_DELETE:
                        break;
                    }
                    break;
                case FUSIONTESTP_REG_TYPE_INTERFACE:
                    switch (Mode)
                    {
                    case FUSIONTESTP_REG_BACKUP:
                        FusionTestpQueryRegString(regKey, NULL, p->InterfaceName);
                        if (regKey.OpenSubKey(numMethodsKey, L"NumMethods"))
                            FusionTestpQueryRegString(numMethodsKey, NULL, p->NumMethods);
                        if (regKey.OpenSubKey(proxyStubClsidKey, L"ProxyStubClsid32"))
                            FusionTestpQueryRegString(proxyStubClsidKey, NULL, p->ProxyStubClsid);
                        break;
                    case FUSIONTESTP_REG_RESTORE:
                        FusionTestpSetRegString(regKey, NULL, p->InterfaceName);
                        if (regKey.OpenOrCreateSubKey(numMethodsKey, L"NumMethods"))
                            FusionTestpSetRegString(numMethodsKey, NULL, p->NumMethods);
                        if (regKey.OpenOrCreateSubKey(proxyStubClsidKey, L"ProxyStubClsid32"))
                            FusionTestpSetRegString(proxyStubClsidKey, NULL, p->ProxyStubClsid);
                    case FUSIONTESTP_REG_DELETE:
                        break;
                    }
                    break;
                }
                switch (Mode)
                {
                case FUSIONTESTP_REG_DELETE:
                    regKey.DestroyKeyTree();
                    break;
                case FUSIONTESTP_REG_BACKUP:
                case FUSIONTESTP_REG_RESTORE:
                    break;
                }
                break;
            }
        }
    }
    FN_EPILOG
}

#if 0 // Use CoWaitForMultipleHandles instead, it is much safer because it only
      // pumps particular messages.
void FusionTestpPumpMessages()
{
    MSG  msg;
    BOOL bRet;
    while ((bRet = ::GetMessageW(&msg, NULL, 0, 0)) != 0)
    { 
        if (bRet == -1)
            return;
        else
        {
            ::TranslateMessage(&msg); 
            if (::IsWindowUnicode(msg.hwnd))
                ::DispatchMessageW(&msg); 
            else
                ::DispatchMessage(&msg); 
        }
    }
}
#endif

HMODULE FusionTestpHmoduleFromComObject(IUnknown* unk)
{
    void** ppv = reinterpret_cast<void**>(unk);
    void* pv = *ppv;
    MEMORY_BASIC_INFORMATION MemBasicInfo = { 0 };
    SIZE_T dw = 0;

    if ((dw = Kernel32.VirtualQuery(pv, &MemBasicInfo, sizeof(MemBasicInfo))) == 0
        || (dw < RTL_SIZEOF_THROUGH_FIELD(MEMORY_BASIC_INFORMATION, BaseAddress)))
    {
        ::Trace("VirtualQuery(%p) failed %lu\n", pv, ::GetLastError());
        return NULL;
    }
    return reinterpret_cast<HMODULE>(MemBasicInfo.AllocationBase);
}


DWORD WINAPI FusionTestpMfcCreateAndMarshalThreadMain(LPVOID pvShouldBeAbleToMarshal)
{
    BOOL Success = FALSE;
    FN_PROLOG_WIN32(Success);
    HRESULT hr = 0;
    const bool ShouldBeAbleToMarshal = (pvShouldBeAbleToMarshal != NULL ? true : false);
    Ole32.CoInitialize(NULL);

    //
    // For each interface, make sure we can unmarshal at least one object.
    //
    for (ULONG InterfaceIndex = 0 ; InterfaceIndex != NUMBER_OF(::FusionTestpMfcRegData) ; InterfaceIndex += 1)
    {
        FUSIONTESTP_REG_DATA* const pi = &::FusionTestpMfcRegData[InterfaceIndex];

        switch (pi->Type)
        {
        case FUSIONTESTP_REG_TYPE_CLASS:
            continue;
        case FUSIONTESTP_REG_TYPE_INTERFACE:
            IID InterfaceId = { 0 };
            FUSIONTESTP_PLAIN_COM_POINTER(IUnknown) InterfaceIntoObjectInAnotherThread = NULL;

            IFCOMFAILED_EXIT(hr = Ole32.IIDFromString(const_cast<PWSTR>(pi->Guid), &InterfaceId));

            // nested loop..
            for (ULONG ClassIndex = 0 ;
                ClassIndex != NUMBER_OF(::FusionTestpMfcRegData) ;
                ClassIndex += 1)
            {
                CLSID ClassId = { 0 };
                FUSIONTESTP_REG_DATA* const pc = &::FusionTestpMfcRegData[ClassIndex];

                switch (pc->Type)
                {
                case FUSIONTESTP_REG_TYPE_INTERFACE:
                    continue;
                case FUSIONTESTP_REG_TYPE_CLASS:

                    WCHAR ModulePathInOtherThread[MAX_PATH];
                    ModulePathInOtherThread[0] = 0;

                    ASSERT(pc->GlobalInterfaceTableCookie != 0);
                    IFCOMFAILED_EXIT(hr = Ole32.CLSIDFromString(const_cast<PWSTR>(pc->Guid), &ClassId));

                    hr = g.GlobalInterfaceTable->GetInterfaceFromGlobal(
                        pc->GlobalInterfaceTableCookie, InterfaceId,
                        reinterpret_cast<void**>(&InterfaceIntoObjectInAnotherThread));

                    if (SUCCEEDED(hr))
                    {
                        IFW32FALSE_EXIT(Kernel32.GetModuleFileNameW(
                            ::FusionTestpHmoduleFromComObject(InterfaceIntoObjectInAnotherThread),
                            ModulePathInOtherThread, NUMBER_OF(ModulePathInOtherThread)));
                    }
                    if (SUCCEEDED(hr) && ShouldBeAbleToMarshal)
                    {
                        Trace("%s SUCCESSfully marshaled interface %ls on class %ls using proxy/stub in %ls\n",
                            __FUNCTION__, pi->Name, pc->Name, ModulePathInOtherThread);
                        g.Successes += 1;
                    }
                    else if (SUCCEEDED(hr) && !ShouldBeAbleToMarshal)
                    {
                        // unexpected success -> ERROR

                        Trace("%s FAILED to fail to marshal interface %ls on class %ls (using proxy/stub in %ls)\n",
                            __FUNCTION__, pi->Name, pc->Name, ModulePathInOtherThread);
                        g.Failures += 1;
                    }
                    else if (FAILED(hr) && ShouldBeAbleToMarshal)
                    {
                        // keep looping, try other objects
                    }
                    else if (FAILED(hr) && !ShouldBeAbleToMarshal)
                    {
                        // keep looping, make sure none succeed
                        //::Trace("%s OK Unable to marshal interface %ls (%ls) 0x%lx (fac 0x%lx code 0x%lx)\n", __FUNCTION__, pi->Name, pi->Guid, hr, HRESULT_FACILITY(hr), HRESULT_CODE(hr));
                    }
                    break;
                }
                if (InterfaceIntoObjectInAnotherThread != NULL && ShouldBeAbleToMarshal)
                {
                    // one successful unmarshal is enough
                    break;
                }
            }
            // use the nullness of InterfaceIntoObjectInAnotherThread as a summary of the loop
            if (InterfaceIntoObjectInAnotherThread == NULL && ShouldBeAbleToMarshal)
            {
                ::Trace("%s FAILURE Unable to marshal interface %ls (%ls)\n", __FUNCTION__, pi->Name, pi->Guid);
                g.Failures += 1;
            }
            else if (InterfaceIntoObjectInAnotherThread == NULL && !ShouldBeAbleToMarshal)
            {
                ::Trace("%s GOOD Unable to marshal interface %ls without actctx as expected\n", __FUNCTION__, pi->Name);
                g.Successes += 1;
            }
            break;
        }
    }
    Ole32.CoUninitialize();
    FN_EPILOG
}

BOOL TestMfcCreateAndMarshal()
{
    BOOL Success = FALSE;
    FN_PROLOG_WIN32(Success);

    ULONG i = 0;
    HRESULT hr = 0;
    HANDLE ThreadHandle = 0;
    DWORD Ignored = 0;

    CFusionActCtxHandle ToolsCrtActCtxHandle;

    ::FusionTestpEnumerateRegistryData(::FusionTestpMfcRegData, NUMBER_OF(::FusionTestpMfcRegData), FUSIONTESTP_REG_BACKUP);
    ::FusionTestpEnumerateRegistryData(::FusionTestpMfcRegData, NUMBER_OF(::FusionTestpMfcRegData), FUSIONTESTP_REG_DELETE);

    Ole32.CoInitialize(NULL);

    //
    // Verify that we cannot create any of the classes.
    //
    for (i = 0 ; i != NUMBER_OF(::FusionTestpMfcRegData) ; i += 1)
    {
        CSmartRef<IUnknown> unk;
        CLSID ClassId = { 0 };

        FUSIONTESTP_REG_DATA* const p = &::FusionTestpMfcRegData[i];
        switch (p->Type)
        {
        case FUSIONTESTP_REG_TYPE_INTERFACE:
            break;
        case FUSIONTESTP_REG_TYPE_CLASS:
            IFCOMFAILED_EXIT(hr = Ole32.CLSIDFromString(const_cast<PWSTR>(p->Guid), &ClassId));
            hr = Ole32.CoCreateInstance(ClassId, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, reinterpret_cast<void**>(&unk));
            if (SUCCEEDED(hr))
            {
                ::Trace("%s BAD, no registry, no actctx CoCreate(%ls) SUCCEEDED, not expected\n", __FUNCTION__, p->Name);
                g.Failures += 1;
            }
            else
            {
                ::Trace("%s GOOD, no registry, no actctx CoCreate(%ls) FAILed 0x%lx, as expected\n", __FUNCTION__, p->Name, hr);
                g.Successes += 1;
            }
            break;
        }
    }

    //
    // Create and activate the context.
    //

    ToolsCrtActCtxHandle = ::CreateActivationContextFromStringW(ToolsCrtManifest);
    if (ToolsCrtActCtxHandle == INVALID_HANDLE_VALUE)
        ::Trace("CreateActCtx(WindowsCrtManifest %p) failed %ld\n", WindowsCrtManifest, ::GetLastError());

    {
        CFusionActCtxScope ToolsCrtActCtxScope;
        if (!ToolsCrtActCtxScope.Win32Activate(ToolsCrtActCtxHandle))
            ::Trace("Activate(ToolsCrtActCtxHandle %p) failed %ld\n", ToolsCrtActCtxHandle, ::GetLastError());

        //
        // Now create each class and print the .dll it came from.
        // And put it in the global interface table for later unmarshalling.
        //

        IFCOMFAILED_EXIT(hr = Ole32.CoCreateInstance(CLSID_StdGlobalInterfaceTable,NULL, CLSCTX_INPROC_SERVER,
            IID_IGlobalInterfaceTable, reinterpret_cast<void**>(&g.GlobalInterfaceTable)));

        for (i = 0 ; i != NUMBER_OF(::FusionTestpMfcRegData)  ; i += 1)
        {
            CLSID ClassId = { 0 };

            FUSIONTESTP_REG_DATA* const p = &::FusionTestpMfcRegData[i];

            //
            // We are not supposed to be able to cocreate this here.
            //
            if (FusionpStrCmpI(p->Guid, OLEAUT_MARSHALER_CLSID_STRING) == 0)
                continue;

            switch (p->Type)
            {
            case FUSIONTESTP_REG_TYPE_INTERFACE:
                break;
            case FUSIONTESTP_REG_TYPE_CLASS:
                IFCOMFAILED_EXIT(hr = Ole32.CLSIDFromString(const_cast<PWSTR>(p->Guid), &ClassId));
                hr = Ole32.CoCreateInstance(ClassId, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown,
                    reinterpret_cast<void**>(&p->CoCreatedObject));
                if (FAILED(hr))
                {
                    Trace("%s Failure: CoCreate(%ls) FAILED\n", __FUNCTION__, p->Name);
                    g.Failures += 1;
                }
                else
                {
                    WCHAR ComObjectModule[MAX_PATH];
                    ComObjectModule[0] = 0;
                
                    IFW32FALSE_EXIT(Kernel32.GetModuleFileNameW(
                        ::FusionTestpHmoduleFromComObject(p->CoCreatedObject), ComObjectModule, NUMBER_OF(ComObjectModule)));
                    Trace("%s SUCCESSfully cocreated %p of type %ls from %ls with actctx influence\n",
                        __FUNCTION__, p->CoCreatedObject, p->Name, ComObjectModule);

                    g.Successes += 1;

#if 0
                    //
                    // Put it in the global interface table for later marshalling.
                    // It does not make sense to use IUnknown here, because ole32 can always
                    // marshal IUnknown itself without any proxy/stubs found via the
                    // registry or fusion (see also my special message pumper in vsee that
                    // takes advantage of this feature...)
                    //
                    IFW32FALSE_EXIT(
                        FusionTestpDynamicallyFindAnyInterfaceIntoObjectExceptIUnknown(
                            p->CoCreatedObject,
                            ::FusionTestpMfcRegData,
                            RTL_NUMBER_OF(::FusionTestpMfcRegData),
                            p->InterfaceIntoObjectInCreatingThread,
                            p->InterfaceIdOfObject
                            ));

                    IFCOMFAILED_EXIT(hr = g.GlobalInterfaceTable->RegisterInterfaceInGlobal(
                        p->InterfaceIntoObjectInCreatingThread,
                        p->InterfaceIdOfObject,
                        &p->GlobalInterfaceTableCookie
                        ));
#else
                    //
                    // It'll still have to look for the proxy/stub at unmarshal time. This is fine.
                    //
                    IFCOMFAILED_EXIT(hr = g.GlobalInterfaceTable->RegisterInterfaceInGlobal(
                        p->CoCreatedObject,
                        IID_IUnknown,
                        &p->GlobalInterfaceTableCookie
                        ));
#endif
                }
                break;
            }
        }
    }

    {
        CFusionActCtxScope ToolsCrtActCtxScope;
        if (!ToolsCrtActCtxScope.Win32Activate(ToolsCrtActCtxHandle))
            ::Trace("Activate(ToolsCrtActCtxHandle %p) failed %ld\n", ToolsCrtActCtxHandle, ::GetLastError());
        //
        // try marshalling with the actctx activated, it should work (not NULL => expected success==TRUE)
        //
        ThreadHandle = CreateThread(NULL, 0, FusionTestpMfcCreateAndMarshalThreadMain, &Ignored, 0, &Ignored);
        CoWaitForMultipleHandles(0, INFINITE, 1, &ThreadHandle, &Ignored);
        CloseHandle(ThreadHandle);
    }

#if 0
    //
    // If interfaces are _really_never_ changed, (but doesn't Fusion let you violate that?),
    // this test case isn't valid. COM does caching and prefills caches when you may not expect
    // (like when you put stuff in the GlobalInterfaceTable), and it does not invalidate its caches
    // because of actctx pushes and pops.
    //
    {
        //
        // try marshalling without the actctx activated, it should NOT work (NULL => expected success==FALSE)
        //
        ThreadHandle = CreateThread(NULL, 0, FusionTestpMfcCreateAndMarshalThreadMain, NULL, 0, &Ignored);
        CoWaitForMultipleHandles(0, INFINITE, 1, &ThreadHandle, &Ignored);
        CloseHandle(ThreadHandle);
    }
#endif


    Ole32.CoUninitialize();

    //::FusionTestpEnumerateRegistryData(::FusionTestpMfcRegData, NUMBER_OF(::FusionTestpMfcRegData), FUSIONTESTP_REG_RESTORE);

    FN_EPILOG
}


void TestAtlCreate()
{
    ::FusionTestpEnumerateRegistryData(FusionTestpAtlRegData, NUMBER_OF(FusionTestpAtlRegData), FUSIONTESTP_REG_BACKUP);
    ::FusionTestpEnumerateRegistryData(FusionTestpAtlRegData, NUMBER_OF(FusionTestpAtlRegData), FUSIONTESTP_REG_DELETE);

    ::FusionTestpEnumerateRegistryData(FusionTestpAtlRegData, NUMBER_OF(FusionTestpAtlRegData), FUSIONTESTP_REG_RESTORE);
}

BOOL TestPrivateSha1Impl(
    PCWSTR pcwszDirName
    )
{
    FN_PROLOG_WIN32
    CFusionArray<BYTE> rgbShaState;
    CFusionFile ffInputFile;
    BYTE bChunkletBuffer[4096];
    CSmallStringBuffer sbHashedString;
    DWORD dwReadData;
    HCRYPTPROV hProvider;
    HCRYPTHASH hHash;
    CFusionHash fHashObject;

    IFW32FALSE_EXIT(fHashObject.Win32Initialize(CALG_SHA1));
    IFW32FALSE_EXIT(ffInputFile.Win32CreateFile(
        pcwszDirName,
        GENERIC_READ,
        FILE_SHARE_READ,
        OPEN_EXISTING));

    IFW32FALSE_EXIT(CryptAcquireContextW(
        &hProvider, 
        NULL, 
        NULL, 
        PROV_RSA_FULL, 
        CRYPT_SILENT | CRYPT_VERIFYCONTEXT ));

    IFW32FALSE_EXIT(CryptCreateHash(
        hProvider, 
        CALG_SHA1, 
        0, 
        0, 
        &hHash ));

    do
    {
        IFW32FALSE_EXIT(::ReadFile(
            ffInputFile, 
            bChunkletBuffer, 
            sizeof(bChunkletBuffer), 
            &dwReadData, 
            NULL));
        IFW32FALSE_EXIT(fHashObject.Win32HashData(bChunkletBuffer, dwReadData));
        IFW32FALSE_EXIT(CryptHashData(hHash, bChunkletBuffer, dwReadData, 0));
    }
    while ( dwReadData != 0 );

    IFW32FALSE_EXIT(fHashObject.Win32GetValue(rgbShaState));

    wprintf(L"%ls (private) hashed to ", pcwszDirName);
    for ( SIZE_T n = 0; n < rgbShaState.GetSize(); n++ )
    {
        wprintf(L"%02x", rgbShaState[n]);
    }


    IFW32FALSE_EXIT(CryptGetHashParam(
        hHash, 
        HP_HASHVAL, 
        bChunkletBuffer, 
        &(dwReadData = sizeof(bChunkletBuffer)),
        0));

    wprintf(L"\n%ls (regular) hashed to ", pcwszDirName);
    for ( SIZE_T n = 0; n < dwReadData; n++ )
    {
        wprintf(L"%02x", bChunkletBuffer[n]);
    }
    
    IFW32FALSE_EXIT(CryptReleaseContext(hProvider, 0));

    FN_EPILOG
}

void TestAlignment()
{
    CCleanupBase* p = reinterpret_cast<CCleanupBase*>(ULONG_PTR(0xffff0000));
    SINGLE_LIST_ENTRY* q = p;

    printf("%p %Ix\n", q, ULONG_PTR(q) % 16);
}

void TestCreateActCtx_PE_flags0()
{
    WCHAR SyssetupDll[MAX_PATH * 2];
    ACTCTXW ActCtx = {sizeof(ActCtx)};
    CFusionActCtxHandle ActCtxHandle;

    GetSystemDirectoryW(SyssetupDll, MAX_PATH);
    wcscat(SyssetupDll, L"\\syssetup.dll");
    ActCtx.lpSource = SyssetupDll;

    printf("%s\n", ActCtxHandle.Win32Create(&ActCtx) ? "true" : "false");
}

void
TestUninstall(
    PCWSTR ManifestPath,
    PCWSTR ReferenceString
    )
{
    SXS_UNINSTALLW UninstallParameters = {sizeof(UninstallParameters)};
    SXS_INSTALL_REFERENCEW Reference = {sizeof(Reference)};
    PSXS_UNINSTALL_W_ROUTINE Uninstall = NULL;
    PSXS_QUERY_MANIFEST_INFORMATION QueryManifestInformation;
    BYTE ManifestInformationBuffer[1UL << 16];
    PSXS_MANIFEST_INFORMATION_BASIC ManifestBasicInfo = reinterpret_cast<PSXS_MANIFEST_INFORMATION_BASIC>(&ManifestInformationBuffer);
    DWORD Disposition = 0;
    BOOL  Success = FALSE;

    LoadSxs();
    GetSxsProc("SxsUninstallW", &Uninstall);
    GetSxsProc("SxsQueryManifestInformation", &QueryManifestInformation);

    Success = QueryManifestInformation(0, ManifestPath,
                SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC, 0, sizeof(ManifestInformationBuffer),
                ManifestBasicInfo, NULL);

    printf("QueryManifestInformation(%ls)->(%ls, %ls)\n", ManifestPath, ManifestBasicInfo->lpIdentity, ManifestBasicInfo->lpShortName);

    UninstallParameters.dwFlags |= SXS_UNINSTALL_FLAG_REFERENCE_VALID;
    UninstallParameters.lpInstallReference = &Reference;
    UninstallParameters.lpAssemblyIdentity = ManifestBasicInfo->lpIdentity;

    Reference.lpIdentifier = ReferenceString;
    Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;

    Success = Uninstall(&UninstallParameters, &Disposition);

    printf("TestUninstall(%ls, %ls) : %s, 0x%lx\n", ManifestPath, ReferenceString, Success ? "true" : "false", Disposition);
}

BOOL 
TestNewSxsInstallAPI(
    PCWSTR pcwszManifest
)
{
    BOOL fSuccess = FALSE;
    PSXS_INSTALL_W sxsInstallW = NULL;
    PSXS_UNINSTALL_ASSEMBLYW sxsUninstallW = NULL;
    SXS_INSTALLW Info = {sizeof(Info)};
    SXS_INSTALL_REFERENCEW Reference = {sizeof(Reference)};
    SXS_UNINSTALLW Uninstall = {sizeof(Uninstall)};
    DWORD dwDisposition;

    Info.dwFlags = SXS_INSTALL_FLAG_REPLACE_EXISTING |        
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
        SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID;
    Info.lpManifestPath = pcwszManifest;
    Info.lpCodebaseURL = Info.lpManifestPath;
    Info.lpReference = &Reference;
    Info.lpLogFileName = L"c:\\thelogfile";

    DWORD dwAttribute = GetFileAttributesW(pcwszManifest);
    if ( dwAttribute == 0xffffffff)  // non-exist
        goto Exit;
    if ( dwAttribute & FILE_ATTRIBUTE_DIRECTORY) // install from a directory recursively
    {
        Info.dwFlags |= SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE;
    }

    Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
    Reference.lpIdentifier = L"Sxs installation";

    LoadSxs();
    GetSxsProc(SXS_INSTALL_W, &sxsInstallW);
    GetSxsProc(SXS_UNINSTALL_ASSEMBLYW, &sxsUninstallW);

    if (!(*sxsInstallW)(&Info))
    {
        goto Exit;
    }

    Uninstall.dwFlags = SXS_UNINSTALL_FLAG_USE_INSTALL_LOG;
    Uninstall.lpInstallLogFile = L"c:\\thelogfile";
    
    if (!(*sxsUninstallW)(&Uninstall, &dwDisposition))
    {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}


VOID
NTAPI
SimpleContextNotification(
    IN ULONG NotificationType,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN const VOID *ActivationContextData,
    IN PVOID NotificationContext,
    IN PVOID NotificationData,
    IN OUT PBOOLEAN DisableNotification
    )
{
    switch (NotificationType)
    {
    case ACTIVATION_CONTEXT_NOTIFICATION_DESTROY:
        RTL_SOFT_VERIFY(NT_SUCCESS(NtUnmapViewOfSection(NtCurrentProcess(), (PVOID) ActivationContextData)));
        break;

    default:
        // Otherwise, we don't need to see this notification ever again.
        *DisableNotification = TRUE;
        break;
    }
}




BOOL
MakeActCtxFromCurrentSxsDll(
    PCWSTR pcwszFileName,
    HANDLE *phActCtx
    )
{
    FN_PROLOG_WIN32;

    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters = {0};
    PACTIVATION_CONTEXT pContextCreated = NULL;
    CStringBuffer   AssemblyDirectory;
    CFileStream     SourceManifestStream;
    PVOID           pvMappedSection = NULL;
    NTSTATUS status;
    BOOL (WINAPI *pfnSxsGenerateActivationContext)(PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters);

    *phActCtx = INVALID_HANDLE_VALUE;

    LoadSxs();
    GetSxsProc("SxsGenerateActivationContext", &pfnSxsGenerateActivationContext);

    IFW32FALSE_EXIT(SourceManifestStream.OpenForRead(pcwszFileName, CImpersonationData(), FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN));
    Parameters.Manifest.Path = pcwszFileName;
    Parameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
    Parameters.Manifest.Stream = &SourceManifestStream;

    IFW32FALSE_EXIT(AssemblyDirectory.Win32Assign(pcwszFileName, ::wcslen(pcwszFileName)));
    AssemblyDirectory.RemoveLastPathElement();
    Parameters.AssemblyDirectory = AssemblyDirectory;
    Parameters.ProcessorArchitecture = 0;
    Parameters.LangId = GetUserDefaultUILanguage();

    IFW32FALSE_EXIT(pfnSxsGenerateActivationContext(&Parameters));
    IFW32NULL_EXIT(pvMappedSection = MapViewOfFile(Parameters.SectionObjectHandle, FILE_MAP_READ, 0, 0, 0));

    status = RtlCreateActivationContext(
        0,
        pvMappedSection,
        0,
        SimpleContextNotification,
        NULL,
        &pContextCreated);

    if (!NT_SUCCESS(status)) {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(RtlCreateActivationContext, RtlNtStatusToDosError(status));
    }

    *phActCtx = pContextCreated;

    FN_EPILOG;
}
    




BOOL SimpleTestFindAndUseSurrogateInformation(PCWSTR filename, PCWSTR GuidToDisplay)
{
    FN_PROLOG_WIN32;
    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters = {0};
    BOOL (WINAPI *pfnSxsGenerateActivationContext)(PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters);
    CFileStream         SourceManifestStream;
    CStringBuffer       AssemblyDirectory;
    BOOL fCreatedOk = false;
    GUID GuidToFind;
    
    LoadSxs();
    GetSxsProc("SxsGenerateActivationContext", &pfnSxsGenerateActivationContext);

    IFW32FALSE_EXIT(SxspParseGUID(GuidToDisplay, ::wcslen(GuidToDisplay), GuidToFind));

    IFW32FALSE_EXIT(SourceManifestStream.OpenForRead(filename, CImpersonationData(), FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN));
    Parameters.Manifest.Path = filename;
    Parameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
    Parameters.Manifest.Stream = &SourceManifestStream;

    IFW32FALSE_EXIT(AssemblyDirectory.Win32Assign(filename, ::wcslen(filename)));
    AssemblyDirectory.RemoveLastPathElement();
    Parameters.AssemblyDirectory = AssemblyDirectory;
    Parameters.ProcessorArchitecture = 0;
    Parameters.LangId = GetUserDefaultUILanguage();

    fCreatedOk = pfnSxsGenerateActivationContext(&Parameters);

    //
    // Spiffy, we've got the thing.
    //
    if (fCreatedOk && (Parameters.SectionObjectHandle != INVALID_HANDLE_VALUE) && (Parameters.SectionObjectHandle != NULL))
    {
        PACTIVATION_CONTEXT pActivationContext = NULL;
        NTSTATUS status;
        ULONG_PTR ulCookie;
        ACTCTX_SECTION_KEYED_DATA Data = { sizeof(Data) };
        // PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE pFoundData;
        /*
        status = RtlCreateActivationContext(
            0,
            Parameters.SectionObjectHandle,
            0,
            SimpleContextNotification,
            NULL,
            &pActivationContext);
        */
        if (ActivateActCtx(static_cast<HANDLE>(pActivationContext), &ulCookie))
        {
            status = FindActCtxSectionGuid(
                0,
                NULL,
                ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES,
                &GuidToFind,
                &Data);
            DeactivateActCtx(0, ulCookie);
            ReleaseActCtx(static_cast<HANDLE>(pActivationContext));
        }
    }

    FN_EPILOG
}

void TestFindAndUseSurrogateInformation(PCWSTR pcwsz, PCWSTR GuidToDisplay)
{
    ACTCTXW actctx = { sizeof(actctx) };
    HANDLE hActCtx = INVALID_HANDLE_VALUE;
    GUID GuidToFind;
    ACTCTX_SECTION_KEYED_DATA Data = { sizeof(Data) };
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE pFoundData;
    BOOL status;
    ULONG_PTR ulCookie;

    SxspParseGUID(GuidToDisplay, wcslen(GuidToDisplay), GuidToFind);

    actctx.lpSource = pcwsz;
    hActCtx = CreateActCtxW(&actctx);

    if ((hActCtx == INVALID_HANDLE_VALUE) || (hActCtx == NULL))
    {
        printf("Sorry, can't find file %ls, error %d", pcwsz, ::GetLastError());
        return;
    }

    ActivateActCtx(hActCtx, &ulCookie);
    __try {
        status = FindActCtxSectionGuid(
            0, 
            NULL, 
            ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES,
            &GuidToFind, 
            &Data);

        pFoundData = (PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE)Data.lpData;

        wprintf(L"The guid %ls maps to assembly '%.*ls', runtime version '%.*ls', module '%.*ls'\n",
            GuidToDisplay,
            pFoundData->TypeNameLength / 2,
            (PCWSTR)(((PBYTE)pFoundData) + pFoundData->TypeNameOffset),
            pFoundData->VersionLength / 2,
            (PCWSTR)(((PBYTE)pFoundData) + pFoundData->VersionOffset));

    }
    __finally
    {
        if (ulCookie != 0)
            DeactivateActCtx(0, ulCookie);
    }

    ReleaseActCtx(hActCtx);

}



BOOL
TestSxsExportedSurrogateStuff(
    PCWSTR pcwszManifest,
    PCWSTR pcwszWhat,
    PCWSTR pcwszData
    )
{
    FN_PROLOG_WIN32;
    
    PFN_SXS_FIND_CLR_CLASS_INFO pfnClrClass = NULL;
    PFN_SXS_FIND_CLR_SURROGATE_INFO pfnClrSurrogate = NULL;
    PFN_SXS_LOOKUP_CLR_GUID pfnClrLookup = NULL;
    SIZE_T cbRequired = 0;
    BOOL f = false;
    PVOID pvTargetBuffer = NULL;
    PCSXS_CLR_SURROGATE_INFORMATION pSurrogateInfo = NULL;
    PCSXS_CLR_CLASS_INFORMATION pClassInfo = NULL;
    CFusionActCtxHandle hActCtxCreated;
    CFusionActCtxScope ActivationScope;
    ACTCTXW ActCtxStruct = {sizeof(ActCtxStruct)};

    LoadSxs();
    GetSxsProc(SXS_FIND_CLR_SURROGATE_INFO, &pfnClrSurrogate);
    GetSxsProc(SXS_FIND_CLR_CLASS_INFO, &pfnClrClass);
    GetSxsProc(SXS_LOOKUP_CLR_GUID, &pfnClrLookup);

    IFW32FALSE_EXIT(MakeActCtxFromCurrentSxsDll(pcwszManifest, &hActCtxCreated));
    IFW32FALSE_EXIT(ActivationScope.Win32Activate(hActCtxCreated));

    if (lstrcmpiW(pcwszWhat, L"clrprogid") == 0)
    {
        f = pfnClrClass(
            SXS_FIND_CLR_CLASS_SEARCH_PROGID | SXS_FIND_CLR_CLASS_GET_ALL,
            (PVOID)pcwszData,
            hActCtxCreated,
            NULL, 0, &cbRequired);

        if (!f) 
        {
            SIZE_T cbWritten = 0;
            pvTargetBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired);
            pfnClrClass(
                SXS_FIND_CLR_CLASS_SEARCH_PROGID | SXS_FIND_CLR_CLASS_GET_ALL,
                (PVOID)pcwszData,
                hActCtxCreated,
                pvTargetBuffer,
                cbRequired,
                &cbWritten);

            pClassInfo = (PCSXS_CLR_CLASS_INFORMATION)pvTargetBuffer;
        }
    }
    else if (lstrcmpiW(pcwszWhat, L"clrguid") == 0)
    {
        GUID ParsedGuid;
        IFW32FALSE_EXIT(SxspParseGUID(pcwszData, wcslen(pcwszData), ParsedGuid));

        f = pfnClrClass(
            SXS_FIND_CLR_CLASS_SEARCH_GUID | SXS_FIND_CLR_CLASS_GET_ALL,
            (PVOID)&ParsedGuid,
            hActCtxCreated,
            NULL, 0, &cbRequired);

        if (!f)
        {
            SIZE_T cbWritten = 0;
            pvTargetBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired);
            pfnClrClass(
                SXS_FIND_CLR_CLASS_SEARCH_GUID | SXS_FIND_CLR_CLASS_GET_ALL,
                (PVOID)&ParsedGuid,
                hActCtxCreated,
                pvTargetBuffer, cbRequired, &cbWritten);

            pClassInfo = (PCSXS_CLR_CLASS_INFORMATION)pvTargetBuffer;
        }
        
    }
    else if (lstrcmpiW(pcwszWhat, L"lookup") == 0)
    {
        GUID ParsedGuid;
        PCSXS_GUID_INFORMATION_CLR pGuidInfo = NULL;

        IFW32FALSE_EXIT(SxspParseGUID(pcwszData, wcslen(pcwszData), ParsedGuid));

        f = pfnClrLookup(
            SXS_LOOKUP_CLR_GUID_FIND_ANY, 
            &ParsedGuid,
            hActCtxCreated, 
            NULL, 
            0, 
            &cbRequired);

        if (!f)
        {
            SIZE_T cbWritten = 0;
            pvTargetBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired);
            
            f = pfnClrLookup(
                SXS_LOOKUP_CLR_GUID_FIND_ANY,
                &ParsedGuid,
                hActCtxCreated, 
                pvTargetBuffer, 
                cbRequired, 
                &cbWritten);

            pGuidInfo = (PCSXS_GUID_INFORMATION_CLR)pvTargetBuffer;
        }
    }
    else if (lstrcmpiW(pcwszWhat, L"surrogate") == 0)
    {
        GUID ParsedGuid;

        IFW32FALSE_EXIT(SxspParseGUID(pcwszData, wcslen(pcwszData), ParsedGuid));

        f = pfnClrSurrogate(
            SXS_FIND_CLR_SURROGATE_USE_ACTCTX | SXS_FIND_CLR_SURROGATE_GET_ALL,
            &ParsedGuid,
            hActCtxCreated,
            NULL, 0, &cbRequired);

        if (!f)
        {
            SIZE_T cbWritten = 0;
            pvTargetBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired);
            pfnClrSurrogate(
                SXS_FIND_CLR_SURROGATE_USE_ACTCTX | SXS_FIND_CLR_SURROGATE_GET_ALL,
                &ParsedGuid,
                hActCtxCreated,
                pvTargetBuffer, cbRequired, &cbWritten);

            pSurrogateInfo = (PCSXS_CLR_SURROGATE_INFORMATION)pvTargetBuffer;
        }        
    }

    FN_EPILOG;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\xpman1\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\teb.c ===
#define _WIN32_WINNT 0x0501
#include <stdio.h>
#include <assert.h>
#include <limits.h>
#include <stddef.h>

void Test1()
{
#if 0
    typedef struct {
        int i;
        struct {
            int j;
            char pseudo_pointer[sizeof(void*)];
        };
    } Struct1;

    typedef struct {
        int i;
        struct {
            int j;
            void* pointer;
        };
    } Struct2;

    typedef struct {
        int i;
        struct {
            int j;
            int k;
            void* pointer;
        };
    } Struct3;

#define X(x) printf("Win%ld %s %ld\n", (long)(sizeof(void*)*CHAR_BIT), #x, (long)x)
    X(sizeof(Struct1));
    X(sizeof(Struct2));
    X(sizeof(Struct3));

    X(offsetof(Struct1, j));
    X(offsetof(Struct2, j));
    X(offsetof(Struct3, j));

    X(offsetof(Struct1, pseudo_pointer));
    X(offsetof(Struct2, pointer));
    X(offsetof(Struct3, pointer));
#undef X
#endif
}

#include "nt.h"
#include "ntrtl.h"
#include "wow64t.h"

#if !defined(RTL_PADDING_BETWEEN_FIELDS)
#define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2) \
    ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) \
        ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) \
        : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))
#endif

void Test2()
{
#undef TEB_MEMBER
#define TEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(TEB, name), (long)RTL_FIELD_SIZE(TEB, name));
#ifdef _IA64_
#define TEB_MEMBER_IA64(name) TEB_MEMBER(name)
#else
#define TEB_MEMBER_IA64(name) /* nothing */
#endif
#define TEB TEB
    printf("\n\nnative TEB %ld\n\n", (long)sizeof(TEB));
    #include "teb.h"
#undef TEB

#undef TEB_MEMBER
#define TEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(TEB32, name), (long)RTL_FIELD_SIZE(TEB32, name));
#undef TEB_MEMBER_IA64
#define TEB_MEMBER_IA64(name) /* nothing */
    printf("\n\nTEB32 %ld\n\n", (long)sizeof(TEB32));
    #include "teb.h"

#undef TEB_MEMBER
#define TEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(TEB64, name), (long)RTL_FIELD_SIZE(TEB64, name));
#if defined(_X86_)
#undef TEB_MEMBER_IA64
#define TEB_MEMBER_IA64(name) TEB_MEMBER(name)
#endif
#define TEB64 TEB64
    printf("\n\nTEB64 %ld\n\n", (long)sizeof(TEB64));
    #include "teb.h"
#undef TEB64

#define PEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(PEB, name), (long)RTL_FIELD_SIZE(PEB, name));
#define PEB PEB
    printf("\n\nnative PEB %ld\n\n", (long)sizeof(PEB));
    #include "peb.h"
#undef PEB

#undef PEB_MEMBER
#define PEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(PEB32, name), (long)RTL_FIELD_SIZE(PEB32, name));
    printf("\n\nPEB32 %ld\n\n", (long)sizeof(PEB32));
    #include "peb.h"

#undef PEB_MEMBER
#define PEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(PEB64, name), (long)RTL_FIELD_SIZE(PEB64, name));
    printf("\n\nPEB64 %ld\n\n", (long)sizeof(PEB64));
    #include "peb.h"

    printf("\n\npadding\n\n");

    printf("TEB %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB, ActivationContextStack, ExceptionCode));
    printf("TEB %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB, ExceptionCode, ActivationContextStack));
    printf("TEB32 %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB32, ActivationContextStack, ExceptionCode));
    printf("TEB32 %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB32, ExceptionCode, ActivationContextStack));
    printf("TEB64 %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB64, ActivationContextStack, ExceptionCode));
    printf("TEB64 %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB64, ExceptionCode, ActivationContextStack));

#if defined(SD_BRANCH_LAB01_FUSION)
    if ((sizeof(PVOID)*CHAR_BIT) == 32)
    {
        assert(sizeof(PEB) == sizeof(PEB32));
        assert(sizeof(TEB) == sizeof(TEB32));
    }
    if ((sizeof(PVOID)*CHAR_BIT) == 64)
    {
        assert(sizeof(PEB) == sizeof(PEB64));
        assert(sizeof(TEB) == sizeof(TEB64));
    }
#endif
}

int main()
{
    Test1();
    Test2();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\testdata\hello\exemultires\makefile.inc ===
$(O)\MultiExe.res: $(O)\2.manifest $(O)\3.manifest

.SUFFIXES: .manifest-cpp .manifest

{}.manifest-cpp{$(O)}.manifest:
    $(C_PREPROCESSOR_NAME) $(SXS_MANIFEST_DEFINES) $(C_PREPROCESSOR_FLAGS) $< > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\xpman12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\testdata\hello\exe.c ===
#include "windows.h"
#include <stdio.h>

#define FOUR_K 0x1000

int __cdecl wmain(int argc, wchar_t** argv)
{
    WCHAR Buffer[2] = {0};
    HANDLE Dll;
    int i;
    int LoadLibraryError;
    int LoadStringError;
    int Error;

    for (i = 0 ; i < 2 ; ++i)
    {
        // steal the address to force a collision on the next load
        if (i == 1)
        {
            fprintf(stderr, "VirtualAlloc:%p\n", VirtualAlloc(Dll, 1, MEM_RESERVE, PAGE_READONLY));
            fprintf(stderr, "Error:%d\n", Error = GetLastError());
        }

        Dll = LoadLibraryW(L"Dll");
        LoadLibraryError = GetLastError();
        Buffer[0] = 0;
        LoadStringW(Dll, 1, Buffer, sizeof(Buffer)/sizeof(Buffer[0]));
        LoadStringError = GetLastError();
        FreeLibrary(Dll);
        //ZeroMemory(Dll, FOUR_K);
        fprintf(stderr, 
            "%ls: Dll:%p, String:%ls, LoadLibraryError:%d, LoadStringError:%d.\n",
            argv[0],
            Dll,
            Buffer,
            LoadLibraryError,
            LoadStringError);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\xpman2\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\xpman13\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

FUSION_BUILD_TYPE=WIN
!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

MAJORCOMP=fusion
MINORCOMP=sxstest

TARGETPATH=obj
DLLDEF=..\$(TARGETNAME).def

#LINK_TIME_CODE_GENERATION=1

C_DEFINES=$(C_DEFINES) $(SXS_MANIFEST_DEFINES)

ISOLATION_AWARE_ENABLED=1

USE_IOSTREAM=1
USE_CRTDLL=1
USE_NATIVE_EH=1
USE_STL=1

# -fixed:no because we turn the .exe into a .dll at runtime
LINKER_FLAGS=$(LINKER_FLAGS) -fixed:no

INCLUDES= \
 $(FUSION_PATH)\sxs; \
 $(FUSION_INC_PATH); \
 $(FUSION_PATH)\xmlparser; \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\eventlog\whistler\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(INCLUDES); \
 ..; \
 $(FUSION_PATH)\dll\whistler; \
 $(FUSION_PATH)\dll\; \
 $(COM_INC_PATH)

UMTYPE=console
UMENTRYABS=Entry

LINKLIBS= \
 $(FUSION_PATH)\tests\sxstest\lib\$(O)\sxstestlib.lib \

TARGETLIBS= \
 $(TARGETLIBS) \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxsmain.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxs1.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxs2.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)utils.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)xmlparser.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)id.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)eventlog.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)uuid.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)xml.lib \
!if !$(AMD64)
 $(SDK_LIB_PATH)\chkstk.obj \
!endif
 $(SDK_LIB_PATH)\noenv.obj \
 $(SDK_LIB_PATH)\noarg.obj \
 $(SDK_LIB_PATH)\msvcrt.lib \
 $(SDK_LIB_PATH)\ntdll.lib \
 $(SDK_LIB_PATH)\uuid.lib \
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\kernl32p.lib \
 $(SDK_LIB_PATH)\advapi32.lib \
 $(SDK_LIB_PATH)\crypt32.lib \
 $(SDK_LIB_PATH)\rpcrt4.lib \
 $(SDK_LIB_PATH)\setupapi.lib \
 $(SDK_LIB_PATH)\imagehlp.lib \
 $(SDK_LIB_PATH)\user32.lib \
 $(SDK_LIB_PATH)\wintrust.lib \
 $(SDK_LIB_PATH)\mpr.lib \
 $(SDK_LIB_PATH)\ole32.lib \
 $(SDK_LIB_PATH)\oleaut32.lib \
 $(SDK_LIB_PATH)\comctl32.lib \

!ifdef MAN1
C_DEFINES=$(C_DEFINES) -DMAN1
SXS_MANIFEST_RESOURCE_ID=1
!endif
!ifdef MAN2
C_DEFINES=$(C_DEFINES) -DMAN2
SXS_MANIFEST_RESOURCE_ID=2
!endif
!ifdef MAN3
C_DEFINES=$(C_DEFINES) -DMAN3
SXS_MANIFEST_RESOURCE_ID=3
!endif

!if !defined(NOMAN)
SXS_MANIFEST=..\sxstest.manifest
SXS_ASSEMBLY_NAME=Microsoft.Windows.SideBySide.Test
SXS_NO_BINPLACE=1
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
!if !defined(MANFILE)
SXS_MANIFEST_IN_RESOURCES=1
!endif
NO_BINPLACE=1
!endif

!if "$(MAN1)$(MAN2)$(MAN3)" == ""
NUMBER_OF_MANIFESTS=0
!elseif "$(MAN1)$(MAN2)$(MAN3)" == "1"
NUMBER_OF_MANIFESTS=1
!elseif "$(MAN1)$(MAN2)$(MAN3)" == "11"
NUMBER_OF_MANIFESTS=2
!elseif "$(MAN1)$(MAN2)$(MAN3)" == "111"
NUMBER_OF_MANIFESTS=3
!endif
C_DEFINES=$(C_DEFINES) -DNUMBER_OF_MANIFESTS=$(NUMBER_OF_MANIFESTS)
!if "$(NUMBER_OF_MANIFESTS)" != "0" && "$(NUMBER_OF_MANIFESTS)" != "1"
USE_MAKEFILE_INC=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\xpman23\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\xpman3\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\whistler\gauntlet\test.c ===
this is a test
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\xpmanfile\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tests\sxstest\testdata\hello\exemultires\multiexe.c ===
#include "windows.h"
#include <stdio.h>
#include <stdlib.h>

BOOL
ExtractResourceToFile(
    HMODULE Module,
    PCWSTR  ResourceType,
    PCWSTR  ResourceName,
    WCHAR*  TempFilePath,
    HANDLE* TempFileHandle
    )
{
    WCHAR TempDirectory[MAX_PATH];
    DWORD Dword = 0;
    int ResourceSize = 0;
    void* ResourceAddress = 0;
    HRSRC ResourceInfo = 0;
    BOOL Success = FALSE;

    TempFilePath[0] = 0;
    TempDirectory[0] = 0;
    *TempFileHandle = 0;

#define X(x) do { if (!(x)) { printf("%s failed\n", #x); goto Exit; } } while(0)
    X(ResourceInfo = FindResourceW(Module, ResourceName, ResourceType));
    X(ResourceAddress = LockResource(LoadResource(Module, ResourceInfo)));
    X(ResourceSize = SizeofResource(Module, ResourceInfo));
    X(GetTempPathW(RTL_NUMBER_OF(TempDirectory), TempDirectory));
    X(GetTempFileNameW(TempDirectory, NULL, 0, TempFilePath));
    *TempFileHandle = CreateFileW(TempFilePath, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    X(*TempFileHandle != INVALID_HANDLE_VALUE);
    X(WriteFile(*TempFileHandle, ResourceAddress, ResourceSize, &Dword, NULL));
#undef X
    Success = TRUE;
Exit:
    if (!Success)
    {
        int Error;
        printf("%s() failed %d\n", __FUNCTION__, Error = GetLastError());
    }
    return Success;
}

int __cdecl wmain(int argc, wchar_t** argv)
{
    PCWSTR BaseNames[]  = { L"dll", L"DLL",  L"Dll" };
    PCWSTR Extensions[] = { L"", L".dll", L".DLL",  L".Dll" };
    const static int Flags1[] = { 0, LOAD_LIBRARY_AS_DATAFILE };
    const static int Flags2[] = { LOAD_LIBRARY_AS_DATAFILE, 0 };
    const int* Flags = Flags1;
    const int NumberOfFlags = 2;
    int i=0, j=0, k=0;
    const PCWSTR CommandLine = GetCommandLineW();

    struct ActivationContext
    {
        HANDLE Handle;
        ULONG  Cookie;
    } ActivationContexts[2] = {0}; // INVALID_HANDLE_VALUE is not convenient.
    HANDLE Handle = NULL;
    INT    ResourceId = 0;
    INT    Error = 0;
    WCHAR  Argv0[MAX_PATH];
    PWSTR  FilePart = 0;
    //
    // This is to target this test at older sxs without the resource feature.
    //
    DWORD  ResourceFlag = ACTCTX_FLAG_RESOURCE_NAME_VALID;

    if ((wcsstr(CommandLine, L"-swapFlagOrder") != 0) ||
        (wcsstr(CommandLine, L"-swapflagorder") != 0) ||
        (wcsstr(CommandLine, L"-swap-flag-order") != 0) ||
        (wcsstr(CommandLine, L"-alterFlagOrder") != 0) ||
        (wcsstr(CommandLine, L"-alterflagorder") != 0) ||
        (wcsstr(CommandLine, L"-alter-flag-order") != 0))
    {
       Flags = Flags2;
    }

    if ((wcsstr(CommandLine, L"-filesInsteadOfResources") != 0) ||
        (wcsstr(CommandLine, L"-filesinsteadofresources") != 0) ||
        (wcsstr(CommandLine, L"-files-instead-of-resources") != 0))
    {
        ResourceFlag = 0;
    }

    if ((wcsstr(CommandLine, L"-alterEmptyExtensionOrder") != 0) ||
        (wcsstr(CommandLine, L"-alteremptyextensionorder") != 0) ||
        (wcsstr(CommandLine, L"-alter-empty-extension-order") != 0))
    {
        Extensions[0] = Extensions[1];
        Extensions[1] = L"";
    }

    if ((wcsstr(CommandLine, L"-alterCaseOrder") != 0) ||
        (wcsstr(CommandLine, L"-altercaseorder") != 0) ||
        (wcsstr(CommandLine, L"-alter-case-order") != 0))
    {
        // flip the case of each letter, this actually creates previously nonexistant
        // cases: .dLL
        WCHAR* String = 0;
        const WCHAR* ConstString = 0;
        for (i = 0 ; i < RTL_NUMBER_OF(BaseNames) ; ++i)
        {
            ConstString = BaseNames[i];
#define X \
            if (ConstString) \
            { \
                String = _wcsdup(ConstString); \
                BaseNames[i] = String; \
                while (*String) \
                    if (*String != '.') *String++ ^= 0x20; \
                    else String++; \
            }
            X
        }
        for (i = 0 ; i < RTL_NUMBER_OF(Extensions) ; ++i)
        {
            ConstString = Extensions[i];
            X
#undef X
        }
    }

    //printf("argv[0]: %ls\n", argv[0]);
    Argv0[0] = 0;
    if (!GetFullPathNameW(argv[0], RTL_NUMBER_OF(Argv0), Argv0, NULL))
    {
        printf("GetFullPathNameW(%ls) failed %d\n", argv[0], Error = GetLastError());
        exit(Error);
    }
    //printf("Argv0: %ls\n", Argv0);
    __try
    {
        for (ResourceId = 0 ; ResourceId < RTL_NUMBER_OF(ActivationContexts) ; ++ResourceId)
        {
            HANDLE ManifestFileHandle = 0;
            WCHAR  ManifestFile[MAX_PATH];
            ACTCTXW CreateActivationContextParameters = {sizeof(CreateActivationContextParameters)};
            ManifestFile[0] = 0;

            CreateActivationContextParameters.dwFlags = ResourceFlag;
            CreateActivationContextParameters.lpResourceName = (PCWSTR)(INT_PTR)(ResourceId + 2);
            CreateActivationContextParameters.lpSource = Argv0;

            if (!ResourceFlag)
            {
                ExtractResourceToFile(
                    NULL,
                    //GetModuleHandleW(NULL),
                    (PCWSTR)RT_MANIFEST,
                    CreateActivationContextParameters.lpResourceName,
                    ManifestFile,
                    &ManifestFileHandle);
                CreateActivationContextParameters.lpSource = ManifestFile;

                printf("dwFlags:0x%lx\n", CreateActivationContextParameters.dwFlags);
                printf("lpSource:%ls\n", CreateActivationContextParameters.lpSource);
            }

            // switch access to readonly
            // keep the file open to prevent deletion
            if (ManifestFileHandle)
            {
                if (!DuplicateHandle(
                    GetCurrentProcess(),
                    ManifestFileHandle,
                    GetCurrentProcess(),
                    &ManifestFileHandle,
                    GENERIC_READ,
                    FALSE,
                    DUPLICATE_CLOSE_SOURCE))
                {
                    ManifestFileHandle = 0;
                }
            }

            Handle = CreateActCtxW(&CreateActivationContextParameters);

            if (Handle == INVALID_HANDLE_VALUE)
                Error = GetLastError();
            if (ManifestFileHandle)
            {
                CloseHandle(ManifestFileHandle);
                ManifestFileHandle = 0;
            }
            if (ManifestFile[0])
            {
                //DeleteFileW(ManifestFile);
                ManifestFile[0] = 0;
            }
            if (Handle == INVALID_HANDLE_VALUE)
            {
                printf("CreateActCtxW(ResourceId:%d) failed %d\n", (ResourceId + 2), Error);
            }
            else
            {
                printf("CreateActCtxW(ResourceId:%d):%p\n", (ResourceId + 2), Handle);
                if (!ActivateActCtx(Handle, &ActivationContexts[ResourceId].Cookie))
                {
                    printf("ActivateActCtx(ResourceId:%d, Handle:%p) failed %d\n", (ResourceId + 2), Handle, Error = GetLastError());
                    ReleaseActCtx(Handle);
                }
                else
                {
                    ActivationContexts[ResourceId].Handle = Handle;
                }
            }
            for (i = 0 ; i < RTL_NUMBER_OF(BaseNames) ; ++i)
            {
                for (j = 0 ; j < RTL_NUMBER_OF(Extensions) ; ++j)
                {
                    for (k = 0 ; k < NumberOfFlags ; ++k)
                    {
                        HRSRC  ResourceInfo = NULL;
                        WCHAR  StringResourceBuffer[2] = {0};
                        HANDLE Dll = 0;
                        WCHAR  Name[8+1+3+1];
                        WCHAR  ModuleNameBuffer[MAX_PATH];
                        Name[0] = 0;
                        ModuleNameBuffer[0] = 0;

                        wcscat(Name, BaseNames[i]);
                        wcscat(Name, Extensions[j]);

                        Dll = LoadLibraryExW(Name, NULL, Flags[k]);
                        Error = GetLastError();
                        if (Dll)
                        {
                            LoadStringW(Dll, 1, StringResourceBuffer, RTL_NUMBER_OF(StringResourceBuffer));
                            GetModuleFileNameW(Dll, ModuleNameBuffer, RTL_NUMBER_OF(ModuleNameBuffer));
                            ResourceInfo = FindResourceW(Dll, (PCWSTR)1, (PCWSTR)RT_STRING);
                            FreeLibrary(Dll);
                        }
                        printf(
                            "LoadLibraryExW(%ls, 0x%x):%p, Error:%d, ResourceInfo:%p, String:%ls, ModuleName:%ls.\n",
                            Name,
                            Flags[k],
                            Dll,
                            Error,
                            ResourceInfo,
                            StringResourceBuffer,
                            ModuleNameBuffer);
                    }
                }
            }
        }
        for (ResourceId = RTL_NUMBER_OF(ActivationContexts) - 1 ; ResourceId >= 0 ; --ResourceId)
        {
            Handle = ActivationContexts[ResourceId].Handle;
            if (Handle)
            {
                ULONG Cookie = ActivationContexts[ResourceId].Cookie;
                if (!DeactivateActCtx(0, Cookie))
                {
                    printf(
                        "DeactivateActCtx(ResourceId:%d, Handle:%p, Cookie:0x%lx) failed %d\n",
                        ResourceId + 2,
                        Handle,
                        Cookie,
                        Error = GetLastError());
                }
                ReleaseActCtx(Handle);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("0x%x\n", Error = GetExceptionCode());
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\buildtool\manglers.h ===
#pragma once

class CPostbuildProcessListEntry;

bool GenerateCatalogContents( const CPostbuildProcessListEntry& item );
bool UpdateManifestHashes( const CPostbuildProcessListEntry& item );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\buildtool\catalogs.cpp ===
#include "stdinc.h"

bool GenerateCatalogContents( const CPostbuildProcessListEntry& item )
{
    string cdfOutputPath;
    string catalogName;
    ofstream cdfOutput;

    cdfOutputPath = item.getManifestPathOnly() + string("\\") + item.getManifestFileName() + string (".cdf");
    catalogName = item.getManifestFileName().substr( 0, item.getManifestFileName().find_last_of('.') ) + string(".cat");

    cdfOutput.open( cdfOutputPath.c_str() );
    if ( !cdfOutput.is_open() ) {
        stringstream ss;
        ss << "Can't open the output cdf file " << cdfOutputPath;
        ReportError( ErrorFatal, ss );
        return false;
    }

    cdfOutput << "[CatalogHeader]" << endl;
    cdfOutput << "Name=" << catalogName << endl;
    cdfOutput << "ResultDir=" << item.getManifestPathOnly() << endl;
    cdfOutput << endl;
    cdfOutput << "[CatalogFiles]" << endl;
    cdfOutput << "<HASH>" << item.getManifestFileName() << "=" << item.getManifestFileName() << endl;
    cdfOutput << item.getManifestFileName() << "=" << item.getManifestFileName() << endl;

    cdfOutput.close();

    if ( g_CdfOutputPath.size() > 0 ) {
        ofstream cdflog;
        cdflog.open( g_CdfOutputPath.c_str(), ofstream::app | ofstream::out );
        if ( !cdflog.is_open() )
        {
            stringstream ss;
            ss << "Can't open cdf logging file " << g_CdfOutputPath.c_str();
            ReportError( ErrorWarning, ss );
        }
        else
        {
            cdflog << cdfOutputPath.c_str() << endl;
            cdflog.close();
        }

    }


    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\append\append.cpp ===
#include "windows.h"
#include "ntverp.h"
#include <string>
#include <xstring>
#include <utility>
#include <vector>

using namespace std;

bool g_BufferStdInFully = false;
bool g_LockPerItem = false;

HANDLE ObtainFileHandle(wstring& wsFileName);

class CTargetFile
{
    wstring m_wsTargetName;
    HANDLE hFile;
public:
    CTargetFile(wstring& wsT) : m_wsTargetName(wsT), hFile(INVALID_HANDLE_VALUE) { };
    ~CTargetFile()
    {
        CloseFile();
    }

    BOOL EnsureOpen()
    {
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hFile = ObtainFileHandle(m_wsTargetName);
        }

        return hFile != INVALID_HANDLE_VALUE;
    }

    BOOL CloseFile()
    {
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
        }

        return hFile == INVALID_HANDLE_VALUE;
    }

    BOOL SetFilePointerToEnd()
    {
        DWORD dwResult = SetFilePointer(hFile, 0, NULL, FILE_END);
        if ((dwResult == INVALID_SET_FILE_POINTER) && GetLastError())
        {
            dwResult = GetLastError();
            return FALSE;
        }

        return TRUE;
    }

    BOOL AppendData(PBYTE pbData, DWORD dwDataSize, DWORD& dwWritten)
    {
        LONG dwHighFileOffset = 0;
        DWORD dwResult = 0;
        BOOL fResult = FALSE;
        OVERLAPPED ol;

        if (EnsureOpen() && SetFilePointerToEnd())
        {
            fResult = WriteFile(hFile, pbData, dwDataSize, &dwWritten, NULL);
            if (!fResult)
            {
                dwResult = GetLastError();
            }
        }

        return fResult;
    }
};


//
// Append from stdin
//
BOOL AppendStdIn(CTargetFile& Target)
{
    HANDLE hStdInput;
    DWORD dwReadChars, dwWritten;
    vector<BYTE> vbDataBlob;
    vector<BYTE> vbDataBlobIntermediate;

    vbDataBlobIntermediate.resize(4096);
    
    hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    if ((hStdInput == INVALID_HANDLE_VALUE) || !hStdInput) 
    {
        return FALSE;
    }
    
    while (ReadFile(hStdInput, &vbDataBlobIntermediate.front(), vbDataBlobIntermediate.size(), &dwReadChars, NULL))
    {
        if (!dwReadChars)
        {
            break;
        }
        else 
        {
            if (g_BufferStdInFully)
            {
                vbDataBlob.insert(
                    vbDataBlob.end(), 
                    vbDataBlobIntermediate.begin(), 
                    vbDataBlobIntermediate.end());
            }
            else
            {
                if (!Target.AppendData(&vbDataBlobIntermediate.front(), dwReadChars, dwWritten))
                {
                    return FALSE;
                }
            }
        }
    }

    if ((dwReadChars == 0) && g_BufferStdInFully)
    {
        if (!Target.AppendData(&vbDataBlob.front(), vbDataBlob.size(), dwWritten))
        {
            return FALSE;
        }
    }

    return (dwReadChars == 0);
}

vector< wstring > AppendingSources;

BOOL WorkHorse(wstring& wsTargetFile)
{
    BOOL bOk = FALSE;
    bool bHasReadStdIn = false;
    CTargetFile TargetFile(wsTargetFile);

    if (!g_LockPerItem) TargetFile.EnsureOpen();

    for (vector<wstring>::const_iterator i = AppendingSources.begin(); 
          i != AppendingSources.end(); 
          i++)
    {
        if (*i == L"-")
        {
            if (g_LockPerItem) TargetFile.EnsureOpen();

            if (!bHasReadStdIn)
            {
                bHasReadStdIn = true;
                if (!AppendStdIn(TargetFile))
                {
                    goto Exit;
                }
            }
            else
            {
                fwprintf(stderr, L"Can't read from stdin multiple times - found '-' twice!\n");
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Exit;
            }

            if (g_LockPerItem) TargetFile.CloseFile();
        }
        else
        {
            fwprintf(stderr, L"We don't support reading in files yet, sorry.\n");
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Exit;
        }
    }
    
    bOk = TRUE;

Exit:
    return bOk;

}


HANDLE
ObtainFileHandle(wstring& wsFileName)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwSleepTime = 250;                // Start at 250ms sleep
    float flBackoffRate = 1.1f;             // Backoff at 1.1x the sleep length
    DWORD dwMaxSleepTime = 5000;            // Don't ever sleep for more than 5 seconds at a time
    DWORD dwMaxTicksAtThisSleepTime = 10;   // Try the sleep time 10 times in a row
    DWORD dwTicksAtThisSleepTime = dwMaxTicksAtThisSleepTime;
    DWORD dwError = 0;

    //
    // We attempt to lock the file based on no sharing.  If it fails with a sharing
    // violation, then we back off for a while and try again later.
    //
    while (true)
    {
        hFile = CreateFileW(
            wsFileName.c_str(), 
            GENERIC_WRITE, 
            0,
            NULL,
            OPEN_ALWAYS, 
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        dwError = ::GetLastError();

        // If we've gotten a good handle back, stop looking.
        if ((hFile != INVALID_HANDLE_VALUE) && (hFile != NULL))
        {
            break;
        }
        else
        {
            // If the error was a sharing violation, then back off for a bit and
            // try again.
            if (dwError == ERROR_SHARING_VIOLATION)
            {
                Sleep(dwSleepTime);
                if (dwTicksAtThisSleepTime == 0)
                {
                    dwTicksAtThisSleepTime = dwMaxTicksAtThisSleepTime;
                    dwSleepTime = (DWORD)((float)dwSleepTime * flBackoffRate);
                    continue;
                }
            }
            // Otherwise, something else bad happened, so quit trying
            else
            {
                hFile = INVALID_HANDLE_VALUE;
                break;
            }
        }
    }

    return hFile;

}

void PrintUsage()
{
    wprintf(L"<-file <output>> [-verbose] [-bufferstdin] [-atomicperitem] <[-] [file [...]]>\n");
    wprintf(L"\n");
    wprintf(L"-bufferstdin     Buffer all of stdin (-) before writing\n");
    wprintf(L"-atomicperitem   Lock the file per item, not per run\n");
    wprintf(L"-file <name>     What file should be written out to\n");
    wprintf(L"-verbose         Up the verbosity of debug spew (if any)\n");
    wprintf(L"-                Read from stdin into the output file.\n");
}

int __cdecl wmain(int argc, WCHAR** argv)
{
    wstring             wsAppendTarget;
    vector<wstring>     wstParams;
    bool                 bInGatheringData = false;
    DWORD                dwVerbosity = 0;
    HANDLE               hFile = INVALID_HANDLE_VALUE;

    for (int i = 1; i < argc; i++)
    {
        wstParams.push_back(argv[i]);
    }

    if (wstParams.empty())
    {
        PrintUsage();
        return 1;
    }

    //
    // Syntax:
    //
    // <-file <output>> [-verbose] [-] file1 file2 ... 
    //
    // -                        - Indicates that the console should be read for input at this point
    // -file <output file>      - Specify output destination
    // -verbose                 - How noisy? +1 noise level per instance
    // 
    for (vector<wstring>::iterator i = wstParams.begin(); i != wstParams.end(); i++)
    {
        if (bInGatheringData)
        {
            AppendingSources.push_back(*i);
        }
        else if (*i == wstring(L"-file"))
        {
            wsAppendTarget = *++i;
        }
        else if (*i == wstring(L"-?"))
        {
            PrintUsage();
            return 1;
        }
        else if (*i == wstring(L"-bufferstdin"))
        {
            g_BufferStdInFully = true;
        }
        else if (*i == wstring(L"-atomicperitem"))
        {
            g_LockPerItem = true;
        }
        else if (*i == L"-verbose")
        {
            dwVerbosity++;
        }
        else 
        {
            bInGatheringData = true;
            AppendingSources.push_back(*i);
        }
    }

    //
    // No target or sources?
    //
    if ((wsAppendTarget.size() == 0) || (AppendingSources.size() == 0))
    {
        PrintUsage();
        return 1;
    }


    WorkHorse(wsAppendTarget);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\buildtool\helpers.cpp ===
#include "stdinc.h"

HRESULT
SxspExtractPathPieces(
    _bstr_t bstSourceName,
    _bstr_t &bstPath,
    _bstr_t &bstName
    )
{
    HRESULT hr = S_OK;

    PCWSTR cwsOriginal = static_cast<PCWSTR>(bstSourceName);
    PWSTR cwsSlashSpot;

    cwsSlashSpot = wcsrchr( cwsOriginal, L'\\' );
    if ( cwsSlashSpot )
    {
        *cwsSlashSpot = L'\0';
        bstName = _bstr_t( cwsSlashSpot + 1 );
        bstPath = cwsSlashSpot;
    }
    else
    {
        bstPath = L"";
        bstName = bstSourceName;
    }

    return hr;
}


HRESULT
SxspSimplifyPutAttribute(
    ATL::CComPtr<IXMLDOMDocument> Document,
    ATL::CComPtr<IXMLDOMNamedNodeMap> Attributes,
    const string AttribName,
    const string Value,
    const string NamespaceURI
    )
{
    ATL::CComPtr<IXMLDOMNode>       pAttribNode;
    ATL::CComPtr<IXMLDOMAttribute>  pAttribActual;
    ATL::CComPtr<IXMLDOMNode>       pTempNode;
    HRESULT                hr;

    //
    // Get the attribute from our namespace
    //
    hr = Attributes->getQualifiedItem(
        _bstr_t(AttribName.c_str()),
        _bstr_t(NamespaceURI.c_str()),
        &pAttribNode);

    if ( SUCCEEDED( hr ) )
    {
        //
        // If we had success, but the attribute node is null, then we have to
        // go create one, which is tricky.
        //
        if ( pAttribNode == NULL )
        {
            VARIANT vt;
            vt.vt = VT_INT;
            vt.intVal = NODE_ATTRIBUTE;

            //
            // Do the actual creation part
            //
            hr = Document->createNode(
                vt,
                _bstr_t(AttribName.c_str()),
                _bstr_t(NamespaceURI.c_str()),
                &pTempNode);

            if ( FAILED( hr ) )
            {
                stringstream ss;
                ss << "Can't create the new attribute node " << AttribName;
                ReportError( ErrorFatal, ss );
                goto lblGetOut;
            }

            //
            // Now we go and put that item into the map.
            //
            if ( FAILED( hr = Attributes->setNamedItem( pTempNode, &pAttribNode ) ) )
                goto lblGetOut;
        }

        hr = pAttribNode->put_text( _bstr_t(Value.c_str()) );
    }

lblGetOut:
//    SAFERELEASE( pAttribNode );
//    SAFERELEASE( pTempNode );
    return hr;
}


HRESULT
SxspSimplifyGetAttribute(
    ATL::CComPtr<IXMLDOMNamedNodeMap> Attributes,
    string AttribName,
    string &Destination,
    string NamespaceURI
    )
{
    ATL::CComPtr<IXMLDOMNode>   NodeValue;
    HRESULT                    hr = S_OK;
    BSTR                    _bst_pretemp;

    Destination = "";

    if ( FAILED( hr = Attributes->getNamedItem(
        _bstr_t(AttribName.c_str()),
//        _bstr_t(NamespaceURI.c_str()),
        &NodeValue
    ) ) )
    {
        goto lblBopOut;
    }
    else if ( NodeValue == NULL )
    {
        goto lblBopOut;
    }
    else
    {
        if ( FAILED( hr = NodeValue->get_text( &_bst_pretemp ) ) )
        {
            goto lblBopOut;
        }
        Destination = (char*)_bstr_t(_bst_pretemp,FALSE);
    }

lblBopOut:
    return hr;
}




ostream& operator<<(
    ostream& ost,
    const CPostbuildProcessListEntry& thing
    )
{
    ost << "(path=" << thing.manifestFullPath.c_str()
        << " name=" << thing.name.c_str()
        << " version=" << thing.version.c_str()
        << " language=" << thing.language.c_str() << ")";
    return ost;
}

bool g_bDisplaySpew = false, g_bDisplayWarnings = true;


bool FileExists( const string& str )
{
    return ( GetFileAttributesA( str.c_str() ) != -1 );
}

string JustifyPath( const string& str )
{
    vector<CHAR> vec;
    DWORD dwCount = GetLongPathNameA( str.c_str(), NULL, 0 );

    if ( dwCount == 0 ) dwCount = ::GetLastError();
    vec.resize( dwCount );
    GetLongPathNameA( str.c_str(), &vec.front(), vec.size() );

    return string( &vec.front() );
}

string FudgePath( const string& path, const string& asmsroot )
{
    string temp = path;

    //
    // At the moment, fudging doesn't do anything useful.
    //

    return temp;
}


void CPostbuildProcessListEntry::setManifestLocation( string root, string where )
{
    manifestFullPath = root + "\\" + where;
    manifestPathOnly = manifestFullPath.substr( 0, manifestFullPath.find_last_of( '\\' ) );
    manifestFileName = manifestFullPath.substr( manifestFullPath.find_last_of( '\\' ) + 1 );

    if ( !FileExists( manifestFullPath ) )
    {
        stringstream ss;
        ss << "Referenced manifest " << where << " does not exist.";
        ReportError(ErrorSpew, ss);
    }
}

string g_AsmsBuildRootPath;


//
// Converts a series of strings, foo=bar chunklets, space-seperated, into a map
// from 'foo' to 'bar'
//
StringStringMap
MapFromDefLine( const wstring& source )
{
    wstring::const_iterator here = source.begin();
    StringStringMap rvalue;

    //
    //
    // The tricky bit is that there could be spaces in quoted strings...
    //
    while ( here != source.end() )
    {
        wstring tag, value;
        wchar_t end_of_value = L' ';
        wstring::const_iterator equals;

        //
        // Look for an equals first
        //
        equals = find( here, source.end(), '=' );

        //
        // If there is no equals sign, stop.
        //
        if (equals == source.end())
            break;

        tag.assign( here, equals );

        //
        // Hop over the equals
        //
        here = equals;
        here++;

        //
        // If the equals sign was the last character in the string, stop.
        //
        if (here == source.end())
            break;

        //
        // Is 'here' at an open quote?  Then extract everything to the next
        // quote, remembering to skip this quote as well
        //
        if ( *here == L'\"' )
        {
            end_of_value = L'\"';
            here++;

            //
            // If the quote was the last character in the string, stop.
            //
            if (here == source.end())
                break;
        }

        //
        // Now go and look for the end of the string, or a quote or a space.
        //
        wstring::const_iterator fullstring = find( here, source.end(), end_of_value );

        value.assign( here, fullstring );

        //
        // If it was a quote or a space, skip it. If end of string, stay put.
        //
        if (fullstring != source.end())
            here = fullstring + 1;

        rvalue.insert( pair<wstring,wstring>( tag, value ) );

        //
        // Skip whitespace, but stop if we hit the end of the string.
        //
        while (here != source.end() && (*here == L' ' || *here == L'\t' || *here == '\n' || *here == '\r' || iswspace(*here)))
            here++;
    }

    return rvalue;
}


wstring SwitchStringRep( const string& source )
{
    vector<WCHAR> wch;
    wch.resize( MultiByteToWideChar( CP_ACP, 0, source.c_str(), source.size(), NULL, 0 ) );
    MultiByteToWideChar( CP_ACP, 0, source.c_str(), source.size(), &wch.front(), wch.size() );

    return wstring( wch.begin(), wch.end() );
}


string SwitchStringRep( const wstring& source )
{
    vector<CHAR> wch;
    wch.resize( WideCharToMultiByte( CP_ACP, 0, source.c_str(), source.size(), NULL, 0, NULL, NULL ) );
    WideCharToMultiByte( CP_ACP, 0, source.c_str(), source.size(), &wch.front(), wch.size(), NULL, NULL );

    return string( wch.begin(), wch.end() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\buildtool\manifestmangler.cpp ===
// manifestmanlger.cpp : Defines the entry point for the console application.
//

#include "stdinc.h"
#include "atlbase.h"

IXMLDOMDocument *g_pCurrentDocument;
BOOL g_bIgnoreMalformedXML = FALSE;

#define MAX_OPERATIONS (20)

extern const string ASM_NAMESPACE_URI ("urn:schemas-microsoft-com:asm.v1");

char MicrosoftCopyrightLogo[] = "Microsoft (R) Side-By-Side Manifest Tool 1.0.0.0\nCopyright (C) Microsoft Corporation 2000-2001.  All Rights Reserved.\n\n";
bool g_RazzleBuildTime = false;

//
// Global flags used in processing
//
string g_BinplaceLogFile;
string g_CdfOutputPath;
ATL::CComPtr<IClassFactory> g_XmlDomClassFactory;
bool g_SuppressBanner = false;

#define XMLDOMSOURCE_FILE    (1)
#define XMLDOMSOURCE_STRING (2)
#define MAX_ARGUMENTS (500)
#define MAX_ARGUMENT_LENGTH (8192)

bool
InitializeMSXML3()
{
    static HMODULE hMsXml3 = NULL;
    ATL::CComPtr<IClassFactory> pFactory;
    HRESULT hr;
    typedef HRESULT (__stdcall * PFN_DLL_GET_CLASS_OBJECT)(REFCLSID, REFIID, LPVOID*);
    PFN_DLL_GET_CLASS_OBJECT pfnGetClassObject = NULL;

    if (hMsXml3 == NULL)
    {
        hMsXml3 = LoadLibraryA("msxml3.dll");
        if (hMsXml3 == NULL)
        {
            cerr << "Unable to load msxml3, trying msxml2" << endl;
            hMsXml3 = LoadLibraryA("msxml2.dll");
            if (hMsXml3 == NULL)
            {
                cerr << "Unable to load msxml2, trying msxml" << endl;
                hMsXml3 = LoadLibraryA("msxml.dll");
            }
        }
    }

    if (hMsXml3 == NULL) {
        cerr << "Very Bad Things - no msxml exists on this machine?" << endl;
        return false;
    }

    pfnGetClassObject = (PFN_DLL_GET_CLASS_OBJECT)GetProcAddress(hMsXml3, "DllGetClassObject");
    if (!pfnGetClassObject)
    {
        return false;
    }

    hr = pfnGetClassObject(__uuidof(MSXML2::DOMDocument30), __uuidof(pFactory), (void**)&pFactory);
    if (FAILED(hr))
    {
        cerr << "Can't load version 3.0, trying 2.6" << endl;

        hr = pfnGetClassObject(__uuidof(MSXML2::DOMDocument26), __uuidof(pFactory), (void**)&pFactory);
        if (FAILED(hr))
        {
            cerr << "Can't load version 2.6, trying 1.0" << endl;

            // from msxml.h, not msxml2.h
//            hr = pfnGetClassObject(__uuidof(DOMDocument), __uuidof(pFactory), (void**)&pFactory);
            if (FAILED(hr))
            {
                cerr << "Poked: no XML v1.0" << endl;
            }
        }
    }

    if (FAILED(hr))
    {
        return false;
    }

    g_XmlDomClassFactory = pFactory;

    return true;
}



HRESULT
ConstructXMLDOMObject(
    string       SourceName,
    ATL::CComPtr<IXMLDOMDocument> &document
   )
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vb;

    hr = g_XmlDomClassFactory->CreateInstance(NULL, __uuidof(document), (void**)&document);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // If they're willing to deal with bad XML, then so be it.
    //
    if (FAILED(hr = document->put_validateOnParse(VARIANT_FALSE)))
    {
        stringstream ss;
        ss << "MSXMLDOM Refuses to be let the wool be pulled over its eyes!";
        ReportError(ErrorSpew, ss);
    }

    hr = document->put_preserveWhiteSpace(VARIANT_TRUE);
    hr = document->put_resolveExternals(VARIANT_FALSE);

    CFileStreamBase *fsbase = new CFileStreamBase; // LEAK out of paranoia
    ATL::CComPtr<IStream> istream = fsbase;

    if (!fsbase->OpenForRead(SourceName))
    {
        stringstream ss;
        ss << "Failed opening " << SourceName.c_str() << " for read.";
        ReportError(ErrorFatal, ss);

        return E_FAIL;
    }

    hr = document->load(_variant_t(istream), &vb);
    if (vb != VARIANT_TRUE)
    {
        ATL::CComPtr<IXMLDOMParseError> perror;
        hr = document->get_parseError(&perror);
        long ecode, filepos, linenumber, linepos;
        BSTR reason, src;

        perror->get_errorCode(&ecode);
        perror->get_filepos(&filepos);
        perror->get_line(&linenumber);
        perror->get_linepos(&linepos);
        perror->get_reason(&reason);
        perror->get_srcText(&src);

        stringstream ss;
        ss << "Error: " << hex << ecode << dec << " " << (char*)_bstr_t(reason)
           << " at position " << filepos << ", line " << linenumber << " column " << linepos << endl
           << " the text was: " << endl << (char*)_bstr_t(src) << endl;
        ReportError(ErrorFatal, ss);

        hr = E_FAIL;
    }

    fsbase->Close();

    return hr;
}

void dispUsage()
{
    const char HelpMessage[] =
        "Modes of operation:\n"
        "   -hashupdate         Update hashes of member files\n"
        "   -makecdfs           Generate CDF files to make catalogs\n"
        "   -verbose            Disply piles of debugging information\n"
        "\n"
        "Modifiers:\n"
        "   -manifest <foo.man> The name of the manifest to work with\n"
        "\n"
        "Normal usage:"
        "   mt.exe -hashupdate -makecdfs -manifest foo.man\n"
        "\n";
        
    cout << HelpMessage;

}

BOOL
ProcessParameters(
    const vector<wstring> &params,
    bool &bUpdateHashes,
    bool &bCreateCatalogs,
    bool &bVerbosity,
    pair<bool, CPostbuildProcessListEntry> &bCmdLineSingleItem
   )
{
    std::vector<wstring>::const_iterator ci;
    bUpdateHashes = bCreateCatalogs = bVerbosity = false;

    for (ci = params.begin(); ci != params.end(); ci++)
    {
        if (*ci == wstring(L"-?"))
        {
            dispUsage();
            exit(1);
        }

        bUpdateHashes   |= (*ci == wstring(L"-hashupdate"));
        bCreateCatalogs |= (*ci == wstring(L"-makecdfs"));
        bVerbosity      |= (*ci == wstring(L"-verbose"));

        if (*ci == wstring(L"-binplacelog"))
        {
            g_BinplaceLogFile = SwitchStringRep(*++ci);
        }
        else if (*ci == wstring(L"-razzle"))
        {
            g_RazzleBuildTime = true;
        }
        else if (*ci == wstring(L"-cdfpath"))
        {
            std::vector<wstring>::const_iterator cinext = ci + 1;
            if ( ( cinext == params.end() ) || ( (*cinext).at(0) == L'-' ) )
            {
                stringstream ss;
                ss << "-cdfpath needs a path name";
                ReportError( ErrorFatal, ss );
                return FALSE;
            }

            g_CdfOutputPath = SwitchStringRep(*++ci);
        }
        else if (*ci == wstring(L"-asmsroot"))
        {
            std::vector<wstring>::const_iterator cinext = ci + 1;
            if ( ( cinext == params.end() ) || ( (*cinext).at(0) == L'-' ) )
            {
                stringstream ss;
                ss << "-asmsroot needs a path name";
                ReportError( ErrorFatal, ss );
                return FALSE;
            }

            g_AsmsBuildRootPath = SwitchStringRep(*++ci);
        }
        else if (*ci == wstring(L"-manifest"))
        {
            std::vector<wstring>::const_iterator cinext = ci + 1;
            if ( ( cinext == params.end() ) || ( (*cinext).at(0) == L'-' ) )
            {
                stringstream ss;
                ss << "-manifest needs a file name";
                ReportError( ErrorFatal, ss );
                return FALSE;
            }

            bCmdLineSingleItem.first = true;

            CHAR ch[MAX_PATH];
            GetCurrentDirectoryA(MAX_PATH, ch);

            bCmdLineSingleItem.first = true;
            bCmdLineSingleItem.second.setManifestLocation(string(ch), SwitchStringRep(*++ci));
        }
        else if (*ci == wstring(L"-version"))
        {
            std::vector<wstring>::const_iterator cinext = ci + 1;
            if ( ( cinext == params.end() ) || ( (*cinext).at(0) == L'-' ) )
            {
                stringstream ss;
                ss << "-version needs a version string";
                ReportError( ErrorFatal, ss );
                return FALSE;
            }

            bCmdLineSingleItem.first = true;
            bCmdLineSingleItem.second.version = SwitchStringRep(*++ci);
        }
        else if (*ci == wstring(L"-language"))
        {
            std::vector<wstring>::const_iterator cinext = ci + 1;
            if ( ( cinext == params.end() ) || ( (*cinext).at(0) == L'-' ) )
            {
                stringstream ss;
                ss << "-language needs a culture name string";
                ReportError( ErrorFatal, ss );
                return FALSE;
            }

            bCmdLineSingleItem.first = true;
            bCmdLineSingleItem.second.language = JustifyPath(SwitchStringRep(*++ci));
        }
        else if (*ci == wstring(L"-name"))
        {
            std::vector<wstring>::const_iterator cinext = ci + 1;
            if ( ( cinext == params.end() ) || ( (*cinext).at(0) == L'-' ) )
            {
                stringstream ss;
                ss << "-name needs an assembly name string";
                ReportError( ErrorFatal, ss );
                return FALSE;
            }

            bCmdLineSingleItem.first = true;
            bCmdLineSingleItem.second.name = SwitchStringRep(*++ci);
        }
    }

    return TRUE;
}

int __cdecl wmain(int argc, WCHAR* argv[])
{
    using namespace std;

    bool bUpdateHashes = true;
    bool bGenerateCatalogs = true;
    vector<wstring> params;
    HRESULT hr;
    pair<bool, CPostbuildProcessListEntry> hasInlinedManifest;

    for (int i = 0; i < argc; i++) {
        wstring here = argv[i];
        if ( here == wstring(L"-nologo"))
            g_SuppressBanner = true;
        else
            params.push_back(here);
    }

    if ( !g_SuppressBanner )
    {
        cout << MicrosoftCopyrightLogo;
    }

    if (!ProcessParameters(params, bUpdateHashes, bGenerateCatalogs, g_bDisplaySpew, hasInlinedManifest))
        return 1;

    //
    // Start COM
    //
    if (FAILED(hr = ::CoInitialize(NULL)))
    {
        stringstream ss;

        ss << "Unable to start com, error " << hex << hr;
        ReportError(ErrorFatal, ss);
        return 1;
    }

    if (!InitializeMSXML3())
    {
        return 2;
    }

    if (hasInlinedManifest.first)
    {
        PostbuildEntries.push_back(hasInlinedManifest.second);
        goto StartProcessing;
    }

    //
    // Populate the processing list, but only if we're really in a Razzle
    // environment
    //
    if ( g_RazzleBuildTime )
    {
        //        string chName = convertWCharToAnsi(argv[1]);
        ifstream BinplaceLog;

        BinplaceLog.open(g_BinplaceLogFile.c_str());
        if (!BinplaceLog.is_open()) {
            cerr << "Failed opening '" << g_BinplaceLogFile << "' as the binplace log?" << endl;
            cerr << "Ensure that the path passed by '-binplacelog' is valid." << endl;
            return 1;
        }

        while (!BinplaceLog.eof())
        {
            string sourceLine;
            wstring wSourceLine;
            CPostbuildProcessListEntry item;
            StringStringMap ValuePairs;

            getline(BinplaceLog, sourceLine);
            wSourceLine = SwitchStringRep(sourceLine);

            ValuePairs = MapFromDefLine(wSourceLine);
            if (!ValuePairs.size())
                continue;

            item.name = SwitchStringRep(ValuePairs[L"SXS_ASSEMBLY_NAME"]);
            item.version = SwitchStringRep(ValuePairs[L"SXS_ASSEMBLY_VERSION"]);
            item.language = SwitchStringRep(ValuePairs[L"SXS_ASSEMBLY_LANGUAGE"]);
            item.setManifestLocation(g_AsmsBuildRootPath, SwitchStringRep(ValuePairs[L"SXS_MANIFEST"]));

            if (item.getManifestFullPath().find("asms\\") == -1) {
                stringstream ss;
                ss << "Skipping manifested item " << item << " because it's not under asms.";
                ReportError(ErrorSpew, ss);
            } else {
                PostbuildEntries.push_back(item);
            }
        }

        std::sort(PostbuildEntries.begin(), PostbuildEntries.end());
        PostbuildEntries.resize(std::unique(PostbuildEntries.begin(), PostbuildEntries.end()) - PostbuildEntries.begin());
    }
    else if ( !hasInlinedManifest.first )
    {
        //
        // No -razzle and no -manifest?  Whoops...
        //
        dispUsage();
        return 1;
    }

StartProcessing:

    if ( !bUpdateHashes && !bGenerateCatalogs )
    {
        cout << "Nothing to do!" << endl;
        dispUsage();
        return 1;
    }

    for (vector<CPostbuildProcessListEntry>::const_iterator cursor = PostbuildEntries.begin(); cursor != PostbuildEntries.end(); cursor++)
    {
        //
        // First, mash the hashes around.
        //
        if (bUpdateHashes)
            UpdateManifestHashes(*cursor);

        //
        // Second, generate catalogs
        //
        if (bGenerateCatalogs)
            GenerateCatalogContents(*cursor);
    }

    hr = S_OK;

    return (hr == S_OK) ? 0 : 1;
}


CPostbuildItemVector PostbuildEntries;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\buildtool\filestream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Implementation of IStream over a win32 file.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include "helpers.h"
#include <windows.h>
#define UNUSED(x)

BOOL
MySetFilePointerEx(
  HANDLE         File,                    // handle to file
  LARGE_INTEGER  DistanceToMove,  // bytes to move pointer
  PLARGE_INTEGER NewFilePointer, // new file pointer
  DWORD          MoveMethod               // starting point
)
{
    LONG DistanceToMoveLow  = static_cast<LONG>(DistanceToMove.LowPart);
    LONG DistanceToMoveHigh = DistanceToMove.HighPart;
    DWORD NewPositionLow = SetFilePointer(File, DistanceToMoveLow, &DistanceToMoveHigh, MoveMethod);

    if (NewPositionLow == INVALID_SET_FILE_POINTER)
    {
        if (GetLastError() != NO_ERROR)
            return FALSE;
    }
    if (NewFilePointer != NULL)
    {
        NewFilePointer->LowPart =  NewPositionLow;
        NewFilePointer->HighPart = DistanceToMoveHigh;
    }
    return TRUE;
}

CFileStreamBase::~CFileStreamBase()
{
    const DWORD dwLastError = ::GetLastError();
    Close();
    ::SetLastError(dwLastError);
}

bool
CFileStreamBase::OpenForWrite(string pszPath)
{
    if (m_hFile != INVALID_HANDLE_VALUE)
        return false;

    m_hFile = ::CreateFileA(
        pszPath.c_str(),
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return (m_hFile != INVALID_HANDLE_VALUE);
}

bool
CFileStreamBase::OpenForRead(string pszPath)
{
    if (m_hFile != INVALID_HANDLE_VALUE)
        return false;

    m_hFile = ::CreateFileA(
        pszPath.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return (m_hFile != INVALID_HANDLE_VALUE);
}

bool
CFileStreamBase::Close()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        if (!::CloseHandle(m_hFile))
        {
            return false;
        }
        m_hFile = INVALID_HANDLE_VALUE;
    }

    return true;
}

ULONG
CFileStreamBase::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

ULONG
CFileStreamBase::Release()
{
    const ULONG ulRefCount = ::InterlockedDecrement(&m_cRef);
    if ( ulRefCount == 0 ) 
    {
        delete this;
        return 0;
    }
    else
    {
        return ulRefCount;
    }
}

HRESULT
CFileStreamBase::QueryInterface(
    REFIID riid,
    PVOID *ppvObj
    )
{
    HRESULT hr = NOERROR;

    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        pIUnknown = static_cast<IStream *>(this);

    if (pIUnknown == NULL)
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    pIUnknown->AddRef();
    *ppvObj = pIUnknown;

    hr = NOERROR;

Exit:
    return hr;
}


HRESULT
CFileStreamBase::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = NOERROR;
    ULONG cbRead = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if (!m_bSeenFirstCharacter)
    {
#ifdef AWFUL_SPACE_HACK
        while (true)
        {
            CHAR ch;
            ReadFile(m_hFile, &ch, 1, &cbRead, NULL);
            if ((ch != '\n') && (ch != '\r') && (ch != ' ') && (ch != '\t')) {
                m_bSeenFirstCharacter = true;
                LARGE_INTEGER li;
                li.QuadPart = -1;
                ::MySetFilePointerEx(m_hFile, li, NULL, FILE_CURRENT);
                break;
            }
        }
#endif
    }

    if (!::ReadFile(m_hFile, pv, cb, &cbRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbRead == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbRead != NULL)
        *pcbRead = cbRead;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Write(
    void const *pv,
    ULONG cb,
    ULONG *pcbWritten
    )
{
    HRESULT hr = NOERROR;
    ULONG cbWritten = 0;

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    if (!::WriteFile(m_hFile, pv, cb, &cbWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbWritten == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition
    )
{
    HRESULT hr = NOERROR;
    DWORD dwWin32Origin = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    switch (dwOrigin)
    {
    default:
        hr = E_INVALIDARG;
        goto Exit;

    case STREAM_SEEK_SET:
        dwWin32Origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        dwWin32Origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        dwWin32Origin = FILE_END;
        break;
    }

    if (!::MySetFilePointerEx(
                m_hFile,
                dlibMove,
                (LARGE_INTEGER *) plibNewPosition,
                dwWin32Origin))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CFileStreamBase::SetSize(
    ULARGE_INTEGER libNewSize
    )
{
    UNUSED(libNewSize);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten
    )
{
    if (pcbRead != NULL)
        pcbRead->QuadPart = 0;

    if (pcbWritten != NULL)
        pcbWritten->QuadPart = 0;

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Commit(
    DWORD grfCommitFlags
    )
{
    HRESULT hr = NOERROR;

    if (grfCommitFlags != 0)
        return E_INVALIDARG;

    if (!Close())
        hr = HRESULT_FROM_WIN32 (GetLastError());

    return hr;
}

HRESULT
CFileStreamBase::Revert()
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag
    )
{
    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(*pstatstg));

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Clone(
    IStream **ppIStream
    )
{
    if (ppIStream != NULL)
        *ppIStream = NULL;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\buildtool\hasheditor.cpp ===
#include "stdinc.h"

#define SHA1_HASH_SIZE_BYTES	( 160 / 8 )
#define HASHFLAG_AUTODETECT		( 0x0001 )
#define HASHFLAG_STRAIGHT_HASH 	( 0x0002 )
#define HASHFLAG_PROCESS_IMAGE	( 0x0004 )


string XML_ATTRIBUTE_NAME( "name" );

HRESULT FreshenFileNodeHashes( PVOID, int argc, WCHAR *argv[] );
HRESULT ProcessSingleFileNode( IXMLDOMDocument *pDocument, IXMLDOMNode *pDocNode );

BOOL	
SxspCreateFileHash(
    DWORD dwFlags,
	ALG_ID PreferredAlgorithm,
	string pwsFileName,
	string &HashBytes
    );

const string p_bstHashAlgName("SHA1");
#if 0
const BOOL p_bUseOldStyleSemantics = FALSE;
const ALG_ID p_HashAlgId = CALG_SHA1;

const static struct { ALG_ID algId; PCWSTR wsName; } HashAlgPairs[] =
{
    { CALG_SHA1,    L"SHA1" },
    { CALG_SHA,     L"SHA" },
    { CALG_MD5,     L"MD5" },
    { CALG_HMAC,    L"HMAC" },
    { CALG_MAC,     L"MAC" },
    { CALG_MD2,     L"MD2" },
    { CALG_MD4,     L"MD4" }
};
#endif

string
ConvertHashToString( std::vector<BYTE> Hash )
{
    stringstream output;
    output << hex;
    output.fill('0');
    output.width(2);

    for ( std::vector<BYTE>::const_iterator it = Hash.begin(); it != Hash.end(); it++ )
    {
        output << *it;
    }

    return output.str();
}


HRESULT
ProcessSingleFileNode(
    ATL::CComPtr<IXMLDOMDocument> Document,
    ATL::CComPtr<IXMLDOMNode> DocNode
    )
{
	//
	// Here, we're dealing with a single file.  So, we have to go and see if
	// there's a Verification subtag of this file, and process it properly.
	//
	
	string				            bstFileName;
	string				            bstNamespace, bstPrefix;
	ATL::CComPtr<IXMLDOMNamedNodeMap>   Attributes;
	ATL::CComPtr<IXMLDOMNode>           Dump;
	HRESULT					        hr;
    string                          Hash;

	//
	// So we get the attributes of this node, which should contain the file
	// name and hash information.
	//
	if ( FAILED( hr = DocNode->get_attributes( &Attributes ) ) )
		goto lblGetOut;

	//
	// Now just the values out
	//
	SxspSimplifyGetAttribute( Attributes, XML_ATTRIBUTE_NAME, bstFileName, ASM_NAMESPACE_URI );

	//
	// Now we use this to gather information about the file, and to fix
	// the values in the hash entry if need be.
	//
    if (::SxspCreateFileHash(HASHFLAG_AUTODETECT, CALG_SHA1, bstFileName, Hash))
	{
		//
		// Write the data back into the node, don't change the file name at all
		//
        ATL::CComPtr<IXMLDOMNode> Dump;
        Attributes->removeNamedItem( _bstr_t(L"hash"), &Dump );
        Attributes->removeNamedItem( _bstr_t(L"hashalg"), &Dump );
		SxspSimplifyPutAttribute( Document, Attributes, "hash", Hash );
		SxspSimplifyPutAttribute( Document, Attributes, "hashalg", p_bstHashAlgName );
		{
		    stringstream ss;
		    ss << bstFileName.c_str() << " hashed to " << Hash.c_str();
		    ReportError( ErrorSpew, ss );
		}
	}
	else
	{
	    stringstream ss;
	    ss << "Unable to create hash for file " << bstFileName.c_str();
	    ReportError( ErrorWarning, ss );
		goto lblGetOut;
	}

lblGetOut:
	return hr;
	
}

string AssemblyFileXSLPattern("/assembly/file");

bool UpdateManifestHashes( const CPostbuildProcessListEntry& item )
{
    ATL::CComPtr<IXMLDOMDocument> document;
    ATL::CComPtr<IXMLDOMElement> rootElement;
    ATL::CComPtr<IXMLDOMNodeList> fileTags;
    ATL::CComPtr<IXMLDOMNode> fileNode;
    HRESULT hr = S_OK;

    if ( FAILED(hr = ConstructXMLDOMObject( item.getManifestFullPath(), document )) )
    {
        stringstream ss;
        ss << "Failed opening the manifest " << item.getManifestFullPath()
           << " for input under the DOM.";
        ReportError( ErrorFatal, ss );
        return false;
    }

    if ( FAILED(document->get_documentElement( &rootElement ) ) )
    {
        stringstream ss;
        ss << "The manifest " << item.getManifestFullPath() << " may be malformed,"
           << " as we were unable to load the root element!";
        ReportError( ErrorFatal, ss );
        return false;
    }

    //
    // Now, let's select all the 'file' nodes under 'assembly' tags:
    //
    hr = document->selectNodes( _bstr_t(AssemblyFileXSLPattern.c_str()), &fileTags );
    if ( FAILED(hr) )
    {
        stringstream ss;
        ss << "Unable to select the file nodes under this assembly tag, can't proceed.";
        ReportError( ErrorFatal, ss );
    }

    long length;
    fileTags->get_length( &length );

    //
    // And for each, process it
    //
    fileTags->reset();
    while ( SUCCEEDED(fileTags->nextNode( &fileNode ) ) )
    {
        //
        // All done
        //
        if ( fileNode == NULL )
        {
            break;
        }

        SetCurrentDirectoryA( item.getManifestPathOnly().c_str() );
        ProcessSingleFileNode( document, fileNode );
    }

    if ( FAILED( hr = document->save( _variant_t(_bstr_t(item.getManifestFullPath().c_str())) ) ) )
    {
        stringstream ss;
        ss << "Unable to save manifest " << item.getManifestFullPath()
           << " back after updating hashes! Changes will be lost.";
        ReportError( ErrorFatal, ss );
    }

    return true;
}


//
// HUGE HACKHACK
//
// There has to be some nice way of including this code (which otherwise lives
// in hashfile.cpp in the fusion\dll\whistler tree) other than just glomping
// it here.
//

BOOL
ImageDigesterFunc(
	DIGEST_HANDLE hSomething,
	PBYTE pbDataBlock,
	DWORD dwLength
    )
{
	return CryptHashData( (HCRYPTHASH)hSomething, pbDataBlock, dwLength, 0 );
}


BOOL
pSimpleHashRoutine(
	HCRYPTHASH hHash,
	HANDLE hFile
    )
{
	static const DWORD FILE_BUFFER = 64 * 1024;
	BYTE pbBuffer[FILE_BUFFER];
	DWORD dwDataRead;
	BOOL b = FALSE;
    BOOL bKeepReading = TRUE;
	
	while ( bKeepReading )
	{
		b = ReadFile( hFile, pbBuffer, FILE_BUFFER, &dwDataRead, NULL );
		if ( b && ( dwDataRead == 0 ) )
		{
			bKeepReading = FALSE;
			b = TRUE;
			continue;
		}
		else if ( !b )
		{
		    WCHAR ws[8192];
		    FormatMessageW(
		        FORMAT_MESSAGE_FROM_SYSTEM,
		        NULL,
		        ::GetLastError(),
		        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
		        ws,
		        0,
		        NULL
		    );
		    bKeepReading = FALSE;
		    continue;
		}
		
		if ( CryptHashData( hHash, pbBuffer, dwDataRead, 0 ) == 0 )
		{
		    b = FALSE;
			break;
		}
	}

	return b;
}


BOOL
pImageHashRoutine(
	HCRYPTHASH hHash,
	HANDLE hFile
    )
{
	return ImageGetDigestStream(
		hFile,
		CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO,
		ImageDigesterFunc,
		(DIGEST_HANDLE)hHash
	);
}

BOOL	
SxspCreateFileHash(DWORD dwFlags,
			   ALG_ID PreferredAlgorithm,
			   string pwsFileName,
			   string &HashBytes
    )
{
	BOOL			fSuccessCode = FALSE;
	HCRYPTPROV		hProvider;
	HCRYPTHASH		hCurrentHash;
	HANDLE			hFile;

	// Initialization
	hProvider = (HCRYPTPROV)INVALID_HANDLE_VALUE;
	hCurrentHash = (HCRYPTHASH)INVALID_HANDLE_VALUE;
	hFile = INVALID_HANDLE_VALUE;

	//
	// First try and open the file.  No sense in doing anything else if we
	// can't get to the data to start with.  Use a very friendly set of
	// rights to check the file.  Future users might want to be sure that
	// you're in the right security context before doing this - system
	// level to check system files, etc.
	//
	hFile = CreateFileA(
		pwsFileName.c_str(),
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
		);
		
	if ( hFile == INVALID_HANDLE_VALUE ) {
		return FALSE;
	}
	
	//
	// Create a cryptological provider that supports everything RSA needs.
	//
	if (!CryptAcquireContextW(&hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
		goto lblCleanup;
	
	//
	// We'll be using SHA1 for the file hash
	//
	if ( !CryptCreateHash( hProvider, PreferredAlgorithm, 0, 0, &hCurrentHash ) )
		goto lblCleanup;


	//
	// So first try hashing it via the image, and if that fails, try the
	// normal file-reading hash routine instead.
	//
	if ( dwFlags & HASHFLAG_AUTODETECT )
	{
		if ( !pImageHashRoutine( hCurrentHash, hFile ) )
		{
			//
			// Oops, the image-hasher wasn't happy.  Let's try the straight
			// hasher instead.
			//
			if ( !pSimpleHashRoutine( hCurrentHash, hFile ) )
			{
				goto lblCleanup;
			}
			else
			{
				fSuccessCode = TRUE;
			}
		}
		else
		{
			fSuccessCode = TRUE;
		}
		
	}
	else if ( dwFlags & HASHFLAG_STRAIGHT_HASH )
	{
		fSuccessCode = pSimpleHashRoutine( hCurrentHash, hFile );
	}
	else if ( dwFlags & HASHFLAG_PROCESS_IMAGE )
	{
		fSuccessCode = pImageHashRoutine( hCurrentHash, hFile );
	}
	else
	{
		::SetLastError( ERROR_INVALID_PARAMETER );
		goto lblCleanup;
	}


	//
	// We know the buffer is the right size, so we just call down to the hash parameter
	// getter, which will be smart and bop out (setting the pdwDestinationSize parameter)
	// if the user passed an invalid parameter.
	//
	if ( fSuccessCode )
	{
        stringstream ss;
	    DWORD dwSize, dwDump;
	    BYTE *pb = NULL;
        fSuccessCode = CryptGetHashParam( hCurrentHash, HP_HASHSIZE, (BYTE*)&dwSize, &(dwDump=sizeof(dwSize)), 0 );
        if ( !fSuccessCode || ( pb = new BYTE[dwSize] ) == NULL ) {
            goto lblCleanup;
        }
		fSuccessCode = CryptGetHashParam( hCurrentHash, HP_HASHVAL, pb, &dwSize, 0);
		if ( !fSuccessCode ) {
		    delete[] pb;
		    goto lblCleanup;
		}


        for ( dwDump = 0; dwDump < dwSize; dwDump++ ) {
            ss << hex;
            ss.fill('0');
            ss.width(2);
		    ss << (unsigned int)pb[dwDump];
        }

        HashBytes = ss.str();
		delete[] pb;
	}

	
lblCleanup:
	DWORD dwLastError = ::GetLastError();
	if ( hFile != INVALID_HANDLE_VALUE )
	{
		CloseHandle( hFile );
	}

	//
	// We just destroy the hash and the crypto context blindly.  If they were
	// invalid before, the release and destroy would just return with a failure,
	// not an exception or fault.
	//
	CryptDestroyHash( hCurrentHash );
	CryptReleaseContext( hProvider, 0 );

	::SetLastError( dwLastError );
	return fSuccessCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\filehasher\filehasher.cpp ===
sdf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\buildtool\stdinc.h ===
#define __USE_MSXML2_NAMESPACE__
#include <utility>
#pragma warning(disable:4512) /* assignment operator could not be generated */
#pragma warning(disable:4511) /* copy constructor could not be generated */
#pragma warning(disable:4663) /* C++ language change */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion, possible loss of data */
#pragma warning(disable:4244) /* conversion, possible loss of data */
#endif
#include "windows.h"
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <sstream>
#include <map>
#include <stdio.h>
#include "comdef.h"
#include "comutil.h"
#include "wincrypt.h"
#include "msxml.h"
#include "msxml2.h"
#include "imagehlp.h"
#include "share.h"
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
using std::basic_string;
using std::cerr;
using std::cout;
using std::dec;
using std::endl;
using std::find;
using std::getline;
using std::hex;
using std::ifstream;
using std::ofstream;
using std::ostream;
using std::pair;
using std::string;
using std::stringstream;
using std::vector;
using std::wifstream;
using std::wistream;
using std::wstring;
#include "atlbase.h"
#include "manglers.h"
#include "helpers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\buildtool\helpers.h ===
#pragma once

extern const string ASM_NAMESPACE_URI;
extern string g_CdfOutputPath;
extern string g_AsmsBuildRootPath;


#define AWFUL_SPACE_HACK TRUE

HRESULT
SxspSimplifyGetAttribute(
	ATL::CComPtr<IXMLDOMNamedNodeMap> Attributes,
	string bstAttribName,
	string &bstDestination,
	string bstNamespaceURI = ASM_NAMESPACE_URI
    );

HRESULT
SxspSimplifyPutAttribute(
    ATL::CComPtr<IXMLDOMDocument> Document,
	ATL::CComPtr<IXMLDOMNamedNodeMap> Attributes,
	const string bstAttribName,
	const string bstValue,
	const string bstNamespaceURI = ASM_NAMESPACE_URI
    );

HRESULT
SxspExtractPathPieces(
	_bstr_t bstSourceName,
	_bstr_t &bstPath,
	_bstr_t &bstName
    );


HRESULT
CreateDocumentNode(
	VARIANT vt,
	_bstr_t bstAttribName,
	_bstr_t bstNamespace,
	IXMLDOMNode **pNewNode
    );

HRESULT
ConstructXMLDOMObject(
	string		SourceName,
	ATL::CComPtr<IXMLDOMDocument> &result
    );


template<class T> class CListing {
private:
	int iListLength, iListMaxLength;
	T* pListData;

	void _ExpandList( int newamount )
	{
		T* pNewListData = new T[newamount];
		if ( pListData )
		{
			for ( int i = 0; i < iListLength; i++ )
			{
				pNewListData[i] = pListData[i];
			}
			delete[] pListData;
		}

		pListData = pNewListData;
		iListMaxLength = newamount;
	}

public:
	int GetLength() { return iListLength; }
	void ClearList() { if ( pListData ) delete[] pListData; };

	CListing()
	{
		iListLength = 0;
		pListData = new T[iListMaxLength = 10];
	}

	~CListing()
	{
		ClearList();
	}

	BOOL Contains( T item )
	{
		for ( int i = 0; i < iListLength; i++ ) {
			if ( pListData[i] == item ) return TRUE;
		}
		return FALSE;
	}

	void Add( T item )
	{
		if ( iListLength >= iListMaxLength )
		{
			_ExpandList( iListMaxLength + 10 );
		}

		pListData[iListLength++] = item;
	}

	T& Get( int i ) {
		if ( i >= iListMaxLength )
		{
			_ExpandList( i + 10 );
		}
		return pListData[i];
	}
};


enum ErrorLevel
{
    ErrorFatal,
    ErrorWarning,
    ErrorSpew
};

extern bool g_bDisplaySpew, g_bDisplayWarnings;
static inline void ReportError( ErrorLevel el, stringstream& message )
{
    if ( ( el == ErrorSpew ) && g_bDisplaySpew )
        cout << "SPEW: " << message.str() << endl;
    else if ( ( el == ErrorWarning ) && g_bDisplayWarnings )
        cout << "WARNING: " << message.str() << endl;
    else if ( el == ErrorFatal )
        cerr << "ERROR: " << message.str() << endl;
}

class CPostbuildProcessListEntry
{
private:
    string manifestFullPath;
    string manifestFileName;
    string manifestPathOnly;

public:
    string version;
    string name;
    string language;

    ATL::CComPtr<IXMLDOMDocument> DocumentPointer;

    string getManifestFullPath() const { return manifestFullPath; }
    string getManifestFileName() const { return manifestFileName; }
    string getManifestPathOnly() const { return manifestPathOnly; }

    void setManifestLocation( string root, string where );

	bool operator==(const CPostbuildProcessListEntry& right) const
    {
        return !(*this < right) && !(right < *this);
    }

    static bool stringPointerLessThan(const std::string* x, const std::string* y)
    {
        return x->compare(*y) < 0;
    }

	bool operator<(const CPostbuildProcessListEntry& right) const
    {
        // the order is arbitrary, 
        const std::string* leftStrings[] =
            { &this->name, &this->version, &this->language, &this->manifestFullPath, &this->manifestFileName, &this->manifestPathOnly  };
        const std::string* rightStrings[] =
            { &right.name, &right.version, &right.language, &right.manifestFullPath, &right.manifestFileName, &right.manifestPathOnly  };
        return std::lexicographical_compare(
            leftStrings, leftStrings + NUMBER_OF(leftStrings),
            rightStrings, rightStrings + NUMBER_OF(rightStrings),
            stringPointerLessThan
            );
    }

	friend ostream& operator<<(ostream& ost, const CPostbuildProcessListEntry& thing );
};

typedef vector<CPostbuildProcessListEntry> CPostbuildItemVector;
extern CPostbuildItemVector PostbuildEntries;

class CFileStreamBase : public IStream
{
public:
    CFileStreamBase()
        : m_cRef(0),
          m_hFile(INVALID_HANDLE_VALUE),
          m_bSeenFirstCharacter(false)
    { }

    virtual ~CFileStreamBase();

    bool OpenForRead( string pszPath );
    bool OpenForWrite( string pszPath );

    bool Close();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);

protected:
    LONG                m_cRef;
    HANDLE              m_hFile;
    bool                m_bSeenFirstCharacter;

private:
    CFileStreamBase(const CFileStreamBase &r); // intentionally not implemented
    CFileStreamBase &operator =(const CFileStreamBase &r); // intentionally not implemented
};

wstring SwitchStringRep( const string& );
string  SwitchStringRep( const wstring& );

typedef std::map<wstring, wstring> StringStringMap;
typedef std::map<wstring, wstring> StringStringPair;
typedef wstring InvalidEquivalence;

StringStringMap   MapFromDefLine( const wstring& source );

string JustifyPath( const string& path );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\certinfo\certinfo.cpp ===
#include "windows.h"
#include "stdio.h"
#include "wchar.h"
#include "wincrypt.h"
#include "stddef.h"


static const WCHAR wchMicrosoftLogo[] = 
    L"Microsoft (R) Side-By-Side Public Key Token Extractor 1.1.0.0\n"
    L"Copyright (C) Microsoft Corporation 2000-2001. All Rights Reserved\n\n";


#define STRONG_NAME_BYTE_LENGTH ( 8 )

typedef struct _SXS_PUBLIC_KEY_INFO
{
    unsigned int SigAlgID;
    unsigned int HashAlgID;
    ULONG KeyLength;
    BYTE pbKeyInfo[1];
} SXS_PUBLIC_KEY_INFO, *PSXS_PUBLIC_KEY_INFO;


#define BUFFER_SIZE ( 8192 )

BOOL
ParseArgs( WCHAR **argv, int argc, PCWSTR* ppcwszFilename, BOOL *fQuiet )
{
    if ( fQuiet )
        *fQuiet = FALSE;
    if ( ppcwszFilename )
        *ppcwszFilename = NULL;

    if ( !fQuiet || !ppcwszFilename )
    {
        return FALSE;
    }

    for ( int i = 1; i < argc; i++ )
    {
        if ( ( argv[i][0] == L'-' ) || ( argv[i][0] == L'/' ) )
        {
            PCWSTR pval = argv[i] + 1;
            if (lstrcmpiW(pval, L"nologo") == 0)
            {
            }
            else if (lstrcmpiW(pval, L"quiet") == 0)
            {
                if ( fQuiet ) *fQuiet = TRUE;
            }
            else if (lstrcmpiW(pval, L"?") == 0 )
            {
                return FALSE;
            }
            else
            {
                fwprintf(stderr, L"Unrecognized parameter %ls\n", argv[i]);
                return FALSE;
            }
        }
        else
        {
            if ( *ppcwszFilename == NULL )
            {
                *ppcwszFilename = argv[i];
            }
            else
            {
                fwprintf(stderr, L"Only one filename parameter at a time.\n", argv[i]);
                return FALSE;
            }
        }
    }

    return TRUE;
}


void DispUsage( PCWSTR pcwszExeName )
{
    const static WCHAR wchUsage[] = 
        L"Extracts public key tokens from certificate files, in a format\n"
        L"usable in Side-By-Side assembly identities.\n"
        L"\n"
        L"Usage:\n"
        L"\n"
        L"%ls <filename.cer> [-quiet]\n";

    wprintf(wchUsage, pcwszExeName);
}

BOOL
HashAndSwizzleKey(
    HCRYPTPROV hProvider,
    BYTE *pbPublicKeyBlob,
    SIZE_T cbPublicKeyBlob,
    BYTE *pbKeyToken,
    SIZE_T &cbKeyToken
    )
{
    BOOL fResult = FALSE;
    HCRYPTHASH hHash = NULL;
    DWORD dwHashSize, dwHashSizeSize;
    ULONG top = STRONG_NAME_BYTE_LENGTH - 1;
    ULONG bottom = 0;


    if ( !CryptCreateHash( hProvider, CALG_SHA1, NULL, 0, &hHash ) )
    {
        fwprintf(stderr, L"Unable to create cryptological hash object, error %ld\n", ::GetLastError());
        goto Exit;
    }

    if ( !CryptHashData( hHash, pbPublicKeyBlob, static_cast<DWORD>(cbPublicKeyBlob), 0 ) )
    {
        fwprintf(stderr, L"Unable to hash public key information, error %ld\n", ::GetLastError());
        goto Exit;
    }

    if ( !CryptGetHashParam( hHash, HP_HASHSIZE, (PBYTE)&dwHashSize, &(dwHashSizeSize = sizeof(dwHashSize)), 0))
    {
        fwprintf(stderr, L"Unable to determine size of hashed public key bits, error %ld\n");
        goto Exit;
    }

    if ( dwHashSize > cbKeyToken )
    {
        fwprintf(stderr, L"Hashed data is too large - space for %ld bytes, got %ld.\n",
            cbKeyToken, dwHashSize);
        goto Exit;
    }

    if ( !CryptGetHashParam( hHash, HP_HASHVAL, pbKeyToken, &(dwHashSize = (DWORD)cbKeyToken), 0))
    {
        fwprintf(stderr, L"Unable to get hash of public key bits, error %ld\n", ::GetLastError());
        goto Exit;
    }

    cbKeyToken = dwHashSize;

    //
    // Now, move down the last eight bytes, then reverse them.
    //
    memmove(pbKeyToken,
        pbKeyToken + (cbKeyToken  - STRONG_NAME_BYTE_LENGTH),
        STRONG_NAME_BYTE_LENGTH);

    while ( bottom < top )
    {
        const BYTE b = pbKeyToken[top];
        pbKeyToken[top] = pbKeyToken[bottom];
        pbKeyToken[bottom] = b;
        bottom++;
        top--;
    }
    
    fResult = TRUE;
Exit:
    if ( hHash != NULL )
    {
        CryptDestroyHash(hHash);
        hHash = NULL;
    }
    return fResult;
}


BOOL
GetTokenOfKey(
    PCERT_PUBLIC_KEY_INFO pKeyInfo,
    PBYTE prgbBuffer,
    SIZE_T &cbPublicKeyTokenLength
    )
{
    BYTE rgbWorkingSpace[8192];
    PSXS_PUBLIC_KEY_INFO pKeyBlobWorkspace = reinterpret_cast<PSXS_PUBLIC_KEY_INFO>(rgbWorkingSpace);
    HCRYPTPROV hContext = NULL;
    HCRYPTKEY hCryptKey = NULL;
    BOOL fResult = FALSE;
    DWORD dwActualBlobSize;

    if ( !CryptAcquireContext(&hContext, NULL, NULL, PROV_RSA_FULL, CRYPT_SILENT | CRYPT_VERIFYCONTEXT))
    {
        fwprintf(stderr, L"Unable to aquire cryptological context, error %ld.\n", ::GetLastError());
        goto Exit;
    }

    ZeroMemory(prgbBuffer, cbPublicKeyTokenLength);

    //
    // Set up the public key info blob for hashing.  Import the key to a real
    // HCRYPTKEY, then export the bits back out to a buffer.  Set up the various
    // other settings in the blob as well, the type of key and the alg. used to
    // sign it.
    //
    if ( !CryptImportPublicKeyInfoEx(
        hContext,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pKeyInfo,
        CALG_RSA_SIGN,
        0,
        NULL,
        &hCryptKey) )
    {
        fwprintf(stderr, L"Unable to import the public key from this certificate. Error %ld.\n", ::GetLastError());
        goto Exit;
    }

    pKeyBlobWorkspace->KeyLength = 
        sizeof(rgbWorkingSpace) - offsetof(SXS_PUBLIC_KEY_INFO, pbKeyInfo);

    if ( !CryptExportKey(
        hCryptKey,
        NULL,
        PUBLICKEYBLOB,
        0,
        pKeyBlobWorkspace->pbKeyInfo,
        &pKeyBlobWorkspace->KeyLength) )
    {
        fwprintf(stderr, L"Unable to extract public key bits from this certificate. Error %ld.\n", ::GetLastError());
        goto Exit;
    }

    pKeyBlobWorkspace->SigAlgID = CALG_RSA_SIGN;
    pKeyBlobWorkspace->HashAlgID = CALG_SHA1;

    dwActualBlobSize = pKeyBlobWorkspace->KeyLength + offsetof(SXS_PUBLIC_KEY_INFO, pbKeyInfo);


    //
    // We now need to hash the public key bytes with SHA1.
    //
    if (!HashAndSwizzleKey(
            hContext,
            (PBYTE)pKeyBlobWorkspace, 
            dwActualBlobSize,
            prgbBuffer,
            cbPublicKeyTokenLength))
    {
        goto Exit;
    }

    fResult = TRUE;
Exit:
    if ( hCryptKey != NULL )
    {
        CryptDestroyKey(hCryptKey);
        hCryptKey = NULL;
    }
    if ( hContext != NULL )
    {
        CryptReleaseContext(hContext, 0);
        hContext = NULL;
    }

    return fResult;
        
}


int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HCERTSTORE hCertStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL fNoLogoDisplay = FALSE;
    BOOL fQuiet = FALSE;
    DWORD STRONG_NAME_LENGTH = 8;
    PCWSTR pcwszFilename = NULL;
    DWORD dwRetVal = ERROR_SUCCESS;

    //
    // Quick check - are we to display the logo?
    for ( int j = 0; j < argc; j++ )
    {
        if (lstrcmpiW(argv[j], L"-nologo") == 0)
            fNoLogoDisplay = TRUE;
    }

    if ( !fNoLogoDisplay )
        wprintf(wchMicrosoftLogo);

    //
    // Now go look for the arguments.
    //
    if ((argc < 2) || !ParseArgs( argv, argc, &pcwszFilename, &fQuiet ))
    {
        DispUsage( argv[0] );
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    else if ( !pcwszFilename )
    {
        DispUsage( argv[0] );
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    hCertStore = CertOpenStore(
        CERT_STORE_PROV_FILENAME,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        NULL,
        CERT_STORE_OPEN_EXISTING_FLAG,
        (void*)pcwszFilename);

    if ( !hCertStore )
    {
        fwprintf( 
            stderr, 
            L"Unable to open the input file %ls, error %ld\n", 
            pcwszFilename,
            dwRetVal = ::GetLastError());
        goto Exit;
    }

    while ( pCertContext = CertEnumCertificatesInStore( hCertStore, pCertContext ) )
    {
        if ( !pCertContext->pCertInfo )
        {
            fwprintf( stderr, L"Oddity with file %ls - Certificate information not decodable\n" );
            continue;
        }

        WCHAR wsNiceName[BUFFER_SIZE] = { L'\0' };
        BYTE bBuffer[BUFFER_SIZE];
        SIZE_T cbBuffer = BUFFER_SIZE;
        DWORD dwKeyLength;
        PCERT_PUBLIC_KEY_INFO pKeyInfo = &(pCertContext->pCertInfo->SubjectPublicKeyInfo);
        DWORD dwDump;

        ZeroMemory( wsNiceName, sizeof( wsNiceName ) / sizeof( *wsNiceName ) );
        dwDump = CertGetNameStringW(
            pCertContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            wsNiceName,
            BUFFER_SIZE
            );
            
        if ( dwDump == 0 )
        {
            fwprintf(stderr, L"Unable to get certificate name string! Error %ld.", GetLastError());
            wcscpy(wsNiceName, L"(Unknown)");
        }

        if ( !fQuiet )
        {
            dwKeyLength = CertGetPublicKeyLength( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pKeyInfo );

            wprintf(L"\nCertificate: \"%ls\" - %ld bits long\n", wsNiceName, dwKeyLength);

            if ( dwKeyLength < 2048 )
            {
                wprintf(L"\tWarning! This key is too short to sign SxS assemblies with.\n\tSigning keys need to be 2048 bits or more.\n");
            }
        }
        
        if (!GetTokenOfKey( pKeyInfo, bBuffer, cbBuffer ))
        {
            fwprintf(stderr, L"Unable to generate public key token for this certificate.\n");
        }
        else
        {
            if ( !fQuiet ) wprintf(L"\tpublicKeyToken=\"");
            for ( SIZE_T i = 0; i < cbBuffer; i++ )

            {
                wprintf(L"%02x", bBuffer[i] );
            }
            if ( !fQuiet ) 
                wprintf(L"\"\n");
            else
                wprintf(L"\n");
            
        }
        
    }

Exit:

    if ( hCertStore != NULL )
    {
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        hCertStore = NULL;
    }

    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\catinfo\catinfo.cpp ===
#include "windows.h"
#include "wincrypt.h"
#include "mscat.h"
#include "stdio.h"
#include "stdlib.h"

VOID
DumpBytes(PBYTE pbBuffer, DWORD dwLength)
{
    for (DWORD dw = 0; dw < dwLength; dw++)
    {
        if (dw % 4 == 0 && dw)
            wprintf(L" ");
        if (dw % 32 == 0 && dw)
            wprintf(L"\n");
        wprintf(L"%02x", pbBuffer[dw]);
    }
}


#pragma pack(1)
typedef struct _PublicKeyBlob
{
    unsigned int SigAlgID;
    unsigned int HashAlgID;
    ULONG cbPublicKey;
    BYTE PublicKey[1];
}
PublicKeyBlob, *PPublicKeyBlob;



VOID
GenerateFusionStrongNameAndKeyFromCertificate(PCCERT_CONTEXT pContext)
{
    HCRYPTPROV      hProvider;
    HCRYPTKEY       hKey;
    PBYTE           pbFusionKeyBlob;
    BYTE            pbBlobData[8192];
    DWORD           cbBlobData = sizeof(pbBlobData);
    DWORD           cbFusionKeyBlob, dwTemp;
    PPublicKeyBlob  pFusionKeyStruct;

    if (!::CryptAcquireContextW(
            &hProvider,
            NULL,
            NULL,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT))
    {
        wprintf(L"Failed opening the crypt context: 0x%08x", ::GetLastError());
        return;
    }

    //
    // Load the public key info into a key to start with
    //
    if (!CryptImportPublicKeyInfo(
        hProvider,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        &pContext->pCertInfo->SubjectPublicKeyInfo,
        &hKey))
    {
        wprintf(L"Failed importing public key info from the cert-context, 0x%08x", ::GetLastError());
        return;
    }

    //
    // Export the key info to a public-key blob
    //
    if (!CryptExportKey(
            hKey,
            NULL,
            PUBLICKEYBLOB,
            0,
            pbBlobData,
            &cbBlobData))
    {
        wprintf(L"Failed exporting public key info back from an hcryptkey: 0x%08x\n", ::GetLastError());
        return;
    }

    //
    // Allocate the Fusion public key blob
    //
    cbFusionKeyBlob = sizeof(PublicKeyBlob) + cbBlobData - 1;
    pFusionKeyStruct = (PPublicKeyBlob)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbFusionKeyBlob);

    //
    // Key parameter for the signing algorithm
    //
    dwTemp = sizeof(pFusionKeyStruct->SigAlgID);
    CryptGetKeyParam(hKey, KP_ALGID, (PBYTE)&pFusionKeyStruct->SigAlgID, &dwTemp, 0);

    //
    // Move over the public key bits from CryptExportKey
    //
    pFusionKeyStruct->cbPublicKey = cbBlobData;
    pFusionKeyStruct->HashAlgID = CALG_SHA1;
    memcpy(pFusionKeyStruct->PublicKey, pbBlobData, cbBlobData);

    wprintf(L"\n  Public key structure:\n");
    DumpBytes((PBYTE)pFusionKeyStruct, cbFusionKeyBlob);

    //
    // Now let's go hash it.
    //
    {
        HCRYPTHASH  hKeyHash;
        BYTE        bHashedKeyInfo[8192];
        DWORD       cbHashedKeyInfo = sizeof(bHashedKeyInfo);

        if (!CryptCreateHash(hProvider, pFusionKeyStruct->HashAlgID, NULL, 0, &hKeyHash))
        {
            wprintf(L"Failed creating a hash for this key: 0x%08x\n", ::GetLastError());
            return;
        }

        if (!CryptHashData(hKeyHash, (PBYTE)pFusionKeyStruct, cbFusionKeyBlob, 0))
        {
            wprintf(L"Failed hashing data: 0x%08x\n", ::GetLastError());
            return;
        }

        if (!CryptGetHashParam(hKeyHash, HP_HASHVAL, bHashedKeyInfo, &cbHashedKeyInfo, 0))
        {
            wprintf(L"Can't get hashed key info 0x%08x\n", ::GetLastError());
            return;
        }

        CryptDestroyHash(hKeyHash);

        wprintf(L"\n  Hash of public key bits:       ");
        DumpBytes(bHashedKeyInfo, cbHashedKeyInfo);
        wprintf(L"\n  Fusion-compatible strong name: ");
        DumpBytes(bHashedKeyInfo + (cbHashedKeyInfo - 8), 8);
    }
}



VOID
PrintKeyContextInfo(PCCERT_CONTEXT pContext)
{
    BYTE bHash[8192];
    DWORD cbHash;

    WCHAR wszBuffer[8192];
    DWORD cchBuffer = 8192;

    wprintf(L"\n\n");

    CertGetNameStringW(pContext, CERT_NAME_FRIENDLY_DISPLAY_TYPE,
        0, NULL, wszBuffer, cchBuffer);

    wprintf(L"Certificate owner: %ls\n", wszBuffer);

    //
    // Spit out the key bits
    //
    wprintf(L"Found key info:\n");
    DumpBytes(
        pContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
        pContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

    //
    // And now the "strong name" (ie: sha1 hash) of the public key bits
    //
    if (CryptHashPublicKeyInfo(
        NULL,
        CALG_SHA1,
        0,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        &pContext->pCertInfo->SubjectPublicKeyInfo,
        bHash,
        &(cbHash = sizeof(bHash))))
    {
        wprintf(L"\nPublic key hash: ");
        DumpBytes(bHash, cbHash);
        wprintf(L"\nStrong name is:  ");
        DumpBytes(bHash, cbHash < 8 ? cbHash : 8);
    }
    else
    {
        wprintf(L"Unable to hash public key info: 0x%08x\n", ::GetLastError());
    }


    GenerateFusionStrongNameAndKeyFromCertificate(pContext);

    wprintf(L"\n\n");
}

int __cdecl wmain(int argc, WCHAR* argv[])
{
    HANDLE              hCatalog;
    HANDLE              hMapping;
    PBYTE               pByte;
    SIZE_T              cBytes;
    PCCTL_CONTEXT       pContext;

    hCatalog = CreateFileW(argv[1], GENERIC_READ,
        FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hCatalog == INVALID_HANDLE_VALUE)
    {
        wprintf(L"Ensure that %ls exists.\n", argv[1]);
        return 0;
    }

    hMapping = CreateFileMapping(hCatalog, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!hMapping || (hMapping == INVALID_HANDLE_VALUE))
    {
        CloseHandle(hCatalog);
        wprintf(L"Unable to map file into address space.\n");
        return 1;
    }

    pByte = (PBYTE)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hMapping);

    if (!pByte)
    {
        wprintf(L"Unable to open view of file.\n");
        CloseHandle(hCatalog);
        return 2;
    }

    if (((cBytes = GetFileSize(hCatalog, NULL)) == -1) || (cBytes < 1))
    {
        wprintf(L"Bad file size %d\n", cBytes);
        return 3;
    }

    if (pByte[0] != 0x30)
    {
        wprintf(L"File is not a catalog.\n");
        return 4;
    }

    pContext = (PCCTL_CONTEXT)CertCreateCTLContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pByte,
        cBytes);

    if (pContext)
    {
        BYTE    bIdent[8192];
        DWORD   cbIdent;
        PCERT_ID  cIdent;

        if (!CryptMsgGetParam(
            pContext->hCryptMsg,
            CMSG_SIGNER_CERT_ID_PARAM,
            0,
            bIdent,
            &(cbIdent = sizeof(bIdent))))
        {
            wprintf(L"Unable to get top-level signer's certificate ID: 0x%08x\n", ::GetLastError());
            return 6;
        }


        cIdent = (PCERT_ID)bIdent;
        HCERTSTORE hStore;

        //
        // Maybe it's there in the message?
        //
        {
            PCCERT_CONTEXT pThisContext = NULL;

            hStore = CertOpenStore(
                CERT_STORE_PROV_MSG,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                NULL,
                0,
                pContext->hCryptMsg);

            if (hStore && (hStore != INVALID_HANDLE_VALUE))
            {
                while (pThisContext = CertEnumCertificatesInStore(hStore, pThisContext))
                {
                    PCERT_INFO    pInfo = pThisContext->pCertInfo;
                    WCHAR        wszBuffer[8192];
                    DWORD        cchBuffer = sizeof(wszBuffer)/sizeof(*wszBuffer);

                    PrintKeyContextInfo(pThisContext);

                }
            }
        }

    }
    else
    {
        wprintf(L"Failed creating certificate context: 0x%08x\n", ::GetLastError());
        return 5;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\copy_bigpath\copy.cpp ===
//
// Simple wrapper around GetFullPathname and CopyFile that converts to \\? form,
// and also appends leaf file to directory name if necessary.
//
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#include "yvals.h"
#pragma warning(disable: 4663)
#pragma warning(pop)
#pragma warning(disable: 4018) /* signed/unsigned mismatch */
#pragma warning(disable: 4290) /* exception specification */
#include <vector>
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
BOOL
FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL
FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"copy_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::FusionpGetLastWin32Error();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::FusionpGetLastWin32Error();
        _snwprintf(rgchWin32Error, sizeof(rgchWin32Error) / sizeof(rgchWin32Error[0]), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}


extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    PWSTR p = NULL;
    std::vector<WCHAR> arg1;
    std::vector<WCHAR> arg2;
    BOOL Success = FALSE;
    PCWSTR Leaf = NULL;
    ULONG FileAttributes = 0;
    DWORD Error = 0;

    if (argc != 3)
    {
        fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <from> <to>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize(1UL << 15);
    arg2.resize(1UL << 15);
    arg1[0] = 0;
    arg2[0] = 0;
    if (!FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
        goto Exit;
    if (!FusionpConvertToBigPath(argv[2], arg2.size(), &arg2[0]))
        goto Exit;
    arg1.resize(1 + ::wcslen(&arg1[0]));
    arg2.resize(1 + ::wcslen(&arg2[0]));
    Error = NO_ERROR;
    Success = CopyFileW(&arg1[0], &arg2[0], FALSE);
    if (!Success
        && ((Error = ::FusionpGetLastWin32Error()) == ERROR_ACCESS_DENIED
            || Error == ERROR_PATH_NOT_FOUND)
        && (FileAttributes = GetFileAttributesW(&arg1[0])) != 0xffffffff
        && (FileAttributes = GetFileAttributesW(&arg2[0])) != 0xffffffff
        && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0
        && (Leaf = wcsrchr(&arg1[0], '\\')) != NULL
        )
    {
        arg2.insert(arg2.end() - 1, Leaf, arg1.end() - 1);
        Success = CopyFileW(&arg1[0], &arg2[0], FALSE);
    }
    if (!Success && Error != NO_ERROR)
    {
        ::FusionpSetLastWin32Error(Error);
    }
    if (!Success)
    {
        ::ReportFailure("CopyFile\n");
        goto Exit;
    }
    printf("%ls -> %ls\n", &arg1[0], &arg2[0]);

    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\fusionmanifestvalidator\helpers.h ===
// helpers.h
//
#pragma once

BOOL
Validating(
    PCWSTR     SourceManName,
    PCWSTR     SchemaName
    );

class CFileStreamBase : public IStream
{
public:
    CFileStreamBase()
        : m_cRef(0),
          m_hFile(INVALID_HANDLE_VALUE),
          m_bSeenFirstCharacter(false)
    { }

    virtual ~CFileStreamBase();

    bool OpenForRead(PCWSTR pszPath);

    bool Close();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);

protected:
    LONG                m_cRef;
    HANDLE              m_hFile;
    bool                m_bSeenFirstCharacter;

private:
    CFileStreamBase(const CFileStreamBase &r); // intentionally not implemented
    CFileStreamBase &operator =(const CFileStreamBase &r); // intentionally not implemented
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\clean\clean.cpp ===
/*
This program cleans build.exe trees.
*/
#include "windows.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// error messages
const static wchar_t errorNT[] = L"This program requires Windows NT.\n";

#define NumberOf(x) (sizeof(x)/sizeof((x)[0]))

void Log(const char* s, const wchar_t* q)
{
	printf(s, q);
}

void Log(const wchar_t* s)
{
	printf("%ls\n", s);
}

void Fail(const wchar_t* s)
{
	Log(s);
	exit(EXIT_FAILURE);
}

void LogRecurse(const wchar_t* s)
{
	printf("Recurse %ls\n", s);
}

void LogDelete(const wchar_t* s)
{
	printf("Delete %ls\n", s);
}

bool IsDotOrDotDot(const wchar_t* s)
{
	return
		(
			s[0] == '.' &&
			(
					(s[1] == 0)
				||	(s[1] == '.' && s[2] == 0)
			)
		);
}

void DeleteDirectory(wchar_t* directory, int length, WIN32_FIND_DATAW* wfd)
{
	directory[length] = 0;
	LogRecurse(directory);

	directory[length] = '\\';
	directory[length+1] = '*';
	directory[length+2] = 0;
	HANDLE hFind = FindFirstFileW(directory, wfd);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		__try
		{
			do
			{
				if (IsDotOrDotDot(wfd->cFileName))
				{
					continue;
				}
				DWORD dwFileAttributes = wfd->dwFileAttributes;
				directory[length] = '\\';
				wcscpy(directory + length + 1, wfd->cFileName);
				if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					DeleteDirectory(directory, length + 1 + wcslen(wfd->cFileName), wfd);
				}
				else
				{
					if (dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))
					{
						//if (!SetFileAttributesW(directory, dwFileAttributes & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
						{
							// ...
						}

					}
					if (DeleteFileW(directory))
					{
						LogDelete(directory);
					}
					else
					{
						// ...
					}
				}
			} while (FindNextFileW(hFind, wfd));
		}
		__finally
		{
			FindClose(hFind);
		}
	}
	directory[length] = 0;
	RemoveDirectoryW(directory);
	LogDelete(directory);
}

void CleanDirectory(
	const wchar_t* obj,
	wchar_t* directory,
	int length,
	WIN32_FIND_DATAW* wfd
	)
{
	directory[length] = 0;
	LogRecurse(directory);

	// clean build[d,fre,chk].[log,wrn,err] builds
	const static wchar_t dfrechk[][4] = { L"", L"d", L"fre", L"chk" };
	const static wchar_t logwrnerr[][4] = { L"log", L"wrn", L"err" };
	for (int b = 0 ; b < NUMBER_OF(dfrechk); b++)
	{
		for (int g = 0 ; g < NUMBER_OF(logwrnerr) ; ++g)
		{
			swprintf(directory + length, L"\\build%s.%s", dfrechk[b], logwrnerr[g]);
			if (DeleteFileW(directory))
			{
				LogDelete(directory);
			}
			else
			{
				// ...
			}
		}
	}
	// Dangerous to clean files out of source directory, but:
	// FUTURE clean *.plg (VC Project Log?) files
	// FUTURE clean *.rsp files that sometimes appear in source dir?
	// FUTURE clean MSG*.bin files that sometimes appear in source dir?
	// FUTURE clean RC* files that sometimes appear in source dir?

	directory[length] = '\\';
	wcscpy(directory + length + 1, obj);
	HANDLE hFind = FindFirstFileW(directory, wfd);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		__try
		{
			do
			{
				directory[length] = '\\';
				wcscpy(directory + length + 1, wfd->cFileName);
				DeleteDirectory(directory, length + 1 + wcslen(wfd->cFileName), wfd);
			}
			while (FindNextFileW(hFind, wfd));
		}
		__finally
		{
			FindClose(hFind);
		}
	}

	directory[length] = '\\';
	directory[length+1] = '*';
	directory[length+2] = 0;

	hFind = FindFirstFileW(directory, wfd);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		__try
		{
			do
			{
				if (IsDotOrDotDot(wfd->cFileName))
				{
					continue;
				}
				if (!(wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					continue;
				}
				directory[length] = '\\';
				wcscpy(directory + length + 1, wfd->cFileName);
				CleanDirectory(obj, directory, length + 1 + wcslen(wfd->cFileName), wfd);
			} while (FindNextFileW(hFind, wfd));
		}
		__finally
		{
			FindClose(hFind);
		}
	}
	directory[length] = 0;
}

#define Lx(x) L ## x
#define  L(x)  Lx(x)

int Clean(
	int argc,
	wchar_t** argv
	)
{
	Log(L"Clean version " L(__TIME__) L" " L(__DATE__));

// are we running on NT?
	long version = GetVersion();
	int  build = ((version >> 16) & 0x7fff);
	int  majorVersion = (version & 0xff);
	bool nt = !(version & 0x80000000);
	if (!nt)
	{
		Fail(errorNT);
	}

// These two buffers are shared by the whole call tree. Be careful.
	WIN32_FIND_DATAW wfd;
	wchar_t currentDirectory[1U << 15];

	if (argc != 2)
	{
		Log(
			"Usage: %ls [delete string].\n"
			" Typical deletion strings are obj, objd, and obj?.\n"
			" This will recursively delete directories matching\n"
			" the deletion string. It will also delete\n"
			" all files named build[d,fre,chk].[log,wrn,err].\n",
			argv[0] ? argv[0] : L"xxx.exe"
			);
		return EXIT_FAILURE;
	}
// I prefer GetCurrentDirectory, but other programs just print '.'
//	if (!GetCurrentDirectoryW(NUMBER_OF(currentDirectory), currentDirectory))
//	{
//		Fail();
//	}
	currentDirectory[0] = '.';
	currentDirectory[1] = 0;
	CleanDirectory(argv[1], currentDirectory, wcslen(currentDirectory), &wfd);

	return EXIT_SUCCESS;
}

int __cdecl wmain(
	int argc,
	wchar_t** argv
	)
{
	return Clean(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\dir_bigpath\dir.cpp ===
//
// Simple wrapper around GetFullPathname and FindFirstFile/FindNextFileand
// that converts to \\? form.
//
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#include "yvals.h"
#pragma warning(disable: 4663)
#include <vector>
#pragma warning(pop)
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
#include "fusionhandle.h"
BOOL
FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL
FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"mkdir_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::FusionpGetLastWin32Error();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::FusionpGetLastWin32Error();
        _snwprintf(rgchWin32Error, sizeof(rgchWin32Error) / sizeof(rgchWin32Error[0]), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    bool mkdir = false;
    bool copy = false;
    int iReturnStatus = EXIT_FAILURE;
    std::vector<WCHAR> arg1;
    PWSTR p = NULL;
    ULONG i = 0;
    WIN32_FIND_DATAW wfd;
    CFindFile FindFileHandle;

    if (argc != 2)
    {
        fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <directory-to-list>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize(1UL << 15);

    arg1[0] = 0;
    if (!FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
        goto Exit;
    arg1.resize(1 + ::wcslen(&arg1[0]));
    arg1.insert(arg1.end() - 1, '\\');
    arg1.insert(arg1.end() - 1, '*');
    if (!FindFileHandle.Win32FindFirstFile(&arg1[0], &wfd))
    {
        ::ReportFailure("FindFirstFile\n");
        goto Exit;
    }
    do
    {
        LARGE_INTEGER Size;
        Size.HighPart = wfd.nFileSizeHigh;
        Size.LowPart = wfd.nFileSizeLow;

        printf("%I64u, %ls%ls\n", Size.QuadPart, wfd.cFileName, (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? L"/" : L"");

    } while(::FindNextFileW(FindFileHandle, &wfd));

//Success:
    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\fusionmanifestvalidator\stdinc.h ===
// stdinc.h
//
#if defined(_WIN64)
#define UNICODE
#define _UNICODE
#endif
#define __USE_MSXML2_NAMESPACE__
#include <utility>
#pragma warning(disable:4663) /* C++ language change */
#pragma warning(disable:4512) /* assignment operator could not be generated */
#pragma warning(disable:4511) /* copy constructor could not be generated */
#pragma warning(disable:4189) /* local variable is initialized but not referenced */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion, possible loss of data */
#pragma warning(disable:4244) /* conversion, possible loss of data */
#endif
#include "windows.h"
#include <vector>
#include <string>
#include <algorithm>
#include <map>
#include <stdio.h>
#include "wincrypt.h"
#include "objbase.h"
#include "msxml.h"
#include "msxml2.h"
#include "imagehlp.h"
#include "atlbase.h"
#include "comdef.h"
#include "comutil.h"
#include "tchar.h"
typedef CONST VOID* PCVOID;
#define QUIET_MODE  0x001
#define NORM_MODE   0x002
#include "share.h"
using std::string;
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#include "helpers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\fuslogvw\cdlids.h ===
#define IDD_CDLLOGVIEW            1500
#define IDC_CB_VIEWLOG            1501
#define IDC_CB_REFRESH            1502
#define IDC_CB_DELETE             1503
#define IDC_CB_DELETE_ALL         1504
#define IDC_LV_LOGMESSAGES        1505
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\fusionmanifestvalidator\filestream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Implementation of IStream over a win32 file.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include "helpers.h"
#include <windows.h>
#include "atlbase.h"
#include "atlconv.h"

#define IS_NT() ((GetVersion() & 0x80000000) == 0)

BOOL
MySetFilePointerEx(
  HANDLE         File,                    // handle to file
  LARGE_INTEGER  DistanceToMove,  // bytes to move pointer
  PLARGE_INTEGER NewFilePointer, // new file pointer
  DWORD          MoveMethod               // starting point
)
{
    LONG DistanceToMoveLow  = static_cast<LONG>(DistanceToMove.LowPart);
    LONG DistanceToMoveHigh = DistanceToMove.HighPart;
    DWORD NewPositionLow = SetFilePointer(File, DistanceToMoveLow, &DistanceToMoveHigh, MoveMethod);

    if (NewPositionLow == INVALID_SET_FILE_POINTER)
    {
        if (GetLastError() != NO_ERROR)
            return FALSE;
    }
    if (NewFilePointer != NULL)
    {
        NewFilePointer->LowPart =  NewPositionLow;
        NewFilePointer->HighPart = DistanceToMoveHigh;
    }
    return TRUE;
}

CFileStreamBase::~CFileStreamBase()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        const DWORD dwLastError = ::GetLastError();
        ::CloseHandle(m_hFile);
        ::SetLastError(dwLastError);
    }
}

bool
CFileStreamBase::OpenForRead(PCWSTR pszPath)
{
    USES_CONVERSION;

    if (m_hFile != INVALID_HANDLE_VALUE)
        return false;

    m_hFile =
        IS_NT() ? CreateFileW(pszPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)
                : CreateFileA(W2A(pszPath), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    return (m_hFile != INVALID_HANDLE_VALUE);
}

bool
CFileStreamBase::Close()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        if (!::CloseHandle(m_hFile))
        {
            return false;
        }
        m_hFile = INVALID_HANDLE_VALUE;
    }

    return true;
}

ULONG
CFileStreamBase::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

ULONG
CFileStreamBase::Release()
{
    return ::InterlockedDecrement(&m_cRef);
}

HRESULT
CFileStreamBase::QueryInterface(
    REFIID riid,
    PVOID* ppvObj
    )
{
    HRESULT hr = NOERROR;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        *ppvObj = static_cast<IStream *>(this);
    else
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    AddRef();

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CFileStreamBase::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = NOERROR;
    ULONG cbRead = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if (!m_bSeenFirstCharacter)
    {
#ifdef AWFUL_SPACE_HACK
        while (true)
        {
            CHAR ch;
            ReadFile(m_hFile, &ch, 1, &cbRead, NULL);
            if ((ch != '\n') && (ch != '\r') && (ch != ' ') && (ch != '\t')) {
                m_bSeenFirstCharacter = true;
                LARGE_INTEGER li;
                li.QuadPart = -1;
                ::MySetFilePointerEx(m_hFile, li, NULL, FILE_CURRENT);
                break;
            }
        }
#endif
    }

    if (!::ReadFile(m_hFile, pv, cb, &cbRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbRead == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbRead != NULL)
        *pcbRead = cbRead;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Write(
    void const *pv,
    ULONG cb,
    ULONG *pcbWritten
    )
{
    HRESULT hr = NOERROR;
    ULONG cbWritten = 0;

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    if (!::WriteFile(m_hFile, pv, cb, &cbWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbWritten == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition
    )
{
    HRESULT hr = NOERROR;
    DWORD dwWin32Origin = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    switch (dwOrigin)
    {
    default:
        hr = E_INVALIDARG;
        goto Exit;

    case STREAM_SEEK_SET:
        dwWin32Origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        dwWin32Origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        dwWin32Origin = FILE_END;
        break;
    }

    if (!::MySetFilePointerEx(
                m_hFile,
                dlibMove,
                (LARGE_INTEGER *) plibNewPosition,
                dwWin32Origin))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CFileStreamBase::SetSize(
    ULARGE_INTEGER libNewSize
    )
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten
    )
{
    if (pcbRead != NULL)
        pcbRead->QuadPart = 0;

    if (pcbWritten != NULL)
        pcbWritten->QuadPart = 0;

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Commit(
    DWORD grfCommitFlags
    )
{
    HRESULT hr = NOERROR;

    if (grfCommitFlags != 0)
        return E_INVALIDARG;

    if (!Close())
        hr = HRESULT_FROM_WIN32 (GetLastError());

    return hr ;
}

HRESULT
CFileStreamBase::Revert()
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag
    )
{
    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(*pstatstg));

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Clone(
    IStream** ppIStream
   )
{
    if (ppIStream != NULL)
        *ppIStream = NULL;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\fusionmanifestvalidator\xmlchk.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xmlchk.cpp

Abstract:

    Use msxml.dll to see if an .xml file conforms to a schema.

Author:

    Ted Padua (TedP)

Revision History:

    Jay Krell (JayKrell) April 2001 partial cleanup
                         many leaks added in attempt to stop it from crashing
                         crash doesn't repro consistently, but there's always a few
                         in a world build

                         June 2001 let it run on Win9x and Win2000

--*/
#include "stdinc.h"
#include "helpers.h"
unsigned long g_nrunFlags = 0; //global run flag - determines if should run in silent mode = 0x01
IClassFactory* g_XmlDomClassFactory;
IClassFactory* g_XmlSchemaCacheClassFactory;
__declspec(thread) long line = __LINE__;
__declspec(thread) ULONG lastError;
#if defined(_WIN64)
#define IsAtLeastXp() (TRUE)
#define g_IsNt (TRUE)
#else
DWORD g_Version;
BOOL  g_IsNt;
#define IsAtLeastXp() (g_IsNt && g_Version >= 0x0501)
#endif

// Globals indicating what we're currently doing.
// L"" is different than the default constructed, because it can be derefed
ATL::CComBSTR szwcharSchemaTmp = L"";
ATL::CComBSTR szwcharManTmp = L"";
bool g_fInBuildProcess = false;

// string to put in front of all error messages so that BUILD can find them.
const char ErrMsgPrefix[] = "NMAKE : U1234: 'FUSION_MANIFEST_VALIDATOR' ";

void ConvertNewlinesToSpaces(char* s)
{
    while (*s)
    {
        if (isspace(*s))
            *s = ' ';
        s += 1;
    }
}

void Error(PCSTR szPrintFormatString, ...)
{
    char buffer[10000];

    va_list args;
    va_start(args, szPrintFormatString);
    vsprintf(buffer, szPrintFormatString, args);
    ConvertNewlinesToSpaces(buffer);
    fprintf(stderr, "%s line=%ld, %s\n", ErrMsgPrefix, line, buffer);
    va_end(args);
}

void PrintOutMode(PCSTR szPrintFormatString, ...)
{
    if (g_fInBuildProcess)
        return;

    if (g_nrunFlags & 1)
    {
        va_list args;
        va_start(args, szPrintFormatString);
        vprintf(szPrintFormatString, args);
        va_end(args);
    }
}

void PrintErrorDuringBuildProcess(IXMLDOMParseError* pError)
{
    HRESULT hr = S_OK;
    ATL::CComBSTR bstrError;
    ATL::CComBSTR bstrText;
    ATL::CComBSTR bstrFileUrl;
    long lErrorCode = 0;
    long lLinePos = 0;
    long lErrorLine = 0;
    long line = __LINE__;

    try
    {
        line = __LINE__;
        if (FAILED(hr = pError->get_reason(&bstrError)))
            throw hr;

        line = __LINE__;
        if (FAILED(hr = pError->get_errorCode(&lErrorCode)))
            throw hr;

        line = __LINE__;
        if (FAILED(hr = pError->get_srcText(&bstrText)))
            throw hr;

        line = __LINE__;
        if (FAILED(hr = pError->get_line(&lErrorLine)))
            throw hr;

        line = __LINE__;
        if (FAILED(hr = pError->get_url(&bstrFileUrl)))
            throw hr;

        if (bstrFileUrl == static_cast<PCWSTR>(NULL))
        {
            bstrFileUrl = szwcharManTmp;
        }

        line = __LINE__;
        if (FAILED(hr = pError->get_linepos(&lLinePos)))
            throw hr;

        Error(
            "error XML%08lX: %ls(%lx) : %ls\n",
            lErrorCode,
            static_cast<PCWSTR>(bstrFileUrl),
            lErrorLine,
            static_cast<PCWSTR>(bstrError));
    }
    catch(HRESULT hr2)
    {
        Error("Failed getting error #1 information hr=%lx, line=%ld\n", static_cast<unsigned long>(hr2), line);
    }
    catch(...)
    {
        Error("Failed getting error #2 information hr=%lx, line=%ld\n", static_cast<unsigned long>(hr), line);
    }
}


void PrintError(IXMLDOMParseError *pError)
{
    ATL::CComBSTR   bstrError;
    ATL::CComBSTR   bstrURL;
    ATL::CComBSTR   bstrText;
    long            errCode = 0;
    long            errLine = 0;
    long            errPos = 0;
    HRESULT         hr = S_OK;
    long            line = __LINE__;
    try
    {
        line = __LINE__;
        hr = pError->get_reason(&bstrError);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_url(&bstrURL);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_errorCode(&errCode);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_srcText(&bstrText);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_line(&errLine);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        hr = pError->get_linepos(&errPos);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;

        PrintOutMode("\nError Info:\n");
        if (bstrError != NULL)
            PrintOutMode("\tDescription: %ls\n", static_cast<PCWSTR>(bstrError));

        if (bstrURL != NULL)
            PrintOutMode("\tURL: %ls\n", static_cast<PCWSTR>(bstrURL));

        //if (errCode > 0)
        PrintOutMode("\tCode=%X", errCode);

        if (errLine > 0)
            PrintOutMode(" on Line:%ld, ", errLine);

        if (errPos > 0)
            PrintOutMode("\tPos:%ld\n", errPos);

        line = __LINE__;
        if (errLine > 0 && bstrText != NULL)
        {
            PrintOutMode("\tLine %ld: ", errLine);

            long lLen = ::SysStringLen(bstrText);
            for (int i = 0; i < lLen; i++)
            {
                if (bstrText[i] == '\t')
                    PrintOutMode(" ");
                else
                    PrintOutMode("%lc", bstrText[i]);
            }
            PrintOutMode("\n");

            if (errPos > 0 || lLen > 0)
            {
                PrintOutMode("\tPos  %ld: ", errPos);
                for (int i = 1; i < errPos; i++)
                {
                    PrintOutMode("-");
                }
                PrintOutMode("^\n");
            }
        }
        line = __LINE__;
    }
    catch(HRESULT hr2)
    {
        Error("Failed getting error #1 information hr=%lx, line=%ld\n", static_cast<unsigned long>(hr2), line);
    }
    catch(...)
    {
        Error("Failed getting error #2 information hr=%lx, line=%ld\n", static_cast<unsigned long>(hr), line);
    }
}


//tedp
// Load an msxml version.  If we don't get v3, we fall to v2, then to v1.  v1 is pretty darn useless,
// however, so it'd be nice if we didn't have to.

bool
InitializeMSXML3()
{
    static HMODULE hMsXml3 = NULL;
    typedef HRESULT (__stdcall * PFN_DLL_GET_CLASS_OBJECT)(REFCLSID, REFIID, LPVOID*);
    PFN_DLL_GET_CLASS_OBJECT pfnGetClassObject = NULL;
    ATL::CComPtr<IClassFactory> pFactory;
    HRESULT hr = S_OK;
    ATL::CComPtr<IClassFactory> pSchemaCacheFactory;

    line = __LINE__;
    if (hMsXml3 == NULL)
    {
        hMsXml3 = LoadLibrary(TEXT("msxml3.dll"));
        if (hMsXml3 == NULL)
        {
            line = __LINE__;
            if (IsAtLeastXp())
                PrintOutMode("Unable to load msxml3, trying msxml2\n");
            line = __LINE__;
            if (IsAtLeastXp())
                hMsXml3 = LoadLibrary(TEXT("msxml2.dll"));
            line = __LINE__;
            if (hMsXml3 == NULL)
            {
                line = __LINE__;
                if (IsAtLeastXp())
                    PrintOutMode("Unable to load msxml2\n");
                line = __LINE__;
            }
        }
    }

    line = __LINE__;
    if (hMsXml3 == NULL)
    {
        if (IsAtLeastXp())
            Error("LoadLibrary(msxml) lastError=%lu\n", GetLastError());
        return false;
    }

    line = __LINE__;
    pfnGetClassObject = reinterpret_cast<PFN_DLL_GET_CLASS_OBJECT>(GetProcAddress(hMsXml3, "DllGetClassObject"));
    if (!pfnGetClassObject)
    {
        line = __LINE__;
        Error("GetProcAddress(msxml, DllGetClassObject) lastError=%lu\n", GetLastError());
        return false;
    }

    line = __LINE__;
    hr = pfnGetClassObject(__uuidof(MSXML2::DOMDocument30), __uuidof(pFactory), (void**)&pFactory);
    if (FAILED(hr))
    {
        PrintOutMode("Can't load version 3.0, trying 2.6\n");

        hr = pfnGetClassObject(__uuidof(MSXML2::DOMDocument26), __uuidof(pFactory), (void**)&pFactory);
        if (FAILED(hr))
        {
            PrintOutMode("Can't load version 2.6\n");
        }
    }
    static_cast<IUnknown*>(pFactory)->AddRef(); // jaykrell hack to try to avoid crash
    static_cast<IUnknown*>(pFactory)->AddRef(); // jaykrell hack to try to avoid crash

    line = __LINE__;
    if (FAILED(hr))
    {
        Error("msxml.DllGetClassObject(DOMDocument) hr=%lx\n", hr);
        return false;
    }

    g_XmlDomClassFactory = pFactory;

    hr = pfnGetClassObject(__uuidof(MSXML2::XMLSchemaCache30), __uuidof(pFactory), (void**)&pSchemaCacheFactory);
    if (FAILED(hr))
    {
        PrintOutMode("Can't load SchemaCache version 3.0, trying 2.6\n");

        hr = pfnGetClassObject(__uuidof(MSXML2::XMLSchemaCache26), __uuidof(pFactory), (void**)&pSchemaCacheFactory);
        if (FAILED(hr))
        {
            PrintOutMode("Can't load SchemaCache version 2.6\n");
        }
    }
    static_cast<IUnknown*>(pSchemaCacheFactory)->AddRef(); // jaykrell hack to try to avoid crash
    static_cast<IUnknown*>(pSchemaCacheFactory)->AddRef(); // jaykrell hack to try to avoid crash

    if (FAILED(hr))
    {
        Error("msxml.DllGetClassObject(SchemaCache) hr=%lx\n", hr);
        return false;
    }

    g_XmlSchemaCacheClassFactory = pSchemaCacheFactory;

    return true;
}

BOOL
Validating(
    PCWSTR      SourceManName,
    PCWSTR      SchemaName
   )
{
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    short sResult = FALSE;
    VARIANT_BOOL vb = VARIANT_FALSE;
    ATL::CComPtr<IXMLDOMParseError> pParseError;
    ATL::CComPtr<IXMLDOMParseError> pParseError2;
    ATL::CComPtr<IXMLDOMDocument> document;
    ATL::CComPtr<MSXML2::IXMLDOMDocument2> spXMLDOMDoc2;
    ATL::CComPtr<MSXML2::IXMLDOMSchemaCollection> spIXMLDOMSchemaCollection;
    try
    {
        hr = g_XmlDomClassFactory->CreateInstance(NULL, __uuidof(document), (void**)&document);
        if (FAILED(hr))
        {
            Error("msxml.CreateInstance(document) hr=%lx\n", hr);
            throw hr;
        }
        if (document != NULL)
        {
            static_cast<IUnknown*>(document)->AddRef(); // jaykrell hack to try to avoid crash
            static_cast<IUnknown*>(document)->AddRef(); // jaykrell hack to try to avoid crash
        }

        //
        // If they're willing to deal with bad XML, then so be it.
        //

        // First pass - validating the manifest itself alone
        PrintOutMode("Validating the manifest as XML file...\n");
        hr = document->put_async(VARIANT_FALSE);
        if (FAILED(hr))
            throw hr;

        hr = document->put_validateOnParse(VARIANT_FALSE);
        if (FAILED(hr))
            throw hr;

        hr = document->put_resolveExternals(VARIANT_FALSE);
        if (FAILED(hr))
            throw hr;

        line = __LINE__;
        CFileStreamBase* fsbase = new CFileStreamBase; // jaykrell leak out of paranoia
        fsbase->AddRef(); // jaykrell leak out of paranoia
        fsbase->AddRef(); // jaykrell leak out of paranoia
        fsbase->AddRef(); // jaykrell leak out of paranoia
        ATL::CComPtr<IStream> istream = fsbase;

        if (!fsbase->OpenForRead(SourceManName))
        {
            lastError = GetLastError();
            hr = HRESULT_FROM_WIN32(lastError);
            Error("OpenForRead(%ls) lastError=%lu\n", SourceManName, lastError);
            throw hr;
        }

        hr = document->load(ATL::CComVariant(istream), &vb);
        if (FAILED(hr) || vb == VARIANT_FALSE)
        {
            if (vb == VARIANT_FALSE)
            PrintOutMode("Well Formed XML Validation: FAILED\n");
            {
                HRESULT loc_hr = document->get_parseError(&pParseError);
                if (pParseError != NULL)
                {
                    static_cast<IUnknown*>(pParseError)->AddRef(); // jaykrell hack to try to avoid crash
                    static_cast<IUnknown*>(pParseError)->AddRef(); // jaykrell hack to try to avoid crash
                }
                if (g_fInBuildProcess)
                    PrintErrorDuringBuildProcess(pParseError);
                else
                    PrintError(pParseError);
            }
            throw hr;
        }
        else
            PrintOutMode("Well Formed XML Validation: Passed\n");

        // Second pass - validating manifest against schema
        PrintOutMode("\nNow validating manifest against XML Schema file...\n");

        // CreateInstance creates you an instance of the object you requested above, and puts
        // the pointer in the out param.  Think of this like CoCreateInstance, but knowing who
        // is going
        hr = g_XmlDomClassFactory->CreateInstance(NULL, __uuidof(spXMLDOMDoc2), (void**)&spXMLDOMDoc2);
        if (FAILED(hr))
        {
             PrintOutMode("Failed creating IXMLDOMDoc2...\n");
            throw hr;
        }
        static_cast<IUnknown*>(spXMLDOMDoc2)->AddRef(); // jaykrell hack to try to avoid crash
        static_cast<IUnknown*>(spXMLDOMDoc2)->AddRef(); // jaykrell hack to try to avoid crash

         hr = spXMLDOMDoc2->put_async(VARIANT_FALSE);
         if (FAILED(hr))
            throw hr;

         hr = spXMLDOMDoc2->put_validateOnParse(VARIANT_TRUE); //changed - was FALSE
         if (FAILED(hr))
            throw hr;

         hr = spXMLDOMDoc2->put_resolveExternals(VARIANT_FALSE);
         if (FAILED(hr))
            throw hr;

         hr = g_XmlSchemaCacheClassFactory->CreateInstance(NULL, __uuidof(spIXMLDOMSchemaCollection), (void**)&spIXMLDOMSchemaCollection);
         if (FAILED(hr))
         {
             PrintOutMode("Failed creating IXMLDOMSchemaCollection...\n");
             throw hr;
         }
        static_cast<IUnknown*>(spIXMLDOMSchemaCollection)->AddRef(); // jaykrell hack to try to avoid crash
        static_cast<IUnknown*>(spIXMLDOMSchemaCollection)->AddRef(); // jaykrell hack to try to avoid crash

         if ((FAILED(hr) || !spIXMLDOMSchemaCollection))
            throw hr;

           
        hr = spIXMLDOMSchemaCollection->add(
            ATL::CComBSTR(L"urn:schemas-microsoft-com:asm.v1"),
            ATL::CComVariant(SchemaName));

        if(FAILED(hr))
        {
            PrintOutMode("BAD SCHEMA file.\n");
            throw hr;
        }

        static_cast<IUnknown*>(spIXMLDOMSchemaCollection)->AddRef(); // jaykrell hack to try to avoid crash
        static_cast<IUnknown*>(spIXMLDOMSchemaCollection)->AddRef(); // jaykrell hack to try to avoid crash
        // ownership of the idispatch/variant-by-value is not clear
        ATL::CComVariant varValue(ATL::CComQIPtr<IDispatch>(spIXMLDOMSchemaCollection).Detach());
        hr = spXMLDOMDoc2->putref_schemas(varValue);

        // The document will load only if a valid schema is
        // attached to the xml file.
        // jaykrell leak here because ownership isn't clear
        hr = spXMLDOMDoc2->load(ATL::CComVariant(ATL::CComBSTR(SourceManName).Copy()), &sResult);

        if (FAILED(hr) || sResult == VARIANT_FALSE)
        {
            PrintOutMode("Manifest Schema Validation: FAILED\n");
            if (sResult == VARIANT_FALSE)
            {
                HRESULT loc_hr = spXMLDOMDoc2->get_parseError(&pParseError2);
                if (pParseError2 != NULL)
                {
                    static_cast<IUnknown*>(pParseError2)->AddRef(); // jaykrell hack to try to avoid crash
                    static_cast<IUnknown*>(pParseError2)->AddRef(); // jaykrell hack to try to avoid crash
                }
                if (g_fInBuildProcess)
                    PrintErrorDuringBuildProcess(pParseError2);
                else
                    PrintError(pParseError2);
                bResult = FALSE;
            }
            else
            {
                throw hr;
            }
        }
        else
        {
            PrintOutMode("Manifest Schema Validation: Passed\n");
            bResult = TRUE;
        }
   }
   catch(...)
   {
        bResult = FALSE;
        if (E_NOINTERFACE == hr)
        {
            Error("*** Error *** No such interface supported! \n");
        }
        else
        {
            ATL::CComPtr<IErrorInfo> pErrorInfo;
            HRESULT loc_hr = GetErrorInfo(0, &pErrorInfo);
            if (pErrorInfo != NULL)
            {
                static_cast<IUnknown*>(pErrorInfo)->AddRef(); // jaykrell hack to try to avoid crash
                static_cast<IUnknown*>(pErrorInfo)->AddRef(); // jaykrell hack to try to avoid crash
            }
            if ((S_OK == loc_hr) && pErrorInfo != NULL)
            {
                ATL::CComBSTR errSource;
                ATL::CComBSTR errDescr;
                pErrorInfo->GetDescription(&errDescr);
                pErrorInfo->GetSource(&errSource);
                Error("*** ERROR *** generated by %ls\n", static_cast<PCWSTR>(errSource));
                Error("*** ERROR *** description: %ls\n", static_cast<PCWSTR>(errDescr));
            }
            else
            {
                if (hr == CO_E_CLASSSTRING)
                {
                    Error("*** Error *** hr returned: CO_E_CLASSSTRING, value %x\n", hr);
                    Error("              msg: The registered CLSID for the ProgID is invalid.\n");
                }
                else
                {
                    Error("*** Error *** Cannot obtain additional error info hr=%lx!\n", static_cast<unsigned long>(hr));
                }
            }
        }
    }
    return bResult;
}

BOOL IsValidCommandLineArgs(int argc, wchar_t** argv, ATL::CComBSTR& szwcharSchemaTmp, ATL::CComBSTR& szwcharManTmp)
{
    // check commandline args a little
    int nOnlyAllowFirstTimeReadFlag = 0; //Manifest = 0x01 Schema = 0x02 Quiet = 0x04
    if((4 >= argc) && (3 <= argc))
    {
        //now check actual values

        for (int i = 1; i < argc; i++)
        {
            if (argv[i][0] == L'/')
            {
                switch (argv[i][1])
                {
                case L'?': return FALSE; break;
                case L'q': case L'Q':
                    if(0x04 & nOnlyAllowFirstTimeReadFlag)
                        return FALSE;
                    else
                        g_nrunFlags |= 1;

                    nOnlyAllowFirstTimeReadFlag = 0x04;
                    break;
                case L'm': case L'M':
                    if (argv[i][2] == L':')
                        {
                        if(0x01 & nOnlyAllowFirstTimeReadFlag)
                            return FALSE;
                        else
                            szwcharManTmp = &argv[i][3];

                        nOnlyAllowFirstTimeReadFlag = 0x01;
                        break;
                        }
                    else
                        {
                        return FALSE;
                        }
                case L's': case L'S':
                    if (argv[i][2] == L':')
                        {
                        if(0x02 & nOnlyAllowFirstTimeReadFlag)
                            return FALSE;
                        else
                            szwcharSchemaTmp = &argv[i][3];

                        nOnlyAllowFirstTimeReadFlag = 0x02;
                        break;
                    }
                    else
                    {
                        return FALSE;
                    }
                case L'B': case L'b':
                    g_fInBuildProcess = true;
                    break;

                default:
                    return FALSE;
                }
            }
            else
                return FALSE;

        }
        if ((0 == szwcharSchemaTmp[0]) ||
            (0 == szwcharManTmp[0]))
        {
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void PrintUsage()
{
    printf("\n");
    printf("Validates Fusion Win32 Manifest files using a schema.");
    printf("\n");
    printf("Usage:");
    printf("    FusionManifestValidator /S:[drive:][path]schema_filename /M:[drive:][path]xml_manifest_filename [/Q]\n\n");
    printf("    /S:   Specify schema filename used to validate manifest\n");
    printf("    /M:   Specify manifest filename to validate\n");
    printf("    /Q    Quiet mode - suppresses output to console\n");
    printf("     \n");
    printf("          The tool without /Q displays details of first encountered error\n");
    printf("          (if errors are present in manifest), and displays Pass or Fail\n");
    printf("          of the validation result. The application returns 0 for Pass,\n");
    printf("          1 for Fail, and returns 2 for bad command line argument.\n");
}

int __cdecl wmain(int argc, wchar_t** argv)
{
    g_nrunFlags = 0;
    int iValidationResult = 0;

#if !defined(_WIN64)
    g_Version = GetVersion();
    g_IsNt = ((g_Version & 0x80000000) == 0);
    g_Version = ((g_Version >> 8) & 0xFF) | ((g_Version & 0xFF) << 8);
    //printf("%x\n", g_Version);
#endif

    // Start COM
    CoInitialize(NULL);

    if (!IsValidCommandLineArgs(argc, argv, szwcharSchemaTmp, szwcharManTmp))
    {
        PrintUsage();
        iValidationResult = 2;  //return error value 2 for CommandLine Arg error
    }
    else
    {
        PrintOutMode("Schema is: %ls\n", static_cast<PCWSTR>(szwcharSchemaTmp));
        PrintOutMode("Manifest is: %ls\n\n", static_cast<PCWSTR>(szwcharManTmp));
        if (InitializeMSXML3())
        {
            BOOL bResult = Validating(szwcharManTmp, szwcharSchemaTmp);
            if (bResult)
                PrintOutMode("\nOverall Validation PASSED.\n");
            else
            {
                Error("Overall Validation FAILED, CommandLine=%ls.\n", GetCommandLineW());
                iValidationResult = 1; //return error value 1 for Validation routine error
            }
        }
        else
        {
            //
            // If running on less than Windows XP, just claim success.
            //
            if (IsAtLeastXp())
            {
                Error("Unable to load MSXML3\n");
                iValidationResult = 3;
            }
            else
                PrintOutMode("\nMsXml3 not always available downlevel, just claim overall Validation PASSED.\n");
        }
    }
    // Stop COM
    //CoUninitialize();
    TerminateProcess(GetCurrentProcess(), iValidationResult);
    return iValidationResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\popcopy\stdinc.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\pktextract\ntdll_hak\ntdll_hak.cpp ===
#define dllimport /* nothing */
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID
    )
{
    return NULL;
}

VOID
NTAPI
RtlPopFrame(
    IN PTEB_ACTIVE_FRAME Frame
    )
{
}


VOID
NTAPI
RtlPushFrame(
    IN PTEB_ACTIVE_FRAME Frame
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\mkdir_bigpath\mkdir.cpp ===
//
// Simple wrapper around GetFullPathname and CreateDirectory that converts to \\? form,
// and creates multiple levels.
//
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#include "yvals.h"
#pragma warning(disable: 4663)
#include <vector>
#pragma warning(pop)
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
BOOL
FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL
FusionpSkipBigPathRoot(PCWSTR s, OUT SIZE_T*);
BOOL
FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"mkdir_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::FusionpGetLastWin32Error();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::FusionpGetLastWin32Error();
        _snwprintf(rgchWin32Error, sizeof(rgchWin32Error) / sizeof(rgchWin32Error[0]), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    bool mkdir = false;
    bool copy = false;
    int iReturnStatus = EXIT_FAILURE;
    std::vector<WCHAR> arg1;
    PWSTR p = NULL;
    SIZE_T i = 0;

    if (argc != 2)
    {
        fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <directory-to-create>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize(1UL << 15);

    arg1[0] = 0;
    if (!FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
        goto Exit;

    if (!FusionpSkipBigPathRoot(&arg1[0], &i))
        goto Exit;
    p = &arg1[i];
    //printf("%ls\n", &arg1[0]);
    while (*p != 0)
    {
        p += wcscspn(p, L"\\/");
        *p = 0;
        if (!CreateDirectoryW(&arg1[0], NULL))
        {
            if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
            {
                ::ReportFailure("CreateDirectoryW\n");
                goto Exit;
            }
            ULONG FileAttributes;
            FileAttributes = GetFileAttributesW(&arg1[0]);
            if (FileAttributes != 0xffffff && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                ::FusionpSetLastWin32Error(ERROR_ALREADY_EXISTS);
                ::ReportFailure("FileInsteadOfDirectoryAlreadyExists\n");
                goto Exit;
            }
        }
        printf("%ls\n", &arg1[0]);
        *p = '\\';
        p += wcsspn(p, L"\\/");
    }

//Success:
    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\mjgcopy\mjgcopy.cpp ===
#include "stdinc.h" // actually from dll\whistler directory
/*-----------------------------------------------------------------------------
Side X ("by") Side Test
-----------------------------------------------------------------------------*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#pragma warning(disable: 4663)
#include <yvals.h>
#pragma warning(disable: 4663)
#include <string>
#include <deque>
#include <vector>
#pragma warning(pop)
#include "fusionbuffer.h"
#include "fusion.h"
#include "sxsasmname.h"
#include "util.h"
#include "filestream.cpp"
#include "sxsapi.h"
#include "fusiontrace.h"
#include "cresourcestream.cpp"
#include "cmemorystream.cpp"
#include "wintrust.h"
#include "softpub.h"
#include "perfclocking.h"
#include "strongname.h"
#include "fusionversion.h"
#include "fusionhash.h"
#include "fusiondeque.h"

BOOL
MySetFilePointerEx(
  HANDLE         File,                    // handle to file
  LARGE_INTEGER  DistanceToMove,  // bytes to move pointer
  PLARGE_INTEGER NewFilePointer, // new file pointer
  DWORD          MoveMethod               // starting point
)
{
    LONG DistanceToMoveLow  = static_cast<LONG>(DistanceToMove.LowPart);
    LONG DistanceToMoveHigh = DistanceToMove.HighPart;
    DWORD NewPositionLow = SetFilePointer(File, DistanceToMoveLow, &DistanceToMoveHigh, MoveMethod);

    if (NewPositionLow == INVALID_SET_FILE_POINTER)
    {
        if (GetLastError() != NO_ERROR)
            return FALSE;
    }
    if (NewFilePointer != NULL)
    {
        NewFilePointer->LowPart =  NewPositionLow;
        NewFilePointer->HighPart = DistanceToMoveHigh;
    }
    return TRUE;
}

BOOL FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }

void ReportFailure(const char szFormat[], ...);

PCWSTR g_pszImage = L"mjgcopy";

CRITICAL_SECTION g_cs;

ULONGLONG g_FilesCopied = 0;
ULONGLONG g_BytesCopied = 0;
ULONGLONG g_FilesLinked = 0;
ULONGLONG g_DirectoriesCopied = 0;
ULONGLONG g_CopiesSkipped = 0;
ULONGLONG g_LinksSkipped = 0;
ULONGLONG g_FileCopiesProcessed = 0;
ULONGLONG g_FileLinksProcessed = 0;
ULONGLONG g_DirScansProcessed = 0;

ULONGLONG g_BytesToCopy = 0;

bool g_fAnnounceDirectories = true;
bool g_fAnnounceCopies = false;
bool g_fAnnounceDeletes = true;
bool g_fAnnounceLinks = true;
bool g_fAnnounceSkips = false;
bool g_fSilent = false;
bool g_fShowProgress = true;

HANDLE g_hIoCompletionPort = NULL;
HANDLE g_hWorkItemDoneEvent = INVALID_HANDLE_VALUE;

DWORD g_dwDestinationSectorsPerCluster = 0;
DWORD g_dwDestinationBytesPerSector = 0;
DWORD g_dwDestinationNumberOfFreeClusters = 0;
DWORD g_dwDestinationTotalNumberOfClusters = 0;

ULONG g_nThreads = 3;

HANDLE g_rghThreads[32];

class CFileCopy;
class CFileLink;
class CDir;

// BOOL ScanAndCopyDir(PCWSTR szSource, PCWSTR szDest);
BOOL BuildDirList(const CBaseStringBuffer &rbuffSource, const CBaseStringBuffer &rbuffDestination);
BOOL MakeDirectoryStructure();
BOOL QueueDirScans();
BOOL QueueFileCopies();
BOOL QueueFileLinks();
DWORD WINAPI WorkerThreadProc(LPVOID pvParameter);
void ComputeTimeDeltas(const SYSTEMTIME &rstStart, const SYSTEMTIME &rstEnd, SYSTEMTIME &rstDelta);
BOOL ProcessFileCopy(CFileCopy *pFileCopy, bool &rfReQueue, BYTE *pBuffer, DWORD cbBuffer);
BOOL ProcessFileLink(CFileLink *pFileLink, bool &rfReQueue);
BOOL ProcessDirScan(CDir *pDir, bool &rfReQueue);
BOOL ResumeWorkerThreads();
BOOL SuspendWorkerThreads();
BOOL
WaitForWorkersToComplete(
    ULONGLONG &rullCounter,
    ULONGLONG ullLimit,
    PCSTR pszOperationName
    );

BOOL
MyCopyFile(
    BYTE *pBuffer,
    DWORD cbBuffer,
    PCWSTR lpExistingFileName,
    PCWSTR lpNewFileName,
    BOOL fFailIfExists,
    HANDLE &rhNewFileHandle
    );

class CEntry
{
private:
    CEntry(const CEntry&); // deliberately not implemented
    void operator=(const CEntry&); // deliberately not implemented
public:
    CEntry() : m_cRetries(0) { }
    ~CEntry() { }

    virtual BOOL BaseDoYourThing(bool &rfReQueue, BYTE *pBuffer, DWORD cbBuffer)
    {
        LARGE_INTEGER liStart, liEnd;
        ::QueryPerformanceCounter(&liStart);
        BOOL fResult = this->DoYourThing(rfReQueue, pBuffer, cbBuffer);
        if (fResult && rfReQueue)
        {
            m_cRetries++;
            if (m_cRetries > 100)
                fResult = FALSE;
        }

        CSxsPreserveLastError ple;
        ::QueryPerformanceCounter(&liEnd);
        ple.Restore();

        m_ullStart = static_cast<ULONGLONG>(liStart.QuadPart);
        m_ullEnd = static_cast<ULONGLONG>(liEnd.QuadPart);

        return fResult;
    }

    virtual BOOL DoYourThing(bool &rfReQueue, BYTE *pbBuffer, DWORD cbBuffer) = 0;

    ULONGLONG m_ullStart, m_ullEnd;
    ULONG m_cRetries;
};

class CDir : public CEntry
{
private:
    CDir(const CDir&); // deliberately not implemented
    void operator=(const CDir&); // deliberately not implemented
public:
    CDir() { };
    ~CDir() { };

    BOOL Initialize(const CBaseStringBuffer &rbuffSource, const CBaseStringBuffer &rbuffDestination)
    {
        BOOL fSuccess = FALSE;

        if (!m_buffSource.Win32Assign(rbuffSource))
            goto Exit;

        if (!m_buffDestination.Win32Assign(rbuffDestination))
            goto Exit;

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    virtual BOOL DoYourThing(bool &rfReQueue, BYTE *, DWORD) { return ::ProcessDirScan(this, rfReQueue); }

    CStringBuffer m_buffSource;
    CStringBuffer m_buffDestination;
    CDequeLinkage m_linkage;
};

class CFileBase : public CEntry
{
private:
    CFileBase(const CFileBase&); // deliberately not implemented
    void operator=(const CFileBase&); // deliberately not implemented
public:
    CFileBase() : m_fDone(false) { }
    ~CFileBase() { }

    BOOL Initialize(
        CDir *pDir,
        PCWSTR pszFilename,
        FILETIME ftSourceCreationTime,
        FILETIME ftSourceLastAccessTime,
        FILETIME ftSourceLastWriteTime,
        ULONGLONG ullFileIndex,
        ULONGLONG cbSize
        )
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IFW32FALSE_EXIT(m_buffFilename.Win32Assign(pszFilename, wcslen(pszFilename)));

        m_ftSourceCreationTime = ftSourceCreationTime;
        m_ftSourceLastAccessTime = ftSourceLastAccessTime;
        m_ftSourceLastWriteTime = ftSourceLastWriteTime;

        m_ullFileIndex = ullFileIndex;
        m_cbSize = cbSize;
        m_pDir = pDir;

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    virtual BOOL GetSource(CBaseStringBuffer &rbuff)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IFW32FALSE_EXIT(rbuff.Win32Assign(m_pDir->m_buffSource));
        IFW32FALSE_EXIT(rbuff.Win32Append(m_buffFilename));
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    virtual BOOL GetDestination(CBaseStringBuffer &rbuff)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IFW32FALSE_EXIT(rbuff.Win32Assign(m_pDir->m_buffDestination));
        IFW32FALSE_EXIT(rbuff.Win32Append(m_buffFilename));
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    CStringBuffer m_buffFilename;
    FILETIME m_ftSourceCreationTime;
    FILETIME m_ftSourceLastAccessTime;
    FILETIME m_ftSourceLastWriteTime;
    ULONGLONG m_ullFileIndex;
    ULONGLONG m_cbSize;
    CDir *m_pDir;
    bool m_fSkipped; // used to avoid skewed statistics about number of bytes copied/sec etc.
    bool m_fDone;

    CDequeLinkage m_linkage;
};

class CFileCopy : public CFileBase
{
public:
    CFileCopy() { }
    ~CFileCopy() { }
    virtual BOOL DoYourThing(bool &rfReQueue, BYTE *pBuffer, DWORD cbBuffer) { return ::ProcessFileCopy(this, rfReQueue, pBuffer, cbBuffer); }

    static int __cdecl QSortBySize(const void *param1, const void *param2)
    {
        CFileCopy **pp1 = (CFileCopy **) param1;
        CFileCopy **pp2 = (CFileCopy **) param2;
        CFileCopy *p1 = *pp1;
        CFileCopy *p2 = *pp2;
        int iRet = 0;

        if (p1->m_fSkipped)
        {
            if (p2->m_fSkipped)
            {
                if (p1->m_cbSize < p2->m_cbSize)
                    iRet = 1;
                else if (p1->m_cbSize > p2->m_cbSize)
                    iRet = -1;
                else
                {
                    if (p1->m_ullFileIndex < p2->m_ullFileIndex)
                        iRet = -1;
                    else
                        iRet = 1;
                }
            }
            else
                iRet = -1;
        }
        else
        {
            if (p2->m_fSkipped)
                iRet = 1;
            else
            {
                if (p1->m_cbSize < p2->m_cbSize)
                    iRet = 1;
                else if (p1->m_cbSize > p2->m_cbSize)
                    iRet = -1;
                else
                {
                    if (p1->m_ullFileIndex < p2->m_ullFileIndex)
                        iRet = -1;
                    else
                        iRet = 1;
                }
            }
        }

        return iRet;
    }

private:
    CFileCopy(const CFileCopy &r);
    void operator =(const CFileCopy &r);
};

class CFileLink : public CFileBase
{
public:
    CFileLink() { }
    ~CFileLink() { }
    virtual BOOL DoYourThing(bool &rfReQueue, BYTE *pBuffer, DWORD cbBuffer) { return ::ProcessFileLink(this, rfReQueue); }

    BOOL GetSource(CBaseStringBuffer &rbuff);

private:
    CFileLink(const CFileLink &r);
    void operator =(const CFileLink &r);
};


CDeque<CDir, offsetof(CDir, m_linkage)> *g_pDirs = NULL;
CDir **g_prgpDirs = NULL;

CDeque<CFileCopy, offsetof(CFileCopy, m_linkage)> *g_pFileCopies = NULL;
CFileCopy **g_prgpFileCopies = NULL;

CDeque<CFileLink, offsetof(CFileLink, m_linkage)> *g_pFileLinks = NULL;
CFileLink **g_prgpFileLinks = NULL;

class CFileIdHashHelper : public CHashTableHelper<ULONGLONG, ULONGLONG, PCWSTR, CStringBuffer>
{
private:
    CFileIdHashHelper(const CFileIdHashHelper&); // deliberately not implemented
    void operator=(const CFileIdHashHelper&); // deliberately not implemented
public:
    static BOOL HashKey(ULONGLONG keyin, ULONG &rulPseudoKey) { rulPseudoKey = static_cast<ULONG>(keyin); return TRUE; }
    static BOOL CompareKey(ULONGLONG keyin, const ULONGLONG &rtkeystored, bool &rfMatch) { rfMatch = keyin == rtkeystored; return TRUE; }
    static VOID PreInitializeKey(ULONGLONG &rtkeystored) { rtkeystored = 0; }
    static VOID PreInitializeValue(CFileCopy *&rtvaluestored) { rtvaluestored = NULL; }
    static BOOL InitializeKey(ULONGLONG keyin, ULONGLONG &rtkeystored) { rtkeystored = keyin; return TRUE; }
    static BOOL InitializeValue(CFileCopy *vin, CFileCopy *&rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(CFileCopy *vin, CFileCopy *&rvstored) { rvstored = vin; return TRUE; }
    static VOID FinalizeKey(ULONGLONG &rtkeystored) { }
    static VOID FinalizeValue(CFileCopy *&rvstored) { rvstored = NULL; }
};

class CFileIdHashTable : public CHashTable<ULONGLONG, ULONGLONG, CFileCopy *, CFileCopy *, CFileIdHashHelper>
{
private:
    CFileIdHashTable(const CFileIdHashTable&); // deliberately not implemented
    void operator=(const CFileIdHashTable&); // deliberately not implemented
public:
    CFileIdHashTable() { }
    ~CFileIdHashTable() { }
};

CFileIdHashTable *g_pFiles = NULL;

FILE *g_pLogFile = NULL;

BOOL
CFileLink::GetSource(CBaseStringBuffer &rbuff)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer *pbuff = NULL;
    CFileCopy **ppFileCopy = NULL;

    if (!g_pFiles->Find(m_ullFileIndex, ppFileCopy))
    {
        ::ReportFailure("Finding file index %I64u in the file table failed.\n");
        goto Exit;
    }

    IFW32FALSE_EXIT((*ppFileCopy)->GetDestination(rbuff));

    FN_EPILOG
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;

    SYSTEMTIME stStart, stAfterScan, stAfterDirCreation, stAfterCopies, stAfterLinks, stEnd;
    ULONG i;
    CStringBuffer buffSource;
    CStringBuffer buffDestination;
    int iSource = 0;
    int iDestination = 0;
    SYSTEMTIME stAfterScanDelta, stAfterDirCreationDelta, stAfterCopiesDelta, stAfterLinksDelta, stEndDelta;
    ULONGLONG ullTemp;
    int iArg;
//    DWORD dwRetVal;

    WCHAR rgwchSourceVolumePath[MAX_PATH];
    WCHAR rgwchSourceVolumeName[MAX_PATH];
    DWORD dwSourceVolumeSerialNumber;
    DWORD dwSourceMaximumComponentLength;
    DWORD dwSourceFileSystemFlags;
    WCHAR rgwchSourceFileSystemNameBuffer[MAX_PATH];
    WCHAR rgwchSourceRemoteName[MAX_PATH];
    DWORD dwSourceRemoteNameLength = NUMBER_OF(rgwchSourceRemoteName);
    UINT uiSourceDriveType;

    WCHAR rgwchDestinationVolumePath[MAX_PATH];
    WCHAR rgwchDestinationVolumeName[MAX_PATH];
    DWORD dwDestinationVolumeSerialNumber;
    DWORD dwDestinationMaximumComponentLength;
    DWORD dwDestinationFileSystemFlags;
    WCHAR rgwchDestinationFileSystemNameBuffer[MAX_PATH];
    WCHAR rgwchDestinationRemoteName[MAX_PATH];
    DWORD dwDestinationRemoteNameLength = NUMBER_OF(rgwchDestinationRemoteName);
    UINT uiDestinationDriveType;

    if (!::FusionpInitializeHeap(NULL))
        goto Exit;

    iArg = 1;

    while (iArg < argc)
    {
        PCWSTR arg = argv[iArg];

        // Let's see if we see some switches...
        if ((arg[0] == L'-') || (arg[0] == L'/'))
        {
            arg++;

            if ((_wcsicmp(arg, L"threads") == 0) ||
                (_wcsicmp(arg, L"t") == 0))
            {
                PWSTR pszDummy;

                iArg++;
                if (iArg >= argc)
                    break;

                g_nThreads = wcstol(argv[iArg], &pszDummy, 10);

                if (g_nThreads < 1)
                    g_nThreads = 1;

                if (g_nThreads > RTL_NUMBER_OF(g_rghThreads))
                    g_nThreads = RTL_NUMBER_OF(g_rghThreads);

                iArg++;

                continue;
            }
            else if ((_wcsicmp(arg, L"quiet") == 0) ||
                     (_wcsicmp(arg, L"q") == 0))
            {
                g_fSilent = true;
                iArg++;
                continue;
            }
            else if (_wcsicmp(arg, L"logfile") == 0)
            {
                iArg++;
                if (iArg >= argc)
                    break;

                g_pLogFile = ::_wfopen(argv[iArg], L"w+");
                if (g_pLogFile == NULL)
                {
                    ::perror("Error opening logfile");
                    goto Exit;
                }
                iArg++;
            }

        }

        // This must be it!  We hope; there should be two things left
        if ((iArg + 2) != argc)
            break;

        iSource = iArg;
        iDestination = iArg + 1;
        break;
    }

    if (iSource == 0)
    {
        fprintf(stderr,
            "%ls: usage:\n"
            "    %ls [-threads n] [-quiet] <source> <dest>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    // Abuse these buffers for debugging purposes...
    {
        HANDLE h;

        if (!::GetLogicalDriveStringsW(NUMBER_OF(rgwchSourceVolumePath), rgwchSourceVolumePath))
        {
            ::ReportFailure("GetLogicalDriveStringsW failed\n");
            goto Exit;
        }

        h = ::FindFirstVolumeW(rgwchSourceVolumePath, NUMBER_OF(rgwchSourceVolumePath));
        if (h == INVALID_HANDLE_VALUE)
        {
            ::ReportFailure("FindFirstVolumeW failed\n");
            goto Exit;
        }

        for (;;)
        {
            DWORD cchReturnLength;

            if (!::GetVolumePathNamesForVolumeNameW(rgwchSourceVolumePath, rgwchDestinationVolumePath, NUMBER_OF(rgwchDestinationVolumePath), &cchReturnLength))
            {
                ::ReportFailure("GetVolumePathNamesForVolumeNameW failed\n");
                goto Exit;
            }

            if (!::FindNextVolumeW(h, rgwchSourceVolumePath, NUMBER_OF(rgwchSourceVolumePath)))
            {
                const DWORD dwLastError = ::GetLastError();
                if (dwLastError != ERROR_NO_MORE_FILES)
                {
                    ::ReportFailure("FindNextVolumeW failed\n");
                    goto Exit;
                }

                break;
            }
        }

        ::FindVolumeClose(h);
    }

    if (!::GetVolumePathNameW(argv[iSource], rgwchSourceVolumePath, NUMBER_OF(rgwchSourceVolumePath)))
    {
        ::ReportFailure("GetVolumePathName(L\"%ls\", ...) failed\n", argv[iSource]);
        goto Exit;
    }

    uiSourceDriveType = ::GetDriveTypeW(rgwchSourceVolumePath);

    if (!::GetVolumePathNameW(argv[iDestination], rgwchDestinationVolumePath, NUMBER_OF(rgwchDestinationVolumePath)))
    {
        ::ReportFailure("GetVolumePathName(L\"%ls\", ...) failed\n", argv[iDestination]);
        goto Exit;
    }

    uiDestinationDriveType = ::GetDriveTypeW(rgwchDestinationVolumePath);

    if (!::GetVolumeInformationW(
                rgwchSourceVolumePath,
                rgwchSourceVolumeName,
                NUMBER_OF(rgwchSourceVolumeName),
                &dwSourceVolumeSerialNumber,
                &dwSourceMaximumComponentLength,
                &dwSourceFileSystemFlags,
                rgwchSourceFileSystemNameBuffer,
                NUMBER_OF(rgwchSourceFileSystemNameBuffer)))
    {
        ::ReportFailure("GetVolumeInformation(L\"%ls\", ...) failed\n", rgwchSourceVolumePath);
        goto Exit;
    }

    if (!::GetVolumeInformationW(
                rgwchDestinationVolumePath,
                rgwchDestinationVolumeName,
                NUMBER_OF(rgwchDestinationVolumeName),
                &dwDestinationVolumeSerialNumber,
                &dwDestinationMaximumComponentLength,
                &dwDestinationFileSystemFlags,
                rgwchDestinationFileSystemNameBuffer,
                NUMBER_OF(rgwchDestinationFileSystemNameBuffer)))
    {
        ::ReportFailure("GetVolumeInformation(L\"%ls\", ...) failed\n", rgwchDestinationVolumePath);
        goto Exit;
    }

    if (!::GetDiskFreeSpaceW(
            rgwchDestinationVolumePath,
            &g_dwDestinationSectorsPerCluster,
            &g_dwDestinationBytesPerSector,
            &g_dwDestinationNumberOfFreeClusters,
            &g_dwDestinationTotalNumberOfClusters))
    {
        ::ReportFailure("GetDiskFreeSpaceW(L\"%ls\", ...) failed\n", rgwchDestinationVolumePath);
        goto Exit;
    }

#if 0
    if ((dwRetVal = ::WNetGetConnectionW(rgwchSourceVolumePath, rgwchSourceRemoteName, &dwSourceRemoteNameLength)) != NO_ERROR)
    {
        ::SetLastError(dwRetVal);
        ::ReportFailure("WNetGetConnection(L\"%ls\", ...) failed\n", rgwchSourceVolumePath);
        goto Exit;
    }
#endif // 0

    InitializeCriticalSection(&g_cs);

    g_pFiles = new CFileIdHashTable;
    g_pDirs = new CDeque<CDir, offsetof(CDir, m_linkage)>;
    g_pFileCopies = new CDeque<CFileCopy, offsetof(CFileCopy, m_linkage)>;
    g_pFileLinks = new CDeque<CFileLink, offsetof(CFileLink, m_linkage)>;

    g_pszImage = wcsrchr(argv[0], L'\\');
    if (g_pszImage == NULL)
        g_pszImage = argv[0];
    else
        g_pszImage++;

    g_hIoCompletionPort = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, g_nThreads);
    if (g_hIoCompletionPort == NULL)
    {
        ::ReportFailure("Creating I/O Completion Port with %lu concurrent threads failed.\n", g_nThreads);
        goto Exit;
    }

    g_hWorkItemDoneEvent = ::CreateEventW(NULL, FALSE, FALSE, NULL);
    if (g_hWorkItemDoneEvent == NULL)
    {
        ::ReportFailure("Creating the file copied event failed.\n");
        goto Exit;
    }
 
    for (i=0; i<g_nThreads; i++)
    {
        g_rghThreads[i] = ::CreateThread(NULL, 0, &WorkerThreadProc, NULL, CREATE_SUSPENDED, NULL);
        if (g_rghThreads[i] == NULL)
        {
            ::ReportFailure("Creating worker thread number %lu failed.\n", i);
            goto Exit;
        }
    }

    ::GetSystemTime(&stStart);

    if (!buffSource.Win32Assign(argv[iSource], wcslen(argv[iSource])))
        goto Exit;

    if (!buffDestination.Win32Assign(argv[iDestination], wcslen(argv[iDestination])))
        goto Exit;

    if (!::BuildDirList(buffSource, buffDestination))
        goto Exit;

    if (!g_fSilent)
        printf("%ls: Found %Iu directories.\n", g_pszImage, g_pDirs->GetEntryCount());

    if (!::QueueDirScans())
        goto Exit;

    if (!::WaitForWorkersToComplete(g_DirScansProcessed, g_pDirs->GetEntryCount(), "Directory scans"))
        goto Exit;

    ::GetSystemTime(&stAfterScan);

    if (!g_fSilent)
    {
        printf("%ls: Copying %Iu files (%I64u bytes)\n", g_pszImage, g_pFileCopies->GetEntryCount(), g_BytesToCopy);
        printf("%ls: Linking %Iu files\n", g_pszImage, g_pFileLinks->GetEntryCount());
    }

    if (!::MakeDirectoryStructure())
        goto Exit;

    if (!g_fSilent)
        printf("%ls: Created %Iu directories.\n", g_pszImage, g_pDirs->GetEntryCount());

    ::GetSystemTime(&stAfterDirCreation);

    if (!::QueueFileCopies())
        goto Exit;

    if (!::WaitForWorkersToComplete(g_FileCopiesProcessed, g_pFileCopies->GetEntryCount(), "File copies"))
        goto Exit;

    ::GetSystemTime(&stAfterCopies);

    ::qsort(g_prgpFileCopies, g_pFileCopies->GetEntryCount(), sizeof(CFileCopy *), &CFileCopy::QSortBySize);

    if (g_pLogFile != NULL)
    {
        LARGE_INTEGER liFreq;
        ULONGLONG ullFreqDiv100;
        CStringBuffer buffDestination;

        ::QueryPerformanceFrequency(&liFreq);

        ullFreqDiv100 = (liFreq.QuadPart / 100);

        for (i=0; i<g_pFileCopies->GetEntryCount(); i++)
        {
            ULONGLONG diff = g_prgpFileCopies[i]->m_ullEnd - g_prgpFileCopies[i]->m_ullStart;
            diff = diff / ullFreqDiv100;
            if (!g_prgpFileCopies[i]->GetDestination(buffDestination))
                goto Exit;
            fprintf(g_pLogFile, "%ls,%Iu,%Iu\n", static_cast<PCWSTR>(buffDestination), diff, g_prgpFileCopies[i]->m_cbSize);
        }
    }

    if (!::QueueFileLinks())
        goto Exit;

    if (!::WaitForWorkersToComplete(g_FileLinksProcessed, g_pFileLinks->GetEntryCount(), "File links"))
        goto Exit;

    ::GetSystemTime(&stAfterLinks);

    ::GetSystemTime(&stEnd);

    ::ComputeTimeDeltas(stStart, stAfterScan, stAfterScanDelta);
    ::ComputeTimeDeltas(stAfterScan, stAfterDirCreation, stAfterDirCreationDelta);
    ::ComputeTimeDeltas(stAfterDirCreation, stAfterCopies, stAfterCopiesDelta);
    ::ComputeTimeDeltas(stAfterCopies, stAfterLinks, stAfterLinksDelta);
    ::ComputeTimeDeltas(stStart, stEnd, stEndDelta);
    
    printf(
        "%ls: Statistics:\n"
        "   Directories Copied: %I64u\n"
        "         Files Copied: %I64u\n"
        "         Bytes Copied: %I64u\n"
        "         Files Linked: %I64u\n"
        "       Copies Skipped: %I64u\n"
        "        Links Skipped: %I64u\n",
        g_pszImage,
        g_DirectoriesCopied,
        g_FilesCopied,
        g_BytesCopied,
        g_FilesLinked,
        g_CopiesSkipped,
        g_LinksSkipped);

    printf(
        "   Times:\n"
        "      Scan:               %u:%02u:%02u.%03u\n"
        "      Directory Creation: %u:%02u:%02u.%03u\n"
        "      Copying Files:      %u:%02u:%02u.%03u\n"
        "      Linking Files:      %u:%02u:%02u.%03u\n"
        "      Total:              %u:%02u:%02u.%03u\n",
        stAfterScanDelta.wHour, stAfterScanDelta.wMinute, stAfterScanDelta.wSecond, stAfterScanDelta.wMilliseconds,
        stAfterDirCreationDelta.wHour, stAfterDirCreationDelta.wMinute, stAfterDirCreationDelta.wSecond, stAfterDirCreationDelta.wMilliseconds,
        stAfterCopiesDelta.wHour, stAfterCopiesDelta.wMinute, stAfterCopiesDelta.wSecond, stAfterCopiesDelta.wMilliseconds,
        stAfterLinksDelta.wHour, stAfterLinksDelta.wMinute, stAfterLinksDelta.wSecond, stAfterLinksDelta.wMilliseconds,
        stEndDelta.wHour, stEndDelta.wMinute, stEndDelta.wSecond, stEndDelta.wMilliseconds
        );

    ullTemp = (((((stAfterCopiesDelta.wHour * 60) + stAfterCopiesDelta.wMinute) * 60) + stAfterCopiesDelta.wSecond) * 1000) + stAfterCopiesDelta.wMilliseconds;

    if (ullTemp != 0)
    {
        ULONGLONG ullFilesPerMS = ((g_FilesCopied * 1000000ui64) / ullTemp);
        ULONGLONG ullBytesPerMS = ((g_BytesCopied * 1000000ui64) / ullTemp);

        printf(
            "   Files copied per second: %I64u.%03u\n"
            "   Bytes copied per second: %I64u.%03u\n",
            static_cast<ULONGLONG>(ullFilesPerMS / 1000ui64), static_cast<ULONG>(ullFilesPerMS % 1000ui64),
            static_cast<ULONGLONG>(ullBytesPerMS / 1000ui64), static_cast<ULONG>(ullBytesPerMS % 1000ui64));
#if 0
            static_cast<ULONGLONG>((g_FilesCopied / ullTemp) * 1000ui64), static_cast<unsigned int>((g_FilesCopied / ullTemp) % 1000),
            static_cast<ULONGLONG>((g_BytesCopied / ullTemp) * 1000ui64), static_cast<unsigned int>((g_BytesCopied / ullTemp) % 1000));
#endif
    }

    ullTemp = (((stAfterLinksDelta.wHour * 60) + stAfterLinksDelta.wMinute) * 60) + stAfterLinksDelta.wSecond;

    if (ullTemp != 0)
    {
        printf(
            "   Files linked per second: %I64u\n",
            static_cast<ULONGLONG>(g_FilesLinked / ullTemp));
    }

    ullTemp = (((stEndDelta.wHour * 60) + stEndDelta.wMinute) * 60) + stEndDelta.wSecond;

    if (ullTemp != 0)
    {
        printf(
            "   Overall files per second: %I64u\n",
            static_cast<ULONGLONG>((g_FilesCopied + g_CopiesSkipped + g_FilesLinked + g_LinksSkipped + g_pDirs->GetEntryCount()) / ullTemp));
    }

    iReturnStatus = EXIT_SUCCESS;

Exit:
    // Wake the children; process termination doesn't seem to work if we don't.
    ::ResumeWorkerThreads();

    if (g_pLogFile != NULL)
    {
        fflush(g_pLogFile);
        fclose(g_pLogFile);
    }

    return iReturnStatus;
}

BOOL
ResumeWorkerThreads()
{
    BOOL fSuccess = FALSE;
    ULONG i;

    for (i=0; i<g_nThreads; i++)
    {
        if (::ResumeThread(g_rghThreads[i]) == -1)
        {
            ::ReportFailure("Failed to resume worker thread %lu\n", i + 1);
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SuspendWorkerThreads()
{
    BOOL fSuccess = FALSE;
    ULONG i;

    for (i=0; i<g_nThreads; i++)
    {
        if (::SuspendThread(g_rghThreads[i]) == -1)
        {
            ::ReportFailure("Failed to suspend worker thread %lu\n", i + 1);
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
WaitForWorkersToComplete(
    ULONGLONG &rullCounter,
    ULONGLONG ullLimit,
    PCSTR pszOperationName
    )
{
    BOOL fSuccess = FALSE;
    ULONGLONG i;

    if (!::ResumeWorkerThreads())
        goto Exit;

    i = 0;
    while (rullCounter < ullLimit)
    {
        // Don't wake more than every tenth of a second...
        ::Sleep(100);

        DWORD dwWFSO = ::WaitForSingleObject(g_hWorkItemDoneEvent, INFINITE);

        if (dwWFSO == WAIT_FAILED)
        {
            ::ReportFailure("Waiting for work item done event failed\n");
            goto Exit;
        }

        i++;

        if ((i % 50) == 0)
        {
            if (!g_fSilent)
                printf("%ls: %s processed (%I64u total): %I64u\n", g_pszImage, pszOperationName, ullLimit, rullCounter);
        }
    }

    if (!::SuspendWorkerThreads())
        goto Exit;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


void
ComputeTimeDeltas(
    const SYSTEMTIME &rstStart,
    const SYSTEMTIME &rstEnd,
    SYSTEMTIME &rstDelta
    )
{
    FILETIME ftStart, ftEnd;
    ULARGE_INTEGER uliStart, uliEnd;
    ULONGLONG ullDiff, ullTemp;
    ULONG ulHours, ulMinutes, ulSeconds, ulMilliseconds;

    ::SystemTimeToFileTime(&rstStart, &ftStart);
    ::SystemTimeToFileTime(&rstEnd, &ftEnd);

    uliStart.LowPart = ftStart.dwLowDateTime;
    uliStart.HighPart = ftStart.dwHighDateTime;

    uliEnd.LowPart = ftEnd.dwLowDateTime;
    uliEnd.HighPart = ftEnd.dwHighDateTime;

    ullDiff = (uliEnd.QuadPart - uliStart.QuadPart);

    ulHours = (ULONG) (ullDiff / (10000000ui64 * 60 * 60));

    ullTemp = ullDiff - ((ULONGLONG) ulHours) * (10000000ui64 * 60 * 60);

    ulMinutes = (ULONG) (ullTemp / (10000000ui64 * 60));

    ullTemp -= ((ULONGLONG) ulMinutes) * (10000000ui64 * 60);

    ulSeconds = (ULONG) (ullTemp / 10000000ui64);

    ullTemp -= ((ULONGLONG) ulSeconds) * 10000000ui64;

    ulMilliseconds = (ULONG) (ullTemp / 10000ui64);

    rstDelta.wYear = 0;
    rstDelta.wMonth = 0;
    rstDelta.wDayOfWeek = 0;
    rstDelta.wDay = 0;
    rstDelta.wHour = (WORD) ulHours;
    rstDelta.wMinute = (WORD) ulMinutes;
    rstDelta.wSecond = (WORD) ulSeconds;
    rstDelta.wMilliseconds = (WORD) ulMilliseconds;
}

BOOL
BuildDirList(
    const CBaseStringBuffer &rbuffSource,
    const CBaseStringBuffer &rbuffDestination
    )
{
    PCWSTR szSrc = rbuffSource;
    BOOL fSuccess = FALSE;
    DWORD dwFileAttributes;
    CStringBuffer buffSrc;
    CStringBuffer buffSrcWildcard;
    CStringBuffer buffDst;
    WIN32_FIND_DATAW wfd;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    SIZE_T cchSrc, cchDst;
    CDir *pDir = NULL;

    dwFileAttributes = ::GetFileAttributesW(rbuffSource);
    if (dwFileAttributes == ((DWORD) -1))
    {
        ::ReportFailure("GetFileAttributesW() on the source \"%ls\" failed\n", szSrc);
        goto Exit;
    }

    if (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        ::ReportFailure("Source directory \"%ls\" is not a directory!\n");
        goto Exit;
    }

    if (!buffSrc.Win32Assign(rbuffSource))
        goto Exit;

    if (!buffSrc.Win32EnsureTrailingPathSeparator())
        goto Exit;

    if (!buffDst.Win32Assign(rbuffDestination))
        goto Exit;

    if (!buffDst.Win32EnsureTrailingPathSeparator())
        goto Exit;

    cchSrc = buffSrc.Cch();
    cchDst = buffDst.Cch();

    pDir = new CDir;
    if (pDir == NULL)
    {
        ::SetLastError(ERROR_OUTOFMEMORY);
        ::ReportFailure("Failed to allocate new CDir object\n");
        goto Exit;
    }

    if (!pDir->Initialize(buffSrc, buffDst))
        goto Exit;

    g_pDirs->AddToTail(pDir);
    pDir = NULL;

    if ((g_pDirs->GetEntryCount() % 50) == 0)
    {
        if (!g_fSilent)
            printf("%ls: Found %Iu directories...\n", g_pszImage, g_pDirs->GetEntryCount());
    }

    if (!buffSrcWildcard.Win32Assign(buffSrc))
        goto Exit;

    if (!buffSrcWildcard.Win32Append(L"*", 1))
        goto Exit;

    if ((hFind = ::FindFirstFileExW(
                        buffSrcWildcard, 
                        FindExInfoStandard,
                        &wfd,
                        FindExSearchLimitToDirectories,
                        NULL,
                        0)) == INVALID_HANDLE_VALUE)
    {
        const DWORD dwLastError = ::GetLastError();

        if (dwLastError != ERROR_NO_MORE_FILES)
        {
            ::ReportFailure("FindFirstFileW(L\"%ls\", ...) failed.\n", static_cast<PCWSTR>(buffSrcWildcard));
            goto Exit;
        }
    }

    for (;;)
    {
        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (wcscmp(wfd.cFileName, L".") != 0) &&
            (wcscmp(wfd.cFileName, L"..") != 0))
        {
            buffSrc.Left(cchSrc);
            buffDst.Left(cchDst);

            if (!buffSrc.Win32Append(wfd.cFileName, wcslen(wfd.cFileName)))
                goto Exit;

            if (!buffDst.Win32Append(wfd.cFileName, wcslen(wfd.cFileName)))
                goto Exit;

            if (!::BuildDirList(buffSrc, buffDst))
                goto Exit;
        }

        if (!::FindNextFileW(hFind, &wfd))
        {
            if (::GetLastError() == ERROR_NO_MORE_FILES)
                break;

            ::ReportFailure("FindNextFileW() failed\n");
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    if (hFind != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::FindClose(hFind);
        ple.Restore();
    }

    if (pDir != NULL)
        delete pDir;

    return fSuccess;
}

BOOL
BuildDirFileList(
    CSxsLockCriticalSection &rlcs,
    CDir *pDir
    )
{
    PCWSTR szSrc = pDir->m_buffSource;
    BOOL fSuccess = FALSE;
    DWORD dwFileAttributes;
    CStringBuffer buffSrc;
    CStringBuffer buffSrcWildcard;
    CStringBuffer buffDst;
    WIN32_FIND_DATAW wfd;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    SIZE_T cchSrc, cchDst;
    CFileLink *pFileLink = NULL;
    CFileCopy *pFileCopy = NULL;

    dwFileAttributes = ::GetFileAttributesW(pDir->m_buffSource);
    if (dwFileAttributes == ((DWORD) -1))
    {
        ::ReportFailure("GetFileAttributesW() on the source \"%ls\" failed", szSrc);
        goto Exit;
    }

    if (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        ::ReportFailure("Source directory \"%ls\" is not a directory!\n", szSrc);
        goto Exit;
    }

    if (!buffSrc.Win32Assign(pDir->m_buffSource))
        goto Exit;

    if (!buffSrc.Win32EnsureTrailingPathSeparator())
        goto Exit;

    if (!buffDst.Win32Assign(pDir->m_buffDestination))
        goto Exit;

    if (!buffDst.Win32EnsureTrailingPathSeparator())
        goto Exit;

    cchSrc = buffSrc.Cch();
    cchDst = buffDst.Cch();

    if (!buffSrcWildcard.Win32Assign(buffSrc))
        goto Exit;

    if (!buffSrcWildcard.Win32Append(L"*", 1))
        goto Exit;

    if ((hFind = ::FindFirstFileW(buffSrcWildcard, &wfd)) == INVALID_HANDLE_VALUE)
    {
        const DWORD dwLastError = ::GetLastError();

        if (::GetLastError() != ERROR_NO_MORE_FILES)
        {
            ::ReportFailure("FindFirstFileW(L\"%ls\", ...) failed\n", static_cast<PCWSTR>(buffSrcWildcard));
            goto Exit;
        }
    }

    for (;;)
    {
        if ((wcscmp(wfd.cFileName, L".") != 0) && (wcscmp(wfd.cFileName, L"..") != 0))
        {
            buffSrc.Left(cchSrc);
            buffDst.Left(cchDst);

            if (!buffSrc.Win32Append(wfd.cFileName, wcslen(wfd.cFileName)))
                goto Exit;

            if (!buffDst.Win32Append(wfd.cFileName, wcslen(wfd.cFileName)))
                goto Exit;

            dwFileAttributes = ::GetFileAttributesW(buffSrc);
            if (dwFileAttributes == ((DWORD) -1))
            {
                ::ReportFailure("GetFileAttribuesW(L\"%ls\") failed\n", static_cast<PCWSTR>(buffSrc));
                goto Exit;
            }

            if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                BY_HANDLE_FILE_INFORMATION bhfi;
                ULONGLONG ullFileIndex;
                ULONGLONG ullFileSize;
                CFileCopy **ppFileCopy = NULL;

                hFile = ::CreateFileW(buffSrc, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    ::ReportFailure("CreateFileW(L\"%ls\", ...) failed\n", static_cast<PCWSTR>(buffSrc));
                    goto Exit;
                }

                if (!::GetFileInformationByHandle(hFile, &bhfi))
                {
                    ::ReportFailure("Failed to GetFileInformationByHandle(%p, ...) on file \"%ls\"\n", hFile, static_cast<PCWSTR>(buffSrc));
                    goto Exit;
                }

                ::CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

                ullFileIndex = (((ULONGLONG) bhfi.nFileIndexHigh) << 32) | ((ULONGLONG) bhfi.nFileIndexLow);
                ullFileSize = (((ULONGLONG) bhfi.nFileSizeHigh) << 32) | ((ULONGLONG) bhfi.nFileSizeLow);

                g_BytesToCopy += ullFileSize;

                if (!rlcs.Lock())
                {
                    ::ReportFailure("Failed to lock global critical section");
                    goto Exit;
                }

                if (!g_pFiles->Find(ullFileIndex, ppFileCopy))
                {
                    ::ReportFailure("Finding file index %I64u in file table failed.\n", ullFileIndex);
                    goto Exit;
                }

                if (ppFileCopy != NULL)
                {
                    pFileLink = new CFileLink;
                    if (pFileLink == NULL)
                    {
                        ::SetLastError(ERROR_OUTOFMEMORY);
                        goto Exit;
                    }

                    if (!pFileLink->Initialize(
                        pDir,
                        wfd.cFileName,
                        bhfi.ftCreationTime,
                        bhfi.ftLastAccessTime,
                        bhfi.ftLastWriteTime,
                        ullFileIndex,
                        ullFileSize))
                        goto Exit;

                    g_pFileLinks->AddToTail(pFileLink);
                    pFileLink = NULL;
                }
                else
                {
                    pFileCopy = new CFileCopy;
                    if (pFileCopy == NULL)
                    {
                        ::SetLastError(ERROR_OUTOFMEMORY);
                        ::ReportFailure("Allocating new CFileCopy object failed.\n");
                        goto Exit;
                    }

                    if (!pFileCopy->Initialize(
                        pDir,
                        wfd.cFileName,
                        bhfi.ftCreationTime,
                        bhfi.ftLastAccessTime,
                        bhfi.ftLastWriteTime,
                        ullFileIndex,
                        ullFileSize))
                        goto Exit;

                    if (!g_pFiles->Insert(ullFileIndex, pFileCopy))
                        goto Exit;

                    g_pFileCopies->AddToTail(pFileCopy);
                    pFileCopy = NULL;
                }

                rlcs.Unlock();
            }
        }

        if (!::FindNextFileW(hFind, &wfd))
        {
            const DWORD dwLastError = ::GetLastError();

            if (dwLastError == ERROR_NO_MORE_FILES)
                break;

            ::ReportFailure("FindNextFileW() call failed\n");
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    if (hFind != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::FindClose(hFind);
        ple.Restore();
    }

    if (pFileLink != NULL)
        delete pFileLink;

    if (pFileCopy != NULL)
        delete pFileCopy;

    return fSuccess;
}

BOOL
MakeDirectoryStructure()
{
    BOOL fSuccess = FALSE;

    CDequeIterator<CDir, offsetof(CDir, m_linkage)> dirIter;

    dirIter.Rebind(g_pDirs);
    
    for (dirIter.Reset(); dirIter.More(); dirIter.Next())
    {
        if (!::CreateDirectoryW(dirIter->m_buffDestination, NULL))
        {
            const DWORD dwLastError = ::GetLastError();

            if (dwLastError != ERROR_ALREADY_EXISTS)
            {
                ::ReportFailure("Unable to create directory \"%ls\"", static_cast<PCWSTR>(dirIter->m_buffDestination));
                goto Exit;
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

void
ReportFailure(
    const char szFormat[],
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::GetLastError();
        _snwprintf(rgchWin32Error, sizeof(rgchWin32Error) / sizeof(rgchWin32Error[0]), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

DWORD
WINAPI
WorkerThreadProc(
    LPVOID pvParameter
    )
{
    ULONG nThread = (ULONG)(ULONG_PTR)pvParameter;
    DWORD dwReturnValue = 0;
    BYTE *pBuffer = NULL;
    DWORD cbBuffer;

    cbBuffer = 8192 * 32;
    pBuffer = (BYTE *) ::VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, PAGE_READWRITE);
    if (pBuffer == NULL)
    {
        ReportFailure("VirtualAlloc() for thread %lu failed.\n", nThread);
        goto Exit;
    }

    for (;;)
    {
        DWORD nBytes = 0;
        ULONG_PTR ulpCompletionKey = 0;
        LPOVERLAPPED lpo = NULL;
        CEntry *pEntry = NULL;
        bool fReQueue = false;

        if (!::GetQueuedCompletionStatus(g_hIoCompletionPort, &nBytes, &ulpCompletionKey, &lpo, INFINITE))
        {
            ReportFailure("Thread %lu failed call to GetQueuedCompletionStatus()\n", nThread);
            dwReturnValue = ::GetLastError();
            goto Exit;
        }

        pEntry = (CEntry *) lpo;

    DoItAgain:
        if (!pEntry->BaseDoYourThing(fReQueue, pBuffer, cbBuffer))
            goto Exit;

        if (fReQueue)
        {
            if (!::PostQueuedCompletionStatus(g_hIoCompletionPort, 0, NULL, lpo))
            {
                ReportFailure("Thread %lu failed to requeue item; retrying directly.\n", nThread);
                goto DoItAgain;
            }
        }

        ::SetEvent(g_hWorkItemDoneEvent);
    }

Exit:
    // Heavy handed but what else can we do?
    ::ExitProcess(dwReturnValue);
    return dwReturnValue;
}

BOOL
QueueDirScans()
{
    BOOL fSuccess = FALSE;
    SIZE_T i;

    g_prgpDirs = new (CDir *[g_pDirs->GetEntryCount()]);

    CDequeIterator<CDir, offsetof(CDir, m_linkage)> dirIter;

    dirIter.Rebind(g_pDirs);

    for (dirIter.Reset(), i=0; dirIter.More(); dirIter.Next(), i++)
    {
        g_prgpDirs[i] = dirIter;

        if (!::PostQueuedCompletionStatus(g_hIoCompletionPort, 0, 0, (LPOVERLAPPED) dirIter.Current()))
        {
            ReportFailure("Failed to queue dir scan\n");
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
QueueFileCopies()
{
    BOOL fSuccess = FALSE;
    SIZE_T i;
    FN_TRACE_WIN32(fSuccess);

    CDequeIterator<CFileCopy, offsetof(CFileCopy, m_linkage)> fileIter;

    g_prgpFileCopies = new (CFileCopy *[g_pFileCopies->GetEntryCount()]);

    fileIter.Rebind(g_pFileCopies);
    i=0;
    
    for (fileIter.Reset(); fileIter.More(); fileIter.Next())
    {
        if (!::PostQueuedCompletionStatus(g_hIoCompletionPort, 0, 0, (LPOVERLAPPED) fileIter.Current()))
        {
            ReportFailure("Failed to queue file copy\n");
            goto Exit;
        }
        g_prgpFileCopies[i++] = fileIter;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
QueueFileLinks()
{
    BOOL fSuccess = FALSE;
    SIZE_T i;

    CDequeIterator<CFileLink, offsetof(CFileLink, m_linkage)> fileIter;

    g_prgpFileLinks = new (CFileLink *[g_pFileLinks->GetEntryCount()]);

    fileIter.Rebind(g_pFileLinks);
    i=0;
    
    for (fileIter.Reset(); fileIter.More(); fileIter.Next())
    {
        if (!::PostQueuedCompletionStatus(g_hIoCompletionPort, 0, 0, (LPOVERLAPPED) fileIter.Current()))
        {
            ReportFailure("Failed to queue file link\n");
            goto Exit;
        }
        g_prgpFileLinks[i++] = fileIter;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
ProcessDirScan(
    CDir *pDir,
    bool &rfReQueue
    )
{
    BOOL fSuccess = FALSE;
    CSxsLockCriticalSection l(g_cs);

    rfReQueue = false;

    if (!::BuildDirFileList(l, pDir))
        goto Exit;

    if (!l.Lock())
    {
        ReportFailure("Failed to lock global critical section");
        goto Exit;
    }

    g_DirScansProcessed++;

    l.Unlock();

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
ProcessFileCopy(
    CFileCopy *pFile,
    bool &rfReQueue,
    BYTE *pBuffer,
    DWORD cbBuffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSxsLockCriticalSection l(g_cs);
    bool fDoCopy = true;
    DWORD dwFileAttributes;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CStringBuffer buffSource, buffDestination;

    rfReQueue = false;

    // If we're about to copy it, it's worth taking a look at the target to see if it's more-or-less
    // out of date.
    WIN32_FILE_ATTRIBUTE_DATA wfad;

    IFW32FALSE_EXIT(pFile->GetSource(buffSource));
    IFW32FALSE_EXIT(pFile->GetDestination(buffDestination));

    if (!::GetFileAttributesExW(buffDestination, GetFileExInfoStandard, &wfad))
    {
        const DWORD dwLastError = ::GetLastError();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            ::ReportFailure("Error opening target file \"%ls\"\n", static_cast<PCWSTR>(buffDestination));
            goto Exit;
        }

        wfad.dwFileAttributes = ((DWORD) -1);
    }
    else
    {
        ULONGLONG cbFileSize = (wfad.nFileSizeHigh << 32) | wfad.nFileSizeLow;

        ASSERT_NTC(cbFileSize >= wfad.nFileSizeLow);

        if ((cbFileSize == pFile->m_cbSize) &&
            (wfad.ftCreationTime == pFile->m_ftSourceCreationTime))
        {
            pFile->m_fSkipped = true;
            fDoCopy = false;
        }
    }

    if (fDoCopy)
    {
        bool fSetTimestamp = true;
        bool fClearedReadOnly = false;

        // Destructively clear the read-only bit if th destination file exists and is read-only.
        dwFileAttributes = wfad.dwFileAttributes;

        // We already filtered out all other reasons for failure other than FILE_NOT_FOUND.
        if (dwFileAttributes != ((DWORD) -1))
        {
            if (dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                // If it's readonly, clear that bit as well as all the others that
                // are illegal to set via SetFileAttributes()
                dwFileAttributes &=
                    ~(FILE_ATTRIBUTE_READONLY |
                      FILE_ATTRIBUTE_COMPRESSED |
                      FILE_ATTRIBUTE_DEVICE |
                      FILE_ATTRIBUTE_DIRECTORY |
                      FILE_ATTRIBUTE_ENCRYPTED |
                      FILE_ATTRIBUTE_REPARSE_POINT |
                      FILE_ATTRIBUTE_SPARSE_FILE);

                if (!::SetFileAttributesW(buffDestination, dwFileAttributes))
                {
                    ::ReportFailure("Error setting file attributes for target file \"%ls\" to 0x%08lx to allow overwrite\n", static_cast<PCWSTR>(buffDestination), dwFileAttributes);
                    goto Exit;
                }
            }
        }

        if (g_fAnnounceCopies)
            printf("Copying \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffSource), static_cast<PCWSTR>(buffDestination));

        // Hey, it's not there.  Let's copy it and put the entry in the table.
        if (!::MyCopyFile(pBuffer, cbBuffer, buffSource, buffDestination, FALSE, hFile))
        {
            ::ReportFailure("Failed to copy \"%ls\" to \"%ls\".\n", static_cast<PCWSTR>(buffSource), static_cast<PCWSTR>(buffDestination));
            goto Exit;
        }

        if (fSetTimestamp)
        {
            if (!::SetFileTime(hFile, &pFile->m_ftSourceCreationTime, &pFile->m_ftSourceLastAccessTime, &pFile->m_ftSourceLastWriteTime))
            {
                ::ReportFailure("Failed call to SetFileTime on file \"%ls\"\n", static_cast<PCWSTR>(buffDestination));
                goto Exit;
            }

            ::CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
        }

        if (!l.Lock())
        {
            ::ReportFailure("Failed to lock global critical section\n");
            goto Exit;
        }

        g_FilesCopied++;
        g_FileCopiesProcessed++;
        g_BytesCopied += pFile->m_cbSize;

        l.Unlock();
    }
    else
    {
        if (g_fAnnounceSkips)
            ::printf("Skipping copy from \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffSource), static_cast<PCWSTR>(buffDestination));

        if (!l.Lock())
        {
            ::ReportFailure("Failed to lock global critical section\n");
            goto Exit;
        }

        g_CopiesSkipped++;
        g_FileCopiesProcessed++;

        l.Unlock();
    }

    fSuccess = TRUE;
Exit:
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::CloseHandle(hFile);
        ple.Restore();
    }

    if (::GetLastError() == ERROR_TOO_MANY_OPEN_FILES)
    {
        rfReQueue = true;
        fSuccess = TRUE;
    }

    return fSuccess;
}

BOOL
ProcessFileLink(
    CFileLink *pFile,
    bool &rfReQueue
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSxsLockCriticalSection l(g_cs);
    bool fDoLink = true;
    CStringBuffer buffSource, buffDestination;
    WIN32_FILE_ATTRIBUTE_DATA wfad;

    rfReQueue = false;

    IFW32FALSE_EXIT(pFile->GetSource(buffSource));
    IFW32FALSE_EXIT(pFile->GetDestination(buffDestination));

    // CreateHardLinkW() doesn't deal with replace-existing like copyfile, so we'll see if a
    // file by that name is already present and if so, delete it.
    if (!::GetFileAttributesExW(buffDestination, GetFileExInfoStandard, &wfad))
    {
        // It failed.  But did it fail for the right reason?
        DWORD dwLastError = ::GetLastError();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            ::ReportFailure("Error probing destination for \"%ls\"\n", static_cast<PCWSTR>(buffDestination));
            goto Exit;
        }
    }
    else
    {
        ULONGLONG cbFileSize = (wfad.nFileSizeHigh << 32) | wfad.nFileSizeLow;

        ASSERT_NTC(cbFileSize >= wfad.nFileSizeLow);

        if ((pFile->m_cbSize == cbFileSize) &&
            (pFile->m_ftSourceCreationTime == wfad.ftCreationTime))
        {
            fDoLink = false;
            pFile->m_fSkipped = true;
        }
        else
        {
            if (g_fAnnounceDeletes)
                ::printf("Deleting file \"%ls\" in preparation for hard link creation\n", static_cast<PCWSTR>(buffDestination));

            if (!::DeleteFileW(buffDestination))
            {
                ::ReportFailure("Error deleting destination \"%ls\" in preparation of hard link creation\n", static_cast<PCWSTR>(buffDestination));
                goto Exit;
            }
        }
    }

    if (fDoLink)
    {
        if (g_fAnnounceLinks)
            ::printf("Creating hard link from \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffDestination), static_cast<PCWSTR>(buffSource));

        // Hey, it's already there.  Let's link it.
        if (!::CreateHardLinkW(buffDestination, buffSource, NULL))
        {
            ::ReportFailure("Error creating hard link from \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffDestination), static_cast<PCWSTR>(buffSource));
            goto Exit;
        }

        if (!l.Lock())
        {
            ::ReportFailure("Failed to lock global critical section\n");
            goto Exit;
        }

        g_FilesLinked++;
        g_FileLinksProcessed++;

        l.Unlock();
    }
    else
    {
        if (g_fAnnounceSkips)
            ::printf("Skipping hard link creation from \"%ls\" to \"%ls\"\n", static_cast<PCWSTR>(buffDestination), static_cast<PCWSTR>(buffSource));

        if (!l.Lock())
        {
            ::ReportFailure("Failed to lock global critical section\n");
            goto Exit;
        }

        g_LinksSkipped++;
        g_FileLinksProcessed++;

        l.Unlock();
    }

    fSuccess = TRUE;
Exit:
    if (::GetLastError() == ERROR_TOO_MANY_OPEN_FILES)
    {
        rfReQueue = true;
        fSuccess = TRUE;
    }

    return fSuccess;
}

BOOL
MyCopyFile(
    BYTE *pBuffer,
    DWORD cbBuffer,
    PCWSTR lpExistingFileName,
    PCWSTR lpNewFileName,
    BOOL fFailIfExists,
    HANDLE &rhFile
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    LARGE_INTEGER liFileSize;

    rhFile = INVALID_HANDLE_VALUE;

    HANDLE hIn = INVALID_HANDLE_VALUE, hOut = INVALID_HANDLE_VALUE;

    hIn = ::CreateFileW(lpExistingFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hIn == INVALID_HANDLE_VALUE)
    {
        ::ReportFailure("Failed to open input file \"%ls\"\n", lpExistingFileName);
        goto Exit;
    }

    hOut = ::CreateFileW(lpNewFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_NO_BUFFERING, NULL);
    if (hOut == INVALID_HANDLE_VALUE)
    {
        ::ReportFailure("Failed to open output file \"%ls\"\n", lpNewFileName);
        goto Exit;
    }

    liFileSize.QuadPart = 0;

    // let the games begin...

    for (;;)
    {
        DWORD dwBytesRead, dwBytesWritten;
        DWORD dwBytesToWrite = 0;

        if (!::ReadFile(hIn, pBuffer, cbBuffer, &dwBytesRead, NULL))
        {
            ::ReportFailure("Error reading from file \"%ls\"\n", lpExistingFileName);
            goto Exit;
        }

        if (dwBytesRead == 0)
            break;

        liFileSize.QuadPart += dwBytesRead;

        if (dwBytesRead != cbBuffer)
        {
            // We have to round to the cluster size for the write...
            dwBytesToWrite = dwBytesRead + (g_dwDestinationBytesPerSector - 1);
            dwBytesToWrite -= (dwBytesToWrite % g_dwDestinationBytesPerSector);
        }
        else
            dwBytesToWrite = dwBytesRead;

        if (!::WriteFile(hOut, pBuffer, dwBytesToWrite, &dwBytesWritten, NULL))
        {
            ::ReportFailure("Error writing to file \"%ls\"\n", lpNewFileName);
            goto Exit;
        }
    }

    // If the file size wasn't a multiple of the sector size, we need to open the
    // file without the unbuffered flag so that we can set its size to the exact
    // correct byte count.
    if ((liFileSize.QuadPart % g_dwDestinationBytesPerSector) != 0)
    {
        ::CloseHandle(hOut);
        hOut = INVALID_HANDLE_VALUE;

        hOut = ::CreateFileW(lpNewFileName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
        if (hOut == INVALID_HANDLE_VALUE)
        {
            ::ReportFailure("Unable to reopen output file \"%ls\"\n", lpNewFileName);
            goto Exit;
        }

        // Truncate the file appropriately

        if (!::MySetFilePointerEx(hOut, liFileSize, NULL, FILE_BEGIN))
        {
            ::ReportFailure("Error setting file pointer on file \"%ls\"\n", lpNewFileName);
            goto Exit;
        }

        if (!::SetEndOfFile(hOut))
        {
            ::ReportFailure("Error setting end of file on file \"%ls\"\n", lpNewFileName);
            goto Exit;
        }
    }

    ::CloseHandle(hIn);
    hIn = INVALID_HANDLE_VALUE;

    // Pass the handle back out and set it to INVALID_HANDLE_VALUE so that we don't
    // try to close it in the exit path.
    rhFile = hOut;
    hOut = INVALID_HANDLE_VALUE;

    fSuccess = TRUE;
Exit:
    if (hIn != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::CloseHandle(hIn);
        ple.Restore();
    }

    if (hOut != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        ::CloseHandle(hOut);
        ple.Restore();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\fuslogvw\fuslogvw.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       fuslogvw.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    25 Mar 97   t-alans (Alan Shi)   Created
//              12 Jan 00   AlanShi (Alan Shi)   Copied from cdllogvw
//              30 May 00   AlanShi (Alan Shi)   Modified to show date/time
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <wininet.h>
#include <commctrl.h>
#include "cdlids.h"
#include "wininet.h"

#define URL_SEARCH_PATTERN             "?FusionBindError!name="
#define DELIMITER_CHAR                 '!'
#define MAX_CACHE_ENTRY_INFO_SIZE      2048
#define MAX_DATE_LEN                   64

#define PAD_DIGITS_FOR_STRING(x) (((x) > 9) ? TEXT("") : TEXT("0"))

const char   *ppszMonths[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

LRESULT CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
void ViewLogEntry(HWND hwnd);
void RefreshLogView(HWND hwnd);
void DeleteLogEntry(HWND hwnd);
void DeleteAllLogs(HWND hwnd);
void FormatDateBuffer(FILETIME *pftLastMod, LPSTR szBuf);
void InitListView(HWND hwndLV);
void AddLogItem(HWND hwndLV, LPINTERNET_CACHE_ENTRY_INFO pCacheEntryInfo);

HINSTANCE hInst;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   PSTR szCmdLine, int iCmdShow)
{
    hInst = hInstance;
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_CDLLOGVIEW), NULL, DlgProc);

    return 0;
}

LRESULT CALLBACK DlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    HWND                                 hwndLV;
    LPNMHDR                              pnmh = NULL;

    switch (iMsg) {
        case WM_INITDIALOG:
            hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
            InitListView(hwndLV);

            RefreshLogView(hwnd);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;
                case IDC_CB_VIEWLOG:
                    ViewLogEntry(hwnd);
                    break;

                case IDC_CB_REFRESH:
                    RefreshLogView(hwnd);
                    break;

                case IDC_CB_DELETE:
                    DeleteLogEntry(hwnd);
                    break;

                case IDC_CB_DELETE_ALL:
                    DeleteAllLogs(hwnd);
                    break;
            }

            return TRUE;

        case WM_NOTIFY:
            if (wParam == IDC_LV_LOGMESSAGES) {
                pnmh = (LPNMHDR)lParam;

                if (pnmh->code == LVN_ITEMACTIVATE) {
                    // Double click (or otherwise activated)
                    ViewLogEntry(hwnd);
                }
            }

            return TRUE;
    }

    return FALSE;
}

void DeleteLogEntry(HWND hwnd)
{
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    HWND                            hwndLV;
    LRESULT                         lIndex = 0;
    LRESULT                         lLength = 0;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    char                            szBuf[INTERNET_MAX_URL_LENGTH];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    lIndex = ListView_GetSelectionMark(hwndLV);
    ListView_GetItemText(hwndLV, lIndex, 0, szBuf, INTERNET_MAX_URL_LENGTH);

    lstrcpy(szUrl, URL_SEARCH_PATTERN);
    lstrcat(szUrl, szBuf);

    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;

    if (DeleteUrlCacheEntry(szUrl)) {
        RefreshLogView(hwnd);
    }
    else {
        MessageBox(hwnd, "Error: Unable to delete cache file!",
                   "Log View Error", MB_OK | MB_ICONERROR);
    }
}

void DeleteAllLogs(HWND hwnd)
{
    HWND                            hwndLV;
    LVITEM                          lvitem;
    char                            szBuf[INTERNET_MAX_URL_LENGTH];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    int                             iCount;
    int                             i;

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    memset(&lvitem, 0, sizeof(LVITEM));
    lvitem.iSubItem = 0;
    lvitem.mask = LVIF_TEXT;
    lvitem.cchTextMax = INTERNET_MAX_URL_LENGTH;
    lvitem.pszText = szBuf;

    iCount = ListView_GetItemCount(hwndLV);
    for (i = 0; i < iCount; i++) {
        szBuf[0] = TEXT('\0');
        lvitem.iItem = i;

        if (ListView_GetItem(hwndLV, &lvitem)) {
            lstrcpy(szUrl, URL_SEARCH_PATTERN);
            lstrcat(szUrl, lvitem.pszText);

            DeleteUrlCacheEntry(szUrl);
        }
    }

    RefreshLogView(hwnd);
}

void ViewLogEntry(HWND hwnd)
{
    LRESULT                         lIndex = 0;
    LRESULT                         lLength = 0;
    HWND                            hwndLV;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    char                            szBuf[INTERNET_MAX_URL_LENGTH];
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    lIndex = ListView_GetSelectionMark(hwndLV);
    ListView_GetItemText(hwndLV, lIndex, 0, szBuf, INTERNET_MAX_URL_LENGTH);

    lstrcpy(szUrl, URL_SEARCH_PATTERN);
    lstrcat(szUrl, szBuf);

    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;

    if (GetUrlCacheEntryInfo(szUrl, pCacheEntryInfo, &dwBufferSize)) {
        if (pCacheEntryInfo->lpszLocalFileName != NULL) {
            if (ShellExecute(NULL, "open",  pCacheEntryInfo->lpszLocalFileName,
                             NULL, NULL, SW_SHOWNORMAL ) <= (HINSTANCE)32) {
                // ShellExecute returns <= 32 if error occured
                MessageBox(hwnd, "Error: Unable to open cache file!",
                            "Log View Error", MB_OK | MB_ICONERROR);
            }
        }
        else {
                MessageBox(hwnd, "Error: No file name available!",
                           "Log View Error", MB_OK | MB_ICONERROR);
        }
    }
}

void RefreshLogView(HWND hwnd)
{
    HANDLE                          hUrlCacheEnum;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    HWND                            hwndLV;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    ListView_DeleteAllItems(hwndLV);
    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    hUrlCacheEnum = FindFirstUrlCacheEntry(URL_SEARCH_PATTERN, pCacheEntryInfo,
                                           &dwBufferSize);
    if (hUrlCacheEnum != NULL) {
        if (pCacheEntryInfo->lpszSourceUrlName != NULL) {
            if (StrStrI(pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN)) {
                AddLogItem(hwndLV, pCacheEntryInfo);
            }
        }

        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        while (FindNextUrlCacheEntry(hUrlCacheEnum, pCacheEntryInfo,
                                     &dwBufferSize)) {
            if (pCacheEntryInfo->lpszSourceUrlName != NULL) {
                if (StrStrI(pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN)) {
                    AddLogItem(hwndLV, pCacheEntryInfo);
                }
            }

            dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        }
    }
}

void AddLogItem(HWND hwndLV, LPINTERNET_CACHE_ENTRY_INFO pCacheEntryInfo)
{
    LVITEM                          lvitem;
    static char                     szBuf[MAX_DATE_LEN];

    memset(&lvitem, 0, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT;

    FormatDateBuffer(&pCacheEntryInfo->LastModifiedTime, szBuf);

    lvitem.iItem = 0;
    lvitem.iSubItem = 0;
    lvitem.pszText = pCacheEntryInfo->lpszSourceUrlName + lstrlen(URL_SEARCH_PATTERN);

    lvitem.iItem = ListView_InsertItem(hwndLV, &lvitem);

    lvitem.iSubItem = 1;
    lvitem.pszText = szBuf;

    ListView_SetItem(hwndLV, &lvitem);
}

void FormatDateBuffer(FILETIME *pftLastMod, LPSTR szBuf)
{
    SYSTEMTIME                    systime;
    FILETIME                      ftLocalLastMod;

    FileTimeToLocalFileTime(pftLastMod, &ftLocalLastMod);
    FileTimeToSystemTime(&ftLocalLastMod, &systime);

    wnsprintf(szBuf, MAX_DATE_LEN, "%s%d %s %d @ %s%d:%s%d:%s%d",
              PAD_DIGITS_FOR_STRING(systime.wDay), systime.wDay,
              ppszMonths[systime.wMonth - 1],
              systime.wYear,
              PAD_DIGITS_FOR_STRING(systime.wHour), systime.wHour,
              PAD_DIGITS_FOR_STRING(systime.wMinute), systime.wMinute,
              PAD_DIGITS_FOR_STRING(systime.wSecond), systime.wSecond);

}

void InitListView(HWND hwndLV)
{
    LVCOLUMN                lvcol;

    memset(&lvcol, 0, sizeof(LVCOLUMN));

    lvcol.mask = LVCF_TEXT | LVCF_WIDTH;

    lvcol.cx = 350;
    lvcol.pszText = TEXT("Description");

    ListView_InsertColumn(hwndLV, 0, &lvcol);

    lvcol.pszText = TEXT("Date/Time");
    lvcol.cx = 150;

    ListView_InsertColumn(hwndLV, 1, &lvcol);

}

int
_stdcall
ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL),
                NULL,
                pszCmdLine,
                (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;           // We never come here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\pktextract\patch\patch.cpp ===
#pragma warning(disable:4127) /* constant conditional expression */
#pragma warning(disable:4100) /* unused parameter */
#include <stdio.h>
#include "windows.h"
#define ASSERT(x) /* nothing */
#include "SxApwHandle.h"
#include "imagehlp.h"

void Main(int argc, char** argv)
{
    CFusionFile File;
    CFileMapping FileMapping;
    CMappedViewOfFile MappedView;
    PIMAGE_SECTION_HEADER ImportSectionHeader = NULL;
    ULONG ImportSize = 0;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor = NULL;
    PIMAGE_NT_HEADERS NtHeaders;

    if (!File.Win32Create(argv[1], GENERIC_READ | GENERIC_WRITE, 0, OPEN_EXISTING))
        goto Exit;
    if (!FileMapping.Win32CreateFileMapping(File, PAGE_READWRITE))
        goto Exit;
    if (!MappedView.Win32MapViewOfFile(FileMapping, FILE_MAP_WRITE))
        goto Exit;
    NtHeaders = ImageNtHeader(MappedView);
    ImportDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(ImageDirectoryEntryToDataEx(MappedView, FALSE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportSize, &ImportSectionHeader));
    while (ImportDescriptor->Name != 0)
    {
        PSTR DllName = reinterpret_cast<PSTR>(ImageRvaToVa(NtHeaders, MappedView, ImportDescriptor->Name, &ImportSectionHeader));
        printf("%s\n", DllName);
        if (_stricmp(DllName, "ntdll.dll") == 0)
        {
            strcpy(DllName, "ntdll.hak");

            DWORD OldChecksum = 0;
            CheckSumMappedFile(MappedView, GetFileSize(File, NULL), &OldChecksum, &NtHeaders->OptionalHeader.CheckSum);
        }
        ++ImportDescriptor;
    }

Exit:
    return;
}

int __cdecl main(int argc, char** argv)
{
    Main(argc, argv);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\preprocessor\stdinc.h ===
#if defined(_WIN64)
#define UNICODE
#define _UNICODE
#endif
#include <utility>
#pragma warning(disable:4663) /* C++ language change */
#pragma warning(disable:4512) /* assignment operator could not be generated */
#pragma warning(disable:4511) /* copy constructor could not be generated */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion, possible loss of data */
#pragma warning(disable:4244) /* conversion, possible loss of data */
#endif
#pragma warning(disable:4018) /* '<=' : signed/unsigned mismatch */
#pragma warning(disable:4389) /* '!=' : signed/unsigned */
#include "windows.h"
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <sstream>
#include <map>
#include <stdio.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
using std::wstring;
using std::string;
using std::vector;
using std::wistream;
using std::wifstream;
using std::getline;
using std::basic_string;
typedef CONST VOID* PCVOID;

class CByteVector : public std::vector<BYTE>
{
public:
    CByteVector() { }
    ~CByteVector() { }

    const BYTE* bytes() const { return &front(); }
          BYTE* bytes()       { return &front(); }

    operator PCSTR  () const { return reinterpret_cast<PCSTR>(this->bytes()); }
    operator PSTR   ()       { return reinterpret_cast<PSTR>(this->bytes()); }
    operator PCWSTR () const { return reinterpret_cast<PCWSTR>(this->bytes()); }
    operator PWSTR  ()       { return reinterpret_cast<PWSTR>(this->bytes()); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\preprocessor\win32file.cpp ===
#include "stdinc.h"
#include "win32file.h"
#include "atlbase.h"
#include "atlconv.h"

#define IS_NT() ((GetVersion() & 0x80000000) == 0)

using std::wstring;

void Win32File::snarfFullFile(wstring& output)
{
    output = L"";
    CByteVector bytes;
    DWORD dwReadSize = 0;

    bytes.resize(filesize() - filepointer());
    if (!ReadFile(_hFile, &bytes.front(), bytes.size(), &dwReadSize, NULL))
    {
        throw new ReadWriteError(false, ::GetLastError());
    }

    // Otherwise, bash the byte vector into a wstring for output
    output = ConvertToWstring(bytes, _type);
}




void Win32File::writeLine(wstring& dump)
{
    CByteVector vb;
    DWORD dwWritten;

    vb = ConvertWstringToDestination(dump, _type);
    if (!WriteFile(_hFile, &vb.front(), vb.size(), &dwWritten, NULL))
        throw new ReadWriteError(true, ::GetLastError());
}



bool Win32File::eof() { return false; }

void
Win32File::openForRead(wstring wstname)
{
    USES_CONVERSION;

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        throw new AlreadyOpened;
    }

    const PCWSTR pcwstr = wstname.c_str();
    const DWORD Flags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;

    _hFile =
        IS_NT() ? CreateFileW(pcwstr, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, Flags, NULL)
                : CreateFileA(W2A(pcwstr), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, Flags, NULL);

    if (_hFile == INVALID_HANDLE_VALUE || _hFile == NULL)
    {
        throw new OpeningError(GetLastError());
    }


    // If this was for reading, then sniff the first few bytes and see what kind
    // of file it is.
    DWORD dwReadBytes = 0;
    BYTE bBuffer[256];
    if (!ReadFile(_hFile, bBuffer, sizeof(bBuffer), &dwReadBytes, NULL))
    {
        throw new ReadWriteError(true, GetLastError());
    }

    // Now let's determine what kind of buffer we've got
    _type = DetermineFileTypeFromBuffer(bBuffer, dwReadBytes);
    _bOpenForRead = true;

    // Let's zip the file pointer past the first gunk
    SetFilePointer(_hFile, DetermineFileTypeSigSize(_type), NULL, FILE_BEGIN);

}




void
Win32File::openForWrite(wstring wstname, FileContentType fct, bool bOverwrite)
{
    USES_CONVERSION;

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        throw new AlreadyOpened;
    }

    const DWORD OpenOrCreate = bOverwrite ? CREATE_ALWAYS : CREATE_NEW;
    const DWORD Flags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;
    PCWSTR pcwstr = wstname.c_str();

    _hFile =
        IS_NT() ? CreateFileW(pcwstr, GENERIC_WRITE, FILE_SHARE_READ, NULL, OpenOrCreate, Flags, NULL)
                : CreateFileA(W2A(pcwstr), GENERIC_WRITE, FILE_SHARE_READ, NULL, OpenOrCreate, Flags, NULL);

    if (_hFile == INVALID_HANDLE_VALUE || _hFile == NULL)
    {
        throw new OpeningError(GetLastError());
    }

    // Now that we have an open file, let's blop the signature bytes into it.
    DWORD dwWritten;
    DWORD dwToWrite;
    PCVOID pvWriteBuffer;
    switch (fct) {
    case FileContentsUnicode:
        pvWriteBuffer = UNICODE_SIGNATURE;
        dwToWrite = sizeof(UNICODE_SIGNATURE);
        break;
    case FileContentsUnicodeBigEndian:
        pvWriteBuffer = UNICODE_BIG_ENDIAN_SIGNATURE;
        dwToWrite = sizeof(UNICODE_BIG_ENDIAN_SIGNATURE);
        break;
    case FileContentsUTF8:
        pvWriteBuffer = NULL;
        dwToWrite = 0;
        break;
    default:
        pvWriteBuffer = UNICODE_SIGNATURE;
        dwToWrite = 0;
        break;
    }

    if (!WriteFile(_hFile, pvWriteBuffer, dwToWrite, &dwWritten, NULL) || (dwWritten != dwToWrite)) {
        throw new ReadWriteError(false, GetLastError());
    }

    _bOpenForRead = false;
    _type = fct;
}




Win32File::Win32File()
    : _hFile(INVALID_HANDLE_VALUE), _type(FileContentsUTF8),
      _bOpenForRead(false), _bEof(false)
{
}





Win32File::~Win32File() { if (_hFile != INVALID_HANDLE_VALUE) { CloseHandle(_hFile); } };


FileContentType DetermineFileTypeFromBuffer(unsigned char *data, int length)
{
    #define CHECKMARK(tp, ct) if ((length > sizeof(tp)) && (memcmp(data, tp, sizeof(tp)) == 0)) return ct;

    CHECKMARK(UNICODE_SIGNATURE, FileContentsUnicode);
    CHECKMARK(UNICODE_BIG_ENDIAN_SIGNATURE, FileContentsUnicodeBigEndian);
    CHECKMARK(UTF8_SIGNATURE, FileContentsUTF8);
    return FileContentsUTF8;
}

int DetermineFileTypeSigSize(FileContentType type)
{
    switch (type)
    {
        case FileContentsUnicode: return sizeof(UNICODE_SIGNATURE);
        case FileContentsUnicodeBigEndian: return sizeof(UNICODE_BIG_ENDIAN_SIGNATURE);
        case FileContentsUTF8:
        default: return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\tools\powercopy\powercopy.cpp ===
// powercopy.cpp : Defines the entry point for the console application.
//

#include <istream>
#include <strstream>
#include <sstream>
#include <string>
#include <iostream>
#include <queue>
#include <vector>
#include <utility>
#include "windows.h"
#include "winbase.h"

using namespace std;

typedef __int64 BigInteger;


void AssertionFailed(
    PCSTR Function,
    int Li