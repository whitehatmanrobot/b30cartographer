ating data
					else
					{
						_dwControlCode = CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES;
					} // else: setting data

					// Set private properties.
					_sc = ClusterResourceTypeControl(
									Hcluster(),
									Peo()->PodObjData()->m_strName,
									NULL,	// hNode
									_dwControlCode,
									_cpl.PbPropList(),
									_cpl.CbPropList(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&_cbProps
									);
					break;
				case CLUADMEX_OT_NETWORK:
					ASSERT( Peo()->PndNetworkData() != NULL );
					ASSERT( Peo()->PndNetworkData()->m_hnetwork != NULL );

					// Determine which control code to use.
					if ( bValidateOnly )
					{
						_dwControlCode = CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES;
					} // if: only validating data
					else
					{
						_dwControlCode = CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES;
					} // else: setting data

					// Set private properties.
					_sc = ClusterNetworkControl(
									Peo()->PndNetworkData()->m_hnetwork,
									NULL,	// hNode
									_dwControlCode,
									_cpl.PbPropList(),
									_cpl.CbPropList(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&_cbProps
									);
					break;
				case CLUADMEX_OT_NETINTERFACE:
					ASSERT( Peo()->PndNetInterfaceData() != NULL );
					ASSERT( Peo()->PndNetInterfaceData()->m_hnetinterface != NULL );

					// Determine which control code to use.
					if ( bValidateOnly )
					{
						_dwControlCode = CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES;
					} // if: only validating data
					else
					{
						_dwControlCode = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
					} // else: setting data

					// Set private properties.
					_sc = ClusterNetInterfaceControl(
									Peo()->PndNetInterfaceData()->m_hnetinterface,
									NULL,	// hNode
									_dwControlCode,
									_cpl.PbPropList(),
									_cpl.CbPropList(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&_cbProps
									);
					break;
				default:
					ASSERT( 0 );
			} // switch: object type

			// Handle errors.
			if ( _sc != ERROR_SUCCESS )
			{
				if ( _sc == ERROR_INVALID_PARAMETER )
				{
					if ( ! bNoNewProps )
					{
						_bSuccess = BSetPrivateProps( bValidateOnly, TRUE /*bNoNewProps*/ );
					} // if: new props are allowed
					else
						_bSuccess = FALSE;
				} // if: invalid parameter error occurred
				else if (	bValidateOnly
						||	(_sc != ERROR_RESOURCE_PROPERTIES_STORED) )
				{
					_bSuccess = FALSE;
				} // else if: only validating and error other than properties only stored

				//
				// If an error occurred, display an error message.
				//
				if ( ! _bSuccess )
				{
					DisplaySetPropsError( _sc, bValidateOnly ? IDS_ERROR_VALIDATING_PROPERTIES : IDS_ERROR_SETTING_PROPERTIES );
				} // if: error occurred
			} // if: error setting/validating data
		} // if: there is data to set
	} // if: no errors building the property list

	// Save data locally.
	if ( ! bValidateOnly && _bSuccess )
	{
		// Save new values as previous values.
		try
		{
			DWORD					_cprop;
			const CObjectProperty *	_pprop;

			for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
			{
				switch ( _pprop->m_propFormat )
				{
					case CLUSPROP_FORMAT_SZ:
					case CLUSPROP_FORMAT_EXPAND_SZ:
						ASSERT(_pprop->m_value.pstr != NULL);
						ASSERT(_pprop->m_valuePrev.pstr != NULL);
						*_pprop->m_valuePrev.pstr = *_pprop->m_value.pstr;
						break;
					case CLUSPROP_FORMAT_DWORD:
					case CLUSPROP_FORMAT_LONG:
						ASSERT( _pprop->m_value.pdw != NULL );
						ASSERT( _pprop->m_valuePrev.pdw != NULL );
						*_pprop->m_valuePrev.pdw = *_pprop->m_value.pdw;
						break;
					case CLUSPROP_FORMAT_BINARY:
					case CLUSPROP_FORMAT_MULTI_SZ:
						ASSERT( _pprop->m_value.ppb != NULL );
						ASSERT( *_pprop->m_value.ppb != NULL );
						ASSERT( _pprop->m_value.pcb != NULL );
						ASSERT( _pprop->m_valuePrev.ppb != NULL );
						ASSERT( *_pprop->m_valuePrev.ppb != NULL );
						ASSERT( _pprop->m_valuePrev.pcb != NULL );
						delete [] *_pprop->m_valuePrev.ppb;
						*_pprop->m_valuePrev.ppb = new BYTE[ *_pprop->m_value.pcb ];
						CopyMemory( *_pprop->m_valuePrev.ppb, *_pprop->m_value.ppb, *_pprop->m_value.pcb );
						*_pprop->m_valuePrev.pcb = *_pprop->m_value.pcb;
						break;
					default:
						ASSERT( 0 ); // don't know how to deal with this type
				} // switch: property format
			} // for: each property
		} // try
		catch ( CException * _pe )
		{
			_pe->ReportError();
			_pe->Delete();
			_bSuccess = FALSE;
		} // catch: CException
	} // if: not just validating and successful so far

	//
	// Indicate we successfully saved the properties.
	//
	if ( ! bValidateOnly && _bSuccess )
	{
		m_bSaved = TRUE;
	} // if: successfully saved data

	return _bSuccess;

} //*** CBasePropertyPage::BSetPrivateProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DisplaySetPropsError
//
//	Routine Description:
//		Display an error caused by setting or validating properties.
//
//	Arguments:
//		sc		[IN] Status to display error on.
//		idsOper	[IN] Operation message.
//
//	Return Value:
//		nStatus	ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DisplaySetPropsError(
	IN DWORD	sc,
	IN UINT		idsOper
	) const
{
	CString _strErrorMsg;
	CString _strOperMsg;
	CString	_strMsgIdFmt;
	CString _strMsgId;
	CString _strMsg;

	_strOperMsg.LoadString( IDS_ERROR_SETTING_PROPERTIES );
	FormatError( _strErrorMsg, sc );
	_strMsgIdFmt.LoadString( IDS_ERROR_MSG_ID );
	_strMsgId.Format( _strMsgIdFmt, sc, sc );
	_strMsg.Format( _T("%s\n\n%s%s"), _strOperMsg, _strErrorMsg, _strMsgId );
	AfxMessageBox( _strMsg );

}  //*** CBasePropertyPage::DisplaySetPropsError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu( CWnd * pWnd, CPoint point )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	m_dlghelp.OnContextMenu( pWnd, point );

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo( HELPINFO * pHelpInfo )
{
	BOOL	_bProcessed;

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	_bProcessed = m_dlghelp.OnHelpInfo( pHelpInfo );
	if ( ! _bProcessed )
	{
		_bProcessed = CPropertyPage::OnHelpInfo( pHelpInfo );
	} // if: message not processed yet
	return _bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp( WPARAM wParam, LPARAM lParam )
{
	LRESULT _bProcessed;

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	_bProcessed = m_dlghelp.OnCommandHelp( wParam, lParam );
	if ( ! _bProcessed )
	{
		_bProcessed = CPropertyPage::OnCommandHelp( wParam, lParam );
	} // if: message not processed yet

	return _bProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetres\wins.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Wins.cpp
//
//  Description:
//      Resource DLL for WINS Services (ClNetRes).
//
//  Author:
//      David Potter (DavidP) March 17, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "ClNetRes.h"
#include "clusvmsg.h"
#include "clusrtl.h"

//
// Type and constant definitions.
//

#define WINS_PARAMS_REGKEY          L"System\\CurrentControlSet\\Services\\WINS\\Parameters"
#define WINS_DATABASEPATH_REGVALUE  L"DbFileNm"
#define WINS_DATABASEPATH2_REGVALUE L"LogFilePath"
#define WINS_BACKUPPATH_REGVALUE    L"BackupDirPath"
#define WINS_CLUSRESNAME_REGVALUE   L"ClusterResourceName"
#define WINS_DATABASE_FILE_NAME     L"wins.mdb"


// ADDPARAM: Add new properties here.
#define PROP_NAME__DATABASEPATH L"DatabasePath"
#define PROP_NAME__BACKUPPATH   L"BackupPath"


#define PROP_DEFAULT__DATABASEPATH  L"%SystemRoot%\\system32\\wins\\"
#define PROP_DEFAULT__BACKUPPATH    L"%SystemRoot%\\system32\\wins\\backup\\"


// ADDPARAM: Add new properties here.
typedef struct _WINS_PROPS
{
    PWSTR           pszDatabasePath;
    PWSTR           pszBackupPath;
} WINS_PROPS, * PWINS_PROPS;

typedef struct _WINS_RESOURCE
{
    RESID                   resid; // for validation
    WINS_PROPS              props;
    HCLUSTER                hCluster;
    HRESOURCE               hResource;
    SC_HANDLE               hService;
    DWORD                   dwServicePid;
    HKEY                    hkeyParameters;
    RESOURCE_HANDLE         hResourceHandle;
    LPWSTR                  pszResourceName;
    CLUS_WORKER             cwWorkerThread;
    CLUSTER_RESOURCE_STATE  state;
} WINS_RESOURCE, * PWINS_RESOURCE;


//
// Global data.
//

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_WinsFunctionTable;

// Single instance semaphore.

#define WINS_SINGLE_INSTANCE_SEMAPHORE L"Cluster$WINS$Semaphore"
static HANDLE g_hSingleInstanceSemaphoreWins = NULL;
static PWINS_RESOURCE g_pSingleInstanceResourceWins = NULL;

//
// WINS Service resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
WinsResourcePrivateProperties[] =
{
    { PROP_NAME__DATABASEPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( WINS_PROPS, pszDatabasePath ) },
    { PROP_NAME__BACKUPPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( WINS_PROPS, pszBackupPath ) },
    { 0 }
};

//
// Registry key checkpoints.
//
LPCWSTR g_pszRegKeysWins[] =
{
    L"System\\CurrentControlSet\\Services\\WINS\\Parameters",
    L"System\\CurrentControlSet\\Services\\WINS\\Partners",
    NULL
};

//
// Crypto key checkpoints.
//
LPCWSTR g_pszCryptoKeysWins[] =
{
    // TODO: Specify any crypto keys to be checkpointed for resources of this type
    // e.g. L"1\\My Provider v1.0\\MYACRONYM",
    NULL
};

//
// Domestic crypto key checkpoints.
//
LPCWSTR g_pszDomesticCryptoKeysWins[] =
{
    // TODO: Specify any domestic crypto keys to be checkpointed for resources of this type
    // e.g. L"1\\My Enhanced Provider v1.0\\MYACRONYM_128",
    NULL
};

//
// Function prototypes.
//

RESID WINAPI WinsOpen(
    IN  LPCWSTR         pszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    );

void WINAPI WinsClose( IN RESID resid );

DWORD WINAPI WinsOnline(
    IN      RESID   resid,
    IN OUT  PHANDLE phEventHandle
    );

DWORD WINAPI WinsOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PWINS_RESOURCE  pResourceEntry
    );

DWORD WINAPI WinsOffline( IN RESID resid );

DWORD WINAPI WinsOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PWINS_RESOURCE  pResourceEntry
    );

void WINAPI WinsTerminate( IN RESID resid );

BOOL WINAPI WinsLooksAlive( IN RESID resid );

BOOL WINAPI WinsIsAlive( IN RESID resid );

BOOL WinsCheckIsAlive(
    IN PWINS_RESOURCE   pResourceEntry,
    IN BOOL             bFullCheck
    );

DWORD WINAPI WinsResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD WinsGetRequiredDependencies(
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD WinsReadParametersToParameterBlock(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      BOOL            bCheckForRequiredProperties
    );

DWORD WinsGetPrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    OUT     PVOID           pOutBuffer,
    IN      DWORD           cbOutBufferSize,
    OUT     LPDWORD         pcbBytesReturned
    );

DWORD WinsValidatePrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      const PVOID     pInBuffer,
    IN      DWORD           cbInBufferSize,
    OUT     PWINS_PROPS     pProps
    );

DWORD WinsValidateParameters(
    IN  PWINS_RESOURCE  pResourceEntry,
    IN  PWINS_PROPS     pProps
    );

DWORD WinsSetPrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      const PVOID     pInBuffer,
    IN      DWORD           cbInBufferSize
    );

DWORD WinsZapSystemRegistry(
    IN  PWINS_RESOURCE  pResourceEntry,
    IN  PWINS_PROPS     pProps,
    IN  HKEY            hkeyParametersKey
    );

DWORD WinsGetDefaultPropertyValues(
    IN      PWINS_RESOURCE  pResourceEntry,
    IN OUT  PWINS_PROPS     pProps
    );

DWORD WinsDeleteResourceHandler( IN PWINS_RESOURCE pResourceEntry );

DWORD WinsSetNameHandler(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      LPWSTR          pszName
    );


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsDllMain
//
//  Description:
//      Main DLL entry point for the WINS Service resource type.
//
//  Arguments:
//      DllHandle   [IN] DLL instance handle.
//      Reason      [IN] Reason for being called.
//      Reserved    [IN] Reserved argument.
//
//  Return Value:
//      TRUE        Success.
//      FALSE       Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI WinsDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    )
{
    //WCHAR szErrorMsg[ 2048 ];
    DWORD status;

    switch ( nReason )
    {
        case DLL_PROCESS_ATTACH:
            //if ( g_hSingleInstanceSemaphoreWins != NULL )
            //{
            //    OutputDebugString( L"WinsDllMain: semaphore not NULL\n" );
            //}
            g_hSingleInstanceSemaphoreWins = CreateSemaphoreW(
                NULL,
                0,
                1,
                WINS_SINGLE_INSTANCE_SEMAPHORE
                );
            status = GetLastError();
            //wsprintf( szErrorMsg, L"WinsDllMain: Status %d from CreateSemaphoreW, handle = %08.8x\n", status, g_hSingleInstanceSemaphoreWins );
            //OutputDebugString( szErrorMsg );
            if ( g_hSingleInstanceSemaphoreWins == NULL )
            {
                return FALSE;
            } // if: error creating semaphore
            if ( status != ERROR_ALREADY_EXISTS )
            {
                // If the semaphore didnt exist, set its initial count to 1.
                ReleaseSemaphore( g_hSingleInstanceSemaphoreWins, 1, NULL );
            } // if: semaphore didn't already exist
            break;

        case DLL_PROCESS_DETACH:
            if ( g_hSingleInstanceSemaphoreWins != NULL )
            {
                CloseHandle( g_hSingleInstanceSemaphoreWins );
                g_hSingleInstanceSemaphoreWins = NULL;
            } // if: single instance semaphore was created
            break;

    } // switch: nReason

    return TRUE;

} //*** WinsDllMain()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsStartup
//
//  Description:
//      Startup the resource DLL for the WINS Service resource type.
//      This routine verifies that at least one currently supported version
//      of the resource DLL is between nMinVersionSupported and
//      nMaxVersionSupported. If not, then the resource DLL should return
//      ERROR_REVISION_MISMATCH.
//
//      If more than one version of the resource DLL interface is supported
//      by the resource DLL, then the highest version (up to
//      nMaxVersionSupported) should be returned as the resource DLL's
//      interface. If the returned version is not within range, then startup
//      fails.
//
//      The Resource Type is passed in so that if the resource DLL supports
//      more than one Resource Type, it can pass back the correct function
//      table associated with the Resource Type.
//
//  Arguments:
//      pszResourceType [IN]
//          Type of resource requesting a function table.
//
//      nMinVersionSupported [IN]
//          Minimum resource DLL interface version supported by the cluster
//          software.
//
//      nMaxVersionSupported [IN]
//          Maximum resource DLL interface version supported by the cluster
//          software.
//
//      pfnSetResourceStatus [IN]
//          Pointer to a routine that the resource DLL should call to update
//          the state of a resource after the Online or Offline routine
//          have returned a status of ERROR_IO_PENDING.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      pFunctionTable [IN]
//          Returns a pointer to the function table defined for the version
//          of the resource DLL interface returned by the resource DLL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful.
//
//      ERROR_CLUSTER_RESNAME_NOT_FOUND
//          The resource type name is unknown by this DLL.
//
//      ERROR_REVISION_MISMATCH
//          The version of the cluster service doesn't match the version of
//          the DLL.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsStartup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    )
{
    DWORD nStatus;

    if (   (nMinVersionSupported > CLRES_VERSION_V1_00)
        || (nMaxVersionSupported < CLRES_VERSION_V1_00) )
    {
        nStatus = ERROR_REVISION_MISMATCH;
    } // if: version not supported
    else if ( lstrcmpiW( pszResourceType, WINS_RESNAME ) != 0 )
    {
        nStatus = ERROR_CLUSTER_RESNAME_NOT_FOUND;
    } // if: resource type name not supported
    else
    {
        *pFunctionTable = &g_WinsFunctionTable;
        nStatus = ERROR_SUCCESS;
    } // else: we support this type of resource

    return nStatus;

} //*** WinsStartup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOpen
//
//  Description:
//      Open routine for WINS Service resources.
//
//      Open the specified resource (create an instance of the resource).
//      Allocate all structures necessary to bring the specified resource
//      online.
//
//  Arguments:
//      pszResourceName [IN]
//          Supplies the name of the resource to open.
//
//      hkeyResourceKey [IN]
//                  Supplies handle to the resource's cluster database key.
//
//      hResourceHandle [IN]
//          A handle that is passed back to the Resource Monitor when the
//          SetResourceStatus or LogEvent method is called.  See the
//          description of the pfnSetResourceStatus and pfnLogEvent arguments
//          to the WinsStartup routine.  This handle should never be
//          closed or used for any purpose other than passing it as an
//          argument back to the Resource Monitor in the SetResourceStatus or
//          LogEvent callbacks.
//
//  Return Value:
//      resid
//          RESID of opened resource.
//
//      NULL
//          Error occurred opening the resource.  Resource Monitor may call
//          GetLastError() to get more details on the error.
//
//--
/////////////////////////////////////////////////////////////////////////////
RESID WINAPI WinsOpen(
    IN  LPCWSTR         pszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    )
{
    DWORD           nStatus;
    RESID           resid = 0;
    HKEY            hkeyParameters = NULL;
    PWINS_RESOURCE  pResourceEntry = NULL;
    DWORD           bSemaphoreAcquired = FALSE; 

    // Loop to avoid goto's.
    do
    {
        //
        // Check if more than one resource of this type.
        //
        if ( WaitForSingleObject( g_hSingleInstanceSemaphoreWins, 0 ) == WAIT_TIMEOUT )
        {
            //
            // A version of this service is already running.
            //
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Service is already running.\n"
                );
            nStatus = ERROR_SERVICE_ALREADY_RUNNING;
            break;
        } // if: semaphore for resources of this type already already locked

        bSemaphoreAcquired = FALSE;
        
        if ( g_pSingleInstanceResourceWins != NULL )
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Service resource info non-null!\n"
                );
            nStatus = ERROR_DUPLICATE_SERVICE_NAME;
            break;
        } // if: resource of this type already exists

        //
        // Get a global handle to the Service Control Manager (SCM).
        // There is no call to CloseSCManager(), since the only time we will
        // need to close this handle is if we are shutting down.
        //
        if ( g_schSCMHandle == NULL )
        {
            g_schSCMHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
            if ( g_schSCMHandle == NULL )
            {
                nStatus = GetLastError();
                (g_pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"Failed to open Service Control Manager. Error: %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error opening the Service Control Manager
        } // if: Service Control Manager not open yet

        //
        // Make sure the service has been stopped.
        //
        nStatus = ResUtilStopResourceService( WINS_SVCNAME );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Failed to stop the '%1!ls!' service. Error: %2!u!.\n",
                WINS_SVCNAME,
                nStatus
                );
            ClNetResLogSystemEvent1(
                LOG_CRITICAL,
                NETRES_RESOURCE_STOP_ERROR,
                nStatus,
                L"WINS" );
            // Don't break here if we fail since we retry to stop it in WinsOnlineThread 
        } // if: resource of this type already exists

        //
        // Open the Parameters registry key for this resource.
        //
        nStatus = ClusterRegOpenKey(
                        hkeyResourceKey,
                        L"Parameters",
                        KEY_ALL_ACCESS,
                        &hkeyParameters
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Unable to open Parameters key. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error creating the Parameters key for the resource

        //
        // Allocate a resource entry.
        //
        pResourceEntry = static_cast< WINS_RESOURCE * >(
            LocalAlloc( LMEM_FIXED, sizeof( WINS_RESOURCE ) )
            );
        if ( pResourceEntry == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Unable to allocate resource entry structure. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error allocating memory for the resource

        //
        // Initialize the resource entry..
        //
        ZeroMemory( pResourceEntry, sizeof( WINS_RESOURCE ) );

        pResourceEntry->resid = static_cast< RESID >( pResourceEntry ); // for validation
        pResourceEntry->hResourceHandle = hResourceHandle;
        pResourceEntry->hkeyParameters = hkeyParameters;
        pResourceEntry->state = ClusterResourceOffline;

        //
        // Save the name of the resource.
        //
        pResourceEntry->pszResourceName = static_cast< LPWSTR >(
            LocalAlloc( LMEM_FIXED, (lstrlenW( pszResourceName ) + 1) * sizeof( WCHAR ) )
            );
        if ( pResourceEntry->pszResourceName == NULL )
        {
            nStatus = GetLastError();
            break;
        } // if: error allocating memory for the name.
        lstrcpyW( pResourceEntry->pszResourceName, pszResourceName );

        //
        // Open the cluster.
        //
        pResourceEntry->hCluster = OpenCluster( NULL );
        if ( pResourceEntry->hCluster == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Unable to open the cluster. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the cluster

        //
        // Open the resource.
        //
        pResourceEntry->hResource = OpenClusterResource(
                                        pResourceEntry->hCluster,
                                        pszResourceName
                                        );
        if ( pResourceEntry->hResource == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Unable to open the resource. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the resource

        //
        // Configure registry key checkpoints.
        //
        nStatus = ConfigureRegistryCheckpoints(
                        pResourceEntry->hResource,
                        hResourceHandle,
                        g_pszRegKeysWins
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error configuring registry key checkpoints

        //
        // Configure crypto key checkpoints.
        //
        nStatus = ConfigureCryptoKeyCheckpoints(
                        pResourceEntry->hResource,
                        hResourceHandle,
                        g_pszCryptoKeysWins
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error configuring crypto key checkpoints

        //
        // Configure domestic crypto key checkpoints.
        //
        nStatus = ConfigureDomesticCryptoKeyCheckpoints(
                        pResourceEntry->hResource,
                        hResourceHandle,
                        g_pszDomesticCryptoKeysWins
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error configuring domestic crypto key checkpoints

        //
        // Startup for the resource.
        //
        // TODO: Add your resource startup code here.


        resid = static_cast< RESID >( pResourceEntry );

    } while ( 0 );


    if ( resid == 0 )
    {
        if ( hkeyParameters != NULL )
        {
            ClusterRegCloseKey( hkeyParameters );
        } // if: registry key was opened
        if ( pResourceEntry != NULL )
        {
            LocalFree( pResourceEntry->pszResourceName );
            LocalFree( pResourceEntry );
        } // if: resource entry allocated
    }

    if ( nStatus != ERROR_SUCCESS )
    {
        SetLastError( nStatus );
        if (bSemaphoreAcquired) {
            ReleaseSemaphore( g_hSingleInstanceSemaphoreWins, 1 , NULL );
        }
    } else {
        g_pSingleInstanceResourceWins = pResourceEntry; // bug #274612
    }// if: error occurred

    return resid;

} //*** WinsOpen()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsClose
//
//  Description:
//      Close routine for WINS Service resources.
//
//      Close the specified resource and deallocate all structures, etc.,
//      allocated in the Open call.  If the resource is not in the offline
//      state, then the resource should be taken offline (by calling
//      Terminate) before the close operation is performed.
//
//  Arguments:
//      resid       [IN] Supplies the resource ID  of the resource to close.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI WinsClose( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Wins: Close request for a nonexistent resource id %p\n",
            resid
            );
        return;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n"
        );
#endif

    //
    // Close the Parameters key.
    //
    if ( pResourceEntry->hkeyParameters )
    {
        ClusterRegCloseKey( pResourceEntry->hkeyParameters );
    } // if: parameters key is open

    //
    // Clean up the semaphore if this is the single resource instance.
    //
    if ( pResourceEntry == g_pSingleInstanceResourceWins )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_INFORMATION,
            L"Close: Setting semaphore %1!ls!.\n",
            WINS_SINGLE_INSTANCE_SEMAPHORE
            );
        g_pSingleInstanceResourceWins = NULL;
        ReleaseSemaphore( g_hSingleInstanceSemaphoreWins, 1 , NULL );
    } // if: this is the single resource instance

    //
    // Deallocate the resource entry.
    //

    // ADDPARAM: Add new propertiess here.
    LocalFree( pResourceEntry->props.pszDatabasePath );
    LocalFree( pResourceEntry->props.pszBackupPath );

    LocalFree( pResourceEntry->pszResourceName );
    LocalFree( pResourceEntry );

} //*** WinsClose()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOnline
//
//  Description:
//      Online routine for WINS Service resources.
//
//      Bring the specified resource online (available for use).  The resource
//      DLL should attempt to arbitrate for the resource if it is present on
//      a shared medium, like a shared SCSI bus.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be brought online
//          (available for use).
//
//      phEventHandle [IN OUT]
//          Returns a signalable handle that is signaled when the resource DLL
//          detects a failure on the resource.  This argument is NULL on
//          input, and the resource DLL returns NULL if asynchronous
//          notification of failurs is not supported.  Otherwise this must be
//          the address of a handle that is signaled on resource failures.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now online.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is pending.  A thread has been activated to process
//          the online request.  The thread that is processing the online
//          request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOnline state (or the resource monitor
//          decides to timeout the online request and Terminate the resource.
//          This pending timeout value is settable and has a default value of
//          3 minutes.).
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsOnline(
    IN      RESID       resid,
    IN OUT  PHANDLE     phEventHandle
    )
{
    PWINS_RESOURCE  pResourceEntry;
    DWORD           nStatus;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Wins: Online request for a nonexistent resource id %p.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n"
        );

    //
    // Start the Online thread to perform the online operation.
    //
    pResourceEntry->state = ClusterResourceOffline;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    nStatus = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( WinsOnlineThread ),
                pResourceEntry
                );
    if ( nStatus != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread. Error: %1!u!.\n",
            nStatus
            );
    } // if: error creating the worker thread
    else
    {
        nStatus = ERROR_IO_PENDING;
    } // if: worker thread created successfully

    return nStatus;

} //*** WinsOnline()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOnlineThread
//
//  Description:
//      Worker function which brings a resource online.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the WINS_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PWINS_RESOURCE  pResourceEntry
    )
{
    RESOURCE_STATUS         resourceStatus;
    DWORD                   nStatus = ERROR_SUCCESS;
    DWORD                   cbBytesNeeded;
    SERVICE_STATUS_PROCESS  ServiceStatus = { 0 };
    RESOURCE_EXIT_STATE     resExitState;
    DWORD                   nRetryCount = 1200; // 10 min max

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    // Loop to avoid goto's.
    do
    {
        //
        // Create the new environment with the simulated net name when the
        // services queries GetComputerName.
        //
        if ( ! ClusWorkerCheckTerminate( pWorker ) )
        {
            nStatus = ResUtilSetResourceServiceEnvironment(
                            WINS_SVCNAME,
                            pResourceEntry->hResource,
                            g_pfnLogEvent,
                            pResourceEntry->hResourceHandle
                            );
            if ( nStatus != ERROR_SUCCESS )
            {
                break;
            } // if: error setting the environment for the service
        } // if: not terminating
        else
        {
            break;
        } // else: terminating

        //
        // Make sure the service is ready to be controlled by the cluster.
        //
        if ( ! ClusWorkerCheckTerminate( pWorker ) )
        {
            nStatus = ResUtilSetResourceServiceStartParameters(
                            WINS_SVCNAME,
                            g_schSCMHandle,
                            &pResourceEntry->hService,
                            g_pfnLogEvent,
                            pResourceEntry->hResourceHandle
                            );
            if ( nStatus != ERROR_SUCCESS )
            {
                break;
            } // if:  error setting service start parameters
        } // if: not terminating
        else
        {
            break;
        } // else: terminating

        //
        // Perform resource-specific initialization before starting the service.
        //
        // TODO: Add code to initialize the resource before starting the service.

        //
        // Stop the service if it's running since we are about to change
        // its parameters.
        //
        nStatus = ResUtilStopResourceService( WINS_SVCNAME );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Failed to stop the '%1!ls!' service. Error %2!u!.\n",
                WINS_SVCNAME,
                nStatus
                );
            ClNetResLogSystemEvent1(
                LOG_CRITICAL,
                NETRES_RESOURCE_STOP_ERROR,
                nStatus,
                L"WINS" );
            break;
        } // if: error stopping the service

        //
        // Read our properties.
        //
        nStatus = WinsReadParametersToParameterBlock( pResourceEntry, TRUE /* bCheckForRequiredProperties */ );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error reading parameters

        //
        // Validate our properties.
        //
        nStatus = WinsValidateParameters( pResourceEntry, &pResourceEntry->props );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error validating parameters

        //
        // Write cluster properties to the system registry.
        //
        nStatus = WinsZapSystemRegistry( pResourceEntry, &pResourceEntry->props, NULL );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error zapping the WINS registry

        //
        // Start the service.
        //
        if ( ! StartServiceW(
                        pResourceEntry->hService,
                        0,
                        NULL
                        ) )
        {
            nStatus = GetLastError();
            if ( nStatus != ERROR_SERVICE_ALREADY_RUNNING )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"OnlineThread: Failed to start the '%1!ls!' service. Error: %2!u!.\n",
                    WINS_SVCNAME,
                    nStatus
                    );
                ClNetResLogSystemEvent1(
                    LOG_CRITICAL,
                    NETRES_RESOURCE_START_ERROR,
                    nStatus,
                    L"WINS" );
                break;
            } // if: error other than service already running occurred
            else
            {
                nStatus = ERROR_SUCCESS;
            } // if: service is already running
        } // if: error starting the service

        //
        // Query the status of the service in a loop until it leaves
        // the pending state.
        //
        while ( ! ClusWorkerCheckTerminate( pWorker ) && ( nRetryCount-- != 0 ) )
        {
            //
            // Query the service status.
            //
            if ( ! QueryServiceStatusEx(
                        pResourceEntry->hService,
                        SC_STATUS_PROCESS_INFO,
                        reinterpret_cast< LPBYTE >( &ServiceStatus ),
                        sizeof( SERVICE_STATUS_PROCESS ),
                        &cbBytesNeeded
                        ) )
            {
                nStatus = GetLastError();
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"OnlineThread: Failed to query service status for the '%1!ls!' service. Error: %2!u!.\n",
                    WINS_SVCNAME,
                    nStatus
                    );          
                resourceStatus.ResourceState = ClusterResourceFailed;
                break;
            } // if: error querying service status

            //
            // If the service is in any pending state continue waiting, otherwise we are done.
            //
            if (    ServiceStatus.dwCurrentState == SERVICE_START_PENDING
                ||  ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING
                ||  ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING
                ||  ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING )
            {
                resourceStatus.ResourceState = ClusterResourceOnlinePending;
            } // if: service state is pending
            else
            {
                break;
            } // else: service state is not pending

            resourceStatus.CheckPoint++;

            //
            // Notify the Resource Monitor of our current state.
            //
            resExitState = static_cast< RESOURCE_EXIT_STATE >(
                (g_pfnSetResourceStatus)(
                                pResourceEntry->hResourceHandle,
                                &resourceStatus
                                ) );
            if ( resExitState == ResourceExitStateTerminate )
            {
                break;
            } // if: resource is being terminated

            //
            // Check again in 1/2 second.
            //
            Sleep( 500 );

        } // while: not terminating while querying the status of the service

        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error querying the status of the service

        //
        // Assume that we failed.
        //
        resourceStatus.ResourceState = ClusterResourceFailed;

        //
        // If we exited the loop before setting ServiceStatus, then return now.
        //
        if ( ClusWorkerCheckTerminate( pWorker ) || ( nRetryCount == (DWORD) -1 ) )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"WinsOnlineThread: Asked to terminate or retry period expired....\n"
                );
            break;
        } // if: being terminated

        if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING )
        {
            if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                nStatus = ServiceStatus.dwServiceSpecificExitCode;
            } else {
                nStatus = ServiceStatus.dwWin32ExitCode;
            }

            ClNetResLogSystemEvent1(
                LOG_CRITICAL,
                NETRES_RESOURCE_START_ERROR,
                nStatus,
                L"WINS" );
            (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"OnlineThread: The '%1!ls!' service failed during initialization. Error: %2!u!.\n",
                    WINS_SVCNAME,
                    nStatus
                    );
            break;
        } // if: service not running when loop exited

        //
        // Set status to online and save process ID of the service.
        // This is used to enable us to terminate the resource more
        // effectively.
        //
        resourceStatus.ResourceState = ClusterResourceOnline;
        if ( ! (ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS) )
        {
            pResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
        } // if: not running in the system process

        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_INFORMATION,
            L"The '%1!ls!' service is now on line.\n",
            WINS_SVCNAME
            );

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Error %1!u! bringing resource online.\n",
            nStatus
            );
        if ( pResourceEntry->hService != NULL )
        {
            CloseServiceHandle( pResourceEntry->hService );
            pResourceEntry->hService = NULL;
        } // if: service handle was opened
    } // if: error occurred

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return nStatus;

} //*** WinsOnlineThread()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOffline
//
//  Description:
//      Offline routine for WINS Service resources.
//
//      Take the specified resource offline (unavailable for use).  Wait
//      for any cleanup operations to complete before returning.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          gracefully.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now offline.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is still pending.  A thread has been activated to
//          process the offline request.  The thread that is processing the
//          offline request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOffline state (or the resource monitor
//          decides  to timeout the offline request and Terminate the
//          resource).
//
//      Win32 error code
//          The operation failed.  This will cause the Resource Monitor to
//          log an event and call the Terminate routine.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsOffline( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;
    DWORD           nStatus;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Wins: Offline request for a nonexistent resource id %p\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n"
        );

    //
    // Start the Offline thread to perform the offline operation.
    //
    pResourceEntry->state = ClusterResourceOfflinePending;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    nStatus = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( WinsOfflineThread ),
                pResourceEntry
                );
    if ( nStatus != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread. Error: %1!u!.\n",
            nStatus
            );
    } // if: error creating the worker thread
    else
    {
        nStatus = ERROR_IO_PENDING;
    } // if: worker thread created successfully

    return nStatus;

} //*** WinsOffline()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsOfflineThread
//
//  Description:
//      Worker function which takes a resource offline.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the WINS_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PWINS_RESOURCE  pResourceEntry
    )
{
    RESOURCE_STATUS     resourceStatus;
    DWORD               nStatus = ERROR_SUCCESS;
    DWORD               nRetryTime = 300;   // 300 msec at a time
    DWORD               nRetryCount = 2000; // Try 10 min max
    BOOL                bDidStop = FALSE;
    SERVICE_STATUS      ServiceStatus;
    RESOURCE_EXIT_STATE resExitState;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    // Loop to avoid goto's.
    do
    {
        //
        // If the service has gone offline or was never brought online,
        // we're done.
        //
        if ( pResourceEntry->hService == NULL )
        {
            resourceStatus.ResourceState = ClusterResourceOffline;
            break;
        }

        //
        // Try to stop the service.  Wait for it to terminate as long
        // as we're not asked to terminate.
        //
        while ( ! ClusWorkerCheckTerminate( pWorker ) && ( nRetryCount-- != 0 ) )
        {
            //
            // Tell the Resource Monitor we are still working.
            //
            resourceStatus.ResourceState = ClusterResourceOfflinePending;
            resourceStatus.CheckPoint++;
            resExitState = static_cast< RESOURCE_EXIT_STATE >(
                g_pfnSetResourceStatus(
                                pResourceEntry->hResourceHandle,
                                &resourceStatus
                                ) );
            if ( resExitState == ResourceExitStateTerminate )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"OnlineThread: Asked to terminate by call to SetResourceStatus callback.\n"
                    );
                break;
            } // if: resource is being terminated

            resourceStatus.ResourceState = ClusterResourceFailed;

            //
            // Request that the service be stopped, or if we already did that,
            // request the current status of the service.
            //
            nStatus = (ControlService(
                            pResourceEntry->hService,
                            (bDidStop
                                ? SERVICE_CONTROL_INTERROGATE
                                : SERVICE_CONTROL_STOP),
                            &ServiceStatus
                            )
                        ? ERROR_SUCCESS
                        : GetLastError()
                        );

            if ( nStatus == ERROR_SUCCESS )
            {
                bDidStop = TRUE;

                if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_INFORMATION,
                        L"OfflineThread: The '%1!ls!' service stopped.\n",
                        WINS_SVCNAME
                        );

                    //
                    // Set the status.
                    //
                    resourceStatus.ResourceState = ClusterResourceOffline;
                    CloseServiceHandle( pResourceEntry->hService );
                    pResourceEntry->hService = NULL;
                    pResourceEntry->dwServicePid = 0;
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_INFORMATION,
                        L"OfflineThread: Service is now offline.\n"
                        );
                    break;
                } // if: current service state is STOPPED
            } // if: ControlService completed successfully

            else if (   ( nStatus == ERROR_EXCEPTION_IN_SERVICE )
                    ||  ( nStatus == ERROR_PROCESS_ABORTED )
                    ||  ( nStatus == ERROR_SERVICE_NOT_ACTIVE ) )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: The '%1!ls!' service died or is not active any more; status = %2!u!.\n",
                    WINS_SVCNAME,
                    nStatus
                    );

                //
                // Set the status.
                //
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( pResourceEntry->hService );
                pResourceEntry->hService = NULL;
                pResourceEntry->dwServicePid = 0;
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: Service is now offline.\n"
                    );
                break;
            } // else if: service stopped abnormally

            //
            // Handle the case in which SCM refuses to accept control
            // requests sine windows is shutting down.
            //
            if ( nStatus == ERROR_SHUTDOWN_IN_PROGRESS )
            {
                DWORD dwResourceState;

                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: System shutting down. Attempting to terminate service process %1!u!...\n",
                    pResourceEntry->dwServicePid
                    );

                nStatus = ResUtilTerminateServiceProcessFromResDll(
                            pResourceEntry->dwServicePid,
                            TRUE,   // bOffline
                            &dwResourceState,
                            g_pfnLogEvent,
                            pResourceEntry->hResourceHandle
                            );
                if ( nStatus == ERROR_SUCCESS )
                {
                    CloseServiceHandle( pResourceEntry->hService );
                    pResourceEntry->hService = NULL;
                    pResourceEntry->dwServicePid = 0;
                    pResourceEntry->state = ClusterResourceOffline;
                } // if: process terminated successfully
                resourceStatus.ResourceState = (CLUSTER_RESOURCE_STATE) dwResourceState;
                break;
            } // if: Windows is shutting down

            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: retrying...\n"
                );

            Sleep( nRetryTime );

        } // while: not asked to terminate
    } while ( 0 );

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return nStatus;

} //*** WinsOfflineThread()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsTerminate
//
//  Description:
//      Terminate routine for WINS Service resources.
//
//      Take the specified resource offline immediately (the resource is
//      unavailable for use).
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          ungracefully.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI WinsTerminate( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Wins: Terminate request for a nonexistent resource id %p\n",
            resid
            );
        return;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n"
        );

    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );

    if ( pResourceEntry->hService != NULL )
    {
        DWORD           nTotalRetryTime = 30*1000;  // Wait 30 secs for shutdown
        DWORD           nRetryTime = 300;           // 300 msec at a time
        DWORD           nStatus;
        BOOL            bDidStop = FALSE;
        SERVICE_STATUS  ServiceStatus;

        for (;;)
        {
            nStatus = (ControlService(
                            pResourceEntry->hService,
                            (bDidStop
                                ? SERVICE_CONTROL_INTERROGATE
                                : SERVICE_CONTROL_STOP),
                            &ServiceStatus
                            )
                        ? ERROR_SUCCESS
                        : GetLastError()
                        );

            if ( nStatus == ERROR_SUCCESS )
            {
                bDidStop = TRUE;

                if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_INFORMATION,
                        L"Terminate: The '%1!ls!' service stopped.\n",
                        WINS_SVCNAME
                        );
                    break;
                } // if: current service state is STOPPED
            } // if: ControlService completed successfully

            //
            // Since SCM doesn't accept any control requests during Windows
            // shutdown, don't send any more control requests.  Just exit
            // from this loop and terminate the process by brute force.
            //
            if ( nStatus == ERROR_SHUTDOWN_IN_PROGRESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"Terminate: System shutdown in progress. Will try to terminate process by brute force...\n"
                    );
                break;
            } // if: Windows is shutting down

            if (    ( nStatus == ERROR_EXCEPTION_IN_SERVICE )
                ||  ( nStatus == ERROR_PROCESS_ABORTED )
                ||  ( nStatus == ERROR_SERVICE_NOT_ACTIVE ) )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"Terminate: Service died; status = %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: service stopped abnormally

            if ( (nTotalRetryTime -= nRetryTime) <= 0 )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Terminate: Service did not stop; giving up.\n" );

                break;
            } // if: retried too many times

            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"Terminate: retrying...\n"
                );

            Sleep( nRetryTime );

        } // forever

        //
        // Declare the service offline.  It may not truly be offline, so
        // if there is a pid for this service, try and terminate that process.
        // Note that terminating a process doesnt terminate all the child
        // processes.
        //
        if ( pResourceEntry->dwServicePid != 0 )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"Terminate: Attempting to terminate process with pid=%1!u!...\n",
                pResourceEntry->dwServicePid
                );
            ResUtilTerminateServiceProcessFromResDll(
                pResourceEntry->dwServicePid,
                FALSE,  // bOffline
                NULL,   // pdwResourceState
                g_pfnLogEvent,
                pResourceEntry->hResourceHandle
                );
        } // if: service process ID available

        CloseServiceHandle( pResourceEntry->hService );
        pResourceEntry->hService = NULL;
        pResourceEntry->dwServicePid = 0;

    } // if: service was started

    pResourceEntry->state = ClusterResourceOffline;

} //*** WinsTerminate()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsLooksAlive
//
//  Description:
//      LooksAlive routine for WINS Service resources.
//
//      Perform a quick check to determine if the specified resource is
//      probably online (available for use).  This call should not block for
//      more than 300 ms, preferably less than 50 ms.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is probably online and available for use.
//
//      FALSE
//          The specified resource is not functioning normally.  The IsAlive
//          function will be called to perform a more thorough check.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI WinsLooksAlive( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Wins: LooksAlive request for a nonexistent resource id %p\n",
            resid
            );
        return FALSE;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! resid = %1!u!.\n",
            resid
            );
        return FALSE;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n"
        );
#endif

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    //
    // Check to see if the resource is alive.
    //
    return WinsCheckIsAlive( pResourceEntry, FALSE /* bFullCheck */ );

} //*** WinsLooksAlive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsIsAlive
//
//  Description:
//      IsAlive routine for WINS Service resources.
//
//      Perform a thorough check to determine if the specified resource is
//      online (available for use).  This call should not block for more
//      more than 300 ms, preferably less than 50 ms.  If it must block for
//      longer than this, create a separate thread dedicated to polling for
//      this information and have this routine return the status of the last
//      poll performed.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is online and functioning normally.
//
//      FALSE
//          The specified resource is not functioning normally.  The resource
//          will be terminated and then Online will be called.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI WinsIsAlive( IN RESID resid )
{
    PWINS_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Wins: IsAlive request for a nonexistent resource id %p\n",
            resid
            );
        return FALSE;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! resid = %1!u!.\n",
            resid
            );
        return FALSE;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n"
        );
#endif

    //
    // Check to see if the resource is alive.
    //
    return WinsCheckIsAlive( pResourceEntry, TRUE /* bFullCheck */ );

} //** WinsIsAlive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsCheckIsAlive
//
//  Description:
//      Check to see if the resource is alive for WINS Service
//      resources.
//
//  Arguments:
//      pResourceEntry  [IN]
//          Supplies the resource entry for the resource to polled.
//
//      bFullCheck [IN]
//          TRUE = Perform a full check.
//          FALSE = Perform a cursory check.
//
//  Return Value:
//      TRUE    The specified resource is online and functioning normally.
//      FALSE   The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WinsCheckIsAlive(
    IN PWINS_RESOURCE   pResourceEntry,
    IN BOOL             bFullCheck
    )
{
    BOOL    bIsAlive = TRUE;
    DWORD   nStatus;

    // Loop to avoid goto's.
    do
    {
        //
        // Check to see if the resource is alive.
        //
        nStatus = ResUtilVerifyService( pResourceEntry->hService );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"CheckIsAlive: Verification of the '%1!ls!' service failed. Error: %2!u!.\n",
                WINS_SVCNAME,
                nStatus
                );
            bIsAlive = FALSE;
            break;
        } // if: error verifying service

        if ( bFullCheck )
        {
            // TODO: Add code to perform a full check.
        } // if: performing a full check
    } while ( 0 );

    return bIsAlive;

} //*** WinsCheckIsAlive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsResourceControl
//
//  Description:
//      ResourceControl routine for WINS Service resources.
//
//      Perform the control request specified by nControlCode on the specified
//      resource.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID for the specific resource.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD           nStatus;
    PWINS_RESOURCE  pResourceEntry;
    DWORD           cbRequired = 0;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PWINS_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Wins: ResourceControl request for a nonexistent resource id %p\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    switch ( nControlCode )
    {
        case CLUSCTL_RESOURCE_UNKNOWN:
            *pcbBytesReturned = 0;
            nStatus = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            nStatus = ResUtilGetPropertyFormats(
                                        WinsResourcePrivateProperties,
                                        static_cast< LPWSTR >( pOutBuffer ),
                                        cbOutBufferSize,
                                        pcbBytesReturned,
                                        &cbRequired );
            if ( nStatus == ERROR_MORE_DATA ) {
                *pcbBytesReturned = cbRequired;
            }
            break;


        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            nStatus = ResUtilEnumProperties(
                            WinsResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( nStatus == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            nStatus = WinsGetPrivateResProperties(
                            pResourceEntry,
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            nStatus = WinsValidatePrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize,
                            NULL
                            );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            nStatus = WinsSetPrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize
                            );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            nStatus = WinsGetRequiredDependencies(
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_DELETE:
            nStatus = WinsDeleteResourceHandler( pResourceEntry );
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            nStatus = WinsSetNameHandler(
                            pResourceEntry,
                            static_cast< LPWSTR >( pInBuffer )
                            );
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
        case CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID:
        case CLUSCTL_RESOURCE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_EVICT_NODE:
        case CLUSCTL_RESOURCE_ADD_DEPENDENCY:
        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
        case CLUSCTL_RESOURCE_ADD_OWNER:
        case CLUSCTL_RESOURCE_REMOVE_OWNER:
        case CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED:
        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
        default:
            nStatus = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

    return nStatus;

} //*** WinsResourceControl()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsResourceTypeControl
//
//  Description:
//      ResourceTypeControl routine for WINS Service resources.
//
//      Perform the control request specified by nControlCode.
//
//  Arguments:
//      pszResourceTypeName [IN]
//          Supplies the name of the resource type.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WinsResourceTypeControl(
    IN  LPCWSTR pszResourceTypeName,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD   nStatus;
    DWORD   cbRequired = 0;

    switch ( nControlCode )
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *pcbBytesReturned = 0;
            nStatus = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            nStatus = ResUtilGetPropertyFormats(
                                WinsResourcePrivateProperties,
                                static_cast< LPWSTR >( pOutBuffer ),
                                cbOutBufferSize,
                                pcbBytesReturned,
                                &cbRequired );
            if ( nStatus == ERROR_MORE_DATA ) {
                *pcbBytesReturned = cbRequired;
            }
            break;


        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            nStatus = ResUtilEnumProperties(
                            WinsResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( nStatus == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            nStatus = WinsGetRequiredDependencies(
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS:
        case CLUSCTL_RESOURCE_TYPE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_TYPE_EVICT_NODE:
        default:
            nStatus = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

    return nStatus;

} //*** WinsResourceTypeControl()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsGetRequiredDependencies
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control
//      function for resources of type WINS Service.
//
//  Arguments:
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsGetRequiredDependencies(
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    // TODO: Specify your resource's required dependencies here.
    //   The default is that the resource requires a dependency on a
    //   storage class resource (e.g. Physical Disk) and an IP Address
    //   resource.
    struct DEP_DATA
    {
        CLUSPROP_RESOURCE_CLASS rcStorage;
        CLUSPROP_SZ_DECLARE( ipaddrEntry, sizeof( RESOURCE_TYPE_IP_ADDRESS ) / sizeof( WCHAR ) );
        CLUSPROP_SZ_DECLARE( netnameEntry, sizeof( RESOURCE_TYPE_NETWORK_NAME ) / sizeof( WCHAR ) );
        CLUSPROP_SYNTAX         endmark;
    };
    DEP_DATA *  pdepdata = static_cast< DEP_DATA * >( pOutBuffer );
    DWORD       nStatus;

    *pcbBytesReturned = sizeof( DEP_DATA );
    if ( cbOutBufferSize < sizeof( DEP_DATA ) )
    {
        if ( pOutBuffer == NULL )
        {
            nStatus = ERROR_SUCCESS;
        } // if: no buffer specified
        else
        {
            nStatus = ERROR_MORE_DATA;
        } // if: buffer specified
    } // if: output buffer is too small
    else
    {
        ZeroMemory( pdepdata, sizeof( DEP_DATA ) );

        //
        // Add the Storage class entry.
        //
        pdepdata->rcStorage.Syntax.dw = CLUSPROP_SYNTAX_RESCLASS;
        pdepdata->rcStorage.cbLength = sizeof( pdepdata->rcStorage.rc );
        pdepdata->rcStorage.rc = CLUS_RESCLASS_STORAGE;

        //
        // Add the IP Address name entry.
        //
        pdepdata->ipaddrEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->ipaddrEntry.cbLength = sizeof( RESOURCE_TYPE_IP_ADDRESS );
        lstrcpyW( pdepdata->ipaddrEntry.sz, RESOURCE_TYPE_IP_ADDRESS );

        //
        // Add the Network Name name entry.
        //
        pdepdata->netnameEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->netnameEntry.cbLength = sizeof( RESOURCE_TYPE_NETWORK_NAME );
        lstrcpyW( pdepdata->netnameEntry.sz, RESOURCE_TYPE_NETWORK_NAME );

        //
        // Add the endmark.
        //
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;

        nStatus = ERROR_SUCCESS;
    } // else: output buffer is large enough

    return nStatus;

} //*** WinsGetRequiredDependencies()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsReadParametersToParameterBlock
//
//  Description:
//      Reads all the parameters for a specied WINS resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      bCheckForRequiredProperties [IN]
//          Determines whether an error should be generated if a required
//          property hasn't been specified.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsReadParametersToParameterBlock(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      BOOL            bCheckForRequiredProperties
    )
{
    DWORD       nStatus;
    LPWSTR      pszNameOfPropInError;

    //
    // Read our parameters.
    //
    nStatus = ResUtilGetPropertiesToParameterBlock(
                    pResourceEntry->hkeyParameters,
                    WinsResourcePrivateProperties,
                    reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
                    bCheckForRequiredProperties,
                    &pszNameOfPropInError
                    );
    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1!ls!' property. Error: %2!u!.\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            nStatus
            );
    } // if: error getting properties

    return nStatus;

} //*** WinsReadParametersToParameterBlock


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsGetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control
//      function for resources of type WINS Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsGetPrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    OUT     PVOID           pOutBuffer,
    IN      DWORD           cbOutBufferSize,
    OUT     LPDWORD         pcbBytesReturned
    )
{
    DWORD   nStatus;
    DWORD   nRetStatus = ERROR_SUCCESS;
    DWORD   cbRequired = 0;
    DWORD   cbLocalOutBufferSize = cbOutBufferSize;

    do {
        //
        // Read our parameters.
        //
        nStatus = WinsReadParametersToParameterBlock(
                            pResourceEntry,
                            FALSE /* bCheckForRequiredProperties */
                            );
        if ( nStatus != ERROR_SUCCESS )
        {
            nRetStatus = nStatus;
            break;
        } // if: error reading parameters

        //
        // If the properties aren't set yet, retrieve the values from
        // the system registry.
        //
        nStatus = WinsGetDefaultPropertyValues( pResourceEntry, &pResourceEntry->props );
        if ( nStatus != ERROR_SUCCESS )
        {
            nRetStatus = nStatus;
            break;
        } // if: error getting default properties

        //
        // Construct a property list from the parameter block.
        //
        nStatus = ResUtilPropertyListFromParameterBlock(
                        WinsResourcePrivateProperties,
                        pOutBuffer,
                        &cbLocalOutBufferSize,
                        reinterpret_cast< const LPBYTE >( &pResourceEntry->props ),
                        pcbBytesReturned,
                        &cbRequired
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            nRetStatus = nStatus;
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error constructing property list from parameter block. Error: %1!u!.\n",
                nStatus
                );
            //
            // Don't exit the loop if buffer is too small.
            //
            if ( nStatus != ERROR_MORE_DATA )
            {
                break;
            } // if: buffer is too small
        } // if: error getting properties

        //
        // Add unknown properties.
        //
        nStatus = ResUtilAddUnknownProperties(
                        pResourceEntry->hkeyParameters,
                        WinsResourcePrivateProperties,
                        pOutBuffer,
                        cbOutBufferSize,
                        pcbBytesReturned,
                        &cbRequired
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            nRetStatus = nStatus;
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error adding unknown properties to the property list. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error adding unknown properties

    } while ( 0 );

    if ( nRetStatus == ERROR_MORE_DATA )
    {
        *pcbBytesReturned = cbRequired;
    } // if: output buffer is too small

    return nRetStatus;

} //*** WinsGetPrivateResProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsValidatePrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
//      function for resources of type WINS Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pProps [OUT]
//          Supplies the parameter block to fill in (optional).
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsValidatePrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      PVOID           pInBuffer,
    IN      DWORD           cbInBufferSize,
    OUT     PWINS_PROPS     pProps
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    WINS_PROPS  propsCurrent;
    WINS_PROPS  propsNew;
    PWINS_PROPS pLocalProps = NULL;
    LPWSTR      pszNameOfPropInError;
    BOOL        bRetrievedProps = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Check if there is input data.
        //
        if (    (pInBuffer == NULL)
            ||  (cbInBufferSize < sizeof( DWORD )) )
        {
            nStatus = ERROR_INVALID_DATA;
            break;
        } // if: no input buffer or input buffer not big enough to contain property list

        //
        // Retrieve the current set of private properties from the
        // cluster database.
        //
        ZeroMemory( &propsCurrent, sizeof( propsCurrent ) );

        nStatus = ResUtilGetPropertiesToParameterBlock(
                     pResourceEntry->hkeyParameters,
                     WinsResourcePrivateProperties,
                     reinterpret_cast< LPBYTE >( &propsCurrent ),
                     FALSE, /*CheckForRequiredProperties*/
                     &pszNameOfPropInError
                     );

        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to read the '%1!ls!' property. Error: %2!u!.\n",
                (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
                nStatus
                );
            break;
        } // if: error getting properties
        bRetrievedProps = TRUE;

        //
        // Duplicate the resource parameter block.
        //
        if ( pProps == NULL )
        {
            pLocalProps = &propsNew;
        } // if: no parameter block passed in
        else
        {
            pLocalProps = pProps;
        } // else: parameter block passed in
        ZeroMemory( pLocalProps, sizeof( WINS_PROPS ) );
        nStatus = ResUtilDupParameterBlock(
                        reinterpret_cast< LPBYTE >( pLocalProps ),
                        reinterpret_cast< LPBYTE >( &propsCurrent ),
                        WinsResourcePrivateProperties
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error duplicating the parameter block

        //
        // Parse and validate the properties.
        //
        nStatus = ResUtilVerifyPropertyTable(
                        WinsResourcePrivateProperties,
                        NULL,
                        TRUE, // AllowUnknownProperties
                        pInBuffer,
                        cbInBufferSize,
                        reinterpret_cast< LPBYTE >( pLocalProps )
                        );
        if ( nStatus == ERROR_SUCCESS )
        {
            //
            // Validate the property values.
            //
            nStatus = WinsValidateParameters( pResourceEntry, pLocalProps );
            if ( nStatus != ERROR_SUCCESS )
            {
                break;
            } // if: error validating parameters
        } // if: property list validated successfully
    } while ( 0 );

    //
    // Cleanup our parameter block.
    //
    if (    (pLocalProps == &propsNew)
        ||  (   (nStatus != ERROR_SUCCESS)
            &&  (pLocalProps != NULL)
            )
        )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( pLocalProps ),
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            WinsResourcePrivateProperties
            );
    } // if: we duplicated the parameter block

    if ( bRetrievedProps )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            NULL,
            WinsResourcePrivateProperties
            );
    } // if: properties were retrieved

    return nStatus;

} // WinsValidatePrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsValidateParameters
//
//  Description:
//      Validate the parameters of a WINS Service resource.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN]
//          Supplies the parameter block to validate.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_BAD_PATHNAME
//          Invalid path specified.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsValidateParameters(
    IN  PWINS_RESOURCE  pResourceEntry,
    IN  PWINS_PROPS     pProps
    )
{
    DWORD   nStatus;

    do {
        //
        // Verify that the service is installed.
        //
        nStatus = ResUtilVerifyResourceService( WINS_SVCNAME );
        if (    ( nStatus != ERROR_SUCCESS )
            &&  ( nStatus != ERROR_SERVICE_NOT_ACTIVE )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error verifying the '%1!ls!' service. Error: %2!u!.\n",
                WINS_SVCNAME,
                nStatus
                );
            break;
        } // if: error verifying service
        else
        {
            nStatus = ERROR_SUCCESS;
        } // else: service verified successfully

        //
        // Validate the DatabasePath.
        //
        if (    ( pProps->pszDatabasePath == NULL )
            ||  ( *pProps->pszDatabasePath == L'\0' )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Database path property must be specified: '%1!ls!'.\n",
                pProps->pszDatabasePath
                );
            nStatus = ERROR_INVALID_PARAMETER;
            break;
        } // if: no database path specified

        //
        // Path must not begin with %SystemRoot% and must be of valid form.
        //
        if (    ( _wcsnicmp( pProps->pszDatabasePath, L"%SystemRoot%", (sizeof( L"%SystemRoot%" ) / sizeof( WCHAR )) - 1 /*NULL*/) == 0 )
            ||  ! ResUtilIsPathValid( pProps->pszDatabasePath )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Database path property is invalid: '%1!ls!'.\n",
                pProps->pszDatabasePath
                );
            nStatus = ERROR_BAD_PATHNAME;
            break;
        } // if: database path is malformed

        //
        // Validate the BackupPath.
        //
        if (    ( pProps->pszBackupPath == NULL )
            ||  ( *pProps->pszBackupPath == L'\0' )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Backup database path must be specified: '%1!ls!'.\n",
                pProps->pszBackupPath
                );
            nStatus = ERROR_INVALID_PARAMETER;
            break;
        } // if: no backup path specified

        //
        // Path must not begin with %SystemRoot% and must be of valid form.
        //
        if (    ( _wcsnicmp( pProps->pszBackupPath, L"%SystemRoot%", (sizeof( L"%SystemRoot%" ) / sizeof( WCHAR )) - 1 /*NULL*/) == 0 )
            ||  ! ResUtilIsPathValid( pProps->pszBackupPath )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Backup database path property is invalid: '%1!ls!'.\n",
                pProps->pszBackupPath
                );
            nStatus = ERROR_BAD_PATHNAME;
            break;
        } // if: backup path is malformed

    } while ( 0 );

    return nStatus;

} //*** WinsValidateParameters()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsSetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control
//      function for resources of type WINS Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsSetPrivateResProperties(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      PVOID           pInBuffer,
    IN      DWORD           cbInBufferSize
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    LPWSTR      pszExpandedPath = NULL;
    WINS_PROPS  props;

    ZeroMemory( &props, sizeof( props ) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    nStatus = WinsValidatePrivateResProperties( pResourceEntry, pInBuffer, cbInBufferSize, &props );
    if ( nStatus != ERROR_SUCCESS )
    {
        return nStatus;
    } // if: error validating properties

    //
    // Expand any environment variables in the database path.
    //
    pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszDatabasePath );
    if ( pszExpandedPath == NULL )
    {
        nStatus = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Error expanding the database path '%1!ls!'. Error: %2!u!.\n",
            props.pszDatabasePath,
            nStatus
            );
        goto Cleanup;
    } // if: error expanding database path        

    //
    // Create the database directory.
    //
    nStatus = ResUtilCreateDirectoryTree( pszExpandedPath );
    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Error creating the database path directory '%1!ls!'. Error: %2!u!.\n",
            pszExpandedPath,
            nStatus
            );
        goto Cleanup;
    } // if: error creating the database directory

    LocalFree( pszExpandedPath );
    pszExpandedPath = NULL;

    //
    // Expand any environment variables in the backup database path.
    //
    pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszBackupPath );
    if ( pszExpandedPath == NULL ) 
    {
        nStatus = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Error expanding the backup database path '%1!ls!'. Error: %2!u!.\n",
            props.pszBackupPath,
            nStatus
            );
        goto Cleanup;
    } // if: error expanding backup database path

    //
    // Create the backup directory.
    //
    nStatus = ResUtilCreateDirectoryTree( pszExpandedPath );
    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Error creating the backup database path directory '%1!ls!'. Error: %2!u!.\n",
            pszExpandedPath,
            nStatus
            );
        goto Cleanup;
    } // if: error creating the backup database directory

    LocalFree( pszExpandedPath );
    pszExpandedPath = NULL;

    //
    // Set the entries in the system registry.
    //
    nStatus = WinsZapSystemRegistry( pResourceEntry, &props, NULL );
    if ( nStatus != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error zapping the registry

    //
    // Save the property values.
    //
    nStatus = ResUtilSetPropertyParameterBlockEx(
                    pResourceEntry->hkeyParameters,
                    WinsResourcePrivateProperties,
                    NULL,
                    reinterpret_cast< LPBYTE >( &props ),
                    pInBuffer,
                    cbInBufferSize,
                    TRUE, // bForceWrite
                    reinterpret_cast< LPBYTE >( &pResourceEntry->props )
                    );

    //
    // If the resource is online, return a non-success status.
    //
    // TODO: Modify the code below if your resource can handle
    // changes to properties while it is still online.
    if ( nStatus == ERROR_SUCCESS )
    {
        if ( pResourceEntry->state == ClusterResourceOnline )
        {
            nStatus = ERROR_RESOURCE_PROPERTIES_STORED;
        } // if: resource is currently online
        else if ( pResourceEntry->state == ClusterResourceOnlinePending )
        {
            nStatus = ERROR_RESOURCE_PROPERTIES_STORED;
        } // else if: resource is currently in online pending
        else
        {
            nStatus = ERROR_SUCCESS;
        } // else: resource is in some other state
    } // if: properties set successfully

Cleanup:
    LocalFree( pszExpandedPath );
    ResUtilFreeParameterBlock(
        reinterpret_cast< LPBYTE >( &props ),
        reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
        WinsResourcePrivateProperties
        );

    return nStatus;

} //*** WinsSetPrivateResProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsZapSystemRegistry
//
//  Description:
//      Zap the values in the system registry used by the service with
//      cluster properties.
//
//  Arguments:
//
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN]
//          Parameter block containing properties with which to zap the
//          registry.
//
//      hkeyParametersKey [IN]
//          Service Parameters key.  Can be specified as NULL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsZapSystemRegistry(
    IN  PWINS_RESOURCE  pResourceEntry,
    IN  PWINS_PROPS     pProps,
    IN  HKEY            hkeyParametersKey
    )
{
    DWORD   nStatus;
    DWORD   cbValue;
    DWORD   dwLen;
    LPWSTR  pszValue = NULL;
    HKEY    hkeyParamsKey = hkeyParametersKey;
    BOOL    fAddBackslash;

    do {
        if ( hkeyParametersKey == NULL )
        {
            //
            // Open the service Parameters key
            //
            nStatus = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            WINS_PARAMS_REGKEY,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkeyParamsKey
                            );
            if ( nStatus != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Unable to open the WINS Parameters key. Error %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error opening the registry key
        } // if: no registry key specified

        //
        // Add the database file name.
        //
        dwLen = lstrlenW( pProps->pszDatabasePath );
        if ( pProps->pszDatabasePath[ dwLen - 1 ] != L'\\' )
        {
            fAddBackslash = TRUE;

        } // if: missing backslash
        else
        {
            fAddBackslash = FALSE;

        } // else: not missing backslash

        cbValue = (DWORD)(( ( fAddBackslash ? dwLen + 1 : dwLen ) * sizeof( WCHAR ) ) + sizeof( WINS_DATABASE_FILE_NAME ));
        pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
        if ( pszValue == NULL )
        {
            nStatus = GetLastError();
            break;

        } // if: error allocating memory

        wsprintfW( pszValue, ( fAddBackslash ? L"%s\\%s" : L"%s%s" ), pProps->pszDatabasePath, WINS_DATABASE_FILE_NAME );

        //
        // Set the database path in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        WINS_DATABASEPATH_REGVALUE,
                        0,
                        REG_EXPAND_SZ,
                        reinterpret_cast< PBYTE >( pszValue ),
                        cbValue
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the WINS '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                WINS_DATABASEPATH_REGVALUE,
                pszValue,
                nStatus
                );
            break;
        } // if: error setting the database path in the registry

        // Truncate the path to remove the WINS_DATABASE_FILE_NAME
        {
            LPWSTR psz = wcsrchr( pszValue, L'\\' ) + 1;
            *psz = L'\0';
        } // end truncate

        //
        // Set the second database path in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        WINS_DATABASEPATH2_REGVALUE,
                        0,
                        REG_EXPAND_SZ,
                        reinterpret_cast< PBYTE >( pszValue ),
                        ( lstrlenW( pszValue ) + 1 ) * sizeof( *pszValue )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the WINS '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                WINS_DATABASEPATH2_REGVALUE,
                pszValue,
                nStatus
                );
            break;
        } // if: error setting the second database path in the registry

        LocalFree( pszValue );
        pszValue = NULL;

        //
        // Add a backslash if needed.
        //
        dwLen = lstrlenW( pProps->pszBackupPath );
        if ( pProps->pszBackupPath[ dwLen - 1 ] != L'\\' )
        {
            cbValue = ( dwLen + 1 * sizeof( WCHAR ) ) + sizeof( WINS_DATABASE_FILE_NAME );
            pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
            if ( pszValue == NULL )
            {
                nStatus = GetLastError();
                break;
            } // if: error allocating memory

            wcscpy( pszValue, pProps->pszBackupPath );
            wcscat( pszValue, L"\\" );

        } // if: missing backslash

        //
        // Set the backup database path in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        WINS_BACKUPPATH_REGVALUE,
                        0,
                        REG_EXPAND_SZ,
                        reinterpret_cast< PBYTE >( ( pszValue != NULL ? pszValue : pProps->pszBackupPath ) ),
                        ( lstrlenW( ( pszValue != NULL ? pszValue : pProps->pszBackupPath ) ) + 1 ) * sizeof( WCHAR )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the WINS '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                WINS_BACKUPPATH_REGVALUE,
                ( pszValue != NULL ? pszValue : pProps->pszBackupPath ),
                nStatus
                );
            break;
        } // if: error setting the backup database path in the registry

        LocalFree( pszValue );
        pszValue = NULL;

        //
        // Set the cluster resource name in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        WINS_CLUSRESNAME_REGVALUE,
                        0,
                        REG_SZ,
                        reinterpret_cast< PBYTE >( pResourceEntry->pszResourceName ),
                        (lstrlenW( pResourceEntry->pszResourceName ) + 1) * sizeof( WCHAR )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the WINS '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                WINS_CLUSRESNAME_REGVALUE,
                pResourceEntry->pszResourceName,
                nStatus
                );
            break;
        } // if: error setting the cluster resource name in the registry

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hkeyParamsKey != hkeyParametersKey )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the registry key

    if ( pszValue != NULL )
    {
        LocalFree( pszValue );
    } // if: allocated memory

    return nStatus;

} //*** WinsZapSystemRegistry()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsGetDefaultPropertyValues
//
//  Description:
//      If any of the properties are not set, use the values from the
//      system registry as default values.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN OUT]
//          Parameter block containing properties to set defaults in.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsGetDefaultPropertyValues(
    IN      PWINS_RESOURCE  pResourceEntry,
    IN OUT  PWINS_PROPS     pProps
    )
{
    DWORD   nStatus = ERROR_SUCCESS;
    DWORD   nType;
    DWORD   cbValue = 0;
    HKEY    hkeyParamsKey = NULL;
    LPWSTR  pszValue = NULL;
    LPWSTR  pszValue2 = NULL;
    WCHAR   szDrive[ _MAX_PATH ];
    WCHAR   szDir[ _MAX_PATH ];

    do
    {
        if (    ( pProps->pszDatabasePath == NULL )
            ||  ( *pProps->pszDatabasePath == L'\0' )
            ||  ( pProps->pszBackupPath == NULL )
            ||  ( *pProps->pszBackupPath == L'\0' )
            )
        {
            //
            // Open the service Parameters key
            //
            nStatus = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            WINS_PARAMS_REGKEY,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkeyParamsKey
                            );
            if ( nStatus != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Unable to open the WINS Parameters key. Error %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error opening the Parameters key

            ///////////////////
            // DATABASE PATH //
            ///////////////////
            if (    ( pProps->pszDatabasePath == NULL )
                ||  ( *pProps->pszDatabasePath == L'\0' )
                )
            {
                //
                // Get the database path from the system registry.
                //
                nStatus = RegQueryValueEx(
                                hkeyParamsKey,
                                WINS_DATABASEPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                NULL,               // lpbData
                                &cbValue
                                );
                if (    ( nStatus == ERROR_SUCCESS )
                    ||  ( nStatus == ERROR_MORE_DATA )
                    )
                {
                    //
                    // Value was found.
                    //
                    pszValue = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                    if ( pszValue == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating memory
                    nStatus = RegQueryValueEx(
                                    hkeyParamsKey,
                                    WINS_DATABASEPATH_REGVALUE,
                                    NULL,               // Reserved
                                    &nType,
                                    reinterpret_cast< PUCHAR >( pszValue ),
                                    &cbValue
                                    );
                } // if: value size read successfully
                else if ( nStatus == ERROR_FILE_NOT_FOUND )
                {
                    //
                    // Value was not found.  Use default value.
                    //
                    cbValue = sizeof( PROP_DEFAULT__DATABASEPATH );
                    pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                    if ( pszValue == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating memory
                    lstrcpyW( pszValue, PROP_DEFAULT__DATABASEPATH );
                    nStatus = ERROR_SUCCESS;
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"The WINS '%1!ls!' value from the system registry was not found. Using default value '%2!ls!'.\n",
                        WINS_DATABASEPATH_REGVALUE,
                        PROP_DEFAULT__DATABASEPATH
                        );
                } // else if: value not found
                if ( nStatus != ERROR_SUCCESS )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"Unable to get the WINS '%1!ls!' value from the system registry. Error %2!u!.\n",
                        WINS_DATABASEPATH_REGVALUE,
                        nStatus
                        );
                    LocalFree( pszValue );
                    pszValue = NULL;
                } // if: error reading the value
                else
                {
                    //
                    // Remove the file name from the database path.
                    //
                    _wsplitpath( pszValue, szDrive, szDir, NULL, NULL );
                    LocalFree( pszValue );
                    pszValue = NULL;
                    cbValue = (lstrlenW( szDrive ) + lstrlenW( szDir ) + 1 ) * sizeof( szDrive[ 0 ] );
                    pszValue2 = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                    if ( pszValue2 == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating memory
                    wsprintf( pszValue2, L"%s%s", szDrive, szDir );
                    LocalFree( pProps->pszDatabasePath );
                    pProps->pszDatabasePath = pszValue2;
                    pszValue2 = NULL;
                } // else: no error reading the value
            } // if: value for DatabasePath not found yet

            /////////////////
            // BACKUP PATH //
            /////////////////
            if (    ( pProps->pszBackupPath == NULL )
                ||  ( *pProps->pszBackupPath == L'\0' )
                )
            {
                //
                // Get the backup database path from the system registry.
                //
                nStatus = RegQueryValueEx(
                                hkeyParamsKey,
                                WINS_BACKUPPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                NULL,               // lpbData
                                &cbValue
                                );
                if (    ( nStatus == ERROR_SUCCESS )
                    ||  ( nStatus == ERROR_MORE_DATA )
                    )
                {
                    //
                    // Value was found.
                    //
                    pszValue = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                    if ( pszValue == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating memory
                    nStatus = RegQueryValueEx(
                                    hkeyParamsKey,
                                    WINS_BACKUPPATH_REGVALUE,
                                    NULL,               // Reserved
                                    &nType,
                                    reinterpret_cast< PUCHAR >( pszValue ),
                                    &cbValue
                                    );
                } // if: value size read successfully
                else if ( nStatus == ERROR_FILE_NOT_FOUND )
                {
                    //
                    // Value was not found.  Use default value.
                    //
                    cbValue = sizeof( PROP_DEFAULT__BACKUPPATH );
                    pszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                    if ( pszValue == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating memory
                    lstrcpyW( pszValue, PROP_DEFAULT__BACKUPPATH );
                    nStatus = ERROR_SUCCESS;
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"The WINS '%1!ls!' value from the system registry was not found. Using default value '%2!ls!'.\n",
                        WINS_BACKUPPATH_REGVALUE,
                        PROP_DEFAULT__BACKUPPATH
                        );
                } // else if: value not found
                if ( nStatus != ERROR_SUCCESS )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"Unable to get the WINS '%1!ls!' value from the system registry. Error %2!u!.\n",
                        WINS_BACKUPPATH_REGVALUE,
                        nStatus
                        );
                    break;
                } // if: error reading the value
                LocalFree( pProps->pszBackupPath );
                pProps->pszBackupPath = pszValue;
                pszValue = NULL;
            } // if: value for BackupPath not found yet
        } // if: some value not found yet
    } while ( 0 );

    LocalFree( pszValue );
    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the Parameters key

    //
    // If a key or value wasn't found, treat it as a success.
    //
    if ( nStatus == ERROR_FILE_NOT_FOUND )
    {
        nStatus = ERROR_SUCCESS;
    } // if: couldn't find one of the values

    return nStatus;

} //*** WinsGetDefaultPropertyValues()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsDeleteResourceHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_DELETE control code by restoring the
//      system registry parameters to their former values.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsDeleteResourceHandler( IN PWINS_RESOURCE pResourceEntry )
{
    DWORD   nStatus = ERROR_SUCCESS;
    HKEY    hkeyParamsKey = NULL;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the service Parameters key
        //
        nStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        WINS_PARAMS_REGKEY,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkeyParamsKey
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to open the WINS Parameters key. Error %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the registry key

        //
        // Delete the database path in the system registry.
        //
        nStatus = RegDeleteValue(
                        hkeyParamsKey,
                        WINS_DATABASEPATH_REGVALUE
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to delete the WINS '%1!ls!' value in the system registry. Error %2!u!.\n",
                WINS_DATABASEPATH_REGVALUE,
                nStatus
                );
            break;
        } // if: error deleting the database path in the registry

        //
        // Delete the second database path in the system registry.
        //
        nStatus = RegDeleteValue(
                        hkeyParamsKey,
                        WINS_DATABASEPATH2_REGVALUE
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to delete the WINS '%1!ls!' value in the system registry. Error %2!u!.\n",
                WINS_DATABASEPATH2_REGVALUE,
                nStatus
                );
            break;
        } // if: error deleting the second database path in the registry

        //
        // Delete the backup database path in the system registry.
        //
        nStatus = RegDeleteValue(
                        hkeyParamsKey,
                        WINS_BACKUPPATH_REGVALUE
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to delete the WINS '%1!ls!' value in the system registry. Error %2!u!.\n",
                WINS_BACKUPPATH_REGVALUE,
                nStatus
                );
            break;
        } // if: error deleting the backup database path in the registry

        //
        // Delete the cluster resource name in the system registry.
        //
        nStatus = RegDeleteValue(
                        hkeyParamsKey,
                        WINS_CLUSRESNAME_REGVALUE
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to delete the WINS '%1!ls!' value in the system registry. Error %2!u!.\n",
                WINS_CLUSRESNAME_REGVALUE,
                nStatus
                );
            break;
        } // if: error deleting the cluster resource name in the registry

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the registry key

    return nStatus;

} //*** WinsDeleteResourceHandler()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  WinsSetNameHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_SET_NAME control code by saving the new
//      name of the resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pszName [IN]
//          The new name of the resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WinsSetNameHandler(
    IN OUT  PWINS_RESOURCE  pResourceEntry,
    IN      LPWSTR          pszName
    )
{
    DWORD   nStatus = ERROR_SUCCESS;

    // Loop to avoid goto's.
    do
    {
        //
        // Save the name of the resource.
        //
        LocalFree( pResourceEntry->pszResourceName );
        pResourceEntry->pszResourceName = static_cast< LPWSTR >(
            LocalAlloc( LMEM_FIXED, (lstrlenW( pszName ) + 1) * sizeof( WCHAR ) )
            );
        if ( pResourceEntry->pszResourceName == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to allocate memory for the new resource name '%1!ls!'. Error %2!u!.\n",
                pszName,
                nStatus
                );
            break;
        } // if: error allocating memory for the name.
        lstrcpyW( pResourceEntry->pszResourceName, pszName );

        //
        // Write cluster properties to the system registry.
        //
        nStatus = WinsZapSystemRegistry( pResourceEntry, &pResourceEntry->props, NULL );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error zapping the WINS registry

    } while ( 0 );

    return nStatus;

} //*** WinsSetNameHandler()


/////////////////////////////////////////////////////////////////////////////
//
// Define Function Table
//
/////////////////////////////////////////////////////////////////////////////

CLRES_V1_FUNCTION_TABLE(
    g_WinsFunctionTable,    // Name
    CLRES_VERSION_V1_00,    // Version
    Wins,                   // Prefix
    NULL,                   // Arbitrate
    NULL,                   // Release
    WinsResourceControl,    // ResControl
    WinsResourceTypeControl // ResTypeControl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		BasePage.h
//
//	Implementation File:
//		BasePage.cpp
//		BasePage.inl
//
//	Description:
//		Definition of the CBasePropertyPage class.  This class provides base
//		functionality for extension DLL property pages.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEPAGE_H__
#define __BASEPAGE_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef __DLGHELP_H__
#include "DlgHelp.h"	// for CDialogHelp
#endif

#ifndef _EXTOBJ_H_
#include "ExtObj.h"		// for CExtObject
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE( CBasePropertyPage )

// Construction
public:
	CBasePropertyPage( void );
	CBasePropertyPage(
		IN const DWORD *	pdwHelpMap,
		IN const DWORD *	pdwWizardHelpMap
		);
	CBasePropertyPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN const DWORD *	pdwWizardHelpMap,
		IN UINT				nIDCaption = 0
		);
	virtual ~CBasePropertyPage( void )
	{
	} //*** ~CBasePropertyPage

	// Second phase construction.
	virtual HRESULT			HrInit( IN OUT CExtObject * peo );
	HRESULT					HrCreatePage( void );

protected:
	void					CommonConstruct( void );

// Attributes
protected:
	CExtObject *			m_peo;
	HPROPSHEETPAGE			m_hpage;

	IDD						m_iddPropertyPage;
	IDD						m_iddWizardPage;
	IDS						m_idsCaption;

	CExtObject *			Peo( void ) const				{ return m_peo; }

	IDD						IddPropertyPage( void ) const	{ return m_iddPropertyPage; }
	IDD						IddWizardPage( void ) const		{ return m_iddWizardPage; }
	IDS						IdsCaption( void ) const		{ return m_idsCaption; }

public:
	HPROPSHEETPAGE			Hpage( void ) const				{ return m_hpage; }
	CLUADMEX_OBJECT_TYPE	Cot( void ) const;

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;
	CString	m_strTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual DWORD			ScParseUnknownProperty(
								IN LPCWSTR							pwszName,
								IN const CLUSPROP_BUFFER_HELPER &	rvalue,
								IN DWORD							cbBuf
								)
	{
		return ERROR_SUCCESS;

	} //*** ScParseUnknownProperty()

	virtual BOOL			BApplyChanges( void );
	virtual BOOL			BBuildPropList( IN OUT CClusPropList & rcpl, IN BOOL bNoNewProps = FALSE );
	virtual void			DisplaySetPropsError( IN DWORD sc, IN UINT idsOper ) const;

	virtual const CObjectProperty *	Pprops( void ) const	{ return NULL; }
	virtual DWORD					Cprops( void ) const	{ return 0; }

// Implementation
protected:
	BOOL					m_bBackPressed;
	BOOL					m_bSaved;
	const DWORD *			m_pdwWizardHelpMap;
	BOOL					m_bDoDetach;

	BOOL					BBackPressed( void ) const		{ return m_bBackPressed; }
	BOOL					BSaved( void ) const			{ return m_bSaved; }
	IWCWizardCallback *		PiWizardCallback( void ) const;
	BOOL					BWizard( void ) const;
	HCLUSTER				Hcluster( void ) const;
	void					EnableNext( IN BOOL bEnable = TRUE );

	DWORD					ScParseProperties( IN CClusPropList & rcpl );
	BOOL					BSetPrivateProps(
								IN BOOL	bValidateOnly = FALSE,
								IN BOOL	bNoNewProps = FALSE
								);

	void					SetHelpMask( IN DWORD dwMask )	{ m_dlghelp.SetHelpMask( dwMask ); }
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	virtual afx_msg void OnContextMenu( CWnd * pWnd, CPoint point );
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList< CBasePropertyPage *, CBasePropertyPage * > CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\clnetresex.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ClNetResEx.h
//
//	Implementation File:
//		ClNetResEx.cpp
//
//	Description:
//		Global definitions across the DLL.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLNETRESEX_H__
#define __CLNETRESEX_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_DHCP_DATABASEPATH L"DatabasePath"
#define REGPARAM_DHCP_LOGFILEPATH L"LogFilePath"
#define REGPARAM_DHCP_BACKUPPATH L"BackupPath"

#define REGPARAM_WINS_DATABASEPATH L"DatabasePath"
#define REGPARAM_WINS_BACKUPPATH L"BackupPath"

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError( CString & rstrError, DWORD dwError );

// Defined in Extensn.cpp
extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // __CLNETRESEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Description:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEPAGE_INL__
#define __BASEPAGE_INL__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

inline IWCWizardCallback * CBasePropertyPage::PiWizardCallback( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->PiWizardCallback();

} //*** CBasePropertyPage::PiWizardCallback()

inline BOOL CBasePropertyPage::BWizard( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->BWizard();

} //*** CBasePropertyPage::BWizard()

inline HCLUSTER CBasePropertyPage::Hcluster( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->Hcluster();

} //*** CBasePropertyPage::Hcluster()

inline CLUADMEX_OBJECT_TYPE CBasePropertyPage::Cot( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->Cot();

} //*** CBasePropertyPage::Cot()

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEPAGE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\clnetresex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999-2000 Microsoft Corporation
//
//	Module Name:
//		ClNetResEx.cpp
//
//	Description:
//		Implementation of the CClNetResApp class and DLL initialization
//		routines.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "ClNetResEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning( disable : 4701 ) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning( default : 4701 )

BEGIN_OBJECT_MAP( ObjectMap )
	OBJECT_ENTRY( CLSID_CoClNetResEx, CExtObject )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow( void );
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID * ppv );
STDAPI DllRegisterServer( void );
STDAPI DllUnregisterServer( void );
STDAPI DllRegisterCluAdminExtension( IN HCLUSTER hcluster );
STDAPI DllUnregisterCluAdminExtension( IN HCLUSTER hcluster );

/////////////////////////////////////////////////////////////////////////////
// class CClNetResApp
/////////////////////////////////////////////////////////////////////////////

class CClNetResApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

}; //*** class CClNetResApp

/////////////////////////////////////////////////////////////////////////////
// The one and only CClNetResApp object

CClNetResApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClNetResApp::InitInstance
//
//	Description:
//		Initialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any return codes from CWinApp::InitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClNetResApp::InitInstance( void )
{
	// Construct the help path.
	{
		TCHAR szPath[_MAX_PATH];
		TCHAR szDrive[_MAX_PATH];
		TCHAR szDir[_MAX_DIR];
		int cchPath;
		VERIFY(::GetSystemWindowsDirectory(szPath, _MAX_PATH));
		cchPath = lstrlen(szPath);
		if (szPath[cchPath - 1] != _T('\\'))
		{
			szPath[cchPath++] = _T('\\');
			szPath[cchPath] = _T('\0');
		} // if: no backslash on the end of the path
		lstrcpy(&szPath[cchPath], _T("Help\\"));
		_tsplitpath(szPath, szDrive, szDir, NULL, NULL);
		_tmakepath(szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp"));
		free((void *) m_pszHelpFilePath);
		BOOL bEnable;
		bEnable = AfxEnableMemoryTracking(FALSE);
		m_pszHelpFilePath = _tcsdup(szPath);
		AfxEnableMemoryTracking(bEnable);
	}  // Construct the help path

	_Module.Init( ObjectMap, m_hInstance );
	return CWinApp::InitInstance();

}  //*** CClNetResApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClNetResApp::ExitInstance
//
//	Description:
//		Deinitialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any return codes from CWinApp::ExitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
int CClNetResApp::ExitInstance( void )
{
	_Module.Term();
	return CWinApp::ExitInstance();

}  //*** CClNetResApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	FormatError
//
//	Description:
//		Format an error.
//
//	Arguments:
//		rstrError	[OUT] String in which to return the error message.
//		dwError		[IN] Error code to format.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError( CString & rstrError, DWORD dwError )
{
	DWORD		_cch;
	TCHAR		_szError[ 512 ];

	_cch = ::FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					dwError,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					_szError,
					sizeof( _szError ) / sizeof( TCHAR ),
					0
					);
	if ( _cch == 0 )
	{
		// Format the NT status code from NTDLL since this hasn't been
		// integrated into the system yet.
		_cch = ::FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
						::GetModuleHandle( _T("NTDLL.DLL") ),
						dwError,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
						_szError,
						sizeof( _szError ) / sizeof( TCHAR ),
						0
						);
	}  // if:  error formatting status code from system

	if ( _cch != 0 )
	{
		rstrError = _szError;
	} // if:  error occurred
	else
	{

#ifdef _DEBUG

		DWORD _sc = GetLastError();

		TRACE( _T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError );

#endif

		rstrError.Format( _T("Error 0x%08.8x"), dwError );

	}  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );
	return ( AfxDllCanUnloadNow() && _Module.GetLockCount() == 0 ) ? S_OK : S_FALSE;

}  //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID * ppv )
{
	return _Module.GetClassObject( rclsid, riid, ppv );

}  //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer( void )
{
	HRESULT hRes = S_OK;
	// registers object, typelib and all interfaces in typelib
	hRes = _Module.RegisterServer( FALSE /*bRegTypeLib*/ );
	return hRes;

}  //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer( void )
{
	HRESULT hRes = S_OK;
	_Module.UnregisterServer();
	return hRes;

}  //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterCluAdminExtension
//
//	Description:
//		Register the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension( IN HCLUSTER hCluster )
{
	HRESULT		hr;
	HRESULT		hrReturn = S_OK;
	LPCWSTR		pwszResTypes = g_wszResourceTypeNames;

	while ( *pwszResTypes != L'\0' )
	{
		wprintf( L"  %s\n", pwszResTypes );
		hr = RegisterCluAdminResourceTypeExtension(
					hCluster,
					pwszResTypes,
					&CLSID_CoClNetResEx
					);
		if ( hr != S_OK )
		{
			hrReturn = hr;
		} // if:  error registering the extension
		pwszResTypes += lstrlenW( pwszResTypes ) + 1;
	}  // while:  more resource types

	return hrReturn;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllUnregisterCluAdminExtension
//
//	Description:
//		Unregister the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension( IN HCLUSTER hCluster )
{
	HRESULT		hr;
	HRESULT		hrReturn = S_OK;
	LPCWSTR		pwszResTypes = g_wszResourceTypeNames;

	while ( *pwszResTypes != L'\0' )
	{
		wprintf( L"  %s\n", pwszResTypes );
		hr = UnregisterCluAdminResourceTypeExtension(
					hCluster,
					pwszResTypes,
					&CLSID_CoClNetResEx
					);
		if ( hr != S_OK )
		{
			hrReturn = hr;
		} // if:  error unregistering the extension
		pwszResTypes += lstrlenW( pwszResTypes ) + 1;
	}  // while:  more resource types

	return hrReturn;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Description:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DDXDDV_H__
#define __DDXDDV_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

inline void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT LONG &			rnValue,
	IN LONG					nMin,
	IN LONG					nMax,
	IN BOOL					bSigned
	)
{
	DDX_Number(
		pDX,
		nIDC,
		reinterpret_cast< DWORD & >( rnValue ),
		static_cast< DWORD >( nMin ),
		static_cast< DWORD >( nMax ),
		bSigned
		);

} //*** DDXNumber( LONG )

void CleanupLabel( LPTSTR psz );

/////////////////////////////////////////////////////////////////////////////

#endif // __DDXDDV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\dhcp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Dhcp.cpp
//
//	Description:
//		Implementation of the DHCP Service resource extension property page classes.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClNetResEx.h"
#include "Dhcp.h"
#include "BasePage.inl"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CDhcpParamsPage, CBasePropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CDhcpParamsPage, CBasePropertyPage )
	//{{AFX_MSG_MAP(CDhcpParamsPage)
	ON_EN_CHANGE( IDC_PP_DHCP_DATABASEPATH, OnChangeRequiredField )
	ON_EN_CHANGE( IDC_PP_DHCP_LOGFILEPATH, OnChangeRequiredField )
	ON_EN_CHANGE( IDC_PP_DHCP_BACKUPPATH, OnChangeRequiredField )
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDhcpParamsPage::CDhcpParamsPage
//
//	Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDhcpParamsPage::CDhcpParamsPage( void )
	: CBasePropertyPage(
			CDhcpParamsPage::IDD,
			g_aHelpIDs_IDD_PP_DHCP_PARAMETERS,
			g_aHelpIDs_IDD_WIZ_DHCP_PARAMETERS
			)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CDhcpParamsPage)
	m_strDatabasePath = _T("");
	m_strLogFilePath = _T("");
	m_strBackupPath = _T("");
	//}}AFX_DATA_INIT

	// Setup the property array.
	{
		m_rgProps[ epropDatabasePath ].Set( REGPARAM_DHCP_DATABASEPATH, m_strDatabasePath, m_strPrevDatabasePath, m_strDatabaseExpandedPath );
		m_rgProps[ epropLogFilePath ].Set( REGPARAM_DHCP_LOGFILEPATH, m_strLogFilePath, m_strPrevLogFilePath, m_strLogFileExpandedPath );
		m_rgProps[ epropBackupPath ].Set( REGPARAM_DHCP_BACKUPPATH, m_strBackupPath, m_strPrevBackupPath, m_strBackupExpandedPath );
	} // Setup the property array

	m_iddPropertyPage = IDD_PP_DHCP_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_DHCP_PARAMETERS;

} //*** CDhcpParamsPage::CDhcpParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDhcpParamsPage::DoDataExchange
//
//	Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDhcpParamsPage::DoDataExchange( CDataExchange * pDX )
{
	if ( ! pDX->m_bSaveAndValidate || ! BSaved() )
	{
		AFX_MANAGE_STATE( AfxGetStaticModuleState() );

		// TODO: Modify the following lines to represent the data displayed on this page.
		//{{AFX_DATA_MAP(CDhcpParamsPage)
		DDX_Control( pDX, IDC_PP_DHCP_DATABASEPATH, m_editDatabasePath );
		DDX_Control( pDX, IDC_PP_DHCP_LOGFILEPATH, m_editLogFilePath );
		DDX_Control( pDX, IDC_PP_DHCP_BACKUPPATH, m_editBackupPath );
		DDX_Text( pDX, IDC_PP_DHCP_DATABASEPATH, m_strDatabasePath );
		DDX_Text( pDX, IDC_PP_DHCP_LOGFILEPATH, m_strLogFilePath );
		DDX_Text( pDX, IDC_PP_DHCP_BACKUPPATH, m_strBackupPath );
		//}}AFX_DATA_MAP

		// Handle numeric parameters.
		if ( ! BBackPressed() )
		{
		} // if: back button not pressed

		if ( pDX->m_bSaveAndValidate )
		{
			// Make sure all required fields are present.
			if ( ! BBackPressed() )
			{
				DDV_RequiredText( pDX, IDC_PP_DHCP_DATABASEPATH, IDC_PP_DHCP_DATABASEPATH_LABEL, m_strDatabasePath );
				DDV_RequiredText( pDX, IDC_PP_DHCP_LOGFILEPATH, IDC_PP_DHCP_LOGFILEPATH_LABEL, m_strLogFilePath );
				DDV_RequiredText( pDX, IDC_PP_DHCP_BACKUPPATH, IDC_PP_DHCP_BACKUPPATH_LABEL, m_strBackupPath );

			} // if: back button not pressed
		} // if: saving data from dialog
	} // if: not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange( pDX );

} //*** CDhcpParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDhcpParamsPage::OnInitDialog
//
//	Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDhcpParamsPage::OnInitDialog( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	CBasePropertyPage::OnInitDialog();

	// Limit the size of the text that can be entered in edit controls.
	m_editDatabasePath.SetLimitText( _MAX_PATH );
	m_editLogFilePath.SetLimitText( _MAX_PATH );
	m_editBackupPath.SetLimitText( _MAX_PATH );

	// If this is a wizard, make sure the default values are something legal.
	if ( BWizard( ) )
	{
		DWORD	 status;
		WCHAR	 szValidDevice[ 3 ]; // "X:" + NULL
		DWORD	 dwSize = sizeof(szValidDevice) / sizeof(szValidDevice[0]);

		szValidDevice[ 0 ] = L'\0';
		
		status = ResUtilFindDependentDiskResourceDriveLetter( Peo( )->Hcluster( ), 
															  Peo( )->PrdResData( )->m_hresource, 
															  szValidDevice, 
															  &dwSize 
															  );

		// Did we find a disk resource in the the dependency list?
		if ( status == ERROR_SUCCESS
		  && szValidDevice[ 0 ] != L'\0' )
		{
			WCHAR szFilePath[ MAX_PATH ];

			// If the default is "%SystemRoot%\<something>" then change it to match the
			// dependent resource
			if ( m_editDatabasePath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
			  && _wcsnicmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
			{
				// Start with the new drive letter
				wcscpy( szFilePath, szValidDevice );

				// Is the expanded string really expanded?
				if ( m_strDatabaseExpandedPath[0] != L'%'  )
				{	// yes, then just copy the expanded string minus the drive letter.
					LPCWSTR psz = m_strDatabaseExpandedPath;
					psz = wcschr( psz, L':' );
					if ( psz )
					{
						psz++;	// move to next character
					}
					else // if: psz
					{
						psz = m_strDatabaseExpandedPath;
					} // else: just cat the whole thing, let the user figure it out.
					wcscat( szFilePath, psz );
				}
				else
				{	// no, then strip the %SystemRoot%
					// find the ending '%'... this must be there because of the strcmp above!
					LPCWSTR psz = m_strDatabaseExpandedPath;
					psz = wcschr( psz + 1, L'%' );
					ASSERT( psz );
					psz++; // move past the '%'
					wcscat( szFilePath, psz );
				}

				m_editDatabasePath.SetWindowText( szFilePath );
			} // if: m_editDatabasePath == %SystemRoot%

			// If the default is "%SystemRoot%\<something>" then change it to match the
			// dependent resource
			if ( m_editLogFilePath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
			  && _wcsnicmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
			{
				// Start with the new drive letter
				wcscpy( szFilePath, szValidDevice );

				// Is the expanded string really expanded?
				if ( m_strLogFileExpandedPath[0] != L'%'  )
				{	// yes, then just copy the expanded string minus the drive letter.
					LPCWSTR psz = m_strLogFileExpandedPath;
					psz = wcschr( psz, L':' );
					if ( psz )
					{
						psz++;	// move to next character
					}
					else // if: psz
					{
						psz = m_strLogFileExpandedPath;
					} // else: just cat the whole thing, let the user figure it out.
					wcscat( szFilePath, psz );
				}
				else
				{	// no, then strip the %SystemRoot%
					// find the ending '%'... this must be there because of the strcmp above!
					LPCWSTR psz = m_strLogFileExpandedPath;
					psz = wcschr( psz + 1, L'%' );
					ASSERT( psz );
					psz++; // move past the '%'
					wcscat( szFilePath, psz );
				}

				m_editLogFilePath.SetWindowText( szFilePath );
			} // if: m_editLogFilePath == %SystemRoot%
			else if ( szFilePath[0] == L'\0' )
			{ // no path found - default to the same as the database path
				m_editDatabasePath.GetWindowText( szFilePath, MAX_PATH );
				m_editLogFilePath.SetWindowText( szFilePath );
			} // else: no log path found

			// If the default is "%SystemRoot%\<something>" then change it to match the
			// dependent resource
			if ( m_editBackupPath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
			  && _wcsnicmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
			{
				// Start with the new drive letter
				wcscpy( szFilePath, szValidDevice );

				// Is the expanded string really expanded?
				if ( m_strBackupExpandedPath[0] != L'%'  )
				{	// yes, then just copy the expanded string minus the drive letter.
					LPCWSTR psz = m_strBackupExpandedPath;
					psz = wcschr( psz, L':' );
					if ( psz )
					{
						psz++;	// move to next character
					}
					else // if: psz
					{
						psz = m_strBackupExpandedPath;
					} // else: just cat the whole thing, let the user figure it out.
					wcscat( szFilePath, psz );
				}
				else
				{	// no, then strip the %SystemRoot%
					// find the ending '%'... this must be there because of the strcmp above!
					LPCWSTR psz = m_strBackupExpandedPath;
					psz = wcschr( psz + 1, L'%' );
					ASSERT( psz );
					psz++; // move past the '%'
					wcscat( szFilePath, psz );
				}

				m_editBackupPath.SetWindowText( szFilePath );
			} // if: m_editBackupPath == %SystemRoot%

		} // if: found a disk resource

	} // if: in a wizard

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

} //*** CDhcpParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDhcpParamsPage::OnSetActive
//
//	Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDhcpParamsPage::OnSetActive( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// Enable/disable the Next/Finish button.
	if ( BWizard() )
	{
		EnableNext( BAllRequiredFieldsPresent() );
	} // if: displaying a wizard

	return CBasePropertyPage::OnSetActive();

} //*** CDhcpParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDhcpParamsPage::OnChangeRequiredField
//
//	Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDhcpParamsPage::OnChangeRequiredField( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	OnChangeCtrl();

	if ( BWizard() )
	{
		EnableNext( BAllRequiredFieldsPresent() );
	} // if: displaying a wizard

} //*** CDhcpParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDhcpParamsPage::BAllRequiredFieldsPresent
//
//	Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDhcpParamsPage::BAllRequiredFieldsPresent( void ) const
{
	BOOL	_bPresent;

	if ( 0
		|| (m_editDatabasePath.GetWindowTextLength() == 0)
		|| (m_editLogFilePath.GetWindowTextLength() == 0)
		|| (m_editBackupPath.GetWindowTextLength() == 0)
		)
	{
		_bPresent = FALSE;
	} // if: required field not present
	else
	{
		_bPresent = TRUE;
	} // else: all required fields are present

	return _bPresent;

} //*** CDhcpParamsPage::BAllRequiredFieldsPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\dhcp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Dhcp.h
//
//	Implementation File:
//		Dhcp.cpp
//
//	Description:
//		Definition of the DHCP Service resource extension property page classes.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DHCP_H__
#define __DHCP_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDhcpParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CDhcpParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CDhcpParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE( CDhcpParamsPage )

// Construction
public:
	CDhcpParamsPage( void );

// Dialog Data
	//{{AFX_DATA(CDhcpParamsPage)
	enum { IDD = IDD_PP_DHCP_PARAMETERS };
	CEdit	m_editDatabasePath;
	CEdit	m_editLogFilePath;
	CEdit	m_editBackupPath;
	CString	m_strDatabasePath;
	CString	m_strLogFilePath;
	CString	m_strBackupPath;
	//}}AFX_DATA
	CString	m_strPrevDatabasePath;
	CString	m_strPrevLogFilePath;
	CString	m_strPrevBackupPath;
	CString m_strDatabaseExpandedPath;
	CString m_strLogFileExpandedPath;
	CString m_strBackupExpandedPath;

protected:
	enum
	{
		epropDatabasePath,
		epropLogFilePath,
		epropBackupPath,
		epropMAX
	};
	CObjectProperty		m_rgProps[ epropMAX ];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDhcpParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops( void ) const	{ return m_rgProps; }
	virtual DWORD					Cprops( void ) const	{ return sizeof( m_rgProps ) / sizeof( CObjectProperty ); }

// Implementation
protected:
	BOOL	BAllRequiredFieldsPresent( void ) const;

	// Generated message map functions
	//{{AFX_MSG(CDhcpParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CDhcpParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // __DHCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.cpp
//
//	Description:
//		Implementation of custom dialog data exchange/dialog data validation
//		routines.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//		The IDS_REQUIRED_FIELD_EMPTY string resource must be defined in
//		the resource file.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DDxDDv.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_Number
//
//	Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		dwValue		[IN OUT] Value to set or get.
//		dwMin		[IN] Minimum value.
//		dwMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned
	)
{
	HWND	hwndCtrl;
	DWORD	dwValue;

	ASSERT( pDX != NULL );
#ifdef _DEBUG
	if ( bSigned )
	{
		ASSERT( static_cast< LONG >( dwMin ) < static_cast< LONG >( dwMax ) );
	}
	else
	{
		ASSERT( dwMin < dwMax );
	}
#endif // _DEBUG

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// Get the control window handle.
	hwndCtrl = pDX->PrepareEditCtrl( nIDC );

	if ( pDX->m_bSaveAndValidate )
	{
		BOOL	bTranslated;

		// Get the number from the control.
		dwValue = GetDlgItemInt( pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned );

		// If the retrival failed, it is a signed number, and the minimum
		// value is the smallest negative value possible, check the string itself.
		if ( ! bTranslated && bSigned && (dwMin == 0x80000000) )
		{
			UINT	cch;
			TCHAR	szNumber[ 20 ];

			// See if it is the smallest negative number.
			cch = GetDlgItemText( pDX->m_pDlgWnd->m_hWnd, nIDC, szNumber, sizeof( szNumber ) / sizeof( TCHAR ) );
			if ( (cch != 0) && (lstrcmp( szNumber, _T("-2147483648") ) == 0) )
			{
				dwValue = 0x80000000;
				bTranslated = TRUE;
			} // if:  text retrieved successfully and is highest negative number
		} // if:  error translating number and getting signed number

		// If the retrieval failed or the specified number is
		// out of range, display an error.
		if (	! bTranslated
			||	(bSigned
				&& (	(static_cast< LONG >( dwValue ) < static_cast< LONG >( dwMin ))
					||	(static_cast< LONG >( dwValue ) > static_cast< LONG >( dwMax ))
					)
				)
			||	(!	bSigned
				&&	(	(dwValue < dwMin)
					||	(dwValue > dwMax)
					)
				)
			)
		{
			TCHAR szMin[ 32 ];
			TCHAR szMax[ 32 ];
			CString strPrompt;

			if ( bSigned )
			{
				wsprintf( szMin, _T("%d%"), dwMin );
				wsprintf( szMax, _T("%d%"), dwMax );
			} // if:  signed number
			else
			{
				wsprintf( szMin, _T("%u%"), dwMin );
				wsprintf( szMax, _T("%u%"), dwMax );
			} // else:  unsigned number
			AfxFormatString2( strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax );
			AfxMessageBox( strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE );
			strPrompt.Empty(); // exception prep
			pDX->Fail();
		} // if:  invalid string
		else
		{
			rdwValue = dwValue;
		} // if:  number is in range
	} // if:  saving data
	else
	{
		CString		strMinValue;
		CString		strMaxValue;
		UINT		cchMax;

		// Set the maximum number of characters that can be entered.
		if ( bSigned )
		{
			strMinValue.Format( _T("%d"), dwMin );
			strMaxValue.Format( _T("%d"), dwMax );
		} // if:  signed value
		else
		{
			strMinValue.Format( _T("%u"), dwMin );
			strMaxValue.Format( _T("%u"), dwMax );
		} // else:  unsigned value
		cchMax = max( strMinValue.GetLength(), strMaxValue.GetLength() );
		SendMessage( hwndCtrl, EM_LIMITTEXT, cchMax, 0 );

		// Set the value into the control.
		if ( bSigned )
		{
			LONG lValue = static_cast< LONG >( rdwValue );
			DDX_Text( pDX, nIDC, lValue );
		} // if:  signed value
		else
			DDX_Text( pDX, nIDC, rdwValue );
	} // else:  setting data onto the dialog

} //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_RequiredText
//
//	Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Value to set or get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	)
{
	ASSERT( pDX != NULL );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	if ( pDX->m_bSaveAndValidate )
	{
		if ( rstrValue.GetLength() == 0 )
		{
			HWND		hwndLabel;
			TCHAR		szLabel[ 1024 ];
			CString		strPrompt;

			// Get the label window handle
			hwndLabel = pDX->PrepareEditCtrl( nIDCLabel );

			// Get the text of the label.
			GetWindowText( hwndLabel, szLabel, sizeof( szLabel ) / sizeof( TCHAR ) );

			// Remove ampersands (&) and colons (:).
			CleanupLabel( szLabel );

			// Format and display a message.
			strPrompt.FormatMessage( IDS_REQUIRED_FIELD_EMPTY, szLabel );
			AfxMessageBox( strPrompt, MB_ICONEXCLAMATION );

			// Do this so that the control receives focus.
			(void) pDX->PrepareEditCtrl( nIDC );

			// Fail the call.
			strPrompt.Empty();	// exception prep
			pDX->Fail();
		} // if:  field not specified
	} // if:  saving data

} //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupLabel
//
//	Description:
//		Prepare a label read from a dialog to be used as a string in a
//		message by removing ampersands (&) and colons (:).
//
//	Arguments:
//		pszLabel	[IN OUT] Label to be cleaned up.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel( LPTSTR pszLabel )
{
	LPTSTR	pIn, pOut;
	LANGID	langid;
	WORD	primarylangid;
	BOOL	bFELanguage;

	// Get the language ID.
	langid = GetUserDefaultLangID();
	primarylangid = static_cast< WORD >( PRIMARYLANGID( langid ) );
	bFELanguage = ((primarylangid == LANG_JAPANESE)
				|| (primarylangid == LANG_CHINESE)
				|| (primarylangid == LANG_KOREAN) );

	//
	// Copy the name sans '&' and ':' chars
	//

	pIn = pOut = pszLabel;
	do
	{
		//
		// Strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
		//
		if (	bFELanguage
			&&	(pIn[ 0 ] == _T('('))
			&&	(pIn[ 1 ] == _T('&'))
			&&	(pIn[ 2 ] != _T('\0'))
			&&	(pIn[ 3 ] == _T(')')) )
		{
			pIn += 3;
		} // if:  Far East language with accelerator
		else if ( (*pIn != _T('&')) && (*pIn != _T(':')) )
		{
			*pOut++ = *pIn;
		} // else if:  accelerator found
	} while ( *pIn++ != _T('\0') );

} //*** CleanupLabel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\dlghelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.h
//
//	Abstract:
//		Definition of the CDialogHelp class.
//
//	Implementation File:
//		DlgHelp.cpp
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DLGHELP_H__
#define __DLGHELP_H__

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
	DWORD	m_nCtrlID;
	DWORD	m_nHelpCtrlID;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp dialog
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp : public CObject
{
	DECLARE_DYNAMIC( CDialogHelp )

// Construction
public:
	CDialogHelp( void ) { CommonConstruct(); }
	CDialogHelp( const DWORD * pdwHelpMap, DWORD dwMask );

	void CommonConstruct(void);

// Attributes
protected:
	const CMapCtrlToHelpID *	m_pmap;
	DWORD						m_dwMask;
	DWORD						m_nHelpID;

public:
	const CMapCtrlToHelpID *	Pmap( void ) const		{ return m_pmap; }
	DWORD						DwMask( void ) const	{ return m_dwMask; }
	DWORD						NHelpID( void ) const	{ return m_nHelpID; }

	DWORD						NHelpFromCtrlID( IN DWORD nCtrlID ) const;
	void						SetMap( IN const DWORD * pdwHelpMap )
	{
		ASSERT( pdwHelpMap != NULL );
		m_pmap = (const CMapCtrlToHelpID *) pdwHelpMap;
	} //*** SetMap()

// Operations
public:
	void		SetHelpMask( IN DWORD dwMask )	{ ASSERT( dwMask != 0 ); m_dwMask = dwMask; }

	void		OnContextMenu( CWnd * pWnd, CPoint point );
	BOOL		OnHelpInfo( HELPINFO * pHelpInfo );
	LRESULT		OnCommandHelp( WPARAM wParam, LPARAM lParam );

// Overrides

// Implementation

};  //*** class CDialogHelp

/////////////////////////////////////////////////////////////////////////////

#endif // __DLGHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      ExtObj.cpp
//
//  Description:
//      Implementation of the CExtObject class, which implements the
//      extension interfaces required by a Microsoft Windows NT Cluster
//      Administrator Extension DLL.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClNetResEx.h"
#include "ExtObj.h"
#include "Dhcp.h"
#include "Wins.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
        L"DHCP Service\0"
        L"WINS Service\0"
        ;
const DWORD g_cchResourceTypeNames  = sizeof( g_wszResourceTypeNames ) / sizeof( WCHAR );

static CRuntimeClass * g_rgprtcDhcpResPSPages[] = {
    RUNTIME_CLASS( CDhcpParamsPage ),
    NULL
    };
static CRuntimeClass * g_rgprtcWinsResPSPages[] = {
    RUNTIME_CLASS( CWinsParamsPage ),
    NULL
    };
static CRuntimeClass ** g_rgpprtcResPSPages[]   = {
    g_rgprtcDhcpResPSPages,
    g_rgprtcWinsResPSPages,
    };
static CRuntimeClass ** g_rgpprtcResWizPages[]  = {
    g_rgprtcDhcpResPSPages,
    g_rgprtcWinsResPSPages,
    };

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CExtObject
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject( void )
{
    m_piData = NULL;
    m_piWizardCallback = NULL;
    m_bWizard = FALSE;
    m_istrResTypeName = 0;

    m_lcid = NULL;
    m_hfont = NULL;
    m_hicon = NULL;
    m_hcluster = NULL;
    m_cobj = 0;
    m_podObjData = NULL;

} //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::~CExtObject
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject( void )
{
    // Release the data interface.
    if ( PiData() != NULL )
    {
        PiData()->Release();
        m_piData = NULL;
    } // if:  we have a data interface pointer

    // Release the wizard callback interface.
    if ( PiWizardCallback() != NULL )
    {
        PiWizardCallback()->Release();
        m_piWizardCallback = NULL;
    } // if:  we have a wizard callback interface pointer

    // Delete the pages.
    {
        POSITION    pos;

        pos = Lpg().GetHeadPosition();
        while ( pos != NULL )
        {
            delete Lpg().GetNext(pos);
        } // while:  more pages in the list
    } // Delete the pages

    delete m_podObjData;

} //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//  Routine Description:
//      Indicates whether an interface suportes the IErrorInfo interface.
//      This interface is provided by ATL.
//
//  Arguments:
//      riid        Interface ID.
//
//  Return Value:
//      S_OK        Interface supports IErrorInfo.
//      S_FALSE     Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo( REFIID riid )
{
    static const IID * _rgiid[] =
    {
        &IID_IWEExtendPropertySheet,
        &IID_IWEExtendWizard,
    };
    int     _iiid;

    for ( _iiid = 0 ; _iiid < sizeof( _rgiid ) / sizeof( _rgiid[ 0 ] ) ; _iiid++ )
    {
        if ( InlineIsEqualGUID( *_rgiid[ _iiid ], riid ) )
        {
            return S_OK;
        } // if:  found a matching IID
    }
    return S_FALSE;

} //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//  Description:
//      Create property sheet pages and add them to the sheet.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object for which the sheet is being displayed.
//
//      piCallback [IN]
//          Pointer to an IWCPropertySheetCallback interface for adding pages
//          to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      _hr             Any error codes from HrGetUIInfo() or HrSaveData().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
    IN IUnknown *                   piData,
    IN IWCPropertySheetCallback *   piCallback
    )
{
    HRESULT             _hr     = NOERROR;
    CException          _exc( FALSE /*bAutoDelete*/ );
    CRuntimeClass **    _pprtc  = NULL;
    int                 _irtc;
    CBasePropertyPage * _ppage;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Validate the parameters.
    if ( (piData == NULL) || (piCallback == NULL) )
    {
        return E_INVALIDARG;
    } // if:  all interfaces not specified

    try
    {
        // Get info about displaying UI.
        _hr = HrGetUIInfo( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error getting UI info

        // Save the data.
        _hr = HrSaveData( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error saving data from host

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while ( pos != NULL )
            {
                delete Lpg().GetNext( pos );
            } // while:  more pages in the list
            Lpg().RemoveAll();
        } // Delete any previous pages

        // Create property pages.
        ASSERT( PodObjData() != NULL );
        switch ( PodObjData()->m_cot )
        {
            case CLUADMEX_OT_RESOURCE:
                _pprtc = g_rgpprtcResPSPages[ IstrResTypeName() ];
                break;

            default:
                _hr = E_NOTIMPL;
                throw &_exc;
                break;
        } // switch:  object type

        // Create each page.
        for ( _irtc = 0 ; _pprtc[ _irtc ] != NULL ; _irtc++ )
        {
            // Create the page.
            _ppage = static_cast< CBasePropertyPage * >( _pprtc[ _irtc ]->CreateObject() );
            ASSERT( _ppage->IsKindOf( _pprtc[ _irtc ] ) );

            // Add it to the list.
            Lpg().AddTail( _ppage );

            // Initialize the property page.
            _hr = _ppage->HrInit( this );
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error initializing the page

            // Create the page.
            _hr = _ppage->HrCreatePage();
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error creating the page

            // Add it to the property sheet.
            _hr = piCallback->AddPropertySheetPage( reinterpret_cast< LONG * >( _ppage->Hpage() ) );
            if ( _hr != NOERROR )
            {
                throw &_exc;
            } // if:  error adding the page to the sheet
        } // for:  each page in the list

    } // try
    catch ( CMemoryException * _pme )
    {
        TRACE( _T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n") );
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  anything
    catch ( CException * _pe )
    {
        TRACE( _T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n") );
        _pe->Delete();
        if ( _hr == NOERROR )
        {
            _hr = E_FAIL;
        } // if:  _hr hasn't beeen set yet
    } // catch:  anything

    if ( _hr != NOERROR )
    {
        piData->Release();
        m_piData = NULL;
    } // if:  error occurred

    piCallback->Release();
    return _hr;

} //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreateWizardPages (IWEExtendWizard)
//
//  Description:
//      Create property sheet pages and add them to the wizard.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object for which the wizard is being displayed.
//
//      piCallback [IN]
//          Pointer to an IWCPropertySheetCallback interface for adding pages
//          to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      _hr             Any error codes from HrGetUIInfo() or HrSaveData().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
    IN IUnknown *           piData,
    IN IWCWizardCallback *  piCallback
    )
{
    HRESULT             _hr     = NOERROR;
    CException          _exc( FALSE /*bAutoDelete*/ );
    CRuntimeClass **    _pprtc  = NULL;
    int                 _irtc;
    CBasePropertyPage * _ppage;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Validate the parameters.
    if ( (piData == NULL) || (piCallback == NULL) )
    {
        return E_INVALIDARG;
    } // if:  all interfaces not specified

    try
    {
        // Get info about displaying UI.
        _hr = HrGetUIInfo( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error getting UI info

        // Save the data.
        _hr = HrSaveData( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error saving data from host

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while ( pos != NULL )
            {
                delete Lpg().GetNext( pos );
            } // while:  more pages in the list
            Lpg().RemoveAll();
        } // Delete any previous pages

        m_piWizardCallback = piCallback;
        m_bWizard = TRUE;

        // Create property pages.
        ASSERT( PodObjData() != NULL );
        switch ( PodObjData()->m_cot )
        {
            case CLUADMEX_OT_RESOURCE:
                _pprtc = g_rgpprtcResWizPages[ IstrResTypeName() ];
                break;

            default:
                _hr = E_NOTIMPL;
                throw &_exc;
                break;
        } // switch:  object type

        // Create each page.
        for ( _irtc = 0 ; _pprtc[ _irtc ] != NULL ; _irtc++ )
        {
            // Create the page.
            _ppage = static_cast< CBasePropertyPage * >( _pprtc[ _irtc ]->CreateObject() );
            ASSERT( _ppage->IsKindOf( _pprtc[ _irtc ] ) );

            // Add it to the list.
            Lpg().AddTail( _ppage );

            // Initialize the property page.
            _hr = _ppage->HrInit( this );
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error initializing the page

            // Create the page.
            _hr = _ppage->HrCreatePage();
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error creating the page

            // Add it to the property sheet.
            _hr = piCallback->AddWizardPage( reinterpret_cast< LONG * >( _ppage->Hpage() ) );
            if ( _hr != NOERROR )
            {
                throw &_exc;
            } // if:  error adding the page to the sheet
        } // for:  each page in the list

    } // try
    catch ( CMemoryException * _pme )
    {
        TRACE( _T("CExtObject::CreateWizardPages() - Failed to add wizard page\n") );
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  anything
    catch ( CException * _pe )
    {
        TRACE( _T("CExtObject::CreateWizardPages() - Failed to add wizard page\n") );
        _pe->Delete();
        if ( _hr == NOERROR )
        {
            _hr = E_FAIL;
        } // if:  _hr hasn't beeen set yet
    } // catch:  anything

    if ( _hr != NOERROR )
    {
        piCallback->Release();
        if ( m_piWizardCallback == piCallback )
        {
            m_piWizardCallback = NULL;
        } // if: already saved interface pointer
        piData->Release();
        m_piData = NULL;
    } // if:  error occurred

    return _hr;

} //*** CExtObject::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetUIInfo
//
//  Description:
//      Get info about displaying UI.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo( IN IUnknown * piData )
{
    HRESULT     _hr = NOERROR;

    ASSERT( piData != NULL );

    // Save info about all types of objects.
    {
        IGetClusterUIInfo * _pi;

        _hr = piData->QueryInterface( IID_IGetClusterUIInfo, reinterpret_cast< LPVOID * >( &_pi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        m_lcid = _pi->GetLocale();
        m_hfont = _pi->GetFont();
        m_hicon = _pi->GetIcon();

        _pi->Release();
    } // Save info about all types of objects

    return _hr;

} //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrSaveData
//
//  Routine Description:
//      Save data from the object so that it can be used for the life
//      of the object.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData( IN IUnknown * piData )
{
    HRESULT     _hr = NOERROR;

    ASSERT( piData != NULL );

    if ( piData != m_piData )
    {
        if ( m_piData != NULL )
        {
            m_piData->Release();
        } // if:  interface queried for previously
        m_piData = piData;
    } // if:  different data interface pointer

    // Save info about all types of objects.
    {
        IGetClusterDataInfo *   _pi;

        _hr = piData->QueryInterface( IID_IGetClusterDataInfo, reinterpret_cast< LPVOID * >( &_pi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        m_hcluster = _pi->GetClusterHandle();
        m_cobj = _pi->GetObjectCount();
        if ( Cobj() != 1 )  // Only have support for one selected object.
        {
            _hr = E_NOTIMPL;
        } // if:  too many objects for us to handle

        _pi->Release();
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error occurred before here
    } // Save info about all types of objects

    // Save info about this object.
    _hr = HrGetObjectInfo();

    return _hr;

} //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectInfo
//
//  Description:
//      Get information about the object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
///         Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo( void )
{
    HRESULT                     _hr = NOERROR;
    IGetClusterObjectInfo *     _piGcoi;
    CLUADMEX_OBJECT_TYPE        _cot = CLUADMEX_OT_NONE;
    CException                  _exc( FALSE /*bAutoDelete*/ );
    const CString *             _pstrResTypeName = NULL;

    ASSERT( PiData() != NULL );

    // Get object info.
    {
        // Get an IGetClusterObjectInfo interface pointer.
        _hr = PiData()->QueryInterface( IID_IGetClusterObjectInfo, reinterpret_cast< LPVOID * >( &_piGcoi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        // Read the object data.
        try
        {
            // Delete the previous object data.
            delete m_podObjData;
            m_podObjData = NULL;

            // Get the type of the object.
            _cot = _piGcoi->GetObjectType( 0 );
            switch ( _cot )
            {
                case CLUADMEX_OT_RESOURCE:
                    {
                        IGetClusterResourceInfo *   _pi;

                        m_podObjData = new CResData;
                        if ( m_podObjData == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                            throw &_exc;
                        } // if: error allocating memory

                        // Get an IGetClusterResourceInfo interface pointer.
                        _hr = PiData()->QueryInterface( IID_IGetClusterResourceInfo, reinterpret_cast< LPVOID * >( &_pi ) );
                        if ( _hr != NOERROR )
                        {
                            throw &_exc;
                        } // if:  error querying for interface

                        PrdResDataRW()->m_hresource = _pi->GetResourceHandle( 0 );
                        ASSERT( PrdResDataRW()->m_hresource != NULL );
                        if ( PrdResDataRW()->m_hresource == NULL )
                        {
                            _hr = E_INVALIDARG;
                        } // if  invalid resource handle
                        else
                        {
                            _hr = HrGetResourceTypeName( _pi );
                        } // else:  resource handle is valid
                        _pi->Release();
                        if ( _hr != NOERROR )
                        {
                            throw &_exc;
                        } // if:  error occurred above

                        _pstrResTypeName = &PrdResDataRW()->m_strResTypeName;
                    } // if:  object is a resource
                    break;

                case CLUADMEX_OT_RESOURCETYPE:
                    m_podObjData = new CObjData;
                    if ( m_podObjData == NULL )
                    {
                        _hr = E_OUTOFMEMORY;
                        throw &_exc;
                    }
                    _pstrResTypeName = &PodObjDataRW()->m_strName;
                    break;

                default:
                    _hr = E_NOTIMPL;
                    throw &_exc;
            } // switch:  object type

            PodObjDataRW()->m_cot = _cot;
            _hr = HrGetObjectName( _piGcoi );
        } // try
        catch ( CException * _pe )
        {
            if ( !FAILED (_hr) )
            {
                _hr = E_FAIL;
            }
            _pe->Delete();
        } // catch:  CException

        _piGcoi->Release();

        // If we failed to initialize _pstrResTypeName, then bail.
        // We are doing this because of PREFIX, which assumes that the
        // new operator for OT_RESOURCETYPE above can fail - 
        // but it should never happen that the new should perform a throw.
        if ( _pstrResTypeName == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }

        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error occurred above
    } // Get object info

    // If this is a resource or resource type, see if we know about this type.
    if (    (   (_cot == CLUADMEX_OT_RESOURCE)
            ||  (_cot == CLUADMEX_OT_RESOURCETYPE) )
        && (_hr == NOERROR) )
    {
        LPCWSTR _pwszResTypeName;

        // Find the resource type name in our list.
        // Save the index for use in other arrays.
        for ( m_istrResTypeName = 0, _pwszResTypeName = g_wszResourceTypeNames
            ; *_pwszResTypeName != L'\0'
            ; m_istrResTypeName++, _pwszResTypeName += lstrlenW( _pwszResTypeName ) + 1
            )
        {
            if ( _pstrResTypeName->CompareNoCase( _pwszResTypeName ) == 0 )
            {
                break;
            } // if:  found resource type name
        } // for:  each resource type in the list
        if ( *_pwszResTypeName == L'\0' )
        {
            _hr = E_NOTIMPL;
        } // if:  resource type name not found
    } // See if we know about this resource type

    return _hr;

} //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectName
//
//  Description:
//      Get the name of the object.
//
//  Arguments:
//      piData [IN]
//          IGetClusterObjectInfo interface pointer for getting the object
//          name.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
//          Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IGetClusterObjectInfo::GetObjectInfo().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName( IN IGetClusterObjectInfo * pi )
{
    HRESULT     _hr         = NOERROR;
    WCHAR *     _pwszName   = NULL;
    LONG        _cchName;

    ASSERT( pi != NULL );

    _hr = pi->GetObjectName( 0, NULL, &_cchName );
    if ( _hr != NOERROR )
    {
        return _hr;
    } // if:  error getting object name

    try
    {
        _pwszName = new WCHAR[ _cchName ];
        _hr = pi->GetObjectName( 0, _pwszName, &_cchName );
        if ( _hr != NOERROR )
        {
            delete [] _pwszName;
            _pwszName = NULL;
        } // if:  error getting object name

        PodObjDataRW()->m_strName = _pwszName;
    } // try
    catch ( CMemoryException * _pme )
    {
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  CMemoryException

    delete [] _pwszName;
    return _hr;

} //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetResourceTypeName
//
//  Routine Description:
//      Get the name of the resource's type.
//
//  Arguments:
//      piData [IN]
//          IGetClusterResourceInfo interface pointer for getting the resource
//          type name.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
//          Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IGetClusterResourceInfo
//          ::GetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName( IN IGetClusterResourceInfo * pi )
{
    HRESULT     _hr         = NOERROR;
    WCHAR *     _pwszName   = NULL;
    LONG        _cchName;

    ASSERT( pi != NULL );

    _hr = pi->GetResourceTypeName( 0, NULL, &_cchName );
    if ( _hr != NOERROR )
    {
        return _hr;
    } // if:  error getting resource type name

    try
    {
        _pwszName = new WCHAR[ _cchName ];
        _hr = pi->GetResourceTypeName( 0, _pwszName, &_cchName );
        if ( _hr != NOERROR )
        {
            delete [] _pwszName;
            _pwszName = NULL;
        } // if:  error getting resource type name

        PrdResDataRW()->m_strResTypeName = _pwszName;
    } // try
    catch ( CMemoryException * _pme )
    {
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  CMemoryException

    delete [] _pwszName;
    return _hr;

} //*** CExtObject::HrGetResourceTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ExtObj.h
//
//	Implementation File:
//		ExtObj.cpp
//
//	Description:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __EXTOBJ_H__
#define __EXTOBJ_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoClNetResEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList< CBasePropertyPage *, CBasePropertyPage * > CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CNodeData
/////////////////////////////////////////////////////////////////////////////

class CNodeData : public CObjData
{
public:
	HNODE		m_hnode;

};  //*** class CNodeData

/////////////////////////////////////////////////////////////////////////////
// class CGroupData
/////////////////////////////////////////////////////////////////////////////

class CGroupData : public CObjData
{
public:
	HGROUP		m_hgroup;

};  //*** class CGroupData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CNetworkData
/////////////////////////////////////////////////////////////////////////////

class CNetworkData : public CObjData
{
public:
	HNETWORK	m_hnetwork;

};  //*** class CNetworkData

/////////////////////////////////////////////////////////////////////////////
// class CNetInterfaceData
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceData : public CObjData
{
public:
	HNETINTERFACE	m_hnetinterface;

};  //*** class CNetInterfaceData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass< CExtObject, &CLSID_CoClNetResEx >
{
public:
	CExtObject( void );
BEGIN_COM_MAP( CExtObject )
	COM_INTERFACE_ENTRY( IWEExtendPropertySheet )
	COM_INTERFACE_ENTRY( IWEExtendWizard )
	COM_INTERFACE_ENTRY( ISupportErrorInfo )
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE( CExtObject ) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY( CExtObject, _T("CLUADMEX.ClNetResEx"), _T("CLUADMEX.ClNetResEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT )

// ISupportsErrorInfo
	STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid );

// IWEExtendPropertySheet
public:
	STDMETHOD( CreatePropertySheetPages )(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD( CreateWizardPages )(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW( void ) const			{ return m_podObjData; }
	CResData *					PrdResDataRW( void ) const			{ return static_cast< CResData * >( m_podObjData ); }

public:
	IUnknown *					PiData( void ) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback( void ) const		{ return m_piWizardCallback; }
	BOOL						BWizard( void ) const				{ return m_bWizard; }
	DWORD						IstrResTypeName( void ) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid( void ) const					{ return m_lcid; }
	HFONT						Hfont( void ) const					{ return m_hfont; }
	HICON						Hicon( void ) const					{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster( void ) const				{ return m_hcluster; }
	LONG						Cobj( void ) const					{ return m_cobj; }

	const CObjData *			PodObjData( void ) const			{ return m_podObjData; }
	const CNodeData *			PndNodeData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_NODE ); return static_cast< CNodeData * >( m_podObjData ); }
	const CGroupData *			PgdGroupData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_GROUP ); return static_cast< CGroupData * >( m_podObjData ); }
	const CResData *			PrdResData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_RESOURCE ); return static_cast< CResData * >( m_podObjData ); }
	const CNetworkData *		PndNetworkData( void ) const		{ ASSERT( Cot() == CLUADMEX_OT_NETWORK ); return static_cast< CNetworkData * >( m_podObjData ); }
	const CNetInterfaceData *	PndNetInterfaceData( void ) const	{ ASSERT( Cot() == CLUADMEX_OT_NETINTERFACE ); return static_cast< CNetInterfaceData * >( m_podObjData ); }

	CLUADMEX_OBJECT_TYPE		Cot( void ) const					{ ASSERT( PodObjData() != NULL ); return PodObjData()->m_cot; }

	HRESULT						HrGetUIInfo( IN IUnknown * piData );
	HRESULT						HrSaveData( IN IUnknown * piData );
	HRESULT						HrGetObjectInfo( void );
	HRESULT						HrGetObjectName( IN IGetClusterObjectInfo * pi );
	HRESULT						HrGetResourceTypeName( IN IGetClusterResourceInfo * pi );

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg( void )							{ return m_lpg; }

}; //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // __EXTOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\dlghelp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.cpp
//
//	Abstract:
//		Implementation of the CDialogHelp class.
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC( CDialogHelp, CObject )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CDialogHelp
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pmap		[IN] Map array mapping control IDs to help IDs.
//		dwMask		[IN] Mask to use for the low word of the help ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDialogHelp::CDialogHelp( IN const DWORD * pdwHelpMap, IN DWORD dwMask )
{
	ASSERT( pdwHelpMap != NULL );

	CommonConstruct();
	SetMap( pdwHelpMap );
	m_dwMask = dwMask;

}  //*** CDialogHelp::CDialogHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CommonConstruct
//
//	Routine Description:
//		Do common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::CommonConstruct( void )
{
	m_pmap = NULL;
	m_dwMask = 0;
	m_nHelpID = 0;

}  //*** CDialogHelp::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::NHelpFromCtrlID
//
//	Routine Description:
//		Return the help ID from a control ID.
//
//	Arguments:
//		nCtrlID		[IN] ID of control to search for.
//
//	Return Value:
//		nHelpID		Help ID associated with the control.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDialogHelp::NHelpFromCtrlID( IN DWORD nCtrlID ) const
{
	DWORD						nHelpID = 0;
	const CMapCtrlToHelpID *	pmap = Pmap();

	ASSERT( pmap != NULL );
	ASSERT( nCtrlID != 0 );

	for ( ; pmap->m_nCtrlID != 0 ; pmap++ )
	{
		if ( pmap->m_nCtrlID == nCtrlID )
		{
			nHelpID = pmap->m_nHelpCtrlID;
			break;
		}  // if:  found a match
	}  // for:  each control

	TRACE( _T("NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x"), nCtrlID, nHelpID );

	return nHelpID;

}  //*** CDialogHelp::NHelpFromCtrlID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::OnContextMenu( CWnd * pWnd, CPoint point )
{
	CWnd *	pwndChild;
	CPoint	ptDialog;
	DWORD	nHelpID = 0;

	ASSERT( pWnd != NULL );

	m_nHelpID = 0;

	// Convert the point into dialog coordinates.
	ptDialog = point;
	pWnd->ScreenToClient( &ptDialog );

	// Find the control the cursor is over.
	{
		DWORD	nCtrlID;

		pwndChild = pWnd->ChildWindowFromPoint( ptDialog );
		if ( ( pwndChild != NULL ) && ( pwndChild->GetStyle() & WS_VISIBLE ) )
		{
			nCtrlID = pwndChild->GetDlgCtrlID();
			if ( nCtrlID != 0 )
			{
				nHelpID = NHelpFromCtrlID( nCtrlID );
			} // if: control ID found
		}  // if:  over a child window
	}  // Find the control the cursor is over

	// Display a popup menu.
	if ( ( nHelpID != 0 ) && ( nHelpID != -1 ) )
	{
		CString	strMenu;
		CMenu	menu;

		try
		{
			strMenu.LoadString( IDS_MENU_WHATS_THIS );
		}  // try
		catch ( CMemoryException * pme )
		{
			pme->Delete();
			return;
		}  // catch:  CMemoryException

		if ( menu.CreatePopupMenu() )
		{
			if ( menu.AppendMenu( MF_STRING | MF_ENABLED, ID_HELP, strMenu ) )
			{
				DWORD	nCmd;
				m_nHelpID = nHelpID;
				nCmd = menu.TrackPopupMenu(
					TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
					point.x,
					point.y,
					AfxGetMainWnd()
					);
				if ( nCmd != 0 )
				{
					AfxGetApp()->WinHelp( m_nHelpID, HELP_CONTEXTPOPUP );
				} // if: menu item selected
			}  // if:  menu item added successfully
			menu.DestroyMenu();
		}  // if:  popup menu created successfully
	}  // if:  over a child window of this dialog with a tabstop

}  //*** CDialogHelp::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDialogHelp::OnHelpInfo( HELPINFO * pHelpInfo )
{
	// If this is for a control, display control-specific help.
	if (	( pHelpInfo->iContextType == HELPINFO_WINDOW )
		&&	( pHelpInfo->iCtrlId != 0 ) )
	{
		DWORD	nHelpID = NHelpFromCtrlID( pHelpInfo->iCtrlId );
		if ( nHelpID != 0 )
		{
			if ( nHelpID != -1 )
			{
				AfxGetApp()->WinHelp( nHelpID, HELP_CONTEXTPOPUP );
			} // if: valid help ID found
			return TRUE;
		}  // if:  found the control in the list
	}  // if:  need help on a specific control

	// Display dialog help.
	return FALSE;

}  //*** CDialogHelp::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		WPARAM		[IN] Passed on to base class method.
//		lParam		[IN] Help ID.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CDialogHelp::OnCommandHelp( WPARAM wParam, LPARAM lParam )
{
	return TRUE;

}  //*** CDialogHelp::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __HELPDATA_H__
#define __HELPDATA_H__

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // __HELPDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\helparr.h ===
// Copyright (c) 1996-1999, Microsoft Corporation, all rights reserved.
//
// cnetharr.h is used by ClNetResEx.rc
// Cluster Admin DHCP and WINs Dialogs
// Help constants & DWORD arrays
//
// 04/29/99 Melissa Simmons
//
//

#define IDH_DISABLEHELP ((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_PP_DHCP_PARAMETERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_DHCP_DATABASEPATH_LABEL, IDH_PP_DHCP_DATABASEPATH,
	IDC_PP_DHCP_DATABASEPATH, IDH_PP_DHCP_DATABASEPATH,
	IDC_PP_DHCP_LOGFILEPATH_LABEL, IDH_PP_DHCP_LOGFILEPATH_CLNR,
	IDC_PP_DHCP_LOGFILEPATH, IDH_PP_DHCP_LOGFILEPATH_CLNR,
	IDC_PP_DHCP_BACKUPPATH_LABEL, IDH_PP_DHCP_BACKUPPATH,
	IDC_PP_DHCP_BACKUPPATH, IDH_PP_DHCP_BACKUPPATH, 
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_WINS_PARAMETERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_WINS_DATABASEPATH_LABEL, IDH_PP_WINS_DATABASEPATH,
	IDC_PP_WINS_DATABASEPATH,IDH_PP_WINS_DATABASEPATH,
	IDC_PP_WINS_BACKUPPATH_LABEL, IDH_PP_WINS_BACKUPPATH,
	IDC_PP_WINS_BACKUPPATH, IDH_PP_WINS_BACKUPPATH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_DHCP_PARAMETERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_DHCP_DATABASEPATH_LABEL, IDH_PP_DHCP_DATABASEPATH,
	IDC_PP_DHCP_DATABASEPATH, IDH_PP_DHCP_DATABASEPATH,
	IDC_PP_DHCP_LOGFILEPATH_LABEL, IDH_PP_DHCP_LOGFILEPATH_CLNR,
	IDC_PP_DHCP_LOGFILEPATH, IDH_PP_DHCP_LOGFILEPATH_CLNR,
	IDC_PP_DHCP_BACKUPPATH_LABEL,	IDH_PP_DHCP_BACKUPPATH,
	IDC_PP_DHCP_BACKUPPATH, IDH_PP_DHCP_BACKUPPATH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_WINS_PARAMETERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_WINS_DATABASEPATH_LABEL, IDH_PP_WINS_DATABASEPATH,
	IDC_PP_WINS_DATABASEPATH,IDH_PP_WINS_DATABASEPATH,
	IDC_PP_WINS_BACKUPPATH_LABEL, IDH_PP_WINS_BACKUPPATH,
	IDC_PP_WINS_BACKUPPATH, IDH_PP_WINS_BACKUPPATH,
	0, 0
};


#else

extern const DWORD g_aHelpIDs_IDD_PP_DHCP_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_DHCP_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_WINS_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_WINS_PARAMETERS[];


#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\helpids.h ===
#define	IDH_PP_DHCP_DATABASEPATH	700000075
#define	IDH_PP_DHCP_BACKUPPATH	700000076
#define IDH_PP_DHCP_LOGFILEPATH_CLNR	700005001
#define	IDH_PP_WINS_DATABASEPATH	700000300
#define	IDH_PP_WINS_BACKUPPATH	700000301
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\proplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		PropList.cpp
//
//	Description:
//		Implementation of the CClusPropList class.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.h"

#ifdef _DEBUG
#ifdef __AFX_H__
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // __AFX_H__
#endif

#ifndef __AFX_H__
class CMemoryException
{
public:
	void Delete( void ) { }

}; //*** class CMemoryException
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

const int BUFFER_GROWTH_FACTOR = 256;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CchMultiSz
//
//	Description:
//		Length of all of the substrings of a multisz string minus the final NULL.
//
//		(i.e., includes the nulls of the substrings, excludes the final null)
//		multiszlen( "abcd\0efgh\0\0" => 5 + 5 = 10
//
//	Arguments:
//		psz		[IN] The string to get the length of.
//
//	Return Value:
//		Count of characters in the multisz or 0 if empty.
//
//--
/////////////////////////////////////////////////////////////////////////////
static size_t CchMultiSz(
	IN LPCWSTR psz
	)
{
	ASSERT( psz != NULL );

	size_t	_cchTotal = 0;
	size_t	_cchChars;

	while ( *psz != _T( '\0' ) )
	{
		_cchChars = lstrlenW( psz ) + 1;

		_cchTotal += _cchChars;
		psz += _cchChars;
	} // while: pointer not stopped on EOS

	return _cchTotal;

} //*** CchMultiSz

/////////////////////////////////////////////////////////////////////////////
//++
//
//	NCompareMultiSz
//
//	Description:
//		Compare two MULTI_SZ buffers.
//
//	Arguments:
//		pszSource	[IN] The source string.
//		pszTarget	[IN] The target string.
//
//	Return Value:
//		If the string pointed to by pszSource is less than the string pointed
//		to by pszTarget, the return value is negative. If the string pointed
//		to by pszSource is greater than the string pointed to by pszTarget,
//		the return value is positive. If the strings are equal, the return value
//		is zero.
//
//--
/////////////////////////////////////////////////////////////////////////////
static int NCompareMultiSz(
	IN LPCWSTR pszSource,
	IN LPCWSTR pszTarget
	)
{
	ASSERT( pszSource != NULL );
	ASSERT( pszTarget != NULL );

	while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') )
	{
		//
		// Move to end of strings.
		//
		while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') && ( *pszSource == *pszTarget ) )
		{
			++pszSource;
			++pszTarget;
		} // while: pointer not stopped on EOS

		//
		// If strings are the same, skip past terminating NUL.
		// Otherwise exit the loop.
		if ( ( *pszSource == L'\0' ) && ( *pszTarget == L'\0') )
		{
			++pszSource;
			++pszTarget;
		} // if: both stopped on EOS
		else
		{
			break;
		} // else: stopped because something is not equal -- wr are done.

	} // while: pointer not stopped on EOS

	return *pszSource - *pszTarget;

} //*** NCompareMultiSz()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropValueList class
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CClusPropValueList, CObject );
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScMoveToFirstValue
//
//	Description:
//		Move the cursor to the first value in the value list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS	Position moved to the first value successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToFirstValue( void )
{
	ASSERT( m_cbhValueList.pb != NULL );

	DWORD	_sc;

	m_cbhCurrentValue = m_cbhValueList;
	m_cbDataLeft = m_cbDataSize;
	m_bAtEnd = FALSE;

	if ( m_cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
	{
		_sc = ERROR_NO_MORE_ITEMS;
	} // if: no items in the value list
	else
	{
		_sc = ERROR_SUCCESS;
	} // else: items exist in the value list

	return _sc;

} //*** CClusPropValueList::ScMoveToFirstValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScMoveToNextValue
//
//	Description:
//		Move the cursor to the next value in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the next value successfully.
//		ERROR_NO_MORE_ITEMS	Already at the end of the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToNextValue( void )
{
	ASSERT( m_cbhCurrentValue.pb != NULL );

	DWORD					_sc		= ERROR_NO_MORE_ITEMS;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;

	_cbhCurrentValue = m_cbhCurrentValue;

	do
	{
		//
		// Don't try to move if we're already at the end.
		//
		if ( m_bAtEnd )
		{
			break;
		} // if: already at the end of the list

		//
		// Make sure the buffer is big enough for the value header.
		//
		if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance buffer pointer.
		//
		_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
					+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

		//
		// Make sure the buffer is big enough for the value header,
		// the data itself, and the endmark.
		//
		if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Move past the current value to the next value's syntax.
		//
		_cbhCurrentValue.pb += _cbDataSize;

		//
		// This test will ensure that the value is always valid since we won't
		// advance if the next thing is the endmark.
		//
		if ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
		{
			m_cbhCurrentValue = _cbhCurrentValue;
			m_cbDataLeft -= _cbDataSize;
			_sc = ERROR_SUCCESS;
		} // if: next value's syntax is not the endmark
		else
		{
			m_bAtEnd = TRUE;
		} // else: next value's syntax is the endmark
	} while ( 0 );

	return _sc;

} //*** CClusPropValueList::ScMoveToNextValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScCheckIfAtLastValue
//
//	Description:
//		Indicate whether we are on the last value in the list or not.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Not currently at the last value in the list.
//		ERROR_NO_MORE_ITEMS	Currently at the last value in the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScCheckIfAtLastValue( void )
{
	ASSERT( m_cbhCurrentValue.pb != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;
	DWORD					_cbDataSize;

	_cbhCurrentValue = m_cbhCurrentValue;

	do
	{
		//
		// Don't try to recalculate if we already know
		// we're at the end of the list.
		//
		if ( m_bAtEnd )
		{
			break;
		} // if: already at the end of the list

		//
		// Make sure the buffer is big enough for the value header.
		//
		if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance buffer pointer.
		//
		_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
					+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

		//
		// Make sure the buffer is big enough for the value header,
		// the data itself, and the endmark.
		//
		if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Move past the current value to the next value's syntax.
		//
		_cbhCurrentValue.pb += _cbDataSize;

		//
		// We are on the last value if the next thing after this value
		// is an endmark.
		//
		if ( _cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
		{
			_sc = ERROR_NO_MORE_ITEMS;
		} // if: next value's syntax is the endmark
	} while ( 0 );

	return _sc;

} //*** CClusPropValueList::ScCheckIfAtLastValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScAllocValueList
//
//	Description:
//		Allocate a value list buffer that's big enough to hold the next
//		value.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the value list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by new.  By default, no exceptions are thrown.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScAllocValueList( IN DWORD cbMinimum )
{
	ASSERT( cbMinimum > 0 );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbTotal = 0;

	//
	// Add the size of the item count and final endmark.
	//
	cbMinimum += sizeof( CLUSPROP_VALUE );
	_cbTotal = m_cbDataSize + cbMinimum;

	if ( m_cbBufferSize < _cbTotal )
	{
		PBYTE	_pbNewValuelist = NULL;

		cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
		_cbTotal = m_cbDataSize + cbMinimum;

		//
		// Allocate and zero a new buffer.
		//
		_pbNewValuelist = new BYTE[ _cbTotal ];
		if ( _pbNewValuelist != NULL )
		{
			ZeroMemory( _pbNewValuelist, _cbTotal );

			//
			// If there was a previous buffer, copy it and the delete it.
			//
			if ( m_cbhValueList.pb != NULL )
			{
				if ( m_cbDataSize != 0 )
				{
					CopyMemory( _pbNewValuelist, m_cbhValueList.pb, m_cbDataSize );
				} // if: data already exists in buffer

				delete [] m_cbhValueList.pb;
				m_cbhCurrentValue.pb = _pbNewValuelist + (m_cbhCurrentValue.pb - m_cbhValueList.pb);
			} // if: there was a previous buffer
			else
			{
				m_cbhCurrentValue.pb = _pbNewValuelist + sizeof( DWORD ); // move past prop count
			} // else: no previous buffer

			//
			// Save the new buffer.
			//
			m_cbhValueList.pb = _pbNewValuelist;
			m_cbBufferSize = _cbTotal;
		} // if: allocation succeeded
		else
		{
			_sc = ERROR_NOT_ENOUGH_MEMORY;
		} // else: allocation failed
	} // if: buffer isn't big enough

	return _sc;

} //*** CClusPropValueList::ScAllocValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScGetResourceValueList
//
//	Description:
//		Get value list of a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropValueList::ScAllocValueList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceValueList(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hResource != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cb = 512;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get values.
	//
	_sc = ScAllocValueList( _cb );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhValueList.pb,
						m_cbBufferSize,
						&_cb
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocValueList( _cb );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceControl(
								hResource,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhValueList.pb,
								m_cbBufferSize,
								&_cb
								);
			} // if: ScAllocValueList succeeded
		} // if: buffer too small
	} // if: ScAllocValueList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeleteValueList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cb;
		m_cbDataLeft = _cb;
	} // else: no errors

	return _sc;

} //*** CClusPropValueList::ScGetResourceValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScGetResourceTypeValueList
//
//	Description:
//		Get value list of a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropValueList::ScAllocValueList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceTypeValueList(
	IN HCLUSTER	hCluster,
	IN LPCWSTR	pwszResTypeName,
	IN DWORD	dwControlCode,
	IN HNODE	hHostNode,
	IN LPVOID	lpInBuffer,
	IN DWORD	cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( pwszResTypeName != NULL );
	ASSERT( *pwszResTypeName != L'\0' );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cb = 512;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get values.
	//
	_sc = ScAllocValueList( _cb );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhValueList.pb,
						m_cbBufferSize,
						&_cb
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocValueList( _cb );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceTypeControl(
								hCluster,
								pwszResTypeName,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhValueList.pb,
								m_cbBufferSize,
								&_cb
								);
			} // if: ScAllocValueList succeeded
		} // if: buffer too small
	} // if: ScAllocValueList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeleteValueList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cb;
		m_cbDataLeft = _cb;
	} // else: no errors

	return _sc;

} //*** CClusPropValueList::ScGetResourceTypeValueList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CClusPropList, CObject );
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScCopy
//
//	Description:
//		Copy a property list.  This function is equivalent to an assignment
//		operator.  Since this operation can fail, no assignment operator is
//		provided.
//
//	Arguments:
//		pcplPropList	[IN] The proplist to copy into this instance.
//		cbListSize		[IN] The total size of the prop list.
//
//	Return Value:
//		Win32 status code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScCopy(
	IN const PCLUSPROP_LIST	pcplPropList,
	IN DWORD				cbListSize
	)
{
	ASSERT( pcplPropList != NULL );

	DWORD	_sc = ERROR_SUCCESS;

	//
	// Clean up any vestiges of a previous prop list.
	//
	if ( m_cbhPropList.pb != NULL )
	{
		DeletePropList();
	} // if: the current list is not empty

	//
	// Allocate the new property list buffer.  If successful,
	// copy the source list.
	//
	m_cbhPropList.pb = new BYTE[ cbListSize ];
	if ( m_cbhPropList.pb != NULL )
	{
		CopyMemory( m_cbhPropList.pList, pcplPropList, cbListSize );
		m_cbBufferSize = cbListSize;
		m_cbDataSize   = cbListSize;
		m_cbDataLeft   = cbListSize;
		_sc = ScMoveToFirstProperty();
	} // if: new succeeded
	else
	{
		_sc = ERROR_NOT_ENOUGH_MEMORY;
	} // else:

	return _sc;

} //*** CClusPropList::ScCopy()

////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToFirstProperty
//
//	Description:
//		Move the cursor to the first propery in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the first property successfully.
//		ERROR_NO_MORE_ITEMS	There are no properties in the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToFirstProperty( void )
{
	ASSERT( m_cbhPropList.pb != NULL );
	ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

	DWORD					_sc;
	DWORD					_cbDataLeft;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;

	do
	{
		//
		// Make sure the buffer is big enough for the list header.
		//
		if ( m_cbDataSize < sizeof( m_cbhPropList.pList->nPropertyCount ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data

		//
		// Set the property counter to the number of properties in the list.
		//
		m_nPropsRemaining = m_cbhPropList.pList->nPropertyCount;

		//
		// Point the name pointer to the first name in the list.
		//
		m_cbhCurrentPropName.pName = &m_cbhPropList.pList->PropertyName;
		m_cbDataLeft = m_cbDataSize - sizeof( m_cbhPropList.pList->nPropertyCount );

		//
		// Check to see if there are any properties in the list.
		//
		if ( m_nPropsRemaining == 0 )
		{
			_sc = ERROR_NO_MORE_ITEMS;
			break;
		} // if: no properties in the list

		//
		// Make sure the buffer is big enough for the first property name.
		//
		if ( m_cbDataLeft < sizeof( *m_cbhCurrentPropName.pName ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance the buffer pointer.
		//
		_cbDataSize = sizeof( *m_cbhCurrentPropName.pName )
					+ ALIGN_CLUSPROP( m_cbhCurrentPropName.pName->cbLength );

		//
		// Make sure the buffer is big enough for the name header
		// and the data itself.
		//
		if ( m_cbDataLeft < _cbDataSize )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Point the value buffer to the first value in the list.
		//
		_cbhCurrentValue.pb = m_cbhCurrentPropName.pb + _cbDataSize;
		_cbDataLeft = m_cbDataLeft - _cbDataSize;
		m_pvlValues.Init( _cbhCurrentValue, _cbDataLeft );

		//
		// Indicate we are successful.
		//
		_sc = ERROR_SUCCESS;

	} while ( 0 );

	return _sc;

} //*** CClusPropList::ScMoveToFirstProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToNextProperty
//
//	Description:
//		Move the cursor to the next property in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the next property successfully.
//		ERROR_NO_MORE_ITEMS	Already at the end of the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToNextProperty( void )
{
	ASSERT( m_cbhPropList.pb != NULL );
	ASSERT( m_pvlValues.CbhValueList().pb != NULL );

	DWORD					_sc;
	DWORD					_cbNameSize;
	DWORD					_cbDataLeft;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;
	CLUSPROP_BUFFER_HELPER	_cbhPropName;

	_cbhCurrentValue = m_pvlValues;
	_cbDataLeft = m_pvlValues.CbDataLeft();

	//
	// If we aren't already at the last property, attempt to move to the next one.
	//
	_sc = ScCheckIfAtLastProperty();
	if ( _sc == ERROR_SUCCESS )
	{
		do
		{
			//
			// Make sure the buffer is big enough for the value header.
			//
			if ( _cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data left

			//
			// Careful!  Add offset only to cbhCurrentValue.pb.  Otherwise
			// pointer arithmetic will give undesirable results.
			//
			while ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
			{
				//
				// Make sure the buffer is big enough for the value
				// and an endmark.
				//
				_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
							+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );
				if ( _cbDataLeft < _cbDataSize + sizeof( *_cbhCurrentValue.pSyntax ) )
				{
					_sc = ERROR_INVALID_DATA;
					break;
				} // if: not enough data left

				//
				// Advance past the value.
				//
				_cbhCurrentValue.pb += _cbDataSize;
				_cbDataLeft -= _cbDataSize;
			} // while: not at endmark

			if ( _sc != ERROR_SUCCESS )
			{
				break;
			} // if: error occurred in loop

			//
			// Advanced past the endmark.
			// Size check already performed in above loop.
			//
			_cbDataSize = sizeof( *_cbhCurrentValue.pSyntax );
			_cbhCurrentValue.pb += _cbDataSize;
			_cbDataLeft -= _cbDataSize;

			//
			// Point the name pointer to the next name in the list.
			//
			_cbhPropName = _cbhCurrentValue;
			ASSERT( _cbDataLeft == m_cbDataSize - (_cbhPropName.pb - m_cbhPropList.pb) );

			//
			// Calculate the size of the name with header.
			// Make sure the buffer is big enough for the name and an endmark.
			//
			if ( _cbDataLeft < sizeof( *_cbhPropName.pName ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data
			_cbNameSize = sizeof( *_cbhPropName.pName )
						+ ALIGN_CLUSPROP( _cbhPropName.pName->cbLength );
			if ( _cbDataLeft < _cbNameSize + sizeof( CLUSPROP_SYNTAX ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data

			//
			// Point the value buffer to the first value in the list.
			//
			_cbhCurrentValue.pb = _cbhPropName.pb + _cbNameSize;
			m_cbhCurrentPropName = _cbhPropName;
			m_cbDataLeft = _cbDataLeft - _cbNameSize;
			m_pvlValues.Init( _cbhCurrentValue, m_cbDataLeft );

			//
			// We've successfully advanced to the next property,
			// so there is now one fewer property remaining.
			//
			--m_nPropsRemaining;
			ASSERT( m_nPropsRemaining >= 1 );

			_sc = ERROR_SUCCESS;

		} while ( 0 );
	} // if: not at last property

	return _sc;

} //*** CClusPropList::ScMoveToNextProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToPropertyByName
//
//	Description:
//		Find the passed in property name in the proplist.  Note that the
//		cursor is reset to the beginning at the beginning of the routine and
//		the current state of the cursor is lost.
//
//	Arguments:
//		pwszPropName	[IN] Name of the property
//
//	Return Value:
//		TRUE if the property was found, FALSE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToPropertyByName( IN LPCWSTR pwszPropName )
{
	ASSERT( m_cbhPropList.pb != NULL );

	DWORD	_sc;

	_sc = ScMoveToFirstProperty();
	if ( _sc == ERROR_SUCCESS )
	{
		do
		{
			//
			// See if this is the specified property.  If so, we're done.
			//
			if ( lstrcmpiW( m_cbhCurrentPropName.pName->sz, pwszPropName ) == 0 )
			{
				break;
			} // if: property found

			//
			// Advance to the next property.
			//
			_sc = ScMoveToNextProperty();

		} while ( _sc == ERROR_SUCCESS );	// do-while: not end of list
	} // if: successfully moved to the first property

	return _sc;

} //*** ClusPropList::ScMoveToPropertyByName( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAllocPropList
//
//	Description:
//		Allocate a property list buffer that's big enough to hold the next
//		property.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by new.  By default, no exceptions are thrown.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAllocPropList( IN DWORD cbMinimum )
{
	ASSERT( cbMinimum > 0 );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbTotal = 0;

	//
	// Add the size of the item count and final endmark.
	//
	cbMinimum += sizeof( CLUSPROP_VALUE );
	_cbTotal = m_cbDataSize + cbMinimum;

	if ( m_cbBufferSize < _cbTotal )
	{
		PBYTE	_pbNewProplist = NULL;

		cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
		_cbTotal = m_cbDataSize + cbMinimum;

		//
		// Allocate and zero a new buffer.
		//
		_pbNewProplist = new BYTE[ _cbTotal ];
		if ( _pbNewProplist != NULL )
		{
			ZeroMemory( _pbNewProplist, _cbTotal );

			//
			// If there was a previous buffer, copy it and the delete it.
			//
			if ( m_cbhPropList.pb != NULL )
			{
				if ( m_cbDataSize != 0 )
				{
					CopyMemory( _pbNewProplist, m_cbhPropList.pb, m_cbDataSize );
				} // if: data already exists in buffer

				delete [] m_cbhPropList.pb;
				m_cbhCurrentProp.pb = _pbNewProplist + (m_cbhCurrentProp.pb - m_cbhPropList.pb);
			} // if: there was a previous buffer
			else
			{
				m_cbhCurrentProp.pb = _pbNewProplist + sizeof( DWORD ); // move past prop count
			} // else: no previous buffer

			//
			// Save the new buffer.
			//
			m_cbhPropList.pb = _pbNewProplist;
			m_cbBufferSize = _cbTotal;
		} // if: allocation succeeded
		else
		{
			_sc = ERROR_NOT_ENOUGH_MEMORY;
		} // else: allocation failed
	} // if: buffer isn't big enough

	return _sc;

} //*** CClusPropList::ScAllocPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR 	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_SZ			_pValue;

	if (( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ))
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pStringValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddMultiSzProp
//
//	Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddMultiSzProp(
	IN LPCWSTR 	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_MULTI_SZ		_pValue;

	if ( ( pwszPrevValue != NULL ) && ( NCompareMultiSz( pwszValue, pwszPrevValue ) == 0 ) )
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (CchMultiSz( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pMultiSzValue;
			CopyMultiSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddMultiSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddExpandSzProp
//
//	Description:
//		Add an EXPAND_SZ string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddExpandSzProp(
	IN LPCWSTR	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_SZ			_pValue;

	if ( ( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ) )
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pStringValue;
			CopyExpandSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddExpandSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a DWORD property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		nValue			[IN] Value of the property to set in the list.
//		nPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR	pwszName,
	IN DWORD	nValue,
	IN DWORD	nPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_DWORD			_pValue;

	if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_DWORD )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pDwordValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( DWORD )

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a LONG property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		nValue			[IN] Value of the property to set in the list.
//		nPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR	pwszName,
	IN LONG		nValue,
	IN LONG		nPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_DWORD			_pValue;

	if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_DWORD )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pDwordValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( LONG )

#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a binary property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pbValue			[IN] Value of the property to set in the list.
//		cbValue			[IN] Count of bytes in pbValue.
//		pbPrevValue		[IN] Previous value of the property.
//		cbPrevValue		[IN] Count of bytes in pbPrevValue.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR			pwszName,
	IN const PBYTE		pbValue,
	IN DWORD			cbValue,
	IN const PBYTE		pbPrevValue,
	IN DWORD			cbPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bChanged = FALSE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_BINARY		_pValue;

	//
	// Determine if the buffer has changed.
	//
	if ( m_bAlwaysAddProp || (cbValue != cbPrevValue) )
	{
		_bChanged = TRUE;
	} // if: always adding the property or the value size changed
	else if ( ( cbValue != 0 ) && ( cbPrevValue != 0 ) )
	{
		_bChanged = memcmp( pbValue, pbPrevValue, cbValue ) != 0;
	} // else if: value length changed

	if ( _bChanged )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_BINARY )
					+ ALIGN_CLUSPROP( cbValue )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pBinaryValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Routine Description:
//		Add a ULONGLONG property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		ullValue		[IN] Value of the property to set in the list.
//		ullPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR		pwszName,
	IN ULONGLONG	ullValue,
	IN ULONGLONG	ullPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD						_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME		_pName;
	PCLUSPROP_ULARGE_INTEGER	_pValue;

	if ( m_bAlwaysAddProp || ( ullValue != ullPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_ULARGE_INTEGER )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pULargeIntegerValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, ullValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScSetPropToDefault
//
//	Description:
//		Add a property to the property list so that it will revert to its
//		default value.
//
//	Arguments:
//		pwszName	[IN] Name of the property.
//		cpfPropFmt	[IN] Format of property
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScSetPropToDefault(
	IN LPCWSTR					pwszName,
	IN CLUSTER_PROPERTY_FORMAT	cpfPropFmt
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	DWORD					_cbNameSize;
	DWORD					_cbValueSize;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_VALUE			_pValue;

	// Calculate sizes and make sure we have a property list.
	_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
				+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
	_cbValueSize = sizeof( CLUSPROP_BINARY )
				+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

	_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
	if ( _sc == ERROR_SUCCESS )
	{
		//
		// Set the property name.
		//
		_pName = m_cbhCurrentProp.pName;
		CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
		m_cbhCurrentProp.pb += _cbNameSize;

		//
		// Set the property value.
		//
		_pValue = m_cbhCurrentProp.pValue;
		CopyEmptyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, cpfPropFmt );
		m_cbhCurrentProp.pb += _cbValueSize;

		//
		// Increment the property count and buffer size.
		//
		m_cbhPropList.pList->nPropertyCount++;
		m_cbDataSize += _cbNameSize + _cbValueSize;
	} // if:

	return _sc;

} //*** CClusPropList::ScSetPropToDefault()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in pwsz string.  If specified as 0,
//						the the length will be determined by a call to strlen.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz		// = 0
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
	} // if: zero size specified
	ASSERT( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	lstrcpyW( pprop->sz, psz );

	//
	// Set an endmark.
	//
	_cbhProps.pStringValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyMultiSzProp
//
//	Description:
//		Copy a MULTI_SZ string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in psz string.  If specified as 0,
//						the the length will be determined by calls to strlen.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyMultiSzProp(
	OUT PCLUSPROP_MULTI_SZ		pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_MULTI_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (CchMultiSz( psz ) + 1) * sizeof( WCHAR );
	} // if: zero size specified
	ASSERT( cbsz == (CchMultiSz( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	CopyMemory( pprop->sz, psz, cbsz );

	//
	// Set an endmark.
	//
	_cbhProps.pMultiSzValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pMultiSzValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyMultiSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyExpandSzProp
//
//	Description:
//		Copy an EXPAND_SZ string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in psz string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyExpandSzProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
	} // if: cbsz == 0
	ASSERT( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	lstrcpyW( pprop->sz, psz );

	//
	// Set an endmark.
	//
	_cbhProps.pStringValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyExpandSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a DWORD property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of DWORD.
//		nValue		[IN] Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_DWORD			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN DWORD					nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = sizeof( DWORD );
	pprop->dw = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pDwordValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pDwordValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( DWORD )

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a LONG property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of LONG.
//		nValue		[IN] Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_LONG			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LONG						nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_LONG;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = sizeof( LONG );
	pprop->l = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pLongValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pLongValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( LONG )

#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a ULONGLONG property to a property structure.
//
//	Arguments:
//		pprop		[OUT]	Property structure to fill.
//		proptype	[IN]	Type of LONG.
//		nValue		[IN]	Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT	PCLUSPROP_ULARGE_INTEGER	pprop,
	IN	CLUSTER_PROPERTY_TYPE		proptype,
	IN	ULONGLONG					nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
	pprop->Syntax.wType = static_cast< WORD >( proptype );
	pprop->cbLength = sizeof( ULONGLONG );
	pprop->li.QuadPart = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pULargeIntegerValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pULargeIntegerValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a binary property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		pb			[IN] Block to copy.
//		cbsz		[IN] Count of bytes in pb buffer.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_BINARY		pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN const PBYTE				pb,
	IN size_t					cb
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = cb;
	if ( cb > 0 )
	{
		CopyMemory( pprop->rgb, pb, cb );
	} // if: non-zero data length

	//
	// Set an endmark.
	//
	_cbhProps.pBinaryValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cb );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyEmptyProp
//
//	Description:
//		Copy an empty property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of property.
//		cpfPropFmt	[IN] Format of property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyEmptyProp(
	OUT PCLUSPROP_VALUE			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN CLUSTER_PROPERTY_FORMAT	cptPropFmt
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = static_cast< WORD >( cptPropFmt );
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = 0;

	//
	// Set an endmark.
	//
	_cbhProps.pValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyEmptyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNodeProperties
//
//	Description:
//		Get properties on a node.
//
//	Arguments:
//		hNode			[IN] Handle for the node to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNodeProperties(
	IN HNODE		hNode,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hNode != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNodeControl(
								hNode,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
							);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetGroupProperties
//
//	Description:
//		Get properties on a group.
//
//	Arguments:
//		hGroup			[IN] Handle for the group to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetGroupProperties(
	IN HGROUP		hGroup,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hGroup != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterGroupControl(
								hGroup,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetResourceProperties
//
//	Description:
//		Get properties on a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceProperties(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hResource != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceControl(
								hResource,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetResourceTypeProperties
//
//	Description:
//		Get properties on a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceTypeProperties(
	IN HCLUSTER		hCluster,
	IN LPCWSTR		pwszResTypeName,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( pwszResTypeName != NULL );
	ASSERT( *pwszResTypeName != L'\0' );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceTypeControl(
								hCluster,
								pwszResTypeName,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNetworkProperties
//
//	Description:
//		Get properties on a network.
//
//	Arguments:
//		hNetwork		[IN] Handle for the network to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetworkProperties(
	IN HNETWORK		hNetwork,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hNetwork != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNetworkControl(
								hNetwork,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNetInterfaceProperties
//
//	Description:
//		Get properties on a network interface.
//
//	Arguments:
//		hNetInterface	[IN] Handle for the network interface to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetInterfaceProperties(
	IN HNETINTERFACE	hNetInterface,
	IN DWORD			dwControlCode,
	IN HNODE			hHostNode,
	IN LPVOID			lpInBuffer,
	IN DWORD			cbInBufferSize
	)
{
	ASSERT( hNetInterface != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc= ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNetInterfaceControl(
								hNetInterface,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNetInterfaceProperties()

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetClusterProperties
//
//	Description:
//		Get properties on a cluster.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetClusterProperties(
	IN HCLUSTER	hCluster,
	IN DWORD	dwControlCode,
	IN HNODE	hHostNode,
	IN LPVOID	lpInBuffer,
	IN DWORD	cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_CLUSTER << CLUSCTL_OBJECT_SHIFT) );
	ASSERT( dwControlCode == CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES );

	DWORD	_sc= ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterControl(
						hCluster,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterControl(
								hCluster,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetClusterProperties()

#endif // CLUSAPI_VERSION >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		PropList.h
//
//	Implementation File:
//		PropList.cpp
//
//	Description:
//		Definition of the CClusPropList class.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROPLIST_H__
#define __PROPLIST_H__

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CObjectProperty;
class CClusPropValueList;
class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#if !defined( ASSERT )
#include <crtdbg.h>
#define ASSERT _ASSERTE
#endif // !defined( ASSERT )

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjectProperty
//
//	Description:
//		Describes a property in a cluster property list.
//
//	Inheritance:
//		CObjectProperty
//
//--
/////////////////////////////////////////////////////////////////////////////

#if defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )

class CObjectProperty
{
public:
	LPCWSTR					m_pwszName;
	CLUSTER_PROPERTY_FORMAT	m_propFormat;

	union CValue
	{
		CString *	pstr;
		LONG *		pl;
		DWORD *		pdw;
		BOOL *		pb;
		struct
		{
			PBYTE *	ppb;
			DWORD *	pcb;
		};
	};
	CValue					m_value;
	CValue					m_valuePrev;
	CValue					m_valueEx;		// expand_sz value (if any)

	DWORD					m_fFlags;

	enum ObjPropFlags
	{
		opfNew = 1
	};

	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_value.pcb = NULL;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	void	SetExpandSz(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
		m_value.pstr = &rstrValue;
		m_value.pcb = NULL;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	// Set() to get extra EXPANDED_SZ value
	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN CString & rstrValueEx,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_value.pcb = NULL;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = &rstrValueEx;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	// Set() to get extra EXPANDED_SZ value
	void	SetExpandSz(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN CString & rstrValueEx,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
		m_value.pstr = &rstrValue;
		m_value.pcb = NULL;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = &rstrValueEx;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	void	Set(
				IN LPCWSTR pwszName,
				IN LONG & rnValue,
				IN LONG & rnPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_LONG;
		m_value.pl = &rnValue;
		m_value.pcb = NULL;
		m_valuePrev.pl = &rnPrevValue;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( LONG & )

	void	Set(
				IN LPCWSTR pwszName,
				IN DWORD & rdwValue,
				IN DWORD & rdwPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pdw = &rdwValue;
		m_value.pcb = NULL;
		m_valuePrev.pdw = &rdwPrevValue;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( DWORD & )

	void	Set(
				IN LPCWSTR pwszName,
				IN BOOL & rbValue,
				IN BOOL & rbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pb = &rbValue;
		m_value.pcb = NULL;
		m_valuePrev.pb = &rbPrevValue;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( BOOL & )

	void	Set(
				IN LPCWSTR pwszName,
				IN PBYTE & rpbValue,
				IN DWORD & rcbValue,
				IN PBYTE & rpbPrevValue,
				IN DWORD & rcbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_BINARY;
		m_value.ppb = &rpbValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = &rpbPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( PBYTE & )

	void	Set(
				IN LPCWSTR pwszName,
				IN LPWSTR & rpwszValue,
				IN DWORD & rcbValue,
				IN LPWSTR & rpwszPrevValue,
				IN DWORD & rcbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
		m_value.ppb = reinterpret_cast< PBYTE * >( &rpwszValue );
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = reinterpret_cast< PBYTE * >( &rpwszPrevValue );
		m_valuePrev.pcb = &rcbPrevValue;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
		m_fFlags = fFlags;

	} //*** Set( LPWSTR & )

}; //*** class CObjectProperty

#endif	// defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPropValueList
//
//	Description:
//		Describes a cluster property list.
//
//	Inheritance:
//		CClusPropValueList
//		CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusPropValueList
#ifdef __AFX_H__
	: public CObject
#endif // __AFX_H__
{
#ifdef __AFX_H__
	DECLARE_DYNAMIC( CClusPropValueList );
#endif // __AFX_H__

public:
	//
	// Construction.
	//

	// Default constructor
	CClusPropValueList( void )
		: m_cbDataSize( 0 )
		, m_cbDataLeft( 0 )
		, m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		m_cbhValueList.pb = NULL;
		m_cbhCurrentValue.pb = NULL;

	} //*** CClusPropValueList()

	// Copy constructor.
	CClusPropValueList( IN const CClusPropValueList & rcpvl )
		: m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		Init( rcpvl );

	} //*** CClusPropValueList()

	// Buffer helper constructor.
	CClusPropValueList( IN CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
		: m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		Init( cbhValueList, cbDataSize );

	} //*** CClusPropValueList()

	// Destructor
	~CClusPropValueList( void )
	{
		DeleteValueList();

	} //*** ~CClusPropValueList()

	// Initialize the value list
	void Init( IN const CClusPropValueList & rcpvl )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= rcpvl.m_cbhValueList;
		m_cbhCurrentValue	= rcpvl.m_cbhCurrentValue;
		m_cbDataSize		= rcpvl.m_cbDataSize;
		m_cbDataLeft		= rcpvl.m_cbDataLeft;
		m_bAtEnd			= rcpvl.m_bAtEnd;

	} //*** Init()

	// Initialize the value list from a buffer helper
	void Init( IN const CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= cbhValueList;
		m_cbhCurrentValue	= cbhValueList;
		m_cbDataSize		= cbDataSize;
		m_cbDataLeft		= cbDataSize;
		m_bAtEnd			= FALSE;

	} //*** Init()

	// Assignment operator
	void operator=( IN const CClusPropValueList & rcpvl )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= rcpvl.m_cbhValueList;
		m_cbhCurrentValue	= rcpvl.m_cbhCurrentValue;
		m_cbDataSize		= rcpvl.m_cbDataSize;
		m_cbDataLeft		= rcpvl.m_cbDataLeft;
		m_bAtEnd			= rcpvl.m_bAtEnd;

	} //*** operator=()

public:
	//
	// Accessor methods.
	//

	// Buffer helper cast operator to access the current value
	operator const CLUSPROP_BUFFER_HELPER( void ) const
	{
		return m_cbhCurrentValue;

	} //*** operator CLUSPROP_BUFFER_HELPER()

	// Access the value list
	CLUSPROP_BUFFER_HELPER CbhValueList( void ) const
	{
		return m_cbhValueList;

	} //*** CbhValueList()

	// Access the current value
	CLUSPROP_BUFFER_HELPER CbhCurrentValue( void ) const
	{
		return m_cbhCurrentValue;

	} //*** CbhCurrentValue()

	// Access the format of the current value
	CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pValue->Syntax.wFormat );

	} //*** CpfCurrentValueFormat()

	// Access the type of the current value
	CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_TYPE >( m_cbhCurrentValue.pValue->Syntax.wType );

	} //*** CptCurrentValueType()

	// Access the syntax of the current value
	CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_SYNTAX >( m_cbhCurrentValue.pValue->Syntax.dw );

	} //*** CpsCurrentValueSyntax()

	// Access the length of the data of the current value
	DWORD CbCurrentValueLength( void ) const
	{
		DWORD cbLength;

		if ( m_cbhCurrentValue.pb == NULL )
		{
			cbLength = 0;
		} // if: no value list allocated yet
		else
		{
			cbLength = m_cbhCurrentValue.pValue->cbLength;
		} // else: value list allocated

		return cbLength;

	} //*** CbCurrentValueLength()

	// Access size of the data in the buffer.
	DWORD CbDataSize( void ) const
	{
		return m_cbDataSize;

	} //*** CbDataSize()

	// Access amount of data left in buffer after current value
	DWORD CbDataLeft( void ) const
	{
		return m_cbDataLeft;

	} //*** CbDataLeft()

public:
	//
	// Parsing methods.
	//

	// Move to the first value in the list
	DWORD ScMoveToFirstValue( void );

	// Move the value after the current one in the list
	DWORD ScMoveToNextValue( void );

	// Query whether we are at the last value in the list or not
	DWORD ScCheckIfAtLastValue( void );

public:
	//
	// Methods for building a value list.
	//

	// Allocate a value list
	DWORD ScAllocValueList( IN DWORD cbMinimum );

	// Delete the value list buffer and cleanup support variables
	void DeleteValueList( void )
	{
		//
		// If m_cbBufferSize is greater then 0 then we allocated the value list.
		// If it's zero then the value list is a part of the property list in
		// CClusPropList.
		//
		if ( m_cbBufferSize > 0 )
		{
			delete [] m_cbhValueList.pb;
			m_cbhValueList.pb = NULL;
			m_cbhCurrentValue.pb = NULL;
			m_cbBufferSize = 0;
			m_cbDataSize = 0;
			m_cbDataLeft = 0;
			m_bAtEnd = FALSE;
		} // if: we allocated anything

	} //*** DeletePropList()

	// Get a value list from a resource
	DWORD ScGetResourceValueList(
						IN HRESOURCE	hResource,
						IN DWORD		dwControlCode,
						IN HNODE		hHostNode		= NULL,
						IN LPVOID		lpInBuffer		= NULL,
						IN DWORD		cbInBufferSize	= 0
						);

	// Get a value list from a resource type
	DWORD ScGetResourceTypeValueList(
						IN HCLUSTER	hCluster,
						IN LPCWSTR	pwszResTypeName,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

private:
	CLUSPROP_BUFFER_HELPER	m_cbhValueList;		// Pointer to the value list for parsing.
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentValue;	// Pointer to the current value for parsing.
	DWORD					m_cbDataSize;		// Amount of data in the buffer.
	DWORD					m_cbDataLeft;		// Amount of data left in buffer after current value.
	DWORD					m_cbBufferSize;		// Size of the buffer if we allocated it.
	BOOL					m_bAtEnd;			// Indicates whether at last value in list.

}; //*** class CClusPropValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPropList
//
//	Description:
//		Describes a cluster property list.
//
//	Inheritance:
//		CClusPropList
//		CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusPropList
#ifdef __AFX_H__
	: public CObject
#endif // __AFX_H__
{
#ifdef __AFX_H__
	DECLARE_DYNAMIC( CClusPropList );
#endif // __AFX_H__

public:
	//
	// Construction.
	//

	// Default constructor
	CClusPropList( IN BOOL bAlwaysAddProp = FALSE )
		: m_bAlwaysAddProp( bAlwaysAddProp )
		, m_cbBufferSize( 0 )
		, m_cbDataSize( 0 )
		, m_cbDataLeft( 0 )
		, m_nPropsRemaining( 0 )
	{
		m_cbhPropList.pList		= NULL;
		m_cbhCurrentProp.pb		= NULL;
		m_cbhCurrentPropName.pb	= NULL;

	} //*** CClusPropList()

	// Destructor
	~CClusPropList( void )
	{
		DeletePropList();

	} //*** ~CClusPropList()

	// Copy list into this list (like assignment operator)
	DWORD ScCopy( IN const PCLUSPROP_LIST pcplPropList, IN DWORD cbListSize );

	// Delete the property list buffer and cleanup support variables
	void DeletePropList( void )
	{
		delete [] m_cbhPropList.pb;
		m_cbhPropList.pb = NULL;
		m_cbhCurrentProp.pb = NULL;
		m_cbhCurrentPropName.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
		m_cbDataLeft = 0;

	} //*** DeletePropList()

protected:
	//
	// Attributes.
	//

	BOOL					m_bAlwaysAddProp;		// Indicate if properties should be added even if not different.
	CLUSPROP_BUFFER_HELPER	m_cbhPropList;			// Pointer to the beginning of the list.
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentProp;		// Pointer to the current property.
	DWORD					m_cbBufferSize;			// Allocated size of the buffer.
	DWORD					m_cbDataSize;			// Amount of data in the buffer.
	DWORD					m_cbDataLeft;			// Amount of data left in buffer after current value.

private:
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentPropName;	// Pointer to the current name for parsing
	DWORD					m_nPropsRemaining;		// Used by BMoveToNextProperty() to track end of list.
	CClusPropValueList		m_pvlValues;			// Helper class for value list of current property.

public:
	//
	// Accessor methods.
	//

	// Access the values of the current property
	const CClusPropValueList & RPvlPropertyValue( void )
	{
		return m_pvlValues;

	} //*** RPvlPropertyValue()

	// Access the property list
	operator PCLUSPROP_LIST( void ) const
	{
		return m_cbhPropList.pList;

	} //*** operator PCLUSPROP_LIST()

	// Access allocated size of the buffer
	DWORD CbBufferSize( void ) const
	{
		return m_cbBufferSize;

	} //*** CbBufferSize()

	// Access the name of the current property
	LPCWSTR PszCurrentPropertyName( void ) const
	{
		return m_cbhCurrentPropName.pName->sz;

	} //*** PszCurrentPropertyName()

	// Access the current property name as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentPropertyName( void )
	{
		return m_cbhCurrentPropName;

	} //*** CbhCurrentPropertyName()

	// Access value list of the current property as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentValueList( void )
	{
		return m_pvlValues.CbhValueList();

	} //*** CbhCurrentValueList()

	// Access current value of the current property as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentValue( void )
	{
		return m_pvlValues.CbhCurrentValue();

	} //*** CbhCurrentValue()

	// Access the format of the current value of the current property
	CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
	{
		return m_pvlValues.CpfCurrentValueFormat();

	} //*** CpfCurrentValueFormat()

	// Access the type of the current value of the current property
	CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
	{
		return m_pvlValues.CptCurrentValueType();

	} //*** CptCurrentValueType()

	// Access the syntax of the current value of the current property
	CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
	{
		return m_pvlValues.CpsCurrentValueSyntax();

	} //*** CpsCurrentValueSyntax()

	// Access the length of the current value of the current property
	DWORD CbCurrentValueLength( void ) const
	{
		return m_pvlValues.CbCurrentValueLength();

	} //*** CbCurrentValueLength()

	PCLUSPROP_LIST Plist( void )
	{
		return m_cbhPropList.pList;

	} //*** Plist()

	const CLUSPROP_BUFFER_HELPER CbhPropList( void ) const
	{
		return m_cbhPropList;

	} //*** CbhPropList()

	PBYTE PbPropList( void ) const
	{
		return m_cbhPropList.pb;

	} //*** PbPropList()

	DWORD CbPropList( void ) const
	{
		return m_cbDataSize + sizeof( CLUSPROP_SYNTAX ); /*endmark*/

	} //*** CbPropList()

	// Access amount of data left in buffer after current value
	DWORD CbDataLeft( void ) const
	{
		return m_cbDataLeft;

	} //*** CbDataLeft()

	DWORD Cprops( void ) const
	{
		if ( m_cbhPropList.pb == NULL )
		{
			return 0;
		} // if:  no buffer yet

		return m_cbhPropList.pList->nPropertyCount;

	} //*** Cprops()

public:
	//
	// Parsing methods.
	//

	// Initialize the size after getting properties from an external source
	void InitSize( IN DWORD cbSize )
	{
		ASSERT( m_cbhPropList.pb != NULL );
		ASSERT( m_cbBufferSize > 0 );

		m_cbDataSize = cbSize;
		m_cbDataLeft = cbSize;

	} //*** InitSize()

	// Move to the first property in the list
	DWORD ScMoveToFirstProperty( void );

	// Move the property after the current one in the list
	DWORD ScMoveToNextProperty( void );

	// Move to a property by specifying its name
	DWORD ScMoveToPropertyByName( IN LPCWSTR pwszPropName );

	// Move to the first value in the current property
	DWORD ScMoveToFirstPropertyValue( void )
	{
		return m_pvlValues.ScMoveToFirstValue();

	} //*** ScMoveToFirstPropertyValue()

	// Move the the value after the current on in the current property
	DWORD ScMoveToNextPropertyValue( void )
	{
		return m_pvlValues.ScMoveToNextValue();

	} //*** ScMoveToNextPropertyValue()

	// Query whether we are at the last property in the list or not
	DWORD ScCheckIfAtLastProperty( void ) const
	{
		DWORD _sc;

		if ( m_nPropsRemaining <= 1 )
		{
			_sc = ERROR_NO_MORE_ITEMS;
		} // if:  at the last property
		else
		{
			_sc = ERROR_SUCCESS;
		} // else:  not at the last property

		return _sc;

	} //*** ScCheckIfAtLastProperty()

	// Query whether the list is empty or not
	BOOL BIsListEmpty( void ) const
	{
		ASSERT( m_cbhPropList.pb != NULL );
		ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

		return m_cbhPropList.pList->nPropertyCount == 0;

	} //*** BIsListEmpty()

public:
	//
	// Methods for building a property list.
	//

	// Allocate a property list
	DWORD ScAllocPropList( IN DWORD cbMinimum );

	void ClearPropList( void )
	{
		m_cbDataSize = 0;
		m_cbDataLeft = 0;

		if ( m_cbBufferSize != 0 )
		{
			ZeroMemory( m_cbhPropList.pb, m_cbBufferSize );
			m_cbhCurrentProp.pb = m_cbhPropList.pb + sizeof( m_cbhPropList.pList->nPropertyCount );
			m_cbhCurrentPropName = m_cbhCurrentProp;
		} // if:  buffer already allocated

	} //*** ClearPropList()

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddMultiSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddProp( IN LPCWSTR pwszName, IN DWORD nValue, IN DWORD nPrevValue );

#if CLUSAPI_VERSION >= 0x0500

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LONG nValue, IN LONG nPrevValue );

#endif // CLUSAPI_VERSION >= 0x0500

	DWORD ScAddProp( IN LPCWSTR pwszName, IN ULONGLONG ullValue, IN ULONGLONG ullPrevValue );

	DWORD ScSetPropToDefault( IN LPCWSTR pwszName, IN CLUSTER_PROPERTY_FORMAT propfmt );

	DWORD ScAddProp(
			IN LPCWSTR		pwszName,
			IN const PBYTE	pbValue,
			IN DWORD		cbValue,
			IN const PBYTE	pbPrevValue,
			IN DWORD		cbPrevValue
			);

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
	{
		return ScAddProp( pwszName, pwszValue, NULL );

	} //*** ScAddProp()

	DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
	{
		return ScAddExpandSzProp( pwszName, pwszValue, NULL );

	} //*** ScAddExpandSzProp()

public:
	//
	// Get Property methods.
	//

	DWORD ScGetNodeProperties(
						IN HNODE	hNode,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetGroupProperties(
						IN HGROUP	hGroup,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetResourceProperties(
						IN HRESOURCE	hResource,
						IN DWORD		dwControlCode,
						IN HNODE		hHostNode		= NULL,
						IN LPVOID		lpInBuffer		= NULL,
						IN DWORD		cbInBufferSize	= 0
						);

	DWORD ScGetResourceTypeProperties(
						IN HCLUSTER	hCluster,
						IN LPCWSTR	pwszResTypeName,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetNetworkProperties(
						IN HNETWORK	hNetwork,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetNetInterfaceProperties(
						IN HNETINTERFACE	hNetInterface,
						IN DWORD			dwControlCode,
						IN HNODE			hHostNode		= NULL,
						IN LPVOID			lpInBuffer		= NULL,
						IN DWORD			cbInBufferSize	= 0
						);

#if CLUSAPI_VERSION >= 0x0500

	DWORD ScGetClusterProperties(
						IN HCLUSTER	hCluster,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

#endif // CLUSAPI_VERSION >= 0x0500

// Implementation
protected:
	void CopyProp(
			IN PCLUSPROP_SZ				pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyExpandSzProp(
			IN PCLUSPROP_SZ				pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyMultiSzProp(
			IN PCLUSPROP_MULTI_SZ		pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyProp(
			IN PCLUSPROP_DWORD			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN DWORD					nValue
			);

#if CLUSAPI_VERSION >= 0x0500

	void CopyProp(
			IN PCLUSPROP_LONG			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LONG						nValue
			);

#endif // CLUSAPI_VERSION >= 0x0500

	void CopyProp(
			OUT	PCLUSPROP_ULARGE_INTEGER	pprop,
			IN	CLUSTER_PROPERTY_TYPE		proptype,
			IN	ULONGLONG					nValue
			);

	void CopyProp(
			IN PCLUSPROP_BINARY			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN const PBYTE				pb,
			IN size_t					cb
			);

	void CopyEmptyProp(
			IN PCLUSPROP_VALUE			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN CLUSTER_PROPERTY_FORMAT	propfmt
			);

}; //*** class CClusPropList

#pragma warning( default : 4201 )

/////////////////////////////////////////////////////////////////////////////

#endif // __PROPLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ClNetResEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ClNetResEx.rc
//
#define IDD_PP_DHCP_PARAMETERS          250
#define IDD_PP_WINS_PARAMETERS          251
#define IDD_WIZ_DHCP_PARAMETERS         260
#define IDD_WIZ_WINS_PARAMETERS         261
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_DHCP_DATABASEPATH_LABEL  1010
#define IDC_PP_DHCP_DATABASEPATH        1011
#define IDC_PP_DHCP_LOGFILEPATH_LABEL   1012
#define IDC_PP_DHCP_LOGFILEPATH         1013
#define IDC_PP_DHCP_BACKUPPATH_LABEL    1014
#define IDC_PP_DHCP_BACKUPPATH          1015
#define IDC_PP_WINS_DATABASEPATH_LABEL  1020
#define IDC_PP_WINS_DATABASEPATH        1021
#define IDC_PP_WINS_BACKUPPATH_LABEL    1022
#define IDC_PP_WINS_BACKUPPATH          1023
#define IDS_CLUADMEX_COMOBJ_DESC        31100
#define IDS_ERROR_MSG_ID                31101
#define IDS_REQUIRED_FIELD_EMPTY        31102
#define IDS_ERROR_SETTING_PROPERTIES    31103
#define IDS_ERROR_VALIDATING_PROPERTIES 31104
#define IDS_ERROR_NO_ENDING_BACKSLASH   31105
#define IDS_APPLY_PARAM_CHANGES_ERROR   31200
#define IDS_MENU_WHATS_THIS             31201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1200
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		RegExt.h
//
//	Implementation File:
//		RegExt.cpp
//
//	Description:
//		Definitions of routines for extension registration.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __REGEXT_H__
#define __REGEXT_H__

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // __REGEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		RegExt.cpp
//
//	Description:
//		Implementation of routines for extension registration.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminClusterExtension
//
//	Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if ( hkey == NULL )
	{
		hr = GetLastError();
	} // if:  error getting cluster key
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension( hkey, pClsid );

		ClusterRegCloseKey( hkey );
	} // else:  GetClusterKey succeeded

	return hr;

} //*** RegisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNodesExtension
//
//	Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension( hCluster, L"Nodes", pClsid );

	return hr;

} //*** RegisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllGroupsExtension
//
//	Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension( hCluster, L"Groups", pClsid );

	return hr;

} //*** RegisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourcesExtension
//
//	Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension( hCluster, L"Resources", pClsid );

	return hr;

} //*** RegisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourceTypesExtension
//
//	Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension( hCluster, L"ResourceTypes", pClsid );

	return hr;

} //*** RegisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNetworksExtension
//
//	Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all networks.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension( hCluster, L"Networks", pClsid );

	return hr;

} //*** RegisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNetInterfacesExtension
//
//	Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all network interfaces.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension( hCluster, L"NetInterfaces", pClsid );

	return hr;

} //*** RegisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminResourceTypeExtension
//
//	Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey( hCluster, pwszResourceType, KEY_ALL_ACCESS );
	if ( hkey == NULL )
	{
		hr = GetLastError();
	} // if:  error getting resource type key
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension( hkey, pClsid );

		ClusterRegCloseKey( hkey );
	} // else:  GetClusterResourceTypeKey succeeded

	return hr;

} //*** RegisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminClusterExtension
//
//	Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey( hCluster, KEY_ALL_ACCESS );
	if ( hkey == NULL )
	{
		hr = GetLastError();
	} // if:  error getting cluster key
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

		ClusterRegCloseKey( hkey );
	} // else:  GetClusterKey succeeded

	return hr;

} //*** UnregisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNodesExtension
//
//	Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension( hCluster, L"Nodes", pClsid );

	return hr;

} //*** UnregisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllGroupsExtension
//
//	Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension( hCluster, L"Groups", pClsid );

	return hr;

} //*** UnregisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourcesExtension
//
//	Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension( hCluster, L"Resources", pClsid );

	return hr;

} //*** UnregisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourceTypesExtension
//
//	Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension( hCluster, L"ResourceTypes", pClsid );

	return hr;

} //*** UnregisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNetworksExtension
//
//	Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all networks.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension( hCluster, L"Networks", pClsid );

	return hr;

} //*** UnregisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNetInterfacesExtension
//
//	Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all network interfaces.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension( hCluster, L"NetInterfaces", pClsid );

	return hr;

} //*** UnregisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminResourceTypeExtension
//
//	Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey( hCluster, pwszResourceType, KEY_ALL_ACCESS );
	if ( hkey == NULL )
	{
		hr = GetLastError();
	} // if:  error getting resource type key
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

		ClusterRegCloseKey( hkey );
	} // else:  GetClusterResourceTypeKey succeeded

	return hr;

} //*** UnregisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey( hCluster, KEY_ALL_ACCESS );
	if ( hkeyCluster == NULL )
	{
		hr = GetLastError();
	} // if:  error getting cluster key
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey( hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey );
		if ( hr == ERROR_SUCCESS )
		{
			// Register the extension.
			hr = RegisterAnyCluAdminExtension( hkey, pClsid );

			ClusterRegCloseKey( hkey );
		} // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey( hkeyCluster );
	} // if:  cluster key retrieved successfully

	return hr;

} //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyRegistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID( *pClsid, &pwszClsid );
	if ( hr == S_OK )
	{
		// Read the current value.
		hr = ReadValue( hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize );
		if (hr == S_OK)
		{
			// Check to see if the extension has been registered yet.
			if ( pwszValue == NULL )
			{
				bAlreadyRegistered = FALSE;
			} // if:  empty value found
			else
			{
				LPCWSTR	pwszValueBuf = pwszValue;

				while ( *pwszValueBuf != L'\0' )
				{
					if ( lstrcmpiW( pwszClsid, pwszValueBuf ) == 0 )
					{
						break;
					} // if:  CLSID for this extension already in list
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				} // while:  more strings in the extension list
				bAlreadyRegistered = (*pwszValueBuf != L'\0');
			} // else:  extension value exists

			// Register the extension.
			if ( ! bAlreadyRegistered )
			{
				// Allocate a new buffer.
				cbNewSize = cbSize + (lstrlenW( pwszClsid ) + 1) * sizeof( WCHAR );
				if ( cbSize == 0 ) // Add size of final NULL if first entry.
				{
					cbNewSize += sizeof( WCHAR );
				} // if:  no previous value
				pwszNewValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbNewSize ) );
				if ( pwszNewValue == NULL )
				{
					hr = GetLastError();
				} // if:  error allocating memory
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	cch;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if ( pwszValue != NULL)
					{
						while ( *pwszValueBuf != L'\0' )
						{
							lstrcpyW( pwszNewValueBuf, pwszValueBuf );
							cch = lstrlenW( pwszValueBuf );
							pwszValueBuf += cch + 1;
							pwszNewValueBuf += cch + 1;
						} // while:  more strings in the extension list
					} // if:  previous value buffer existed

					// Add the new CLSID to the list.
					lstrcpyW( pwszNewValueBuf, pwszClsid );
					pwszNewValueBuf += lstrlenW( pwszClsid ) + 1;
					*pwszNewValueBuf = L'\0';

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									reinterpret_cast< LPBYTE >( pwszNewValue ),
									cbNewSize
									);

					LocalFree( pwszNewValue );
				} // else:  new buffer allocated successfully

			} // if:  extension not registered yet

			LocalFree( pwszValue );
		} // if:  value read successfully

		CoTaskMemFree( pwszClsid );
	} // if:  CLSID converted to a string successfully

	return hr;

} //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey( hCluster, KEY_ALL_ACCESS );
	if ( hkeyCluster == NULL )
	{
		hr = GetLastError();
	} // if:  error getting cluster key
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey( hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey );
		if ( hr == ERROR_SUCCESS )
		{
			// Unregister the extension.
			hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

			ClusterRegCloseKey( hkey );
		} // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey( hkeyCluster );
	} // if:  cluster key retrieved successfully

	return hr;

} //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyUnregistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID( *pClsid, &pwszClsid );
	if ( hr == S_OK )
	{
		// Read the current value.
		hr = ReadValue( hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize );
		if ( hr == S_OK )
		{
			// Check to see if the extension has been unregistered yet.
			if ( pwszValue == NULL )
			{
				bAlreadyUnregistered = TRUE;
			} // if:  empty value found
			else
			{
				LPCWSTR pwszValueBuf = pwszValue;

				while ( *pwszValueBuf != L'\0' )
				{
					if ( lstrcmpiW( pwszClsid, pwszValueBuf ) == 0 )
					{
						break;
					} // if:  CLSID for this extension found in list
					pwszValueBuf += lstrlenW( pwszValueBuf ) + 1;
				} // while:  more strings in the extension list
				bAlreadyUnregistered = (*pwszValueBuf == L'\0');
			} // else:  extension value exists

			// Unregister the extension.
			if ( ! bAlreadyUnregistered )
			{
				// Allocate a new buffer.
				cbNewSize = cbSize - (lstrlenW( pwszClsid ) + 1) * sizeof( WCHAR );
				if ( cbNewSize == sizeof( WCHAR ) )
				{
					cbNewSize = 0;
				} // if:  no previous value
				pwszNewValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbNewSize ) );
				if ( pwszNewValue == NULL )
				{
					hr = GetLastError();
				} // if:  error allocating memory
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if ( (cbNewSize > 0) && (pwszValue != NULL) )
					{
						while ( *pwszValueBuf != L'\0' )
						{
							if ( lstrcmpiW( pwszClsid, pwszValueBuf ) != 0 )
							{
								lstrcpyW( pwszNewValueBuf, pwszValueBuf );
								pwszNewValueBuf += lstrlenW( pwszNewValueBuf ) + 1;
							} // if:  not CLSID being removed
							pwszValueBuf += lstrlenW( pwszValueBuf ) + 1;
						} // while:  more strings in the extension list
						*pwszNewValueBuf = L'\0';
					} // if:  previous value buffer existed

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									reinterpret_cast< LPBYTE >( pwszNewValue ),
									cbNewSize
									);

					LocalFree( pwszNewValue );
				} // else:  new buffer allocated successfully

			} // if:  extension not unregistered yet

			LocalFree( pwszValue );
		} // if:  value read successfully

		CoTaskMemFree( pwszClsid );
	} // if:  CLSID converted to a string successfully

	return hr;

} //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReadValue
//
//	Description:
//		Reads a value from the cluster database.
//
//	Arguments:
//		hkey [IN]
//			Handle for the key to read from.
//
//		pwszValueName [IN]
//			Name of value to read.
//
//		ppwszValue [OUT]
//			Address of pointer in which to return data.  The string is
//			allocated using LocalAlloc and must be deallocated by the calling
//			LocalFree.
//
//		pcbSize [OUT]
//			Size in bytes of the allocated value buffer.
//
//	Return Value:
//		Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	)
{
	DWORD		dwStatus;
	DWORD		cbSize;
	DWORD		dwType;
	LPWSTR		pwszValue;

	*ppwszValue = NULL;
	*pcbSize = 0;

	// Get the length of the value.
	dwStatus = ClusterRegQueryValue(
					hkey,
					pwszValueName,
					&dwType,
					NULL,
					&cbSize
					);
	if (	(dwStatus != ERROR_SUCCESS)
		&&	(dwStatus != ERROR_MORE_DATA) )
	{
		if ( dwStatus  == ERROR_FILE_NOT_FOUND )
		{
			dwStatus = ERROR_SUCCESS;
		} // if:  value not found
		return dwStatus;
	} // if:  error occurred

	if ( cbSize > 0 )
	{
		// Allocate a value string.
		pwszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbSize ) );
		if ( pwszValue == NULL )
		{
			dwStatus = GetLastError();
			return dwStatus;
		} // if:  error allocating memory

		// Read the the value.
		dwStatus = ClusterRegQueryValue(
						hkey,
						pwszValueName,
						&dwType,
						reinterpret_cast< LPBYTE >( pwszValue ),
						&cbSize
						);
		if ( dwStatus != ERROR_SUCCESS )
		{
			LocalFree( pwszValue );
			pwszValue = NULL;
			cbSize = 0;
		} // if:  error occurred

		*ppwszValue = pwszValue;
		*pcbSize = cbSize;
	} // if:  value is not empty

	return dwStatus;

} //*** ReadValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE			// Microsoft Windows NT Cluster Administrator
							//   Extension DLLs need to be Unicode
							//   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment( lib, "clusapi.lib" )

// Link against the Cluster Administrator Extensions library.
#pragma comment( lib, "cluadmex.lib" )

// Link against Resource Utilities library.
#pragma comment( lib, "resutils.lib" )

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h>			// MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <clusapi.h>
#include <resapi.h>

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT	IDS;
typedef UINT	IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\wins.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Wins.cpp
//
//	Description:
//		Implementation of the WINS Service resource extension property page classes.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClNetResEx.h"
#include "Wins.h"
#include "BasePage.inl"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWinsParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CWinsParamsPage, CBasePropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CWinsParamsPage, CBasePropertyPage )
	//{{AFX_MSG_MAP(CWinsParamsPage)
	ON_EN_CHANGE( IDC_PP_WINS_DATABASEPATH, OnChangeRequiredField )
	ON_EN_CHANGE( IDC_PP_WINS_BACKUPPATH, OnChangeRequiredField )
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWinsParamsPage::CWinsParamsPage
//
//	Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWinsParamsPage::CWinsParamsPage( void )
	: CBasePropertyPage(
			CWinsParamsPage::IDD,
			g_aHelpIDs_IDD_PP_WINS_PARAMETERS,
			g_aHelpIDs_IDD_WIZ_WINS_PARAMETERS
			)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CWinsParamsPage)
	m_strDatabasePath = _T("");
	m_strBackupPath = _T("");
	//}}AFX_DATA_INIT

	// Setup the property array.
	{
		m_rgProps[ epropDatabasePath ].Set( REGPARAM_WINS_DATABASEPATH, m_strDatabasePath, m_strPrevDatabasePath, m_strDatabaseExpandedPath );
		m_rgProps[ epropBackupPath ].Set( REGPARAM_WINS_BACKUPPATH, m_strBackupPath, m_strPrevBackupPath, m_strBackupExpandedPath );
	} // Setup the property array

	m_iddPropertyPage = IDD_PP_WINS_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_WINS_PARAMETERS;

} //*** CWinsParamsPage::CWinsParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWinsParamsPage::DoDataExchange
//
//	Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWinsParamsPage::DoDataExchange( CDataExchange * pDX )
{
	if ( ! pDX->m_bSaveAndValidate || ! BSaved() )
	{
		AFX_MANAGE_STATE( AfxGetStaticModuleState() );

		// TODO: Modify the following lines to represent the data displayed on this page.
		//{{AFX_DATA_MAP(CWinsParamsPage)
		DDX_Control( pDX, IDC_PP_WINS_DATABASEPATH, m_editDatabasePath );
		DDX_Control( pDX, IDC_PP_WINS_BACKUPPATH, m_editBackupPath );
		DDX_Text( pDX, IDC_PP_WINS_DATABASEPATH, m_strDatabasePath );
		DDX_Text( pDX, IDC_PP_WINS_BACKUPPATH, m_strBackupPath );
		//}}AFX_DATA_MAP

		// Handle numeric parameters.
		if ( ! BBackPressed() )
		{
		} // if: back button not pressed

		if ( pDX->m_bSaveAndValidate )
		{
			// Make sure all required fields are present.
			if ( ! BBackPressed() )
			{
				DDV_RequiredText( pDX, IDC_PP_WINS_DATABASEPATH, IDC_PP_WINS_DATABASEPATH_LABEL, m_strDatabasePath );
				DDV_RequiredText( pDX, IDC_PP_WINS_BACKUPPATH, IDC_PP_WINS_BACKUPPATH_LABEL, m_strBackupPath );

			} // if: back button not pressed
		} // if: saving data from dialog
	} // if: not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange( pDX );

} //*** CWinsParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWinsParamsPage::OnInitDialog
//
//	Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWinsParamsPage::OnInitDialog( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	CBasePropertyPage::OnInitDialog();

	// Limit the size of the text that can be entered in edit controls.
	m_editDatabasePath.SetLimitText( _MAX_PATH );
	m_editBackupPath.SetLimitText( _MAX_PATH );

	// If this is a wizard, make sure the default values are something legal.
	if ( BWizard( ) )
	{
		DWORD	 status;
		WCHAR	 szValidDevice[ 3 ]; // "X:" + NULL
		DWORD	 dwSize = sizeof(szValidDevice) / sizeof(szValidDevice[0]);

		szValidDevice[ 0 ] = L'\0';
		
		status = ResUtilFindDependentDiskResourceDriveLetter( Peo( )->Hcluster( ), 
															  Peo( )->PrdResData( )->m_hresource, 
															  szValidDevice, 
															  &dwSize 
															  );

		// Did we find a disk resource in the the dependency list?
		if ( status == ERROR_SUCCESS
		  && szValidDevice[ 0 ] != L'\0' )
		{
			WCHAR szFilePath[ MAX_PATH ];

			// If the default is "%SystemRoot%\<something>" then change it to match the
			// dependent resource
			if ( m_editDatabasePath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
			  && _wcsnicmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
			{
				// Start with the new drive letter
				wcscpy( szFilePath, szValidDevice );

				// Is the expanded string really expanded?
				if ( m_strDatabaseExpandedPath[0] != L'%'  )
				{	// yes, then just copy the expanded string minus the drive letter.
					LPCWSTR psz = m_strDatabaseExpandedPath;
					psz = wcschr( psz, L':' );
					if ( psz )
					{
						psz++;	// move to next character
					}
					else // if: psz
					{
						psz = m_strDatabaseExpandedPath;
					} // else: just cat the whole thing, let the user figure it out.
					wcscat( szFilePath, psz );
				}
				else
				{	// no, then strip the %SystemRoot%
					// find the ending '%'... this must be there because of the strcmp above!
					LPCWSTR psz = m_strBackupExpandedPath;
					psz = wcschr( psz + 1, L'%' );
					ASSERT( psz );
					psz++; // move past the '%'
					wcscat( szFilePath, psz );
				}

				m_editDatabasePath.SetWindowText( szFilePath );
			} // if: m_editDatabasePath == %SystemRoot%

			// If the default is "%SystemRoot%\<something>" then change it to match the
			// dependent resource
			if ( m_editBackupPath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
			  && _wcsnicmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
			{
				// Start with the new drive letter
				wcscpy( szFilePath, szValidDevice );

				// Is the expanded string really expanded?
				if ( m_strBackupExpandedPath[0] != L'%'  )
				{	// yes, then just copy the expanded string minus the drive letter. minus the drive letter.
					LPCWSTR psz = m_strBackupExpandedPath;
					psz = wcschr( psz, L':' );
					if ( psz )
					{
						psz++;	// move to next character
					}
					else // if: psz
					{
						psz = m_strBackupExpandedPath;
					} // else: just cat the whole thing, let the user figure it out.
					wcscat( szFilePath, psz );
				}
				else
				{	// no, then strip the %SystemRoot%
					// find the ending '%'... this must be there because of the strcmp above!
					LPCWSTR psz = m_strBackupExpandedPath;
					psz = wcschr( psz + 1, L'%' );
					ASSERT( psz );
					psz++; // move past the '%'
					wcscat( szFilePath, psz );
				}

				m_editBackupPath.SetWindowText( szFilePath );
			} // if: m_editBackupPath == %SystemRoot%

		} // if: found a disk resource


	} // if: in a wizard

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

} //*** CWinsParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWinsParamsPage::OnSetActive
//
//	Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWinsParamsPage::OnSetActive( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// Enable/disable the Next/Finish button.
	if ( BWizard() )
	{
		EnableNext( BAllRequiredFieldsPresent() );
	} // if: displaying a wizard

	return CBasePropertyPage::OnSetActive();

} //*** CWinsParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWinsParamsPage::OnChangeRequiredField
//
//	Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWinsParamsPage::OnChangeRequiredField( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	OnChangeCtrl();

	if ( BWizard() )
	{
		EnableNext( BAllRequiredFieldsPresent() );
	} // if: displaying a wizard

} //*** CWinsParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWinsParamsPage::BAllRequiredFieldsPresent
//
//	Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWinsParamsPage::BAllRequiredFieldsPresent( void ) const
{
	BOOL	_bPresent;

	if ( 0
		|| (m_editDatabasePath.GetWindowTextLength() == 0)
		|| (m_editBackupPath.GetWindowTextLength() == 0)
		)
	{
		_bPresent = FALSE;
	} // if: required field not present
	else
	{
		_bPresent = TRUE;
	} // else: all required fields are present

	return _bPresent;

} //*** CWinsParamsPage::BAllRequiredFieldsPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\wins.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Wins.h
//
//	Implementation File:
//		Wins.cpp
//
//	Description:
//		Definition of the WINS Service resource extension property page classes.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WINS_H__
#define __WINS_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWinsParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CWinsParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CWinsParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE( CWinsParamsPage )

// Construction
public:
	CWinsParamsPage( void );

// Dialog Data
	//{{AFX_DATA(CWinsParamsPage)
	enum { IDD = IDD_PP_WINS_PARAMETERS };
	CEdit	m_editDatabasePath;
	CEdit	m_editBackupPath;
	CString	m_strDatabasePath;
	CString	m_strBackupPath;
	//}}AFX_DATA
	CString	m_strPrevDatabasePath;
	CString	m_strPrevBackupPath;
	CString m_strDatabaseExpandedPath;
	CString m_strBackupExpandedPath;

protected:
	enum
	{
		epropDatabasePath,
		epropBackupPath,
		epropMAX
	};
	CObjectProperty		m_rgProps[ epropMAX ];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWinsParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops( void ) const	{ return m_rgProps; }
	virtual DWORD					Cprops( void ) const	{ return sizeof( m_rgProps ) / sizeof( CObjectProperty ); }

// Implementation
protected:
	BOOL	BAllRequiredFieldsPresent( void ) const;

	// Generated message map functions
	//{{AFX_MSG(CWinsParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CWinsParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // __WINS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\common\svc.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    svc.h

Abstract:

    Header file for definitions and structure for the NT Cluster
    Special generic services.

Author:

    John Vert (jvert) 14-June-1997

Revision History:

--*/

#ifndef _COMMONSVC_INCLUDED_
#define _COMMONSVC_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


typedef struct _COMMON_DEPEND_SETUP {
    DWORD               Offset;
    CLUSPROP_SYNTAX     Syntax;
    DWORD               Length;
    PVOID               Value;
} COMMON_DEPEND_SETUP, * PCOMMON_DEPEND_SETUP;

// Localsvc.h must define CommonDependSetup using this structure.
// Localsvc.h must define COMMON_CONTROL to generate control functions

#ifdef _cplusplus
}
#endif


#endif // ifndef _COMMONSVC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clusres\utils.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Common utility routines for clusters resources

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/
#include "clusres.h"
#include "clusrtl.h"
#include "clusudef.h"



DWORD
ClusResOpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    )
/*++

Routine Description:

    This function opens a specified IO drivers.

Arguments:

    Handle - pointer to location where the opened drivers handle is
        returned.

    DriverName - name of the driver to be opened.

Return Value:

    Windows Error Code.

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      nameString;
    NTSTATUS            status;

    *Handle = NULL;

    //
    // Open a Handle to the IP driver.
    //

    RtlInitUnicodeString(&nameString, DriverName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile(
        Handle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        NULL,
        0
        );

    return( RtlNtStatusToDosError( status ) );

} // ClusResOpenDriver



NTSTATUS
ClusResDoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    )
/*++

Routine Description:

    Utility routine used to issue a filtering ioctl to the tcpip driver.

Arguments:

    Handle - An open file handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output buffer.

Return Value:

    NT Status Code.

--*/
{
    IO_STATUS_BLOCK    ioStatusBlock;
    NTSTATUS           status;


    ioStatusBlock.Information = 0;

    status = NtDeviceIoControlFile(
                                 Handle,                          // Driver handle
                 NULL,                            // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IoctlCode,                       // Control code
                 Request,                         // Input buffer
                 RequestSize,                     // Input buffer size
                 Response,                        // Output buffer
                 *ResponseSize                    // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     Handle,
                     TRUE,
                     NULL
                     );
    }

    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
        *ResponseSize = (DWORD)ioStatusBlock.Information;
    }
    else {
        *ResponseSize = 0;
    }

    return(status);

} // ClusResDoIoctl


VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    PWCHAR resName = ResourceName;
    DWORD   dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof( ResourceName );

again:
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)resName,
                                   &BufSize );

    if ( Status == ERROR_MORE_DATA ) {
        resName = LocalAlloc( LMEM_FIXED, BufSize );
        if ( resName != NULL ) {
            goto again;
        }

        resName = ResourceName;
        ResourceName[0] = UNICODE_NULL;
    } else if ( Status != ERROR_SUCCESS ) {
        ResourceName[0] = '\0';
    }

    ClusterLogEvent1(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     resName);

    if ( resName != ResourceName ) {
        LocalFree( resName );
    }

    return;

} // ClusResLogEventWithName0


VOID
ClusResLogEventWithName1(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    PWCHAR resName = ResourceName;
    DWORD   dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof( ResourceName );

again:
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)resName,
                                   &BufSize );

    if ( Status == ERROR_MORE_DATA ) {
        resName = LocalAlloc( LMEM_FIXED, BufSize );
        if ( resName != NULL ) {
            goto again;
        }

        resName = ResourceName;
        ResourceName[0] = UNICODE_NULL;
    } else if ( Status != ERROR_SUCCESS ) {
        ResourceName[0] = '\0';
    }

    ClusterLogEvent2(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     resName,
                     Arg1);

    if ( resName != ResourceName ) {
        LocalFree( resName );
    }

    return;
} // ClusResLogEventWithName1

VOID
ClusResLogEventWithName2(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

    Arg2 - Supplies the second insertion string

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    PWCHAR resName = ResourceName;
    DWORD   dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof( ResourceName );

again:
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)resName,
                                   &BufSize );

    if ( Status == ERROR_MORE_DATA ) {
        resName = LocalAlloc( LMEM_FIXED, BufSize );
        if ( resName != NULL ) {
            goto again;
        }

        resName = ResourceName;
        ResourceName[0] = UNICODE_NULL;
    } else if ( Status != ERROR_SUCCESS ) {
        ResourceName[0] = '\0';
    }

    ClusterLogEvent3(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     resName,
                     Arg1,
                     Arg2);

    if ( resName != ResourceName ) {
        LocalFree( resName );
    }

    return;
} // ClusResLogEventWithName2

VOID
ClusResLogEventWithName3(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

    Arg2 - Supplies the second insertion string

    Arg3 - Supplies the third insertion string

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    PWCHAR resName = ResourceName;
    DWORD   dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof( ResourceName );

again:
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)resName,
                                   &BufSize );

    if ( Status == ERROR_MORE_DATA ) {
        resName = LocalAlloc( LMEM_FIXED, BufSize );
        if ( resName != NULL ) {
            goto again;
        }

        resName = ResourceName;
        ResourceName[0] = UNICODE_NULL;
    } else if ( Status != ERROR_SUCCESS ) {
        ResourceName[0] = '\0';
    }

    ClusterLogEvent4(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     resName,
                     Arg1,
                     Arg2,
                     Arg3);

    if ( resName != ResourceName ) {
        LocalFree( resName );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\arbitrat.h ===
/*++

Copyright (c) 1998

Module Name:

    arbitrate.h

Abstract:

    These are the structures and defines that are used in the
    arbitration code.

Authors:

   Gor Nishanov    (t-gorn)       5-Jun-1998
   
Revision History:

--*/
#ifndef ARBITRATE_H
#define ARBITRATE_H

#define DEFAULT_SECTOR_SIZE   512 // must be a power of two //
#define BLOCK_X               11
#define BLOCK_Y               12

DWORD
DiskArbitration(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN HANDLE FileHandle
    );

DWORD
StartPersistentReservations(
      IN OUT PDISK_RESOURCE ResourceEntry,
      IN HANDLE FileHandle
      );

VOID
StopPersistentReservations(
      IN OUT PDISK_RESOURCE ResourceEntry
      );

VOID 
ArbitrationInitialize(
      VOID
      );

VOID 
ArbitrationCleanup(
      VOID
      );

DWORD
ArbitrationInfoInit(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

VOID
ArbitrationInfoCleanup(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

VOID
DestroyArbWorkQueue(
    VOID
    );

DWORD
CreateArbWorkQueue(
      IN RESOURCE_HANDLE ResourceHandle
      );
    

#define ReservationInProgress(ResEntry) ( (ResEntry)->ArbitrationInfo.ControlHandle )

#endif // ARBITRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\common\svc.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    gensvc.c

Abstract:

    Resource DLL to control and monitor NT services.

Author:


    Robs 3/28/96, based on RodGa's generic resource dll

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "svc.h"
#include "localsvc.h"
#include "wincrypt.h"

#define DBG_PRINT printf

typedef struct _COMMON_RESOURCE {
#ifdef COMMON_PARAMS_DEFINED
    COMMON_PARAMS   Params;
#endif
    HRESOURCE       hResource;
    HANDLE          ServiceHandle;
    RESOURCE_HANDLE ResourceHandle;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    CLUS_WORKER     PendingThread;
    BOOL            Online;
    DWORD           dwServicePid;
} COMMON_RESOURCE, * PCOMMON_RESOURCE;

//
// Global Data
//

// Handle to service controller,  set by the first create resource call.

static SC_HANDLE g_ScHandle = NULL;

// Log Event Routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

#ifdef COMMON_SEMAPHORE
static HANDLE CommonSemaphore;
static PCOMMON_RESOURCE CommonResource;
#endif

#ifndef CRYPTO_VALUE_COUNT
static DWORD  CryptoSyncCount = 0;
static LPWSTR CryptoSync[1] = {NULL};
#endif

#ifndef DOMESTIC_CRYPTO_VALUE_COUNT
static DWORD  DomesticCryptoSyncCount = 0;
static LPWSTR DomesticCryptoSync[1] = {NULL};
#endif

//
// Forward routines
//

static
DWORD
CommonOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    );

DWORD
CommonOfflineThread(
    PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    );

static
BOOL
CommonVerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag
    );


static
DWORD
SvcpTerminateServiceProcess(
    IN PCOMMON_RESOURCE pResourceEntry,
    IN BOOL     bOffline,
    OUT PDWORD  pdwResourceState
    );


#ifdef COMMON_ONLINE_THREAD
#define COMMON_ONLINE_THREAD_ROUTINE COMMON_ONLINE_THREAD
#else
#define COMMON_ONLINE_THREAD_ROUTINE CommonOnlineThread
#endif

//
// Local Routines
//


#ifndef COMMON_ONLINE_THREAD
static
DWORD
CommonOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the worker structure

    ResourceEntry - A pointer to the resource entry for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    SERVICE_STATUS_PROCESS      ServiceStatus;
    DWORD                       status = ERROR_SUCCESS;
    RESOURCE_STATUS             resourceStatus;
    DWORD                       valueSize;
    PVOID                       pvEnvironment = NULL;
    HKEY                        hkeyServicesKey;
    HKEY                        hkeyServiceName;
    DWORD                       cbBytesNeeded;
    DWORD                       prevCheckPoint = 0;
    DWORD                       idx;
    LPSERVICE_FAILURE_ACTIONS   pSvcFailureActions = NULL;
    LPQUERY_SERVICE_CONFIG      lpquerysvcconfig=NULL;
    RESOURCE_EXIT_STATE         exitState;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    if ( ResourceEntry != CommonResource ) {
        return(ERROR_SUCCESS);
    }

    //set it to NULL, when it is brought online and if the
    //service is not running in the system or lsa process
    //then store the process id for forced termination
    ResourceEntry->dwServicePid = 0;

#if ENVIRONMENT

    //
    // Create the new environment with the simulated net name when the
    // services queries GetComputerName.
    //
    pvEnvironment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    if ( pvEnvironment != NULL ) {

        WCHAR *         pszEnvString;

        //
        // Compute the size of the environment. We are looking for
        // the double NULL terminator that ends the environment block.
        //
        pszEnvString = (WCHAR *)pvEnvironment;
        while (*pszEnvString) {
            while (*pszEnvString++) {
            }
        }
        valueSize = (DWORD)((PUCHAR)pszEnvString - (PUCHAR)pvEnvironment) + sizeof(WCHAR);
    }

    //
    // Set the environment value in the service's registry key.
    //

    status = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                            LOCAL_SERVICES,
                            0,
                            KEY_READ,
                            &hkeyServicesKey );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open services key, error = %1!u!.\n",
            status );
        goto error_exit;
    }
    status = RegOpenKeyExW( hkeyServicesKey,
                            SERVICE_NAME,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkeyServiceName );
    RegCloseKey( hkeyServicesKey );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service key, error = %1!u!.\n",
            status );
        goto error_exit;
    }
    status = RegSetValueExW( hkeyServiceName,
                             L"Environment",
                             0,
                             REG_MULTI_SZ,
                             pvEnvironment,
                             valueSize );

    RegCloseKey( hkeyServiceName );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to set service environment value, error = %1!u!.\n",
            status );
        goto error_exit;
    }

#endif //ENVIRONMENT

    //
    // Now open the requested service
    //
    ResourceEntry->ServiceHandle = OpenService( g_ScHandle,
                                                SERVICE_NAME,
                                                SERVICE_ALL_ACCESS );

    if ( ResourceEntry->ServiceHandle == NULL ) {
        status = GetLastError();

        ClusResLogSystemEventByKeyData( ResourceEntry->ResourceKey,
                                  LOG_CRITICAL,
                                  RES_GENSVC_OPEN_FAILED,
                                  sizeof(status),
                                  &status );
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    valueSize = sizeof(QUERY_SERVICE_CONFIG);
AllocSvcConfig:
    // Query the service to make sure it is not disabled
    lpquerysvcconfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc( LMEM_FIXED, valueSize );
    if ( lpquerysvcconfig == NULL ){
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[Svc] Failed to allocate memory for query_service_config, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    
    if ( ! QueryServiceConfig(
                    ResourceEntry->ServiceHandle,
                    lpquerysvcconfig,
                    valueSize,
                    &cbBytesNeeded ) )
    {
        status=GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER){
            (g_LogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_ERROR,
                 L"svc: Failed to query service configuration, error= %1!u!.\n",
                 status );
            goto error_exit;
         }
        
        status=ERROR_SUCCESS; 
        LocalFree( lpquerysvcconfig );
        lpquerysvcconfig=NULL;
        valueSize = cbBytesNeeded;
        goto AllocSvcConfig;
    }
        
    if ( lpquerysvcconfig->dwStartType == SERVICE_DISABLED )
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"svc:The service is DISABLED\n");
        status=ERROR_SERVICE_DISABLED;
        goto error_exit;
    }

    //
    // Make sure service is set to manual start.
    //
    ChangeServiceConfig( ResourceEntry->ServiceHandle,
                         SERVICE_NO_CHANGE,
                         SERVICE_DEMAND_START, // Manual start
                         SERVICE_NO_CHANGE,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL );


    // Use valuesize as the dummy buffer since the queryserviceconfig2
    // api is not that friendly.
    // If any of the service action is set to service restart, set it to
    // none
    if ( ! (QueryServiceConfig2(
                    ResourceEntry->ServiceHandle,
                    SERVICE_CONFIG_FAILURE_ACTIONS,
                    (LPBYTE)&valueSize,
                    sizeof(DWORD),
                    &cbBytesNeeded )) )
    {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER )
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"svc: Failed to query service configuration for size, error= %1!u!.\n",
                status );
            goto error_exit;
        }
        else
            status = ERROR_SUCCESS;
    }

    pSvcFailureActions = (LPSERVICE_FAILURE_ACTIONS)LocalAlloc( LMEM_FIXED, cbBytesNeeded );

    if ( pSvcFailureActions == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate memory of size %1!u!, error = %2!u!.\n",
            cbBytesNeeded,
            status );
        goto error_exit;
    }

    if ( ! (QueryServiceConfig2(
                    ResourceEntry->ServiceHandle,
                    SERVICE_CONFIG_FAILURE_ACTIONS,
                    (LPBYTE)pSvcFailureActions,
                    cbBytesNeeded,
                    &cbBytesNeeded )) )
    {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"svc:Failed to query service configuration, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    for ( idx=0; idx < pSvcFailureActions->cActions; idx++ )
    {
        if ( pSvcFailureActions->lpsaActions[idx].Type == SC_ACTION_RESTART ) {
            pSvcFailureActions->lpsaActions[idx].Type = SC_ACTION_NONE;
        }
    }
    ChangeServiceConfig2(
            ResourceEntry->ServiceHandle,
            SERVICE_CONFIG_FAILURE_ACTIONS,
            pSvcFailureActions );

#ifdef COMMON_ONLINE_THREAD_CALLBACK
    //
    // Allow the resource DLL to perform some operations before the service
    // is started, such as setting registry keys, etc.
    //
    status = CommonOnlineThreadCallback( ResourceEntry );
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }
#endif // COMMON_ONLINE_THREAD_CALLBACK

    if ( ! StartServiceW(
                    ResourceEntry->ServiceHandle,
                    0,
                    NULL ) ) {

        status = GetLastError();

        if (status != ERROR_SERVICE_ALREADY_RUNNING) {

            ClusResLogSystemEventByKeyData( ResourceEntry->ResourceKey,
                                      LOG_CRITICAL,
                                      RES_GENSVC_START_FAILED,
                                      sizeof(status),
                                      &status );
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Failed to start %1!ws! service. Error: %2!u!.\n",
                         SERVICE_NAME,
                         status );
            goto error_exit;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    while ( ! ClusWorkerCheckTerminate( &ResourceEntry->PendingThread ) )  {
        if ( ! QueryServiceStatusEx(
                    ResourceEntry->ServiceHandle,
                    SC_STATUS_PROCESS_INFO,
                    (LPBYTE)&ServiceStatus, 
                    sizeof(SERVICE_STATUS_PROCESS),
                    &cbBytesNeeded ) ) {
            
            status = GetLastError();

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Query Service Status failed %1!u!.\n",
                status );
            resourceStatus.ResourceState = ClusterResourceFailed;
            goto error_exit;
        }

        if ( ServiceStatus.dwCurrentState != SERVICE_START_PENDING ) {
            break;
        }
        if ( prevCheckPoint != ServiceStatus.dwCheckPoint ) {
            prevCheckPoint = ServiceStatus.dwCheckPoint;
            ++resourceStatus.CheckPoint;
        }
        exitState = (g_SetResourceStatus)(
                            ResourceEntry->ResourceHandle,
                            &resourceStatus );
        if ( exitState == ResourceExitStateTerminate ) {
            break;
        }

        Sleep( 500 );     // Sleep for 1/2 second
    }

    //
    // Assume that we failed.
    //
    resourceStatus.ResourceState = ClusterResourceFailed;

    //
    // If we exited the loop before setting ServiceStatus, then return now.
    //
    if ( ClusWorkerCheckTerminate( &ResourceEntry->PendingThread ) )  {
        goto error_exit;
    }

    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING ) {
        
        if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
            status = ServiceStatus.dwServiceSpecificExitCode;
        } else {
            status = ServiceStatus.dwWin32ExitCode;
        }

        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                 LOG_CRITICAL,
                                 RES_GENSVC_FAILED_AFTER_START,
                                 sizeof(status),
                                 &status);
        (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Service failed during initialization. Error: %1!u!.\n",
                status );

        goto error_exit;
    }

    resourceStatus.ResourceState = ClusterResourceOnline;
    if ( ! (ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS) ) {
        ResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
    }

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Service is now on line.\n" );

error_exit:

    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }

    if(lpquerysvcconfig)
        LocalFree(lpquerysvcconfig);
    if (pSvcFailureActions) 
        LocalFree(pSvcFailureActions);

#if ENVIRONMENT

    if ( pvEnvironment != NULL ) {
        RtlDestroyEnvironment( pvEnvironment );
    }

#endif

    return(status);

} // CommonOnlineThread
#endif


static
RESID
WINAPI
CommonOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic service resource.
    This routine gets a handle to the service controller, if we don't already have one,
    and then gets a handle to the specified service.  The service handle is saved
    in the COMMON structure.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    RESID   svcResid = 0;
    DWORD   status;
    HKEY    parametersKey = NULL;
    HKEY    resKey = NULL;
    PCOMMON_RESOURCE resourceEntry = NULL;
    DWORD   paramNameSize = 0;
    DWORD   paramNameMaxSize = 0;
    HCLUSTER hCluster;
    DWORD   returnSize;
    DWORD   idx;

    //
    // Open registry parameters key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                L"Parameters",
                                KEY_READ,
                                &parametersKey );

    if ( status != NO_ERROR ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key. Error: %1!u!.\n",
            status);
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // First get a handle to the service controller.
    //

    if ( g_ScHandle == NULL ) {

        g_ScHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS);

        if ( g_ScHandle == NULL ) {
            status = GetLastError();
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to open service control manager, error = %1!u!.\n",
                status);
            goto error_exit;
        }
    }

    resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(COMMON_RESOURCE) );

    if ( resourceEntry == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a service info structure.\n");
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEntry, sizeof(COMMON_RESOURCE) );

    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;

    hCluster = OpenCluster(NULL);
    if ( hCluster == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open cluster, error %1!u!.\n",
            status );
        goto error_exit;
    }
    resourceEntry->hResource = OpenClusterResource( hCluster, ResourceName );
    status = GetLastError();
    CloseCluster( hCluster );
    if ( resourceEntry->hResource == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource, error %1!u!.\n",
            status );
        goto error_exit;
    }

    //
    // Set any registry checkpoints that we need.
    //
    if ( RegSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < RegSyncCount; idx++ ) {
            status = ClusterResourceControl( resourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                                             RegSync[idx],
                                             (lstrlenW( RegSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if ( status == ERROR_ALREADY_EXISTS ){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set registry checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set any crypto checkpoints that we need.
    //
    if ( CryptoSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < CryptoSyncCount; idx++ ) {
            status = ClusterResourceControl( resourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                             CryptoSync[idx],
                                             (lstrlenW( CryptoSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if (status == ERROR_ALREADY_EXISTS){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set crypto checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set any domestic crypto checkpoints that we need.
    //
    if ( DomesticCryptoSyncCount != 0 ) {
        HCRYPTPROV hProv = 0;
        //
        // check if domestic crypto is available
        //
        if (CryptAcquireContextA( &hProv,
                                  NULL,
                                  MS_ENHANCED_PROV_A,
                                  PROV_RSA_FULL,
                                  CRYPT_VERIFYCONTEXT)) {
            CryptReleaseContext( hProv, 0 );
            returnSize = 0;
            //
            // Set registry sync keys if we need them.
            //
            for ( idx = 0; idx < DomesticCryptoSyncCount; idx++ ) {
                status = ClusterResourceControl( resourceEntry->hResource,
                                                 NULL,
                                                 CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                                 DomesticCryptoSync[idx],
                                                 (lstrlenW( DomesticCryptoSync[idx] ) + 1) * sizeof(WCHAR),
                                                 NULL,
                                                 0,
                                                 &returnSize );
                if ( status != ERROR_SUCCESS ){
                    if (status == ERROR_ALREADY_EXISTS){
                        status = ERROR_SUCCESS;
                    }
                    else{
                        (g_LogEvent)(
                            resourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"Failed to set domestic crypto checkpoint, status %1!u!.\n",
                            status );
                        goto error_exit;
                    }
                }
            }
        }
    }
#ifdef COMMON_PARAMS_DEFINED
    //
    // Get any parameters... so we can handle the GET_DEPENDENCIES request.
    //
    CommonReadParameters( resourceEntry );
    // ignore status return
#endif // COMMON_PARAMS_DEFINED

#ifdef COMMON_SEMAPHORE
    //
    // Check if more than one resource of this type.
    //
    if ( WaitForSingleObject( CommonSemaphore, 0 ) == WAIT_TIMEOUT ) {
        //
        // A version of this service is already running
        //
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Service is already running.\n");
        status = ERROR_SERVICE_ALREADY_RUNNING;
        goto error_exit;
    }

    if ( CommonResource ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Service resource info non-null!\n");
        status = ERROR_DUPLICATE_SERVICE_NAME;
        goto error_exit;
    }

    CommonResource = resourceEntry;

#endif // COMMON_SEMAPHORE

    svcResid = (RESID)resourceEntry;
    return(svcResid);

error_exit:

    LocalFree( resourceEntry );

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }
    if ( resKey != NULL) {
        ClusterRegCloseKey( resKey );
    }

    SetLastError( status );

    return((RESID)NULL);

} // CommonOpen


static
DWORD
WINAPI
CommonOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Common Service resource.

Arguments:

    ResourceId - Supplies resource id to be brought online

    EventHandle - Supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    DWORD   status;
    PCOMMON_RESOURCE resourceEntry;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry != CommonResource ) {
        DBG_PRINT( "Common: Online request for wrong resource, 0x%p.\n",
                    ResourceId );
    }

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Online request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               COMMON_ONLINE_THREAD_ROUTINE,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // CommonOnline


static
VOID
WINAPI
CommonTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Common Service resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    SERVICE_STATUS      ServiceStatus;
    PCOMMON_RESOURCE    resourceEntry;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry != CommonResource ) {
        DBG_PRINT( "Common: Offline request for wrong resource, 0x%p.\n",
                    ResourceId );
        return;
    }

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Offline request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Offline request.\n" );

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    if ( resourceEntry->ServiceHandle != NULL ) {

        DWORD retryTime = 30*1000;  // wait 30 secs for shutdown
        DWORD retryTick = 300;      // 300 msec at a time
        DWORD status;
        BOOL  didStop = FALSE;

        for (;;) {

            status = (ControlService(
                            resourceEntry->ServiceHandle,
                            (didStop
                             ? SERVICE_CONTROL_INTERROGATE
                             : SERVICE_CONTROL_STOP),
                            &ServiceStatus )
                      ? NO_ERROR
                      : GetLastError());

            if (status == NO_ERROR) {

                didStop = TRUE;

                if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"Service stopped.\n" );
                    //set the status                                    
                    resourceEntry->Online = FALSE;
                    resourceEntry->dwServicePid = 0;
                    break;
                }
            }

            //
            // Chittur Subbaraman (chitturs) - 2/21/2000
            //
            // Since SCM doesn't accept any control requests during
            // windows shutdown, don't send any more control
            // requests. Just exit from this loop and terminate
            // the process brute force.
            //
            if (status == ERROR_SHUTDOWN_IN_PROGRESS)
			{
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"System shutdown in progress. Will try to terminate the process...\n");
                break;
            }

            if (status == ERROR_EXCEPTION_IN_SERVICE ||
                status == ERROR_PROCESS_ABORTED ||
                status == ERROR_SERVICE_NOT_ACTIVE) {

                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service died; status = %1!u!.\n",
                    status);
                //set the status                                    
                resourceEntry->Online = FALSE;
                resourceEntry->dwServicePid = 0;
                break;

            }

            if ((retryTime -= retryTick) <= 0) {

                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Service did not stop; giving up.\n" );

                break;
            }

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Offline: retrying...\n" );

            Sleep(retryTick);
        }

        //if there is a pid for this, try and terminate that process
        //note that terminating a process doesnt terminate all
        //the child processes
        if (resourceEntry->dwServicePid)
        {
            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"SvcTerminate: terminating processid =%1!u!\n",
                resourceEntry->dwServicePid);
            SvcpTerminateServiceProcess( resourceEntry,
                                         FALSE,
                                         NULL );
        }                
        CloseServiceHandle( resourceEntry->ServiceHandle );
        resourceEntry->ServiceHandle = NULL;
        resourceEntry->dwServicePid = 0;
    }

    resourceEntry->Online = FALSE;

} // CommonTerminate

static
DWORD
WINAPI
CommonOffline(
    IN RESID ResourceId
    )
/*++

Routine Description:

    Offline routine for Common Service resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/
{
    PCOMMON_RESOURCE resourceEntry;
    DWORD            status;


    resourceEntry = (PCOMMON_RESOURCE)ResourceId;
    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Offline request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry != CommonResource ) {
        DBG_PRINT( "Common: Offline request for wrong resource, 0x%p.\n",
                    ResourceId );
        return(ERROR_INVALID_PARAMETER);
    }

    (g_LogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Offline request.\n" );

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               CommonOfflineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);
}



static
DWORD
CommonOfflineThread(
    PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Offline routine for Common Service resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/
{
    RESOURCE_STATUS resourceStatus;
    DWORD           retryTick = 300;      // 300 msec at a time
    DWORD           status = ERROR_SUCCESS;
    BOOL            didStop = FALSE;
    SERVICE_STATUS  ServiceStatus;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    //check if the service has gone offline or was never brought online
    if ( ResourceEntry->ServiceHandle == NULL )
    {
        resourceStatus.ResourceState = ClusterResourceOffline;
        goto FnExit;
    }

    //try to stop the cluster service, wait for it to be terminated
    //as long as we are not asked to terminate
    while (!ClusWorkerCheckTerminate(pWorker)) {


        status = (ControlService(
                        ResourceEntry->ServiceHandle,
                        (didStop
                         ? SERVICE_CONTROL_INTERROGATE
                         : SERVICE_CONTROL_STOP),
                        &ServiceStatus )
                  ? NO_ERROR
                  : GetLastError());

        if (status == NO_ERROR) {

            didStop = TRUE;

            if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service stopped.\n" );

                //set the status                                    
                ResourceEntry->Online = FALSE;
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service is now offline.\n" );
                break;
            }
        }

        //
        // Chittur Subbaraman (chitturs) - 2/21/2000
        //
        // Since SCM doesn't accept any control requests during
        // windows shutdown, don't send any more control
        // requests. Just exit from this loop and terminate
        // the process brute force.
        //
        if (status == ERROR_SHUTDOWN_IN_PROGRESS)
        {
            DWORD   dwResourceState;
 
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: System shutting down. Attempt to terminate service process %1!u!...\n",
                ResourceEntry->dwServicePid );

            status = SvcpTerminateServiceProcess( ResourceEntry,
                                                  TRUE,
                                                  &dwResourceState );

            if ( status == ERROR_SUCCESS )
            {
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                ResourceEntry->Online = FALSE;
            }
            resourceStatus.ResourceState = dwResourceState;
            break;
        }

        if (status == ERROR_EXCEPTION_IN_SERVICE ||
            status == ERROR_PROCESS_ABORTED ||
            status == ERROR_SERVICE_NOT_ACTIVE) {

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service died or not active any more; status = %1!u!.\n",
                status);
                
            //set the status                                    
            ResourceEntry->Online = FALSE;
            resourceStatus.ResourceState = ClusterResourceOffline;
            CloseServiceHandle( ResourceEntry->ServiceHandle );
            ResourceEntry->ServiceHandle = NULL;
            ResourceEntry->dwServicePid = 0;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service is now offline.\n" );
            break;

        }

        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Offline: retrying...\n" );

        Sleep(retryTick);
    }


FnExit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return(status);

}
// CommonOfflineThread


static
BOOL
WINAPI
CommonIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Common service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - if service is running

    FALSE - if service is in any other state

--*/
{

    return( CommonVerifyService( ResourceId, TRUE ) );

} // CommonIsAlive



static
BOOL
CommonVerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag)

/*++

Routine Description:

        Verify that a specified service is running

Arguments:

        ResourceId - Supplies the resource id
        IsAliveFlag - Says this is an IsAlive call - used only for debug print

Return Value:

        TRUE - if service is running or starting

        FALSE - service is in any other state

--*/
{
    SERVICE_STATUS ServiceStatus;
    PCOMMON_RESOURCE resourceEntry;
    DWORD   status = TRUE;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry != CommonResource ) {
        DBG_PRINT( "Common: IsAlive request for wrong resource 0x%p.\n",
                   ResourceId );
        return(FALSE);
    }

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: IsAlive request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(FALSE);
    }

    if ( !QueryServiceStatus( resourceEntry->ServiceHandle,
                              &ServiceStatus ) ) {

         (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Query Service Status failed %1!u!.\n",
            GetLastError() );
         return(FALSE);
    }

//
//  Now check the status of the service
//

  if ((ServiceStatus.dwCurrentState != SERVICE_RUNNING)&&(ServiceStatus.dwCurrentState != SERVICE_START_PENDING)){
      status = FALSE;
   }
   if (!status) {
       (g_LogEvent)(
          resourceEntry->ResourceHandle,
          LOG_ERROR,
          L"Failed the IsAlive test. Current State is %1!u!.\n",
          ServiceStatus.dwCurrentState );
   }
    return(status);

} // Verify Service


static
BOOL
WINAPI
CommonLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Common Service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return( CommonVerifyService( ResourceId, FALSE ) );

} // CommonLooksAlive



static
VOID
WINAPI
CommonClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Common Services resource.
    This routine will stop the service, and delete the cluster
    information regarding that service.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PCOMMON_RESOURCE resourceEntry;
    DWORD   errorCode;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );

    //
    // Shut it down if it's on line
    //

    CommonTerminate( ResourceId );
    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );

#ifdef COMMON_SEMAPHORE
    if ( resourceEntry == CommonResource ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Setting Semaphore %1!ws!.\n",
            COMMON_SEMAPHORE );
        CommonResource = NULL;
        ReleaseSemaphore( CommonSemaphore, 1 , NULL );
    }
#endif

    LocalFree( resourceEntry );

} // CommonClose



static
DWORD
SvcpTerminateServiceProcess(
    IN PCOMMON_RESOURCE pResourceEntry,
    IN BOOL     bOffline,
    OUT PDWORD  pdwResourceState
    )

/*++

Routine Description:

    Attempts to terminate a service process.

Arguments:

    pResourceEntry - Gensvc resource structure.

    bOffline - Called from the offline thread or not.

    pdwResourceState - State of the gensvc resource.

Return Value:

    ERROR_SUCCESS - The termination was successful.

    Win32 error - Otherwise.

--*/

{
    HANDLE  hSvcProcess = NULL;
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOLEAN bWasEnabled;
    DWORD   dwResourceState = ClusterResourceFailed;

    //
    //  Chittur Subbaraman (chitturs) - 2/23/2000
    //
    (g_LogEvent)(
        pResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SvcpTerminateServiceProcess: Process with id=%1!u! might be terminated...\n",
        pResourceEntry->dwServicePid );

    //
    //  Adjust the privilege to allow debug. This is to allow
    //  termination of a service process which runs in a local 
    //  system account from a different service process which runs in a 
    //  domain user account.
    //
    dwStatus = ClRtlEnableThreadPrivilege( SE_DEBUG_PRIVILEGE,
                                           &bWasEnabled );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SvcpTerminateServiceProcess: Unable to set debug privilege for process with id=%1!u!, status=%2!u!...\n",
            pResourceEntry->dwServicePid,
            dwStatus );
        goto FnExit;
    }
                
    hSvcProcess = OpenProcess( PROCESS_TERMINATE, 
                               FALSE, 
                               pResourceEntry->dwServicePid );
				                           
    if ( !hSvcProcess ) 
    {
        //
        //  Did this happen because the process terminated
        //  too quickly after we sent out one control request ?
        //
        dwStatus = GetLastError();
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SvcpTerminateServiceProcess: Unable to open pid=%1!u! for termination, status=%2!u!...\n",
            pResourceEntry->dwServicePid,
            dwStatus );
        goto FnRestoreAndExit;
    }

    if ( !bOffline )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SvcpTerminateServiceProcess: Pid=%1!u! will be terminated brute force...\n",
            pResourceEntry->dwServicePid );
        goto skip_waiting;
    }
    
    if ( WaitForSingleObject( hSvcProcess, 3000 ) 
               == WAIT_OBJECT_0 )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SvcpTerminateServiceProcess: Process with id=%1!u! shutdown gracefully...\n",
            pResourceEntry->dwServicePid );
        dwResourceState = ClusterResourceOffline;
        dwStatus = ERROR_SUCCESS;
        goto FnRestoreAndExit;
    }

skip_waiting:
    if ( !TerminateProcess( hSvcProcess, 0 ) ) 
    {
        dwStatus = GetLastError();
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SvcpTerminateServiceProcess: Unable to terminate process with id=%1!u!, status=%2!u!...\n",
            pResourceEntry->dwServicePid,
            dwStatus );
        goto FnRestoreAndExit;
    } 

    dwResourceState = ClusterResourceOffline;

FnRestoreAndExit:
    ClRtlRestoreThreadPrivilege( SE_DEBUG_PRIVILEGE,
                                 bWasEnabled );

FnExit:
    if ( hSvcProcess )
    {
        CloseHandle( hSvcProcess );
    }
       
    if ( ARGUMENT_PRESENT( pdwResourceState ) )
    {
        *pdwResourceState = dwResourceState;
    }

    (g_LogEvent)(
        pResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SvcpTerminateServiceProcess: Process id=%1!u!, status=%2!u!, state=%3!u!...\n",
        pResourceEntry->dwServicePid,
        dwStatus,
        dwResourceState );
    
    return( dwStatus );
} // SvcpTerminateServiceProcess


#ifdef COMMON_CONTROL

static
DWORD
CommonGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for common service resources.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    PCOMMON_DEPEND_SETUP pdepsetup = CommonDependSetup;
    PCOMMON_DEPEND_DATA pdepdata = (PCOMMON_DEPEND_DATA)OutBuffer;
    CLUSPROP_BUFFER_HELPER value;
    DWORD       status;
    
    *BytesReturned = sizeof(COMMON_DEPEND_DATA);
    if ( OutBufferSize < sizeof(COMMON_DEPEND_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( OutBuffer, sizeof(COMMON_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 ) {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat ) {

            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
                value.pULargeIntegerValue->li.LowPart = 
                    (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return(status);

} // CommonGetRequiredDependencies



static
DWORD
CommonGetRegistryCheckpoints(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS control function
    for common service resources.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       i;
    DWORD       totalBufferLength = 0;
    LPWSTR      psz = OutBuffer;

    // Build a Multi-sz string.

    //
    // Calculate total buffer length needed.
    //
    for ( i = 0; i < RegSyncCount; i++ ) {
        totalBufferLength += (lstrlenW( RegSync[i] ) + 1) * sizeof(WCHAR);
    }

    if ( !totalBufferLength ) {
        *BytesReturned = 0;
        return(ERROR_SUCCESS);
    }

    totalBufferLength += sizeof(UNICODE_NULL);

    *BytesReturned = totalBufferLength;

    if ( OutBufferSize < totalBufferLength ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        //ZeroMemory( OutBuffer, totalBufferLength );

        for ( i = 0; i < RegSyncCount; i++ ) {
            lstrcpyW( psz, RegSync[i] );
            psz += lstrlenW( RegSync[i] ) + 1;
        }

        *psz = L'\0';
        status = ERROR_SUCCESS;
    }

    return(status);

} // CommonGetRegistryCheckpoints



static
DWORD
CommonGetCryptoCheckpoints(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS control function
    for common service resources.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       i;
    DWORD       totalBufferLength = 0;
    LPWSTR      psz = OutBuffer;

    // Build a Multi-sz string.

    //
    // Calculate total buffer length needed.
    //
    for ( i = 0; i < CryptoSyncCount; i++ ) {
        totalBufferLength += (lstrlenW( CryptoSync[i] ) + 1) * sizeof(WCHAR);
    }

    if ( !totalBufferLength ) {
        *BytesReturned = 0;
        return(ERROR_SUCCESS);
    }

    totalBufferLength += sizeof(UNICODE_NULL);

    *BytesReturned = totalBufferLength;

    if ( OutBufferSize < totalBufferLength ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        //ZeroMemory( OutBuffer, totalBufferLength );

        for ( i = 0; i < CryptoSyncCount; i++ ) {
            lstrcpyW( psz, CryptoSync[i] );
            psz += lstrlenW( CryptoSync[i] ) + 1;
        }

        *psz = L'\0';
        status = ERROR_SUCCESS;
    }

    return(status);

} // CommonGetCryptoCheckpoints



static
DWORD
WINAPI
CommonResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Common Virtual Root resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    PCOMMON_RESOURCE  resourceEntry = NULL;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = CommonGetRequiredDependencies( OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned
                                                    );
            break;

        case CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS:
            status = CommonGetRegistryCheckpoints( OutBuffer,
                                                   OutBufferSize,
                                                   BytesReturned
                                                   );
            break;

        case CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS:
            status = CommonGetCryptoCheckpoints( OutBuffer,
                                                 OutBufferSize,
                                                 BytesReturned
                                                 );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // CommonResourceControl



static
DWORD
WINAPI
CommonResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Common Virtual Root resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = CommonGetRequiredDependencies( OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned
                                                    );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REGISTRY_CHECKPOINTS:
            status = CommonGetRegistryCheckpoints( OutBuffer,
                                                   OutBufferSize,
                                                   BytesReturned
                                                   );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CRYPTO_CHECKPOINTS:
            status = CommonGetCryptoCheckpoints( OutBuffer,
                                                   OutBufferSize,
                                                   BytesReturned
                                                   );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // CommonResourceTypeControl

#endif // COMMON_CONTROL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\arbitrat.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    arbitrat.c

Abstract:

    DiskArbitration, DiskReservationThread

Author:

    Gor Nishanov    (gorn)    5-Jun-1998

Revision History:

   gorn: different arbitration algorithm implemented

--*/

//
// Cannot use DoReserve/Release/BreakReserve from
// filter.c . Because of hold io we won't be
// able to open \Device\HarddiskX\ParitionY device
//

#define DoReserve DoReserve_don_t_use
#define DoRelease DoRelease_don_t_use
#define DoBreakReserve DoBreakReserve_don_t_use

#include "disksp.h"
#include "lmcons.h"

#include "diskarbp.h"
#include "arbitrat.h"
#include "newmount.h"

#undef DoReserve
#undef DoRelease
#undef DoBreakReserve

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

#define DISKARB_MAX_WORK_THREADS      1
#define DISKARB_WORK_THREAD_PRIORITY  THREAD_PRIORITY_ABOVE_NORMAL

#define ARBITRATION_ATTEMPTS_SZ "ArbitrationAttempts"
#define ARBITRATION_SLEEP_SZ    "ArbitrationSleepBeforeRetry"

#define RESERVATION_TIMER  (1000*RESERVE_TIMER) // Reservation timer in milliseconds      //
                                                // RESERVE_TIMER is defined in diskarbp.h //

#define WAIT_FOR_RESERVATION_TO_BE_RESTORED      (RESERVATION_TIMER + 2000)
#define BUS_SETTLE_TIME                          (2000)
#define FAST_MUTEX_DELAY                         (1000)

#define DEFAULT_SLEEP_BEFORE_RETRY               (9999)
#define MIN_SLEEP_BEFORE_RETRY                   (0)
#define MAX_SLEEP_BEFORE_RETRY                   (30000)

#define DEFAULT_ARBITRATION_ATTEMPTS             (1)
#define MIN_ARBITRATION_ATTEMPTS                 (1)
#define MAX_ARBITRATION_ATTEMPTS                 (9)

//
// Variables Local To Arbitration Module
//

static DWORD             ArbitrationAttempts           = DEFAULT_ARBITRATION_ATTEMPTS;
static DWORD             ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;
static CRITICAL_SECTION  ArbitrationLock;
static PCLRTL_WORK_QUEUE WorkQueue = 0;
static BOOLEAN           AllGlobalsInitialized = FALSE;
static BOOLEAN           LegacyMode = FALSE;
static UCHAR             NodeName[MAX_COMPUTERNAME_LENGTH + 1];

enum { NAME_LENGTH = min(MAX_COMPUTERNAME_LENGTH,
                         sizeof ( ((PARBITRATION_ID)0)->NodeSignature ) ) };

DWORD
ArbitrateOnce(
    IN PDISK_RESOURCE ResourceEntry,
    IN HANDLE         FileHandle,
    LPVOID            buf
    );

DWORD
VerifySectorSize(
      IN OUT PDISK_RESOURCE ResourceEntry,
      IN HANDLE             FileHandle
      );

DWORD
DoReadWrite(
      IN PDISK_RESOURCE ResourceEntry,
      IN ULONG Operation,
      IN HANDLE FileHandle,
      IN DWORD BlockNumber,
      IN PVOID Buffer
      );

DWORD
DiskReservationThread(
    IN PDISK_RESOURCE ResourceEntry
    );

VOID
ReadArbitrationParameters(
    VOID
    );

DWORD
AsyncCheckReserve(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

DWORD
DoArbEscape(
    IN PDISK_RESOURCE  ResourceEntry,   
    IN HANDLE FileHandle,
    IN ULONG Operation,
    IN PWCHAR OperationName,
    IN PVOID OutBuffer,
    IN ULONG OutBufferSize
    );
    

#define DoBlockRead(RE,FH,BN,BUF)  DoReadWrite(RE, AE_READ, FH, BN, BUF)
#define DoBlockWrite(RE,FH,BN,BUF) DoReadWrite(RE, AE_WRITE, FH, BN, BUF)
#define DoReserve(FH,RE)         DoArbEscape(RE,FH,AE_RESERVE,L"Reserve",NULL,0)
#define DoRelease(FH,RE)         DoArbEscape(RE,FH,AE_RELEASE,L"Release",NULL,0)
#define DoBreakReserve(FH,RE)    DoArbEscape(RE,FH,AE_RESET,L"BusReset",NULL,0)
#define GetSectorSize(RE,FH,buf) DoArbEscape(RE,FH,AE_SECTORSIZE,L"GetSectorSize",buf,sizeof(ULONG) )
#define PokeDiskStack(RE,FH)     DoArbEscape(RE,FH,AE_POKE,L"GetPartInfo",NULL,0)


#define OldFashionedRIP(ResEntry) \
  ( ( (ResEntry)->StopTimerHandle != NULL) || ( (ResEntry)->DiskInfo.ControlHandle != NULL) )

/**************************************************************************************/

VOID
ArbitrationInitialize(
      VOID
      )
/*++
Routine Description:
  To be called from DllProcessAttach
Arguments:
Return Value:
--*/

{
   InitializeCriticalSection( &ArbitrationLock );

   //
   // Read ArbitrationAttempts and ArbitratationSleepBeforeRetry from the registry
   //
   ReadArbitrationParameters();
}

VOID
ArbitrationCleanup(
      VOID
      )
/*++
Routine Description:
  To be called from DllProcessDetach
Arguments:
Return Value:
--*/
{
   DeleteCriticalSection( &ArbitrationLock );
}


VOID
DestroyArbWorkQueue(
    VOID
    )
/*++
Routine Description:
  To be called from DllProcessDetach
Arguments:
Return Value:
--*/
{
   if (WorkQueue) {
      ClRtlDestroyWorkQueue(WorkQueue);
      WorkQueue = NULL;
   }
}

DWORD
CreateArbWorkQueue(
      IN RESOURCE_HANDLE ResourceHandle
      )
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
   if (WorkQueue) {
      return ERROR_SUCCESS;
   }
   //
   // Create a work queue to process overlapped I/O completions
   //
   WorkQueue = ClRtlCreateWorkQueue(
                            DISKARB_MAX_WORK_THREADS,
                            DISKARB_WORK_THREAD_PRIORITY
                   );

   if (WorkQueue == NULL) {
       DWORD status = GetLastError();
       (DiskpLogEvent)(
           ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] Unable to create work queue. Error: %1!u!.\n",
           status );
       return status;
   }
   return ERROR_SUCCESS;
}

DWORD ArbitrationInitializeGlobals(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++
Routine Description:
   Additional initialization of global variables.
   The ones that might fail and we want to
   to log the failure.

   Otherwise we could have just added the stuff we are doing here
   to ArbitrationInitialize which is called from DllEntryPoint.

   Currently we are using it only to initialize ArbitrationWork queue.

   Called with ArbitrationLock held
Arguments:
Return Value:
--*/
{
   DWORD status;
   DWORD NameSize;

   NameSize = sizeof(NodeName);
   RtlZeroMemory(NodeName, NameSize);
   if( !GetComputerName( NodeName, &NameSize ) ) {
      status = GetLastError();
      (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_ERROR,
          L"[Arb] GetComputerName failed, error %1!u!.\n", status);
      return status;
   }

   LegacyMode = FALSE;

   AllGlobalsInitialized = TRUE;
   return ERROR_SUCCESS;
}

DWORD
ArbitrationInfoInit(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
{
   DWORD status = ERROR_SUCCESS;
   EnterCriticalSection( &ArbitrationLock );
    if (!AllGlobalsInitialized) {
       status = ArbitrationInitializeGlobals(ResourceEntry);
    }
   LeaveCriticalSection( &ArbitrationLock );
   if(status != ERROR_SUCCESS) {
      return status;
   }

   InitializeCriticalSection( &(ResourceEntry->ArbitrationInfo.DiskLock) );
   return ERROR_SUCCESS;
}

VOID
ArbitrationInfoCleanup(
   IN OUT PDISK_RESOURCE ResourceEntry
   )
{
   (DiskpLogEvent)(
       ResourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"[DiskArb] ArbitrationInfoCleanup.\n");
   DeleteCriticalSection( &(ResourceEntry->ArbitrationInfo.DiskLock) );
   return;
}

BOOL
DoesNotNeedExpensiveReservations(
    IN  PDISK_RESOURCE ResourceEntry)
{
    return (ResourceEntry->LostQuorum) == NULL;
}

void
ComputeArbitrationId(
      IN  PDISK_RESOURCE ResourceEntry,
      OUT PARBITRATION_ID UniqueId
      )
/*++

Routine Description:
Arguments:
Return Value:

--*/
{
      RtlZeroMemory(UniqueId, sizeof(ARBITRATION_ID));
      GetSystemTimeAsFileTime( (LPFILETIME) &(UniqueId->SystemTime) );
      RtlCopyMemory(UniqueId->NodeSignature, NodeName, NAME_LENGTH );
} // ComputeArbitrationId //



DWORD
ArbitrateOnce(
    IN PDISK_RESOURCE ResourceEntry,
    IN HANDLE         FileHandle,
    LPVOID            buf
    )

/*++

Routine Description:

    Perform full arbitration for a disk. Once arbitration has succeeded,
    a thread is started that will keep reservations on the disk.

Arguments:

    ResourceEntry - the disk info structure for the disk.

    FileHandle - the file handle to use for arbitration.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   status;
    ARBITRATION_ID  id, old_y, empty;

    if (LegacyMode) {
       status = DoReserve( FileHandle, ResourceEntry );
       if ( status != ERROR_SUCCESS ) {
           //
           // We will attempt to break the reservation of the other system, in case
           // it has gone down.
           //
           status = DoBreakReserve( FileHandle, ResourceEntry );
           if ( status != ERROR_SUCCESS ) {
               (DiskpLogEvent)(
                   ResourceEntry->ResourceHandle,
                   LOG_ERROR,
                   L"Failed to break reservation, error %1!u!.\n",
                   status );
           }

           //
           // Sleep for twice the RESERVATION_TIMER period to allow the
           // remote system to replace its reservation.
           //
           Sleep((2 * RESERVATION_TIMER) + 100);

           status = DoReserve( FileHandle, ResourceEntry );
       }
       if (status != ERROR_SUCCESS) {
          return status;
       }
       goto WinnerCode;
    } // Legacy Mode //

    PokeDiskStack(ResourceEntry, FileHandle);

    ComputeArbitrationId(ResourceEntry, &id);
    RtlZeroMemory( &empty, sizeof(empty) );
    RtlZeroMemory( &old_y, sizeof(old_y) );
    status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);

    if (  (status == ERROR_SUCCESS) 
       && ( (0 == memcmp(&empty, buf, sizeof(empty)) ) // clean release
            ||(0 == memcmp(&id.NodeSignature, 
                         &(((PARBITRATION_ID)buf)->NodeSignature),
                         sizeof(id.NodeSignature) ) ) // we dropped this disk
          )
       )
    {
        // Disk was voluntary released
        // or we are picking up the disk that was dropped by us
        // and nobody was using it while we were away
        //
        // => Fast Arbitration
        CopyMemory( &old_y ,buf, sizeof(old_y) );
        goto FastMutex;
    }

    if (status != ERROR_SUCCESS) {
        // Breaker //
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"[DiskArb]We are about to break reserve.\n");
        status = DoBreakReserve( FileHandle, ResourceEntry );
        if( ERROR_SUCCESS != status ) {
            (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                           LOG_ERROR,
                           L"[DiskArb]Failed to break reservation, error %1!u!.\n",
                           status
                           );
            return status;
        }
        Sleep( BUS_SETTLE_TIME );
        PokeDiskStack(ResourceEntry, FileHandle);
#if 0
        status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
#else
        CopyMemory(buf, &id, sizeof(id)); id.SeqNo.QuadPart ++;
        status = DoBlockWrite(ResourceEntry, FileHandle, BLOCK_Y, buf);
#endif
        if(status != ERROR_SUCCESS) { return status; }
    } else {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"[DiskArb]No reservation found. Read'n'wait.\n");
        Sleep( BUS_SETTLE_TIME ); // so that reader would not get an advantages
    }
    CopyMemory(&old_y, buf, sizeof(ARBITRATION_ID));

    Sleep( WAIT_FOR_RESERVATION_TO_BE_RESTORED );
    status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
    if(status != ERROR_SUCCESS) { return status; }
    if( 0 == memcmp(&empty, buf, sizeof(ARBITRATION_ID)) ) {;} else
    if( 0 != memcmp(&old_y, buf, sizeof(ARBITRATION_ID)) ) { return ERROR_QUORUM_OWNER_ALIVE; }
    // Fast Mutex Code //

FastMutex:
    //  write(x, id) //
    CopyMemory(buf, &id, sizeof(id));
    status = DoBlockWrite(ResourceEntry, FileHandle, BLOCK_X, buf);
    if(status != ERROR_SUCCESS) { return status; }

    //  if(y != old_y && y != empty) return FALSE; //
    status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
    if(status != ERROR_SUCCESS) { return status; }

    if( 0 == memcmp(&empty, buf, sizeof(ARBITRATION_ID)) ) {;} else
    if( 0 != memcmp(&old_y, buf, sizeof(ARBITRATION_ID)) ) { return ERROR_QUORUM_OWNER_ALIVE; }

    // write(y, id) //
    CopyMemory(buf, &id, sizeof(id));
    status = DoBlockWrite(ResourceEntry, FileHandle, BLOCK_Y, buf);
    if(status != ERROR_SUCCESS) { return status; }

    // if(x != id) ...
    status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_X, buf);
    if(status != ERROR_SUCCESS) { return status; }

    if( 0 != memcmp(&id, buf, sizeof(ARBITRATION_ID)) ) {
        Sleep(FAST_MUTEX_DELAY);

        // if(y == 0) goto FastMutex //
        // if(y != id) return FALSE //
        status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
        if(status != ERROR_SUCCESS) { return status; }
        if( 0 == memcmp(&empty, buf, sizeof(ARBITRATION_ID)) ) {
            RtlZeroMemory( &old_y, sizeof(old_y) );
            goto FastMutex;
        }
        if( 0 != memcmp(&id, buf, sizeof(ARBITRATION_ID)) ) { return ERROR_QUORUM_OWNER_ALIVE; }
    }
WinnerCode:
    status = StartPersistentReservations(ResourceEntry, FileHandle);
    return(status);

} // ArbitrateOnce //


DWORD
DiskArbitration(
    IN PDISK_RESOURCE ResourceEntry,
    IN HANDLE     FileHandle
    )

/*++

Routine Description:

    Perform arbitration for a disk. Once arbitration has succeeded,
    a thread is started that will keep reservations on the disk.
    If arbitration fails, the routine will retry to arbitrate in ArbitratationSleepBeforeRetry
    milliseconds. A number of arbitration attempts is controlled by ArbitrationAttempts variable.

    ArbitrationAttempts and ArbitratationSleepBeforeRetry are read from the registry on
    start up.

Arguments:

    ResourceEntry - the disk info structure for the disk.

    FileHandle - the file handle to use for arbitration.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   status;
    int     repeat;
    LPVOID  unalignedBuf = 0;
    LPVOID  buf = 0;

    __try {
        (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"[DiskArb] Arbitration Parameters (%1!u! %2!u!).\n",
                        ArbitrationAttempts, ArbitratationSleepBeforeRetry);
        EnterCriticalSection( &(ResourceEntry->ArbitrationInfo.DiskLock) );

        //
        // If we already are performing reservations, then just leave now.
        //
        if ( ReservationInProgress(ResourceEntry) ) {
            status = ERROR_SUCCESS;
            __leave;
        }
        status = VerifySectorSize(ResourceEntry, FileHandle);
        if ( status != ERROR_SUCCESS ) {
            // VerifySectorSize logs an error //
            __leave;
        }

        unalignedBuf = LocalAlloc(LMEM_FIXED, ResourceEntry->ArbitrationInfo.SectorSize * 2);
        if( unalignedBuf == 0 ) {
            status = GetLastError();
            (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                           LOG_ERROR,
                           L"[DiskArb]Failed to allocate arbitration buffer X, error %1!u!.\n", status );
            __leave;
        }
        // Alignment code assumes that ResourceEntry->ArbitrationInfo.SectorSize is the power of two //
        buf = (LPVOID)( ((ULONG_PTR)unalignedBuf + ResourceEntry->ArbitrationInfo.SectorSize
                       ) & ~((ULONG_PTR)(ResourceEntry->ArbitrationInfo.SectorSize - 1))
                     );
        ZeroMemory(buf, ResourceEntry->ArbitrationInfo.SectorSize);

        repeat = ArbitrationAttempts;
        for(;;) {
            status = ArbitrateOnce(ResourceEntry, FileHandle, buf);
            if(status == ERROR_SUCCESS) {
                break;
            }
            if(--repeat <= 0) {
                break;
            }
            Sleep(ArbitratationSleepBeforeRetry);
        }
        if(status != ERROR_SUCCESS) {
            __leave;
        }

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"[DiskArb]Assume ownership of the device.\n");

    } __finally {
        LeaveCriticalSection( &(ResourceEntry->ArbitrationInfo.DiskLock) );
        if(unalignedBuf) {
            LocalFree(unalignedBuf);
        }
    }

    return(status);

} // DiskArbitration //


DWORD
DoArbEscape(
    IN PDISK_RESOURCE ResourceEntry,
    IN HANDLE FileHandle,
    IN ULONG Operation,
    IN PWCHAR OperationName,
    IN PVOID OutBuffer,
    IN ULONG OutBufferSize
    )
{    
    DWORD bytesReturned;
    DWORD status;
    DWORD LogLevel = LOG_INFORMATION;
    ARBITRATION_READ_WRITE_PARAMS params;

    params.Operation  = Operation;
    params.SectorSize = 0;
    params.SectorNo   = 0;
    params.Buffer     = 0;
    params.Signature  = ResourceEntry->DiskInfo.Params.Signature;

    (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                     LOG_INFORMATION,
                     L"[DiskArb] Issuing %1!ws! on signature %2!x!.\n",
                     OperationName,
                     params.Signature );

    status = DeviceIoControl( FileHandle,
                              IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE,
                              &params,
                              sizeof(params),
                              OutBuffer,
                              OutBufferSize,
                              &bytesReturned,
                              FALSE );

    if( status == FALSE) {
        status = GetLastError();
        LogLevel = LOG_ERROR;
    } else {
        status = ERROR_SUCCESS;
    }
    (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                     LogLevel,
                     L"[DiskArb] %1!ws! completed, status %2!u!.\n",
                     OperationName, status );
    return status;                     
}    

DWORD
DoReadWrite(
      IN PDISK_RESOURCE ResourceEntry,
      IN ULONG Operation,
      IN HANDLE FileHandle,
      IN DWORD BlockNumber,
      IN PVOID Buffer
      )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   DWORD bytesReturned;
   DWORD status;
   PWCHAR opname = (Operation == AE_READ)?L"read ":L"write";
   ARBITRATION_READ_WRITE_PARAMS params;

   params.Operation = Operation;
   params.SectorSize = ResourceEntry->ArbitrationInfo.SectorSize;
   params.SectorNo = BlockNumber;
   params.Buffer = Buffer;
   params.Signature = ResourceEntry->DiskInfo.Params.Signature;

   status = DeviceIoControl( FileHandle,
                             IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE,
                             &params,
                             sizeof(params),
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE );

   if( status == 0) {
      status = GetLastError();
      (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"[DiskArb]Failed to %1!ws! (sector %2!u!), error %3!u!.\n",
                      opname,
                      BlockNumber,
                      status );
      return status;
   } else {
#if 0
      (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                       LOG_INFORMATION,
                       L"[DiskArb]Successful %1!ws! (sector %2!u!).\n",
                       opname,
                       BlockNumber,
#else
      WCHAR buf[64];
      mbstowcs(buf, ((PARBITRATION_ID)Buffer)->NodeSignature, sizeof(((PARBITRATION_ID)Buffer)->NodeSignature));
      (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                       LOG_INFORMATION,
                       L"[DiskArb]Successful %1!ws! (sector %2!u!) [%3!ws!:%4!u!] (%5!x!,%6!08x!:%7!08x!).\n",
                       opname,
                       BlockNumber,
                       buf,
                       ((PARBITRATION_ID)Buffer)->SeqNo.LowPart,
                       ((PARBITRATION_ID)Buffer)->SeqNo.HighPart,
                       ((PARBITRATION_ID)Buffer)->SystemTime.LowPart,
                       ((PARBITRATION_ID)Buffer)->SystemTime.HighPart
                     );
#endif
   }
   return ERROR_SUCCESS;
} // DoReadWrite //


DWORD
VerifySectorSize(
      IN OUT PDISK_RESOURCE ResourceEntry,
      IN HANDLE             FileHandle
      )

/*++

Routine Description:

    The routine checks whether
    a ResourceEntry->ArbitrationInfo.SectorSize has a value assigned to it.
    If ResourceEntry->ArbitrationInfo.SectorSize is 0 then the routine tries
    to obtain a correct sector size using GetDriveGeometry IOCTL.

Arguments:

Return Value:

    ERROR_SUCCESS
      or
    Error Code returned by IOCTL_DISK_GET_DRIVE_GEOMETRY

Comment:

    The routine always succeeds. If it cannot obtain
    disk geometry it will use a default sector size.

--*/

{
    BOOL  success;
    DWORD bytesReturned;
    DWORD status;
    DWORD sectorSize;

    if (ResourceEntry->ArbitrationInfo.SectorSize)
    {
        return ERROR_SUCCESS;
    }

    status = GetSectorSize(ResourceEntry, FileHandle, &sectorSize);
    if (status == ERROR_SUCCESS) {
        ResourceEntry->ArbitrationInfo.SectorSize = sectorSize;
    } else {
        ResourceEntry->ArbitrationInfo.SectorSize = DEFAULT_SECTOR_SIZE;
        // GetDiskGeometry logs an error //
        return status;
    }

    // ArbitrationInfo.SectorSize should be at least 64 bytes //
    if( ResourceEntry->ArbitrationInfo.SectorSize < sizeof(ARBITRATION_ID) ) {
        (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] ArbitrationInfo.SectorSize is too small %1!u!\n", ResourceEntry->ResourceHandle);
        ResourceEntry->ArbitrationInfo.SectorSize = DEFAULT_SECTOR_SIZE;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // ArbitrationInfo.SectorSize should be a power of two //
    if( (ResourceEntry->ArbitrationInfo.SectorSize & (ResourceEntry->ArbitrationInfo.SectorSize - 1)) != 0 ) {
        (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] ArbitrationInfo.SectorSize is not a power of two %1!u!\n", ResourceEntry->ResourceHandle);
        ResourceEntry->ArbitrationInfo.SectorSize = DEFAULT_SECTOR_SIZE;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] ArbitrationInfo.SectorSize is %1!u!\n", ResourceEntry->ArbitrationInfo.SectorSize);
    return ERROR_SUCCESS;
} // VerifySectorSize //


VOID
ReadArbitrationParameters(
    VOID
    )
/*++

Routine Description:

   Reads

      DWORD ArbitrationAttempts           = DEFAULT_ARBITRATION_ATTEMPTS;
      DWORD ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;

   from the registry

Arguments:

   NONE

Return Value:

   NONE

--*/
{
    DWORD status;
    HKEY  key;
    DWORD size;

    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           "Cluster",
                           0,
                           KEY_READ,
                           &key );

    if ( status != ERROR_SUCCESS ) {
        ArbitrationAttempts           = DEFAULT_ARBITRATION_ATTEMPTS;
        ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;
        return;
    }
    size = sizeof(ArbitrationAttempts);
    status = RegQueryValueEx(key,
                             ARBITRATION_ATTEMPTS_SZ,
                             0,
                             NULL,
                             (LPBYTE)&ArbitrationAttempts,
                             &size);

    if(status != ERROR_SUCCESS) {
       ArbitrationAttempts = DEFAULT_ARBITRATION_ATTEMPTS;
    }
    if(ArbitrationAttempts < MIN_ARBITRATION_ATTEMPTS
    || ArbitrationAttempts > MAX_ARBITRATION_ATTEMPTS)
    {
       ArbitrationAttempts = DEFAULT_ARBITRATION_ATTEMPTS;
    }

    size = sizeof(ArbitratationSleepBeforeRetry);
    status = RegQueryValueEx(key,
                             ARBITRATION_SLEEP_SZ,
                             0,
                             NULL,
                             (LPBYTE)&ArbitratationSleepBeforeRetry,
                             &size);

    if(status != ERROR_SUCCESS) {
       ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;
    }
    //
    // Removed this part of the check:
    //      ArbitratationSleepBeforeRetry < MIN_SLEEP_BEFORE_RETRY
    // as DWORD/ULONG cannot be less than zero and it always evaluated
    // to FALSE.
    //
    if(ArbitratationSleepBeforeRetry > MAX_SLEEP_BEFORE_RETRY)
    {
       ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;
    }
    RegCloseKey(key);
} // ReadArbitrationParameters //



VOID
CompletionRoutine(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
    PDISK_RESOURCE    ResourceEntry;

    if( IoContext ) {
       ResourceEntry = (PDISK_RESOURCE)IoContext;

       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_INFORMATION,
           L"[DiskArb] CompletionRoutine, status %1!u!.\n", Status);

    } else {
       PARBITRATION_INFO info =  CONTAINING_RECORD(
                                   WorkItem,  // Expr //
                                   ARBITRATION_INFO,
                                   WorkItem); // FieldName //

       ResourceEntry = CONTAINING_RECORD(
                          info,
                          DISK_RESOURCE,
                          ArbitrationInfo);

       (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"[DiskArb] CompletionRoutine starts.\n", Status);
    }

    if (Status == ERROR_SUCCESS) {

        if (ResourceEntry->ArbitrationInfo.StopReserveInProgress) {
           return;
        }
        //
        // Repost the request
        //
        Status = AsyncCheckReserve(ResourceEntry);
        if (Status == ERROR_SUCCESS) {
           return;
        }
    }

    //
    // Some kind of error occurred,
    // but if we are in the middle of StopReserve
    // then everything is fine.
    //
    if (ResourceEntry->ArbitrationInfo.StopReserveInProgress) {
       return;
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_ERROR,
        L"[DiskArb] CompletionRoutine: reservation lost!\n");

    ClusResLogSystemEventByKey(ResourceEntry->ResourceKey,
                               LOG_CRITICAL,
                               RES_DISK_RESERVATION_LOST);

    //
    // Callout to cluster service to indicate that quorum has
    // been lost.
    //

    if (ResourceEntry->LostQuorum != NULL) {
        (ResourceEntry->LostQuorum)(ResourceEntry->ResourceHandle);
    }
    ResourceEntry->DiskInfo.FailStatus = Status;
    ResourceEntry->Reserved = FALSE;

    return;

}  // CompletionRoutine //

DWORD
AsyncCheckReserve(
    IN OUT PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to check reserve.
    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    PARBITRATION_INFO Info = &ResourceEntry->ArbitrationInfo;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] posting AsyncCheckReserve request.\n");

    ClRtlInitializeWorkItem(
        &(Info->WorkItem),
        CompletionRoutine,
        ResourceEntry
        );

    success = DeviceIoControl( Info->ControlHandle,
                               IOCTL_DISK_CLUSTER_ALIVE_CHECK,
                               &Info->InputData,
                               sizeof(Info->InputData),
                               &Info->OutputData,
                               sizeof(Info->OutputData),
                               &bytesReturned,
                               &Info->WorkItem.Overlapped);

    if ( !success ) {
        errorCode = GetLastError();

        if( errorCode == ERROR_IO_PENDING ) {
           (DiskpLogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_INFORMATION,
               L"[DiskArb] ********* IO_PENDING **********.\n");
           return ERROR_SUCCESS;
        }
        if ( !success ) {
            errorCode = GetLastError();
               (DiskpLogEvent)(
                   ResourceEntry->ResourceHandle,
                   LOG_ERROR,
                   L"[DiskArb] error checking disk reservation thread, error %1!u!.\n",
                   errorCode);
            return(errorCode);
        }
    }
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_ERROR,
        L"[DiskArb], Premature completion of CheckReserve.\n");

    return(ERROR_CAN_NOT_COMPLETE);

} // AsyncCheckReserve


DWORD
StartPersistentReservations(
      IN OUT PDISK_RESOURCE ResourceEntry,
      IN HANDLE             FileHandle
      )
/*++

Routine Description:

    Starts driver level persistent reservations.
    Also starts a user-mode thread to keep an eye on driver level reservations.

Arguments:

    ResourceEntry - the disk info structure for the disk.

    FileHandle - the file handle to use for arbitration.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // If we already are performing reservations, then just leave now.
    //
    if ( ReservationInProgress(ResourceEntry) ) {
        return(ERROR_SUCCESS);
    }

    CL_ASSERT(WorkQueue != NULL);
    VerifySectorSize(ResourceEntry, FileHandle);

    status = DoReserve( FileHandle, ResourceEntry );
    if(status != ERROR_SUCCESS) {
       return status;
    }

    {
         START_RESERVE_DATA params;
         DWORD              paramsSize;
         DWORD              NameSize = sizeof(params.NodeSignature);

         // Preparing parameters to call StartReserveEx //
         params.DiskSignature     = ResourceEntry->DiskInfo.Params.Signature;
         params.Version           = START_RESERVE_DATA_V1_SIG;
         params.ArbitrationSector = BLOCK_Y;
         params.SectorSize        = ResourceEntry->ArbitrationInfo.SectorSize;
         params.NodeSignatureSize = sizeof(params.NodeSignature);
         RtlZeroMemory(params.NodeSignature, sizeof(params.NodeSignature) );
         RtlCopyMemory(params.NodeSignature, NodeName, NAME_LENGTH );

         #if 0
         // When we have a reliable way of determining
         // whether this disk resource is a quorum
         // this code can be enabled
         if ( DoesNotNeedExpensiveReservations(ResourceEntry) ) {
            paramsSize = sizeof( params.DiskSignature );
         } else {
            paramsSize = sizeof( params );
         }
         #else
            paramsSize = sizeof( params );
         #endif

         status = StartReserveEx( &ResourceEntry->ArbitrationInfo.ControlHandle,
                                  &params,
                                  paramsSize,
                                  ResourceEntry->ResourceHandle );
    }

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[DiskArb]Failed to start driver reservation thread, error %1!u!.\n",
            status );
        DoRelease( FileHandle, ResourceEntry );
        return(status);
    }

    ResourceEntry->ArbitrationInfo.StopReserveInProgress = FALSE;
    status = ClRtlAssociateIoHandleWorkQueue(
                 WorkQueue,
                 ResourceEntry->ArbitrationInfo.ControlHandle,
                 (ULONG_PTR)ResourceEntry
                 );

    if ( status != ERROR_SUCCESS ) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] ClRtlAssociateIoHandleWorkQueue failed, error %1!u!.\n",
           status );
        StopPersistentReservations( ResourceEntry );
        DoRelease( FileHandle, ResourceEntry );
        return(status);
    }

    ClRtlInitializeWorkItem(
        &(ResourceEntry->ArbitrationInfo.WorkItem),
        CompletionRoutine,
        0
        );

    status = ClRtlPostItemWorkQueue(
                 WorkQueue,
                 &ResourceEntry->ArbitrationInfo.WorkItem,
                 0,0);

    if ( status != ERROR_SUCCESS ) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] ClRtlPostItemWorkQueue failed, error %1!u!.\n",
           status );
        StopPersistentReservations( ResourceEntry );
        DoRelease( FileHandle, ResourceEntry );
        return(status);
    }
    ResourceEntry->Reserved = TRUE;

    return ERROR_SUCCESS;
} // StartPersistentReservations //

DWORD
CleanupArbitrationSector(
    IN PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

Arguments:

    ResourceEntry - the disk info structure for the disk.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    HANDLE  FileHandle = DiskspClusDiskZero;
    DWORD   status;
    LPVOID  unalignedBuf = 0;
    PARBITRATION_ID buf = 0;
    try {
       (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"[ArbCleanup] Verifying sector size. \n" );
       VerifySectorSize(ResourceEntry, FileHandle);

       unalignedBuf = LocalAlloc(LMEM_FIXED, ResourceEntry->ArbitrationInfo.SectorSize * 2);
       if( unalignedBuf == 0 ) {
          status = GetLastError();
          (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                           LOG_ERROR,
                           L"[ArbCleanup] Failed to allocate buffer, error %1!u!.\n", status );
          leave;
       }
       // Alignment code assumes that ResourceEntry->ArbitrationInfo.SectorSize is the power of two //
       buf = (PARBITRATION_ID)
               (
                   ( (ULONG_PTR)unalignedBuf + ResourceEntry->ArbitrationInfo.SectorSize )
                & ~((ULONG_PTR)(ResourceEntry->ArbitrationInfo.SectorSize - 1))
               );
       ZeroMemory(buf, ResourceEntry->ArbitrationInfo.SectorSize);

       (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"[ArbCleanup] Reading arbitration block. \n" );
       status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
       if (status != ERROR_SUCCESS) { leave; }
       if( 0 != memcmp(buf->NodeSignature, NodeName, NAME_LENGTH) ) {
          //
          // Somebody is challenging us. No need to clean up the sector
          //
          status = ERROR_OPERATION_ABORTED;
          leave;
       }

       ZeroMemory(buf, ResourceEntry->ArbitrationInfo.SectorSize);
       (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"[ArbCleanup] Writing arbitration block. \n" );
       status = DoBlockWrite(ResourceEntry, FileHandle, BLOCK_Y, buf);
       if(status != ERROR_SUCCESS) {
          leave;
       }

    } finally {
       if(unalignedBuf) {
          LocalFree(unalignedBuf);
       }
    }

    (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                     LOG_INFORMATION,
                     L"[ArbCleanup] Returning status %1!u!. \n", status );

    return(status);

} // CleanupArbitrationSector //


VOID
StopPersistentReservations(
      IN OUT PDISK_RESOURCE ResourceEntry
      )
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
    HANDLE localHandle;
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] StopPersistentReservations is called.\n");

    //
    // ReservationInProgress returns current contents of
    // ResourceEntry->ArbitrationInfo.ControlHandle
    //
    localHandle = ReservationInProgress(ResourceEntry);
    if ( localHandle ) {
        DWORD  status;
        HANDLE ExchangeResult;

        ExchangeResult = InterlockedCompareExchangePointer(
            &ResourceEntry->ArbitrationInfo.ControlHandle,
            0,
            localHandle);
        if (ExchangeResult == localHandle) {
            //
            // Only one thread is allowed in here
            //
             
            ResourceEntry->ArbitrationInfo.StopReserveInProgress = TRUE;
      
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"[DiskArb] Stopping reservation thread.\n");

            //
            // Close the Control Handle, which stops the reservation thread and
            // dismounts the volume, releases the disk, and marks it offline.
            //
            status = StopReserve( localHandle,
                                  ResourceEntry->ResourceHandle );
            if ( status != ERROR_SUCCESS ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Cleanup, error stopping reservation thread, error %1!u!.\n",
                    status);
            }
      
            status = CleanupArbitrationSector( ResourceEntry );
            if (status != ERROR_SUCCESS) {
               (DiskpLogEvent)(
                   ResourceEntry->ResourceHandle,
                   LOG_ERROR,
                   L"Cleanup, error cleaning arbitration sector, error %1!u!.\n",
                   status);
            }
        }
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] StopPersistentReservations is complete.\n");

    ResourceEntry->ArbitrationInfo.ControlHandle = NULL;
    ResourceEntry->Reserved = FALSE;
    ResourceEntry->LostQuorum = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clusres\clusres.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    clusres.c

Abstract:

    Common Resource DLL Startup

Author:

    John Vert (jvert) 12/15/1996

Revision History:
    Sivaprasad Padisetty (sivapad) 04/22/1996  Added the local quorum

--*/
#include "clusres.h"
#include "clusrtl.h"
#include "clusudef.h"

PSET_RESOURCE_STATUS_ROUTINE ClusResSetResourceStatus = NULL;
PLOG_EVENT_ROUTINE ClusResLogEvent = NULL;


BOOLEAN
WINAPI
ClusResDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
/*++

Routine Description:

    Main DLL entrypoint for combined resource DLL.

Arguments:

    DllHandle - Supplies the DLL handle.

    Reason - Supplies the call reason

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(DllHandle);
        ClRtlInitialize( TRUE, NULL );
        ClRtlInitWmi(NULL);
    }

    //
    // Let everybody else have their shot at it.
    //
    if (!GenAppDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!GenSvcDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

#if 0
    if (!FtSetDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }
#endif

    if (!DisksDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!NetNameDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!IpAddrDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!SmbShareDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!SplSvcDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!LkQuorumDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!TimeSvcDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!GenScriptDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!MsMQDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!MajorityNodeSetDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    return(TRUE);
}

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup a particular resource type. This means verifying the version
    requested, and returning the function table for this resource type.

Arguments:

    ResourceType - Supplies the type of resource.

    MinVersionSupported - The minimum version number supported by the cluster
                    service on this system.

    MaxVersionSupported - The maximum version number supported by the cluster
                    service on this system.

    SetResourceStatus - xxx

    LogEvent - xxx

    FunctionTable - Returns the Function Table for this resource type.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( !ClusResLogEvent ) {
        ClusResLogEvent = LogEvent;
        ClusResSetResourceStatus = SetResourceStatus;
    }

    if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_GENSVC ) == 0 ) {
        *FunctionTable = &GenSvcFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_GENAPP ) == 0 ) {
        *FunctionTable = &GenAppFunctionTable;
        return(ERROR_SUCCESS);
#if 0
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_FTSET ) == 0 ) {
        *FunctionTable = &FtSetFunctionTable;
        return(ERROR_SUCCESS);
#endif
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_PHYS_DISK ) == 0 ) {
        *FunctionTable = &DisksFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_FILESHR ) == 0 ) {
        *FunctionTable = &SmbShareFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_NETNAME ) == 0 ) {
        *FunctionTable = &NetNameFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_IPADDR ) == 0 ) {
        *FunctionTable = &IpAddrFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_TIMESVC ) == 0 ) {
        *FunctionTable = &TimeSvcFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_PRTSPLR ) == 0 ) {
        *FunctionTable = &SplSvcFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_LKQUORUM ) == 0 ) {
        *FunctionTable = &LkQuorumFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_MSMQ ) == 0 ) {
        *FunctionTable = &MsMQFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_GENSCRIPT ) == 0 ) {
        *FunctionTable = &GenScriptFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_MAJORITYNODESET) == 0 ) {
        *FunctionTable = &MajorityNodeSetFunctionTable;
        return(ERROR_SUCCESS);
    } else {
        return(ERROR_CLUSTER_RESNAME_NOT_FOUND);
    }
} // Startup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\disksp.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    disksp.h

Abstract:

    Disks Resource DLL private definitions.

Author:

    Rod Gamache (rodga) 29-Mar-1996

Revision History:

--*/

#include "clusres.h"
#include "ntddscsi.h"
#include "ntddft.h"
#include "clusdisk.h"
#include "clusrtl.h"
#include "disk.h"
#include "clusstor.h"

#define DiskpLogEvent ClusResLogEvent
#define DiskpSetResourceStatus ClusResSetResourceStatus

#define MAX_DISKS       100

#define DISKS_PRINT printf
#define FTSET_PRINT printf

#define CLUSDISK_REGISTRY_AVAILABLE_DISKS \
    "System\\CurrentControlSet\\Services\\ClusDisk\\Parameters\\AvailableDisks"

#define CLUSDISK_REGISTRY_SIGNATURES \
    "System\\CurrentControlSet\\Services\\ClusDisk\\Parameters\\Signatures"

#define CLUSREG_VALUENAME_MANAGEDISKSONSYSTEMBUSES L"ManageDisksOnSystemBuses"


#define UNINITIALIZED_UCHAR     (UCHAR)-1

#define MIN_USABLE_QUORUM_PARTITION_LENGTH  50 * 1000 * 1000    //  50 MB

extern PLOG_EVENT_ROUTINE DiskpLogEvent;
extern HANDLE DiskspClusDiskZero;
//extern PSTR PartitionName;
//extern PSTR DiskName;

typedef struct _ARBITRATION_INFO {
   CLRTL_WORK_ITEM  WorkItem;
   DWORD            SectorSize;
   CRITICAL_SECTION DiskLock;

   DWORD            InputData;
   DWORD            OutputData;

   HANDLE           ControlHandle;    // Moved here from DISK_INFO //
   BOOL             ReservationError; // Moved here from DISK_INFO //
   BOOL             StopReserveInProgress;

   LONG             CheckReserveInProgress;
   DWORD            ArbitrateCount;

} ARBITRATION_INFO, *PARBITRATION_INFO;

typedef struct _MOUNTIE_VOLUME *PMOUNTIE_VOLUME;

typedef struct _MOUNTIE_INFO {
   DWORD           HarddiskNo;
   DWORD           DriveLetters;
   DWORD           NeedsUpdate;
   DWORD           VolumeStructSize;
   PMOUNTIE_VOLUME Volume;
   DWORD           UpdateThreadIsActive;
} MOUNTIE_INFO, *PMOUNTIE_INFO;

typedef struct _DISK_PARAMS {
    DWORD   Signature;
    LPWSTR  SerialNumber;
    LPWSTR  Drive;
    DWORD   SkipChkdsk;
    DWORD   ConditionalMount;
    LPWSTR  MPVolGuids;         // REG_MULTI_SZ string of Volume{GUIDS}
    DWORD   MPVolGuidsSize;     // Number of bytes, not number of WCHARs!
    DWORD   UseMountPoints;
    LPWSTR  VolGuid;
} DISK_PARAMS, *PDISK_PARAMS;

//
// DISK_INFO structures are common to both the physical disk resource
// and the FT set resource. The underlying SCSI/filter driver interfaces
// deal with DISK_INFO structures. Each one represents a physical disk.
//

typedef struct _DISK_INFO {
    LIST_ENTRY ListEntry;
    DISK_PARAMS Params;
    DWORD PhysicalDrive;
    HANDLE  FileHandle;
    DWORD   FailStatus;
} DISK_INFO, *PDISK_INFO;

typedef struct _MOUNTPOINT_INFO {
    DWORD   MPUpdateThreadIsActive;
    CRITICAL_SECTION MPLock;
    BOOL    Initialized;
    DWORD   MPListCreateInProcess;
} MOUNTPOINT_INFO, *PMOUNTPOINT_INFO;

//
// DISK_RESOURCE structures are used by the physical disk resource.
// It encapsulates a DISK_INFO structure that represents the physical
// disk. Each DISK_RESOURCE may contain multiple partitions.
//
typedef struct _DISK_RESOURCE {
    LIST_ENTRY ListEntry;           // Linkage onto list of online disks
    DISK_INFO DiskInfo;
    RESOURCE_HANDLE ResourceHandle;
    HKEY    ResourceKey;
    HKEY    ResourceParametersKey;
    HKEY    ClusDiskParametersKey;
//    HANDLE  StopTimerHandle;
    BOOL    Reserved;
    BOOL    Valid;
    BOOL    Inserted;
    BOOL    Attached;
    CLUS_WORKER  OnlineThread;
    CLUS_WORKER  OfflineThread;
    PQUORUM_RESOURCE_LOST LostQuorum;
    PFULL_DISK_INFO DiskCpInfo;          // returned from DiskGetFullDiskInfo
    DWORD   DiskCpSize;
    MOUNTPOINT_INFO  MPInfo;
    ARBITRATION_INFO ArbitrationInfo;
    MOUNTIE_INFO     MountieInfo;
} DISK_RESOURCE, *PDISK_RESOURCE;


//
// FTSET_RESOURCE structures are used by the FT set resource.
// It encapsulates a list of DISK_INFO structures that represent
// the physical members of the FT set.
//
typedef struct _FTSET_RESOURCE {
    LIST_ENTRY ListEntry;               // Linkage onto list of online FT sets
    LIST_ENTRY MemberList;
    HANDLE  FtSetHandle;
    HKEY    ResourceKey;
    HKEY    ResourceParametersKey;
    HKEY    ClusDiskParametersKey;
    HANDLE  StopTimerHandle;
    HANDLE  ReservationThread;
    BOOL    Valid;
    BOOL    Attached;
    BOOL    Inserted;
    CLUS_WORKER OnlineThread;
    RESOURCE_HANDLE ResourceHandle;
    DWORD SignatureLength;
    LPWSTR  SignatureList;
    PFULL_FTSET_INFO FtSetInfo;          // returned from DiskGetFullFtSetInfo
    DWORD   FtSetSize;
    PQUORUM_RESOURCE_LOST LostQuorum;
} FTSET_RESOURCE, *PFTSET_RESOURCE;

#define FtRoot(_res_) CONTAINING_RECORD((_res_)->MemberList.Flink,   \
                                        DISK_INFO,                   \
                                        ListEntry)


typedef struct _SCSI_ADDRESS_ENTRY {
    SCSI_ADDRESS        ScsiAddress;
    struct _SCSI_ADDRESS_ENTRY  *Next;
} SCSI_ADDRESS_ENTRY, *PSCSI_ADDRESS_ENTRY;


BOOL
IsVolumeDirty(
    IN UCHAR DriveLetter
    );

#if 0
DWORD
GetSymbolicLink(
    IN PCHAR RootName,
    IN OUT PCHAR ObjectName      // Assumes this points at a MAX_PATH length buffer
    );
#endif
LPSTR
GetRegParameter(
    IN HKEY RegKey,
    IN LPCSTR ValueName
    );
#if 0
HANDLE
OpenObject(
    PCHAR   Directory,
    PCHAR   Name
    );
#endif

DWORD
AssignDriveLetters(
    HANDLE  FileHandle,
    PDISK_INFO DiskInfo
    );

DWORD
RemoveDriveLetters(
    HANDLE  FileHandle,
    PDISK_INFO DiskInfo
    );

DWORD
GoOnline(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
FixDriveLayout(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
GoOffline(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
SetOfflinePending(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

VOID
DoHoldIO(
    VOID
    );

VOID
DoResumeIO(
    VOID
    );

DWORD
DoAttach(
    DWORD Signature,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
DoDetach(
    DWORD Signature,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
DoReserve(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
DoRelease(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
DoBreakReserve(
    HANDLE     FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
StartReserve(
    OUT HANDLE *FileHandle,
    IN DWORD  Signature,
    IN RESOURCE_HANDLE ResourceHandle
    );

DWORD
StartReserveEx(
    OUT HANDLE *FileHandle,
    LPVOID InputData,
    DWORD  InputDataSize,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
StopReserve(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
CheckReserve(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
DiskpSetThreadPriority(
    VOID
    );

DWORD
GetRegDwordValue(
    IN LPWSTR RegKeyName,
    IN LPWSTR ValueName,
    OUT LPDWORD ValueBuffer
    );


//
// Common registry routines.
//

BOOLEAN
GetAssignedDriveLetter(
    ULONG       Signature,
    ULONG       PartitionNumber,
    PUCHAR      DriveLetter,
    PUSHORT     FtGroup,
    PBOOL       AssignDriveLetter
    );

//
// Common SCSI routines.
//

DWORD
GetScsiAddress(
    IN DWORD Signature,
    OUT LPDWORD ScsiAddress,
    OUT LPDWORD DiskNumber
    );

DWORD
ScsiIsAlive(
    IN HANDLE DiskHandle
    );

DWORD
ClusDiskGetAvailableDisks(
    OUT PVOID OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned,
    IN BOOL  FtSet
    );

DWORD
GetDiskInfo(
    IN DWORD Signature,
    OUT PVOID *OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    IN BOOL  FtSet
    );

VOID
GetSystemBusInfo(
    );

VOID
CleanupSystemBusInfo(
    );

BOOL
IsDiskOnSystemBus(
    PSCSI_ADDRESS DiskAddr
    );

BOOL
IsDiskSystemDisk(
    PSCSI_ADDRESS DiskAddr
    );

DWORD
GetSerialNumber(
    IN DWORD Signature,
    OUT LPWSTR *SerialNumber
    );

DWORD
GetSignatureFromSerialNumber(
    IN LPWSTR SerialNumber,
    OUT LPDWORD Signature
    );


//
// Common routines for handling logical volumes
//
DWORD
DisksDriveIsAlive(
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL Online
    );

DWORD
DisksMountDrives(
    IN PDISK_INFO DiskInfo,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Signature
    );

DWORD
DisksDismountDrive(
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Signature
    );

//
// PnP stuff
//
DWORD
DiskspGetQuorumPath(
     OUT LPWSTR* lpQuorumLogPath
     );

DWORD
DiskspSetQuorumPath(
     IN LPWSTR QuorumLogPath
     );

//
// [HACKHACK] Currently, there is not polically correct way
//  for the resource to learn whether it is a quorum resource or not
//
DWORD
GetQuorumSignature(
    OUT PDWORD QuorumSignature
    );

DWORD
StartNotificationWatcherThread(
    VOID
    );

VOID
StopNotificationWatcher(
    VOID
    );

VOID
WatchDisk(
    IN PDISK_RESOURCE ResourceEntry
    );

VOID
StopWatchingDisk(
    IN PDISK_RESOURCE ResourceEntry
    );

BOOL
IsDiskInPnpVolumeList(
    PDISK_RESOURCE ResourceEntry,
    BOOL UpdateVolumeList
    );

DWORD
QueueWaitForVolumeEvent(
    HANDLE Event,
    PDISK_RESOURCE ResourceEntry
    );

DWORD
RemoveWaitForVolumeEvent(
    PDISK_RESOURCE ResourceEntry
    );

//
// Mount point list processing.
//

VOID
DisksMountPointCleanup(
    PDISK_RESOURCE ResourceEntry
    );

VOID
DisksMountPointInitialize(
    PDISK_RESOURCE ResourceEntry
    );

DWORD
DisksProcessMountPointInfo(
    PDISK_RESOURCE ResourceEntry
    );

DWORD
DisksProcessMPControlCode(
    PDISK_RESOURCE ResourceEntry,
    DWORD ControlCode
    );

DWORD
DisksUpdateMPList(
    PDISK_RESOURCE ResourceEntry
    );

DWORD
PostMPInfoIntoRegistry(
    PDISK_RESOURCE ResourceEntry
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\disks.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    disks.c

Abstract:

    Resource DLL for disks.

Author:

    John Vert (jvert) 5-Dec-1995
    Rod Gamache (rodga) 18-Dec-1995

Revision History:

--*/

#include "disksp.h"
#include "lm.h"

#include "arbitrat.h"
#include "newdisks.h"
#include "newmount.h"

#define UNICODE 1

#define LOG_CURRENT_MODULE LOG_MODULE_DISK


#define DISKS_REG_CLUSTER_QUORUM "Cluster\\Quorum"
#define DISKS_REG_QUORUM_PATH CLUSREG_NAME_QUORUM_PATH

#define MAX_HANDLES 10

extern PWCHAR GLOBALROOT_HARDDISK_PARTITION_FMT;    // L"\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition%u\\";

PDISK_RESOURCE DiskTable[MAX_DISKS] = {0};
LONG           DiskCount = 0;

CRITICAL_SECTION DisksLock;

LIST_ENTRY DisksListHead;

HANDLE DisksRegistryThread = NULL;
HANDLE DisksTerminateEvent = NULL;
HANDLE DiskspClusDiskZero  = NULL;

DWORD               SystemDiskAddressFound = 0;
PSCSI_ADDRESS_ENTRY SysDiskAddrList = NULL;


extern CLRES_FUNCTION_TABLE DisksFunctionTable;

extern RTL_RESOURCE PnpVolumeLock;
extern RTL_RESOURCE PnpWaitingListLock;

//
// Disk resource property names
//
#define DISKS_SIGNATURE         CLUSREG_NAME_PHYSDISK_SIGNATURE
#define DISKS_DRIVE             CLUSREG_NAME_PHYSDISK_DRIVE   // pseudonym for signature
#define DISKS_SKIPCHKDSK        CLUSREG_NAME_PHYSDISK_SKIPCHKDSK
#define DISKS_CONDITIONAL_MOUNT CLUSREG_NAME_PHYSDISK_CONDITIONAL_MOUNT
#define DISKS_MPVOLGUIDS        CLUSREG_NAME_PHYSDISK_MPVOLGUIDS
#define DISKS_VOLGUID           CLUSREG_NAME_PHYSDISK_VOLGUID       // Not saved in cluster DB
#define DISKS_SERIALNUMBER      CLUSREG_NAME_PHYSDISK_SERIALNUMBER

//
// Disk resource private read-write properties.
// Allow for a pseudonym for Signature (Drive), but don't allow both
// drive and signature to be passed.
//
RESUTIL_PROPERTY_ITEM
DiskResourcePrivateProperties[] = {
    { DISKS_SIGNATURE, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0xFFFFFFFF, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(DISK_PARAMS,Signature) },
    { DISKS_SKIPCHKDSK, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS,SkipChkdsk) },
    { DISKS_CONDITIONAL_MOUNT, NULL, CLUSPROP_FORMAT_DWORD, 1, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS,ConditionalMount) },
#if USEMOUNTPOINTS_KEY
    { DISKS_USEMOUNTPOINTS, NULL, CLUSPROP_FORMAT_DWORD, 1, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS, UseMountPoints) },
#endif
    { DISKS_MPVOLGUIDS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS, MPVolGuids) },
    { DISKS_SERIALNUMBER, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS,SerialNumber) },
    { 0 }
};

RESUTIL_PROPERTY_ITEM
DiskResourcePrivatePropertiesAlt[] = {
    { DISKS_SIGNATURE, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0xFFFFFFFF, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(DISK_PARAMS,Signature) },
    { DISKS_SKIPCHKDSK, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS,SkipChkdsk) },
    { DISKS_DRIVE, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(DISK_PARAMS,Drive) },
    { DISKS_CONDITIONAL_MOUNT, NULL, CLUSPROP_FORMAT_DWORD, 1, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS,ConditionalMount) },
#if USEMOUNTPOINTS_KEY
    { DISKS_USEMOUNTPOINTS, NULL, CLUSPROP_FORMAT_DWORD, 1, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS, UseMountPoints) },
#endif
    { DISKS_MPVOLGUIDS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS, MPVolGuids) },
    { DISKS_VOLGUID, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS, VolGuid) },
    { DISKS_SERIALNUMBER, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS,SerialNumber) },
    { 0 }
};

#define CLUSTERLOG_ENV_VARIABLE     L"ClusterLog"

//
// Local functions.
//

DWORD
DisksValidatePrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PDISK_PARAMS Params
    );

DWORD
DisksSetPrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
DisksGetPrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
ProcessDllExtension(
    IN PDISK_RESOURCE ResourceEntry,
    IN PVOID    InBuffer,
    IN DWORD    InBufferSize,
    OUT PVOID   OutBuffer,
    IN DWORD    OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
DisksOpenChkdskLogFile(
    IN PDISK_RESOURCE ResourceEntry,
    IN OUT PHANDLE ChkdskLogFile,
    IN OUT LPWSTR *ChkdskLogFileName
    );

//
// Error callbacks from disk library
//

VOID
DiskErrorFatal(
    INT MessageId,
    DWORD Error,
    LPSTR File,
    DWORD Line
    )
{
    DWORD Data[3];

    Data[0] = MessageId;
    Data[1] = Error;
    Data[2] = Line;
    ClusResLogSystemEventData(LOG_CRITICAL,
                              RES_FTSET_DISK_ERROR,
                              sizeof(Data),
                              Data);
}

VOID
DiskErrorLogInfo(
    LPSTR Format,
    ...
    )
{
}



BOOLEAN
WINAPI
DisksDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    DWORD status;

    switch ( Reason ) {

        case DLL_PROCESS_ATTACH:
            InitializeCriticalSection( &DisksLock );
            InitializeListHead( &DisksListHead );
            RtlInitializeResource( &PnpVolumeLock );
            RtlInitializeResource( &PnpWaitingListLock );
            ArbitrationInitialize();
            GetSystemBusInfo();

            break;

        case DLL_PROCESS_DETACH:
            //
            // only do clean up if we're not exiting the process.
            // ClRtlDestroyWorkQueue waits on an event to be set and it is
            // possible at this point that there are no threads to do that.
            // This causes resmon to linger and generally be a pest.
            //
            if (DiskspClusDiskZero) {
                DevfileClose(DiskspClusDiskZero);
            }
            CleanupSystemBusInfo();
            ArbitrationCleanup();
            DeleteCriticalSection( &DisksLock );
            RtlDeleteResource( &PnpVolumeLock );
            RtlDeleteResource( &PnpWaitingListLock );
            break;

        default:
            break;
    }

    return(TRUE);

} // DisksDllEntryPoint




RESID
DiskspGetNextDisk(
    VOID
    )

/*++

Routine Description:

    This routine will find the next disk slot entry.

Arguments:

    None.

Return Value:

    A valid resource ID if one is found.

    -1 if no free entry is found.

--*/

{
    DWORD   index;

    for ( index = 1; index < MAX_DISKS; index++ ) {
        if ( DiskTable[index] == NULL ) {
            return((RESID)( UlongToPtr(index) ) );
        }
    }

    return((RESID)-1);

} // DiskspGetNextDisk



VOID
WINAPI
DisksTerminate(
    IN RESID Resource
    )
{
   ULONG uResId=PtrToUlong(Resource);

   PDISK_RESOURCE resourceEntry = DiskTable[uResId];
   if ( resourceEntry == NULL ) {
       DISKS_PRINT("Terminate, bad resource id, %u\n", uResId);
       return;
   }
   // Wait for offline thread to complete, if there is one //
   ClusWorkerTerminate(&(resourceEntry->OfflineThread));
   DisksOfflineOrTerminate(resourceEntry, TERMINATE);
}


DWORD
WINAPI
DisksArbitrate(
    IN RESID Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    )

/*++

Routine Description:

    Arbitrate for a device by performing a reservation on the device.

Arguments:

    Resource - supplies resource id to be brought online.

    LostQuorumResource - routine to call when quorum resource is lost.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code if other failure.

--*/

{
    PDISK_RESOURCE  resourceEntry;
    DWORD status;

    ULONG uResId = PtrToUlong(Resource);

    //
    // Make sure the RESID is okay.
    //
    resourceEntry = DiskTable[uResId];
    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Arbitrate, bad resource id, %u\n", uResId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    // [HACKHACK]
    // [GorN] 10/28/1999. If Offline thread detects that
    //   it is being terminated, it will not set the resource status to
    //   offline. ArbitrateCount != 0 will give it a hint on whether
    //   to set the resource status or not

    InterlockedIncrement(&resourceEntry->ArbitrationInfo.ArbitrateCount);

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb]Wait for offline thread to complete...\n"
        );
    ClusWorkerTerminate(&(resourceEntry->OfflineThread));

    //
    // Perform DoAttach only. Do not open.
    //
    status = DisksOpenResourceFileHandle(resourceEntry, L"Arbitrate",0);
    if (status != ERROR_SUCCESS) {
       goto error_exit;
    }

    status = DiskArbitration( resourceEntry, DiskspClusDiskZero );

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb]Arbitrate returned status %1!u!.\n",
        status );

    if (status == ERROR_SUCCESS) {
       resourceEntry->LostQuorum = LostQuorumResource;
    }
error_exit:
    InterlockedDecrement(&resourceEntry->ArbitrationInfo.ArbitrateCount);

    return status;
} // DisksArbitrate //



RESID
WINAPI
DisksOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for Disk resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies handle to this resource's cluster
        registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    DWORD       diskResource = 0;
    UCHAR       deviceName[MAX_PATH];
    DWORD       status;
    HKEY        clusDiskParametersKey = NULL;
    HKEY        resourceParametersKey = NULL;
    HKEY        resKey = NULL;
    PDISK_RESOURCE  resourceEntry;
    DWORD       valueType;
    DWORD       valueLength;
    LPWSTR      nameOfPropInError;
    DWORD       previousDiskCount;

    //
    // Open registry parameters key for ClusDisk.
    //
    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           CLUSDISK_REGISTRY_SIGNATURES,
                           0,
                           KEY_READ,
                           &clusDiskParametersKey );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open ClusDisk parameters key. Error: %1!u!.\n",
            status );
        return(0);
    }

    //
    // Open the resource's parameters key.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                CLUSREG_KEYNAME_PARAMETERS,
                                KEY_READ | KEY_WRITE,
                                &resourceParametersKey );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open resource parameters key. Error: %1!u!.\n",
            status );
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(ResourceHandle,
                        LOG_ERROR,
                        L"Unable to open resource key. Error: %1!u!.\n",
                        status );
        goto error_exit;
    }

    //
    // Allocate and zero disk info structure.
    //
    resourceEntry = LocalAlloc(LMEM_FIXED, sizeof(DISK_RESOURCE));
    if (!resourceEntry) {
        status = GetLastError();
        (DiskpLogEvent)(ResourceHandle,
                        LOG_ERROR,
                        L"Unable to allocate disk resource data. Error: %1!u!.\n",
                        status );
        goto error_exit;
    }
    ZeroMemory( resourceEntry, sizeof(DISK_RESOURCE));
    resourceEntry->ResourceParametersKey = resourceParametersKey;
    resourceEntry->ClusDiskParametersKey = clusDiskParametersKey;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ResourceHandle = ResourceHandle;
    //resourceEntry->Inserted = FALSE;
    //resourceEntry->Attached = FALSE;
    //resourceEntry->DiskInfo.Params.Signature = 0;

    status = ArbitrationInfoInit(resourceEntry);
    if ( status != ERROR_SUCCESS ) {
       LocalFree( resourceEntry );
       goto error_exit;
    }
    status = CreateArbWorkQueue(ResourceHandle);
    if ( status != ERROR_SUCCESS ) {
       LocalFree( resourceEntry );
       goto error_exit;
    }

#if 0
    //
    // GN: It seems that there is no point doing this here
    //     If we are on the join path, we cannot get
    //     any information about the disk and the call will fail
    //
    //     If we are forming the cluster we will update the information
    //     when we bring the disk online
    //
    status = DiskspSsyncDiskInfo( L"Open", resourceEntry , 0 );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(ResourceHandle,
                        LOG_ERROR,
                        L"Unable to ssync DiskInfo. Error: %1!u!.\n",
                        status );
    }
#endif

    //
    // Save disk info structure.
    //

    EnterCriticalSection( &DisksLock );

    if (DiskspClusDiskZero == NULL) {
        status = DevfileOpen(&DiskspClusDiskZero, L"\\Device\\ClusDisk0");
        if (!NT_SUCCESS(status) ) {
            MountieCleanup ( &resourceEntry -> MountieInfo );
            ArbitrationInfoCleanup( resourceEntry );
            LocalFree( resourceEntry );
            LeaveCriticalSection( &DisksLock );
            (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Cannot open a handle to clusdisk driver, %1!x!.\n",
                status);
            goto error_exit;
        }
    }
    diskResource = PtrToUlong(DiskspGetNextDisk());

    if ( diskResource >= MAX_DISKS ) {
        MountieCleanup ( &resourceEntry -> MountieInfo );
        ArbitrationInfoCleanup( resourceEntry );
        LocalFree( resourceEntry );
        LeaveCriticalSection( &DisksLock );
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Couldn't find an available resource slot %1!u!.\n",
            diskResource);
        status = ERROR_ALLOTTED_SPACE_EXCEEDED;
        goto error_exit;
    }

    DiskTable[diskResource] = resourceEntry;
    previousDiskCount = InterlockedExchangeAdd(&DiskCount, 1);

    LeaveCriticalSection( &DisksLock );

    if (previousDiskCount == 0) {
        StartNotificationWatcherThread();
    }

    DisksMountPointInitialize( resourceEntry );

    //
    // Read our disk signature from the resource parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( resourceEntry->ResourceParametersKey,
                                                   DiskResourcePrivateProperties,
                                                   (LPBYTE) &resourceEntry->DiskInfo.Params,
                                                   FALSE, //CheckForRequiredProperties
                                                   &nameOfPropInError );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
    }

    return((RESID)( UlongToPtr(diskResource) ) );

error_exit:

    if ( clusDiskParametersKey != NULL ) {
        RegCloseKey( clusDiskParametersKey );
    }

    if ( resourceParametersKey != NULL ) {
        ClusterRegCloseKey( resourceParametersKey );
    }

    if ( resKey != NULL ) {
        ClusterRegCloseKey( resKey );
    }

    SetLastError( status );
    return((RESID)0);

} // DisksOpen



DWORD
WINAPI
DisksRelease(
    IN RESID Resource
    )

/*++

Routine Description:

    Release arbitration for a device by stopping the reservation thread.

Arguments:

    Resource - supplies resource id to be brought online

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_HOST_NODE_NOT_OWNER if the resource is not owned.
    A Win32 error code if other failure.

--*/

{
    DWORD       status;
    PDISK_RESOURCE  resourceEntry;
    ULONG  uResId=PtrToUlong(Resource);

    //
    // Make sure the RESID is okay.
    //

    resourceEntry = DiskTable[uResId];
    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Release, bad resource id, %u\n", uResId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    (DiskpLogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"DisksRelease started, Inserted = %1!u! \n",
       resourceEntry->Inserted );

    if (resourceEntry->Inserted) { // [GN] #209018 //
       (DiskpLogEvent)(
           resourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Cannot release, Disk is online.\n");
    } else {
       StopPersistentReservations(resourceEntry);
    }
    resourceEntry->LostQuorum = NULL;

    return(ERROR_SUCCESS);

} // DisksRelease



DWORD
WINAPI
DisksOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Disk resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PDISK_RESOURCE  resourceEntry;
    DWORD  Status;
    ULONG  uResId=PtrToUlong(Resource);

    //
    // Make sure the RESID is okay.
    //

    resourceEntry = DiskTable[uResId];
    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Online, bad resource id, %u\n", uResId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Shutdown the online thread if it's running.
    //
    ClusWorkerTerminate(&resourceEntry->OnlineThread);

    Status = ClusWorkerCreate(&resourceEntry->OnlineThread,
                              DisksOnlineThread,
                              resourceEntry);
    if (Status == ERROR_SUCCESS) {
        Status = ERROR_IO_PENDING;
    }
    return(Status);

} // DisksOnline

DWORD
DisksOfflineThread(
    IN PCLUS_WORKER Worker,
    IN PDISK_RESOURCE ResourceEntry
    )
{
    RESOURCE_STATUS resourceStatus;
    DWORD status;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;
    ClusWorkerTerminate( &ResourceEntry->OnlineThread );
    status = DisksOfflineOrTerminate(ResourceEntry, OFFLINE);

    if (status == ERROR_SUCCESS) {
        resourceStatus.ResourceState = ClusterResourceOffline;
    }

    //
    // [HACKHACK] [GorN 10/04/1999]
    //    If Terminate is called when the offline is in progress,
    //    the terminate blocks waiting for OfflineThread to complete.
    //    However, offline thread is stuck trying
    //    to set ResourceStatus, since event list lock in the resmon
    //    is taken out by Terminate thread.
    //
    //    The following code doesn't fix this deadlock completely.
    //    It just reduces the window during which the problem can occur.
    //    [Resmon times out SetResourceStatus in 3 minutes, this breaks the deadlock]
    //
    // [HACKHACK] [GorN 10/28/1999]
    //    Arbitrate is also trying to terminate the offline thread
    //    We need some way to distinguish between these two cases
    //
    //    The order of setting is
    //       ArbitrateCount
    //       ClusWorkerTerminate
    //
    //    Order of checking is ClusWorkerTerminate then ArbitrateCount.
    //    (Won't work with aggressive memory access reordering, but who cares <grin>)
    //
    if ( !ClusWorkerCheckTerminate( Worker ) ||
          ResourceEntry->ArbitrationInfo.ArbitrateCount)
    {
        (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                 &resourceStatus );
    }
    return status;
}

DWORD
WINAPI DisksOffline(
	IN RESID ResourceId
	)
{
	PDISK_RESOURCE	ResourceEntry;
	DWORD			status = ERROR_SUCCESS;
    ULONG  uResId=PtrToUlong(ResourceId);

    //
    // Make sure the RESID is okay.
    //

    ResourceEntry = DiskTable[uResId];
    if ( ResourceEntry == NULL ) {
        DISKS_PRINT("Offline, bad resource id, %u\n", uResId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    status = ClusWorkerCreate( &ResourceEntry->OfflineThread,
                               (PWORKER_START_ROUTINE)DisksOfflineThread,
                               ResourceEntry );
    if ( status	!= ERROR_SUCCESS )
    {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread, status %1!u!.\n",
            status
            );
    }
    else
    {
        status = ERROR_IO_PENDING;
    }

    return status;

} // DisksOffline


BOOL
WINAPI
DisksIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for Disk resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    DWORD  status;
    PDISK_RESOURCE resourceEntry;

    ULONG uResId=PtrToUlong(Resource);

    //
    // Make sure the RESID is okay.
    //

    resourceEntry = DiskTable[uResId];
    if ( resourceEntry == NULL ) {
        DISKS_PRINT("IsAlive, bad resource id, %u\n", uResId);
        return(FALSE);
    }

    if ( resourceEntry->DiskInfo.FailStatus != 0 ) {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive, error checking device, error %1!u!.\n",
            resourceEntry->DiskInfo.FailStatus );
        ClusResLogSystemEventByKey(resourceEntry->ResourceKey,
                                   LOG_CRITICAL,
                                   RES_DISK_FAILED_SCSI_CHECK);
        resourceEntry->DiskInfo.FailStatus = 0;
        return(FALSE);
    }

    //
    // Check out the interesting partitions.
    //

#if 0
    (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"About to call DriveIsAlive!\n" );
#endif

    status = DisksDriveIsAlive( resourceEntry,
                                FALSE);

    if (status == ERROR_SUCCESS) {
        return(TRUE);
    } else {
        ClusResLogSystemEventByKeyData(resourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_DISK_FILESYSTEM_FAILED,
                                       sizeof(status),
                                       &status);
        return(FALSE);
    }

} // DisksIsAlive


BOOL
WINAPI
DisksLooksAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    LooksAlive routine for Disk resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    BOOL  success;
    PDISK_RESOURCE resourceEntry;

    ULONG uResId=PtrToUlong(Resource);

    //
    // Make sure the RESID is okay.
    //

    resourceEntry = DiskTable[uResId];
    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Online, bad resource id, %u\n", uResId);
        return(FALSE);
    }

    if ( resourceEntry->DiskInfo.FailStatus != 0 ) {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive, error checking device, error %1!u!.\n",
            resourceEntry->DiskInfo.FailStatus );
        return FALSE;
    }

    return(TRUE);

} // DisksLooksAlive


VOID
WINAPI
DisksClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for Disk resource.

Arguments:

    Resource - supplies resource id to be closed.

Return Value:

    None.

--*/

{
    PDISK_RESOURCE resourceEntry;

    ULONG uResId=PtrToUlong(Resource);

    //
    // Make sure the RESID is okay.
    //

    resourceEntry = DiskTable[uResId];
    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Close, bad resource id, %u\n", uResId);
        return;
    }

    //
    // Wait for the online thread to finish.
    //
    DisksTerminate( Resource );

    DisksMountPointCleanup( resourceEntry );

    if ( resourceEntry->DiskInfo.Params.SerialNumber ) {
        LocalFree( resourceEntry->DiskInfo.Params.SerialNumber );
        resourceEntry->DiskInfo.Params.SerialNumber = NULL;
    }
    
    DiskTable[uResId] = NULL;
    if ( InterlockedExchangeAdd(&DiskCount, -1) == 1 ) {
        // This is the last disk //
        StopNotificationWatcher();
        DestroyArbWorkQueue();
    }

    ClusterRegCloseKey( resourceEntry->ResourceParametersKey);
    ClusterRegCloseKey( resourceEntry->ResourceKey);
    RegCloseKey(resourceEntry->ClusDiskParametersKey);
    ArbitrationInfoCleanup(resourceEntry);
    MountieCleanup( &resourceEntry->MountieInfo );
    LocalFree(resourceEntry);

    return;

} // DisksClose


#define TEST_WRITE_BUFFER_SIZE    512
#define TEST_WRITE_BUFFER_BLOCKS  10


DWORD
DisksWriteTestFile(
    IN PWCHAR VolumeName,
    IN PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Checks for disk corruption problem by opening a temporary file, writing
    a test pattern, and saving the file.  Then it reopens the file, reads
    the data and verifies the data.  If any part of this fails, indicate an
    error to the caller so that chkdsk can run.

Arguments:

    VolumeName - Supplies the device name of the form:
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the resource structure

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PTEB currentTeb;

    HANDLE hFile = INVALID_HANDLE_VALUE;

    PCHAR testBuffer = NULL;
    PCHAR testBufferSave;
    PCHAR readBuffer = NULL;

    WCHAR szFilePrefix[] = L"zClusterOnlineChk.tmp";
    WCHAR tempFileName[MAX_PATH * 2];

    ULONG hardErrorValue;

    BOOL hardErrorsDisabled = FALSE;

    DWORD error = ERROR_SUCCESS;
    DWORD bytesTransferred;
    DWORD i;
    DWORD len;

    //
    // Wrap in try-finally.
    //

    _try {

        //
        // Temporarily disable hard pop-ups.
        //

        currentTeb = NtCurrentTeb();
        hardErrorValue = currentTeb->HardErrorsAreDisabled;
        currentTeb->HardErrorsAreDisabled = 1;
        hardErrorsDisabled = TRUE;

        //
        // Allocate and prepare the test buffer.
        //

        testBuffer = LocalAlloc( LMEM_FIXED, TEST_WRITE_BUFFER_SIZE );

        if ( !testBuffer ) {
            error = GetLastError();
            (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                            L"DisksWriteTestFile: Unable to allocate test buffer %1!u! \n",
                            error );
            _leave;
        }

        testBufferSave = testBuffer;
        for ( i = 0; i < TEST_WRITE_BUFFER_SIZE; i++ ) {
            testBuffer[i] = (CHAR)i;
        }
        testBuffer = testBufferSave;

        //
        // Allocate the read buffer.
        //

        readBuffer = LocalAlloc( LMEM_FIXED, TEST_WRITE_BUFFER_SIZE );

        if ( !readBuffer ) {
            error = GetLastError();
            (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                            L"DisksWriteTestFile: Unable to allocate read buffer %1!u! \n",
                            error );
            _leave;
        }

        //
        // Create a temporary file name.  GetTempFileNameW doesn't like the path
        // \\?\Volume{GUID}\ so we build our own file name.
        //

        len = wcslen( VolumeName );

        if ( len > sizeof(tempFileName) ) {
            error = ERROR_ALLOTTED_SPACE_EXCEEDED;
            _leave;
        }

        ZeroMemory( tempFileName, sizeof(tempFileName) );

        wcsncpy( tempFileName, VolumeName, len );
        wcsncat( tempFileName, szFilePrefix, wcslen( szFilePrefix ) );

        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_INFORMATION,
                        L"DisksWriteTestFile: Creating test file (%1!ws!) \n",
                        tempFileName );

        //
        // First, try to delete the file to make sure we didn't leave one laying around.
        // We will ignore the return status as the next CreateFile will fail when we try
        // to open the temporary file again.
        //

        DeleteFileW( tempFileName );

        //
        // Open temporary file.  Make sure the data is actually written to the disk
        // and is not cached.  Do NOT specify FILE_ATTRIBUTE_TEMPORARY as the system
        // will then try to keep all the file's data in memory instead of on the
        // disk.
        //

        hFile = CreateFileW( tempFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_NEW,
                             FILE_FLAG_WRITE_THROUGH,
                             NULL );

        if ( INVALID_HANDLE_VALUE == hFile ) {
            error = GetLastError();
            (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                            L"DisksWriteTestFile: CreateFile for (%1!ws!) failed %2!u! \n",
                            tempFileName,
                            error );
            _leave;
        }

        //
        // Write the data pattern for some number of blocks.
        //

        for ( i = 0; i < TEST_WRITE_BUFFER_BLOCKS; i++ ) {

            if ( !WriteFile( hFile,
                             testBuffer,
                             TEST_WRITE_BUFFER_SIZE,
                             &bytesTransferred,
                             NULL ) ) {

                // Write failed...

                error = GetLastError();
                (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                                L"DisksWriteTestFile: Write test file failed %1!u! \n",
                                error );
                _leave;
            }

            if ( bytesTransferred != TEST_WRITE_BUFFER_SIZE ) {
                error = ERROR_IO_DEVICE;
                (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                                L"DisksWriteTestFile: bytes written (%1!u!) != test buffer (%2!u!) \n",
                                bytesTransferred,
                                TEST_WRITE_BUFFER_SIZE );
                _leave;
            }

        }

        //
        // Close the file.
        //

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;

        //
        // Reopen the same file.
        //

        hFile = CreateFileW( tempFileName,
                             GENERIC_READ,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

        if ( INVALID_HANDLE_VALUE == hFile ) {
            error = GetLastError();
            (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                            L"DisksWriteTestFile: CreateFile (second open) for (%1!ws!) failed %2!u! \n",
                            tempFileName,
                            error );
            _leave;
        }

        //
        // Read the data and compare to original buffer.
        //

        for ( i = 0; i < TEST_WRITE_BUFFER_BLOCKS; i++ ) {

            if ( !ReadFile( hFile,
                            readBuffer,
                            TEST_WRITE_BUFFER_SIZE,
                            &bytesTransferred,
                            NULL ) ) {

                // Read failed...

                error = GetLastError();
                (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                                L"DisksWriteTestFile: Read test file failed %1!u! \n",
                                error );
                _leave;
            }

            if ( bytesTransferred != TEST_WRITE_BUFFER_SIZE ) {
                error = ERROR_IO_DEVICE;
                (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                                L"DisksWriteTestFile: bytes read (%1!u!) != test buffer (%2!u!) \n",
                                bytesTransferred,
                                TEST_WRITE_BUFFER_SIZE );
                _leave;
            }

            //
            // Compare original buffer to that just read from file.
            //

            if ( !memcmp( testBuffer, readBuffer, TEST_WRITE_BUFFER_SIZE ) ) {

                //
                // Buffers identical, check next buffer.
                //

                continue;
            }

            // Miscompare...

            error = ERROR_IO_DEVICE;

            (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                            L"DisksWriteTestFile: byte miscompare in block %1!u! \n",
                            i );
            _leave;

        }

    }
    _finally {

        //
        // Clean up all resources.
        //

        if ( testBuffer ) {
            LocalFree( testBuffer );
        }

        if ( readBuffer ) {
            LocalFree( readBuffer );
        }

        if ( hFile != INVALID_HANDLE_VALUE ) {

            //
            // Close must happen before the delete.
            //

            CloseHandle( hFile );

            //
            // Only report an error deleting file if the error code was not set
            // in the code above.  We don't want to overwrite a potentially
            // informative error code.
            //

            if ( !DeleteFileW( tempFileName ) && ( ERROR_SUCCESS == error ) ) {
                error = GetLastError();

                (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                                L"DisksWriteTestFile: Unable to delete file (%1!ws!) failed %2!u! \n",
                                tempFileName,
                                error );
            }
        }

        //
        // Re-enable hard pop-ups.
        //

        if ( hardErrorsDisabled ) {
            currentTeb = NtCurrentTeb();
            currentTeb->HardErrorsAreDisabled = hardErrorValue;
        }
    }

    if ( ERROR_DISK_FULL == error ) {

        DWORD quorumSignature;
        DWORD logMsg;
        DWORD logLevel;

        //
        // We don't want chkdsk to run because the disk is full, so indicate there
        // was no error and write a message to system event log.
        //

        error = NO_ERROR;

        if ( NO_ERROR == GetQuorumSignature( &quorumSignature ) ) {

            if ( quorumSignature == ResourceEntry->DiskInfo.Params.Signature ) {
                logMsg = RES_DISK_FULL_DISK_QUORUM;
                logLevel = LOG_CRITICAL;
            } else {
                logMsg = RES_DISK_FULL_DISK_NOT_QUORUM;
                logLevel = LOG_UNUSUAL;
            }
        } else {
            logMsg = RES_DISK_FULL_DISK_UNKNOWN;
            logLevel = LOG_CRITICAL;
        }

        ClusResLogSystemEventByKey1(ResourceEntry->ResourceKey,
                                    logLevel,
                                    logMsg,
                                    VolumeName );
    }

    (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_INFORMATION,
                    L"DisksWriteTestFile: Returns status %1!u! \n",
                    error );

    return error;

}   // DisksWriteTestFile


DWORD
DisksCheckCorruption(
    IN PWCHAR DeviceName,
    IN PWCHAR VolumeName,
    IN PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Checks for disk corruption problems.

Arguments:

    DeviceName - Supplies name of the form:
                \Device\HarddiskX\PartitionY    [Note: no trailing backslash]

    VolumeName - Supplies the device name of the form:
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the resource structure

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    BOOL dirty;
    DWORD status = ERROR_SUCCESS;

    if ( ResourceEntry->DiskInfo.Params.SkipChkdsk ) {
        status = ERROR_SUCCESS;
        goto FnExit;
    }

    status = DisksIsVolumeDirty( DeviceName, ResourceEntry, &dirty );
    if (status == ERROR_SUCCESS && dirty) {

        status = ERROR_DISK_CORRUPT;

    } else {

        status = DisksWriteTestFile( VolumeName, ResourceEntry );

        if ( status != ERROR_SUCCESS ) {
            status = ERROR_DISK_CORRUPT;
        }
    }

FnExit:

    return status;

} // DisksCheckCorruption


DWORD
DisksFixCorruption(
    IN PWCHAR VolumeName,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD CorruptStatus
    )

/*++

Routine Description:

    Fix file or disk corrupt problems.

Arguments:

    VolumeName - Supplies the device name of the form:
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the disk resource entry

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes:

    We'll need to lock the volume exclusive while we do this...
    So threads that call this routine should ensure there are no
    open files!

--*/

{
    LPWSTR  chkdskLogFileName = NULL;

    DWORD   Status;
    DWORD   len;
    STARTUPINFOW StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    WCHAR   CheckDiskInfo[MAX_PATH*2];
    RESOURCE_STATUS resourceStatus;
    RESOURCE_EXIT_STATE exit;
    BOOL    replaceBackslash;

    BOOL    bInheritHandles;
    HANDLE  chkdskLogFile = INVALID_HANDLE_VALUE;
    UINT    previousMode;

    previousMode = SetErrorMode( SEM_FAILCRITICALERRORS|SEM_NOGPFAULTERRORBOX|SEM_NOOPENFILEERRORBOX );

    //
    // We need to strip the trailing backslash off so chkdsk will work.
    //

    len = wcslen( VolumeName );

    if ( len > MAX_PATH ) {
        SetErrorMode( previousMode );
        return ERROR_ALLOTTED_SPACE_EXCEEDED;
    }

    if ( VolumeName[len-1] == L'\\') {
        VolumeName[len-1] = UNICODE_NULL;
        replaceBackslash = TRUE;
    } else {
        replaceBackslash = FALSE;
    }

    //
    // Now handle the corruption problem by running CHKDSK.
    //

    _snwprintf(CheckDiskInfo, MAX_PATH * 2, L"ChkDsk /x /f %ws", VolumeName);

    //
    // Restore the backslash.
    //

    if ( replaceBackslash ) {
        VolumeName[len-1] = L'\\';
    }


    ZeroMemory( &StartupInfo, sizeof(STARTUPINFOW) );
    StartupInfo.cb = sizeof(STARTUPINFO);
    StartupInfo.lpDesktop = L"WinSta0\\Default";

    bInheritHandles = FALSE;

    Status = DisksOpenChkdskLogFile( ResourceEntry,
                                     &chkdskLogFile,
                                     &chkdskLogFileName );

    if ( NO_ERROR == Status && INVALID_HANDLE_VALUE != chkdskLogFile ) {

        //
        // When the output is redirected, we don't want to show the console window because it
        // will be blank with simply a title in it.  The event log message will let the user
        // know to look in the chkdsk file.
        //

        StartupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
        StartupInfo.wShowWindow = SW_HIDE;

        // Someone watching the console won't know what is happening, so show
        // the window anyway...
        // StartupInfo.dwFlags = STARTF_USESTDHANDLES;

        StartupInfo.hStdInput = GetStdHandle(STD_INPUT_HANDLE);

        //
        // [169631] Chkdsk now verifies that hStdInput is not NULL.
        // Since the resmon process was started with InheritHandles set to FALSE,
        // GetStdHandle(STD_INPUT_HANDLE) will return NULL.  When we run chkdsk with
        // the options "/f /x", chkdsk should not be prompting the user and the
        // input handle wouldn't be used.  However, ulibs.dll was changed to always
        // insure a nonzero input handle was supplied.  So we have to supply some type
        // of input handle.  We could put INVALID_HANDLE_VALUE here, but the checks
        // may change and it will fail later.  For now, point input to the temporary
        // output file we created.
        //

        if ( NULL == StartupInfo.hStdInput ) {
            StartupInfo.hStdInput = chkdskLogFile;
        }

        StartupInfo.hStdOutput = chkdskLogFile;
        StartupInfo.hStdError = chkdskLogFile;

        bInheritHandles = TRUE;
    }

    //
    // Log an event
    //
    if ( CorruptStatus == ERROR_DISK_CORRUPT ) {
        // Must be corrupt disk
        ClusResLogSystemEventByKey2(ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_CORRUPT_DISK,
                                    VolumeName,
                                    chkdskLogFileName);
    } else {
        // Must be corrupt file.
        ClusResLogSystemEventByKey2(ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_CORRUPT_FILE,
                                    VolumeName,
                                    chkdskLogFileName);
    }

    if ( chkdskLogFileName ) {
        LocalFree( chkdskLogFileName );
        chkdskLogFileName = NULL;
    }

    if ( !CreateProcessW( NULL,
                          CheckDiskInfo,
                          NULL,
                          NULL,
                          bInheritHandles,
                          NORMAL_PRIORITY_CLASS,
                          NULL,
                          NULL,
                          &StartupInfo,
                          &ProcessInfo ) ) {
        Status = GetLastError();

        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                        L"DisksFixCorruption: CreateProcessW for chkdsk failed %1!u! \n",
                        Status );

        if ( INVALID_HANDLE_VALUE != chkdskLogFile ) {
            CloseHandle( chkdskLogFile );
        }
        SetErrorMode( previousMode );
        return(Status);
    }

    CloseHandle( ProcessInfo.hThread );

    //
    // Wait for CHKDSK to finish.
    //
#if 1
    //
    // Don't wait "forever"... things could get ugly if we dismount the file
    // system while ChkDsk is running! But KeithKa says its okay to kill
    // ChkDsk while it is running - it has to handle powerfails, crashes, etc.
    //
    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    while ( !ResourceEntry->OnlineThread.Terminate ) {
        (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                 &resourceStatus );
        Status = WaitForSingleObject( ProcessInfo.hProcess, 2000 );
        if ( Status != WAIT_TIMEOUT ) {
            break;
        }
    }

    if ( ResourceEntry->OnlineThread.Terminate ) {
        // If we were asked to terminate, make sure ChkNtfs is killed
        TerminateProcess( ProcessInfo.hProcess, 999 );
        CloseHandle( ProcessInfo.hProcess );
        if ( INVALID_HANDLE_VALUE != chkdskLogFile ) {
            CloseHandle( chkdskLogFile );
        }
        SetErrorMode( previousMode );
        return(ERROR_SHUTDOWN_CLUSTER);
    }

    //
    // Update our checkpoint state.
    //
    ++resourceStatus.CheckPoint;
    exit = (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                    &resourceStatus );
    if ( exit == ResourceExitStateTerminate ) {
        TerminateProcess( ProcessInfo.hProcess, 998 );
        CloseHandle( ProcessInfo.hProcess );
        if ( INVALID_HANDLE_VALUE != chkdskLogFile ) {
            CloseHandle( chkdskLogFile );
        }
        SetErrorMode( previousMode );
        return(ERROR_SHUTDOWN_CLUSTER);
    }

#else
    // Wait "forever"...
    Status = WaitForSingleObject( ProcessInfo.hProcess, INFINITE );
#endif

    if ( (Status == 0) &&
        GetExitCodeProcess( ProcessInfo.hProcess, &Status ) ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"FixCorruption: CHKDSK returned status of %1!u!.\n",
                        Status );
// [From supera.hxx]
//
// These symbols are used by Chkdsk functions to return an appropriate
// exit status to the chkdsk program.
// In order of most important first, the error level order are as follows:
//   3 > 1 > 2 > 0
// An error level of 3 will overwrite an error level of 1, 2, or 0.

// #define CHKDSK_EXIT_SUCCESS         0
// #define CHKDSK_EXIT_ERRS_FIXED      1
// #define CHKDSK_EXIT_MINOR_ERRS      2       // whether or not "/f"
// #define CHKDSK_EXIT_CLEANUP_WORK    2       // whether or not "/f"
// #define CHKDSK_EXIT_COULD_NOT_CHK   3
// #define CHKDSK_EXIT_ERRS_NOT_FIXED  3
// #define CHKDSK_EXIT_COULD_NOT_FIX   3

        if (Status >= 3) {
            Status = ERROR_DISK_CORRUPT;
        } else {
            Status = ERROR_SUCCESS;
        }
    }

    CloseHandle( ProcessInfo.hProcess );

    if ( INVALID_HANDLE_VALUE != chkdskLogFile ) {
        CloseHandle( chkdskLogFile );
    }

    SetErrorMode( previousMode );

    return(Status);

} // DisksFixCorruption

DWORD
DiskspGetQuorumPath(
     OUT LPWSTR* lpQuorumLogPath
     )
/*++

Routine Description:

    Reads QuorumPath value from the registry.


Arguments:

    lpQuorumLogPath - receives the poiner to a buffer containing QuorumLogPath
                      the buffer needs to be deallocated later via LocalFree

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD Status;
    LPWSTR QuorumLogPath = NULL;
    DWORD QuorumLogSize = 0;
    DWORD Type;
    HKEY  QuorumKey;

    Status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         DISKS_REG_CLUSTER_QUORUM,
                         &QuorumKey );
    if ( Status == ERROR_SUCCESS ) {
        Status = RegQueryValueExW(QuorumKey,
                                  DISKS_REG_QUORUM_PATH,
                                  0,
                                  &Type,
                                  NULL,
                                  &QuorumLogSize );
        if ( Status != ERROR_SUCCESS ) {
            return( Status );
        }

        if ( (Type != REG_SZ) ||
             (QuorumLogSize > (MAX_PATH - 2)) ) {
            return(ERROR_INVALID_DATA);
        }
        if ( (Status == ERROR_SUCCESS) ||
             (Status == ERROR_MORE_DATA) ) {
            QuorumLogPath = LocalAlloc( LMEM_FIXED,
                                        (QuorumLogSize + 1) * sizeof(WCHAR) );
            if ( QuorumLogPath == NULL ) {
                RegCloseKey( QuorumKey );
                return(ERROR_NOT_ENOUGH_MEMORY); // Mostly catastrophic
            }

            Status = RegQueryValueExW(QuorumKey,
                                      DISKS_REG_QUORUM_PATH,
                                      0,
                                      &Type,
                                      (LPBYTE)QuorumLogPath,
                                      &QuorumLogSize );
            if (Status == ERROR_SUCCESS) {
                *lpQuorumLogPath = QuorumLogPath;
            } else {
                LocalFree(QuorumLogPath);
                *lpQuorumLogPath = 0;
            }
        }
        RegCloseKey( QuorumKey );
    }
    return Status;
}

DWORD
DiskspSetQuorumPath(
     IN LPWSTR QuorumLogPath
     )
/*++

Routine Description:

    Reads QuorumPath value from the registry.


Arguments:

    lpQuorumLogPath - receives the poiner to a buffer containing QuorumLogPath
                      the buffer needs to be deallocated later via LocalFree

    ResourceEntry - receives a drive letter of the quorum

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD status;
    HKEY  QuorumKey;
    HKEY  ClusterKey;

    HCLUSTER hCluster;

    hCluster = OpenCluster(NULL);
    if (!hCluster) {
        status = GetLastError();
        return status;
    }

    ClusterKey = GetClusterKey(hCluster, KEY_READ | KEY_WRITE);
    if (!ClusterKey) {
        status = GetLastError();
        CloseCluster(hCluster);
        return status;
    }

    status = ClusterRegOpenKey( ClusterKey,
                                CLUSREG_KEYNAME_QUORUM,
                                KEY_READ | KEY_WRITE,
                                &QuorumKey );
    if (status != ERROR_SUCCESS) {
        ClusterRegCloseKey(ClusterKey);
        CloseCluster(hCluster);
        return status;
    }

    status = ResUtilSetSzValue(
                QuorumKey,
                CLUSREG_NAME_QUORUM_PATH,
                QuorumLogPath,
                0);

    ClusterRegCloseKey(QuorumKey);
    ClusterRegCloseKey(ClusterKey);
    CloseCluster(hCluster);
    return status;
}


DWORD
DisksDriveIsAlive(
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL Online
    )

/*++

Routine Description:

    Checks out a drive partition to see if the filesystem has mounted
    it and it's working. We will also run CHKDSK if the partition/certain
    files are Corrupt and the Online flag is TRUE.

Arguments:

    ResourceEntry - Supplies a pointer to the resource entry for this disk

    Online - TRUE if the disk was just brought online.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PMOUNTIE_PARTITION entry;

    DWORD Status = ERROR_SUCCESS;
    DWORD nPartitions = MountiePartitionCount( &ResourceEntry->MountieInfo );
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
    DWORD i;

    LPWSTR QuorumLogPath = NULL;
    BOOL  QuorumResource = FALSE;

    WCHAR szDiskPartName[MAX_PATH];
    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];
    WCHAR szQuorumVolumeName[MAX_PATH];
    WCHAR szQuorumDriveLetter[16];

    ZeroMemory( szDiskPartName, sizeof(szDiskPartName) );
    ZeroMemory( szGlobalDiskPartName, sizeof(szGlobalDiskPartName) );
    ZeroMemory( szVolumeName, sizeof(szVolumeName) );
    ZeroMemory( szQuorumVolumeName, sizeof(szQuorumVolumeName) );
    ZeroMemory( szQuorumDriveLetter, sizeof(szQuorumDriveLetter) );

    //
    // Find the quorum path... this is a hack!
    //
    if ( Online ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"DriveIsAlive called for Online check\n" );

        {
            DWORD QuorumSignature;
            Status = GetQuorumSignature( &QuorumSignature );
            if (Status == ERROR_SUCCESS) {
                QuorumResource =
                    (QuorumSignature == ResourceEntry->DiskInfo.Params.Signature);
            } else {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_INFORMATION,
                      L"GetQuorumSignature returned %1!u!\n", Status );
            }
        }


        Status = DiskspGetQuorumPath( &QuorumLogPath );
        if (Status != ERROR_SUCCESS) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"DiskspGetQuorumPath returned %1!u!\n", Status );

        } else {

            //
            // For now, quorum path will have a drive letter.  Get the corresponding volume name.
            //

            _snwprintf( szQuorumDriveLetter,
                        16,
                        L"%wc:\\",
                        QuorumLogPath[0] );

            if ( !GetVolumeNameForVolumeMountPointW( szQuorumDriveLetter,
                                                     szQuorumVolumeName,
                                                     sizeof(szQuorumVolumeName)/sizeof(WCHAR) )) {

                    Status = GetLastError();

                    (DiskpLogEvent)(
                          ResourceEntry->ResourceHandle,
                          LOG_ERROR,
                          L"DriveIsAlive: GetVolumeNameForVolumeMountPoint (quorum) returned %1!u!\n", Status );

            }

        }

    }

#if 0
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DriveIsAlive is now checking each partition\n" );
#endif

    //
    // Now check out each interesting partition.  Since only "valid" partitions are
    // saved in the MountieInfo structure, we will only look at those (ignoring those
    // partitions that are not NTFS).
    //

    for ( i = 0; i < nPartitions; ++i ) {

        entry = MountiePartition( &ResourceEntry->MountieInfo, i );

        if ( !entry ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"DriveIsAlive no partition entry for partition %1!u! \n", i );

            //
            // Something bad happened to our data structures.  We have to indicate that the
            // drive is not alive.
            //

            Status = ERROR_INVALID_DATA;

            break;
        }

        //
        // Create device name of form \Device\HarddiskX\PartitionY (no trailing backslash).
        //

        _snwprintf( szDiskPartName,
                    MAX_PATH,
                    DEVICE_HARDDISK_PARTITION_FMT,
                    physicalDrive,
                    entry->PartitionNumber );

        //
        // Given the DiskPartName, get the VolGuid name.  This name must have a trailing
        // backslash to work correctly.
        //

        _snwprintf( szGlobalDiskPartName,
                    MAX_PATH,
                    GLOBALROOT_HARDDISK_PARTITION_FMT,
                    physicalDrive,
                    entry->PartitionNumber );

        if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                 szVolumeName,
                                                 sizeof(szVolumeName)/sizeof(WCHAR) )) {

            Status = GetLastError();

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"DriveIsAlive: GetVolumeNameForVolumeMountPoint for %1!ws! returned %2!u!\n",
                  szGlobalDiskPartName,
                  Status );

            //
            // If disk is not corrupt, exit.  If disk is corrupt, fall through so chkdsk runs.
            //

            if ( ERROR_DISK_CORRUPT != Status && ERROR_FILE_CORRUPT != Status ) {

                //
                // Something bad happened.  We have to stop checking this disk.  Return the
                // error status we received.
                //

                break;
            }

        }

        //
        // Simple algorithm used here is to do a FindFirstFile on X:\* and see
        // if it works. Then we open each file for read access. This is the
        // cluster directory, and all files in it are subject to our opening.
        //

        Status = DiskspCheckPath( szVolumeName,
                                  ResourceEntry,
                                  FALSE,
                                  Online );

        //
        // [HACKHACK] Ignore error 21 during periodic IsAlive/LooksAlive
        //
        if ( !Online && (Status == ERROR_NOT_READY) ) {
            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_WARNING,
                            L"DiskpCheckPath for %1!ws!: returned status = %2!u! (ChkDsk running?)\n",
                            szVolumeName,
                            Status );
            Status = ERROR_SUCCESS;
        }

        // if we haven't chkdsk'd yet, keep looking.
        if ( Status != ERROR_SUCCESS ) {
            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskpCheckPath for %1!ws!: returned status = %2!u!\n",
                            szVolumeName,
                            Status );
        }

        if ( (Status == ERROR_SUCCESS) && Online &&
             QuorumLogPath && QuorumResource &&
             ( wcslen( szVolumeName ) == wcslen( szQuorumVolumeName ) ) &&
             ( !wcsncmp( szVolumeName, szQuorumVolumeName, wcslen( szQuorumVolumeName ) ))) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"DriveIsAlive checking quorum drive \n" );

            //
            // Everything looks fine... if this is the quorum device, then
            // we should check the quorum log path if given
            //

            Status = DiskspCheckPath( szQuorumVolumeName,
                                      ResourceEntry,
                                      TRUE,
                                      Online );
        }

        if ( (Status == ERROR_SUCCESS) &&
             Online ) {

            //
            // Check if the volume dirty bit is on
            //
            Status = DisksCheckCorruption( szDiskPartName,
                                           szVolumeName,
                                           ResourceEntry );

            //
            // If we're requested to shutdown, then do that immediately
            if ( ResourceEntry->OnlineThread.Terminate ) {
                Status = ERROR_SHUTDOWN_CLUSTER;
                break;
            }
        }


        if ( (Status != ERROR_SUCCESS) && Online) {
            if ( ResourceEntry->DiskInfo.Params.ConditionalMount ) {

                Status = DisksFixCorruption( szVolumeName,
                                             ResourceEntry,
                                             ERROR_DISK_CORRUPT );

                //
                // Since ConditionalMount is set, if we couldn't fix the corruption
                // on the disk, we don't want to continue checking the other
                // partitions - we want to return an error.  So we fall through
                // and check the status.  If status wasn't successful, we break out
                // of the loop to return the error.
                //

            } else {
                if ( QuorumLogPath ) {
                    LocalFree( QuorumLogPath );
                }
                return( Status );
            }
        }
        if ( Status != ERROR_SUCCESS ) {
            break;
        }

    }

    if ( QuorumLogPath ) {
        LocalFree( QuorumLogPath );
    }

    return(Status);

}  // DisksDriveIsAlive



DWORD
DisksMountDrives(
    IN PDISK_INFO DiskInfo,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Signature
    )
/*++

Routine Description:

    For each drive letter on the supplied disk, this mounts the filesystem
    and checks it out.

Arguments:

    DiskInfo - Supplies the disk information

    ResourceEntry - Supplies a pointer to the disk resource

    Signature - the signature for the disk.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    WCHAR wDeviceName[4];
    WCHAR wShareName[4];
    DWORD letterMask;
    UCHAR index;
    UCHAR driveLetter;
    SHARE_INFO_2 shareInfo;

    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"DisksMountDrives: calling IsAlive function.\n" );

    //
    // Call the IsAlive to see if the filesystem checks out ok.
    //
    Status = DisksDriveIsAlive( ResourceEntry,
                                TRUE);

    if ( (Status != ERROR_SUCCESS) ||
         (ResourceEntry->OnlineThread.Terminate) ) {
        return(Status);
    }

    //
    // Now create the drive$ share name for each drive letter;
    //
    letterMask = DisksGetLettersForSignature(
                            ResourceEntry);

    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"DisksMountDrives: letter mask is %1!08x!.\n",
                    letterMask);

    index = 0;
    while ( letterMask ) {
        while ( !(letterMask & 1) ) {
            letterMask = letterMask >> 1;
            index++;
        }
        driveLetter = 'A' + index;
        letterMask = letterMask >> 1;
        index++;
        if ( isalpha(driveLetter) ) {
            wsprintfW(wDeviceName, L"%c:\\", driveLetter);
            wsprintfW(wShareName, L"%c$", driveLetter);
            shareInfo.shi2_netname = wShareName;
            shareInfo.shi2_type = STYPE_DISKTREE;
            shareInfo.shi2_remark = NULL;
            shareInfo.shi2_permissions = 0;
            shareInfo.shi2_max_uses = (DWORD)-1;
            shareInfo.shi2_current_uses = 0;
            shareInfo.shi2_path = wDeviceName;
            shareInfo.shi2_passwd = NULL;

            Status = NetShareAdd( NULL, 2, (PBYTE)&shareInfo, NULL );
            if ( Status != ERROR_SUCCESS && Status != NERR_DuplicateShare ) {
                (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                                LOG_ERROR,
                                L"DisksMountDrives, error creating default share %1!ws!. Error: %2!u!.\n",
                                wShareName,
                                Status);
            }
        }
    }

    return(ERROR_SUCCESS);

}  // DisksMountDrives


DWORD
DisksDismountDrive(
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Signature
    )

/*++

Routine Desccription:

    Delete the default device share names for a given disk.

Arguments:

    ResourceHandle - the resource handle for logging events

    Signature - the disk's signature

Return Value:

    WIN32 error code.

--*/

{
    WCHAR   shareName[8];
    DWORD   letterMask;
    UCHAR   index;
    UCHAR   driveLetter;

    letterMask = DisksGetLettersForSignature(
                            ResourceEntry);

    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"DisksDismountDrives: letter mask is %1!08x!.\n",
                    letterMask);

    index = 0;
    while ( letterMask ) {
        while ( !(letterMask & 1) ) {
            letterMask = letterMask >> 1;
            index++;
        }
        driveLetter = 'A' + index;
        letterMask = letterMask >> 1;
        index++;
        if ( isalpha(driveLetter) ) {
            shareName[0] = (WCHAR)driveLetter;
            shareName[1] = (WCHAR)'$';
            shareName[2] = (WCHAR)0;

            NetShareDel( NULL,
                         shareName,
                         0 );

        }
    }

    return (ERROR_SUCCESS);

} // DisksDismountDrive



LPSTR
GetRegParameter(
    IN HKEY RegKey,
    IN LPCSTR ValueName
    )

/*++

Routine Description:

    Queries a REG_SZ parameter out of the registry and allocates the
    necessary storage for it.

Arguments:

    RegKey - Supplies the cluster key where the parameter is stored

    ValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter if successful.

    NULL if unsuccessful.

--*/

{
    LPSTR Value;
    DWORD ValueLength;
    DWORD ValueType;
    DWORD Status;

    ValueLength = 0;
    Status = RegQueryValueEx(RegKey,
                             ValueName,
                             NULL,
                             &ValueType,
                             NULL,
                             &ValueLength);
    if ( (Status != ERROR_SUCCESS) &&
         (Status != ERROR_MORE_DATA) ) {
        return(NULL);
    }
    if ( ValueType == REG_SZ ) {
        ValueLength++;
    }
    Value = LocalAlloc(LMEM_FIXED, ValueLength);
    if (Value == NULL) {
        return(NULL);
    }
    Status = RegQueryValueEx(RegKey,
                             ValueName,
                             NULL,
                             &ValueType,
                             (LPBYTE)Value,
                             &ValueLength);
    if (Status != ERROR_SUCCESS) {
        LocalFree(Value);
        Value = NULL;
    }

    return(Value);

}  // GetRegParameter


DWORD
DisksResourceControl(
    IN RESID Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD           status = ERROR_SUCCESS;
    PDISK_RESOURCE  resourceEntry;
    DWORD           required;

    ULONG uResId=PtrToUlong(Resource);

    //
    // Make sure the RESID is okay.
    //

    resourceEntry = DiskTable[uResId];
    if ( resourceEntry == NULL ) {
        DISKS_PRINT("ResourceControl, bad resource id, %u\n", uResId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( DiskResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
            }
            break;

        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
            status = GetDiskInfo( resourceEntry->DiskInfo.Params.Signature,
                                  &OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  FALSE );

            // Add the endmark.
            if ( OutBufferSize > *BytesReturned ) {
                OutBufferSize -= *BytesReturned;
            } else {
                OutBufferSize = 0;
            }
            *BytesReturned += sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize >= sizeof(CLUSPROP_SYNTAX) ) {
                PCLUSPROP_SYNTAX ptrSyntax = OutBuffer;
                ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            }
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( DiskResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = DisksGetPrivateResProperties( resourceEntry,
                                                   OutBuffer,
                                                   OutBufferSize,
                                                   BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = DisksValidatePrivateResProperties( resourceEntry,
                                                        InBuffer,
                                                        InBufferSize,
                                                        NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = DisksSetPrivateResProperties( resourceEntry,
                                                   InBuffer,
                                                   InBufferSize );
#if 0
            status = ClusterRegQueryValue(resourceEntry->ResourceParametersKey,
                                          DISKS_DISK_INFO,
                                          NULL,
                                          NULL,
                                          &required);
            if (status == ERROR_FILE_NOT_FOUND ) {
                // If not found, then make it.
                PFT_INFO diskInfo;
                diskInfo = DiskGetFtInfo();
                if ( diskInfo ) {
                    status = DiskspRestoreState( resourceEntry,
                                                 diskInfo );
                    DiskFreeFtInfo( diskInfo );
                }
            }
#else
            DiskspSsyncDiskInfo(L"ResourceControl", resourceEntry, 0);
#endif
            break;

        case CLUSCTL_RESOURCE_DELETE:
            if ( resourceEntry->DiskInfo.Params.Signature ) {
                (DiskpLogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Delete disk resource %1!lx!\n",
                    resourceEntry->DiskInfo.Params.Signature );
                status = DoDetach( resourceEntry->DiskInfo.Params.Signature,
                                   resourceEntry->ResourceHandle );
            }
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_DELETE_REQUIRES_ALL_NODES;
            }
            break;

        case CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION:

            status = ProcessDllExtension( resourceEntry,
                                          InBuffer,
                                          InBufferSize,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned );
            break;

        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
        case CLUSCTL_RESOURCE_ADD_DEPENDENCY:

            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Add/Remove dependency:  source signature %1!lx!  target name (%2!ws!) \n",
                resourceEntry->DiskInfo.Params.Signature,
                InBuffer );

            status = DisksProcessMPControlCode( resourceEntry,
                                                ControlCode );

            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // DisksResourceControl



DWORD
DisksResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Process control requests for this resource type.

Arguments:

    ResourceTypeName - the name of the resource type - not very useful!

    ControlCode - the control request

    InBuffer - pointer to the input buffer

    InBufferSize - the size of the input buffer

    OutBuffer - pointer to the output buffer

    OutBufferSize - the size of the output buffer

    BytesReturned - the number of bytes returned (or needed if larger than
                OutBufferSize and ERROR_MORE_DATA is returned

Return Value:

    ERROR_SUCCESS if successful

    A WIN32 error on failure

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( DiskResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_HOLD_IO:
            DoHoldIO();
            break;

        case CLUSCTL_RESOURCE_TYPE_RESUME_IO:
            DoResumeIO();
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( DiskResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS:
            status = ClusDiskGetAvailableDisks( OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                FALSE );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_DELETE_REQUIRES_ALL_NODES;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // DisksResourceTypeControl



DWORD
DisksGetPrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type Physical Disk.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties(
                                    ResourceEntry->ResourceParametersKey,
                                    DiskResourcePrivateProperties,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned,
                                    &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // DisksGetPrivateResProperties



DWORD
DisksConvertDriveToSignature(
    IN OUT PDISK_PARAMS Params,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Change the drive letter or VolGuid to the associated disk signature.

Arguments:

    Params - Supplies the parameter block that contains the drive letter
            (or VolGuid) to convert to a signature.

            VolGuid syntax is returned from mountvol.exe and in the form:
                \\?\Volume{e6de97f1-6f97-11d3-bb7f-806d6172696f}\

    ResourceHandle -

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly or is invalid.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    PWCHAR  deviceName = NULL;
    DWORD   deviceNameBytes;
    DWORD   lenChar;
    DWORD   status = ERROR_SUCCESS;
    LPWSTR  drive = Params->Drive;
    LPWSTR  volGuid = Params->VolGuid;
    HANDLE  fileHandle;
    BOOL    success;
    PDRIVE_LAYOUT_INFORMATION driveLayout = NULL;

    //
    // Build device string for CreateFile
    //

    if ( drive ) {

        deviceNameBytes = (( wcslen( drive ) + wcslen( L"\\\\.\\" ) ) * sizeof(WCHAR) ) +
                            sizeof( UNICODE_NULL );

        deviceName = LocalAlloc( LPTR, deviceNameBytes );

        if ( !deviceName ) {
            goto FnExit;
        }

        _snwprintf( deviceName,
                    deviceNameBytes/sizeof(WCHAR),
                    L"\\\\.\\%ws",
                    drive );

    } else if ( volGuid ) {

        deviceNameBytes = ( wcslen( volGuid ) * sizeof( WCHAR ) ) + sizeof( UNICODE_NULL );

        deviceName = LocalAlloc( LPTR, deviceNameBytes );

        if ( !deviceName ) {
            goto FnExit;
        }

        CopyMemory( deviceName,
                    volGuid,
                    deviceNameBytes );

        //
        // If user specified \\?\Volume{guid}\ with trailing backslash, we need to get
        // rid of the backslash.
        //

        lenChar = wcslen( deviceName );

        if ( lenChar > 1 && L'\\' == deviceName[lenChar-1] ) {
            deviceName[lenChar-1] = L'\0';
        }


    } else {
        goto FnExit;
    }

    fileHandle = CreateFileW( deviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL );
    if ( (fileHandle == INVALID_HANDLE_VALUE) ||
         (fileHandle == NULL) ) {
        status = GetLastError();
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"ConvertDriveToSignature, error opening device '%1!ws!'. Error: %2!u!\n",
            deviceName,
            status );
        goto FnExit;
    }

    //
    // Get drive layout - in order to get disk signature.
    //
    success = ClRtlGetDriveLayoutTable( fileHandle, &driveLayout, NULL );

    if ( success &&
         driveLayout->Signature ) {
        Params->Signature = driveLayout->Signature;

        if ( Params->Drive ) {
            LocalFree( Params->Drive );
            Params->Drive = NULL;
        }

        if ( Params->VolGuid ) {
            LocalFree( Params->VolGuid );
            Params->VolGuid = NULL;
        }

    } else {
        status = ERROR_FILE_NOT_FOUND;
    }

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }
    CloseHandle( fileHandle );

FnExit:

    if ( deviceName ) {
        LocalFree( deviceName );
    }

    return(status);

} // DisksConvertDriveToSignature


DWORD
DisksValidatePrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PDISK_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Physical Disk.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly or is invalid.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           enableSanBoot;
    DWORD           diskNumber;
    DWORD           oldSerNumLen = 0;
    DWORD           newSerNumLen = 0;
    DISK_PARAMS     params;
    PDISK_PARAMS    pParams;
    PDISK_PARAMS    currentParams = &ResourceEntry->DiskInfo.Params;

    SCSI_ADDRESS            scsiAddress;
    CLUSPROP_SCSI_ADDRESS   clusScsiAddress;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &params;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(DISK_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) currentParams,
                                       DiskResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties. Accept the alternate name here.
    //
    status = ResUtilVerifyPropertyTable( DiskResourcePrivatePropertiesAlt,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );
    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //
    // First make sure there are no bogus properties - i.e. we don't allow
    // specifying both the signature and the drive in the same request.
    // We also don't allow specifying the VolGuid and signature in the same
    // request.
    //
    if ( (pParams->Drive || pParams->VolGuid) && pParams->Signature ) {
        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    if ( pParams->Drive || pParams->VolGuid ) {
        //
        // Convert from drive to signature.
        //
        status = DisksConvertDriveToSignature( pParams,
                                               ResourceEntry->ResourceHandle );
    }

    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //
    // Verify the new serial number is valid and not overwriting an existing
    // serial number.
    //
    
    if ( pParams->SerialNumber ) {
        newSerNumLen = wcslen( pParams->SerialNumber );
    }
    
    if ( currentParams->SerialNumber ) {
        oldSerNumLen = wcslen( currentParams->SerialNumber );
    }
    
    //
    // If there was an old serial number, make sure the new serial number is
    // the same.
    //
    
    if ( oldSerNumLen && 
            ( oldSerNumLen != newSerNumLen || 
              0 != wcsncmp( currentParams->SerialNumber, pParams->SerialNumber, newSerNumLen ) ) ) {
        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    //
    // Check serial number and signature.
    //
    
    if ( 0 == oldSerNumLen &&
         pParams->SerialNumber && 
         0 == currentParams->Signature ) {
        
        //
        // New serial number specified and no current signature.
        //
        
        if ( 0 == pParams->Signature ) {

            //
            // No new signature specified, use the new serial number to 
            // find the new signature.
            //

            status = GetSignatureFromSerialNumber( pParams->SerialNumber,
                                                   &pParams->Signature );
            
            if ( status != ERROR_SUCCESS ) {
                goto FnExit;
            }
            
        } else {
        
            //
            // New signature and new serial number specified.  Fail the request.
            //
            
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }
    }
    
    //
    // Validate the parameter values.
    //
    // Make sure the disk signature is not zero.
    //

    if ( 0 == pParams->Signature ) {
        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    // At this point, we have a valid disk signature.
    
    //
    // If no serial number, get it.
    //
    
    if ( !pParams->SerialNumber || newSerNumLen <= 1 ) {
        
        status = GetSerialNumber( pParams->Signature,
                                  &pParams->SerialNumber );
    }

    if ( ERROR_SUCCESS != status ) {
        goto FnExit;
    }
    

    ZeroMemory( &clusScsiAddress, sizeof(clusScsiAddress) );
    status = GetScsiAddress( pParams->Signature, &clusScsiAddress.dw, &diskNumber );

    if ( ERROR_SUCCESS != status ) {
        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    scsiAddress.Length      = sizeof(SCSI_ADDRESS);
    scsiAddress.PortNumber  = clusScsiAddress.PortNumber;
    scsiAddress.PathId      = clusScsiAddress.PathId;
    scsiAddress.TargetId    = clusScsiAddress.TargetId;
    scsiAddress.Lun         = clusScsiAddress.Lun;

    //
    // Make sure the SCSI address is not system disk.
    //

    enableSanBoot = 0;
    GetRegDwordValue( CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_VALUENAME_MANAGEDISKSONSYSTEMBUSES,
                      &enableSanBoot );


    if ( !enableSanBoot ) {

        //
        // Signature is valid if:
        //  - the signature is for a disk not on system bus
        //

        if ( IsDiskOnSystemBus( &scsiAddress ) ) {
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

    } else {

        // Allow disks on system bus to be added to cluster.

        //
        // Signature is valid if:
        //  - the signature is not for the system disk

        if ( IsDiskSystemDisk( &scsiAddress ) ) {
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

    }

    //
    // For now, we don't allow setting mount point volume GUIDs this way.
    // This is a multi SZ string, so use memcmp to skip past each string's
    // terminating NULL.
    //

    if ( ( currentParams->MPVolGuidsSize != pParams->MPVolGuidsSize ) ||
         ( 0 != memcmp( currentParams->MPVolGuids, pParams->MPVolGuids, currentParams->MPVolGuidsSize ) ) ) {
    
        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

FnExit:

    //
    // Cleanup our parameter block.
    //
    if ( pParams == &params ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                   DiskResourcePrivateProperties );
    }

    return(status);

} // DisksValidatePrivateResProperties



DWORD
DisksSetPrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Physical Disk.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DISK_PARAMS     params;

    ZeroMemory( &params, sizeof(DISK_PARAMS) );

    //
    // Parse and validate the properties.
    //
    status = DisksValidatePrivateResProperties( ResourceEntry,
                                                InBuffer,
                                                InBufferSize,
                                                &params );
    if ( status != ERROR_SUCCESS ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                   DiskResourcePrivateProperties );
        return(status);
    }

    //
    // We cannot allow changing the Signature 'on the fly'...
    //
    if ( (ResourceEntry->DiskInfo.Params.Signature != 0) &&
         (params.Signature != ResourceEntry->DiskInfo.Params.Signature) ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                   DiskResourcePrivateProperties );
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SetPrivateProperties doesn't allow changing signature, old %1!lx!, new %2!lx!\n",
            ResourceEntry->DiskInfo.Params.Signature,
            params.Signature );
        return(ERROR_INVALID_STATE);
    }

    //
    // Save the parameter values.
    //
    // NB: Unknown, or non-property table values are dealt with farther below.  That is why InBuffer and
    // InBufferSize are not used in this call.  Only the propertys in the parameter block are handled here.
    //
    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ResourceParametersKey,
                                               DiskResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               NULL,
                                               0,
                                               (LPBYTE) &ResourceEntry->DiskInfo.Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->DiskInfo.Params,
                               DiskResourcePrivateProperties );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SetPrivateResProperties: Error %1!d! saving properties\n",
            status );
        return(status);
    }

    //
    // Save any unknown properties.
    //
    status = ResUtilSetUnknownProperties(
                ResourceEntry->ResourceParametersKey,
                DiskResourcePrivatePropertiesAlt,
                InBuffer,
                InBufferSize );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SetPrivateResProperties: Error %1!d! saving unknown properties\n",
            status );
    }

    //
    // Try to attach to this device if we have a signature.
    //
    if ( ResourceEntry->DiskInfo.Params.Signature ) {
       #if 0
        DiskspVerifyState(  ResourceEntry );
       #endif
        DoAttach( ResourceEntry->DiskInfo.Params.Signature,
                  ResourceEntry->ResourceHandle );
        // ignore status return
    }

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( ResourceEntry->Valid ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // DisksSetPrivateResProperties



DWORD
ProcessDllExtension(
    IN PDISK_RESOURCE ResourceEntry,
    IN PVOID    InBuffer,
    IN DWORD    InBufferSize,
    OUT PVOID   OutBuffer,
    IN DWORD    OutBufferSize,
    OUT LPDWORD BytesReturned
    )
/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION control function
    for resources of type Physical Disk.  The caller will specify a DLL
    and DLL entry point that should be called.  This routine will call
    into that entry point with the disk device name represented by the
    Signature parameter.

Arguments:

    ResourceEntry -

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to a buffer containing output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - the number of bytes returned (or needed if larger than
                OutBufferSize and ERROR_MORE_DATA is returned

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The input data is formatted incorrectly.

    ERROR_REVISION_MISMATCH - The input buffer did not have the correct
        revision information.

    ERROR_MORE_DATA - The output buffer is not large enough to hold all
        the requested data.

    Win32 error code - The function failed.

--*/
{
    lpPassThruFunc  passThruFunc = NULL;

    PCHAR           dllModuleName;
    PCHAR           dllProcName;
    PCHAR           contextStr;

    PDISK_DLL_EXTENSION_INFO    passThru = InBuffer;

    HINSTANCE       dllModule = NULL;
    DWORD           scsiAddress;
    DWORD           diskNumber;
    DWORD           dwStatus;
    DWORD           signature = ResourceEntry->DiskInfo.Params.Signature;
    DWORD           expandedSize;

    CHAR            deviceName[MAX_PATH];
    CHAR            expandedDllModuleName[MAX_PATH];

    if ( !InBuffer || !OutBuffer || !OutBufferSize ) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    if ( InBufferSize < sizeof(DISK_DLL_EXTENSION_INFO) ) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    try {

        if ( passThru->MajorVersion != NT5_MAJOR_VERSION ||
             passThru->MinorVersion != 0 ) {

            dwStatus = ERROR_REVISION_MISMATCH;
            goto FnExit;
        }

        //
        // Get the DLL module name from the Input buffer.
        //

        dllModuleName = passThru->DllModuleName;

        //
        // Get the DLL entry point name from the Input buffer.
        //

        dllProcName = passThru->DllProcName;

        contextStr = passThru->ContextStr;

        //
        // Get the SCSI address to build the device name.
        //

        dwStatus = GetScsiAddress( signature, &scsiAddress, &diskNumber );

        if ( NO_ERROR != dwStatus ) {
            goto FnExit;
        }

        _snprintf( deviceName, sizeof(deviceName), "\\\\.\\PhysicalDrive%d", diskNumber );

        expandedSize = ExpandEnvironmentStrings( dllModuleName, expandedDllModuleName, MAX_PATH );

        if ( !expandedSize ) {
            dwStatus = GetLastError();
            goto FnExit;
        }

        if ( expandedSize > MAX_PATH ) {
            dwStatus = ERROR_BAD_PATHNAME;
            goto FnExit;
        }

        //
        // Assume the DLL has not yet been loaded into the address space.
        // The caller should specify a fully qualified path name to make sure their
        // DLL is called, and they are responsible for making sure that the DLL is
        // protected.
        //

        dllModule = LoadLibraryEx( expandedDllModuleName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );

        if ( NULL == dllModule ) {
            dwStatus = GetLastError();
            goto FnExit;
        }

        //
        // The function name MUST be as defined (i.e. with exactly the same type
        // and number of parameters) or we will have stack problems.
        //

        passThruFunc = (lpPassThruFunc)GetProcAddress( dllModule, dllProcName );

        if ( NULL == passThruFunc ) {

            //
            // The specified function is not available in the DLL, exit now.
            //

            dwStatus = GetLastError();
            goto FnExit;
        }

        //
        // Call into the specified DLL.
        //

        dwStatus = (passThruFunc)( deviceName,
                                   contextStr,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        dwStatus = GetExceptionCode();

        (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"ProcessDllExtension: Exception occurred %1!X! \n",
                         dwStatus );
    }

FnExit:

    if ( dllModule ) {
        FreeLibrary( dllModule );
    }

    return dwStatus;

}   // ProcessDllExtension


DWORD
DisksOpenChkdskLogFile(
    IN PDISK_RESOURCE ResourceEntry,
    IN OUT PHANDLE ChkdskLogFile,
    IN OUT LPWSTR *ChkdskLogFileName
    )
/*++

Routine Description:

    Creates a file to log chkdsk output and returns the handle to the caller.
    The file will not be deleted on close.

Arguments:

    ResourceEntry - Supplies a pointer to the resource structure

    ChkdskLogFile - Returned handled of newly opened log file.

    ChkdskLogFileName - String pointer to the name of the newly
                        opened log file.  Caller is responsible
                        for freeing storage.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD status = NO_ERROR;
    HANDLE retHandle = INVALID_HANDLE_VALUE;

    PWCHAR last;
    PWCHAR current;

    LPWSTR clusterDir = NULL;
    LPWSTR fileName = NULL;
    LPWSTR finalFileName = NULL;

    DWORD clusterDirLength;             // This value can change.
    DWORD fileNameLength = MAX_PATH;
    DWORD finalFileNameLength;

    SECURITY_ATTRIBUTES sa;

    if ( !ChkdskLogFile || !ChkdskLogFileName ) {
        return ERROR_INVALID_PARAMETER;
    }

    *ChkdskLogFile = INVALID_HANDLE_VALUE;
    *ChkdskLogFileName = NULL;

    _try {

        //
        // Get the environment variable "ClusterLog".  Embedded in this string
        // is the cluster directory.
        //

        clusterDir = LocalAlloc( LMEM_FIXED, MAX_PATH * sizeof(WCHAR) );
        if ( !clusterDir ) {
            status = GetLastError();
            _leave;
        }

        clusterDirLength = GetEnvironmentVariableW( CLUSTERLOG_ENV_VARIABLE,
                                                    clusterDir,
                                                    MAX_PATH );

        if ( !clusterDirLength ) {
            status = GetLastError();
            _leave;
        }

        if ( clusterDirLength > MAX_PATH ) {

            LocalFree( clusterDir );
            clusterDir = LocalAlloc( LMEM_FIXED, clusterDirLength * sizeof( WCHAR ) );
            if ( NULL == clusterDir ) {
                status = GetLastError();
                _leave;
            }

            clusterDirLength = GetEnvironmentVariableW( CLUSTERLOG_ENV_VARIABLE,
                                                        clusterDir,
                                                        clusterDirLength );

            if ( !clusterDirLength ) {
                status = GetLastError();
                LocalFree( clusterDir );
                clusterDir = NULL;
                _leave;
            }
        }

        //
        // We have the log file path and name.  Find the last backslash and strip off the
        // log file name.  This will be used as our temporary file path.
        //

        last = NULL;
        current = (PWCHAR) clusterDir;

        while ( *current != L'\0' ) {

            if ( L'\\' == *current ) {
                last = current;
            }
            current++;
        }

        if ( !last ) {
            status = ERROR_BAD_FORMAT;
            _leave;
        }

        //
        // Change the last backslash to the end of string mark.
        //

        *last = L'\0';

        //
        // Now create a file name based on the disk signature.
        //

        fileName = LocalAlloc( LMEM_FIXED, fileNameLength * sizeof(WCHAR) );
        if ( !fileName ) {
            status = GetLastError();
            _leave;
        }

        _snwprintf( fileName, fileNameLength,
                    L"ChkDsk_Disk%d_Sig%08X.log",
                    ResourceEntry->DiskInfo.PhysicalDrive,
                    ResourceEntry->DiskInfo.Params.Signature );

        //
        // Put it all together for the final name.
        //

        finalFileNameLength = fileNameLength + clusterDirLength + MAX_PATH;

        finalFileName = LocalAlloc( LMEM_FIXED, finalFileNameLength  * sizeof(WCHAR));
        if ( !finalFileName ) {
            status = GetLastError();
            _leave;
        }

        _snwprintf( finalFileName, finalFileNameLength, L"%ws\\%ws", clusterDir, fileName );

        //
        // Now open up the file name to log the chkdsk info.
        //

        ZeroMemory( &sa, sizeof(sa) );
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle = TRUE;

        retHandle = CreateFileW( finalFileName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 &sa,
                                 CREATE_ALWAYS,             // Create a new file or overwrite existing file
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL );

        if ( INVALID_HANDLE_VALUE == retHandle ) {
            status = GetLastError();
            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DisksOpenChkdskLogFile: CreateFile returned status of %1!u! \n",
                            status );
            _leave;
        }

        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"DisksOpenChkdskLogFile: ChkDsk output is in file: %1!s! \n",
                        finalFileName );

    } _finally {

        *ChkdskLogFile = retHandle;

        if ( clusterDir ) {
            LocalFree( clusterDir );
        }

        if ( fileName ) {
            LocalFree( fileName );
        }

        if ( finalFileName ) {
            *ChkdskLogFileName = finalFileName;
        }
    }

    return status;

}   // DisksOpenChkdskLogFile


DWORD
GetRegDwordValue(
    IN LPWSTR RegKeyName,
    IN LPWSTR ValueName,
    OUT LPDWORD ValueBuffer
    )
{
    DWORD   dwValue;
    DWORD   dwValueType;
    DWORD   dwDataBufferSize = sizeof( DWORD );
    DWORD   dwError;

    HKEY    hClusParmKey = NULL;

    if ( !ValueBuffer ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    *ValueBuffer = 0;

    //
    // Open the cluster service parameters key.
    //

    dwError = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                             RegKeyName,
                             0,
                             KEY_READ,
                             &hClusParmKey );

    if ( ERROR_SUCCESS != dwError ) {
        goto FnExit;
    }

    //
    // Get the DWORD value.
    //

    dwError = RegQueryValueExW( hClusParmKey,
                                ValueName,
                                NULL,
                                &dwValueType,
                                (LPBYTE) &dwValue,
                                &dwDataBufferSize );

    if ( ERROR_SUCCESS == dwError ) {

        // Insure that a DWORD value was returned.  If not, return an error.

        if ( REG_DWORD == dwValueType ) {

            *ValueBuffer = dwValue;

        } else {

            dwError = ERROR_BAD_FORMAT;

        }
    }

FnExit:

    if ( hClusParmKey ) {
        RegCloseKey( hClusParmKey );
    }


    return dwError;

}   // GetRegDwordValue



//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( DisksFunctionTable,
                         CLRES_VERSION_V1_00,
                         Disks,
                         DisksArbitrate,
                         DisksRelease,
                         DisksResourceControl,
                         DisksResourceTypeControl );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\mountpoints.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mountpoints.c

Abstract:

    This module processes mount point information for the disk resource DLL.

Author:

    Steve Dziok (stevedz) 15-May-2000

Environment:

    User Mode
    
Revision History:

--*/

#define UNICODE 1

#include "disksp.h"

#include "arbitrat.h"
#include "newdisks.h"
#include "newmount.h"
#include <mountmgr.h>

#define SPACE_CHAR  L' '

#define MAX_OFFSET_CHARS    80      // Maximum number of chars allowed in offset string

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

extern PWCHAR GLOBALROOT_HARDDISK_PARTITION_FMT;    // L"\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition%u\\";

extern PWCHAR DEVICE_HARDDISK_PARTITION_FMT;        // L"\\Device\\Harddisk%u\\Partition%u";

#ifndef ClusterHashGuid

//
// Hash a GUID to a ULONG value.
//

#define ClusterHashGuid(_guid) ( ((PULONG) &(_guid))[0] ^ ((PULONG) &(_guid))[1] ^ \
                                 ((PULONG) &(_guid))[2] ^ ((PULONG) &(_guid))[3] )

#endif

#define MPS_ENABLED                         0x00000001
#define MPS_DELETE_INVALID_MPS              0x00000002  // Not currently used
#define MPS_NONCLUSTERED_TO_CLUSTERED_MPS   0x00000010  // Not currently used
#define MPS_KEEP_EXISTING_MPS               0x00000020  // Not currently used
#define MPS_IGNORE_MAX_VOLGUIDS             0x00000100

// Assume 32 nodes with 8 partitions per disk.
#define MAX_ALLOWED_VOLGUID_ENTRIES_PER_DISK    32 * 8

#define STOP_CLUSTER_ENUMERATIONS   ERROR_INVALID_PRINTER_COMMAND
#define PHYSICAL_DISK_WSTR  L"Physical Disk"
#define CHAR_TO_REPLACE 2

#define MOUNTDEV_WSZ_VOLUME_GUID_PREFIX         L"\\??\\Volume{"        // Forms: \??\Volume{
#define MOUNTDEV_CB_VOLUME_GUID_PREFIX          22

#define MOUNTDEV_LOOKS_LIKE_VOLUME_GUID(name, length) \
              ((length > MOUNTDEV_CB_VOLUME_GUID_PREFIX) && \
              (!memcmp(name, MOUNTDEV_WSZ_VOLUME_GUID_PREFIX, MOUNTDEV_CB_VOLUME_GUID_PREFIX)))

#define MOUNTDEV_WSZ_ALT_VOLUME_GUID_PREFIX     L"\\\\?\\Volume{"       // Forms: \\?\Volume{
#define MOUNTDEV_CB_ALT_VOLUME_GUID_PREFIX      22

#define MOUNTDEV_LOOKS_LIKE_ALT_VOLUME_GUID(name, bytelength) \
              ((bytelength > MOUNTDEV_CB_ALT_VOLUME_GUID_PREFIX) && \
              (!memcmp(name, MOUNTDEV_WSZ_ALT_VOLUME_GUID_PREFIX, MOUNTDEV_CB_ALT_VOLUME_GUID_PREFIX)))


typedef struct _SIG_INFO {
    DWORD Signature;
    BOOL Clustered;
} SIG_INFO, *PSIG_INFO;

typedef struct _DEPENDENCY_INFO {
    DWORD   SrcSignature;
    DWORD   TargetSignature;
    BOOL    DependencyCorrect;
} DEPENDENCY_INFO, *PDEPENDENCY_INFO;


typedef struct _STR_LIST {
    LPWSTR  MultiSzList;        // REG_MULTI_SZ string
    DWORD   ListBytes;          // Number of bytes, not number of WCHARs!
}   STR_LIST, *PSTR_LIST;

DWORD
AddStrToList(
    IN PDISK_RESOURCE ResourceEntry,
    IN PWSTR NewStr,
    IN DWORD PartitionNumber,
    IN OUT PSTR_LIST StrList
    );

DWORD
AssignDevice(
    HANDLE MountMgrHandle,
    PWCHAR MountName,
    PWCHAR VolumeDevName
    );

DWORD
CheckDependencies(
    DWORD SrcSignature,
    DWORD TargetSignature,
    PBOOL DependencyCorrect
    );

VOID
CheckMPsForVolume(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR VolumeName
    );

DWORD
CheckSignatureClustered(
    DWORD Signature,
    PBOOL IsClustered
    );

DWORD
CreateVolGuidList(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

DWORD
DeleteVolGuidList(
    PDISK_RESOURCE ResourceEntry
    );

DWORD 
DependencyCallback(
    RESOURCE_HANDLE hOriginal,   
    RESOURCE_HANDLE hResource,  
    PVOID lpParams   
    );

#if DBG
VOID
DumpDiskInfoParams(
    PDISK_RESOURCE ResourceEntry
    );
#endif

DWORD
EnumSigDependencies(
    RESOURCE_HANDLE DependentResource,
    DWORD DependsOnSignature,
    PBOOL DependencyCorrect
    );

DWORD
GetMountPoints(
    PWSTR   VolumeName,
    PWSTR   *VolumePaths
    );

BOOL
GetOffsetFromPartNo(
    DWORD PartitionNo,
    PMOUNTIE_INFO Info,
    PLARGE_INTEGER Offset
    );

BOOL
GetPartNoFromOffset(
    PLARGE_INTEGER Offset,
    PMOUNTIE_INFO Info,
    PDWORD PartitionNumber
    );

DWORD
GetSignatureForVolume(
    PDISK_RESOURCE ResourceEntry,
    PWSTR Volume,
    PDWORD Signature
    );

DWORD
GetSignatureFromDiskInfo(
    RESOURCE_HANDLE hResource,
    DWORD *dwSignature
    );

BOOL
IsMountPointAllowed(
    PWSTR MpName,
    PWSTR TargetVol,
    PDISK_RESOURCE ResourceEntry
    );

BOOL
MPIsDriveLetter(
    IN PWSTR MountPoint
    );

VOID
PrintStrList(
    PDISK_RESOURCE ResourceEntry,
    LPWSTR MultiSzList,
    DWORD ListBytes
    );

DWORD
ProcessVolGuidList(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

static
DWORD
SetMPListThread(
    LPVOID lpThreadParameter
    );

DWORD
SetupVolGuids(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

DWORD 
SigInfoCallback(
    RESOURCE_HANDLE hOriginal,   
    RESOURCE_HANDLE hResource,  
    PVOID lpParams   
    );

DWORD
ValidateListOffsets(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR MasterList
    );

DWORD
ValidateMountPoints(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

DWORD
WrapClusterResourceControl(
    RESOURCE_HANDLE hResource,
    DWORD dwControlCode,    
    LPVOID *OutBuffer,
    DWORD *dwBytesReturned
    );


DWORD
DisksProcessMountPointInfo(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    During online processing, find all mount points directed towards this volume
    (identified by the ResourceEntry), and process the VolGuid list for this
    volume.

    If the VolGuid list exists in the cluster database, use it.  Otherwise,
    get the current VolGuid and add it to the VolGuid list.

    VolGuid list is of the form:

        SectorOffset1 VolGuid1
        SectorOffset1 VolGuid2
        SectorOffset1 VolGuid3
        SectorOffset2 VolGuid1
        SectorOffset2 VolGuid2
        SectorOffset3 VolGuid1
        ...           ...

    There are three possible mount point configurations involving clustered disks (we
    are not concerned about nonshared disks pointing to nonshared disks):

            Source            -->   Target
            -----------------       -----------------
        1.  clustered disk          clustered disk
        2.  nonclustered disk       clustered disk
        3.  clustered disk          nonclustered disk

    Only configuration (1) is supported.  Configurations (2) and (3) are not supported.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    ERROR_NOT_READY - MPInfo structure not yet initialized.

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;
    
    //
    // Mount point structures not initialized (i.e. critical section).  Don't continue.
    //

    if ( !ResourceEntry->MPInfo.Initialized ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"DisksProcessMountPointInfo: Mount point information not initialized. \n" );
              
        return ERROR_NOT_READY;              
        
    }

#if USEMOUNTPOINTS_KEY
    //
    // Mount point support disabled, don't do anything.
    //
    
    if ( !( ResourceEntry->DiskInfo.Params.UseMountPoints & MPS_ENABLED ) ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"DisksProcessMountPointInfo: Mount point processing disabled via registry \n" );

        //
        // Delete the VolGuid list if it exists and remove this info 
        // from the cluster database.
        //
        
        dwError = DeleteVolGuidList( ResourceEntry );
        
        if ( ERROR_SHARING_PAUSED == dwError ) {
            PostMPInfoIntoRegistry( ResourceEntry );
        }

        dwError = NO_ERROR;
        return dwError;
    }
#endif

    //
    // Check if we are currently processing mount point info.  If so, exit with an error.
    //

    if ( InterlockedCompareExchange(
            &ResourceEntry->MPInfo.MPListCreateInProcess,
            1, 0 ) )  {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksProcessMountPointInfo: MPList creation in process, bypassing request \n" );
        return ERROR_BUSY;
    }

    __try {

        dwError = ProcessVolGuidList( ResourceEntry );

        ValidateMountPoints( ResourceEntry );
        
        // Fall through...

#if 0

        // Add code similar to this when MPs from nonclustered to clustered disks is supported.

        if ( ( ResourceEntry->DiskInfo.Params.UseMountPoints & MPS_ENABLED ) &&
             ( ResourceEntry->DiskInfo.Params.UseMountPoints & MPS_NONCLUSTERED_TO_CLUSTERED_MPS ) ) {
            
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"DisksProcessMountPointInfo: ProcessMPList \n" );

            dwError = ProcessMPListConfig2( ResourceEntry );
#endif    
        
    } __finally {
    
        InterlockedExchange( &ResourceEntry->MPInfo.MPListCreateInProcess, 0 );
    }
                              
    return dwError;

}   // DisksProcessMountPointInfo


DWORD
ProcessVolGuidList(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Main routine to create a new VolGuid list or to process an existing VolGuid list.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;
    
    __try {
    
        //
        // Always try to add the current VolGuid to the list.
        //
        
        dwError = CreateVolGuidList( ResourceEntry );
        if ( NO_ERROR != dwError ) {
             (DiskpLogEvent)(
                   ResourceEntry->ResourceHandle,
                   LOG_ERROR,
                   L"ProcessVolGuidList: Stop processing VolGuid list, Create failed %1!u! \n",
                   dwError );
            __leave;
        }
        
        //
        // If the list is empty here (it shouldn't be), then exit with an error.
        //

        if ( !ResourceEntry->DiskInfo.Params.MPVolGuids ||
             0 == ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {
        
            dwError = ERROR_INVALID_DATA;
            __leave;
        }
        
        PrintStrList( ResourceEntry, 
                      ResourceEntry->DiskInfo.Params.MPVolGuids,
                      ResourceEntry->DiskInfo.Params.MPVolGuidsSize ); 
        
        //
        // Make sure the offsets are correct in the VolGuid list.
        // Note that it is possible for the list to be deleted and
        // recreated after this validation, but that is not a problem (because
        // when they are recreated they will have the correct offsets).
        //

        dwError = ValidateListOffsets( ResourceEntry, 
                                       ResourceEntry->DiskInfo.Params.MPVolGuids );

        if ( ERROR_INVALID_DATA == dwError ) {

            //
            // At least one of the offsets is invalid.  Possibly, the partition
            // layout on the disk has been changed.  Delete the existing 
            // list, and create a new one.
            //
            // This code should run infrequently...
            //
            // The partition layout might change if ASR runs and creates new partitions
            // that don't match the previous system exactly.  Since NTBACKUP saves the
            // cluster DB information, the mount point list will be restored but won't
            // match the actual "new" partition layout.  ASR will insure that all the
            // mount points and VolGuids on the system are created, so we should be able 
            // to simply delete and recreate the mount point list.
            //        

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"ProcessVolGuidList: Invalid offset in existing VolGuid list.  Deleting and recreating. \n" );
            
            DeleteVolGuidList( ResourceEntry );

            dwError = CreateVolGuidList( ResourceEntry );
            
            __leave;
        
        } else if ( ERROR_INSUFFICIENT_BUFFER == dwError ) {
            //
            // The Volguid list is too large and likely corrupt.  We cannot 
            // proceed.
            //

            __leave;
        }

        //
        // For every VolGuid in the list, make sure they are assigned to the correct
        // volumes on this system.
        //

        dwError = SetupVolGuids( ResourceEntry );

    } __finally {
    
    }

    return dwError;
    
}   // ProcessVolGuidList


DWORD
CreateVolGuidList(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Add the current system VolGuid to the list.  If the list is empty, create a new list.

    For each partition on this disk (identified by the ResourceEntry), get the byte
    offset of that partition.  Get the current VolGuid for that parition, and add
    it to the list.  If the current VolGuid is already in the list, ignore the error.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    ERROR_INVALID_DATA - partition info in disk resource is invalid

    Win32 error code.

--*/
{
    PMOUNTIE_PARTITION entry;

    HANDLE  mountMgrHandle = INVALID_HANDLE_VALUE;

    DWORD dwError = ERROR_SUCCESS;
    DWORD nPartitions = MountiePartitionCount( &ResourceEntry->MountieInfo );
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
    DWORD idx;
    DWORD volumeNameLenChars;   // Number of characters
    DWORD newStrListLenBytes;   // Number of bytes
    
    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];
    
    STR_LIST    newStrList;

    BOOL        freeNewList = TRUE;

    __try {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"CreateVolGuidList: Adding current VolGuid to list \n" );

        EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

        ZeroMemory( szGlobalDiskPartName, sizeof(szGlobalDiskPartName) );
        ZeroMemory( szVolumeName, sizeof(szVolumeName) );
        ZeroMemory( &newStrList, sizeof(STR_LIST) );

        dwError = DevfileOpen( &mountMgrHandle, MOUNTMGR_DEVICE_NAME );
        
        if ( dwError != NO_ERROR ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"CreateVolGuidList: Failed to open MountMgr %1!u! \n",
                  dwError );
            __leave;
        }

        newStrListLenBytes = ResourceEntry->DiskInfo.Params.MPVolGuidsSize;

        if ( newStrListLenBytes ) {
            
            newStrList.MultiSzList = LocalAlloc( LPTR, newStrListLenBytes );
            
            if ( !(newStrList.MultiSzList) ) {
                
                dwError = GetLastError();
                
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"CreateVolGuidList: Failed to allocate storage for new list %1!u! \n",
                      dwError );

                __leave;
            }
        
            //
            // Copy current list to newStrList.
            //
    
            memcpy( newStrList.MultiSzList, ResourceEntry->DiskInfo.Params.MPVolGuids, newStrListLenBytes );
            newStrList.ListBytes = newStrListLenBytes;

#if 0       // Useful for debugging

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: newStrListLen %1!u! \n",
                  newStrList.ListBytes );

            PrintStrList( ResourceEntry, newStrList.MultiSzList, newStrList.ListBytes );
#endif                  
        
        } else {
        
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: Current list empty, creating new list \n" );
        }

        //
        // Check each interesting partition.  Since only "valid" partitions are 
        // saved in the MountieInfo structure, we will only look at those (ignoring those
        // partitions that are not NTFS).
        //
        
        for ( idx = 0; idx < nPartitions; ++idx ) {
    
            entry = MountiePartition( &ResourceEntry->MountieInfo, idx );
    
#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: index %1!u!   entry %2!x! \n", idx, entry );
#endif              
    
            if ( !entry ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"CreateVolGuidList: no partition entry for index %1!u! \n", idx );
                
                // 
                // Something bad happened to our data structures.  
                //
                
                dwError = ERROR_INVALID_DATA;
                __leave;
            }
            
            // 
            // Create the device name of the form:
            //  \\?\GLOBALROOT\Device\HarddiskX\PartitionY\  (uses trailing backslash)
            //
    
            _snwprintf( szGlobalDiskPartName,
                        MAX_PATH,                           // Number of CHARS, not bytes
                        GLOBALROOT_HARDDISK_PARTITION_FMT, 
                        physicalDrive,
                        entry->PartitionNumber );
    
#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: Using name (%1!ws!) \n", 
                  szGlobalDiskPartName );
#endif

            //
            // Get the current VolGuid for this partition.
            //
                                
            if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                     szVolumeName,
                                                     sizeof(szVolumeName)/sizeof(WCHAR) )) {
                                                     
                dwError = GetLastError();
        
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"CreateVolGuidList: GetVolumeNameForVolumeMountPoint for (%1!ws!) returned %2!u!\n", 
                      szGlobalDiskPartName,
                      dwError );

                // Try next partition.
                
                continue;
            }
    
#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: Returned volume name (%1!ws!) \n", 
                  szVolumeName );
#endif

            //
            // Fix current VolGuid name.  
            //
            // GetVolumeNameForVolumeMountPoint returns name of the form:
            //      \\?\Volume{-GUID-}\
            //
            // But we need the name to be in the form:
            //      \??\Volume{-GUID-}
            //

            volumeNameLenChars = wcslen( szVolumeName );
            if ( !(MOUNTDEV_LOOKS_LIKE_ALT_VOLUME_GUID( szVolumeName, volumeNameLenChars * sizeof(WCHAR) ) ) ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"CreateVolGuidList: Improper volume name format (%1!ws!) \n", 
                      szVolumeName );
                
                // Try next partition.
                
                continue;
            }

            szVolumeName[1] = L'?';
            
            if ( L'\\' == szVolumeName[volumeNameLenChars-1]) {
                szVolumeName[volumeNameLenChars-1] = L'\0';
            }

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: Fixed volume name    (%1!ws!) \n", 
                  szVolumeName );
#endif

            //
            // Add the new string to the list.  If the new string is already in the list, this
            // routine won't do anything and will return NO_ERROR.
            //

            dwError = AddStrToList( ResourceEntry,
                                    szVolumeName,
                                    entry->PartitionNumber,
                                    &newStrList );

            if ( NO_ERROR != dwError ) {
                __leave;
            }

        }

        //
        // Optimization:
        // If the new list is the same as the old list, we are done.
        //

        if ( newStrList.MultiSzList && 
             newStrList.ListBytes &&
             newStrList.ListBytes == ResourceEntry->DiskInfo.Params.MPVolGuidsSize && 
             ( 0 == memcmp( newStrList.MultiSzList, ResourceEntry->DiskInfo.Params.MPVolGuids, newStrListLenBytes ) ) ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_INFORMATION,
                      L"CreateVolGuidList: New list same as old list, skipping update \n" );
                
                __leave;
        }
        
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"CreateVolGuidList: Saving new VolGuid list \n" );

        freeNewList = FALSE;
                
        //
        // The new list is different from the old list.  Free the old list, update
        // the ResourceEntry with the new list information, and update the cluster
        // database.
        //
    
        DeleteVolGuidList( ResourceEntry );

        EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

        ResourceEntry->DiskInfo.Params.MPVolGuids = newStrList.MultiSzList;
        ResourceEntry->DiskInfo.Params.MPVolGuidsSize = newStrList.ListBytes;

        LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

        PrintStrList( ResourceEntry, 
                      ResourceEntry->DiskInfo.Params.MPVolGuids,
                      ResourceEntry->DiskInfo.Params.MPVolGuidsSize );

        dwError = PostMPInfoIntoRegistry( ResourceEntry );

    } __finally {
    
        if ( INVALID_HANDLE_VALUE != mountMgrHandle ) {
            CloseHandle( mountMgrHandle );
        }
    
        if ( freeNewList && newStrList.MultiSzList ) {
            LocalFree( newStrList.MultiSzList );
        }
    
        LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );    
    
    }

    return dwError;

}   // CreateVolGuidList


DWORD
AddStrToList(
    IN PDISK_RESOURCE ResourceEntry,
    IN PWSTR NewStr,
    IN DWORD PartitionNumber,
    IN OUT PSTR_LIST StrList
    )
/*++

Routine Description:

    Add the string to the MULTI_SZ list.  Convert the partition number to a byte offset 
    so we don't rely on partition numbers.

    List format will be:
    
      ByteOffset1 Str1
      ByteOffset1 Str2
      ByteOffset1 Str3
      ByteOffset2 Str1
      ByteOffset2 Str2
      ByteOffset3 Str1
      ...         ...

Arguments:


Return Value:


--*/
{
    PWCHAR  listEntry = NULL;
    
    DWORD   listEntrySizeChars;
    
    DWORD   lenChars;
    DWORD   newStrLenChars;
    DWORD   listChars;
    DWORD   remainingLen;
    DWORD   dwError = ERROR_INVALID_DATA;
    
    LARGE_INTEGER   offset;

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"AddStrToList: Adding str (%1!ws!) \n", NewStr );
#endif

    newStrLenChars = wcslen( NewStr );

    if ( 0 == newStrLenChars ) {

        // 
        // Something wrong with the string length.
        //
        
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"AddStrToList: Invalid length: NewStrLen = %1!u! \n",
              newStrLenChars );
        
        goto FnExit;
    } 

    //
    // Indicate an error unless we can allocate and copy the info
    // into the list.  Calculate the minimum size needed, then get 
    // larger buffer.  This buffer is temporary and freed later.
    //

    listEntrySizeChars = ( newStrLenChars +     // Char length of parameter string
                           MAX_OFFSET_CHARS +   // Char length of offset string
                           1 +                  // Room to change end of offset string to space and extend it
                           1 )                  // Unicode NULL
                           * 2;                 // Make sure buffer is large enough
    
    listEntry = LocalAlloc( LPTR, listEntrySizeChars * sizeof(WCHAR) );
    
    if ( !listEntry ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Get the offset for the specified partition.
    //
    
    if ( !GetOffsetFromPartNo( PartitionNumber,
                               &ResourceEntry->MountieInfo,
                               &offset ) ) {

        //
        // Can't get the offset for the specified partition.
        //

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"AddStrToList: GetOffsetFromPartNo failed \n" );

        goto FnExit;
        
    }
                              
    //
    // Convert the offset into a string.  Put the offset into listEntry.
    //
    
    _ui64tow( offset.QuadPart, listEntry, 16 );
    lenChars = wcslen( listEntry );

    if ( 0 == lenChars || lenChars >= MAX_OFFSET_CHARS ) {

        //
        // The length of the offset string is invalid.
        //

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"AddStrToList: Invalid offset string length = %1!u! \n",
              lenChars );
        
        goto FnExit;
        
    }
    
    // Format will be:  
    //  ByteOffset1 Str1
    //  ByteOffset1 Str2
    //  ByteOffset1 Str3
    //  ByteOffset2 Str1
    //  ByteOffset2 Str2
    //  ByteOffset3 Str1
    //  ...         ...
    
    //
    // Change the end of the offset string to another character.  Move the end of string
    // out one character.  This extra space was included when we allocated the buffer.
    //

    listEntry[lenChars+1] = UNICODE_NULL;
    listEntry[lenChars] = SPACE_CHAR;
    
    // 
    // One more check.  Make sure enough space remaining for adding string.
    //
    
    remainingLen = listEntrySizeChars - wcslen( listEntry ) - 1;

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"AddStrToList: New string length %1!u!   Remaining list entry length %2!u! \n",
          newStrLenChars,
          remainingLen );
#endif

    if ( newStrLenChars >= remainingLen ) {
        
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"AddStrToList: New string length %1!u! larger than remaining list entry length %2!u! \n",
              newStrLenChars,
              remainingLen );
        goto FnExit;
    }
    
    // 
    // Put the rest of the string in list entry.
    //
    
    wcsncat( listEntry, NewStr, newStrLenChars );

    //
    // If the string is already in the list, skip it.
    //

    if ( ClRtlMultiSzScan( ResourceEntry->DiskInfo.Params.MPVolGuids, listEntry ) ) {
        
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"AddStrToList: Skipping duplicate entry (%1!ws!) \n", 
              listEntry );
        dwError = NO_ERROR;
        goto FnExit;
    }

    //
    // Note that ClRtlMultiSzAppend updates the number of CHARACTERS, but we 
    // need to have the number of BYTES in the property table.  We will adjust
    // this value later.
    //
    
    listChars = StrList->ListBytes / sizeof(WCHAR);

#if DBG
    
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"AddStrToList: StrList->MultiSzList at %1!x!,  numBytes %2!u!  \n",
          StrList->MultiSzList,
          StrList->ListBytes );
    
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"AddStrToList: Adding str entry: (%1!ws!) numChars %2!u!  \n",
          listEntry,
          listChars );
#endif                                  
    
    dwError = ClRtlMultiSzAppend( &(StrList->MultiSzList),
                                  &listChars,
                                  listEntry );

    //
    // Convert the number of CHARACTERS back to bytes.
    //

    StrList->ListBytes = listChars * sizeof(WCHAR);
    
    if ( ERROR_SUCCESS == dwError) {
#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"AddStrToList: Added str, numBytes %1!u!  numChars %2!u!  \n", 
              StrList->ListBytes,
              listChars );
#endif                                  
                                                  
    } else {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"AddStrToList: Unable to append MultiSz string for (%1!ws!), failed %x \n",
              NewStr,
              dwError );
    }
            
FnExit:
    
    if ( listEntry ) {
        LocalFree( listEntry );
    }

    return dwError;    

}   // AddStrToList


DWORD
SetupVolGuids(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Add every VolGuid in the existing MULTI_SZ VolGuid list to the system.
    
Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.
    
Return Value:

    Win32 error code.

--*/
{
    PWCHAR currentStr;
    PWCHAR volGuid;

    HANDLE  mountMgrHandle = INVALID_HANDLE_VALUE;

    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
    DWORD currentStrLenChars = 0;
    DWORD dwError = NO_ERROR;
    DWORD partitionNo;
    DWORD count;

    LARGE_INTEGER offset;

    WCHAR szDiskPartName[MAX_PATH];

    __try {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"SetupVolGuids: Processing VolGuid list \n" );

        EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

        dwError = DevfileOpen( &mountMgrHandle, MOUNTMGR_DEVICE_NAME );
        
        if ( dwError != NO_ERROR ) {
            __leave;
        }

        //
        // Parse through the list.
        // 

        for ( currentStr = (PWCHAR)ResourceEntry->DiskInfo.Params.MPVolGuids,
              currentStrLenChars = wcslen( currentStr ) ;
                currentStrLenChars ;
                    currentStr += currentStrLenChars + 1,
                    currentStrLenChars = wcslen( currentStr ) ) {

            offset.QuadPart = 0;

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"SetupVolGuids: CurrentStr (%1!ws!), numChars %2!u! \n",
                  currentStr,
                  currentStrLenChars );
#endif

            //
            // Convert the offset from a string to a large integer value.
            //

            count = swscanf( currentStr, L"%I64x ", &offset.QuadPart );

            if ( 0 == count ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"SetupVolGuids: Unable to parse offset from currentStr (%1!ws!) \n",
                      currentStr );
                continue;                      
            }
            
            //
            // Convert the offset to a partition number.
            //

            if ( !GetPartNoFromOffset( &offset, &ResourceEntry->MountieInfo, &partitionNo ) ) {

                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"SetupVolGuids: Unable to convert offset ( %1!08X!%2!08X! ) to partition number \n",
                      offset.HighPart,
                      offset.LowPart );                // couldn't get !I64X! to work...

                continue;
            }

            //
            // Get a pointer to the VolGuid data, just after the byte offset.
            //

            volGuid = wcsstr( currentStr, MOUNTDEV_WSZ_VOLUME_GUID_PREFIX );
            
            if ( !volGuid ) {
                
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"SetupVolGuids: Unable to find volume string in current list entry (%1!ws) \n",
                      currentStr );
                      
                continue;
            }

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"SetupVolGuids: Using VolGuid (%1!ws!) \n",
                  volGuid );
#endif

            ZeroMemory( szDiskPartName, sizeof( szDiskPartName ) );

            // 
            // Create the device name of the form:
            //  \Device\HarddiskX\PartitionY  (no trailing backslash)
            //
    
            _snwprintf( szDiskPartName,
                        MAX_PATH,                           // Number of CHARS, not bytes
                        DEVICE_HARDDISK_PARTITION_FMT, 
                        physicalDrive,
                        partitionNo );
    
#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"SetupVolGuids: Using device name (%1!ws!) \n", 
                  szDiskPartName );
#endif

            dwError = AssignDevice( mountMgrHandle, volGuid, szDiskPartName );
            
            if ( NO_ERROR != dwError && 
                 STATUS_OBJECT_NAME_COLLISION != dwError ) {
                
                // Assign device will return: 0xC0000035 STATUS_OBJECT_NAME_COLLISION
                // if we are setting a VolGuid that was previously set.  This is not
                // a problem.
                
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"SetupVolGuids: Unable to assign VolGuid to device, error %1!x! \n", 
                      dwError );
                      
                // Continue processing with error...
                
            }

            dwError = STATUS_SUCCESS;
            
        }

    
    } __finally {
    
        if ( INVALID_HANDLE_VALUE != mountMgrHandle ) {
            CloseHandle( mountMgrHandle );
        }
    
        LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );    

    }

    return dwError;

}   // SetupVolGuids


DWORD
AssignDevice(
    HANDLE MountMgrHandle,
    PWCHAR MountName,
    PWCHAR VolumeDevName
    )
/*++

Routine Description:

    Put the specified MountName (i.e. mount point name) into the mount manager's internal table
    of mount points.
    
Inputs:
    
    MountMgrHandle - Handle to the mount manager.  The caller is responsible for 
                     opening and closing this handle.
    
    MountName - Mountpoint name of the form:
     
                \??\Volume{-GUID-}  - note prefix "\??\" and no trailing backslash.
                \DosDevices\X:      - works if a drive letter is not already assigned 
    
    VolumeDevName - Volume device name.  Can be one of the following forms (note that case is 
                    important).  The "#" is a zero-based device number (and partition number
                    as appropriate).
                    
                    \Device\CdRom#
                    \Device\Floppy#
                    \Device\HarddiskVolume#
                    \Device\Harddisk#\Partition#

Return value:

    A Win32 error code.

--*/
{
    PMOUNTMGR_CREATE_POINT_INPUT input;
    
    DWORD   status;
    
    USHORT  mountNameLenBytes;
    USHORT  volumeDevNameLenBytes;
    
    USHORT  inputlengthBytes;

    if ( INVALID_HANDLE_VALUE == MountMgrHandle ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    mountNameLenBytes       = wcslen( MountName ) * sizeof(WCHAR);
    volumeDevNameLenBytes   = wcslen( VolumeDevName ) * sizeof(WCHAR);
    
    inputlengthBytes = sizeof(MOUNTMGR_CREATE_POINT_INPUT) + mountNameLenBytes + volumeDevNameLenBytes;

    input = (PMOUNTMGR_CREATE_POINT_INPUT)LocalAlloc( LPTR, inputlengthBytes );
    
    if ( !input ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    input->SymbolicLinkNameLength = mountNameLenBytes;
    input->DeviceNameOffset = input->SymbolicLinkNameOffset +
                              input->SymbolicLinkNameLength;
    input->DeviceNameLength = volumeDevNameLenBytes;
    
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  MountName, mountNameLenBytes);
    RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                  VolumeDevName, volumeDevNameLenBytes);
    
    status = DevfileIoctl( MountMgrHandle, 
                           IOCTL_MOUNTMGR_CREATE_POINT,
                           input, 
                           inputlengthBytes,
                           NULL, 
                           0, 
                           NULL );
    
    LocalFree( input );
    
    return status;

} // AssignDevice

    
DWORD
DeleteVolGuidList(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Delete the list from the DISK_RESOURCE structure, if it exists (free the
    memmory).  Also deletes the information from the cluster database.
    
Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.
                      
Return Value:

    NO_ERROR - The list was deleted.
    
    ERROR_NOT_READY - The mount point information was not yet initialized.
    
    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    //
    // Mount point structures not initialized (i.e. critical section).  Don't continue.
    //

    if ( !ResourceEntry->MPInfo.Initialized ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"DeleteVolGuidList: Mount point info not initialized.  List not deleted. \n" );

        dwError = ERROR_NOT_READY;
        goto FnExit;
    }

    EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );
        
    //
    // If existing list, free it.
    //
    
    if ( ResourceEntry->DiskInfo.Params.MPVolGuids ) {
        LocalFree( ResourceEntry->DiskInfo.Params.MPVolGuids );
        ResourceEntry->DiskInfo.Params.MPVolGuidsSize = 0;
        ResourceEntry->DiskInfo.Params.MPVolGuids = NULL;
        
        dwError = ClusterRegDeleteValue( ResourceEntry->ResourceParametersKey,
                                         CLUSREG_NAME_PHYSDISK_MPVOLGUIDS );

        //
        // If the update failed and the disk is not yet online, it will fail with
        // ERROR_SHARING_PAUSED.  Just return the error.  If the caller really,
        // really, really wants the cluster database cleaned up, they can 
        // use the PostMPInfoIntoRegistry call to create a thread to do this 
        // work.

        if ( NO_ERROR != dwError ) {
            
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"DeleteVolGuidList: Unable to delete VolGuid from cluster database %1!u! \n",
                  dwError );
        }
    }
    
    LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

FnExit:

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DeleteVolGuidList: returns %1!u! \n",
          dwError );
#endif          
    
    return dwError;
    
}   // DeleteVolGuidList


BOOL
IsMountPointAllowed(
    PWSTR MpName,
    PWSTR TargetVol,
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Verify that the mount point is allowed.  There are several reasons why the mount
    point would not be allowed.
    
    At this point, the source volume will be accessible.  If the source were offline, 
    we wouldn't even know about it, and we wouldn't even get to this routine.  The
    fact that the source is accessible allows us to do some things differently (i.e. we 
    can talk to the disk if needed).
    

    Dependencies:
    
        If source disk S has a mount point to target disk T ( S:\tdir --> T: ), then
        source S is dependent on target T and target T must be brought online before
        source S is online.

    Quorum drive restrictions:

        Generally, the quorum drive cannot have a mount point to another disk.  This
        is because the quorum drive is not allowed to be dependent on another resource.

        A mount point from clustered source S to quorum target Q is allowed.  The 
        dependency requirement is that quorum drive Q must come online before
        source drive S (i.e. S depends on Q).
              
        A mount point from quorum source Q to a clustered target T is not allowed because
        this would require T to be online before Q (i.e. Q depnends on T), and the 
        quorum drive cannot have dependencies.
          
        A mount point from quorum source Q to a nonclustered target C is invalid.
                                                                  
    Mount points to non-clustered disks:
    
        These types of mountpoints should not be used.

    Configurations supported:
    
        C is a non-clustered disk.
        X, Y are clustered disks, not quorum disks.
        Q is quorum disk.
        
        Source      Target                      Status
        ------      ------      ------------------------------------------------------------    
          C    -->    Q           Not supported.  Log error to system event log.
          C    -->    X           Not supported.  Log error to system event log.
          X    -->    C           Not supported.  We never process non-clustered target C.
          X    -->    Q           Valid if drive X is dependent on drive Q (same group).
          X    -->    Y           Valid if drive X is dependent on drive Y (Y online first).
          Q    -->    X           Invalid.  Quorum drive cannot be dependent on another resource.
          Q    -->    C           Not supported.  We never process target C.

    Future work:
    
        Log event message when invalid mount point used.  
        
Arguments:

    MpName - Possible mount point.  This will either be a mount point or a drive letter 
             (which is actually a mount point).  Format can be:
           
             x:\                                [Note trailing backslash!]
             x:\some-mp-name\                   [Note trailing backslash!]
             x:\some-dir\some-mp-name\          [Note trailing backslash!]
    
    TargetVol - Mount point target volume name.  Format:
                \\?\Volume{GUID}\       [Note trailing backslash!]

    ResourceEntry - Pointer to the DISK_RESOURCE structure for the target volume.
                      
Return Value:

    TRUE if the mount point is allowed.

--*/
{
    DWORD srcSignature;
    DWORD targetSignature = ResourceEntry->DiskInfo.Params.Signature;
    DWORD quorumSignature;
    
    DWORD dwError = NO_ERROR;
    DWORD messageId = 0;
    
    BOOL mpAllowed = TRUE;
    BOOL srcSigIsClustered;
    BOOL dependencyCorrect;

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"IsMountPointAllowed: MP source (%1!ws!) \n",
          MpName  );
#endif

    //
    // Since the drive letter is also a mountpoint, a drive letter is valid.
    //
    
    if ( MPIsDriveLetter( MpName ) ) {
#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"IsMountPointAllowed: Valid MP: MP is a drive letter \n" );
#endif              
        mpAllowed = TRUE;
        goto FnExit;
    }
    
    //
    // Get the signature of the source drive.  This drive is accessible (or
    // we wouldn't even have the mount point info yet) but we cannot assume it 
    // is a clustered drive.  If this fails, we can't use the mountpoint.
    //

    dwError = GetSignatureForVolume( ResourceEntry, MpName, &srcSignature );

    if ( NO_ERROR != dwError || !srcSignature ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"IsMountPointAllowed: Unable to get signature from volume, error %1!u! \n",
              dwError );
        
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SIG_UNAVAILABLE;
        goto FnExit;
    }
    
    //
    // If source points back to target, this mount point is not allowed.  Even though
    // the mount point code seems to allow this, there are some strange circular 
    // dependencies that show up.
    // 
            
    if ( srcSignature == targetSignature ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Invalid MP: Source and target volumes are the same device \n" );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SOURCE_EQUAL_TARGET;
        goto FnExit;
    }

    //
    // If we can't enumerate the cluster disk signatures, assume that this mount 
    // point is not allowed.
    //

    dwError = CheckSignatureClustered( srcSignature, &srcSigIsClustered );
    
    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"IsMountPointAllowed: Unable to enumerate disk signatures, error %1!u! \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SIG_ENUMERATION_FAILED;
        goto FnExit;
    }

    //
    // In the future, a non-clustered source might be valid only if a special registry 
    // key is specified - this is not currently implemented.  So even though this will
    // work without us doing anything (on this one node - when the disk is moved to 
    // another node, the MP won't work), we will warn the user that it is invalid.
    //
    // The user would have to manually set these types of mountpoints on each node.
    //
    //      C --> X     - Invalid, but should work
    //      C --> Q     - Invalid, but should work
    
    if ( !srcSigIsClustered ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Invalid MP: Source volume is non-clustered \n" );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SOURCE_NOT_CLUSTERED;
        goto FnExit;
    }
    
    //
    // At this point, the source drive is a clustered drive but we don't yet know 
    // what the target looks like.
    //
    //      X --> ??
    //      Q --> ??

    //
    // Get quorum signature.  If this fails, assume the mount point is not allowed.
    //
        
    dwError = GetQuorumSignature( &quorumSignature );
    
    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"IsMountPointAllowed: Unable to get quorum signature, error %1!u! \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_QUORUM_SIG_UNAVAILABLE;
        goto FnExit;
    }

    //
    // If the source is the quorum drive, the mount point is not allowed because
    // the quorum cannot be dependent on another disk resource.  We already know
    // that the source and target are different devices from an ealier check.
    //

    if ( quorumSignature == srcSignature ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,                                                             
              L"IsMountPointAllowed: Invalid MP: source sig %1!x! is quorum disk, target sig %2!x! is clustered \n",
              srcSignature,
              targetSignature );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SOURCE_IS_QUORUM;
        goto FnExit;
    }
    

#if 0
    // This config is valid only if the dependencies are correct between x and q.  Fall through
    // to check dependencies.
    
    //
    // If the target is the quorum drive and the source and target are different, then
    // this mount point is allowed.
    //
    //      X --> Q
    
    if ( quorumSignature == targetSignature && 
         srcSignature != targetSignature ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"IsMountPointAllowed: Valid MP: source sig %1!x! is clustered, target sig %2!x! is quorum disk \n",
              srcSignature,
              targetSignature );
        mpAllowed = TRUE;
        goto FnExit;
    }
#endif

    //
    // We have two possibilities left:
    //
    //      X --> Q     - valid
    //      X --> Y     - valid
    //
    
    // 
    // These are valid only if the dependencies are set up correctly.  Y must
    // be online before X, so X is dependent on Y.
    //

    dependencyCorrect = FALSE;
    dwError = CheckDependencies( srcSignature,
                                 targetSignature,
                                 &dependencyCorrect );


    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"IsMountPointAllowed: Unable to enumerate disk dependencies, error %1!u! \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_ENUM_DISK_DEP_FAILED;
        goto FnExit;
    }

    if ( dependencyCorrect ) {
#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"IsMountPointAllowed: Valid MP: Dependencies are correct \n" );
#endif
        mpAllowed = TRUE;
        goto FnExit;
    }
    
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_WARNING,
          L"IsMountPointAllowed: Invalid MP: Dependencies are incorrect \n",
          MpName  );

    //
    // If we get here, the mount point is not allowed.
    //
    
    mpAllowed = FALSE;
    messageId = RES_DISK_INVALID_MP_INVALID_DEPENDENCIES;

FnExit:

    if ( !mpAllowed && messageId ) {

        // Log event...
        
        ClusResLogSystemEventByKey2(ResourceEntry->ResourceKey,
                                    LOG_UNUSUAL,
                                    messageId,
                                    MpName,
                                    TargetVol);
    }

    return mpAllowed;

    
}   // IsMountPointAllowed


DWORD
CheckDependencies(
    DWORD SrcSignature,
    DWORD TargetSignature,
    PBOOL DependencyCorrect
    )
/*++

Routine Description:

    Determine if the dependency between the source volume and target volume is set up 
    correctly.  Since we are using the cluster APIs, they should insure that the
    resources are in the same group and have dependencies set.
    
Arguments:

    SrcSignature - Disk signature of the source volume.
    
    TargetSignature - Disk signature of the targe volume.
    
    DependencyCorrect - Indicates whether the dependency is set up correctly between the
                        source and target.  If set up correctly, this will be returned
                        as TRUE.
    
Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;
    
    DEPENDENCY_INFO dependInfo;
    
    ZeroMemory( &dependInfo, sizeof(DEPENDENCY_INFO) );

    //
    // We need to find the source's resources first.
    //
        
    dependInfo.SrcSignature = SrcSignature;
    dependInfo.TargetSignature = TargetSignature;
    dependInfo.DependencyCorrect = FALSE;

    //
    // Worst case assume that the dependency is invalid.
    //
    
    *DependencyCorrect = FALSE;
    
    dwError = ResUtilEnumResources( NULL,
                                    PHYSICAL_DISK_WSTR,
                                    DependencyCallback,
                                    &dependInfo
                                    );

    //
    // STOP_CLUSTER_ENUMERATIONS is our way to indicate that the
    // enumerations stopped (possibly early).  Check for this return
    // value and also if the DependencyCorrect flag was set to indicate
    // status to the caller.
    //
    
    if ( STOP_CLUSTER_ENUMERATIONS == dwError ) {
        dwError = NO_ERROR;
    
        if ( dependInfo.DependencyCorrect ) {
            *DependencyCorrect = TRUE;
        } 
    }
     

    return dwError;

}   // CheckDependencies


DWORD 
DependencyCallback(
    RESOURCE_HANDLE hOriginal,   
    RESOURCE_HANDLE hResource,  
    PVOID lpParams   
    )
/*++

Routine Description:

    For each enumerated disk resource, get the signature and see if it matches the 
    mount point source signature (passed in the DEPENDENCY_INFO structure).  If it 
    does not match, return success so that the disk enumeration continues.
    
    If the enumerated resource signature matches the mount point source signature,
    then check the cluster dependencies and make sure they are correct.  Once we
    have had a match on the signatures, we need to return an error to stop the
    disk enumeration, so we use STOP_CLUSTER_ENUMERATIONS as that special error
    value.

    If the cluster dependencies are acceptable, the DependencyCorrect flag will be
    set to TRUE in the DEPENDENCY_INFO structure.
        
Arguments:

    hOriginal - Handle to the original resource.  Not used.
    
    hResource - Handle to a cluster resource of type PHYSICAL_DISK.
    
    lpParams - Pointer to DEPENDENCY_INFO structure.
    
Return Value:

    STOP_CLUSTER_ENUMERATIONS - Special flag to stop the enumeration process.
    
    Win32 error code.

--*/
{
    PDEPENDENCY_INFO dependInfo = lpParams;
    
    DWORD dwSignature;
    DWORD dwError = NO_ERROR;
    
    //
    // Get the disk info and parse the signature from it.
    //

    dwError = GetSignatureFromDiskInfo( hResource, &dwSignature );    


    if ( NO_ERROR != dwError ) {
        return dwError;
    }

    //
    // Check if we have a resource handle to the source disk or to 
    // a different disk.  If the resource is the source disk, 
    // enumerate the dependencies and make sure they are correct.
    //
    
    if ( dwSignature == dependInfo->SrcSignature ) {
        
        dwError = EnumSigDependencies( hResource, 
                                       dependInfo->TargetSignature,
                                       &dependInfo->DependencyCorrect );
        
        //
        // If the dependency check did not get an error, set a fake 
        // error to make the disk enumeration stop.
        //
         
        if ( NO_ERROR == dwError ) {
            dwError = STOP_CLUSTER_ENUMERATIONS;
        }
    }
            
    return dwError;
    
} // DependencyCallback


DWORD
EnumSigDependencies(
    RESOURCE_HANDLE DependentResource,
    DWORD DependsOnSignature,
    PBOOL DependencyCorrect
    )
/*++

Routine Description:

    Check that the cluster disk dependencies are correct between the source and
    target of the mount point.

    To do this, we open the dependent resource and use the cluster APIs to enumerate
    all the disk resources dependencies.  For each dependency found, check for a 
    match of the DependsOnSignature.  If the signatures match, the dependency is 
    correct and we are done.  Otherwise, keep checking all the dependencies until
    we exhaust the list or find a match.
    
    Note: Dependency is brought online before the DependentResource.
    
Arguments:

    DependentResource - Resource Handle to check all the dependencies.
    
    DependsOnSignature - Signature of a possibly dependent disk.  This disk must be 
                         brought online before the DependentResource.
    
    DependencyCorrect - Flag set to TRUE when the cluster dependencies between
                       the DependentResource and it's dependency (identified by the
                       DependsOnSignature) are correct.
    
Return Value:

    Win32 error code.

--*/
{
    HRESENUM resEnum = NULL;
    HCLUSTER hCluster = NULL;
    HRESOURCE dependsOnResource = NULL;

    DWORD idx;
    DWORD dwError = NO_ERROR;
    DWORD enumType;
    DWORD nameLen;
    DWORD signature;
    
    WCHAR enumNameW[MAX_PATH * 2];

    __try {

        hCluster = OpenCluster( NULL );
        
        if ( NULL == hCluster ) {
            dwError = GetLastError();
            __leave;
        }

        //
        // Open an enumerator for iterating through the resources.
        //
        
        resEnum = ClusterResourceOpenEnum( DependentResource,
                                           CLUSTER_RESOURCE_ENUM_DEPENDS );
                                           
        if ( !resEnum ) {
            dwError = GetLastError();
            __leave;
        }

        //
        // Iterate through the dependencies.
        //
        
        idx = 0;
        while ( TRUE ) {

            nameLen = MAX_PATH;
            ZeroMemory( enumNameW, sizeof(enumNameW) );
            
            dwError = ClusterResourceEnum( resEnum,
                                           idx,
                                           &enumType,
                                           enumNameW,
                                           &nameLen );
                                           
            if ( ERROR_NO_MORE_ITEMS == dwError ) {
                
                //
                // The list is exhausted.  Indicate no error and leave.  This 
                // just means we checked all the dependencies and we didn't find
                // a match.
                //
                
                dwError = NO_ERROR;
                __leave;
            }
            
            if ( ERROR_SUCCESS != dwError ) {
                
                //
                // Some type of error, we have to stop processing.
                //
                __leave;
            } 

            //
            // Now we have the name (in the form of a string) of a resource we are 
            // dependent on.  We need to get the signature and compare to the  
            // signature passed in.
            //
                         
            dependsOnResource = OpenClusterResource( hCluster, 
                                                     enumNameW );
                                               
            if ( NULL == dependsOnResource ) {
                dwError = GetLastError();
                __leave;

            }

            //
            // Get the disk signature from the resources disk info.
            //
            
            dwError = GetSignatureFromDiskInfo( dependsOnResource, &signature );

            //
            // If the signature passed in matches the signature we are dependent on,
            // then the dependency is correct.  Otherwise, we have to keep looking.
            //
                        
            if ( NO_ERROR == dwError && signature == DependsOnSignature ) {
                *DependencyCorrect = TRUE;
                dwError = NO_ERROR;
                __leave;
            }
            
            //
            // Look at the next enumeration resource.
            //
            
            CloseClusterResource( dependsOnResource );
            dependsOnResource = NULL;
            idx++;
        }
    
    } __finally {
    
        if ( dependsOnResource ) {
            CloseClusterResource( dependsOnResource );
        }
            
        if ( resEnum ) {
            ClusterResourceCloseEnum( resEnum );
        }
        
        if ( hCluster ) {
            CloseCluster( hCluster );
        }
    }
    
    return dwError;


}   // EnumSigDependencies


DWORD
CheckSignatureClustered(
    DWORD Signature,
    PBOOL IsClustered
    )
/*++

Routine Description:

    Determine if the specified disk signature belongs to a clustered disk.
    Enumerates the cluster physical disks and tries to find a signature 
    match.  
    
    The enumeration returns STOP_CLUSTER_ENUMERATIONS when it has found
    a matching signature.  This special error code is to stop the disk 
    enumeration.
    
Arguments:

    Signature - Disk signature to be checked.
    
    IsClustered - Flag indicating disk is clustered.  If TRUE, disk is a
                  clustered disk.
                      
Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    SIG_INFO sigInfo;
    
    ZeroMemory( &sigInfo, sizeof(SIG_INFO) );
    
    sigInfo.Signature = Signature;
    sigInfo.Clustered = FALSE;

    *IsClustered = FALSE;
    
    dwError = ResUtilEnumResources( NULL,
                                    PHYSICAL_DISK_WSTR,
                                    SigInfoCallback,
                                    &sigInfo
                                    );

    if ( STOP_CLUSTER_ENUMERATIONS == dwError && sigInfo.Clustered ) {
        dwError = NO_ERROR;
        *IsClustered = TRUE;
    } 

    return dwError;

}   // CheckSignatureClustered


DWORD 
SigInfoCallback(
    RESOURCE_HANDLE hOriginal,   
    RESOURCE_HANDLE hResource,  
    PVOID lpParams   
    )
/*++

Routine Description:

    For each enumerated disk resource, get the signature and see if it matches the 
    specified disk signature (passed in the SIG_INFO structure).  If it does not 
    match, return success so that the disk enumeration continues.
    
    If the enumerated resource signature matches the mount point source signature,
    sets the Clustered flag in the SIG_INFO structure to TRUE.
     
Arguments:

    hOriginal - Handle to the original resource.  Not used.
    
    hResource - Handle to a cluster resource of type PHYSICAL_DISK.
    
    lpParams - Pointer to SIGN_INFO structure.
    
Return Value:

    STOP_CLUSTER_ENUMERATIONS - Special flag to stop the enumeration process.
    
    Win32 error code.

--*/
{
    PSIG_INFO sigInfo = lpParams;
    
    DWORD dwSignature;
    DWORD dwError = NO_ERROR;
    
    //
    // Get the disk info and parse the signature from it.
    //

    dwError = GetSignatureFromDiskInfo( hResource, &dwSignature );    


    if ( NO_ERROR != dwError ) {
        return dwError;
    }

    if ( dwSignature == sigInfo->Signature ) {
        sigInfo->Clustered = TRUE;
        
        //
        // Return an error to stop the enumeration.
        //
        
        dwError = STOP_CLUSTER_ENUMERATIONS;
    }
            
    return dwError;
    
} // SigInfoCallback


DWORD
GetSignatureFromDiskInfo(
    RESOURCE_HANDLE hResource,
    DWORD *dwSignature
    )
/*++

Routine Description:

    Get the signature for the given volume from the cluster using
    ClusterResourceControl.
    
Arguments:

    hResource - Handle to a cluster resource of type PHYSICAL_DISK.
    
    Signature - On success, the signature is returned into this pointer.
                      
Return Value:

    Win32 error code.

--*/
{
    PBYTE   outBuffer = NULL;
    PCLUSPROP_DISK_SIGNATURE diskSignature;
    
    DWORD   dwError;
    DWORD   dwBytesReturned;
    
    DWORD   signature;

    *dwSignature = 0;
    
    dwError = WrapClusterResourceControl( hResource,
                                          CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                                          &outBuffer,
                                          &dwBytesReturned );

    if ( NO_ERROR == dwError && outBuffer ) {

        //
        // CLUSPROP_DISK_SIGNATURE must always begin the value list returned from the
        // CLUSCTL code.
        //
        
        diskSignature = (PCLUSPROP_DISK_SIGNATURE)outBuffer;
        
        if ( diskSignature->Syntax.dw != CLUSPROP_SYNTAX_DISK_SIGNATURE ) {
            //
            // Invalid syntax.
            //
            
            dwError = ERROR_BAD_FORMAT;
        
        } else if ( diskSignature->cbLength != sizeof(DWORD) ) {
            
            //
            // Invalid length.
            //
            
            dwError = ERROR_BAD_FORMAT;
        
        } else {
        
            //
            // Return the signature.
            //
            
            *dwSignature = diskSignature->dw;
        }
        
    } 

    if (outBuffer) {
        LocalFree(outBuffer);
    }
    
    return dwError;
                                      
}   // GetSignatureFromDiskInfo



DWORD
GetSignatureForVolume(
    PDISK_RESOURCE ResourceEntry,
    PWSTR MpName,
    PDWORD Signature
    )
/*++

Routine Description:

    Get the signature for the given volume.  The signature is found by issuing
    IOCTL_DISK_GET_DRIVE_LAYOUT_EX or IOCTL_DISK_GET_DRIVE_LAYOUT.
    
    The volume must be online for this to work and not reserved by another node.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.
    
    MpName - Possible mount point.  This will either be a mount point or a drive letter 
             (which is actually a mount point).  Format can be:
           
             x:\                                [Note trailing backslash!]
             x:\some-mp-name\                   [Note trailing backslash!]
             x:\some-dir\some-mp-name\          [Note trailing backslash!]
    
    Signature - On success, the signature is returned into this pointer.
                      
Return Value:

    Win32 error code.

--*/
{
    PDRIVE_LAYOUT_INFORMATION_EX layoutEx = NULL;
    PDRIVE_LAYOUT_INFORMATION layout = NULL;

    HANDLE handle = NULL;
    DWORD bytesReturned;
    DWORD dwError = NO_ERROR;
    DWORD lenChars = 0;
    
    BOOL restoreStr = FALSE;
    WCHAR replaceChar;
    
    WCHAR drive[ 64 ];

    __try {    
    
    
        if ( !MpName || !Signature ) {
            dwError = ERROR_INVALID_PARAMETER;
            __leave;
        }
        
        *Signature = 0;

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"GetSignatureForVolume: Checking mount point (%1!ws!) \n", 
              MpName );

#endif

        //
        // If mount point is of form x:\aaa\bbb, temporarily strip off the 
        // string to make it into a drive letter.
        //
        
        lenChars = wcslen( MpName );
        
        if ( lenChars < 3 ) {
            dwError = ERROR_INVALID_PARAMETER;
            __leave;
        } 

        if ( lenChars > 3 ) {
            restoreStr = TRUE;
            replaceChar = (WCHAR)*(MpName + CHAR_TO_REPLACE);
            (WCHAR)*(MpName + CHAR_TO_REPLACE) = 0;
        }
        
        //
        // Make the name into the form:  \\?\x:     [Note: no trailing backslash!] 
        //

        ZeroMemory( drive, sizeof( drive ) );
        wcscpy( drive, L"\\\\.\\" );
        wcscat( drive, MpName );
        
#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"GetSignatureForVolume: CreateFile using %1!ws! \n", 
              drive );
              
#endif

        handle = CreateFileW( drive,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );
    
        if ( INVALID_HANDLE_VALUE == handle ) {
            dwError = GetLastError();
            
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"GetSignatureForVolume: CreateFile failed, error %1!u! \n", 
                  dwError );
            
            __leave;
        }

        //
        // Try IOCTL_DISK_GET_DRIVE_LAYOUT_EX first.  If it fails, try with
        // IOCTL_DISK_GET_DRIVE_LAYOUT.
        //
    
        layoutEx = DoIoctlAndAllocate( handle, 
                                       IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                       0,
                                       0,
                                       &bytesReturned );
    
        if ( !layoutEx ) {
    
            dwError = GetLastError();              
            
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"GetSignatureForVolume: IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed, error %1!u! \n", 
                  dwError );
            
            //
            // Try the old IOCTL...
            //
    
            layout = DoIoctlAndAllocate( handle, 
                                         IOCTL_DISK_GET_DRIVE_LAYOUT,
                                         0,
                                         0,
                                         &bytesReturned );
        
            if ( !layout ) {
    
                dwError = GetLastError();              
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"GetSignatureForVolume: IOCTL_DISK_GET_DRIVE_LAYOUT failed, error %1!u! \n", 
                      dwError );
                
                //
                // Fall through and cleanup.
                //
                
            } else {
                //
                // Get the signature from the returned structure and return it to 
                // the caller.
                //
                *Signature = layout->Signature;
                
                //
                // Have to set NO_ERROR here because the current value shows the
                // first IOCTL that failed.
                //
                
                dwError = NO_ERROR;
            }
            
        
        } else {
    
            //
            // Get the signature from the returned structure and return it to 
            // the caller.
            //
          
            if ( PARTITION_STYLE_MBR == layoutEx->PartitionStyle ) {
                *Signature = layoutEx->Mbr.Signature;
            
            } else if ( PARTITION_STYLE_GPT == layoutEx->PartitionStyle ) {
                
                //
                // Since our signatures won't handle the GPT GUID, we have to
                // simulate a signature.
                //
                
                *Signature = ClusterHashGuid(layoutEx->Gpt.DiskId);
            }
        
        }
    
        
    } __finally {

        if ( layoutEx ) {
            free( layoutEx );
        }
        
        if ( layout ) {
            free( layout );    
        }
    
        if ( handle ) {
            CloseHandle( handle );
        }

        //
        // Restore string to original format.
        //
        
        if ( lenChars > 3 && restoreStr ) {
            (WCHAR)*(MpName + CHAR_TO_REPLACE) = replaceChar;
        }
                
    }

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"GetSignatureForVolume: Returning signature %1!x! for mount point (%2!ws!) \n", 
          *Signature,
          MpName );
#endif
    
    return dwError;

}   // GetSignatureForVolume
                                
                                
BOOL
GetOffsetFromPartNo(
    DWORD PartitionNo,
    PMOUNTIE_INFO Info,
    PLARGE_INTEGER Offset
    )
/*++

Routine Description:

    Given the partition number and the drive layout, return the byte offset for the
    specified partition.

Arguments:

    PartitionNo - Supplies the partition number.  Zero is invalid since partition zero
                  represents the entire disk.
                  
    Info - Pointer to MOUNTIE_INFO based on drive layout information.
    
    Offset - Pointer to hold the returned byte offset for the partition.  Space is 
             allocated by the caller.
                      
Return Value:

    TRUE if successful.

--*/
{
    PMOUNTIE_PARTITION entry;
    DWORD idx;
    DWORD partitionCount;
    BOOL retVal = FALSE;

    if ( !PartitionNo || !Info || !Offset ) {
        goto FnExit;
    }

    if ( 0 == Info->Volume ) {
        goto FnExit;
    }

#if DBG
    (DiskpLogEvent)(
          NULL,                     // ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"GetOffsetFromPartNo: partition %1!u! \n", 
          PartitionNo );
#endif          
    
    Offset->QuadPart = 0;   // Offset of zero is invalid.  This will indicate an error.
    
    partitionCount = Info->Volume->PartitionCount;
    entry = Info->Volume->Partition;
    
    for ( idx = 0; idx < partitionCount; ++idx, ++entry) {

#if DBG
        (DiskpLogEvent)(
              NULL,                 // ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"GetOffsetFromPartNo: index %1!u! offset %2!x! \n",
              idx,
              entry->StartingOffset.LowPart );
#endif
              
        if ( entry->PartitionNumber == PartitionNo ) {
            
            Offset->QuadPart = entry->StartingOffset.QuadPart;
            retVal = TRUE;
            break;
        }
    }
    
FnExit:    
    
    return retVal;
    
}   // GetOffsetFromPartNo



BOOL
GetPartNoFromOffset(
    PLARGE_INTEGER Offset,
    PMOUNTIE_INFO Info,
    PDWORD PartitionNumber
    )
/*++

Routine Description:

    Given the offset and the drive layout, return the partition number for the specified offset.

Arguments:

    Offset - Pointer to the byte offset.  
    
    Info - Pointer to MOUNTIE_INFO based on drive layout information.
    
    PartitionNo - Pointer to hold the returned partition number.  Space is allocated by the
                  caller.
    
                      
Return Value:

    TRUE if successful.

--*/
{
    PMOUNTIE_PARTITION entry;
    DWORD idx;
    DWORD partitionCount;
    BOOL retVal = FALSE;
    
    if ( !Offset->QuadPart || !Info || !PartitionNumber) {
        goto FnExit;
    }
    
    if ( 0 == Info->Volume ) {
        goto FnExit;
    }
    
    *PartitionNumber = 0;   // Partition zero is invalid.  This will indicate an error.

    partitionCount = Info->Volume->PartitionCount;
    entry = Info->Volume->Partition;
    
    for ( idx = 0; idx < partitionCount; ++idx, ++entry ) {
        
        if ( entry->StartingOffset.QuadPart == Offset->QuadPart ) {
            *PartitionNumber = entry->PartitionNumber;
            retVal = TRUE;
            break;
        }
    }
        
FnExit:    
    
    return retVal;

}   // GetPartNoFromOffset


VOID
PrintStrList(
    PDISK_RESOURCE ResourceEntry,
    LPWSTR MultiSzList,
    DWORD ListBytes
    )
/*++

Routine Description:

    Display the list in the cluster log.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    MultiSzList - REG_MULTI_SZ string
    
    ListBytes - Number of bytes in MultiSzList, not number of WCHARs!

Return Value:

    None.

--*/
{
    PWSTR currentStr;
    PWCHAR data;
    
    LARGE_INTEGER offset;
    
    DWORD currentStrLenChars = 0;
    DWORD count;

    if ( !ResourceEntry || !MultiSzList || 0 == ListBytes ) {
        return;
    }

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"     Offset                      String \n" ); 
          
          
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"================  ====================================== \n" );


    EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

    currentStr = (PWCHAR)MultiSzList;
    currentStrLenChars = wcslen( currentStr );
    
    while ( currentStrLenChars ) {

        data = NULL;
        offset.QuadPart = 0;

        //
        // Convert the offset from a string to a large integer value.
        //
        
        count = swscanf( currentStr, L"%I64x ", &offset.QuadPart );

        if ( 0 == count ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"Error: Unable to parse offset from currentStr (%1!ws!) \n",
                  currentStr );
            
            // Stop processing the list...
            break;
        }
        
        //
        // Data starts just after the first space.
        //
        
        data = wcschr( currentStr, SPACE_CHAR );
        
        if ( !data || wcslen(data) < 3 ) {
            
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"Error: Unable to get mount point str from currentStr %1!ws! \n",
                  currentStr );
              
            // Stop processing the list...
            break;
        }

        //
        // Skip past the space character.  Note that the length was previously validated.
        //
        
        if ( SPACE_CHAR == *data ) {
            data++;    
        }
        
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"%1!08X!%2!08X!  %3!ws! \n",         // couldn't get !I64X! to work...
              offset.HighPart,
              offset.LowPart,
              data );

        currentStr += currentStrLenChars + 1;
        currentStrLenChars = wcslen( currentStr );
    }

    LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"*** End of list *** \n" );

}   // PrintStrList


static
DWORD
SetMPListThread(
    LPVOID lpThreadParameter
    )
/*++

Routine Description:

    Mount point list update thread.  Updates the cluster data base.

Arguments:

    lpThreadParameter - stores ResourceEntry.

Return Value:

    None

--*/

{
    DWORD dwError;
    PDISK_RESOURCE ResourceEntry = lpThreadParameter;
    DWORD idx;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: started.\n");
        
    //
    // Will die in 10 minutes if unsuccessful
    //
    
    for ( idx = 0; idx < 300; ++idx ) {
        
        //
        // Wait for either the terminate event or the timeout
        //
        
        dwError = WaitForSingleObject( DisksTerminateEvent, 2000 );
        
        if ( WAIT_TIMEOUT == dwError ) {

            EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

#if DBG
            DumpDiskInfoParams( ResourceEntry );
#endif

            //
            // Bug in ResUtilSetPropertyParameterBlock.  It will update the cluster
            // database with updated MULTI_SZ data, but it doesn't clear the values
            // appropriately.  Use ClusterRegDeleteValue to make sure the lists are 
            // cleared if they have been deleted.
            //

            if ( !ResourceEntry->DiskInfo.Params.MPVolGuids && 
                 0 == ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {
                
                dwError = ClusterRegDeleteValue( ResourceEntry->ResourceParametersKey,
                                                 CLUSREG_NAME_PHYSDISK_MPVOLGUIDS );
            }

            //
            // Timer expired.  Update the cluster database.  
            //

            dwError = ResUtilSetPropertyParameterBlock( ResourceEntry->ResourceParametersKey,
                                                        DiskResourcePrivateProperties,
                                                        NULL,
                                                        (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                                        NULL,
                                                        0,
                                                        NULL );

            LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );
            
            if ( ERROR_SUCCESS == dwError ) {
                
                //
                // We're done.
                //
                
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"SetMPListThread: mount point info updated in cluster data base \n" );
                
                break;
                
            } else if ( ERROR_SHARING_PAUSED != dwError ) {
                
                //
                // If the drive is not yet online, we should have seen ERROR_SHARING_PAUSED.  If
                // we see any other error, something bad happened.
                //
                
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SetMPListThread: Failed to update cluster data base, error = %1!u! \n", 
                    dwError );
                break;
            }

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"SetMPListThread: Wait again for event or timeout, count %1!u! \n",
                idx );
        
        } else {
        
            // 
            // The terminate event is possibly set.
            //
            
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SetMPListThread: WaitForSingleObject returned error = %1!u! \n", 
                dwError );
            break;
        }
    } 

    //
    // Thread ending, clear the flag.
    //
    
    InterlockedExchange( &ResourceEntry->MPInfo.MPUpdateThreadIsActive, 0 );
    
    return(ERROR_SUCCESS);

}   // SetMPListThread


DWORD
PostMPInfoIntoRegistry(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Set the DiskResourcePrivateProperties in the cluster database.  If the disk
    is not yet online, create a thread to update the cluster database.  The disk
    might not be fully online if we are in the process of bringing the quorum disk
    online and trying to update the mount point information.
    
Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError;

    //
    // Update the cluster database.  
    //

    EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

#if DBG
    DumpDiskInfoParams( ResourceEntry );
#endif

    //
    // Bug in ResUtilSetPropertyParameterBlock.  It will update the cluster
    // database with updated MULTI_SZ data, but it doesn't clear the values
    // appropriately.  Use ClusterRegDeleteValue to make sure the lists are 
    // cleared if they have been deleted.
    //

    if ( !ResourceEntry->DiskInfo.Params.MPVolGuids && 
         0 == ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {
        
        dwError = ClusterRegDeleteValue( ResourceEntry->ResourceParametersKey,
                                         CLUSREG_NAME_PHYSDISK_MPVOLGUIDS );
    }

    dwError = ResUtilSetPropertyParameterBlock( ResourceEntry->ResourceParametersKey,
                                                DiskResourcePrivateProperties,
                                                NULL,
                                                (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                                NULL,
                                                0,
                                                NULL );

    LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

    //
    // If the update failed and the disk is not yet online, it will fail with
    // ERROR_SHARING_PAUSED.  In this case, create a thread to update the cluster
    // data base.  Any other error or success should simply continue.
    //
    
    if ( ERROR_SHARING_PAUSED == dwError ) {

        //
        // Check if the thread is already active.  If it is, exit with an error.
        //
        
        if ( InterlockedCompareExchange(
                &ResourceEntry->MPInfo.MPUpdateThreadIsActive,
                1, 0 ) )  {
        
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_WARNING,
                L"PostMPInfoIntoRegistry: MountPoint thread is already running \n" );
        
                dwError = ERROR_ALREADY_EXISTS;
    
        } else {
            HANDLE thread;
            DWORD threadId;
        
            thread = CreateThread( NULL,
                                   0,
                                   SetMPListThread,
                                   ResourceEntry,
                                   0,
                                   &threadId );
        
            if ( NULL == thread ) {
                
                //
                // Thread creation failed.  Log error, clear thread active flag, 
                // and return.
                //
                
                dwError = GetLastError();
        
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"PostMPInfoIntoRegistry: CreateThread failed, error %1!u!\n",
                    dwError );
        
                InterlockedExchange( &ResourceEntry->MPInfo.MPUpdateThreadIsActive, 0 );
        
            } else {

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"PostMPInfoIntoRegistry: Thread created \n" );

                //
                // Thread created.  Indicate no error.
                //
                
                CloseHandle( thread );
                dwError = ERROR_SUCCESS;
            }
        }
    
    } else {
    
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              ( NO_ERROR == dwError ? LOG_INFORMATION : LOG_ERROR ),
              L"PostMPInfoIntoRegistry: ResUtilSetPropertyParameterBlock returned %1!u! \n",
              dwError );
    }
            
    return dwError;
    
}   // PostMpInfoIntoRegistry


DWORD
WrapClusterResourceControl(
    RESOURCE_HANDLE hResource,
    DWORD dwControlCode,    
    LPVOID *OutBuffer,
    DWORD *dwBytesReturned
    )
/*++

Routine Description:

    Wrap the call to ClusterResourceControl.  This routine will allocate the
    output buffer, call ClusterResourceControl, and return the address of the
    output buffer to the caller.

    The caller of this routine is responsible for freeing the output buffer.
    
Arguments:

    hResource - Handle to a cluster resource of type PHYSICAL_DISK.
    
    dwControlCode - The resource control code to be performed.
    
    OutBuffer - Address to store the output buffer.
    
    dwBytesReturned - Number of bytes in the allocated output buffer.

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError;

    DWORD  cbOutBufferSize  = MAX_PATH;
    DWORD  cbResultSize     = MAX_PATH;
    LPVOID tempOutBuffer    = LocalAlloc( LPTR, cbOutBufferSize );

    dwError = ClusterResourceControl( hResource,
                                      NULL,
                                      dwControlCode,
                                      NULL, 
                                      0, 
                                      tempOutBuffer,
                                      cbOutBufferSize, 
                                      &cbResultSize );

    //
    // Reallocation routine if buffer is too small
    //
    
    if ( ERROR_MORE_DATA == dwError )
    {
        LocalFree( tempOutBuffer );

        cbOutBufferSize = cbResultSize;

        tempOutBuffer = LocalAlloc( LPTR, cbOutBufferSize );

        dwError = ClusterResourceControl( hResource,
                                          NULL,
                                          dwControlCode,
                                          NULL, 
                                          0, 
                                          tempOutBuffer, 
                                          cbOutBufferSize, 
                                          &cbResultSize );
    }

    //
    // On success, give the user the allocated buffer.  The user is responsible
    // for freeing this buffer.  On failure, free the buffer and return a status.
    //
    
    if ( NO_ERROR == dwError ) {
        *OutBuffer = tempOutBuffer;
        *dwBytesReturned = cbResultSize;
    } else {
        *OutBuffer = NULL;
        *dwBytesReturned = 0;
        LocalFree( tempOutBuffer );
    }
    
    return dwError;

}   // WrapClusterResourceControl


VOID
DisksMountPointCleanup(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Cleanup everything the mount point code used.  
    This routine should be called in DisksClose.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    None.

--*/
{
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DisksMountPointCleanup: Cleanup mount point information \n" );
    
    //
    // If existing MPVolGuids list, free it.
    //
    
    if ( ResourceEntry->DiskInfo.Params.MPVolGuids ) {
        LocalFree( ResourceEntry->DiskInfo.Params.MPVolGuids );
        ResourceEntry->DiskInfo.Params.MPVolGuidsSize = 0;
        ResourceEntry->DiskInfo.Params.MPVolGuids = NULL;
    }    
    
    ResourceEntry->MPInfo.Initialized = FALSE;

    DeleteCriticalSection( &ResourceEntry->MPInfo.MPLock );

}   // DisksMountPointCleanup


VOID
DisksMountPointInitialize(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Prepare the mount point structures in the ResourceEntry for use.  
    This routine should be called in DisksOpen.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    None.

--*/
{
    InitializeCriticalSection( &ResourceEntry->MPInfo.MPLock );
    
    ResourceEntry->MPInfo.Initialized = TRUE;

    InterlockedExchange( &ResourceEntry->MPInfo.MPUpdateThreadIsActive, 0 );
    InterlockedExchange( &ResourceEntry->MPInfo.MPListCreateInProcess, 0 );

}   // DisksMountPointInitialize



DWORD
DisksUpdateMPList(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Validate the mount points.  
    
Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    Win32 error code.

--*/
{
    DWORD   dwError = NO_ERROR;

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DisksUpdateMPList: Processing PNP mountpoint notification \n" );

    //
    // Check if the MPList is in process of being updated.  If it is, exit with an error.
    //

    if ( InterlockedCompareExchange(
            &ResourceEntry->MPInfo.MPListCreateInProcess,
            1, 0 ) )  {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"DisksUpdateMPList: Update in process, bypassing PNP notification \n" );
        return ERROR_BUSY;
    }

    dwError = ValidateMountPoints( ResourceEntry );

    InterlockedExchange( &ResourceEntry->MPInfo.MPListCreateInProcess, 0 );

    return dwError;

}   // DisksUpdateMPList


DWORD
DisksProcessMPControlCode(
    PDISK_RESOURCE ResourceEntry,
    DWORD ControlCode
    )
/*++

Routine Description:
 
    Process the disk mount point control code.  Since we are in the thread
    that handed us the control code (DisksResourceControl), we can't do
    much except a separate thread to do the bulk of the mount point
    processing.
    
Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    ControlCode - Cluster resource control for mount point processing.
        
Return Value:

--*/
{
    HANDLE thread;
    DWORD threadId;
    DWORD dwError = NO_ERROR;
    
    __try {

        //
        // Create a thread to update the mount point list.  We don't need to
        // copy the ResourceEntry as this pointer will be valid when the thread
        // runs.
        //
        
        thread = CreateThread( NULL,
                               0,
                               DisksUpdateMPList,
                               ResourceEntry,
                               0,
                               &threadId );
        
        if ( NULL == thread ) {
            dwError = GetLastError();
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"DisksProcessMPControlCode: CreateThread failed %1!u! \n",
                  dwError );
            __leave;
        }
            
        //
        // Thread created.  Indicate no error.
        //
        
        CloseHandle( thread );
        dwError = NO_ERROR;

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"DisksProcessMPControlCode: Created thread to process control code \n" );
#endif              

    } __finally {

    }

    return dwError;
    
}   // DisksProcessMPControlCode


DWORD
ValidateMountPoints(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    For each partition on this disk, get the mountpoints directed toward this
    partition.  Check each mountpoint to make sure it is allowed.  For those
    mountpoints not allowed, write a message to system event log indicating
    why it is an invalid mountpoint.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    ERROR_INVALID_DATA - Partition info stored in MountieInfo is invalid.

    Win32 error code.

--*/
{
    PMOUNTIE_PARTITION entry;
    
    DWORD dwError = ERROR_SUCCESS;
    DWORD nPartitions = MountiePartitionCount( &ResourceEntry->MountieInfo );
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
    DWORD idx;
    
    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];

    ZeroMemory( szGlobalDiskPartName, sizeof(szGlobalDiskPartName) );
    ZeroMemory( szVolumeName, sizeof(szVolumeName) );

    //
    // Check each interesting partition.  Since only "valid" partitions are 
    // saved in the MountieInfo structure, we will only look at those (ignoring those
    // partitions that are not NTFS).
    //
    
    for ( idx = 0; idx < nPartitions; ++idx ) {

        entry = MountiePartition( &ResourceEntry->MountieInfo, idx );

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"ValidateMountPoints: index %1!u!   entry %2!x! \n", idx, entry );
#endif              

        if ( !entry ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"ValidateMountPoints: no partition entry for index %1!u! \n", idx );
            
            // 
            // Something bad happened to our data structures.  
            //
            
            dwError = ERROR_INVALID_DATA;

            break;
        }
        
        // 
        // Create the device name of the form:
        //  \\?\GLOBALROOT\Device\HarddiskX\PartitionY\  (uses trailing backslash)
        //

        _snwprintf( szGlobalDiskPartName,
                    MAX_PATH,                           // Number of CHARS, not bytes
                    GLOBALROOT_HARDDISK_PARTITION_FMT, 
                    physicalDrive,
                    entry->PartitionNumber );

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"ValidateMountPoints: Using name (%1!ws!) \n", 
              szGlobalDiskPartName );
#endif
                
        if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                 szVolumeName,
                                                 sizeof(szVolumeName)/sizeof(WCHAR) )) {
                                                 
            dwError = GetLastError();
    
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"ValidateMountPoints: GetVolumeNameForVolumeMountPoint for (%1!ws!) returned %2!u!\n", 
                  szGlobalDiskPartName,
                  dwError );
                
            break;
        }

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"ValidateMountPoints: Returned volume name (%1!ws!) \n", 
              szVolumeName );
#endif

        CheckMPsForVolume( ResourceEntry, 
                           szVolumeName );

    }

    return dwError;

}   // ValidateMountPoints


VOID
CheckMPsForVolume(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR VolumeName
    )
/*++

Routine Description:

    For the specified volume, find all mount points directed towards this volume.
    For each mountpoint, make sure it is allowed.
    
Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.
    
    VolumeName - Target volume for the mount point.  Format is:
                 \\?\Volume{GUID}\       [Note trailing backslash!]
    
Return Value:

    None.
    
--*/
{
    PWSTR volumePaths = NULL;
    PWSTR currentMP;
    
    DWORD dwError;

    __try {

        //
        // GetMountPoints will allocate a MultiSz buffer with 
        // all the mount points for this target volume.
        //
        
        dwError = GetMountPoints( VolumeName, &volumePaths );
    
        if ( NO_ERROR != dwError || !volumePaths ) {
    
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"CheckMPsForVolume: GetMountPoints returns %1!u! \n", dwError );
            
            __leave;
        }
        
        //
        // Loop through each mount point in the list.
        //
        // Each mount point will either be a mount point or a drive letter 
        // (which is actually a mount point).  Format can be:
        //       
        //         x:\                                [Note trailing backslash!]
        //         x:\some-mp-name\                   [Note trailing backslash!]
        //         x:\some-dir\some-mp-name\          [Note trailing backslash!]
        //
        
        currentMP = volumePaths;
                
        for (;;) {
    
            IsMountPointAllowed( currentMP, VolumeName, ResourceEntry );
    
            //
            // Skip through current mount point to end of string.
            //
                    
            while (*currentMP++);
    
            //
            // If next mount point is empty, the list is exhausted.
            //
            
            if (!*currentMP) {
                break;
            }
        }

    } __finally {
    
        if ( volumePaths ) {
            LocalFree( volumePaths );            
        }
    }

}   // CheckMPsForVolume


DWORD
GetMountPoints(
    PWSTR   VolumeName,
    PWSTR   *VolumePaths
    )
/*++

Routine Description:

    For the specified volume, find all mount points directed towards this volume.
    
    The mount point buffer will be allocated by this routine and must be freed by
    the caller.  
    
Arguments:

    VolumeName - Target volume for the mount point.  Format is:
                 \\?\Volume{GUID}\       [Note trailing backslash!]
    
    VolumePaths - Pointer to a MultiSz string containing all mount points directed 
                  toward this volume.  If there are no mount points, this pointer will
                  be set to NULL.  The caller is responsible for freeing this buffer.
                      
Return Value:

    Win32 error code.
    
--*/
{
    DWORD   lenChars;
    WCHAR   messageBuffer[MAX_PATH];
    PWSTR   paths = NULL;
    PWSTR   currentMP;
    
    DWORD   dwError;

    if ( !VolumeName || !VolumePaths ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    *VolumePaths = NULL;

    //
    // Determine the size of the buffer we need.
    //
    
    if ( !GetVolumePathNamesForVolumeName( VolumeName, NULL, 0, &lenChars ) ) {
        dwError = GetLastError();
        if ( ERROR_MORE_DATA != dwError ) {
            return dwError;
        }
    }
    
    //
    // Allocate the mount point buffer.
    //
    
    paths = LocalAlloc( 0, lenChars * sizeof(WCHAR) );
    if ( !paths ) {
        dwError = GetLastError();
        return dwError;
    }

    //
    // Get the mount points.
    //
    
    if ( !GetVolumePathNamesForVolumeName( VolumeName, paths, lenChars, NULL ) ) {
        dwError = GetLastError();
        LocalFree( paths );
        return dwError;
    }

    //
    // If no mount points, free the buffer and return to the caller.
    //
    
    if ( !paths[0] ) {
        LocalFree(paths);
        
        //
        // If no mount points for this volume, return no error and a NULL 
        // pointer to the mount point list.
        //
        
        return NO_ERROR;
    }
    
    *VolumePaths = paths;

    return NO_ERROR;
    
}   // GetMountPoints


DWORD
ValidateListOffsets(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR MasterList
    )
/*++

Routine Description:

    Verify each entry in the list to make sure the byte offset
    is valid.  Also, count the number of entries to make sure 
    there are not too many entries saved (there should be one
    VolGuid per node times the number of volumes on the disk).

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    MasterList - REG_MULTI_SZ list to be checked.

Return Value:

    ERROR_INVALID_DATA - List contains at least one invalid byte offset
                         value, possibly more.

    ERROR_INSUFFICIENT_BUFFER - List possibly corrupt as it contains too
                                many entries.
    
    Win32 error code.

--*/
{
    PWCHAR currentStr;

    DWORD currentStrLenChars = 0;
    DWORD dwError = NO_ERROR;
    DWORD partitionNo;
    DWORD numberOfEntries = 0;
    DWORD count;

    LARGE_INTEGER offset;
    
    BOOL invalidOffset = FALSE;

    EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );
    
    //
    // Parse through the list.
    // 

    for ( currentStr = (PWCHAR)MasterList,
          currentStrLenChars = wcslen( currentStr ) ;
            currentStrLenChars ;
                currentStr += currentStrLenChars + 1,
                currentStrLenChars = wcslen( currentStr ) ) {

        offset.QuadPart = 0;

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"ValidateListOffsets: CurrentStr (%1!ws!), numChars %2!u! \n",
              currentStr,
              currentStrLenChars );
#endif

        //
        // Convert the offset from a string to a large integer value.
        //
        
        count = swscanf( currentStr, L"%I64x ", &offset.QuadPart );

        if ( 0 == count ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"ValidateListOffsets: Unable to parse offset from currentStr (%1!ws!) \n",
                  currentStr );
            numberOfEntries++;
            continue;                      
        }
        
        //
        // Convert the offset to a partition number.
        //
        
        if ( !GetPartNoFromOffset( &offset, &ResourceEntry->MountieInfo, &partitionNo ) ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"ValidateListOffsets: Unable to convert offset ( %1!08X!%2!08X! ) to partition number \n",
                  offset.HighPart,
                  offset.LowPart );                // couldn't get !I64X! to work...

            invalidOffset = TRUE;
            
            // As soon as we find an invalid partition number, we are done.
            
            break;
        }

        numberOfEntries++;
    }
    
    if ( invalidOffset ) {
        dwError = ERROR_INVALID_DATA;
    
    } else if ( numberOfEntries > MAX_ALLOWED_VOLGUID_ENTRIES_PER_DISK ) {
        
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"ValidateListOffset: VolGuid list too large, %1!u! entries \n",
              numberOfEntries );

#if USEMOUNTPOINTS_KEY
        //
        // See if the user wants to ignore the number of entries in VolGuid list.
        //

        if ( !(ResourceEntry->DiskInfo.Params.UseMountPoints & MPS_IGNORE_MAX_VOLGUIDS) ) {

            //
            // Log an error to system event log.
            //

            ClusResLogSystemEventByKey(ResourceEntry->ResourceKey,
                                        LOG_UNUSUAL,
                                        RES_DISK_MP_VOLGUID_LIST_EXCESSIVE );

            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
#endif

    }

    LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );    

    return dwError;
    
}   // ValidateListOffsets


BOOL
MPIsDriveLetter(
    IN PWSTR MountPoint
    )
/*++

Routine Description:

    Determine if the mount point string is a drive letter.  A drive letter will be
    represented by a string of the form "x:\" with a length of 3.
    
Arguments:

    MountPoint - Mount point string to be verified.

Return Value:

    TRUE if the mount point string represents a drive letter.
    
--*/
{
    DWORD lenChars;

    lenChars = wcslen( MountPoint );
    
    if ( 3 == lenChars && 
         L':' == MountPoint[1] && 
         L'\\' == MountPoint[2] &&
         iswalpha( MountPoint[0] ) ) {
                
                return TRUE;
    }
    
    return FALSE;
    
}   // MPIsDriveLetter


#if DBG

//
// Debug helper routine
//

VOID
DumpDiskInfoParams(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Display in the cluster log interesting mountpoint information.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    None.


--*/
{
#if 0   // Drive is not currently stored
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: Signature %1!x!  Drive (%2!ws!) \n",
        ResourceEntry->DiskInfo.Params.Signature,
        ResourceEntry->DiskInfo.Params.Drive ); 
#endif

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: Signature %1!x! \n",
        ResourceEntry->DiskInfo.Params.Signature );


#if USEMOUNTPOINTS_KEY
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: SkipChkdsk %1!x!  ConditionalMount %2!x!  UseMountPoints %3!x! \n",
        ResourceEntry->DiskInfo.Params.SkipChkdsk,
        ResourceEntry->DiskInfo.Params.ConditionalMount,
        ResourceEntry->DiskInfo.Params.UseMountPoints ); 
#else
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: SkipChkdsk %1!x!  ConditionalMount %2!x! \n",
        ResourceEntry->DiskInfo.Params.SkipChkdsk,
        ResourceEntry->DiskInfo.Params.ConditionalMount );
#endif

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: VolGuid list %1!x!     VolGuid size %2!u! \n",
        ResourceEntry->DiskInfo.Params.MPVolGuids,
        ResourceEntry->DiskInfo.Params.MPVolGuidsSize ); 

}   // DumpDiskInfoParams

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\filter.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    filter.c

Abstract:

    ClusDisk Filter Driver interfaces for Disk Resource DLL in NT Clusters.

Author:

    Rod Gamache (rodga) 20-Dec-1995

Revision History:

   gorn: 18-June-1998 -- StartReserveEx function added

--*/

#include "disksp.h"


DWORD
GoOnline(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to bring online.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    UCHAR oldState;
    UCHAR newState;

    newState = DiskOnline;

    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_SET_STATE,
                               &newState,
                               sizeof(newState),
                               &oldState,
                               sizeof(oldState),
                               &bytesReturned,
                               FALSE);
    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error performing state change. Error: %1!u!.\n",
            errorCode = GetLastError());
        return(errorCode);
    }

    return(ERROR_SUCCESS);

}  // GoOnline



DWORD
GoOffline(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to take offline.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    UCHAR oldState;
    UCHAR newState;

    newState = DiskOffline;

    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_SET_STATE,
                               &newState,
                               sizeof(newState),
                               &oldState,
                               sizeof(oldState),
                               &bytesReturned,
                               FALSE);
    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Error taking device offline. Error: %1!u!.\n",
            errorCode = GetLastError());
        return(errorCode);
    }

    return(ERROR_SUCCESS);

}  // GoOffline


DWORD
SetOfflinePending(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Tell clusdisk we are in offline/terminate processing.  When NTFS has
    completed dismount processing, it will send unlock media IOCTL.  Clusdisk
    will immediately mark the disk offline as soon as the unlock IOCTL is
    received as long as the offline pending flag is set.

Arguments:

    FileHandle - Handle for device to bring online.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    UCHAR oldState;
    UCHAR newState;

    newState = DiskOfflinePending;

    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_SET_STATE,
                               &newState,
                               sizeof(newState),
                               &oldState,
                               sizeof(oldState),
                               &bytesReturned,
                               FALSE);
    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Error performing state change. Error: %1!u!.\n",
            errorCode = GetLastError());
        return(errorCode);
    }

    return(ERROR_SUCCESS);

}  // SetOfflinePending


VOID
DoHoldIO(
    VOID
    )

/*++

Routine Description:

    This routine performs the HOLD IO for this resource... it does this by
    passing an IOCTL_DISK_CLUSTER_HOLD_IO request to Clusdisk0 device object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS        ntStatus;
    DWORD           status;
    HANDLE          fileHandle;
    ANSI_STRING     objName;
    UNICODE_STRING  unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOL            success;
    DWORD           bytesReturned;
    UCHAR           string[64];

    strcpy( string, "\\Device\\ClusDisk0" );
    RtlInitString( &objName, string );
    ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                             &objName,
                                             TRUE );
    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SCSI, error converting string to unicode, error 0x%1!lx!.\n",
            ntStatus );
        return;
    }

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    RtlFreeUnicodeString( &unicodeName );

    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SCSI, error opening ClusDisk0, error 0x%1!lx!.\n",
            ntStatus );
        return;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_HOLD_IO,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    NtClose( fileHandle );
    if ( !success) {
        status = GetLastError();
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SCSI, error doing HOLD IO request %1!u!.\n",
            status );
        return;
    }

    return;

} // DoHoldIO


VOID
DoResumeIO(
    VOID
    )

/*++

Routine Description:

    This routine performs the HOLD IO for this resource... it does this by
    passing an IOCTL_DISK_CLUSTER_HOLD_IO request to Clusdisk0 device object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS        ntStatus;
    DWORD           status;
    HANDLE          fileHandle;
    ANSI_STRING     objName;
    UNICODE_STRING  unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOL            success;
    DWORD           bytesReturned;
    UCHAR           string[64];

    strcpy( string, "\\Device\\ClusDisk0" );
    RtlInitString( &objName, string );
    ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                             &objName,
                                             TRUE );
    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SCSI, error converting string to unicode, error 0x%1!lx!.\n",
            ntStatus );
        return;
    }

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    RtlFreeUnicodeString( &unicodeName );

    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SCSI, error opening ClusDisk0, error 0x%1!lx!.\n",
            ntStatus );
        return;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_RESUME_IO,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    NtClose( fileHandle );
    if ( !success) {
        status = GetLastError();
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SCSI, error doing HOLD IO request %1!u!.\n",
            status );
        return;
    }

    return;

} // DoResumeIO


DWORD
DoAttach(
    DWORD   Signature,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to bring online.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    NTSTATUS        ntStatus;
    DWORD           status;
    HANDLE          fileHandle;
    ANSI_STRING     objName;
    UNICODE_STRING  unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOL            success;
    DWORD           signature = Signature;
    DWORD           bytesReturned;
    UCHAR           string[64];

    strcpy( string, "\\Device\\ClusDisk0" );
    RtlInitString( &objName, string );
    ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                             &objName,
                                             TRUE );
    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error converting string to unicode, error 0x%1!lx!.\n",
            ntStatus );
        return(RtlNtStatusToDosError(ntStatus));
    }

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    RtlFreeUnicodeString( &unicodeName );

    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error opening ClusDisk0, error 0x%1!lx!.\n",
            ntStatus );
        return(RtlNtStatusToDosError(ntStatus));
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_ATTACH,
                               &signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    NtClose( fileHandle );
    if ( !success) {
        status = GetLastError();
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error attaching to signature %1!lx!, error %2!u!.\n",
            Signature,
            status );
        return(status);
    }

    return(ERROR_SUCCESS);

} // DoAttach


DWORD
DoDetach(
    DWORD   Signature,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to bring online.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    NTSTATUS        ntStatus;
    DWORD           status;
    HANDLE          fileHandle;
    ANSI_STRING     objName;
    UNICODE_STRING  unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOL            success;
    DWORD           signature = Signature;
    DWORD           bytesReturned;
    UCHAR           string[64];

    strcpy( string, "\\Device\\ClusDisk0" );
    RtlInitString( &objName, string );
    ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                             &objName,
                                             TRUE );
    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Detach, error converting string to unicode, error 0x%1!lx!.\n",
            ntStatus );
        return(RtlNtStatusToDosError(ntStatus));
    }

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    RtlFreeUnicodeString( &unicodeName );

    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Detach, error opening ClusDisk0, error 0x%1!lx!.\n",
            ntStatus );
        return(RtlNtStatusToDosError(ntStatus));
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_DETACH,
                               &signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    NtClose( fileHandle );
    if ( !success) {
        status = GetLastError();
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Detach, error detaching from signature %1!lx!, error %2!u!.\n",
            Signature,
            status );
        return(status);
    }

    return(ERROR_SUCCESS);

} // DoDetach


DWORD
DoReserve(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to bring online.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD unused;
    DWORD status;


    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_RESERVE,
                               &unused,
                               sizeof(unused),
                               &status,
                               sizeof(status),
                               &bytesReturned,
                               FALSE);

    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error reserving disk, error %1!u!.\n",
            errorCode = GetLastError());
        return(errorCode);
    }

    return(ERROR_SUCCESS);

} // DoReserve



DWORD
DoRelease(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to bring online.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD unused;
    DWORD status;


    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_RELEASE,
                               &unused,
                               sizeof(unused),
                               &status,
                               sizeof(status),
                               &bytesReturned,
                               FALSE);
#if 0
    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error releasing disk, error %1!u!.\n",
            errorCode = GetLastError());
        return(errorCode);
    }
#endif
    return(ERROR_SUCCESS);

} // DoRelease



DWORD
DoBreakReserve(
    IN HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - The handle for the disk to break the reservation.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    SCSI_PASS_THROUGH spt;

    spt.Length = sizeof(spt);
    spt.PathId = 0;

    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_RESET_BUS,
                               &spt,
                               sizeof(spt),
                               &spt,
                               sizeof(spt),
                               &bytesReturned,
                               FALSE);

    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error resetting bus, error %1!u!.\n",
            errorCode = GetLastError());
        return(errorCode);
    }

    return(ERROR_SUCCESS);

} // DoBreakReserve



DWORD
StartReserveEx(
    OUT HANDLE *FileHandle,
    LPVOID InputData,
    DWORD  InputDataSize,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    This routine is used by 
      StartReserve to perform actual work

Arguments:

    FileHandle - Returns control handle for this device.
    
    InputData - Data to be passed to DeviceIoControl
    
    InputDataSize - The size of InputData buffer

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD unused;
    DWORD status;
    ANSI_STRING objectName;
    UNICODE_STRING unicodeName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    RtlInitString( &objectName, "\\Device\\ClusDisk0" );
    status = RtlAnsiStringToUnicodeString( &unicodeName,
                                           &objectName,
                                           TRUE );
    if ( !NT_SUCCESS(status) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to init object attributes for control handle to ClusDisk0, error %1!u!.\n",
            status );
        return(status);
    }

    InitializeObjectAttributes( &objectAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //
    // Open a file handle to the control device
    //
    status = NtCreateFile( FileHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &objectAttributes,
                           &ioStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN, 
                           0,
                           NULL,
                           0 );
    RtlFreeUnicodeString( &unicodeName );
    if ( !NT_SUCCESS(status) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open control handle to ClusDisk0, error %1!lx!.\n",
            status );
        return(status);
    }

    success = DeviceIoControl( *FileHandle,
                               IOCTL_DISK_CLUSTER_START_RESERVE,
                               InputData,
                               InputDataSize,
                               &status,
                               sizeof(status),
                               &bytesReturned,
                               FALSE);

    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error starting disk reservation thread, error %1!u!.\n",
            errorCode = GetLastError());
        return(errorCode);
    }

    return(ERROR_SUCCESS);

} // StartReserve

DWORD
StartReserve(
    OUT HANDLE *FileHandle,
    DWORD  Signature,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Returns control handle for this device.

    Signature - Supplies the signature on which reservations should be started

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    return( StartReserveEx(FileHandle, &Signature, sizeof(Signature), ResourceHandle) );
} // StartReserve


DWORD
StopReserve(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Supplies the control handle for device where reservations
            should be stopped. This is the handle returned by StartReserve.
            This handle will be closed.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD bytesReturned;

    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_STOP_RESERVE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE);

    if ( !success ) {
        (DiskpLogEvent)(
            NULL,
            LOG_ERROR,
            L"SCSI, error stopping disk reservations, error %1!u!.\n",
            GetLastError());
    }
    CloseHandle(FileHandle);

    return(ERROR_SUCCESS);

} // StopReserve



DWORD
CheckReserve(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to check reserve.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD unused;
    DWORD status;

    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_ALIVE_CHECK,
                               &unused,
                               sizeof(unused),
                               &status,
                               sizeof(status),
                               &bytesReturned,
                               FALSE);

    if ( !success ) {
        errorCode = GetLastError();
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI, error checking disk reservation thread, error %1!u!.\n",
            errorCode);
        return(errorCode);
    }

    return(ERROR_SUCCESS);

} // CheckReserve



DWORD
FixDriveLayout(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Fix the drive layout for the disk.

Arguments:

    FileHandle - Handle for the layout
    ResourceHandle - Handle for logging errors.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                       status;
    DWORD                       index;
    DWORD                       driveLayoutSize;
    DWORD                       bytesPerTrack;
    DWORD                       bytesPerCylinder;
    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;
    PPARTITION_INFORMATION      partInfo;
    BOOL                        success;
    DWORD                       returnLength;
    DISK_GEOMETRY               diskGeometry;
    LARGE_INTEGER               partOffset;
    LARGE_INTEGER               partLength;
    LARGE_INTEGER               partSize;
    LARGE_INTEGER               modulo;

    success = ClRtlGetDriveLayoutTable(FileHandle,
                                       &driveLayout,
                                       &driveLayoutSize);

    if ( !success || !driveLayout ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"FixDriveLayout, error getting partition information. Error: %1!u!.\n",
            status = GetLastError() );
        return(status);
    }

    //
    // Read the drive capacity to get bytesPerSector and bytesPerCylinder.
    //
    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &returnLength,
                               FALSE );
    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"FixDriveLayout, error reading drive capacity. Error: %1!u!.\n",
            status = GetLastError());
        LocalFree( driveLayout );
        return(status);
    }

    //
    // If read of the partition table originally failed, then we rebuild
    // it if the PartitionCount and Signature are okay. Otherwise, log the
    // failure to rebuild the partition info.
    //
    if ( !driveLayout->PartitionCount ||
         !driveLayout->Signature ) {
#if 0
        driveLayout->PartitionCount = MAX_PARTITIONS;
        // What about disk signature?

        bytesPerTrack = diskGeometry.SectorsPerTrack *
                        diskGeometry.BytesPerSector;

        bytesPerCylinder = diskGeometry.TracksPerCylinder *
                           bytesPerTrack;


        partLength.QuadPart = bytesPerCylinder * diskGeometry.Cylinders.QuadPart;
        partInfo = &driveLayout->PartitionEntry[0];

        //
        // The partition offset is 1 track (in bytes).
        // Size is media_size - offset, rounded down to cylinder boundary.
        //
        partOffset.QuadPart = bytesPerTrack;
        partSize.QuadPart = partLength.QuadPart - partOffset.QuadPart;

        modulo.QuadPart = (partOffset.QuadPart + partSize.QuadPart) %
                          bytesPerCylinder;
        partSize.QuadPart -= modulo.QuadPart;

        partInfo = driveLayout->PartitionEntry;

        //
        // Initialize first partition entry.
        //
        partInfo->RewritePartition = TRUE;
        partInfo->PartitionType = PARTITION_IFS;
        partInfo->BootIndicator = FALSE;
        partInfo->StartingOffset.QuadPart = partOffset.QuadPart;
        partInfo->PartitionLength.QuadPart = partSize.QuadPart;
        partInfo->HiddenSectors = 0;
        partInfo->PartitionNumber = 1;

        //
        // For now, the remaining partition entries are unused.
        //
        for ( index = 1; index < MAX_PARTITIONS; index++ ) {
            partInfo->RewritePartition = TRUE;
            partInfo->PartitionType = PARTITION_ENTRY_UNUSED;
            partInfo->BootIndicator = FALSE;
            partInfo->StartingOffset.QuadPart = 0;
            partInfo->PartitionLength.QuadPart = 0;
            partInfo->HiddenSectors = 0;
            partInfo->PartitionNumber = 0;
        }
#else
        if ( !driveLayout->PartitionCount ) {
            (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"FixDriveLayout, no partition count.\n");
        } else {
            (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"FixDriveLayout, no disk signature.\n");
        }
        LocalFree( driveLayout );
        return(ERROR_INVALID_PARAMETER);
#endif

    } else {
        //
        // Recalculate the starting offset for the extended partitions.
        //
        for ( index = 0; index < driveLayout->PartitionCount; index++ ) {
            LARGE_INTEGER   extendedOffset;
            LARGE_INTEGER   bytesPerSector;

            bytesPerSector.QuadPart = diskGeometry.BytesPerSector;
            extendedOffset.QuadPart = 0;

            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->RewritePartition = TRUE;
            partInfo->PartitionNumber = index + 1;
            if ( IsContainerPartition(partInfo->PartitionType) ) {
                //
                // If this is the first extended partition, then remember
                // the offset to added to the next partition.
                //
                if ( extendedOffset.QuadPart == 0 ) {
                    extendedOffset.QuadPart = bytesPerSector.QuadPart *
                                              (LONGLONG)partInfo->HiddenSectors;
                } else {
                    //
                    // We need to recalculate this extended partition's starting
                    // offset based on the current 'HiddenSectors' field and
                    // the first extended partition's offset.
                    //
                    partInfo->StartingOffset.QuadPart = extendedOffset.QuadPart
                                 + (bytesPerSector.QuadPart *
                                    (LONGLONG)partInfo->HiddenSectors);
                    partInfo->HiddenSectors = 0;
                }
            }
        }
    }
    //
    // Now set the new partition information.
    //
    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_SET_DRIVE_LAYOUT,
                               driveLayout,
                               driveLayoutSize,
                               NULL,
                               0,
                               &returnLength,
                               FALSE );
    LocalFree( driveLayout );

    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"FixDriveLayout, error setting partition information. Error: %1!u!.\n",
            status = GetLastError() );
        return(status);
    }

    return(ERROR_SUCCESS);

} // FixDriveLayout
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\newmount.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    newmount.c

Abstract:

    Replacement for mountie.c

Author:

    Gor Nishanov (GorN) 31-July-1998

Environment:

    User Mode

Revision History:


--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <devioctl.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <mountmgr.h>
#include <winioctl.h>

#include <ntddscsi.h>
#include "clusdisk.h"
#include "disksp.h"
#include "newmount.h"

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

extern PWCHAR DEVICE_HARDDISK_PARTITION_FMT; // L"\\Device\\Harddisk%u\\Partition%u" //
extern PWCHAR GLOBALROOT_HARDDISK_PARTITION_FMT;    // L"\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition%u\\";


#define MOUNTIE_VOLUME_INFO   L"MountVolumeInfo"
#define DISKS_DISK_INFO       L"DiskInfo"

#define BOGUS_BUFFER_LENGTH 512

#define FIRST_SHOT_SIZE 512

//
//  LETTER_ASSIGNMENT structure is used to store letter assignment
//  information from various information providers
//

typedef USHORT PARTITION_NUMBER_TYPE;

typedef struct _LETTER_ASSIGNMENT {
  DWORD  MatchCount; 
  DWORD  MismatchCount; 
  DWORD  DriveLetters;
  PARTITION_NUMBER_TYPE PartNumber[26];
} LETTER_ASSIGNMENT, *PLETTER_ASSIGNMENT;


DWORD
MountMgr_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result);

/*
 * DoIoctlAndAllocate - allocates a result buffer and
 *   tries to perform DeviceIoControl, it it fails due to insufficient buffer,
 *   it tries again with a bigger buffer.
 *
 * FIRST_SHOT_SIZE is a constant that regulates the size of the buffer
 *   for the first attempt to do DeviceIoControl.
 *
 * Return a non-zero code for error.
 */


PVOID
DoIoctlAndAllocate(
    IN HANDLE FileHandle,
    IN DWORD  IoControlCode,
    IN PVOID  InBuf,
    IN ULONG  InBufSize,
    OUT LPDWORD BytesReturned
    )
{
   UCHAR firstShot[ FIRST_SHOT_SIZE ];

   DWORD status = ERROR_SUCCESS;
   BOOL  success;

   DWORD outBufSize;
   PVOID outBuf = 0;
   DWORD bytesReturned;

   success = DeviceIoControl( FileHandle,
                      IoControlCode,
                      InBuf,
                      InBufSize,
                      &firstShot,
                      sizeof(firstShot),
                      &bytesReturned,
                      (LPOVERLAPPED) NULL );

   if ( success ) {
      outBufSize = bytesReturned;
      outBuf     = malloc( outBufSize );
      if (!outBuf) {
         status = ERROR_OUTOFMEMORY;
      } else {
         RtlCopyMemory(outBuf, &firstShot, outBufSize);
         status = ERROR_SUCCESS;
      }
   } else {
      outBufSize = sizeof(firstShot);
      for(;;) {
         status = GetLastError();
         //
         // If it is not a buffer size related error, then we cannot do much
         //
         if ( status != ERROR_INSUFFICIENT_BUFFER 
           && status != ERROR_MORE_DATA
           && status != ERROR_BAD_LENGTH
            ) {
            break;
         }
         //
         // Otherwise, try an outbut buffer twice the previous size
         //
         outBufSize *= 2;
         outBuf = malloc( outBufSize );
         if ( !outBuf ) {
            status = ERROR_OUTOFMEMORY;
            break;
         }

         success = DeviceIoControl( FileHandle,
                                    IoControlCode,
                                    InBuf,
                                    InBufSize,
                                    outBuf,
                                    outBufSize,
                                    &bytesReturned,
                                    (LPOVERLAPPED) NULL );
         if (success) {
            status = ERROR_SUCCESS;
            break;
         }
         free( outBuf );
      } 
   }
   
   if (status != ERROR_SUCCESS) {
      free( outBuf ); // free( 0 ) is legal //
      outBuf = 0;
      bytesReturned = 0;
   }

   SetLastError( status );
   *BytesReturned = bytesReturned;
   return outBuf;
}

/*
 * DevfileOpen - open a device file given a pathname
 *
 * Return a non-zero code for error.
 */
NTSTATUS
DevfileOpen(
    OUT HANDLE *Handle,
    IN wchar_t *pathname
    )
{
    HANDLE      fh;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;

    RtlInitUnicodeString(&cwspath, pathname);
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               NULL, NULL);
    fh = NULL;
    status = NtOpenFile(&fh,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &objattrs, &iostatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (status != STATUS_SUCCESS) {
        return status;
    }

    if ( !NT_SUCCESS(iostatus.Status) ) {
        if (fh) {
            NtClose(fh);
        }
        return iostatus.Status;
    }

    *Handle = fh;
    return STATUS_SUCCESS;

} // DevfileOpen


/*
 * DevfileClose - close a file
 */
VOID
DevfileClose(
    IN HANDLE Handle
    )
{

    NtClose(Handle);

} // DevFileClose

/*
 * DevfileIoctl - issue an ioctl to a device
 */
NTSTATUS
DevfileIoctl(
    IN HANDLE Handle,
    IN DWORD Ioctl,
    IN PVOID InBuf,
    IN ULONG InBufSize,
    IN OUT PVOID OutBuf,
    IN DWORD OutBufSize,
    OUT LPDWORD returnLength
    )
{
    NTSTATUS        status;
    IO_STATUS_BLOCK ioStatus;

    status = NtDeviceIoControlFile(Handle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) NULL,
                                   NULL,
                                   &ioStatus,
                                   Ioctl,
                                   InBuf, InBufSize,
                                   OutBuf, OutBufSize);
    if ( status == STATUS_PENDING ) {
        status = NtWaitForSingleObject( Handle, FALSE, NULL );
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatus.Status;
    }

    if ( ARGUMENT_PRESENT(returnLength) ) {
        *returnLength = (ULONG)ioStatus.Information;
    }

    return status;

} // DevfileIoctl


#define OUTPUT_BUFFER_LEN (1024)
#define INPUT_BUFFER_LEN  (sizeof(MOUNTMGR_MOUNT_POINT) + 2 * MAX_PATH * sizeof(WCHAR))

DWORD
DisksAssignDosDeviceM(
    HANDLE  MountManager,
    PCHAR   MountName,
    PWCHAR  VolumeDevName
    )

/*++

Routine Description:

Inputs:
    MountManager - Handle to MountMgr
    MountName -
    VolumeDevName - 

Return value:

    A Win32 error code.

--*/

{
    WCHAR mount_device[MAX_PATH];
    USHORT mount_point_len;
    USHORT dev_name_len;
    DWORD   status;
    USHORT inputlength;
    PMOUNTMGR_CREATE_POINT_INPUT input;

    swprintf(mount_device, L"\\DosDevices\\%S\0", MountName);
    mount_point_len = wcslen(mount_device) * sizeof(WCHAR);
    dev_name_len = wcslen(VolumeDevName) * sizeof(WCHAR);
    inputlength = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                  mount_point_len + dev_name_len;

    input = (PMOUNTMGR_CREATE_POINT_INPUT)malloc(inputlength);
    if (!input) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    input->SymbolicLinkNameLength = mount_point_len;
    input->DeviceNameOffset = input->SymbolicLinkNameOffset +
                              input->SymbolicLinkNameLength;
    input->DeviceNameLength = dev_name_len;
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  mount_device, mount_point_len);
    RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                  VolumeDevName, dev_name_len);
    status = DevfileIoctl(MountManager, IOCTL_MOUNTMGR_CREATE_POINT,
                          input, inputlength, NULL, 0, NULL);
    free(input);
    return status;

} // DisksAssignDosDevice



DWORD
DisksRemoveDosDeviceM(
    HANDLE MountManager,
    PCHAR   MountName
    )

/*++

Routine Description:

Inputs:
    MountManager - Handle to MountMgr
    MountName - 

Return value:


--*/

{
    WCHAR mount_device[MAX_PATH];
    USHORT mount_point_len;
    USHORT dev_name_len;
    DWORD  status;
    USHORT inputlength;
    PMOUNTMGR_MOUNT_POINT input;

    PUCHAR  bogusBuffer;    // this buffer should NOT be required!
    DWORD   bogusBufferLength = BOGUS_BUFFER_LENGTH;

    //
    // Remove old mount points for this mount name.
    //
    swprintf(mount_device, L"\\DosDevices\\%S", MountName);
    mount_point_len = wcslen(mount_device) * sizeof(WCHAR);
    inputlength = sizeof(MOUNTMGR_MOUNT_POINT) + mount_point_len;

    input = (PMOUNTMGR_MOUNT_POINT)malloc(inputlength);
    if (!input) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    bogusBuffer = malloc(bogusBufferLength);
    if (!bogusBuffer) {
        free(input);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    input->UniqueIdOffset = 0;
    input->UniqueIdLength = 0;
    input->DeviceNameOffset = 0;
    input->DeviceNameLength = 0;
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input->SymbolicLinkNameLength = mount_point_len;
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  mount_device, mount_point_len);
    do {
        status = DevfileIoctl(MountManager, IOCTL_MOUNTMGR_DELETE_POINTS,
                          input, inputlength, bogusBuffer, bogusBufferLength, NULL);
        free( bogusBuffer );
        if ( status == ERROR_MORE_DATA ) {
            bogusBufferLength += BOGUS_BUFFER_LENGTH;
            bogusBuffer = malloc(bogusBufferLength);
            if (!bogusBuffer) {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } while ( status == ERROR_MORE_DATA );

    free(input);

    //
    // Use the 'old-style' name on error in case we got a 'half-built' stack.
    //
    if ( status != ERROR_SUCCESS ) {
        DefineDosDevice( DDD_REMOVE_DEFINITION | DDD_NO_BROADCAST_SYSTEM,
                         MountName,
                         NULL );
    }

    return status;

} // DisksRemoveDosDevice


static
NTSTATUS
GetAssignedLetterM ( 
    IN HANDLE MountMgrHandle,
    IN PWCHAR deviceName, 
    OUT PCHAR driveLetter ) 
/*++

Routine Description:

    Get an assigned drive letter from MountMgr, if any

Inputs:
    MountMgrHandle - 
    deviceName - 
    driveLetter - receives drive letter

Return value:

    STATUS_SUCCESS - on success
    NTSTATUS code  - on failure

--*/

{
   DWORD status = STATUS_SUCCESS;
   
   PMOUNTMGR_MOUNT_POINT  input  = NULL;
   PMOUNTMGR_MOUNT_POINTS output = NULL;
   PMOUNTMGR_MOUNT_POINT out;
   
   DWORD len = wcslen( deviceName ) * sizeof(WCHAR);
   DWORD bytesReturned;
   DWORD idx;
   
   DWORD outputLen;
   DWORD inputLen;

   WCHAR wc;

   
   inputLen = INPUT_BUFFER_LEN;
   input = LocalAlloc( LPTR, inputLen );
   
   if ( !input ) {
       goto FnExit;
   }

   input->SymbolicLinkNameOffset = 0;
   input->SymbolicLinkNameLength = 0;
   input->UniqueIdOffset = 0;
   input->UniqueIdLength = 0;
   input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
   input->DeviceNameLength = (USHORT) len;
   RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                 deviceName, len );
   if (len > sizeof(WCHAR) && deviceName[1] == L'\\') {
       // convert Dos name to NT name
       ((PWCHAR)(input + input->DeviceNameOffset))[1] = L'?';
   }

   outputLen = OUTPUT_BUFFER_LEN;
   output = LocalAlloc( LPTR, outputLen );
   
   if ( !output ) {
       goto FnExit;
   }
   
   status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                input, inputLen, output, outputLen, &bytesReturned);
   
   if ( STATUS_BUFFER_OVERFLOW == status ) {
       
       outputLen = output->Size;
       LocalFree( output );
       
       output = LocalAlloc( LPTR, outputLen );
       
       if ( !output ) {
           goto FnExit;
       }
   
       status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                    input, inputLen, output, outputLen, &bytesReturned);
   }

   if ( !NT_SUCCESS(status) ) {
       goto FnExit;
   }

   if (driveLetter) {
       *driveLetter = 0;
   }
   for ( idx = 0; idx < output->NumberOfMountPoints; ++idx ) {
       out = &output->MountPoints[idx];
       if (out->SymbolicLinkNameLength/sizeof(WCHAR) == 14 &&
           (_wcsnicmp((PWCHAR)((PCHAR)output + out->SymbolicLinkNameOffset), L"\\DosDevices\\", 12) == 0) &&
           L':' == *((PCHAR)output + out->SymbolicLinkNameOffset + 13*sizeof(WCHAR)) ) 
       {
           wc = *((PCHAR)output + out->SymbolicLinkNameOffset + 12*sizeof(WCHAR));
           if (driveLetter && out->UniqueIdLength) {
              *driveLetter = (CHAR)toupper((UCHAR)wc);
              break;
           }
       }
   }

FnExit:   
   
   if ( output ) {
       LocalFree( output );
   }
   
   if ( input ) {
       LocalFree( input );
   }
   
   return status;
}



BOOL 
InterestingPartition(
   PPARTITION_INFORMATION info
   )
/*++

Routine Description:
    Quick check whether a partition is "interesting" for us

Inputs:
    info - GetDriveLayout's partition information

Return value:
    TRUE or FALSE

--*/

{
   return ( (info->RecognizedPartition) 
       && ((info->PartitionType == PARTITION_IFS) ||
           IsContainerPartition(info->PartitionType)) );
}


PMOUNTIE_VOLUME
CreateMountieVolumeFromDriveLayoutInfo (
   IN PDRIVE_LAYOUT_INFORMATION info,
   IN HANDLE ResourceHandle
   )
/*++

Routine Description:
    Collects all interesing partition from DriveLayoutInformation
    then it allocates and fills MountieVolume structure

Inputs:
    info - GetDriveLayout's information
    ResourceHandle - for error logging - not used (may be NULL!)

Return value:
    TRUE or FALSE

--*/
{
   DWORD           i;
   DWORD           nPartitions = 0;
   PMOUNTIE_VOLUME vol;
   PMOUNTIE_PARTITION mountie;
   DWORD           size;

   //
   // Count Partitions
   //
   for (i = 0; i < info->PartitionCount; ++i) {
      if ( InterestingPartition( info->PartitionEntry + i ) ) {
         ++nPartitions;
      }
   }

   if (!nPartitions) {
      SetLastError(ERROR_INVALID_DATA);
      return 0;
   }

   //
   // Allocate memory for Mountie structure
   //

   size = sizeof(MOUNTIE_VOLUME) + sizeof(MOUNTIE_PARTITION) * (nPartitions - 1);
   vol = malloc( size );
   if (!vol) {
      SetLastError(ERROR_OUTOFMEMORY);
      return 0;
   }
   RtlZeroMemory(vol, size);
   vol->PartitionCount = nPartitions;
   vol->Signature      = info->Signature;

   //
   // Copy all relevant Information from DriveLayout info
   //

   mountie = vol->Partition;

   for (i = 0; i < info->PartitionCount; ++i) {
      PPARTITION_INFORMATION entry = info->PartitionEntry + i;
   
      if ( InterestingPartition(entry) ) {

         mountie->StartingOffset  = entry->StartingOffset;
         mountie->PartitionLength = entry->PartitionLength;
         mountie->PartitionNumber = entry->PartitionNumber;
         mountie->PartitionType   = entry->PartitionType;

         ++mountie;
      }
   }
   
   return vol;
}


VOID
MountieUpdateDriveLetters(
    IN OUT PMOUNTIE_INFO info
    )
/*++

Routine Description:
    Updates DriveLetter bitmap.
    This routine needs to be called every time
    drive letter information is changed in MountieInfo

Inputs:
    info - MountieInfo

--*/
{  
   DWORD i;
   DWORD driveLetters = 0;
   PMOUNTIE_VOLUME vol = info->Volume;

   if (vol) {
      for (i = 0; i < vol->PartitionCount; ++i) {
         UCHAR ch = vol->Partition[i].DriveLetter;
         if (ch) {
            driveLetters |= 1 << (ch - 'A');
         }
      }
   }

   info->DriveLetters = driveLetters;
}


PMOUNTIE_PARTITION
MountiePartitionByOffsetAndLength(
    IN PMOUNTIE_INFO Info,
    LARGE_INTEGER Offset, LARGE_INTEGER Len)
{
    DWORD     PartitionCount;
    PMOUNTIE_PARTITION entry;

    if (!Info->Volume) {
        return 0;
    }
    
    PartitionCount = Info->Volume->PartitionCount;
    entry          = Info->Volume->Partition;

    while ( PartitionCount-- ) {

       if (entry->StartingOffset.QuadPart == Offset.QuadPart 
        && entry->PartitionLength.QuadPart == Len.QuadPart) {
          return entry;
       }

       ++entry;
    }
    return 0;
}


DWORD 
MountiePartitionCount(
   IN PMOUNTIE_INFO Info)
{
   if (Info->Volume) {
      return Info->Volume->PartitionCount;
   } else {
      return 0;
   }
}


PMOUNTIE_PARTITION
MountiePartition(
   IN PMOUNTIE_INFO Info,
   IN DWORD Index)
{
   return Info->Volume->Partition + Index;
}


PMOUNTIE_PARTITION
MountiePartitionByPartitionNo(
   IN PMOUNTIE_INFO Info,
   IN DWORD PartitionNumber
   )
{
   DWORD i, n;
   PMOUNTIE_PARTITION entry;
   if (Info->Volume == 0) {
      return 0;
   }
   n = Info->Volume->PartitionCount;
   entry = Info->Volume->Partition;
   for (i = 0; i < n; ++i, ++entry) {
      if (entry->PartitionNumber == PartitionNumber)
      {
         return entry;
      }
   }
   return 0;
}


VOID
MountiePrint(   
   IN PMOUNTIE_INFO Info,
   IN HANDLE ResourceHandle
   )
{
   DWORD i, n;
   PMOUNTIE_PARTITION entry;
   if (Info->Volume == 0) {
      return;
   }
   n = Info->Volume->PartitionCount;
   entry = Info->Volume->Partition;
   for (i = 0; i < n; ++i, ++entry) {
      (DiskpLogEvent)(
          ResourceHandle,
          LOG_INFORMATION,
          L"Mountie[%1!u!]: %2!u!, let=%3!c!, start=%4!X!, len=%5!X!.\n", 
          i, 
          entry->PartitionNumber, 
          NICE_DRIVE_LETTER(entry->DriveLetter),
          entry->StartingOffset.LowPart,
          entry->PartitionLength.LowPart );
   }
}


DWORD
DisksGetLettersForSignature(
    IN PDISK_RESOURCE ResourceEntry
    )
{
   return ResourceEntry->MountieInfo.DriveLetters;
}


DWORD
MountieRecreateVolumeInfoFromHandle(
    IN  HANDLE FileHandle,
    IN  DWORD  HarddiskNo,
    IN  HANDLE ResourceHandle,
    IN OUT PMOUNTIE_INFO Info
    )

/*++

Routine Description:
    Recreate a MountieInfo that has no
    DriveLetter assignments.
    
    IMPORTANT!!! The code assumes that Info->Volume
    either contains a valid pointer or NULL

Inputs:
    ResourceHandle - may be NULL.

Outputs:
    Info - MountieInfo

--*/
{
   PDRIVE_LAYOUT_INFORMATION layout;
   DWORD status;
   DWORD bytesReturned;

   free( Info->Volume ); // free(0) is OK //
   Info->HarddiskNo = HarddiskNo;
   Info->DriveLetters = 0;
   Info->Volume = 0;
   Info->VolumeStructSize = 0;
   
   layout = DoIoctlAndAllocate(
      FileHandle, IOCTL_DISK_GET_DRIVE_LAYOUT, 0,0, &bytesReturned);
   if (!layout) {
      return GetLastError();
   }

   status = ERROR_SUCCESS;
   try {

      Info->Volume = CreateMountieVolumeFromDriveLayoutInfo( layout , ResourceHandle );
      if (!Info->Volume) {
         status = GetLastError();
         leave;
      }
      Info->VolumeStructSize = sizeof(MOUNTIE_VOLUME) +
         sizeof(MOUNTIE_PARTITION) * (Info->Volume->PartitionCount - 1);

   } finally {
      free( layout );
   }
   if ( ResourceHandle ) MountiePrint(Info, ResourceHandle);
   return status;
}


DWORD
MountieFindPartitionsForDisk(
    IN DWORD HarddiskNo,
    OUT PMOUNTIE_INFO MountieInfo
    )
/*++

  Note that Caller of this routine is responsible for freeing Volume Information 
  via call to MountieCleanup().

--*/
{
    UCHAR   deviceName[MAX_PATH];
    HANDLE  fileHandle;
    DWORD   status;

    sprintf( deviceName,
             "\\\\.\\PhysicalDrive%u",
             HarddiskNo );
    ASSERT( strlen(deviceName) < sizeof( deviceName ));

    fileHandle = CreateFile( deviceName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL );
    if ( (fileHandle == NULL) ||
         (fileHandle == INVALID_HANDLE_VALUE) ) {
        status = GetLastError();
        return status;
    }

    RtlZeroMemory( MountieInfo, sizeof(MOUNTIE_INFO) );
    status = MountieRecreateVolumeInfoFromHandle(
                        fileHandle,
                        HarddiskNo,
                        NULL,
                        MountieInfo );
    if ( status != ERROR_SUCCESS ) {
        CloseHandle( fileHandle );
        
        return status;
    }

    CloseHandle( fileHandle );

    return(ERROR_SUCCESS);

} // MountieFindPartitionsForDisk 



VOID
MountieCleanup(
    IN OUT PMOUNTIE_INFO Info
    )
/*++

Routine Description:
    Deallocates Volume information

Inputs:
    Info - MountieInfo

--*/
{
    PVOID volume;
     
    Info->VolumeStructSize = 0;
    volume = InterlockedExchangePointer(&(Info->Volume), 0);
    free(volume);
}


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

// 
//  Disk information is specified in different formats in various places
//
//  The following code is an attempt to provide some common denominator
//  to simplify verification of all disk information and keeping it in sync.
//

UCHAR
AssignedLetterByPartitionNumber (
   PLETTER_ASSIGNMENT Assignment, 
   DWORD PartitionNo) 
/*++

Routine Description:
    Returns a drive letter assigned to a partition

Inputs:
    Assignment - drive letter assignment info
    PartitionNo - partition number (As in Harddisk0\PartitionX)

--*/
{
   UCHAR  i;
   for( i = 0; i < 26; ++i ) {
      if (Assignment->PartNumber[i] == PartitionNo) {
         return ('A' + i);
      }
   }
   return 0;
}


//  For every different way to describe a disk information
//  there should be two functions defined GetInfo and SetInfo
//  which will read/write the information into/from LETTER_ASSIGNMENT structure

typedef DWORD (*GetInfoFunc) (PMOUNTIE_INFO, PDISK_RESOURCE ResourceEntry, PLETTER_ASSIGNMENT Result);
typedef DWORD (*SetInfoFunc) (PMOUNTIE_INFO, PDISK_RESOURCE ResourceEntry);

//
// The following structure is a description of disk information provider.
//
// It is used to bind a provider name (Used as a label in error logging)
// and information access routines
//

typedef struct _INFO_PROVIDER {
   PWCHAR Name;
   GetInfoFunc GetInfo;
   SetInfoFunc SetInfo;
} INFO_PROVIDER, *PINFO_PROVIDER;

////////////////////////////////////////////////////////////////////
//
// The following routine gets FtInfo, by reading existing one or
//   creating an empty one if there is no System\DISK in the registry)
//
// Then it adds/updates drive letter assignment for the specified drive, 
//   using the information supplied in MOUNTIE_INFO structure.
//

PFT_INFO 
FtInfo_CreateFromMountie(
    PMOUNTIE_INFO Info, 
    PDISK_RESOURCE ResourceEntry) 
{
   PFT_INFO ftInfo = 0;
   DWORD i, n;
   DWORD Status = ERROR_SUCCESS;
   PMOUNTIE_PARTITION entry;

   try {
      ftInfo = DiskGetFtInfo();
      if ( !ftInfo ) {
          (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"Failed to get FtInfo.\n");
          Status = ERROR_NOT_ENOUGH_MEMORY;
          ftInfo = 0;
          leave;
      }
  
      Status = DiskAddDiskInfoEx( ftInfo,
                       ResourceEntry->DiskInfo.PhysicalDrive,
                       ResourceEntry->DiskInfo.Params.Signature, 
                       DISKRTL_REPLACE_IF_EXISTS );
      
      if ( Status != ERROR_SUCCESS ) {
          (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"Error %1!d! adding DiskInfo.\n",
                  Status);
          ftInfo = 0;
          leave;
      }
  
      n = Info->Volume->PartitionCount;
      entry = Info->Volume->Partition;
      //
      // Now add the partition info for each partition
      //
      for ( i = 0; i < n; ++i,++entry ) {
          UCHAR driveLetter;

          Status = DiskAddDriveLetterEx( ftInfo,
                                       ResourceEntry->DiskInfo.Params.Signature,
                                       entry->StartingOffset,
                                       entry->PartitionLength,
                                       entry->DriveLetter, 0);
          if ( Status != ERROR_SUCCESS ) {
              (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"Error %1!d! adding partition %2!x!:%3!x! letter %4!X! sig %5!x!.\n",
                      Status, entry->StartingOffset.LowPart, 
                              entry->PartitionLength.LowPart,
                              entry->DriveLetter, 
                              Info->Volume->Signature);
              break;
          }
      }
   } finally {
      if (Status != ERROR_SUCCESS) {
         SetLastError(Status);
         if (ftInfo) {
            DiskFreeFtInfo(ftInfo);
            ftInfo = 0;
         }
      }
   }
   return ftInfo;
}



DWORD FtInfo_GetFromFtInfo(
   IN PMOUNTIE_INFO  Info, 
   IN PDISK_RESOURCE ResourceEntry,
   IN PFT_INFO       FtInfo, 
   IN OUT PLETTER_ASSIGNMENT Result) 
{
   DWORD i, n;
   PFT_DISK_INFO FtDisk;

   FtDisk = FtInfo_GetFtDiskInfoBySignature(
               FtInfo, ResourceEntry->DiskInfo.Params.Signature);

   if ( !FtDisk ) {
      (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"FtInfo_GetFromFtInfo: GetFtDiskInfoBySignature failed.\n");
      ++Result->MismatchCount;
      return ERROR_NOT_FOUND;
   }

   n = FtDiskInfo_GetPartitionCount(FtDisk);
   if (n == 0) {
      (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"FtInfo_GetFromFtInfo: DiskInfo has no partitions.\n");
      ++Result->MismatchCount;
      return ERROR_NOT_FOUND;
   }
   // sanity check                      //
   // number 10 is completely arbitrary //
   if (n > Info->Volume->PartitionCount * 10) {
      (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"FtInfo_GetFromFtInfo: DiskInfo has %1!u! partitions!\n", n);
      n = Info->Volume->PartitionCount * 10;
   }
   for(i = 0; i < n; ++i) {
      DISK_PARTITION UNALIGNED *entry;
      PMOUNTIE_PARTITION mountie;

      entry = FtDiskInfo_GetPartitionInfoByIndex(FtDisk, i);

      mountie = MountiePartitionByOffsetAndLength(
                   Info, 
                   entry->StartingOffset, 
                   entry->Length);
      if (mountie) {
         UCHAR ch = (UCHAR)toupper( entry->DriveLetter );
         if ( isalpha(ch) ) {
            ch -= 'A';
            Result->DriveLetters |= ( 1 << ch );
            Result->PartNumber[ch] = (PARTITION_NUMBER_TYPE) mountie->PartitionNumber;
            ++Result->MatchCount;
         }
      } else {
         //
         //  Chittur Subbaraman (chitturs) - 11/5/98
         //
         //  Added the following 4 statements for event logging in MountieVerify
         //
         UCHAR uch = (UCHAR)toupper( entry->DriveLetter );
         if ( isalpha(uch) ) {
            uch -= 'A';
            Result->DriveLetters |= ( 1 << uch );
         }
         ++Result->MismatchCount;
         (DiskpLogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_WARNING,
                 L"Strange partition: %1!X!, %2!X!, Type=%3!u!, letter=%4!c!.\n", 
                 entry->StartingOffset.LowPart, entry->Length.LowPart,
                 entry->FtType, NICE_DRIVE_LETTER(entry->DriveLetter) );
      }
   }
   return ERROR_SUCCESS;
}



/////////////////////////////////////////////////////////////////
//
//  NT4 style System\DISK and ClusReg\DiskInfo
//  accessing routines
//
//    ClusDiskInfo_Get
//    ClusDiskInfo_Set
//    FtInfo_Get
//    FtInfo_Set
//

DWORD
CluDiskInfo_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result) 
{
   DWORD Length;
   DWORD Status;
   DWORD errorLevel;
   PFULL_DISK_INFO DiskInfo = 0;

   try {
   //
   // Read out the diskinfo parameter from our resource.
   //
      Status = ClusterRegQueryValue(ResourceEntry->ResourceParametersKey,
                                    DISKS_DISK_INFO,
                                    NULL,
                                    NULL,
                                    &Length);
                                    
      if (Status == ERROR_SUCCESS ) {



        DiskInfo = malloc(Length);
        if (!DiskInfo) {
           Status = ERROR_OUTOFMEMORY;
        } else {
           Status = ClusterRegQueryValue(ResourceEntry->ResourceParametersKey,
                                         DISKS_DISK_INFO,
                                         NULL,
                                         (LPBYTE)DiskInfo,
                                         &Length);

           if (Status == ERROR_SUCCESS) {
              PFT_INFO ftInfo = DiskGetFtInfoFromFullDiskinfo(DiskInfo);
              if (ftInfo) {
                 Status = FtInfo_GetFromFtInfo(Info, 
                                               ResourceEntry, 
                                               ftInfo, 
                                               Result);             
                 DiskFreeFtInfo(ftInfo);
              } else {
                 Status = GetLastError();
              }
           }
        }
      }

   } finally {
      if (Status != ERROR_SUCCESS) {

         if ( !DisksGetLettersForSignature( ResourceEntry ) ) {
            // No drive letters, we are using mount points and this is not an error.
            errorLevel = LOG_WARNING;
         } else {
            // Drive letters exist, this is likely an error.
            errorLevel = LOG_ERROR;
         }

         (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            errorLevel,
            L"CluDiskInfo_Get: Status=%1!u!.\n", Status);
            ++Result->MismatchCount;

      }
      free(DiskInfo);
   }

   return ERROR_SUCCESS;
}



DWORD
FtInfo_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result) 
{
   PFT_INFO FtInfo;
   DWORD Status;

   //
   // Get registry info.
   //
   FtInfo = DiskGetFtInfo();
   if ( !FtInfo ) {
      return ERROR_OUTOFMEMORY;
   }
   
   Status = FtInfo_GetFromFtInfo(Info, ResourceEntry, FtInfo, Result); 
   DiskFreeFtInfo(FtInfo);

   if (Status != ERROR_SUCCESS) {
      ++Result->MismatchCount;
   }

   return ERROR_SUCCESS;
}

DWORD
FtInfo_Set(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry)
{
   PFT_INFO ftInfo = FtInfo_CreateFromMountie(Info, ResourceEntry);
   if (ftInfo) {
      DWORD status = DiskCommitFtInfo(ftInfo);
      if (status != ERROR_SUCCESS) {
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"FtInfo_Set: CommitFtInfo status = %1!u!.\n", status);
      } else {
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"FtInfo_Set: Update successful.\n");
      }
      DiskFreeFtInfo(ftInfo);
      return status;
   } else {
       DWORD status = GetLastError();
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"FtInfoSet: CreateFromMountie failed, status = %1!u!.\n", status);
      return status;
   }
}


DWORD
CluDiskInfo_Set(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry)
{
   PFT_INFO ftInfo = FtInfo_CreateFromMountie(Info, ResourceEntry);
   if (ftInfo) {
      PFULL_DISK_INFO DiskInfo;
      DWORD Length;
      DWORD Status;
      DiskInfo = DiskGetFullDiskInfo( ftInfo,
                                      ResourceEntry->DiskInfo.Params.Signature,
                                      &Length );
      if ( DiskInfo ) {
          Status = ClusterRegSetValue(ResourceEntry->ResourceParametersKey,
                                      DISKS_DISK_INFO,
                                      REG_BINARY,
                                      (CONST BYTE *)DiskInfo,
                                      Length);
          if (Status != ERROR_SUCCESS && Status != ERROR_SHARING_PAUSED) {
             (DiskpLogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_ERROR,
                 L"CluDiskInfo_Set: Data Length = %1!u!.\n", Length);
          }
          LocalFree( DiskInfo );
      } else {
         (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_ERROR,
             L"CluDiskInfo_Set: Disk with signature %1!x! is not found. Error=%2!u!\n", ResourceEntry->DiskInfo.Params.Signature, GetLastError());
         Status = ERROR_FILE_NOT_FOUND;
      }
      
      DiskFreeFtInfo(ftInfo);
      return Status;
   } else {
      (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_ERROR,
          L"CluDiskInfo_Set: Failed to create FtInfo.\n");
      return GetLastError();
   }
}



////////////////////////////////////////////////////////
//
// New NT5 clusreg volume information access routines
//
//    Mountie_Get
//    Mountie_Set
//
//////////

DWORD
Mountie_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result) 
{
   DWORD Length = 0;        // Prefix bug 56153: initialize variable.
   DWORD Status;
   PMOUNTIE_VOLUME Volume = NULL;
   DWORD i, n;
   PMOUNTIE_PARTITION entry;

   try {
      //
      // Read out the diskinfo parameter from our resource.
      //
      Status = ClusterRegQueryValue(ResourceEntry->ResourceParametersKey,
                                    MOUNTIE_VOLUME_INFO,
                                    NULL,
                                    NULL,
                                    &Length);
      if (Status == ERROR_FILE_NOT_FOUND ) {
         ++Result->MismatchCount; 
         Status = ERROR_SUCCESS;
         leave;
      }

      //
      // Prefix bug 56153: Make sure the length is valid before allocating 
      // memory.
      //
      if ( !Length ) {
          Status = ERROR_BAD_LENGTH;
          leave;
      }
      
      Volume = malloc(Length);
      if (!Volume) {
         Status = ERROR_OUTOFMEMORY;
         leave;
      }

      Status = ClusterRegQueryValue(ResourceEntry->ResourceParametersKey,
                                    MOUNTIE_VOLUME_INFO,
                                    NULL,
                                    (LPBYTE)Volume,
                                    &Length);
      if (Status != ERROR_SUCCESS) {
         leave;
      }

      if (Length < sizeof(MOUNTIE_VOLUME) ) {
          ++Result->MismatchCount;
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"Get: MountVolumeInfo key is truncated. Cannot read header, length %1!d!.\n", Length);
          Status = ERROR_SUCCESS;
          leave;
      }

      n = Volume->PartitionCount;
      entry = Volume->Partition;

      if (n == 0) {
         ++Result->MismatchCount;
         (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_ERROR,
             L"Get: MountVolumeInfo key is corrupted. No partitions.\n");
         Status = ERROR_SUCCESS;
         leave;
      }
      if ( Length < (sizeof(MOUNTIE_VOLUME) + (n-1) * sizeof(MOUNTIE_PARTITION)) ) {
          DWORD delta = sizeof(MOUNTIE_VOLUME) + (n-1) * sizeof(MOUNTIE_PARTITION) - Length;
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"Get: MountVolumeInfo key is corrupted. "
              L"Length %1!d!, PartitionCount %2!d!, delta %3!d!.\n", Length, n, delta);
          ++Result->MismatchCount;
          Status = ERROR_SUCCESS;
          leave;
      }


      for (i = 0; i < n; ++i, ++entry) {
         PMOUNTIE_PARTITION mountie;

         mountie = MountiePartitionByOffsetAndLength(
                      Info, 
                      entry->StartingOffset, 
                      entry->PartitionLength);
         if (mountie) {
            UCHAR ch = (UCHAR)toupper( entry->DriveLetter );
            if ( isalpha(ch) ) {
               ch -= 'A';
               Result->DriveLetters |= ( 1 << ch );
               Result->PartNumber[ch] = (PARTITION_NUMBER_TYPE) mountie->PartitionNumber;
               ++Result->MatchCount;
            }
         } else {
            ++Result->MismatchCount;
         }

      }

   } finally {
      if (Status != ERROR_SUCCESS) {
         ++Result->MismatchCount; 
      }
      free(Volume);
   }
   return ERROR_SUCCESS;
}


DWORD
Mountie_Set(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry)
{
   DWORD Status = ClusterRegSetValue(ResourceEntry->ResourceParametersKey,
                               MOUNTIE_VOLUME_INFO,
                               REG_BINARY,
                               (LPBYTE)Info->Volume,
                               Info->VolumeStructSize);
   return Status;
}


///////////////////////////////////////////////////////////
//
// NT5 MountManager's volume information access routines
//
//   MountMgr_Get
//   MountMgr_Set
//
//////////

DWORD
MountMgr_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result)
{
   DWORD PartitionCount = Info->Volume->PartitionCount;
   DWORD i;
   DWORD error;
   NTSTATUS ntStatus;
   HANDLE MountManager;

   ntStatus = DevfileOpen(&MountManager, MOUNTMGR_DEVICE_NAME);
   if (!NT_SUCCESS(ntStatus)) {
      if ( ResourceEntry ) {
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"Get: MountMgr open failed, status %1!X!.\n", ntStatus);
       }
       return RtlNtStatusToDosError(ntStatus);
   }

   error = ERROR_SUCCESS;
   try {

      for (i = 0; i < PartitionCount; ++i) {
         PMOUNTIE_PARTITION entry = Info->Volume->Partition + i;
         WCHAR DeviceName[MAX_PATH];
         UCHAR ch;

         swprintf(DeviceName, DEVICE_HARDDISK_PARTITION_FMT, 
                  Info->HarddiskNo, entry->PartitionNumber);

         ntStatus = GetAssignedLetterM(MountManager, DeviceName, &ch);
         
         if ( NT_SUCCESS(ntStatus) ) {
            if (Result && ch) {
               ch -= 'A';
               Result->DriveLetters |= ( 1 << ch );
               Result->PartNumber[ch] = (PARTITION_NUMBER_TYPE) entry->PartitionNumber;
               ++Result->MatchCount;
            }
         } else {
            if ( ResourceEntry ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Get Assigned Letter for %1!ws! returned status %2!X!.\n", DeviceName, ntStatus);
            }
            error = RtlNtStatusToDosError(ntStatus);
            leave;
         }
      }

   } finally {
      DevfileClose(MountManager);
   }
   
   return error;
}


DWORD
MountMgr_Set(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry
    )
{
   HANDLE MountManager;
   DWORD PartitionCount = Info->Volume->PartitionCount;
   DWORD i, status;
   UCHAR dosName[3];
   NTSTATUS ntStatus;

  (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MountMgr_Set: Entry\n");

   ntStatus = DevfileOpen(&MountManager, MOUNTMGR_DEVICE_NAME);
   if (!NT_SUCCESS(ntStatus)) {
      (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_ERROR,
          L"Set: MountMgr open failed, status %1!X!.\n", ntStatus);
       return RtlNtStatusToDosError(ntStatus);
   }

   try {
      dosName[1] = ':';
      dosName[2] = '\0';
   
      //
      // Remove old assignment of letters we are going to use
      //
   
      for (i = 0; i < 26; ++i) {
        if ( (1 << i) & Info->DriveLetters ) {
           dosName[0] = (UCHAR)('A' + i);
           status = DisksRemoveDosDeviceM(MountManager, dosName);
           (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountMgr_Set: Remove Dos Device, letter=%1!c!, status=%2!u!\n",
                NICE_DRIVE_LETTER(dosName[0]), status);
        }
      }
      
      for (i = 0; i < PartitionCount; ++i) {
         PMOUNTIE_PARTITION entry = Info->Volume->Partition + i;
         WCHAR DeviceName[MAX_PATH];
         UCHAR ch;
   
         swprintf(DeviceName, DEVICE_HARDDISK_PARTITION_FMT, 
                  Info->HarddiskNo, entry->PartitionNumber);
   
         ntStatus = GetAssignedLetterM(MountManager, DeviceName, &ch);
         if ( NT_SUCCESS(ntStatus) && ch) {
            dosName[0] = ch;
            status = DisksRemoveDosDeviceM(MountManager, dosName);                    
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountMgr_Set: Remove Dos Device 2, letter=%1!c!, status=%2!u!\n",
                NICE_DRIVE_LETTER(dosName[0]), status);
         }
         if (entry->DriveLetter) {
            dosName[0] = entry->DriveLetter;
            status = DisksAssignDosDeviceM(MountManager, dosName, DeviceName);
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountMgr_Set: Assign Dos Device, letter=%1!c!, status=%2!u!\n",
                NICE_DRIVE_LETTER(dosName[0]), status);
         }
      }
   } finally {
      DevfileClose( MountManager );
   }

    return ERROR_SUCCESS;

}


/////////////////////////////////////////////////////////////////////////
//
// information providers table
//
//  Disk\Information has to be the last entry of the table
//
//  Order of the entries is important
//
/////////////////////////////////////////////////////////////////

INFO_PROVIDER Providers[] = {
   {L"ClusReg-DiskInfo",      CluDiskInfo_Get, CluDiskInfo_Set},
   {L"ClusReg-Mountie",       Mountie_Get, Mountie_Set},
   {L"MountMgr",              MountMgr_Get, MountMgr_Set},
   {L"Registry-System\\DISK", FtInfo_Get, FtInfo_Set}, // Disk\Information must be the last (Why?)
};

enum {
   PROVIDER_COUNT = sizeof(Providers)/sizeof(Providers[0]),
   MOUNT_MANAGER = PROVIDER_COUNT - 2,
};

DWORD
MountieUpdate(
    PMOUNTIE_INFO info, 
    PDISK_RESOURCE ResourceEntry)
/*++

Routine Description:
    Update disk information for all providers
    marked in NeedsUpdate bitmask

Inputs:
    Info - MountieInfo
    
--*/
{
    DWORD NeedsUpdate = info->NeedsUpdate;
    BOOLEAN SharingPausedError = FALSE;
    DWORD   LastError = ERROR_SUCCESS;
    INT   i;

    if (!NeedsUpdate) {
       return ERROR_SUCCESS;
    }

    for (i = 0; i < PROVIDER_COUNT; ++i) {
       if ( (1 << i) & NeedsUpdate ) {
          DWORD status; 
          status = Providers[i].SetInfo(info, ResourceEntry);
          if (status != ERROR_SUCCESS) {
             (DiskpLogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_INFORMATION,
                 L"MountieUpdate: %1!ws!.SetInfo failed, error %2!u!.\n", Providers[i].Name, status);
             if (status == ERROR_SHARING_PAUSED) {
                SharingPausedError = TRUE;
             } else {
                LastError = status;
             }
          } else {
             NeedsUpdate &= ~(1 << i);
          }
       }
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MountieUpdate: Update needed for %1!02x!.\n", NeedsUpdate);
    info->NeedsUpdate = NeedsUpdate;
    if (NeedsUpdate) {
       if (SharingPausedError) {
          return ERROR_SHARING_PAUSED;
       }
       return LastError;
    }
    return ERROR_SUCCESS;
}


DWORD
MountieVerify(
    PMOUNTIE_INFO info, 
    PDISK_RESOURCE ResourceEntry,
    BOOL UseMountMgr
    ) 
/*++

Routine Description:

    1. Compares information from all
       providers and select one of them as source of
       drive letter assignment.
       
    2. Update MountieInfo with this drive letter assignment
    
    3. Set NeedsUpdate for every provider whose information
       differ from the MountieInfo

Inputs:
    Info - MountieInfo
    
--*/
{
    LETTER_ASSIGNMENT results[PROVIDER_COUNT + 1];
    INT i;
    INT GoodProvider = -1;
    INT BestProvider = -1;
    DWORD BestMatch  = 0;
    INT PartitionCount;
    DWORD DriveLetters;
    BOOLEAN UnassignedPartitions = FALSE;
    DWORD NeedsUpdate = 0;
    DWORD errorLevel;

    if (!info->Volume || info->Volume->PartitionCount == 0) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"FatalError: Bad Mountie Info.\n");
        return  ERROR_INVALID_HANDLE;
    }

    PartitionCount = info->Volume->PartitionCount;

    // 
    // Clear old DriveLetters in MOUNTIE_INFO
    //
    for (i = 0; i < PartitionCount; ++i) {
        info->Volume->Partition[i].DriveLetter = 0;
    }

    //
    // Collect Letter Assignments from Providers
    //

    RtlZeroMemory( results, sizeof(results) );

    for (i = PROVIDER_COUNT; --i >= 0;) {
        DWORD status;
        status = Providers[i].GetInfo(info, ResourceEntry, results + i);
        if (status != ERROR_SUCCESS) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountieVerify: %1!ws!.GetInfo returned %2!u! [%3!u!:%4!u!].\n", 
                Providers[i].Name, status, results[i].MatchCount, results[i].MismatchCount);
            return status;
        }
        if (results[i].MatchCount && !results[i].MismatchCount) {
            GoodProvider = i;
            if (results[i].MatchCount >= BestMatch) {
                BestProvider = i;
                BestMatch    = results[i].MatchCount;
            }
        } else {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountieVerify: %1!ws!.GetInfo returned %2!u! [%3!u!:%4!u!].\n", 
                Providers[i].Name, status, results[i].MatchCount, results[i].MismatchCount);
        }
    }

    if (GoodProvider < 0 || GoodProvider >= PROVIDER_COUNT) {

        if ( !DisksGetLettersForSignature( ResourceEntry ) ) {
            // No drive letters, we are using mount points and this is not an error.
            errorLevel = LOG_WARNING;
        } else {
            // Drive letters exist, this is likely an error.
            errorLevel = LOG_ERROR;
        }

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            errorLevel,
            L"MountieVerify: No good providers: %1!d!. \n", GoodProvider);
        return  ERROR_INVALID_HANDLE;
    }

    if (UseMountMgr) {
        GoodProvider = MOUNT_MANAGER;
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MountieVerify: %1!ws! selected.\n", 
        Providers[GoodProvider].Name);

    if (GoodProvider != BestProvider) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"MountieVerify: %1!ws! is better.\n", 
            Providers[BestProvider].Name);
    }

    //
    // Now GoodProvider now holds an index of the highest
    // provider with non stale information.
    //
    // Copy its letter assignment to a MOUNTIE_INFO
    //

    for (i = 0; i < PartitionCount; ++i) {
        UCHAR ch = AssignedLetterByPartitionNumber(
                   results + GoodProvider, 
                   info->Volume->Partition[i].PartitionNumber);
        info->Volume->Partition[i].DriveLetter = ch;
        if (!ch) {
            UnassignedPartitions = TRUE;
        }
    }

#if 0
    // No need to assign drive letters, since now we understand
    // PnP
    if (UnassignedPartitions) {
      //
      // Now give some arbitrary letter assignment to all 
      // partitions without a drive letter
      //

      DriveLetters = GetLogicalDrives();
      if (!DriveLetters) {
         (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_ERROR,
             L"GetLogicalDrivers failed, error %u.\n", GetLastError() );
      } else {
         DWORD Letter = 0;

         DriveLetters &= ~results[MOUNT_MANAGER].DriveLetters; 
         DriveLetters |=  results[GoodProvider].DriveLetters;
         DriveLetters |=  3; // Consider A and B drive letters busy //

         for (i = 0; i < PartitionCount; ++i) {
            PUCHAR pch = &info->Volume->Partition[i].DriveLetter;
            if (!*pch) {
               while( (1 << Letter) & DriveLetters ){
                  if (++Letter == 26) {
                     goto no_more_letters;
                  }
               }
               *pch = (UCHAR) ('A' + Letter);
               if (++Letter == 26) {
                  break;
               }
            }
         }
         no_more_letters:;
      }
    }
#endif

    // Update Drive Letters Mask //
    MountieUpdateDriveLetters(info);
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MountieVerify: DriveLetters mask is now %1!08x!.\n", info->DriveLetters );

    //
    // At this point MOUNTIE_INFO has a complete letter assignment
    // for all partitions
    //
    // Now let's find which Providers needs to be updated
    // 

    for (i = 0; i < PartitionCount; ++i) {
        PMOUNTIE_PARTITION entry = info->Volume->Partition + i;
        if (entry->DriveLetter) {
            results[PROVIDER_COUNT].PartNumber[ entry->DriveLetter - 'A' ] = 
                (PARTITION_NUMBER_TYPE) entry->PartitionNumber;
        }
    }
    results[PROVIDER_COUNT].DriveLetters = info->DriveLetters;

    //
    // All provides whose entries are different from results[PROVIDER_COUNT]
    // need to be updated
    //

    for (i = 0; i < PROVIDER_COUNT; ++i) {
        if (results[i].DriveLetters != results[PROVIDER_COUNT].DriveLetters
          || results[i].MismatchCount
          || 0 != memcmp(results[i].PartNumber, 
                         results[PROVIDER_COUNT].PartNumber, sizeof(results[i].PartNumber) ) 
         )
        {
            NeedsUpdate |= (1 << i);
        }
    }

    info->NeedsUpdate = NeedsUpdate;

    if (NeedsUpdate) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"MountieVerify: Update needed for %1!02x!.\n", NeedsUpdate);
        //
        //  Chittur Subbaraman (chitturs) - 11/5/98
        //
        //  If you plan to update the cluster registry values with info
        //  from the other providers, then log a warning to the event log.
        //
        if ( ( NeedsUpdate & 0x0003 ) && (GoodProvider == 2) && !UseMountMgr )
        {
            WCHAR  szNewDriveLetterList[55];
            WCHAR  szOriginalDriveLetterList[55];
            DWORD  j = 0, k = 0;

            for (i = 0; i < 26; ++i) {
                if ( (1 << i) & results[PROVIDER_COUNT].DriveLetters ) {
                    szNewDriveLetterList[j] = (WCHAR)(L'A' + i);
                    szNewDriveLetterList[j+1] = L' ';
                    j += 2;
                }
                if ( (1 << i) & results[0].DriveLetters ) {
                    szOriginalDriveLetterList[k] = (WCHAR)(L'A' + i);
                    szOriginalDriveLetterList[k+1] = L' ';
                    k += 2;
                }
            }
            szNewDriveLetterList[j] = L'\0';
            szOriginalDriveLetterList[k] = L'\0';

            //
            // GorN. 8/25/99.
            //
            // Log the event only if OriginalDriveLetterList is empty.
            //
            if ( results[PROVIDER_COUNT].DriveLetters ) {
                ClusResLogSystemEventByKey2( ResourceEntry->ResourceKey,
                                             LOG_NOISE,
                                             RES_DISK_WRITING_TO_CLUSREG,
                                             szOriginalDriveLetterList,
                                             szNewDriveLetterList
                                             );
            }                                       
        }
    }

    return ERROR_SUCCESS;
}

DWORD VolumesReady(
   IN PMOUNTIE_INFO Info,
   IN PDISK_RESOURCE ResourceEntry
   )
/*++

Routine Description:
    
    Checks whether each partition described in the MountieInfo can be seen by the
    Mount Manager.

Inputs:

    
--*/
{
    PMOUNTIE_PARTITION entry;
    
    DWORD status = NO_ERROR;
    DWORD nPartitions = MountiePartitionCount( Info );
    DWORD i;
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
       
    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];
   
    for ( i = 0; i < nPartitions; ++i ) {

        entry = MountiePartition( Info, i );

        if ( !entry ) {
            
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"VolumesReady: no partition entry for partition %1!u! \n", i );
            
            // 
            // Something bad happened to our data structures.  Stop processing and
            // return error.
            //
            
            status = ERROR_INVALID_DATA;
            
            break;
        }
        
        //
        // Given the DiskPartName, get the VolGuid name.  This name must have a trailing
        // backslash to work correctly.
        //

        _snwprintf( szGlobalDiskPartName,
                    MAX_PATH,
                    GLOBALROOT_HARDDISK_PARTITION_FMT, 
                    physicalDrive,
                    entry->PartitionNumber );
                
        if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                 szVolumeName,
                                                 sizeof(szVolumeName)/sizeof(WCHAR) )) {
                                                 
            status = GetLastError();
    
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"VolumesReady: GetVolumeNameForVolumeMountPoint for %1!ws! returned %2!u!\n", 
                  szGlobalDiskPartName,
                  status );
            
            // 
            // Something bad happened - stop checking this disk.  Return the
            // error status we received.
            //
            
            break;
        }
        
        //
        // If we get here, this volume is recognized by the Mount Manager.
        //
    }        
   
    return status;

}   // VolumesReady

                   
NTSTATUS
GetAssignedLetter ( 
    PWCHAR deviceName, 
    PCHAR driveLetter ) 
{
   HANDLE MountMgrHandle = NULL;
   DWORD status = DevfileOpen( &MountMgrHandle, MOUNTMGR_DEVICE_NAME );

   if (driveLetter) {
      *driveLetter = 0;
   }

   if ( NT_SUCCESS(status) && MountMgrHandle ) {
      status = GetAssignedLetterM(MountMgrHandle, deviceName, driveLetter);
      DevfileClose(MountMgrHandle);
   } 

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\newmount.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    newmount.h

Abstract:

    Replacement for mountie.h

Author:

    Gor Nishanov (GorN) 31-July-1998

Environment:

    User Mode

Revision History:


--*/

typedef struct _MOUNTIE_PARTITION {
    LARGE_INTEGER   StartingOffset;
    LARGE_INTEGER   PartitionLength;
    DWORD           PartitionNumber;
    UCHAR           PartitionType;
    UCHAR           DriveLetter;
    USHORT          Reserved; // must be 0 //
} MOUNTIE_PARTITION, *PMOUNTIE_PARTITION;

// PARTITION_INFORMATION

typedef struct _MOUNTIE_VOLUME {
    DWORD         Signature;
    DWORD         PartitionCount;
    MOUNTIE_PARTITION Partition[1];
} MOUNTIE_VOLUME, *PMOUNTIE_VOLUME;


#define NICE_DRIVE_LETTER(x) ((x)?(x):'?')

NTSTATUS
GetAssignedLetter ( 
    PWCHAR deviceName, 
    PCHAR driveLetter 
    );

PVOID
DoIoctlAndAllocate(
    IN HANDLE FileHandle,
    IN DWORD  IoControlCode,
    IN PVOID  InBuf,
    IN ULONG  InBufSize,
    OUT LPDWORD BytesReturned
    );

NTSTATUS
DevfileOpen(
    OUT HANDLE *Handle,
    IN wchar_t *pathname
    );

VOID
DevfileClose(
    IN HANDLE Handle
    );


DWORD
MountieRecreateVolumeInfoFromHandle(
   IN  HANDLE FileHandle,
   IN  DWORD  HarddiskNo,
   IN  HANDLE ResourceHandle,
   IN OUT PMOUNTIE_INFO Info
   );

VOID
MountieCleanup(
   IN OUT PMOUNTIE_INFO Info
   );

DWORD 
VolumesReady(
   IN PMOUNTIE_INFO Info,
   IN PDISK_RESOURCE ResourceEntry
   );

DWORD
MountieFindPartitionsForDisk(
    IN DWORD HarddiskNo,
    OUT PMOUNTIE_INFO MountieInfo
    );

DWORD
DisksGetLettersForSignature(
    IN PDISK_RESOURCE ResourceEntry
    );

DWORD
MountieUpdate(
   PMOUNTIE_INFO Info,
   PDISK_RESOURCE ResourceEntry
   );

DWORD
MountieVerify(
   PMOUNTIE_INFO info, 
   PDISK_RESOURCE ResourceEntry,
   BOOL UseMountMgr
   );

DWORD 
MountiePartitionCount(
   IN PMOUNTIE_INFO Info
   );

PMOUNTIE_PARTITION
MountiePartition(
   IN PMOUNTIE_INFO Info,
   IN DWORD Index
   );

VOID
MountiePrint(   
   IN PMOUNTIE_INFO Info,
   IN HANDLE ResourceHandle
   );

NTSTATUS
DevfileIoctl(
    IN HANDLE Handle,
    IN DWORD Ioctl,
    IN PVOID InBuf,
    IN ULONG InBufSize,
    IN OUT PVOID OutBuf,
    IN DWORD OutBufSize,
    OUT LPDWORD returnLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\pnp.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pnp

Abstract:

    This module processes disk related PnP notifications
    and tries to adjust partitions and drive letter information
    accordingly.

Author:

    Gor Nishanov (gorn) 21-Dec-1998

Environment:

    User Mode

Revision History:


--*/

#define UNICODE 1
#define INITGUID 1
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <dbt.h>
#include <devioctl.h>
#include <devguid.h>
#include <ioevent.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <mountmgr.h>
#include <pnpmgr.h>
#include <setupapi.h>

//#include <windows.h>

#include "disksp.h"
#include "newmount.h"
#include "newdisks.h"

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

static HWND DummyWindow = 0;
static BOOL PnPInitialized = FALSE;
static HANDLE NotificationWatcherThreadHandle;

static HANDLE PnpInterfacesRegistered;

static LONG VolumeListUpdateInProcess = 0;

RTL_RESOURCE    PnpVolumeLock;
RTL_RESOURCE    PnpWaitingListLock;

WCHAR g_DiskResource[] = L"rtPhysical Disk";
#define RESOURCE_TYPE ((RESOURCE_HANDLE)g_DiskResource)

extern PWCHAR GLOBALROOT_HARDDISK_PARTITION_FMT;    // L"\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition%u\\";

LIST_ENTRY WaitingDisks;

typedef struct _WAITING_DISK  {
    LIST_ENTRY  ListEntry;
    PDISK_RESOURCE ResourceEntry;
    HANDLE      Event;
    DWORD       Signature;
    ULONG       PartitionCount;
} WAITING_DISK, *PWAITING_DISK;

#define AcquireShared( _res_lock )      \
    RtlAcquireResourceShared( _res_lock, TRUE );

#define ReleaseShared( _res_lock )      \
    RtlReleaseResource( _res_lock );
    
#define AcquireExclusive( _res_lock )   \
    RtlAcquireResourceExclusive( _res_lock, TRUE );

#define ReleaseExclusive( _res_lock )   \
    RtlReleaseResource( _res_lock );


DWORD
NotificationWatcherThread(
    IN LPVOID
    );

VOID
ProcessMountPointChange( 
    HDEVNOTIFY devNotify 
    );

PWAITING_DISK
FindWaitingDisk(
    DWORD Signature
    );

DWORD
GetVolName(
    PWCHAR Name,
    PWCHAR *VolGuid
    );

DWORD
StartNotificationWatcherThread(
    VOID)
{
    DWORD status = ERROR_SUCCESS;
    HANDLE thread;

    if ( InterlockedCompareExchange(&PnPInitialized, TRUE, FALSE) ) {
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] PnP was already initialized.\n",
             status );
        return ERROR_SUCCESS;
    }

    PnpInterfacesRegistered = NULL;
    PnpInterfacesRegistered = CreateEvent( NULL,    // security attributes
                                           TRUE,    // manual reset
                                           FALSE,   // initial state nonsignaled
                                           NULL );  // event name

    if ( NULL == PnpInterfacesRegistered ) {
        status = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] Unable to create event for PnP interface registration. \n",
             status );
        status = ERROR_SUCCESS;
    }

    thread = 
        CreateThread( NULL, // security attributes
                      0,    // stack_size = default
                      NotificationWatcherThread,
                      (LPVOID)0, // no parameters
                      0,    // runs immediately
                      0 );  // don't need thread id
    if(thread == NULL) {
        status = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] StartNotificationWatcherThread failed, error: %1!u!. \n",
             status );
    } else {

        if ( NULL != PnpInterfacesRegistered ) {
            
            //
            // Before returning to caller, make sure all PnP interfaces
            // are registered.
            //

            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] Waiting for PnP interface registration to complete.\n" );

            status = WaitForSingleObject( PnpInterfacesRegistered, 30 * 1000 );

            if ( WAIT_TIMEOUT == status ) {
                (DiskpLogEvent)(
                     RESOURCE_TYPE,
                     LOG_ERROR,
                     L"[PnP] PnP interface registration failed to complete in time, error: %1!u! \n",
                     status );
            }
            
            CloseHandle( PnpInterfacesRegistered );
            PnpInterfacesRegistered = NULL;

            status = ERROR_SUCCESS;
        }

    }
    NotificationWatcherThreadHandle = thread;

    return status;
}

VOID
StopNotificationWatcher(
    VOID
    )
/*++

 Routine Description:

     Handler for console control events 

 Arguments:

     dwCtrlType - Indicates the console event to handle.

 Return Value:

     TRUE if the event was handled, FALSE otherwise.

--*/

{
    HANDLE localHandle = NotificationWatcherThreadHandle;
    if (DummyWindow) {
        PostMessage(DummyWindow, WM_QUIT, 0, 0);
        if (localHandle) {
            WaitForSingleObject(localHandle, 10 * 1000);
            CloseHandle(localHandle);
        }
    }
}

#define WM_WatchDisk        (WM_USER + 1)
#define WM_StopWatchingDisk (WM_USER + 2)

VOID
WatchDisk(
    IN PDISK_RESOURCE ResourceEntry
    )
{
    if (DummyWindow) {
        PostMessage(DummyWindow, WM_WatchDisk, 0, (LPARAM)ResourceEntry);
    }
}

VOID
StopWatchingDisk(
    IN PDISK_RESOURCE ResourceEntry
    )
{
    if (DummyWindow) {
        SendMessage(DummyWindow, WM_StopWatchingDisk, 0, (LPARAM)ResourceEntry);
    }
}

///////////////////////////////////////////////////////////////////////////

VOID
MyUnregisterDeviceNotification(HDEVNOTIFY hNotify) 
{
#if DBG
    (DiskpLogEvent)(
         RESOURCE_TYPE,
         LOG_INFORMATION,
         L"[PnP] Unregistering device notification - HDEVNOTIFY %1!x! \n",
         hNotify );
#endif
    
    UnregisterDeviceNotification( hNotify );
}
        
HDEVNOTIFY
MyRegisterDeviceNotification(
    IN HANDLE hRecipient,
    IN LPVOID NotificationFilter,
    IN DWORD Flags
    )
{

#if DBG
    (DiskpLogEvent)(
         RESOURCE_TYPE,
         LOG_INFORMATION,
         L"[PnP] Registering device notification - Recipient %1!x!  Flags %2!x! \n",
         hRecipient,
         Flags );
#endif

    return RegisterDeviceNotification( hRecipient,
                                       NotificationFilter,
                                       Flags
                                       );
}

DWORD
RegisterDeviceHandle(
    IN HANDLE wnd, 
    IN HANDLE device,
    OUT HDEVNOTIFY *devNotify) 
{
    DEV_BROADCAST_HANDLE DbtHandle;
    DWORD status = ERROR_SUCCESS;
    *devNotify = 0;

    ZeroMemory(&DbtHandle,sizeof(DEV_BROADCAST_HANDLE));
 
    DbtHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    DbtHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
    DbtHandle.dbch_handle = device;
 
        
    *devNotify = MyRegisterDeviceNotification(
                                    (HANDLE)wnd,
                                    &DbtHandle,
                                    DEVICE_NOTIFY_WINDOW_HANDLE
                                    );
    if (!*devNotify) {
        status = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] DBT_DEVTYP_HANDLE failed, error %1!u!\n", 
             status );
    }
    return status;
}

DWORD
RegisterDeviceInterface(
    IN HANDLE wnd, 
    IN const GUID * guid,
    OUT HDEVNOTIFY *devNotify) 
{
    DEV_BROADCAST_DEVICEINTERFACE filter;
    DWORD status = ERROR_SUCCESS;
    *devNotify = 0;

    ZeroMemory(&filter, sizeof(filter));
    filter.dbcc_size = sizeof(filter);
    filter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    CopyMemory(&filter.dbcc_classguid, guid, sizeof(filter.dbcc_classguid));
        
    *devNotify = MyRegisterDeviceNotification(
                                    (HANDLE)wnd,
                                    &filter,
                                    DEVICE_NOTIFY_WINDOW_HANDLE
                                    );
    if (!*devNotify) {
        status = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] DBT_DEVTYP_DEVICEINTERFACE failed, error %1!u!\n", 
             status );
    }
    return status;
}

///////////// Forward Declarations /////////////////
typedef struct _VOLUME *PVOLUME;

VOID
PokeDiskResource(
    PVOLUME vol
    );
/*++

Routine Description:

    Updates ClusterRegistry info if necessary

Arguments:

    Volume of interest (used only to get the disk signature)
    Updates a per disk basis

Return Value:

    None

--*/

DWORD
GetVolumeInfo(
    PVOLUME Vol,
    PHANDLE FileHandle
    );


///////////// End Forward Declarations /////////////


////////////// Notification List Management //////////////////////////////
//
// We maintain a list of all volumes we are getting PnP notifications for
//
//   PVOLUME FindVolume(HDEVNOTIFY Key);
//   VOID    DestroyVolume(PVOLUME vol);
//   VOID    RemoveVolume(HDEVNOTIFY devNotify);
//   VOID    AddVolume(PWCHAR Name) 
//
LIST_ENTRY VolumeList;

typedef struct _VOLUME  {
    LIST_ENTRY ListEntry;
    HDEVNOTIFY DevNotify;
    DWORD Signature;
    LARGE_INTEGER PartOffset;
    LARGE_INTEGER PartLength;
    ULONG         PartNo;
    BYTE PartitionType;
    UCHAR DriveLetter;
    WCHAR Name[1];
} VOLUME;


PVOLUME
FindVolume(HDEVNOTIFY Key)
{
    PLIST_ENTRY entry;
    for ( entry = VolumeList.Flink;
          entry != &VolumeList;
          entry = entry->Flink
        )
    {
        PVOLUME vol = CONTAINING_RECORD(
                       entry,
                       VOLUME,
                       ListEntry
                       );

        if (vol->DevNotify == Key) {
            return(vol);
        }
    }
    return 0;
}

VOID
DestroyVolume(
    PVOLUME vol)
{
//    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
//        L"Destroying entry for %1!s!\n", vol->Name);
    MyUnregisterDeviceNotification(vol->DevNotify);
    LocalFree(vol);
}

VOID
RemoveVolume(HDEVNOTIFY devNotify)
{
    PVOLUME vol = NULL;

    // Use a lock here as the online thread might be parsing the volume list.
    
    AcquireExclusive( &PnpVolumeLock );

    vol = FindVolume( devNotify );    
    if (!vol) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] RemoveVolume: devNotify %1!d! is not in the list\n", devNotify);
        ReleaseExclusive( &PnpVolumeLock );
        return;
    }

    PokeDiskResource(vol);

    RemoveEntryList(&vol->ListEntry);
    ReleaseExclusive( &PnpVolumeLock );
    DestroyVolume(vol);
}


VOID
AddVolume(
    PWCHAR Name
    ) 
{
    PWAITING_DISK  waitDisk;
    PLIST_ENTRY entry;
    PVOLUME volList;
    PVOLUME vol = NULL;
    PWCHAR  volGuid = NULL;

    DWORD   status;
    DWORD   signature;
        
    INT     len;
    
    HANDLE  fileHandle;
    
    BOOL    duplicateEntry;
    BOOL    keepVolume = FALSE;

    //
    // Convert name to VolGuid name.  If name is already a VolGuid
    // name, the correct name will be returned.  GetVolName will
    // always return a name with a trailing backslash.
    //
    
    status = GetVolName( Name, &volGuid );    
    
    if ( ERROR_SUCCESS != status || !volGuid ) {
        goto FnExit;
    }

    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] AddVolume: Attempting to add volume %1!s!\n", volGuid );
    
    len = wcslen(volGuid);
    vol = LocalAlloc(LPTR, sizeof(VOLUME) + len * sizeof(WCHAR));
    
    if ( NULL == vol ) {
        
        status = GetLastError();
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] AddVolume: can't alloc VOL+%1!d!, error %2!u!\n", len, status );
        
        goto FnExit;
    }

    ZeroMemory( vol, sizeof(VOLUME) + len * sizeof(WCHAR) );
    wcscpy(vol->Name, volGuid);
    
    //
    // Skip CDROM devices.  This requires a trailing backslash and
    // prefix \\?\.
    //

    if ( DRIVE_CDROM == GetDriveType( vol->Name ) ) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Skipping CDROM volume %1!s!\n", vol->Name );
        goto FnExit;
    }

    //
    // Skip floppy devices.  This requires a trailing backslash and
    // prefix \\?\.
    //

    if ( DRIVE_REMOVABLE == GetDriveType( vol->Name ) ) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Skipping floppy volume %1!s!\n", vol->Name );
        goto FnExit;
    }

    if (len > 0 && vol->Name[len-1] == L'\\') 
    {
        // remove trailing backslash
        vol->Name[len-1] = 0;
    }

    if (len > 2 && vol->Name[0] == L'\\' && vol->Name[1] == L'\\') {
        // Convert to NT file name 
        vol->Name[1] = L'?';
    }
    
    //
    // Make sure the volume isn't already in the list.  If so,
    // skip it.
    //

    duplicateEntry = FALSE;
    AcquireShared( &PnpVolumeLock );
    
    len = wcslen( vol->Name );
    for ( entry = VolumeList.Flink;
          entry != &VolumeList;
          entry = entry->Flink
        )
    {
        volList = CONTAINING_RECORD( entry,
                                     VOLUME,              
                                     ListEntry
                                     );

        if ( ( len == wcslen( volList->Name) ) &&
             ( 0 == _wcsnicmp( vol->Name, volList->Name, len ) ) ) {
            
            duplicateEntry = TRUE;
            break;
        }
    }

    ReleaseShared( &PnpVolumeLock );

    if ( duplicateEntry ) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Skipping duplicate volume %1!s!\n", vol->Name );
        goto FnExit;
    }

    status = GetVolumeInfo( vol, &fileHandle );
    
    //
    // We might have a clustered disk now, but we can't read the 
    // partition info or drive layout because the disk is reserved
    // by another node.  
    //
    // If the disk is reserved by another node, we typically see
    // this returned:  
    //   170 ERROR_BUSY
    // If the disk is offline, we can see this:
    //   2 ERROR_FILE_NOT_FOUND
    //
    // About all we know for sure is that if this is a non-fixed device,
    // ERROR_INVALID_FUNCTION will be returned.  For now, skip these
    // devices and track any other volumes coming through.
    //
    
    if ( ERROR_INVALID_FUNCTION == status ) {

        if ( INVALID_HANDLE_VALUE != fileHandle) {
            DevfileClose( fileHandle );
        }
        
        // Change this from LOG_ERROR to LOG_INFORMATION.  This thread gets
        // notified when non-fixed disks arrive (i.e. floppy), so logging
        // an error for a floppy disk is misleading.
        
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Skipping volume %1!ws! \n",
            vol->Name);
        
        goto FnExit;
    }

    if ( INVALID_HANDLE_VALUE == fileHandle ) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_WARNING,
            L"[PnP] AddVolume: Unable to get volume handle (%1!ws!), error %2!u!\n",
            vol->Name, status);
        
        goto FnExit;
    }

    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] AddVolume: adding volume %1!s!\n", vol->Name );

    status = RegisterDeviceHandle(DummyWindow, fileHandle, &vol->DevNotify);
    DevfileClose( fileHandle );

    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] AddVolume: RDN(%1!ws!), error %2!u!\n",
            vol->Name, 
            status);
        goto FnExit;
    }

    GetAssignedLetter(vol->Name, &vol->DriveLetter);

    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] AddVolume: %1!s! '%2!c!', %3!d! (%4!u!)\n", 
        Name, (vol->DriveLetter)?vol->DriveLetter:' ', vol->PartitionType, vol->DevNotify);
    
    // Use a lock here as the online thread might be parsing the volume list.

    // As soon as the volume is added to the list, another thread could come
    // through and remove it.  Save the signature to a local variable so
    // we can check the waiting list.
    
    signature = vol->Signature;
    keepVolume = TRUE;
    AcquireExclusive( &PnpVolumeLock );
    InsertTailList(&VolumeList, &vol->ListEntry);
    ReleaseExclusive( &PnpVolumeLock );
    
    AcquireShared( &PnpWaitingListLock );
    waitDisk = FindWaitingDisk( signature );
    if ( waitDisk ) {
        
        // 
        // We have a waiting disk that matches this volume signature.  
        // Now see if all the volumes are in the volume list.
        //

        if ( IsDiskInPnpVolumeList( waitDisk->ResourceEntry, FALSE ) ) {

            (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
                L"[PnP] AddVolume: All volumes present, signal event for signature %1!x!\n", 
                signature );
            
            //
            // All volumes present, signal the event.
            //

            SetEvent( waitDisk->Event );
        
        } else {
        
            (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
                L"[PnP] AddVolume: All volumes not ready for signature %1!x!\n", 
                signature );
        }
    } else {

        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Online request not queued for signature %1!x!\n", 
            signature );
    
    }

    ReleaseShared( &PnpWaitingListLock );

FnExit:

    if ( volGuid ) {
        LocalFree( volGuid );
    }

    if ( !keepVolume && vol ) {
        LocalFree( vol );
    }
}


DWORD
GetVolName(
    PWCHAR Name,
    PWCHAR *VolGuid
    )
{
    PWCHAR  volName = NULL;
    PWCHAR  tempName = NULL;
    
    DWORD   volNameLenBytes;
    DWORD   tempNameLenBytes;
    DWORD   nameLen;

    DWORD   dwError = ERROR_SUCCESS;

    if ( VolGuid ) {
        *VolGuid = NULL;
    }

#if DBG
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] GetVolName: Name %1!s!\n", Name );
#endif
    
    nameLen = wcslen( Name );
    
    //
    // Create a buffer with room for a backslash.
    //
    
    tempNameLenBytes = ( nameLen * sizeof(WCHAR) ) + sizeof(UNICODE_NULL) + sizeof(WCHAR);

    
    tempName = LocalAlloc( LPTR, tempNameLenBytes );
    
    if ( !tempName ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] GetVolName: LocalAlloc for tempName failed, error %1!d! \n", 
             dwError );
        goto FnExit;
    }
    
    wcsncpy( tempName, Name, nameLen );
    
    //
    // Add trailing backslash.
    //
        
    if ( nameLen > 0 && tempName[nameLen-1] != L'\\' ) {
         //
         // This is safe because temporary buffer is larger than
         // original buffer.
         //
         tempName[nameLen] = L'\\';
    }

#if DBG
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] GetVolName: tempName %1!s!\n", tempName );
#endif

    volNameLenBytes = MAX_PATH * sizeof(WCHAR);
    volName = LocalAlloc( LPTR, volNameLenBytes );

    if ( !volName ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] GetVolName: LocalAlloc for volName failed, error %1!d! \n", 
             dwError );
        goto FnExit;
    }

    if ( !GetVolumeNameForVolumeMountPointW( tempName,
                                             volName,
                                             volNameLenBytes / sizeof(WCHAR) ) ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] GetVolName: GetVolumeNameForVolumeMountPoint failed, error %1!d! \n", 
             dwError );
        goto FnExit;                                            
    }

    if ( VolGuid ) {
        *VolGuid = volName;
    }

FnExit:

    if ( dwError != ERROR_SUCCESS && volName ) {
        LocalFree( volName );
    }

    if ( tempName ) {
        LocalFree( tempName );
    }
    
#if DBG
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] GetVolName: returns error %1!d!\n", dwError );
#endif

    return dwError;

}   // GetVolName


///////////////////// VolumeManagement code ends //////////////////////////////////////////

//////////////////// WatchedDiskTable //////////////////////
//
// We maintain a table of disks that are currently online
// and under cluster control. Any PnP notification
// coming for the volumes belonging to these disks,
// need to be processed and cluster registry might need
// to be updated
//
PDISK_RESOURCE WatchedDiskTable[MAX_DISKS] = {0};
INT WatchedDiskCount = 0;

INT
FindDisk(DWORD Signature)
{
    INT i;
    
    if ( !Signature ) {
        return -1;
    }
    
    for(i = 0; i < WatchedDiskCount; ++i) {
        if (WatchedDiskTable[i]->DiskInfo.Params.Signature == Signature) {
            return i;
        }
    }
    return -1;
}

VOID
RemoveDisk(
    PDISK_RESOURCE ResourceEntry
    )
{
    INT i = FindDisk(ResourceEntry->DiskInfo.Params.Signature);
    (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_INFORMATION,
        L"[PnP] Stop watching disk %1!x!\n",
        ResourceEntry->DiskInfo.Params.Signature );

    if (i < 0) {
       (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
           L"[PnP] RemoveDisk: disk %1!x! not found\n", 
           ResourceEntry->DiskInfo.Params.Signature);
       return;
    }
    --WatchedDiskCount;
    if (WatchedDiskCount > 0) {
        WatchedDiskTable[i] = WatchedDiskTable[WatchedDiskCount];
    }
}

VOID
MarkMatchingPartition(
    PVOLUME Volume, 
    PDRIVE_LAYOUT_INFORMATION driveLayout)
/*++

Routine Description:

    Finds a partition in DRIVE_LAYOUT_INFORMATION corresponding to 
    the Volume in question and marks it.
    This routine is used in the code that verifies that there is a
    volume in the VolumeList for every recognized partition on the disk.

Arguments:

Return Value:

    none
    
--*/
{
    PPARTITION_INFORMATION   p   = driveLayout->PartitionEntry;
    PPARTITION_INFORMATION   end = p + driveLayout->PartitionCount;

    for(;p < end; ++p)
    {
        if(p->RecognizedPartition &&
           p->StartingOffset.QuadPart == Volume->PartOffset.QuadPart &&
           p->PartitionLength.QuadPart == Volume->PartLength.QuadPart)
        {
            p->PartitionType = 1;
        }
    }
}

VOID
AddDisk(
    PDISK_RESOURCE ResourceEntry
    )
{
    INT i = FindDisk(ResourceEntry->DiskInfo.Params.Signature);
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    HANDLE fileHandle;
    WCHAR deviceName[MAX_PATH];
    PLIST_ENTRY entry;
    BOOL success;

    (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_INFORMATION,
        L"[PnP] Start watching disk %1!x!\n",
        ResourceEntry->DiskInfo.Params.Signature );

    if (i >= 0) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
            L"[PnP] AddDisk: disk %1!x! is already being watched\n", 
            ResourceEntry->DiskInfo.Params.Signature);
        return;
    }
    if (WatchedDiskCount >= MAX_DISKS) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
            L"[PnP] AddDisk: Disk limit is reached\n");
        return;
    }
    WatchedDiskTable[WatchedDiskCount++] = ResourceEntry;

    // Now we need to verify that we are watching for changes on every //
    // recognized partition on this drive                              //

    wsprintf( deviceName, L"\\\\.\\PhysicalDrive%d", ResourceEntry->DiskInfo.PhysicalDrive );
    fileHandle = CreateFile(deviceName+0,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     0,
                     NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] AddDisk: Can't open %1!s!\n", deviceName);
        return;
    }

    success = ClRtlGetDriveLayoutTable(fileHandle, &driveLayout, 0);
    CloseHandle( fileHandle );

    if ( !success ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
            L"[PnP] AddDisk: Error performing GetDriveLayout; error %1!d!\n",
            GetLastError() );
        return;
    }

    // Clear PartitionType field. We will be using it to mark partions
    // which are in the our list of watched volumes

    for (i = 0; i < (INT)driveLayout->PartitionCount; ++i) {
        driveLayout->PartitionEntry[i].PartitionType = 0;
    }

    // Walk the list of all volumes and mark if this volume is in the partition table //
    for ( entry = VolumeList.Flink;
          entry != &VolumeList;
          entry = entry->Flink
        )
    {
        PVOLUME vol = CONTAINING_RECORD(
                       entry,
                       VOLUME,
                       ListEntry
                       );

        if (vol->Signature == driveLayout->Signature) {
            MarkMatchingPartition(vol, driveLayout);
        }
    }

    // Now all partitions that are in our list is marked
    // We need to add all unmarked partitions to the list

    for (i = 0; i < (INT)driveLayout->PartitionCount; ++i) {
        if (driveLayout->PartitionEntry[i].PartitionType == 0
            && driveLayout->PartitionEntry[i].RecognizedPartition
            ) 
        {
            swprintf( deviceName, GLOBALROOT_HARDDISK_PARTITION_FMT, 
                      ResourceEntry->DiskInfo.PhysicalDrive, 
                      driveLayout->PartitionEntry[i].PartitionNumber);
            AddVolume( deviceName );
        }
    }

    LocalFree( driveLayout );
}
//////////////////// WatchedDiskTable management end //////////////////////



void PokeDiskResource(
    PVOLUME vol) 
/*++

Routine Description:

    Updates ClusterRegistry info if necessary

Arguments:

    Volume of interest (used only to get the disk signature)
    Updates a per disk basis

Return Value:

    None

--*/
{
    INT i = FindDisk(vol->Signature);
    PDISK_RESOURCE ResourceEntry;
    MOUNTIE_INFO Info;
    HANDLE fileHandle;
    DWORD status;
    PVOID OldMountieVolume;
    WCHAR deviceName[MAX_PATH];

    if(i == -1) {
        return;
    }

    ResourceEntry = WatchedDiskTable[i];
    if( ResourceEntry->MountieInfo.UpdateThreadIsActive ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] PokeDiskResource: ClusApi is read only. PnP request ignored\n");
        return;
    }

    ZeroMemory( &Info, sizeof(Info) );
    
    wsprintf( deviceName, L"\\\\.\\PhysicalDrive%d", ResourceEntry->DiskInfo.PhysicalDrive );
    fileHandle = CreateFile(deviceName+0,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     0,
                     NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] PokeDiskResource: Can't open %1!s!\n", deviceName);
        return;
    }

    status = MountieRecreateVolumeInfoFromHandle(
                fileHandle,
                ResourceEntry->MountieInfo.HarddiskNo,
                0,
                &Info);
    CloseHandle(fileHandle);

    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] PokeDiskResource: Can't read partition table, error %1!d!\n", status);
        return;
    }

    MountiePrint(&Info, ResourceEntry->ResourceHandle);

    status = VolumesReady(&Info, ResourceEntry);

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] PokeDiskResource: Volumes not ready, error %1!d!\n", status);
        MountieCleanup(&Info);
        return;
    }

    MountieVerify(&Info, ResourceEntry, TRUE);

    ResourceEntry->MountieInfo.DriveLetters = Info.DriveLetters;
    OldMountieVolume = InterlockedExchangePointer(&ResourceEntry->MountieInfo.Volume, Info.Volume);
    Info.Volume = OldMountieVolume;
    ResourceEntry->MountieInfo.NeedsUpdate = Info.NeedsUpdate;
    ResourceEntry->MountieInfo.VolumeStructSize = Info.VolumeStructSize;

    MountiePrint(&ResourceEntry->MountieInfo, ResourceEntry->ResourceHandle);
    MountieUpdate(&ResourceEntry->MountieInfo, ResourceEntry);

    MountieCleanup(&Info);
}

//
// [HACKHACK] Currently, there is not polically correct way
//  for the resource to learn whether it is a quorum resource or not
//
DWORD
GetQuorumSignature(
    OUT PDWORD QuorumSignature)
{
    WCHAR buf[MAX_PATH];
    WCHAR guid[ sizeof(GUID) * 3 + 1]; 
    // 2 character per byte + 1, in case somebody will put a dash //
    // between every byte                                         //

    DWORD BufSize;
    DWORD Status;
    DWORD Type;
    HKEY  Key;

    lstrcpy(buf, CLUSREG_KEYNAME_CLUSTER);
    lstrcat(buf, L"\\");
    lstrcat(buf, CLUSREG_KEYNAME_QUORUM);

    Status = RegOpenKey( HKEY_LOCAL_MACHINE, buf, &Key );
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    BufSize = sizeof(guid);
    Status = RegQueryValueExW(Key,
                              CLUSREG_NAME_QUORUM_RESOURCE,
                              0,
                              &Type,
                              (LPBYTE)guid,
                              &BufSize );
    RegCloseKey( Key );
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    //
    // Now, we got a quorum resource guid.
    // Let's try to open this resource and read its parameters.
    //

    lstrcpy(buf, CLUSREG_KEYNAME_CLUSTER);
    lstrcat(buf, L"\\");
    lstrcat(buf, CLUSREG_KEYNAME_RESOURCES);
    lstrcat(buf, L"\\");
    lstrcat(buf, guid);
    lstrcat(buf, L"\\");
    lstrcat(buf, CLUSREG_KEYNAME_PARAMETERS);
    
    Status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         buf,
                         &Key );
    if (Status != ERROR_SUCCESS) {
        return Status;
    }
    BufSize = sizeof(DWORD);
    Status = RegQueryValueExW(Key,
                              CLUSREG_NAME_PHYSDISK_SIGNATURE,
                              0,
                              &Type,
                              (LPBYTE)QuorumSignature,
                              &BufSize );
    if (Status != ERROR_SUCCESS) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] DriveLetterChange: failed to open Path = %1!ws!\n", buf);
    }

    RegCloseKey(Key);
    return Status;
}
                    
DWORD
CheckQuorumLetterChange(
    HDEVNOTIFY devNotify,
    UCHAR Old, 
    UCHAR New,
    DWORD Signature)
{
    static HDEVNOTIFY QuorumDevNotify = 0;
    static UCHAR StoredDriveLetter = 0;
    DWORD status;
    UCHAR  QuorumDriveLetter;
    LPWSTR QuorumPath;
    DWORD  QuorumSignature;

    //
    // If we are not watching the disk this volume is on, do nothing
    //
    if ( FindDisk(Signature) == -1) {
        return ERROR_SUCCESS;
    }
    status = GetQuorumSignature(&QuorumSignature);
    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] DriveLetterChange: Unable to query quorum drive signature, status %1!u!\n", status);
        QuorumDevNotify = 0;
        StoredDriveLetter = 0;
        return status;
    }
    
    //
    // Not a quorum disk. Ignore this notification
    //
    if ( QuorumSignature != Signature ) {
        return ERROR_SUCCESS;
    }

    status = DiskspGetQuorumPath(&QuorumPath);
    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] DriveLetterChange: Unable to query quorum drive letter, status %1!u!\n", status);
        QuorumDevNotify = 0;
        StoredDriveLetter = 0;
        return status;
    }
    QuorumDriveLetter = (UCHAR) QuorumPath[0];

    if (QuorumDriveLetter == Old) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] DriveLetterChange: Quorum drive letter %1!c! is being changed\n", QuorumDriveLetter);
        QuorumDevNotify = devNotify;
        StoredDriveLetter = QuorumDriveLetter;
    }
    
    if (New && QuorumDevNotify == devNotify 
        && QuorumDriveLetter != New 
        && QuorumDriveLetter == StoredDriveLetter) 
    {
        WCHAR szOld[2] = {QuorumDriveLetter, 0};
        WCHAR szNew[2] = {New, 0};
        
        ClusterLogEvent2(
            LOG_UNUSUAL, LOG_CURRENT_MODULE, 
            __FILE__, __LINE__,
            RES_DISK_PNP_CHANGING_QUORUM,
            0, NULL,
            szOld, szNew);

        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] DriveLetterChange: Quorum drive letter changed from %1!c! to %2!c!\n", 
            QuorumDriveLetter, New);
        QuorumPath[0] = New;
        status = DiskspSetQuorumPath(QuorumPath);
        if (status != ERROR_SUCCESS) {
            (DiskpLogEvent)(RESOURCE_TYPE, LOG_SEVERE,
                L"[PnP] DriveLetterChange: Unable to update QuorumPath (%1!c!: => %2!c!:), status %3!u!\n", 
                QuorumDriveLetter, New, status);
        }
    }

    LocalFree(QuorumPath);
    return status;
}

VOID
ProcessDriveLetterChange( HDEVNOTIFY devNotify )
{
    PVOLUME vol = FindVolume(devNotify);
    UCHAR ch;
    if (!vol) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] DriveLetterChange: devNotify %1!d! is not in the list\n", devNotify);
        return;
    }
    GetAssignedLetter(vol->Name, &ch);
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] DriveLetterChange: %1!c! => %2!c!\n", 
                    NICE_DRIVE_LETTER(vol->DriveLetter),
                    NICE_DRIVE_LETTER(ch)
        );
    if (vol->PartitionType == PARTITION_IFS 
     && vol->DriveLetter != ch) 
    {
        CheckQuorumLetterChange(devNotify, vol->DriveLetter, ch, vol->Signature);
        PokeDiskResource(vol);
    }
    vol->DriveLetter = ch;
}

VOID 
ProcessVolumeInfoChange( HDEVNOTIFY devNotify )
{
    PVOLUME vol = FindVolume(devNotify);
    BOOL success;
    HANDLE fileHandle = NULL;
    PARTITION_INFORMATION partInfo;
    DWORD bytesReturned;
    NTSTATUS ntStatus;

    if (!vol) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] VolumeInfoChange: devNotify %1!d! is not in the list\n", devNotify);
        return;
    }
    ntStatus = DevfileOpen(&fileHandle, vol->Name);
    if ( !NT_SUCCESS(ntStatus) || !fileHandle ) {
        (DiskpLogEvent)(
            RESOURCE_TYPE,
            LOG_ERROR,
            L"[PnP] VolumeInfoChange: Can't open %1!ws!, error %2!X!.\n",
            vol->Name, ntStatus);
        return;
    }
    
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_PARTITION_INFO,
                               NULL,
                               0,
                               &partInfo,
                               sizeof(PARTITION_INFORMATION),
                               &bytesReturned,
                               FALSE );

    DevfileClose( fileHandle );
    if (!success) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] VolumeInfoChange: Error performing GetPartitionInfo; error %1!d!\n",
            GetLastError());
        return;
    }
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] VolumeInfoChange: partType %1!d! => %2!d!\n", 
                    vol->PartitionType,
                    partInfo.PartitionType
                    );
    if (vol->PartitionType != partInfo.PartitionType 
     && (partInfo.PartitionType == PARTITION_IFS 
         || vol->PartitionType == PARTITION_IFS) ) 
    {
        PokeDiskResource(vol);
    }
    vol->PartitionType = partInfo.PartitionType;
}

//////////////////////////// WindowProc /////////////////////////////////////

#ifndef PDEV_BROADCAST_HEADER
typedef struct _DEV_BROADCAST_HEADER * PDEV_BROADCAST_HEADER;
#endif


LRESULT CALLBACK TestWndProc(
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
) {
    if (uMsg == WM_WatchDisk) {
        PDISK_RESOURCE p = (PDISK_RESOURCE)lParam;
        if (p) {
            AddDisk(p);
        }
        return TRUE;
    }
    if (uMsg == WM_StopWatchingDisk) {
        PDISK_RESOURCE p = (PDISK_RESOURCE)lParam;
        if (p) {
            RemoveDisk(p);
        }
        return TRUE;
    }
    if (uMsg != WM_DEVICECHANGE) {
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    if (!lParam) {
        return TRUE;
    }
#if DBG
    (DiskpLogEvent)(
         RESOURCE_TYPE,
         LOG_INFORMATION,
         L"[PnP] Event %1!x! received\n", 
         wParam );
#endif
    switch( ((PDEV_BROADCAST_HEADER)lParam)->dbcd_devicetype ) 
    {
    case DBT_DEVTYP_DEVICEINTERFACE:
        {
            PDEV_BROADCAST_DEVICEINTERFACE p = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
            if (wParam == DBT_DEVICEARRIVAL && 
                IsEqualGUID(&p->dbcc_classguid, &GUID_IO_VOLUME_DEVICE_INTERFACE)
               ) 
            {
                AddVolume( p->dbcc_name );
            }
            break;
        }
    case DBT_DEVTYP_HANDLE:
        {
            PDEV_BROADCAST_HANDLE p = (PDEV_BROADCAST_HANDLE)lParam;
            if (wParam == DBT_DEVICEREMOVECOMPLETE) {
                RemoveVolume(p->dbch_hdevnotify);
            } else if (wParam == DBT_CUSTOMEVENT) {
                PVOLUME Vol = 0;
                PWCHAR guidName = 0;
                LPDWORD dw = (LPDWORD)&p->dbch_eventguid;
                
                Vol = FindVolume( p->dbch_hdevnotify );

                if ( IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_NAME_CHANGE) ) 
                {
                    // Update disk info.
                    GetVolumeInfo( Vol, NULL );
    
                    ProcessDriveLetterChange( p->dbch_hdevnotify );
                    ProcessMountPointChange( p->dbch_hdevnotify );
                    guidName = L"GUID_IO_VOLUME_NAME_CHANGE";
                } 
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_CHANGE) ) 
                {
                    // Update disk info.
                    GetVolumeInfo( Vol, NULL );
    
                    ProcessVolumeInfoChange( p->dbch_hdevnotify );
                    ProcessMountPointChange( p->dbch_hdevnotify );
                    guidName = L"GUID_IO_VOLUME_CHANGE";
                } 
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_LOCK) ) 
                {
                    guidName = L"GUID_IO_VOLUME_LOCK";
                } 
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_UNLOCK) ) 
                {
                    guidName = L"GUID_IO_VOLUME_UNLOCK";
                } 
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_MOUNT) ) 
                {
//                        ProcessDriveLetterChange( p->dbch_hdevnotify );
                    guidName = L"GUID_IO_VOLUME_MOUNT";
                } 
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_DISMOUNT) ) 
                {
                    guidName = L"GUID_IO_VOLUME_DISMOUNT";
                } 
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_LOCK_FAILED) ) 
                {
                    guidName = L"GUID_IO_VOLUME_LOCK_FAILED";
                } 
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_DISMOUNT_FAILED) ) 
                {
                    guidName = L"GUID_IO_VOLUME_DISMOUNT_FAILED";
                }  
                if (guidName) {
                    if (Vol) {
                        (DiskpLogEvent)(
                             RESOURCE_TYPE,
                             LOG_INFORMATION,
                             L"[PnP] Event %1!s! for %2!c! (Partition%3!d!) received.\n", 
                             guidName, NICE_DRIVE_LETTER(Vol->DriveLetter), Vol->PartNo );
                    } else {
                        (DiskpLogEvent)(
                             RESOURCE_TYPE,
                             LOG_INFORMATION,
                             L"[PnP] Event %1!s! for %2!d! received\n", 
                             guidName, p->dbch_hdevnotify );
                    }
                } else {
                    (DiskpLogEvent)(
                         RESOURCE_TYPE,
                         LOG_INFORMATION,
                         L"[PnP] Event %2!x! %3!x! %4!x! %5!x! for %1!d! received\n", 
                         p->dbch_hdevnotify, dw[0], dw[1], dw[2], dw[3] );
                }
            }
//#endif
            break;
        }
    }
    return TRUE;
}


VOID
AddVolumes()
/*++

Routine Description:

    Enumerate all known volumes and register for the notifications on these volumes

Arguments:

    None

Return Value:

    None

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDiDetail = NULL;

    DWORD                       dwError = ERROR_SUCCESS;
    DWORD                       count;
    DWORD                       sizeDiDetail;

    LONG                        oldValue;

    BOOL                        result;

    HDEVINFO                    hdevInfo;

    SP_DEVICE_INTERFACE_DATA    devInterfaceData;
    SP_DEVINFO_DATA             devInfoData;

    //
    // If this routine is currently running, the old value will be 1.  If so,
    // we don't need to run again.  This call will set the flag to 1 if it is 0.
    //

    oldValue = InterlockedCompareExchange( &VolumeListUpdateInProcess,
                                           1, 
                                           0 );
                                             
    if ( 1 == oldValue ) {
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] AddVolumes: Volume list update in process, skipping update \n" );
        goto FnExit;
    }

    //
    // Get a device interface set which includes all volume devices
    // present on the machine. VolumeClassGuid is a predefined GUID that
    // will return all volume-type device interfaces
    //
    
    hdevInfo = SetupDiGetClassDevs( &VolumeClassGuid,
                                    NULL,
                                    NULL,
                                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );

    if ( !hdevInfo ) {
        dwError = GetLastError();
        goto FnExit;
    }
    
    ZeroMemory( &devInterfaceData, sizeof( SP_DEVICE_INTERFACE_DATA) );
    
    //
    // Iterate over all devices interfaces in the set
    //
    
    for ( count = 0; ; count++ ) {

        // must set size first
        devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA); 

        //
        // Retrieve the device interface data for each device interface
        //
        
        result = SetupDiEnumDeviceInterfaces( hdevInfo,
                                              NULL,
                                              &VolumeClassGuid,
                                              count,
                                              &devInterfaceData );

        if ( !result ) {
            
            //
            // If we retrieved the last item, break
            //
            
            dwError = GetLastError();

            if ( ERROR_NO_MORE_ITEMS == dwError ) {
                dwError = ERROR_SUCCESS;
                break;
            
            } 
            
            // 
            // Some other error occurred.  Stop processing.
            //
            
            goto FnExit;
        }

        //
        // Get the required buffer-size for the device path.  Note that
        // this call is expected to fail with insufficient buffer error.
        //
        
        result = SetupDiGetDeviceInterfaceDetail( hdevInfo,
                                                  &devInterfaceData,
                                                  NULL,
                                                  0,
                                                  &sizeDiDetail,
                                                  NULL
                                                  );

        if ( !result ) {

            dwError = GetLastError();
            
            //
            // If a value other than "insufficient buffer" is returned,
            // we have to skip this device.
            //
            
            if ( ERROR_INSUFFICIENT_BUFFER != dwError ) {
                continue;
            }
        
        } else {
            
            //
            // The call should have failed since we're getting the
            // required buffer size.  If it doesn't fail, something bad
            // happened.
            //
            
            continue;
        }

        //
        // Allocate memory for the device interface detail.
        //
        
        pDiDetail = LocalAlloc( LPTR, sizeDiDetail );

        if ( !pDiDetail ) {
            dwError = GetLastError();
            goto FnExit;
        }

        // must set the struct's size member
        
        pDiDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Finally, retrieve the device interface detail info.
        //
        
        result = SetupDiGetDeviceInterfaceDetail( hdevInfo,
                                                  &devInterfaceData,
                                                  pDiDetail,
                                                  sizeDiDetail,
                                                  NULL,
                                                  &devInfoData
                                                  );
        
        if ( !result ) {
            
            dwError = GetLastError();

            //
            // Shouldn't fail, if it does, try the next device.
            //            
            
            continue;
        }

#if DBG
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] AddVolumes: Found volume %1!ws! \n", 
             pDiDetail->DevicePath );
#endif

        AddVolume( pDiDetail->DevicePath );
            
        LocalFree( pDiDetail );
        pDiDetail = NULL;
        
    }
    
FnExit:

    //
    // If old update value was zero, then it is now 1.  Reset it to
    // zero so another update can take place if needed.
    //
    
    if ( 0 == oldValue ) {
        InterlockedExchange( &VolumeListUpdateInProcess, 0 );
    }
    
    if ( pDiDetail ) {
        LocalFree( pDiDetail );
    }
    
#if DBG
    if ( ERROR_SUCCESS != dwError ) {
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] AddVolumes: returns error %1!d! \n", 
             dwError );
    }
#endif

}   // AddVolumes


DWORD
GetVolumeInfo(
    PVOLUME Vol,
    PHANDLE FileHandle
    )
/*++

Routine Description:

    Get drive layout info and partition info for the specified volume.
    
Arguments:

    Vol - Pointer to PVOLUME structure.  Caller is responsible for allocating
          and freeing.
          
    FileHandle - Returned handle to volume.  Caller is responsible for closing.
                 This parameter is optional.  If not specified by the user, 
                 the volume handle will be closed by this routine.

Return Value:

    Win32 error value.

--*/
{
    PARTITION_INFORMATION partInfo;
    PDRIVE_LAYOUT_INFORMATION driveLayout;

    DWORD status = ERROR_SUCCESS;
    DWORD bytesReturned;
    NTSTATUS ntStatus;

    HANDLE hFile = NULL;

    BOOL success;

    //
    // If no VOL parameter specified or the signature is already set,
    // we don't need to update the volume information.
    //
    if ( !Vol || Vol->Signature ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    if ( FileHandle ) {
        *FileHandle = INVALID_HANDLE_VALUE;
    }

    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] GetVolumeInfo: Updating info for %1!s!\n", Vol->Name );
    
    ntStatus = DevfileOpen(&hFile, Vol->Name);
    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            RESOURCE_TYPE,
            LOG_ERROR,
            L"[PnP] GetVolumeInfo: error opening %1!ws!, error %2!X!.\n",
            Vol->Name, ntStatus);
        
        return RtlNtStatusToDosError(ntStatus);
    }
    
    success = DeviceIoControl( hFile,
                               IOCTL_DISK_GET_PARTITION_INFO,
                               NULL,
                               0,
                               &partInfo,
                               sizeof(PARTITION_INFORMATION),
                               &bytesReturned,
                               FALSE );

    if (!success) {

        status = GetLastError();

        // Change this from LOG_ERROR to LOG_WARNING.  This thread gets
        // notified when non-fixed disks arrive (i.e. floppy), so logging
        // an error for a floppy disk is misleading.
        
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_WARNING,
            L"[PnP] GetVolumeInfo: GetPartitionInfo(%1!ws!), error %2!u!\n",
            Vol->Name, status);
        
        goto FnExit;
    }

    Vol->PartOffset = partInfo.StartingOffset;
    Vol->PartLength = partInfo.PartitionLength;
    Vol->PartNo     = partInfo.PartitionNumber;
    Vol->PartitionType = partInfo.PartitionType;

    success = ClRtlGetDriveLayoutTable(hFile, &driveLayout, 0);

    if ( !success ) {
        
        status = GetLastError();
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_WARNING,
            L"[PnP] GetVolumeInfo: GetDriveLayout(%1!ws!) error %2!u!\n",
            Vol->Name, 
            status );
        
        goto FnExit;
    }

    Vol->Signature = driveLayout->Signature;

    LocalFree(driveLayout);

    GetAssignedLetter(Vol->Name, &Vol->DriveLetter);

FnExit:

    if ( FileHandle ) {
        *FileHandle = hFile;
    } else {
        DevfileClose( hFile );
    }
    
    return status;
    
}   // UpdateVolumeInfo


DWORD
NotificationWatcherThread(
    IN LPVOID unused
    )

/*++

Routine Description:

    Creates window. Process messages until WM_QUIT is received

Arguments:

    unused

Return Value:

    status

--*/

{
    WNDCLASSEX cl;
    ATOM classAtom;
    DWORD status = ERROR_SUCCESS;
    static WCHAR* clsname = L"RESDLL!DISKS!MESSAGEWND";
    HDEVNOTIFY devNotify = 0;
    MSG msg;

    try {
        
        SetErrorMode(SEM_FAILCRITICALERRORS);
        InitializeListHead( &VolumeList );
        InitializeListHead( &WaitingDisks );
    
        ZeroMemory( &cl, sizeof(cl) );
        
        cl.cbSize = sizeof(cl); 
        cl.lpfnWndProc = TestWndProc; 
        cl.lpszClassName = clsname; 
    
        classAtom = RegisterClassEx( &cl );
        if (classAtom == 0) {
            status = GetLastError();
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_ERROR,
                 L"[PnP] Failed to register window class, error %1!u!.\n", status );
            return status;
        }
    
        DummyWindow = CreateWindowEx(
            0,            // extended window style
            clsname,    // pointer to registered class name
            L"ClusterDiskPnPWatcher",// pointer to window name
            0,            // window style
            0,            // horizontal position of window
            0,            // vertical position of window
            0,            // window width
            0,            // window height
            HWND_MESSAGE, // handle to parent or owner window
            0,            // handle to menu, or child-window identifier
            0,            // handle to application instance (ignored on NT)
            NULL          // pointer to window-creation data
        );
        if (DummyWindow == 0) {
            status = GetLastError();
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_ERROR,
                 L"[PnP] Failed to create message window, error %u.\n", status );
            UnregisterClass( clsname , 0);
            return status;
        }
        
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] PnP window created successfully.\n");
        
        //
        // Call AddVolumes after registering for device arrival notification.
        // 
        status = RegisterDeviceInterface(DummyWindow, &MOUNTDEV_MOUNTED_DEVICE_GUID, &devNotify);
        AddVolumes();
        
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] PnP interface registration complete.\n");

        if ( NULL != PnpInterfacesRegistered ) {
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] Setting PnP interface registration event.\n");
            SetEvent( PnpInterfacesRegistered );
        }

        if (status == ERROR_SUCCESS) {
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] NotifierThread is waiting for messages.\n");
            while(GetMessage(&msg, 0, 0, 0)) { 
                if (msg.message == WM_QUIT) {
                    break;
                }
                DispatchMessage(&msg); 
            }
            MyUnregisterDeviceNotification( devNotify );
#if 0
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] NotifierThread is shutting down.\n");
#endif
        } else {
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_ERROR,
                 L"[PnP] Unable to register for MOUNTDEV_MOUNTED_DEVICE_GUID, error %1!u!.\n", status );
        }
    
        DestroyWindow( DummyWindow );
        DummyWindow = 0;
        UnregisterClass( clsname , 0 );
    
        // Use a lock here as the online thread might be parsing the volume list.
        AcquireExclusive( &PnpVolumeLock );
        while ( !IsListEmpty(&VolumeList) ) {
            PLIST_ENTRY listEntry;
            PVOLUME vol;
            listEntry = RemoveHeadList(&VolumeList);
            vol = CONTAINING_RECORD( listEntry,
                                     VOLUME,
                                     ListEntry );
            DestroyVolume(vol);
        }
        ReleaseExclusive( &PnpVolumeLock );
#if 0
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] PnpThread: Volumes destroyed.\n");
#endif
    
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // We can leave without this thread
        //
        status = GetExceptionCode();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] PnpThread: Exception caught, error %1!u!.\n", status );
    }

    InterlockedCompareExchange(&PnPInitialized, FALSE, TRUE);
    return status;
} 


VOID
ProcessMountPointChange( 
    HDEVNOTIFY devNotify 
    )
/*++

Routine Description:

    Updates mount point info in the cluster registry.

Arguments:

    devNotify - Handle to the device notification.  

Return Value:

    None

--*/
{
    PDISK_RESOURCE resourceEntry;
    PVOLUME vol;
    INT idx;
    
    //
    // Get the volume for the device notification.
    //
                    
    vol = FindVolume( devNotify );
    
    if ( !vol ) {
        
        (DiskpLogEvent)(
            RESOURCE_TYPE, 
            LOG_INFORMATION,
            L"[PnP] ProcessMountPointChange: devNotify %1!d! is not in the list \n", 
            devNotify );
        return;
    }
    
    //
    // Search the WatchedDiskTable to find a disk that matches the signature.  
    // The return value is the index into the WatchedDiskTable.
    //
    
    idx = FindDisk( vol->Signature );
    if ( idx == -1 ) {
        (DiskpLogEvent)(
            RESOURCE_TYPE, 
            LOG_INFORMATION,
            L"[PnP] ProcessMountPointChange: Unable to find disk for signature %1!x! \n", 
            vol->Signature );
        return;
    }

    //
    // Get the ResourceEntry for the disk.
    //
    
    resourceEntry = WatchedDiskTable[idx];

    if ( !resourceEntry ) {
        
        (DiskpLogEvent)(
            RESOURCE_TYPE,
            LOG_ERROR,
            L"[PnP] ProcessMountPointChange: Unable to get ResourceEntry for signature %1!x! \n",
            vol->Signature );
        return;
    }

    DisksUpdateMPList( resourceEntry );

}   // ProcessMountPointChange



//////////////////////////////////////////////////////////////////////////////////



DWORD
QueueWaitForVolumeEvent(
    HANDLE Event,
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Queues a request to watch for particular volume arrivals.
    The event will be signaled only when all volumes are 
    available on the system.

Arguments:

    Event - event to be signaled when all volumes for the specified
            disk are available.
    
    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

Return Value:

    ERROR_SUCCESS - request queued.
                               
    Win32 error on failure.

--*/
{
    PWAITING_DISK   waitDisk;
    PMOUNTIE_VOLUME mountVol = ResourceEntry->MountieInfo.Volume;
    
    DWORD   dwError = ERROR_SUCCESS;
    
    waitDisk = LocalAlloc( LPTR, sizeof(WAITING_DISK) );
    
    if ( !waitDisk ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_ERROR,
             L"[PnP] QueueWaitForVolumeEvent: can't allocate storage for disk entry. Error %1!u! \n",
             dwError );
        goto FnExit;
    }

    waitDisk->ResourceEntry = ResourceEntry;
    waitDisk->Event = Event;
    waitDisk->Signature = mountVol->Signature;
    waitDisk->PartitionCount = mountVol->PartitionCount;
    
    AcquireExclusive( &PnpWaitingListLock );
    InsertHeadList( &WaitingDisks, &waitDisk->ListEntry );
    ReleaseExclusive( &PnpWaitingListLock );

FnExit:

    return dwError;    

}   // QueueWaitForVolumeEvent


BOOL
IsDiskInPnpVolumeList(
    PDISK_RESOURCE ResourceEntry,
    BOOL UpdateVolumeList
    )
/*++

Routine Description:
    
    Checks all the volumes currently known by the PnP thread and see if
    all volumes for the specified disk are recognized.

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.
    
    UpdateVolumeList - TRUE means call AddVolumes to make sure all volumes
                       are in the volume list.

Return Value:

    TRUE - If all volumes for the specified disk are available on the system.

--*/
{
    PLIST_ENTRY entry;
    PVOLUME vol = 0;
    PMOUNTIE_VOLUME mountVol = ResourceEntry->MountieInfo.Volume;

    DWORD partitionCount = 0;

    BOOL retVal = FALSE;

    if ( UpdateVolumeList ) {
        
        //
        // This call shouldn't be required.  However, sometimes we can't find 
        // find volumes that should be available.  So we need to walk through
        // the pnp list again.
        //
        AddVolumes();
    }

    AcquireExclusive( &PnpVolumeLock );
        
    for ( entry = VolumeList.Flink;
          entry != &VolumeList;
          entry = entry->Flink
        )
    {
        vol = CONTAINING_RECORD(
                   entry,
                   VOLUME,
                   ListEntry
                   );

        GetVolumeInfo( vol, NULL );
        
        if ( vol->Signature == mountVol->Signature ) {
            partitionCount++;
        }
    }

    ReleaseExclusive( &PnpVolumeLock );

    //    
    // Might be some non-NTFS partitions on the disk, so if there
    // are more volumes than partitions, we are good.
    //
    
    return ( ( partitionCount >= mountVol->PartitionCount ) ? TRUE : FALSE ) ;
    
}   // IsDiskInPnpVolumeList


PWAITING_DISK
FindWaitingDisk(
    DWORD Signature
    )
/*++

Routine Description:

    Find the entry in the waiting list for the specified disk
    signature.  
    
    The caller will hold the critical section.

Arguments:

    Signature - Disk signature of the entry to be removed.

Return Value:

    Pointer to a WAITING_DISK entry for the disk.
    
    NULL if entry not found.
    
--*/
{
    PLIST_ENTRY entry;
    PWAITING_DISK waitDisk = NULL;

    if ( !Signature ) {
        goto FnExit;
    }
    
    for ( entry = WaitingDisks.Flink;
          entry != &WaitingDisks;
          entry = entry->Flink
        )
    {
        waitDisk = CONTAINING_RECORD( entry,
                                      WAITING_DISK,
                                      ListEntry
                                      );

        if ( waitDisk->Signature == Signature ) {
            goto FnExit;
        }
        
        waitDisk = 0;
    }

FnExit:

    return waitDisk;
    
}   // FindWaitingDisk


DWORD
RemoveWaitForVolumeEvent(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Remove from the disk waiting list the entry for the specified disk.

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

Return Value:


--*/
{
    PWAITING_DISK   waitDisk = NULL;
    PMOUNTIE_VOLUME mountVol = ResourceEntry->MountieInfo.Volume;

    AcquireExclusive( &PnpWaitingListLock );

    waitDisk = FindWaitingDisk( mountVol->Signature );

    if ( !waitDisk ) {
        (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_INFORMATION,
             L"[PnP] RemoveWaitForVolumeEvent: can't locate waiting volume in list \n" );
        ReleaseExclusive( &PnpWaitingListLock );
        return ERROR_INVALID_PARAMETER;
    }
    
    RemoveEntryList( &waitDisk->ListEntry );
    ReleaseExclusive( &PnpWaitingListLock );
    
    LocalFree( waitDisk );

    return ERROR_SUCCESS;
    
}   // RemoveWaitForVolumeEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\scsi.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    scsi.c

Abstract:

    Common routines for dealing with SCSI disks, usable
    by both raw disks and FT sets

Author:

    John Vert (jvert) 11/6/1996

Revision History:

--*/

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddstor.h>   // IOCTL_STORAGE_QUERY_PROPERTY

#include "disksp.h"
#include "newmount.h"
#include <string.h>
#include <shlwapi.h>    // SHDeleteKey
#include <ntddvol.h>    // IOCTL_VOLUME_QUERY_FAILOVER_SET  
#include <setupapi.h>

//
// The registry key containing the system partition
//
const CHAR DISKS_REGKEY_SETUP[]              = "SYSTEM\\SETUP";
const CHAR DISKS_REGVALUE_SYSTEM_PARTITION[] = "SystemPartition";

extern PWCHAR DEVICE_HARDDISK_PARTITION_FMT; // L"\\Device\\Harddisk%u\\Partition%u" //
extern PWCHAR GLOBALROOT_HARDDISK_PARTITION_FMT; // L"\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition%u\\"

extern DWORD                SystemDiskAddressFound;
extern PSCSI_ADDRESS_ENTRY  SysDiskAddrList;

#define INVALID_SCSIADDRESS_VALUE   (DWORD)-1

typedef struct _SCSI_PASS_THROUGH_WITH_SENSE {
    SCSI_PASS_THROUGH Spt;
    UCHAR   SenseBuf[32];
} SCSI_PASS_THROUGH_WITH_SENSE, *PSCSI_PASS_THROUGH_WITH_SENSE;


typedef struct _UPDATE_AVAIL_DISKS {
    HKEY    AvailDisksKey;
    HKEY    SigKey;
    DWORD   EnableSanBoot;
    BOOL    SigKeyIsEmpty;
} UPDATE_AVAIL_DISKS, *PUPDATE_AVAIL_DISKS;

typedef struct _SCSI_INFO {
    DWORD   Signature;
    DWORD   DiskNumber;
    DWORD   ScsiAddress;
} SCSI_INFO, *PSCSI_INFO;

typedef struct _SERIAL_INFO {
    DWORD   Signature;
    DWORD   Error;
    LPWSTR  SerialNumber;
} SERIAL_INFO, *PSERIAL_INFO;

typedef
DWORD
(*LPDISK_ENUM_CALLBACK) (
    HANDLE DeviceHandle,
    DWORD Index,
    PVOID Param1
    );
    
//
// Local Routines
//


DWORD
AddSignatureToRegistry(
    HKEY RegKey,
    DWORD Signature
    );

BOOL
IsClusterCapable(
    IN DWORD Signature
    );

BOOL
IsSignatureInRegistry(
    HKEY RegKey,
    DWORD Signature
    );

DWORD
UpdateAvailableDisks(
    );

DWORD
UpdateAvailableDisksCallback(
    HANDLE DeviceHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
AddScsiAddressToList(
    PSCSI_ADDRESS ScsiAddress
    );

DWORD
GetVolumeFailoverSet(
    IN HANDLE DevHandle,
    OUT PVOLUME_FAILOVER_SET *FailoverSet
    );

DWORD
BuildScsiListFromFailover(
    IN HANDLE DevHandle
    );

HANDLE
OpenNtldrDisk(
    );

HANDLE
OpenOSDisk(
    );

DWORD
EnumerateDisks(
    LPDISK_ENUM_CALLBACK DiskEnumCallback,
    PVOID Param1
    );

DWORD
GetScsiAddressCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
GetSerialNumberCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
GetSigFromSerNumCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
RetrieveSerialNumber(
    HANDLE DevHandle,
    LPWSTR *SerialNumber
    );



DWORD
ScsiIsAlive(
    IN HANDLE DiskHandle
    )
/*++

Routine Description:

    Sends a SCSI passthrough command down to the disk to see if
    it is still there.

Arguments:

    DiskHandle - Supplies a handle to the disk.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    BOOL success;
    DWORD bytesReturned;

    success = DeviceIoControl( DiskHandle,
                               IOCTL_DISK_CLUSTER_ALIVE_CHECK,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if ( !success ) {
        return(GetLastError());
    }
    return(ERROR_SUCCESS);

}


DWORD
ClusDiskGetAvailableDisks(
    OUT PVOID OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned,
    IN BOOL  FtSet
    )

/*++

Routine Description:

    Enumerate and build a list of available disks on this system.

Arguments:

    OutBuffer - pointer to the output buffer to return the data.

    OutBufferSize - size of the output buffer.

    BytesReturned - the actual number of bytes that were returned (or
                the number of bytes that should have been returned if
                OutBufferSize is too small).

    FtSet - TRUE if FT Set info wanted, FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD   status;
    HKEY    resKey;
    DWORD   ival;
    DWORD   signature;
    DWORD   bytesReturned = 0;
    DWORD   totalBytesReturned = 0;
    DWORD   dataLength;
    DWORD   outBufferSize = OutBufferSize;
    PVOID   ptrBuffer = OutBuffer;
    CHAR    signatureName[9];
    PCLUSPROP_SYNTAX ptrSyntax;

    //
    // Make sure the AvailableDisks key is current.
    //
    
    UpdateAvailableDisks();
    
    *BytesReturned = 0;

    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           CLUSDISK_REGISTRY_AVAILABLE_DISKS,
                           0,
                           KEY_READ,
                           &resKey );

    if ( status != ERROR_SUCCESS ) {

        // If the key wasn't found, return an empty list.
        if ( status == ERROR_FILE_NOT_FOUND ) {

            // Add the endmark.
            bytesReturned += sizeof(CLUSPROP_SYNTAX);
            if ( bytesReturned <= outBufferSize ) {
                ptrSyntax = ptrBuffer;
                ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                ptrSyntax++;
                ptrBuffer = ptrSyntax;
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }

            *BytesReturned = bytesReturned;
        }
        // We can't log an error, we have no resource handle!
        return(status);
    }

    totalBytesReturned = bytesReturned;
    bytesReturned = 0;

    for ( ival = 0; ; ival++ ) {
        dataLength = sizeof(signatureName);
        status = RegEnumKey( resKey,
                             ival,
                             signatureName,
                             dataLength );
        if ( status == ERROR_NO_MORE_ITEMS ) {
            status = ERROR_SUCCESS;
            break;
        } else if ( status != ERROR_SUCCESS ) {
            break;
        }

        dataLength = sscanf( signatureName, "%x", &signature );
        if ( dataLength != 1 ) {
            status = ERROR_INVALID_DATA;
            break;
        }

        //
        // If not cluster capable, then skip it.
        //
        if ( !IsClusterCapable(signature) ) {
            continue;
        }

        GetDiskInfo( signature,
                     &ptrBuffer,
                     outBufferSize,
                     &bytesReturned,
                     FtSet );
        if ( outBufferSize > bytesReturned ) {
            outBufferSize -= bytesReturned;
        } else {
            outBufferSize = 0;
        }
        totalBytesReturned += bytesReturned;
        bytesReturned = 0;
    }

    RegCloseKey( resKey );

    bytesReturned = totalBytesReturned;

    // Add the endmark.
    bytesReturned += sizeof(CLUSPROP_SYNTAX);
    if ( bytesReturned <= outBufferSize ) {
        ptrSyntax = ptrBuffer;
        ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
        ptrSyntax++;
        ptrBuffer = ptrSyntax;
    }

    if ( bytesReturned > OutBufferSize ) {
        status = ERROR_MORE_DATA;
    }

    *BytesReturned = bytesReturned;

    return(status);

} // ClusDiskGetAvailableDisks



DWORD
GetScsiAddress(
    IN DWORD Signature,
    OUT LPDWORD ScsiAddress,
    OUT LPDWORD DiskNumber
    )

/*++

Routine Description:

    Find the SCSI addressing for a given signature.

Arguments:

    Signature - the signature to find.

    ScsiAddress - pointer to a DWORD to return the SCSI address information.

    DiskNumber - the disk number associated with the signature.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD       dwError;
    
    SCSI_INFO   scsiInfo;
    
    ZeroMemory( &scsiInfo, sizeof(scsiInfo) );
    
    scsiInfo.Signature = Signature;
    
    dwError = EnumerateDisks( GetScsiAddressCallback, &scsiInfo );

    //
    // If the SCSI address was not set, we know the disk was not found.
    //
    
    if ( INVALID_SCSIADDRESS_VALUE == scsiInfo.ScsiAddress ) {
        dwError = ERROR_FILE_NOT_FOUND;
        goto FnExit;
    }
    
    //
    // The callback routine will use ERROR_POPUP_ALREADY_ACTIVE to stop
    // the disk enumeration.  Reset the value to success if that special
    // value is returned.
    //
    
    if ( ERROR_POPUP_ALREADY_ACTIVE == dwError ) {
        dwError = ERROR_SUCCESS;
    }

    *ScsiAddress    = scsiInfo.ScsiAddress;
    *DiskNumber     = scsiInfo.DiskNumber;

FnExit:
    
    return dwError;
    
}   // GetScsiAddress


DWORD
GetScsiAddressCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    )
/*++

Routine Description:

    Find the SCSI address and disk number for a given signature.

Arguments:

    DevHandle - open handle to a physical disk.  Do not close
                the handle on exit.
                
    Index - current disk count.  Not used.
    
    Param1 - pointer to PSCSI_INFO structure.
                    
Return Value:

    ERROR_SUCCESS to continue disk enumeration.
    
    ERROR_POPUP_ALREADY_ACTIVE to stop disk enumeration.  This 
    value will be changed to ERROR_SUCCESS by GetScsiAddress.

--*/
{
    PSCSI_INFO scsiInfo = Param1;

    PDRIVE_LAYOUT_INFORMATION driveLayout = NULL;

    // Always return success to keep enumerating disks.  Any
    // error value will stop the disk enumeration.
    
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   bytesReturned;
    
    BOOL    success;
    
    SCSI_ADDRESS            scsiAddress;
    STORAGE_DEVICE_NUMBER   deviceNumber;
    CLUSPROP_SCSI_ADDRESS   clusScsiAddress;

    scsiInfo->ScsiAddress = INVALID_SCSIADDRESS_VALUE;

    success = ClRtlGetDriveLayoutTable( DevHandle,
                                        &driveLayout,
                                        NULL );
    
    if ( !success || !driveLayout || 
         ( driveLayout->Signature != scsiInfo->Signature ) ) {
        goto FnExit;
    }

    //
    // We have a signature match.  Now get the scsi address.
    //

    ZeroMemory( &scsiAddress, sizeof(scsiAddress) );        
    success = DeviceIoControl( DevHandle,
                               IOCTL_SCSI_GET_ADDRESS,
                               NULL,
                               0,
                               &scsiAddress,
                               sizeof(scsiAddress),
                               &bytesReturned,
                               FALSE );

    if ( !success ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Get the disk number.
    //

    ZeroMemory( &deviceNumber, sizeof(deviceNumber) );

    success = DeviceIoControl( DevHandle,
                               IOCTL_STORAGE_GET_DEVICE_NUMBER,
                               NULL,
                               0,
                               &deviceNumber,
                               sizeof(deviceNumber),
                               &bytesReturned,
                               NULL );
                           
    if ( !success ) {
        dwError = GetLastError();
        goto FnExit;
    }

    clusScsiAddress.PortNumber  = scsiAddress.PortNumber;
    clusScsiAddress.PathId      = scsiAddress.PathId;
    clusScsiAddress.TargetId    = scsiAddress.TargetId;
    clusScsiAddress.Lun         = scsiAddress.Lun;
    
    scsiInfo->ScsiAddress   = clusScsiAddress.dw;
    scsiInfo->DiskNumber    = deviceNumber.DeviceNumber;
    
    dwError = ERROR_POPUP_ALREADY_ACTIVE;
    
FnExit:

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }
    
    return dwError;

} // GetScsiAddressCallback



BOOL
IsClusterCapable(
    IN DWORD Signature
    )

/*++

Routine Description:

    Check if the device is cluster capable. If this function cannot read
    the disk information, then it will assume that the device is cluster
    capable!

Arguments:

    Signature - the signature to find.

Return Value:

    TRUE if the device is cluster capable, FALSE otherwise.

Notes:

    On failures... we err on the side of being cluster capable.

--*/

{
    NTSTATUS        ntStatus;
    HANDLE          fileHandle;
    ANSI_STRING     objName;
    UNICODE_STRING  unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOL            success;
    DWORD           bytesReturned;
    PWCHAR          clusDiskControlDevice = L"\\Device\\ClusDisk0";

    RtlInitUnicodeString( &unicodeName, clusDiskControlDevice );

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    if ( !NT_SUCCESS(ntStatus) ) {
        return(TRUE);
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE,
                               &Signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    NtClose( fileHandle );

    return(!success);

} // IsClusterCapable



DWORD
GetDiskInfo(
    IN DWORD  Signature,
    OUT PVOID *OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned,
    IN BOOL   FtSet
    )

/*++

Routine Description:

    Gets all of the disk information for a given signature.

Arguments:

    Signature - the signature of the disk to return info.

    OutBuffer - pointer to the output buffer to return the data.

    OutBufferSize - size of the output buffer.

    BytesReturned - the actual number of bytes that were returned (or
                the number of bytes that should have been returned if
                OutBufferSize is too small).

    FtSet - TRUE if FT Set info wanted, FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD   status;
    DWORD   bytesReturned = *BytesReturned;
    PVOID   ptrBuffer = *OutBuffer;
    PCLUSPROP_DWORD ptrDword;
    PCLUSPROP_SCSI_ADDRESS ptrScsiAddress;
    PCLUSPROP_DISK_NUMBER ptrDiskNumber;
    PCLUSPROP_PARTITION_INFO ptrPartitionInfo;
    PCLUSPROP_SZ ptrSerialNumber;
    DWORD   cbSzSize;
    DWORD   cbDataSize;
    DWORD   scsiAddress;
    DWORD   diskNumber;

    NTSTATUS    ntStatus;
    CHAR        driveLetter;
    DWORD       i;
    MOUNTIE_INFO mountieInfo;
    PMOUNTIE_PARTITION entry;
    PWCHAR  serialNumber = NULL;
    
    WCHAR szDiskPartName[MAX_PATH];
    WCHAR szGlobalDiskPartName[MAX_PATH];

    LONGLONG    llCurrentMinUsablePartLength = 0x7FFFFFFFFFFFFFFF;
    PCLUSPROP_PARTITION_INFO ptrMinUsablePartitionInfo = NULL;

    // Return the signature - a DWORD
    bytesReturned += sizeof(CLUSPROP_DWORD);
    if ( bytesReturned <= OutBufferSize ) {
        ptrDword = ptrBuffer;
        ptrDword->Syntax.dw = CLUSPROP_SYNTAX_DISK_SIGNATURE;
        ptrDword->cbLength = sizeof(DWORD);
        ptrDword->dw = Signature;
        ptrDword++;
        ptrBuffer = ptrDword;
    }
                              
    // Return the SCSI_ADDRESS - a DWORD
    status = GetScsiAddress( Signature,
                             &scsiAddress,
                             &diskNumber );

    if ( status == ERROR_SUCCESS ) {
        bytesReturned += sizeof(CLUSPROP_SCSI_ADDRESS);
        if ( bytesReturned <= OutBufferSize ) {
            ptrScsiAddress = ptrBuffer;
            ptrScsiAddress->Syntax.dw = CLUSPROP_SYNTAX_SCSI_ADDRESS;
            ptrScsiAddress->cbLength = sizeof(DWORD);
            ptrScsiAddress->dw = scsiAddress;
            ptrScsiAddress++;
            ptrBuffer = ptrScsiAddress;
        }

        // Return the DISK NUMBER - a DWORD
        bytesReturned += sizeof(CLUSPROP_DISK_NUMBER);
        if ( bytesReturned <= OutBufferSize ) {
            ptrDiskNumber = ptrBuffer;
            ptrDiskNumber->Syntax.dw = CLUSPROP_SYNTAX_DISK_NUMBER;
            ptrDiskNumber->cbLength = sizeof(DWORD);
            ptrDiskNumber->dw = diskNumber;
            ptrDiskNumber++;
            ptrBuffer = ptrDiskNumber;
        }
    } else {
        return( status);
    }

    // Get the disk serial number.
    
    status = GetSerialNumber( Signature, 
                              &serialNumber );

    if ( ERROR_SUCCESS == status && serialNumber ) {
        
        cbSzSize = (wcslen( serialNumber ) + 1) * sizeof(WCHAR);
        cbDataSize = sizeof(CLUSPROP_SZ) + ALIGN_CLUSPROP( cbSzSize );  
        
        bytesReturned += cbDataSize;
        
        if ( bytesReturned <= OutBufferSize ) {
            ptrSerialNumber = ptrBuffer;
            ZeroMemory( ptrSerialNumber, cbDataSize );
            ptrSerialNumber->Syntax.dw = CLUSPROP_SYNTAX_DISK_SERIALNUMBER;
            ptrSerialNumber->cbLength = cbSzSize;
            wcsncpy( ptrSerialNumber->sz, serialNumber, wcslen(serialNumber) );
            ptrBuffer = (PCHAR)ptrBuffer + cbDataSize;
        }
        
        if ( serialNumber ) {
            LocalFree( serialNumber );
        }
    }

    // Get all the valid partitions on the disk.  We must free the 
    // volume info structure later.

    status = MountieFindPartitionsForDisk( diskNumber,
                                           &mountieInfo
                                           );

    if ( ERROR_SUCCESS == status ) {

        // For each partition, build a Property List.

        for ( i = 0; i < MountiePartitionCount( &mountieInfo ); ++i ) {

            entry = MountiePartition( &mountieInfo, i );

            if ( !entry ) {
                break;
            }

            // Always update the bytesReturned, even if there is more data than the
            // caller requested.  On return, the caller will see that there is more
            // data available.

            bytesReturned += sizeof(CLUSPROP_PARTITION_INFO);

            if ( bytesReturned <= OutBufferSize ) {
                ptrPartitionInfo = ptrBuffer;
                ZeroMemory( ptrPartitionInfo, sizeof(CLUSPROP_PARTITION_INFO) );
                ptrPartitionInfo->Syntax.dw = CLUSPROP_SYNTAX_PARTITION_INFO;
                ptrPartitionInfo->cbLength = sizeof(CLUSPROP_PARTITION_INFO) - sizeof(CLUSPROP_VALUE);

                // Create a name that can be used with some of our routines.
                // Don't use the drive letter as the name because we might be using
                // partitions without drive letters assigned.

                _snwprintf( szDiskPartName,
                            sizeof(szDiskPartName)/sizeof(WCHAR),
                            DEVICE_HARDDISK_PARTITION_FMT, 
                            diskNumber,
                            entry->PartitionNumber );
                            
                //
                // Create a global DiskPart name that we can use with the Win32
                // GetVolumeInformationW call.  This name must have a trailing 
                // backslash to work correctly.
                //
        
                _snwprintf( szGlobalDiskPartName,
                            sizeof(szGlobalDiskPartName)/sizeof(WCHAR),
                            GLOBALROOT_HARDDISK_PARTITION_FMT, 
                            diskNumber,
                            entry->PartitionNumber );
                
           
                // If partition has a drive letter assigned, return this info.
                // If no drive letter assigned, need a system-wide (i.e. across nodes)
                // way of identifying the device.

                ntStatus = GetAssignedLetter( szDiskPartName, &driveLetter );

                if ( NT_SUCCESS(status) && driveLetter ) {
                
                    // Return the drive letter as the device name.
    
                    _snwprintf( ptrPartitionInfo->szDeviceName,
                                sizeof(ptrPartitionInfo->szDeviceName),
                                L"%hc:",
                                driveLetter );

                    ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_STICKY;

                } else {

                    // Return a physical device name.

#if 0
                    
                    // Return string name:
                    //   Signature xxxxxxxx Partition YYY
                    
                    _snwprintf( ptrPartitionInfo->szDeviceName,
                                sizeof(ptrPartitionInfo->szDeviceName),
                                L"Signature %X Partition %u",
                                Signature,
                                entry->PartitionNumber );
#endif

                    // Return string name:
                    //   DiskXXXPartionYYY
                    
                    _snwprintf( ptrPartitionInfo->szDeviceName,
                                sizeof(ptrPartitionInfo->szDeviceName),
                                L"Disk%uPartition%u",
                                diskNumber,
                                entry->PartitionNumber );

                }

                //
                // Call GetVolumeInformationW with the GlobalName we have created.
                //
                                    
                if ( !GetVolumeInformationW ( szGlobalDiskPartName,
                                              ptrPartitionInfo->szVolumeLabel,
                                              sizeof(ptrPartitionInfo->szVolumeLabel)/sizeof(WCHAR),
                                              &ptrPartitionInfo->dwSerialNumber,
                                              &ptrPartitionInfo->rgdwMaximumComponentLength,
                                              &ptrPartitionInfo->dwFileSystemFlags,
                                              ptrPartitionInfo->szFileSystem,
                                              sizeof(ptrPartitionInfo->szFileSystem)/sizeof(WCHAR) ) ) {

                    ptrPartitionInfo->szVolumeLabel[0] = L'\0';
                
                } else if ( CompareStringW( LOCALE_INVARIANT, 
                                            NORM_IGNORECASE,
                                            ptrPartitionInfo->szFileSystem,
                                            -1,
                                            L"NTFS",
                                            -1
                                            ) == CSTR_EQUAL ) {
                    
                    // Only NTFS drives are currently supported.
                    
                    ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_USABLE;

                    //
                    //  Find the minimum size partition that is larger than MIN_QUORUM_PARTITION_LENGTH
                    //
                    if ( ( entry->PartitionLength.QuadPart >= MIN_USABLE_QUORUM_PARTITION_LENGTH ) &&
                         ( entry->PartitionLength.QuadPart < llCurrentMinUsablePartLength ) )
                    {
                        ptrMinUsablePartitionInfo = ptrPartitionInfo;
                        llCurrentMinUsablePartLength = entry->PartitionLength.QuadPart;
                    }
                }

                ptrPartitionInfo++;
                ptrBuffer = ptrPartitionInfo;
            }

        } // for

        // Free the volume information.

        MountieCleanup( &mountieInfo );
    }

    //
    //  If we managed to find a default quorum partition, change the flags to indicate this.
    //
    if ( ptrMinUsablePartitionInfo != NULL )
    {
        ptrMinUsablePartitionInfo->dwFlags |= CLUSPROP_PIFLAG_DEFAULT_QUORUM;    
    }
    
    *OutBuffer = ptrBuffer;
    *BytesReturned = bytesReturned;

    return(status);

} // GetDiskInfo




DWORD
UpdateAvailableDisks(
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    HKEY    availDisksKey;
    HKEY    sigKey;
    
    DWORD   dwError = NO_ERROR;
    DWORD   enableSanBoot;
    
    BOOL    availDisksOpened = FALSE;
    BOOL    sigKeyOpened = FALSE;
    BOOL    sigKeyIsEmpty = FALSE;

    UPDATE_AVAIL_DISKS  updateDisks;
    
    __try {

        //
        // If we haven't yet determined the system disk information, don't do anything else.
        //

        if ( !SystemDiskAddressFound ) {
             
             __leave;
        }

        enableSanBoot = 0;
        GetRegDwordValue( CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                          CLUSREG_VALUENAME_MANAGEDISKSONSYSTEMBUSES,
                          &enableSanBoot );
        
        //
        // Delete the old AvailableDisks key.  This will remove any stale information.
        //
        
        SHDeleteKey( HKEY_LOCAL_MACHINE, CLUSDISK_REGISTRY_AVAILABLE_DISKS );
            
        //
        // Open the AvailableDisks key.  If the key doesn't exist, it will be created.
        //

        dwError = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                  CLUSDISK_REGISTRY_AVAILABLE_DISKS,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_CREATE_SUB_KEY,
                                  NULL,
                                  &availDisksKey,
                                  NULL );
        
        if ( NO_ERROR != dwError) {
            __leave;
        }
        
        availDisksOpened = TRUE;
        
        //
        // Open the Signatures key.  
        //

        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                CLUSDISK_REGISTRY_SIGNATURES,
                                0,
                                KEY_READ,
                                &sigKey );

        //
        // If Signatures key does not exist, save all valid signatures 
        // in the AvailableDisks key.
        //

        if ( ERROR_FILE_NOT_FOUND == dwError ) {
            dwError = NO_ERROR;
            sigKeyIsEmpty = TRUE;
        } else if ( NO_ERROR != dwError) {
            __leave;
        } else {
            sigKeyOpened = TRUE;
        }
        
        ZeroMemory( &updateDisks, sizeof(updateDisks) );
        updateDisks.EnableSanBoot   = enableSanBoot;
        updateDisks.SigKeyIsEmpty   = sigKeyIsEmpty;
        updateDisks.SigKey          = sigKey;
        updateDisks.AvailDisksKey    = availDisksKey;
        
        EnumerateDisks( UpdateAvailableDisksCallback, &updateDisks );
    
    } __finally {
    
        if ( availDisksOpened ) {
            RegCloseKey( availDisksKey );
        }
        
        if ( sigKeyOpened ) {
            RegCloseKey( sigKey );
        }
    }

    return  dwError;

} // UpdateAvailableDisks


DWORD
UpdateAvailableDisksCallback(
    HANDLE DeviceHandle,
    DWORD Index,
    PVOID Param1
    )
{
    PDRIVE_LAYOUT_INFORMATION driveLayout = NULL;
    PUPDATE_AVAIL_DISKS       updateDisks = Param1;

    DWORD   bytesReturned;
    DWORD   enableSanBoot;

    BOOL    success;

    SCSI_ADDRESS    scsiAddress;
    
    //
    // Look at all disks on the system.  For each valid signature, add it to the
    // AvailableList if it is not already in the Signature key.
    //
    success = ClRtlGetDriveLayoutTable( DeviceHandle,
                                        &driveLayout,
                                        NULL );
        
    if ( success && driveLayout && 
         ( 0 != driveLayout->Signature ) ) {

        //
        // Get SCSI address info.
        //

        if ( DeviceIoControl( DeviceHandle,
                              IOCTL_SCSI_GET_ADDRESS,
                              NULL,
                              0,
                              &scsiAddress,
                              sizeof(scsiAddress),
                              &bytesReturned,
                              NULL ) ) {
            
            if ( !updateDisks->EnableSanBoot ) {
                
                //
                // Add signature to AvailableDisks key if:
                //  - the signature is for a disk not on system bus
                //  - the signature is not already in the Signatures key
                //

                if ( !IsDiskOnSystemBus( &scsiAddress ) &&
                     ( updateDisks->SigKeyIsEmpty || 
                       !IsSignatureInRegistry( updateDisks->SigKey, driveLayout->Signature ) ) ) {
                    
                    AddSignatureToRegistry( updateDisks->AvailDisksKey, 
                                            driveLayout->Signature );
                }

            } else {

                // Allow disks on system bus to be added to cluster.
                
                //
                // Add signature to AvailableDisks key if:
                //  - the signature is not for the system disk
                //  - the signature is not already in the Signatures key
                //

                if ( !IsDiskSystemDisk( &scsiAddress ) &&
                     ( updateDisks->SigKeyIsEmpty || 
                       !IsSignatureInRegistry( updateDisks->SigKey, driveLayout->Signature ) ) ) {
                       
                    AddSignatureToRegistry( updateDisks->AvailDisksKey, 
                                            driveLayout->Signature );
                }
            
            }

        }

    }

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }

    //
    // Always return success so all disks are enumerated.
    //
    
    return ERROR_SUCCESS;
    
}   // UpdateAvailableDisksCallback


DWORD
AddSignatureToRegistry(
    HKEY RegKey,
    DWORD Signature
    )
/*++

Routine Description:

    Add the specified disk signature to the ClusDisk registry subkey.
    The disk signatures are subkeys of the ClusDisk\Parameters\AvailableDisks
    and ClusDisk\Parameters\Signatures keys. 
    
Arguments:

    RegKey - Previously opened ClusDisk registry subkey
    
    Signature - Signature value to add 

Return Value:

    Win32 error on failure.

--*/
{
    HKEY subKey;
    DWORD dwError;
    
    CHAR signatureName[MAX_PATH];
    
    ZeroMemory( signatureName, sizeof(signatureName) );
    _snprintf( signatureName, 8, "%08X", Signature );
    
    //
    // Try and create the key.  If it exists, the existing key will be opened.
    //
    
    dwError = RegCreateKeyEx( RegKey,
                              signatureName,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &subKey,
                              NULL );

    // 
    // If the key exists, ERROR_SUCCESS is still returned.
    //
                                  
    if ( ERROR_SUCCESS == dwError ) {
        RegCloseKey( subKey );
    }

    return dwError;
    
}   // AddSignatureToRegistry


BOOL
IsSignatureInRegistry(
    HKEY RegKey,
    DWORD Signature
    )
/*++

Routine Description:

    Check if the specified disk signature is in the ClusDisk registry subkey.
    The disk signatures are subkeys of the ClusDisk\Parameters\AvailableDisks
    and ClusDisk\Parameters\Signatures keys. 
    
    On error, assume the key is in the registry so it is not recreated.

Arguments:

    RegKey - Previously opened ClusDisk registry subkey
    
    Signature - Signature value to check 

Return Value:

    TRUE - Signature is in registry

--*/
{
    DWORD   ival;
    DWORD   sig;
    DWORD   dataLength;
    DWORD   dwError;

    BOOL retVal = FALSE;

    CHAR    signatureName[9];
    
    for ( ival = 0; ; ival++ ) {
        dataLength = sizeof(signatureName);
        
        dwError = RegEnumKey( RegKey,
                              ival,
                              signatureName,
                              dataLength );
    
        // If the list is exhausted, return FALSE.
        
        if ( ERROR_NO_MORE_ITEMS == dwError ) {
            break;
        }
        
        // If some other type of error, return TRUE.
        
        if ( ERROR_SUCCESS != dwError ) {
            retVal = TRUE;
            break;
        }

        dataLength = sscanf( signatureName, "%x", &sig );
        if ( dataLength != 1 ) {
            retVal = TRUE;
            break;
        }

        // If signature is a subkey, return TRUE.
        
        if ( sig == Signature ) {
            retVal = TRUE;
            break;
        }
    }

    return retVal;

}   // IsSignatureInRegistry


VOID
GetSystemBusInfo(
    )
/*++

Routine Description:

    Need to find out where the NTLDR files reside (the "system disk") and where the
    OS files reside (the "boot disk").  We will call all these disks the "system disk".
    
    There may be more than one system disk if the disks are mirrored.  So if the NTLDR
    files are on a different disk than the OS files, and each of these disks is 
    mirrored, we could be looking at 4 different disks.
    
    Find all the system disks and save the information in a list we can look at later.
    
Arguments:

Return Value:

    None
    
--*/
{
    HANDLE  hOsDevice = INVALID_HANDLE_VALUE;
    HANDLE  hNtldrDevice = INVALID_HANDLE_VALUE;

    DWORD   dwError;

    //
    // Open the disk with the OS files on it.
    //
    
    hOsDevice = OpenOSDisk();
    
    if ( INVALID_HANDLE_VALUE == hOsDevice ) {
        goto FnExit;
    }
    
    //
    // Find all mirrored disks and add them to the SCSI address list.
    //
    
    if ( ERROR_SUCCESS != BuildScsiListFromFailover( hOsDevice ) ) {
        goto FnExit;
    }        
    
    //
    // Now find the disks with NTLDR on it.  Disk could be mirrored.
    //
    
    hNtldrDevice = OpenNtldrDisk();

    if ( INVALID_HANDLE_VALUE == hNtldrDevice ) {
        goto FnExit;
    }

    //
    // Find all mirrored disks and add them to the SCSI address list.
    //
    
    if ( ERROR_SUCCESS != BuildScsiListFromFailover( hNtldrDevice ) ) {
        goto FnExit;
    }        
    
    //
    // Indicate we went through this code one more time.
    //
    
    SystemDiskAddressFound++;
    
FnExit:

    if ( INVALID_HANDLE_VALUE != hOsDevice ) {
        CloseHandle( hOsDevice );
    }
    if ( INVALID_HANDLE_VALUE != hNtldrDevice ) {
        CloseHandle( hNtldrDevice );
    }

    return;
    
}   // GetSystemBusInfo


HANDLE
OpenOSDisk(
    )
{
    PCHAR   systemDir = NULL;
    
    HANDLE  hDevice = INVALID_HANDLE_VALUE;
    DWORD   len;

    CHAR    systemPath[] = "\\\\.\\?:";

    //
    // First find the disks with OS files.  Disk could be mirrored.
    //
    
    systemDir = LocalAlloc( LPTR, MAX_PATH );
    
    if ( !systemDir ) {
        goto FnExit;
    }
    
    len = GetSystemDirectory( systemDir,
                              MAX_PATH );

    if ( !len || len < 3 ) {
        goto FnExit;
    }

    //
    // If system path doesn't start with a drive letter, exit.
    //  c:\windows ==> c:

    if ( ':' != systemDir[1] ) {
        goto FnExit;
    }

    //
    // Stuff the drive letter in the system path.
    //
    
    systemPath[4] = systemDir[0];
        
    //
    // Now open the device.
    //

    hDevice = CreateFile( systemPath,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );

FnExit:

    if ( systemDir ) {
        LocalFree( systemDir );
    }
    
    return hDevice;
        
}   // OpenOSDisk


HANDLE
OpenNtldrDisk(
    )
{
    PSTR    systemPartition = NULL;
    
    HANDLE  hDevice = INVALID_HANDLE_VALUE;
    
    HKEY    regKey = NULL;
    
    NTSTATUS    ntStatus;
    
    DWORD   dwError;
    DWORD   cbSystemPartition;
    DWORD   cbDeviceName;
    DWORD   type = 0;

    ANSI_STRING         objName;
    UNICODE_STRING      unicodeName;
    OBJECT_ATTRIBUTES   objAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    
    // 
    // Open the reg key to find the system partition
    //
    
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,    // hKey
                            DISKS_REGKEY_SETUP,    // lpSubKey
                            0,                     // ulOptions--Reserved, must be 0
                            KEY_READ,              // samDesired
                            &regKey                // phkResult    
                            );
                             
    if ( ERROR_SUCCESS != dwError ) {
        goto FnExit;
    }

    //
    // Allocate a reasonably sized buffer for the system partition, to
    // start off with.  If this isn't big enough, we'll re-allocate as
    // needed.
    //
    
    cbSystemPartition = MAX_PATH + 1;
    systemPartition = LocalAlloc( LPTR, cbSystemPartition );

    if ( !systemPartition ) {
        goto FnExit;
    }
    
    // 
    // Get the system partition device Name. This is of the form
    //      \Device\Harddisk0\Partition1                (basic disks)
    //      \Device\HarddiskDmVolumes\DgName\Volume1    (dynamic disks)
    //
    
    dwError = RegQueryValueEx( regKey,
                               DISKS_REGVALUE_SYSTEM_PARTITION,
                               NULL,
                               &type,
                               (LPBYTE)systemPartition,
                               &cbSystemPartition        // \0 is included
                               );

    while ( ERROR_MORE_DATA == dwError ) {
        
        //
        // Our buffer wasn't big enough, cbSystemPartition contains 
        // the required size.
        //
        
        LocalFree( systemPartition );
        systemPartition = NULL;
        
        systemPartition = LocalAlloc( LPTR, cbSystemPartition );
    
        if ( !systemPartition ) {
            goto FnExit;
        }

        dwError = RegQueryValueEx( regKey,
                                   DISKS_REGVALUE_SYSTEM_PARTITION,
                                   NULL,
                                   &type,
                                   (LPBYTE)systemPartition,
                                   &cbSystemPartition        // \0 is included
                                   );
    }


    RtlInitString( &objName, systemPartition );
    ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                             &objName,
                                             TRUE );
    
    if ( !NT_SUCCESS(ntStatus) ) {
        goto FnExit;
    }
    
    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
                                
    ntStatus = NtCreateFile( &hDevice,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );
    
    RtlFreeUnicodeString( &unicodeName );
                         
FnExit:

    if ( regKey ) {
        RegCloseKey( regKey );
    }
    
    if ( systemPartition ) {
        LocalFree( systemPartition );
    }
    
    return hDevice;

}   // OpenNtldrDisk


DWORD
BuildScsiListFromFailover(
    IN HANDLE DevHandle
    )
{
    PVOLUME_FAILOVER_SET failoverSet = NULL;
    
    HANDLE  hDevice;
    
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   idx;
    DWORD   bytesReturned;
    
    SCSI_ADDRESS    scsiAddress;
    
    PCHAR   deviceName = NULL;

    deviceName = LocalAlloc( LPTR, MAX_PATH+1 );
    
    if ( !deviceName ) {
        dwError = GetLastError();
        goto FnExit;
    }
    
    //
    // Find out how many physical disks are represented by this device.
    //
    
    dwError = GetVolumeFailoverSet( DevHandle, &failoverSet );

    if ( ERROR_SUCCESS != dwError || !failoverSet ) {
        goto FnExit;
    }

    //
    // For each physical disk, get the scsi address and add it to the list.
    //
    
    for ( idx = 0; idx < failoverSet->NumberOfDisks; idx++ ) {
        
        ZeroMemory( deviceName, MAX_PATH );
        _snprintf( deviceName, 
                   MAX_PATH,
                   "\\\\.\\\\PhysicalDrive%d", 
                   failoverSet->DiskNumbers[idx] );

        hDevice = CreateFile( deviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );
    
        if ( INVALID_HANDLE_VALUE == hDevice ) {
            continue;
        }
        
        ZeroMemory( &scsiAddress, sizeof( scsiAddress ) );
        if ( !DeviceIoControl( hDevice,
                               IOCTL_SCSI_GET_ADDRESS,
                               NULL,
                               0,
                               &scsiAddress,
                               sizeof(scsiAddress),
                               &bytesReturned,
                               NULL ) ) {
    
            continue;
        }

        CloseHandle( hDevice );
        hDevice = INVALID_HANDLE_VALUE;
        
        AddScsiAddressToList( &scsiAddress );
    }

FnExit:

    if ( failoverSet ) {
        LocalFree( failoverSet );
    }

    if ( deviceName ) {
        LocalFree( deviceName );
    }

    return dwError;
    
}   // BuildScsiListFromFailover


DWORD
GetVolumeFailoverSet(
    IN HANDLE DevHandle,
    OUT PVOLUME_FAILOVER_SET *FailoverSet
    )
{
    PVOLUME_FAILOVER_SET    failover = NULL;
    
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   bytesReturned;
    DWORD   sizeFailover;

    BOOL    result;

    if ( !FailoverSet ) {
        goto FnExit;
    }
    
    sizeFailover = ( sizeof(VOLUME_FAILOVER_SET)  + 10 * sizeof(ULONG) );
            
    failover = (PVOLUME_FAILOVER_SET) LocalAlloc( LPTR, sizeFailover );

    if ( !failover ) {
        dwError = GetLastError();
        goto FnExit;    
    }
        
    result = DeviceIoControl( DevHandle,
                              IOCTL_VOLUME_QUERY_FAILOVER_SET,
                              NULL,
                              0,
                              failover,
                              sizeFailover,
                              &bytesReturned,
                              NULL );

    //
    // We're doing this in a while loop because if the disk configuration  
    // changes in the small interval between when we get the reqd buffer 
    // size and when we send the ioctl again with a buffer of the "reqd" 
    // size, we may still end up with a buffer that isn't big enough.
    //
        
    while ( !result ) {
            
        dwError = GetLastError();

        if ( ERROR_MORE_DATA == dwError ) {
            //
            // The buffer was too small, reallocate the requested size.
            //
            
            dwError = ERROR_SUCCESS;
            
            sizeFailover = ( sizeof(VOLUME_FAILOVER_SET)  + 
                             ((failover->NumberOfDisks) * sizeof(ULONG)) );
            
            LocalFree( failover );
            
            failover = (PVOLUME_FAILOVER_SET) LocalAlloc( LPTR, sizeFailover );

            if ( !failover ) {
                dwError = GetLastError();
                goto FnExit;    
            }

            result = DeviceIoControl( DevHandle,
                                      IOCTL_VOLUME_QUERY_FAILOVER_SET,
                                      NULL,
                                      0,
                                      failover,
                                      sizeFailover,
                                      &bytesReturned,
                                      NULL );
       
        } else {

            // Some other error, return error.

            goto FnExit;
       
        }
    }

    *FailoverSet = failover;
    
FnExit:

    if ( ERROR_SUCCESS != dwError && failover ) {
        LocalFree( failover );
    }
    
    return dwError;

}   // GetVolumeFailoverSet


DWORD
AddScsiAddressToList(
    PSCSI_ADDRESS ScsiAddress
    )
{
    PSCSI_ADDRESS_ENTRY entry;
    
    DWORD   dwError = ERROR_SUCCESS;

    //
    // Optimization: don't add the SCSI address if it already
    // matches one in the list.
    //
    
    if ( IsDiskSystemDisk( ScsiAddress ) ) {
        goto FnExit;
    }
        
    entry = LocalAlloc( LPTR, sizeof( SCSI_ADDRESS_ENTRY ) );
    
    if ( !entry ) {
        dwError = GetLastError();
        goto FnExit;
    }

    entry->ScsiAddress.Length       = ScsiAddress->Length;
    entry->ScsiAddress.PortNumber   = ScsiAddress->PortNumber;
    entry->ScsiAddress.PathId       = ScsiAddress->PathId;
    entry->ScsiAddress.TargetId     = ScsiAddress->TargetId;
    entry->ScsiAddress.Lun          = ScsiAddress->Lun;

    if ( SysDiskAddrList ) {
        
        entry->Next = SysDiskAddrList;
        SysDiskAddrList = entry;
        
    } else {
    
        SysDiskAddrList = entry;
    }

FnExit:

    return dwError;
    
}   // AddScsiAddressToList

                           
VOID
CleanupSystemBusInfo(
    )
{
    PSCSI_ADDRESS_ENTRY entry;
    PSCSI_ADDRESS_ENTRY next;
    
    entry = SysDiskAddrList;
    
    while ( entry ) {
        next = entry->Next;
        LocalFree( entry );
        entry = next;
    }

}   // CleanupSystemBusInfo


BOOL
IsDiskSystemDisk(
    PSCSI_ADDRESS DiskAddr
    )
{
    PSCSI_ADDRESS_ENTRY     entry = SysDiskAddrList;
    PSCSI_ADDRESS_ENTRY     next;
    
    while ( entry ) {
        next = entry->Next;        
        
        if ( DiskAddr->PortNumber   == entry->ScsiAddress.PortNumber &&
             DiskAddr->PathId       == entry->ScsiAddress.PathId &&
             DiskAddr->TargetId     == entry->ScsiAddress.TargetId &&
             DiskAddr->Lun          == entry->ScsiAddress.Lun ) {
             
             return TRUE;
        }

        entry = next;
    }
    
    return FALSE;
    
}   // IsDiskSystemDisk


BOOL
IsDiskOnSystemBus(
    PSCSI_ADDRESS DiskAddr
    )
{
    PSCSI_ADDRESS_ENTRY     entry = SysDiskAddrList;
    PSCSI_ADDRESS_ENTRY     next;
    
    while ( entry ) {
        next = entry->Next;        
        
        if ( DiskAddr->PortNumber   == entry->ScsiAddress.PortNumber &&
             DiskAddr->PathId       == entry->ScsiAddress.PathId ) {
    
            return TRUE;
        }
        
        entry = next;
    }

    return FALSE;
    
}   // IsDiskOnSystemBus


DWORD
EnumerateDisks(
    LPDISK_ENUM_CALLBACK DiskEnumCallback,
    PVOID Param1
    )
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDiDetail = NULL;

    HANDLE                      hDevice;
    
    DWORD                       dwError = ERROR_SUCCESS;
    DWORD                       count;
    DWORD                       sizeDiDetail;
    
    BOOL                        result;

    HDEVINFO                    hdevInfo;

    SP_DEVICE_INTERFACE_DATA    devInterfaceData;
    SP_DEVINFO_DATA             devInfoData;

    if ( !DiskEnumCallback ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    //
    // Get a device interface set which includes all Disk devices
    // present on the machine. DiskClassGuid is a predefined GUID that
    // will return all disk-type device interfaces
    //
    
    hdevInfo = SetupDiGetClassDevs( &DiskClassGuid,
                                    NULL,
                                    NULL,
                                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );

    if ( !hdevInfo ) {
        dwError = GetLastError();
        goto FnExit;
    }
    
    ZeroMemory( &devInterfaceData, sizeof( SP_DEVICE_INTERFACE_DATA) );
    
    //
    // Iterate over all devices interfaces in the set
    //
    
    for ( count = 0; ; count++ ) {

        // must set size first
        devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA); 

        //
        // Retrieve the device interface data for each device interface
        //
        
        result = SetupDiEnumDeviceInterfaces( hdevInfo,
                                              NULL,
                                              &DiskClassGuid,
                                              count,
                                              &devInterfaceData );

        if ( !result ) {
            
            //
            // If we retrieved the last item, break
            //
            
            dwError = GetLastError();

            if ( ERROR_NO_MORE_ITEMS == dwError ) {
                dwError = ERROR_SUCCESS;
                break;
            
            } 
            
            // 
            // Some other error occurred.  Stop processing.
            //
            
            goto FnExit;
        }

        //
        // Get the required buffer-size for the device path.  Note that
        // this call is expected to fail with insufficient buffer error.
        //
        
        result = SetupDiGetDeviceInterfaceDetail( hdevInfo,
                                                  &devInterfaceData,
                                                  NULL,
                                                  0,
                                                  &sizeDiDetail,
                                                  NULL
                                                  );

        if ( !result ) {

            dwError = GetLastError();
            
            //
            // If a value other than "insufficient buffer" is returned,
            // we have to skip this device.
            //
            
            if ( ERROR_INSUFFICIENT_BUFFER != dwError ) {
                continue;
            }
        
        } else {
            
            //
            // The call should have failed since we're getting the
            // required buffer size.  If it doesn't fail, something bad
            // happened.
            //
            
            continue;
        }

        //
        // Allocate memory for the device interface detail.
        //
        
        pDiDetail = LocalAlloc( LPTR, sizeDiDetail );

        if ( !pDiDetail ) {
            dwError = GetLastError();
            goto FnExit;
        }

        // must set the struct's size member
        
        pDiDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Finally, retrieve the device interface detail info.
        //
        
        result = SetupDiGetDeviceInterfaceDetail( hdevInfo,
                                                  &devInterfaceData,
                                                  pDiDetail,
                                                  sizeDiDetail,
                                                  NULL,
                                                  &devInfoData
                                                  );
        
        if ( !result ) {
            
            dwError = GetLastError();

            //
            // Shouldn't fail, if it does, try the next device.
            //            
            
            continue;
        }

        //
        // Open a handle to the device.
        //
        
        hDevice = CreateFile( pDiDetail->DevicePath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );
    
        LocalFree( pDiDetail );
        pDiDetail = NULL;
        
        if ( INVALID_HANDLE_VALUE == hDevice ) {
            continue;
        }
        
        //
        // Call the specified callback routine.  An error returned stops the 
        // disk enumeration.
        //
        
        dwError = (*DiskEnumCallback)( hDevice, count, Param1 );
        
        CloseHandle( hDevice );
        
        if ( ERROR_SUCCESS != dwError ) {
            goto FnExit;
        }
    }
    
FnExit:

    if ( pDiDetail ) {
        LocalFree( pDiDetail );
    }
    
    return dwError;

}   // EnumerateDisks



DWORD
GetSerialNumber(
    IN DWORD Signature,
    OUT LPWSTR *SerialNumber
    )

/*++

Routine Description:

    Find the disk serial number for a given signature.

Arguments:

    Signature - the signature to find.

    SerialNumber - pointer to allocated buffer holding the returned serial
                   number.  The caller must free this buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD       dwError;
    
    SERIAL_INFO serialInfo;
    
    if ( !Signature || !SerialNumber ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    *SerialNumber = NULL;

    ZeroMemory( &serialInfo, sizeof(serialInfo) );
    
    serialInfo.Signature = Signature;
    serialInfo.Error = ERROR_SUCCESS;
    
    dwError = EnumerateDisks( GetSerialNumberCallback, &serialInfo );

    //
    // The callback routine will use ERROR_POPUP_ALREADY_ACTIVE to stop
    // the disk enumeration.  Reset the value to the value returned
    // in the SERIAL_INFO structure.
    //
    
    if ( ERROR_POPUP_ALREADY_ACTIVE == dwError ) {
        dwError = serialInfo.Error;
    }

    // This will either be NULL or an allocated buffer.  Caller is responsible
    // to free.

    *SerialNumber = serialInfo.SerialNumber;

FnExit:

    return dwError;
    
}   // GetSerialNumber


DWORD
GetSerialNumberCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    )
/*++

Routine Description:

    Find the disk serial number for a given signature.

Arguments:

    DevHandle - open handle to a physical disk.  Do not close
                the handle on exit.
                
    Index - current disk count.  Not used.
    
    Param1 - pointer to PSERIAL_INFO structure.
                    
Return Value:

    ERROR_SUCCESS to continue disk enumeration.
    
    ERROR_POPUP_ALREADY_ACTIVE to stop disk enumeration.  This 
    value will be changed to ERROR_SUCCESS by GetScsiAddress.

--*/
{
    PSERIAL_INFO                serialInfo = Param1;

    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;
    
    DWORD   dwError = ERROR_SUCCESS;
    
    BOOL    success;

    // Always return success to keep enumerating disks.  Any
    // error value will stop the disk enumeration.
    
    STORAGE_PROPERTY_QUERY propQuery;

    success = ClRtlGetDriveLayoutTable( DevHandle,
                                        &driveLayout,
                                        NULL );
    
    if ( !success || !driveLayout || 
         ( driveLayout->Signature != serialInfo->Signature ) ) {
        goto FnExit;
    }
    
    //
    // At this point, we have a signature match.  Now this function
    // must return this error value to stop the disk enumeration.  The
    // error value for the serial number retrieval will be returned in
    // the SERIAL_INFO structure.
    //
    
    dwError = ERROR_POPUP_ALREADY_ACTIVE;

    serialInfo->Error = RetrieveSerialNumber( DevHandle, &serialInfo->SerialNumber );
    
FnExit:

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }
    
    if ( serialInfo->Error != ERROR_SUCCESS && serialInfo->SerialNumber ) {
        LocalFree( serialInfo->SerialNumber );
    }
    
    return dwError;

} // GetSerialNumberCallback


DWORD
GetSignatureFromSerialNumber(
    IN LPWSTR SerialNumber,
    OUT LPDWORD Signature
    )

/*++

Routine Description:

    Find the disk signature for the given serial number.

Arguments:

    SerialNumber - pointer to allocated buffer holding the serial number.

    Signature - pointer to location to hold the signature.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD       dwError;
    
    SERIAL_INFO serialInfo;
    
    if ( !Signature || !SerialNumber ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    *Signature = 0;

    ZeroMemory( &serialInfo, sizeof(serialInfo) );
    
    serialInfo.SerialNumber = SerialNumber;    
    serialInfo.Error = ERROR_SUCCESS;
    
    dwError = EnumerateDisks( GetSigFromSerNumCallback, &serialInfo );

    //
    // The callback routine will use ERROR_POPUP_ALREADY_ACTIVE to stop
    // the disk enumeration.  Reset the value to the value returned
    // in the SERIAL_INFO structure.
    //
    
    if ( ERROR_POPUP_ALREADY_ACTIVE == dwError ) {
        dwError = serialInfo.Error;
    }

    // This signature will either be zero or valid.

    *Signature = serialInfo.Signature;

FnExit:

    return dwError;
    
}   // GetSignatureFromSerialNumber


DWORD
GetSigFromSerNumCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    )
/*++

Routine Description:

    Find the disk signature for a given serial number.

Arguments:

    DevHandle - open handle to a physical disk.  Do not close
                the handle on exit.
                
    Index - current disk count.  Not used.
    
    Param1 - pointer to PSERIAL_INFO structure.
                    
Return Value:

    ERROR_SUCCESS to continue disk enumeration.
    
    ERROR_POPUP_ALREADY_ACTIVE to stop disk enumeration.  This 
    value will be changed to ERROR_SUCCESS by GetScsiAddress.

--*/
{
    PSERIAL_INFO                serialInfo = Param1;
    LPWSTR                      serialNum = NULL;
    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;
    
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   oldLen;
    DWORD   newLen;
    
    BOOL    success;

    // Always return success to keep enumerating disks.  Any
    // error value will stop the disk enumeration.
    
    dwError = RetrieveSerialNumber( DevHandle, &serialNum );
    
    if ( NO_ERROR != dwError || !serialNum ) {
        dwError = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    // We have a serial number, now try to match it.
    //
    
    newLen = wcslen( serialNum );
    oldLen = wcslen( serialInfo->SerialNumber );
    
    if ( newLen != oldLen ||
         0 != wcsncmp( serialNum, serialInfo->SerialNumber, newLen ) ) {
        goto FnExit;
    }
    
    //
    // At this point, we have a serial number match.  Now this function
    // must return this error value to stop the disk enumeration.  The
    // error value for the signature retrieval will be returned in
    // the SERIAL_INFO structure.
    //

    dwError = ERROR_POPUP_ALREADY_ACTIVE;
    
    success = ClRtlGetDriveLayoutTable( DevHandle,
                                        &driveLayout,
                                        NULL );
    
    if ( !success || !driveLayout ) {
        serialInfo->Error = ERROR_INVALID_DATA;
        goto FnExit;
    }
    
    serialInfo->Signature = driveLayout->Signature;
    serialInfo->Error = NO_ERROR;
    
FnExit:

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }
    
    if ( serialNum ) {
        LocalFree( serialNum );
    }
    
    return dwError;

} // GetSigFromSerNumCallback


DWORD
RetrieveSerialNumber(
    HANDLE DevHandle,
    LPWSTR *SerialNumber
    )
{
    PSTORAGE_DEVICE_DESCRIPTOR  descriptor = NULL;

    PWCHAR  wSerNum = NULL;
    PCHAR   sigString;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   bytesReturned;
    DWORD   descriptorSize;

    size_t  count1;
    size_t  count2;

    BOOL    success;
    
    STORAGE_PROPERTY_QUERY propQuery;
    
    if ( !SerialNumber ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    *SerialNumber = NULL;
    
    descriptorSize = sizeof( STORAGE_DEVICE_DESCRIPTOR) + 4096;

    descriptor = LocalAlloc( LPTR, descriptorSize );

    if ( !descriptor ) {
        dwError = GetLastError();
        goto FnExit;
    }

    ZeroMemory( &propQuery, sizeof( propQuery ) );

    propQuery.PropertyId = StorageDeviceProperty;
    propQuery.QueryType  = PropertyStandardQuery;

    success = DeviceIoControl( DevHandle,
                               IOCTL_STORAGE_QUERY_PROPERTY,
                               &propQuery,
                               sizeof(propQuery),
                               descriptor,
                               descriptorSize,
                               &bytesReturned,
                               NULL );

    if ( !success ) {
        dwError = GetLastError();
        goto FnExit;
    }

    if ( !bytesReturned ) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    //
    // Make sure the offset is reasonable.
    // IA64 sometimes returns -1 for SerialNumberOffset.
    //
    
    if ( 0 == descriptor->SerialNumberOffset ||
         descriptor->SerialNumberOffset > descriptor->Size ) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }
    
    //
    // Serial number string is a zero terminated ASCII string.  
    //
    // The header ntddstor.h says the for devices with no serial number,
    // the offset will be zero.  This doesn't seem to be true.
    //
    // For devices with no serial number, it looks like a string with a single
    // null character '\0' is returned.
    //
    
    sigString = (PCHAR)descriptor + (DWORD)descriptor->SerialNumberOffset;
    
    if ( strlen(sigString) == 0) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    //
    // Convert ASCII string to WCHAR.
    //

    // Figure out how big the WCHAR buffer should be.  Allocate the WCHAR 
    // buffer and copy the string into it.
    
    count1 = mbstowcs( NULL, sigString, strlen(sigString) );
    
    if ( -1 == count1 || 0 == count1 ) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }
    
    wSerNum = LocalAlloc( LPTR, ( count1 * sizeof(WCHAR) + sizeof(UNICODE_NULL) ) );
    
    if ( !wSerNum ) {
        dwError = GetLastError();
        goto FnExit;
    }
    
    count2 = mbstowcs( wSerNum, sigString, strlen(sigString) );
    
    if ( count1 != count2 ) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    *SerialNumber = wSerNum;
    dwError = NO_ERROR;
    
FnExit:

    if ( descriptor ) {
        LocalFree( descriptor );
    }

    return dwError;

}   // RetrieveSerialNumber
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\newdisks.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    newdisks.h

Abstract:

    Definitions exported by newdisks.c
    and used by disks.c

Author:

    Gor Nishanov (GorN) 31-July-1998

Revision History:

--*/

DWORD
DisksOnlineThread(
    IN PCLUS_WORKER Worker,
    IN PDISK_RESOURCE ResourceEntry
    );
/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the cluster worker context

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

DWORD
DisksOpenResourceFileHandle(
    IN PDISK_RESOURCE ResourceEntry,
    IN PWCHAR         InfoString, 
    OUT PHANDLE       fileHandle OPTIONAL
    );
/*++

Routine Description:

    Open a file handle for the resource.
    It performs the following steps:
      1. Read Disk signature from cluster registry
      2. Attaches clusdisk driver to a disk with this signature
      3. Gets Harddrive no from ClusDisk driver registry
      4. Opens \\.\PhysicalDrive%d device and returns open handle

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.
    
    InfoString - Supplies a label to be printed with error messages
    
    fileHandle - receives file handle


Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

enum {
  OFFLINE   = FALSE,
  TERMINATE = TRUE
};

DWORD
DisksOfflineOrTerminate(
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL Terminate
    );
/*++

Routine Description:

    Used by DisksOffline and DisksTerminate.
    
    Routine performs the following steps:
    
      1. ClusWorkerTerminate (Terminate only)
      
      2. Then For all of the partitions on the drive...
   
         a. Flush the file buffers.                                        (Offline only)
         b. Lock the volume to purge all in memory contents of the volume. (Offline only)
         c. Dismount the volume
         
      3. Removes default network shares (C$, F$, etc)   
   

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

    Terminate     - Set it to TRUE to cause Termination Behavior    


Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/


enum {
   MOUNTIE_VALID  = 0x1,
   MOUNTIE_THREAD = 0x2,
   MOUNTIE_QUIET  = 0x4,
};

DWORD
DiskspSsyncDiskInfo(
    IN PWCHAR InfoLabel,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Options
    );
/*++

Routine Description:

    Restores the disk registry information
    if necessary.

Arguments:

    InfoLabel - Supplies a label to be printed with error messages

    ResourceEntry - Supplies the disk resource structure.

    Options - 0 or combination of the following:
    
        MOUNTIE_VALID: ResourceEntry contains up to date MountieInfo.
                       If this flag is not set, MountieInfo will be recomputed
                       
        MOUNTIE_THREAD: If ERROR_SHARING_PAUSED prevents updating cluster registry,
                        launch a thread to do it later
                        
        MOUNTIE_QUIET: Quiet mode. Less noise in logs.
                       

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

DWORD
DisksIsVolumeDirty(
    IN PWCHAR         DeviceName,
    IN PDISK_RESOURCE ResourceEntry,
    OUT PBOOL         Dirty
    );

DWORD
DiskspCheckPath(
    IN LPWSTR VolumeName,
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL OpenFiles,
    IN BOOL LogFileNotFound
    );


/////////////////////////////////////////////////////////////////

//
// Import the following from disks.c
//
extern CRITICAL_SECTION DisksLock;
extern RESUTIL_PROPERTY_ITEM DiskResourcePrivateProperties[];
extern HANDLE DisksTerminateEvent;
extern LIST_ENTRY DisksListHead;

extern PWCHAR DEVICE_HARDDISK_PARTITION_FMT; // L"\\Device\\Harddisk%u\\Partition%u";

DWORD
DisksFixCorruption(
    IN PWCHAR VolumeName,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD CorruptStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\newdisks.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    newdisks.c

Abstract:

    Some of the functions that used to be
    in disks.c reside now here

Author:

    Gor Nishanov (GorN) 31-July-1998

Revision History:

--*/

#include "disksp.h"
#include "partmgrp.h"

#include "arbitrat.h"
#include "newdisks.h"
#include "newmount.h"
#include "mountmgr.h"

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

PSTR  DiskName = "\\Device\\Harddisk%u";
PWCHAR DEVICE_HARDDISK_PARTITION_FMT = L"\\Device\\Harddisk%u\\Partition%u";

//
// This string is needed to convert the \Device\HarddiskX\PartitionY name to 
// the Vol{GUID} name.  Note that the trailing backslash is required!
// 

PWCHAR GLOBALROOT_HARDDISK_PARTITION_FMT = L"\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition%u\\";


DWORD
WaitForDriveLetters(
    IN DWORD DriveLetters,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  timeOutInSeconds
    );
    
DWORD
WaitForVolumes(
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  timeOutInSeconds
    );

DWORD
DiskspCheckPathLite(
    IN LPWSTR VolumeName,
    IN PDISK_RESOURCE ResourceEntry
    );

DWORD
DiskCleanup(
    PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Stops the reservations, dismount drive and frees DiskCpInfo

Arguments:

    ResourceEntry - the disk info structure for the disk.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"DiskCleanup started.\n");

    StopPersistentReservations(ResourceEntry);
    //
    // If the remaining data in the resource entry is not valid, then leave
    // now.
    //
    if ( !ResourceEntry->Valid ) {
        goto FnExit;
    }

    //
    // Delete the DiskCpInfo.
    //
    if ( ResourceEntry->DiskCpInfo ) {
        LocalFree(ResourceEntry->DiskCpInfo);
        ResourceEntry->DiskCpInfo = NULL;
        ResourceEntry->DiskCpSize = 0;
    }

    ResourceEntry->Attached = FALSE;
    ResourceEntry->Valid = FALSE;

    //
    // Remove the Dos Drive Letters, this is better done here rather than
    // in ClusDisk.
    //
    DisksDismountDrive( ResourceEntry,
                        ResourceEntry->DiskInfo.Params.Signature );

FnExit:

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"DiskCleanup returning final error %1!u! \n",
        status );

    return(status);
} // DiskCleanup

static
DWORD
DisksSetDiskInfoThread(
    LPVOID lpThreadParameter
    )

/*++

Routine Description:

    Registry update thread. 

Arguments:

    lpThreadParameter - stores ResourceEntry.

Return Value:

    None

--*/

{
    DWORD Status;
    BOOL  TryAgain = TRUE;
    PDISK_RESOURCE ResourceEntry = lpThreadParameter;
    DWORD i;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Checkpoint thread started.\n");
    //
    // Will die in 10 minutes if unsuccessful
    //
    for(i = 0; i < 300; ++i) {
        //
        // Wait for either the terminate event or the timeout
        //
        Status = WaitForSingleObject( DisksTerminateEvent, 2000 );
        if (Status == WAIT_TIMEOUT ) {
            Status = MountieUpdate(&ResourceEntry->MountieInfo, ResourceEntry);
            if ( Status == ERROR_SUCCESS ) {
                // We're done
                break;
            } else if ( Status != ERROR_SHARING_PAUSED ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Watcher Failed to checkpoint disk info, status = %1!u!.\n", Status );
                break;
            }
        } else {
           (DiskpLogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_INFORMATION,
               L"CheckpointThread: WaitForSingleObject returned status = %1!u!.\n", Status );
           break;
        }
    } 

    InterlockedExchange(
      &ResourceEntry->MountieInfo.UpdateThreadIsActive, 0);
    return(ERROR_SUCCESS);

} // DisksSetDiskInfoThread



DWORD
DisksOfflineOrTerminate(
    IN PDISK_RESOURCE resourceEntry,
    IN BOOL Terminate
    )
/*++

Routine Description:

    Used by DisksOffline and DisksTerminate.
    
    Routine performs the following steps:
    
      1. ClusWorkerTerminate (Terminate only)
      
      2. Then for all of the partitions on the drive...
   
         a. Flush the file buffers.                                        (Offline only)
         b. Lock the volume to purge all in memory contents of the volume. (Offline only)
         c. Dismount the volume
         
      3. Removes default network shares (C$, F$, etc)   
   

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

    Terminate     - Set it to TRUE to cause Termination Behavior    


Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    PWCHAR WideName = (Terminate)?L"Terminate":L"Offline";
    
    PHANDLE handleArray = NULL;

    BOOL   Offline  = !Terminate;
    DWORD status;
    DWORD length;
    DWORD idx;
    DWORD PartitionCount;
    DWORD handleArraySize;

    HANDLE fileHandle;
    DWORD  bytesReturned;
    WCHAR  szDiskPartName[MAX_PATH];
    NTSTATUS ntStatus;

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"%1!ws!, ResourceEntry @ %2!x!  Valid %3!x! \n", 
        WideName, 
        resourceEntry,
        resourceEntry->Valid );

    if (Terminate) {
        ClusWorkerTerminate(&resourceEntry->OnlineThread);
    }
    
    StopWatchingDisk(resourceEntry);

    //
    // If the disk info is not valid, then don't use it!
    //
    if ( !resourceEntry->Valid ) {
        DiskCleanup( resourceEntry );
        return(ERROR_SUCCESS);
    }

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"%1!ws!, Processing disk number %2!u!.\n", 
        WideName, 
        resourceEntry->DiskInfo.PhysicalDrive );

#if 0
    if( Offline ) {
        //
        // Checkpoint our registry state
        //
    }
#endif

    PartitionCount = MountiePartitionCount(&resourceEntry->MountieInfo);

    //
    // Allocate a buffer to hold handle for each partition.  Since the
    // lock is released as soon as we call CloseHandle, we need to save all
    // the handles and close them after the disk is marked offline by
    // DiskCleanup.  If we cannot allocate the storage for the handle
    // array, we will fall back to the previous behavior.
    //
    
    handleArraySize = PartitionCount * sizeof(HANDLE);
    handleArray = LocalAlloc( LPTR, handleArraySize );

    if ( !handleArray ) {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_WARNING,
            L"%1!ws!, Unable to allocate storage for handle array, error %2!u!.\n", 
            WideName, 
            GetLastError() );
    } else {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"%1!ws!, Using handle array. \n",
            WideName );
    }

    //
    // For all of the partitions on the drive...
    //
    // 1. Flush the file buffers.                                        (Offline only)
    // 2. Lock the volume to purge all in memory contents of the volume. (Offline only)
    // 3. Dismount the volume
    //

    for ( idx = 0; idx < PartitionCount; ++idx ) {
        PMOUNTIE_PARTITION partition = MountiePartition(&resourceEntry->MountieInfo, idx);

        swprintf( szDiskPartName, DEVICE_HARDDISK_PARTITION_FMT, 
                  resourceEntry->DiskInfo.PhysicalDrive, 
                  partition->PartitionNumber);

        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"%1!ws!, Opening device %2!ws!.\n", 
            WideName, 
            szDiskPartName );

        ntStatus = DevfileOpen(&fileHandle, szDiskPartName);
        if ( !NT_SUCCESS(ntStatus) ) {
            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%2!ws!, error opening %3!ws!, error %1!X!.\n",
                ntStatus, WideName, szDiskPartName );
            continue;
        }

        //
        // Save the current partition handle and close it after the device has been
        // marked offline.
        //
        
        if ( handleArray ) {
            handleArray[idx] = fileHandle;
        }

        if (Offline) {
            DWORD retryCount;
            //
            // Flush file buffers
            //

            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"%1!ws!, FlushFileBuffers for %2!ws!.\n", 
                WideName, 
                szDiskPartName );

            if ( !FlushFileBuffers( fileHandle ) ) {
                (DiskpLogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Offline, error flushing file buffers on device %2!ws!. Error: %1!u!.\n",
                    GetLastError(), szDiskPartName );

                CloseHandle( fileHandle );

                continue;
            }

            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"%1!ws!, Locking volume for %2!ws!.\n", 
                WideName, 
                szDiskPartName );

            //
            // Lock the volume, try this twice
            //
            retryCount = 0;
            while ( (retryCount < 2) &&
                !DeviceIoControl( fileHandle,
                                  FSCTL_LOCK_VOLUME,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &bytesReturned,
                                  NULL ) ) {

                (DiskpLogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"%1!ws!, Locking volume failed, error %2!u!.\n", 
                    WideName, 
                    GetLastError() );

                retryCount++;
                Sleep(600);
            }
        }

        //
        // Now Dismount the volume.
        //
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"%1!ws!, Dismounting volume %2!ws!.\n", WideName, szDiskPartName);
        
        if ( !DeviceIoControl( fileHandle,
                               FSCTL_DISMOUNT_VOLUME,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               NULL ) ) {
            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%1!ws!, error dismounting volume %2!ws!. Error %3!u!.\n",
                WideName, szDiskPartName, GetLastError() );
        }  

        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"%1!ws!, Dismount complete, volume %2!ws!.\n", WideName, szDiskPartName);

        // 
        // Close the handle only if we couldn't allocate the handle array.
        //
        
        if ( !handleArray ) {
            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"%1!ws!, No handle array, closing device %2!ws!.\n", 
                WideName, 
                szDiskPartName );

            CloseHandle( fileHandle );
        }
    }

    //
    // Take this resource off the 'online' list.
    //
    EnterCriticalSection( &DisksLock );
    if ( resourceEntry->Inserted ) {
        RemoveEntryList( &resourceEntry->ListEntry );
        resourceEntry->Inserted = FALSE;
        if ( IsListEmpty( &DisksListHead ) ) {
            //
            // Fire Disk Terminate Event
            //
            SetEvent( DisksTerminateEvent ) ;
            CloseHandle( DisksTerminateEvent );
            DisksTerminateEvent = NULL;
        }
    }
    LeaveCriticalSection( &DisksLock );

    status = ERROR_SUCCESS;

    DiskCleanup( resourceEntry );

    //
    // If we have the handle array, close the handles to all the partitions.  This 
    // is done after DiskCleanup sets the disk state to offline.  Issuing the lock 
    // and keeping the handle open will prevent new mounts on the partition.
    //
    
    if ( handleArray ) {

        for ( idx = 0; idx < PartitionCount; idx++ ) {
            if ( handleArray[idx] ) {
                CloseHandle( handleArray[idx] );
            }
        }

        LocalFree( handleArray );
    }

    resourceEntry->Valid = FALSE;

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"%1!ws!, Returning final error %2!u!.\n",
        WideName,
        status );

    return(status);

} // DisksOfflineOrTerminate


DWORD
DisksOnlineThread(
    IN PCLUS_WORKER Worker,
    IN PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the cluster worker context

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD       status = ERROR_INVALID_PARAMETER;
    HANDLE      fileHandle = NULL;
    HANDLE      event = NULL;
    DWORD       index;
    RESOURCE_STATUS resourceStatus;
    DWORD       threadId;
    BOOL        success;
    HANDLE      thread;
    DWORD       bytesReturned;
    UINT        i, nRetries;
    HANDLE      MountManager = 0;
    DWORD       ntStatus;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    //
    // Check if we've been here before... without offline/terminate
    //
    if ( ResourceEntry->Inserted ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, resource is already in online list!\n");
        goto exit;
    }

    ResourceEntry->DiskInfo.FailStatus = 0;

    status = DisksOpenResourceFileHandle(ResourceEntry, L"Online", &fileHandle);
    if (status != ERROR_SUCCESS) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Online, DisksOpenResourceFileHandle failed. Error: %1!u!\n", status);
       goto exit;
    }

    if( !ReservationInProgress(ResourceEntry) ) { // [GN] 209018 //
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_WARNING,
           L"DiskArbitration must be called before DisksOnline.\n");
// [GN] We can steal the disk while regular arbitration is in progress in another thread //
//      We have to do a regular arbitration, no shortcuts as the one below
//       status = StartPersistentReservations(ResourceEntry, fileHandle);
//       if ( status != ERROR_SUCCESS ) {
          status = DiskArbitration( ResourceEntry, DiskspClusDiskZero );
//       }
       if ( status != ERROR_SUCCESS ) {
           (DiskpLogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_ERROR,
               L"Online, arbitration failed. Error: %1!u!.\n",
               status );
           status = ERROR_RESOURCE_NOT_AVAILABLE;
           goto exit;
       }
    }

    //
    // Synchronize with async cleanup worker
    //
    {
        ULONG waitTimeInSeconds = 10;
        status = DevfileIoctl( fileHandle,
                               IOCTL_DISK_CLUSTER_WAIT_FOR_CLEANUP,
                               &waitTimeInSeconds, sizeof(waitTimeInSeconds),
                               NULL, 0,
                               &bytesReturned );
        if ( !NT_SUCCESS(status) ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, WaitForCleanup returned. Status: 0x%1!x!.\n",
                status );
            goto exit;            
        }
    }

    //
    // Bring the device online.
    // we have to do this here for PartMgr poke to succeed.
    //
    status = GoOnline( fileHandle, ResourceEntry->ResourceHandle );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, error bringing device online. Error: %1!u!.\n",
            status );
        goto exit;
    }
    
    //
    // Create volume information
    //
    status = MountieRecreateVolumeInfoFromHandle(fileHandle, 
                                     ResourceEntry->DiskInfo.PhysicalDrive,
                                     ResourceEntry->ResourceHandle,
                                     &ResourceEntry->MountieInfo);
    if (status != ERROR_SUCCESS) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Online, MountieCreateFromHandle failed. Error: %1!u!\n", status);
       goto exit;
    }

    //
    // Now poke partition manager
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    if (!success) {
        status = GetLastError();
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, Partmgr failed to claim all partitions. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Before attempting to access the device, close our open handles.
    //
    CloseHandle( fileHandle );
    fileHandle = NULL;

    ntStatus = DevfileOpen(&MountManager, MOUNTMGR_DEVICE_NAME);
    if (!NT_SUCCESS(ntStatus)) {
       status = RtlNtStatusToDosError(ntStatus);
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Online, MountMgr open failed. Error: %1!u!.\n", status);
        goto exit;
    }

    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    
    // we will wait not more than 48 seconds per partition
    nRetries = 24 * ResourceEntry->MountieInfo.Volume->PartitionCount;
    // Don't wait for longer than 10 minutes total time //
    if (nRetries > 300) {
        nRetries = 300;
    }

    __try {
    
        // We cannot call VolumesReady because pnp might be adding this device
        // the same time we are trying to get the volume name.  We must wait
        // for the volume to show up in the pnp list.
        //
        // Check the PnP thread's volume list to see if the volume arrived.
        // If not in the list, fall through and wait for the event to be
        // signaled.
        //
        // First time through the list, don't update the volume list as this
        // can be time consuming.
        //
        
        if ( IsDiskInPnpVolumeList( ResourceEntry, FALSE ) ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, disk found in PnP volume list on first attempt \n");
            
            //
            // VolumesReady should work now.  If not, there is some other problem.
            //
            
            status = VolumesReady(&ResourceEntry->MountieInfo, ResourceEntry); 
            
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, VolumesReady returns: %1!u!. \n",
                status );
    
            //
            // If disk corrupt or file corrupt error returned, disk is ready and
            // we need to run chkdsk.  Change status to success and fall through.
            //
            
            if ( ERROR_DISK_CORRUPT == status || ERROR_FILE_CORRUPT == status ) {
                
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"Online, Allowing corrupt disk online for chkdsk processing \n" );
                
                status = STATUS_SUCCESS;
            }
            
            __leave;
        }
                
        //
        // Create event for waiting.
        //

        event = CreateEvent( NULL,      // security attributes
                             TRUE,      // manual reset
                             FALSE,     // initial state: nonsignaled
                             NULL );    // object name

        if ( !event ) {
            status = GetLastError();
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, Failed to create event for PnP notification. Error: %1!u!.\n",
                status );
            __leave;
        }

        // 
        // Tell our PnP code we are waiting for this disk.
        //
        
        status = QueueWaitForVolumeEvent( event, 
                                          ResourceEntry );
        
        if ( ERROR_SUCCESS != status ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, Failed to create event for PnP notification. Error: %1!u!.\n",
                status );
            __leave;
        }
        
        resourceStatus.CheckPoint += 1;
        (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                 &resourceStatus );
        
        for (i = 0; i < nRetries; ++i) {
    
            //
            // Make sure we aren't terminated.  We don't need to wait for pnp 
            // in this case.
            //
            
            if ( ResourceEntry->OnlineThread.Terminate ) {
                status = ERROR_SHUTDOWN_CLUSTER;
                __leave;
            }
            
            //
            // Ask mountmgr to process volumes.  
            //

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, about to call check unprocessed volumes...\n");
            success = DeviceIoControl( MountManager,
                                       IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES,
                                       NULL,
                                       0,
                                       NULL,
                                       0,
                                       &bytesReturned,
                                       FALSE );

            if ( !success ) {
                status = GetLastError();
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Online, MountMgr failed to check unprocessed volumes. Error: %1!u!.\n",
                    status );

                // The call to the mountmgr can return an error if there are
                // disks reserved by another node.  Fall through...

            }

            //
            // Wait for event signal or timeout.  We wait only 2 seconds
            // at a time so we can update the checkpoint.
            //
            
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, waiting for PnP notification...\n");
            
            status = WaitForSingleObject( event,
                                          2000 );

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, wait for PnP notification returns %1!u! \n", status );

            if ( WAIT_OBJECT_0 == status ) {
                
                //
                // Event was signaled, try VolumesReady one more time.  
                // This should work or there is a more serious problem.
                
                status = VolumesReady(&ResourceEntry->MountieInfo, ResourceEntry); 
                __leave;
            }
            
            if ( WAIT_TIMEOUT != status ) {
                status = GetLastError();
                __leave;
            }

            //
            // Force a check in the PnP thread's volume list in
            // case we somehow missed the volume arrival.  If all
            // volumes are available for this disk, we are done 
            // waiting.
            //

            if ( IsDiskInPnpVolumeList( ResourceEntry, TRUE ) ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Online, disk found in PnP volume list\n");
                
                //
                // VolumesReady should work now.  If not, there is some other problem.
                //
                
                status = VolumesReady(&ResourceEntry->MountieInfo, ResourceEntry); 
                __leave;
            }
            
        
            resourceStatus.CheckPoint += 1;
            (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                     &resourceStatus );
        }
    
    } __finally {

        //
        // Tell our PnP code that we are no longer waiting.  Not a 
        // problem if we never queued the request previously.
        //

        RemoveWaitForVolumeEvent( ResourceEntry );

        if ( event ) {
            CloseHandle( event );
        }
    }
    
    DevfileClose(MountManager);
    resourceStatus.ResourceState = ClusterResourceFailed;

    if (status != ERROR_SUCCESS) {
       (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, volumes not ready. Error: %1!u!.\n",
            status );
       goto exit;
    }

   (DiskpLogEvent)(
       ResourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Online, volumes ready.\n");

    //
    // Need to synchronize with ClusDisk by issuing 
    // IOCTL_CLUSTER_VOLUME_TEST on all partitions
    //
    // Need to read volume type. If it is RAW, we need to
    // dismount and mount it again as a workaround for 389861 
    //

    resourceStatus.ResourceState = ClusterResourceOnline;
    ResourceEntry->Valid = TRUE;

    //
    // Start the registry notification thread, if needed.
    //
    EnterCriticalSection( &DisksLock );

    if ( IsListEmpty( &DisksListHead ) ) {
        DisksTerminateEvent = CreateEventW( NULL,
                                            TRUE,
                                            FALSE,
                                            NULL );
        if ( DisksTerminateEvent == NULL ) {
            status = GetLastError();
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, error %1!d! creating registry thread terminate event\n",
                status);
            LeaveCriticalSection( &DisksLock );
            goto exit;
        }
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Online, created registry thread terminate event \n");        
    }

    ResourceEntry->Inserted = TRUE;
    InsertTailList( &DisksListHead, &ResourceEntry->ListEntry );
    LeaveCriticalSection( &DisksLock );

    DiskspSsyncDiskInfo(L"Online", ResourceEntry, MOUNTIE_VALID | MOUNTIE_THREAD );

    status = WaitForVolumes( ResourceEntry,
                             30 // seconds timeout //
                             );

    //
    // We cannot just check for NO_ERROR status.  The problem is that WaitForVolumes 
    // calls GetFileAttributes, which can return ERROR_DISK_CORRUPT (1393).  If the 
    // disk is corrupt, we should fall through and let chkdsk try to clean it up.  
    // We should also do this if ERROR_FILE_CORRUPT (1392) is returned  (haven't 
    // yet seen file corrupt error returned from GetFileAttributes, but one never knows).
    //

    if ( NO_ERROR != status && ERROR_DISK_CORRUPT != status && ERROR_FILE_CORRUPT != status ) {
        ClusResLogSystemEventByKey( ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_MOUNT_FAILED );
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, error waiting for file system to mount. Error: %1!u!.\n",
            status );
        resourceStatus.ResourceState = ClusterResourceFailed;
        ResourceEntry->Valid = FALSE;

        EnterCriticalSection( &DisksLock );
        CL_ASSERT ( ResourceEntry->Inserted );
        ResourceEntry->Inserted = FALSE;
        RemoveEntryList( &ResourceEntry->ListEntry );
        if ( IsListEmpty( &DisksListHead ) ) {
            //
            // Fire Disk Terminate Event
            //
            SetEvent( DisksTerminateEvent ) ;
            CloseHandle( DisksTerminateEvent );
            DisksTerminateEvent = NULL;
        }
        LeaveCriticalSection( &DisksLock );
        goto exit;
    }
    
    status = DisksMountDrives( &ResourceEntry->DiskInfo,
                               ResourceEntry,
                               ResourceEntry->DiskInfo.Params.Signature );

    if ( status != ERROR_SUCCESS ) {
        ClusResLogSystemEventByKey( ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_MOUNT_FAILED );
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, error mounting disk or creating share names for disk. Error: %1!u!.\n",
            status );
        resourceStatus.ResourceState = ClusterResourceFailed;
        ResourceEntry->Valid = FALSE;

        EnterCriticalSection( &DisksLock );
        CL_ASSERT ( ResourceEntry->Inserted );
        ResourceEntry->Inserted = FALSE;
        RemoveEntryList( &ResourceEntry->ListEntry );
        if ( IsListEmpty( &DisksListHead ) ) {
            //
            // Fire Disk Terminate Event
            //
            SetEvent( DisksTerminateEvent ) ;
            CloseHandle( DisksTerminateEvent );
            DisksTerminateEvent = NULL;
        }
        LeaveCriticalSection( &DisksLock );
    }

    if ( ERROR_SUCCESS == status ) {
    
        LPWSTR newSerialNumber = NULL;
        DWORD newSerNumLen = 0;
        DWORD oldSerNumLen = 0;
        
        DisksProcessMountPointInfo( ResourceEntry );

        // Validate serial number.

        status = GetSerialNumber( ResourceEntry->DiskInfo.Params.Signature,
                                  &newSerialNumber );

        if ( NO_ERROR == status && newSerialNumber ) {
            newSerNumLen = wcslen( newSerialNumber );
            
            if ( ResourceEntry->DiskInfo.Params.SerialNumber ) {
                oldSerNumLen = wcslen( ResourceEntry->DiskInfo.Params.SerialNumber );
            }
    
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, Old SerNum (%1!ws!)   Old SerNumLen (%2!d!) \n",
                ResourceEntry->DiskInfo.Params.SerialNumber,
                oldSerNumLen
                );
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, New SerNum (%1!ws!)   New SerNumLen (%2!d!) \n",
                newSerialNumber,
                newSerNumLen
                );

            if ( 0 == oldSerNumLen || 
                 NULL == ResourceEntry->DiskInfo.Params.SerialNumber ||
                 newSerNumLen != oldSerNumLen ||
                 ( 0 != wcsncmp( ResourceEntry->DiskInfo.Params.SerialNumber,
                               newSerialNumber,
                               newSerNumLen ) ) ) {

                // Need to log an error?
                
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"Online, disk serial number has changed.  Saving new serial number.\n" );
                
                // Free existing serial number and update serial number.

                if ( ResourceEntry->DiskInfo.Params.SerialNumber ) {
                    LocalFree( ResourceEntry->DiskInfo.Params.SerialNumber );
                }

                ResourceEntry->DiskInfo.Params.SerialNumber = newSerialNumber;
                newSerialNumber = NULL;
                
                // User MP thread to post info into registry.
                
                PostMPInfoIntoRegistry( ResourceEntry );
            }
        }
        
        if ( newSerialNumber ) {
            LocalFree( newSerialNumber );
        }
        
        // Reset status to success so online completes.
        
        status = ERROR_SUCCESS;
    }

exit:

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, setting ResourceState %1!u! .\n",
        resourceStatus.ResourceState );

    (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                             &resourceStatus );

    if ( fileHandle != NULL)  {
        CloseHandle( fileHandle );
    }

    if (status == ERROR_SUCCESS) {
        WatchDisk(ResourceEntry);
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, returning final error %1!u!   ResourceState %2!u!  Valid %3!x! \n",
        status,
        resourceStatus.ResourceState,
        ResourceEntry->Valid );

    return(status);

} // DisksOnlineThread


DWORD
DisksOpenResourceFileHandle(
    IN PDISK_RESOURCE ResourceEntry,
    IN PWCHAR         InfoString, 
    OUT PHANDLE       fileHandle OPTIONAL
    )
/*++

Routine Description:

    Open a file handle for the resource.
    It performs the following steps:
      1. Read Disk signature from cluster registry
      2. Attaches clusdisk driver to a disk with this signature
      3. Gets Harddrive no from ClusDisk driver 
      4. Opens \\.\PhysicalDrive%d device and returns the handle

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.
    
    InfoString - Supplies a label to be printed with error messages
    
    fileHandle - receives file handle


Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    DWORD       status;
    UCHAR       deviceName[MAX_PATH];
    HKEY        signatureKey = NULL;
    PCHAR       diskName;
    PWCHAR      signature;
    DWORD       count;
    WCHAR       wDeviceName[MAX_PATH];
    LPWSTR      nameOfPropInError;
    UCHAR       resourceString[MAX_PATH];

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb]------- Disks%1!ws! -------.\n", InfoString);
    
    //
    // Read our disk signature from the resource parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ResourceParametersKey,
                                                   DiskResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"%3!ws!: Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status, InfoString );
        return(status);
    }

    //
    // Try to attach to this device.
    //
    status = DoAttach( ResourceEntry->DiskInfo.Params.Signature,
                       ResourceEntry->ResourceHandle );
    if ( status != ERROR_SUCCESS ) {
        WCHAR Signature[9];
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"%3!ws!: Unable to attach to signature %1!lx!. Error: %2!u!.\n",
            ResourceEntry->DiskInfo.Params.Signature,
            status, InfoString );

        // Added this event message back in as replication has been changed (regroup
        // shouldn't be blocked now).
        
        wsprintfW( Signature, L"%08lX", ResourceEntry->DiskInfo.Params.Signature );
        ClusResLogSystemEventByKey1(ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_MISSING,
                                    Signature);
        return(status);
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb]DisksOpenResourceFileHandle: Attach successful.\n");
        
    //
    // Now open the signature key under ClusDisk.
    //

    sprintf( resourceString, "%08lX", ResourceEntry->DiskInfo.Params.Signature );

    status = RegOpenKeyEx( ResourceEntry->ClusDiskParametersKey,
                           resourceString,
                           0,
                           KEY_READ,
                           &signatureKey );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"%3!ws!: Unable to open ClusDisk signature key %1!lx!. Error: %2!u!.\n",
            ResourceEntry->DiskInfo.Params.Signature,
            status, InfoString );
            return(status);
    }

    //
    // Read our disk name from ClusDisk.
    //

    diskName = GetRegParameter(signatureKey, "DiskName");

    RegCloseKey( signatureKey );

    if ( diskName == NULL ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"%1!ws!: Unable to read disk name.\n", InfoString );
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Parse disk name to find disk drive number.
    //
    count = sscanf( diskName, DiskName, &ResourceEntry->DiskInfo.PhysicalDrive );
    // count is zero if failed! Otherwise count of parsed values.

    LocalFree(diskName);

    if (count == 0) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"%1!ws!: Unable to parse disk name.\n", InfoString );
       return ERROR_INVALID_PARAMETER;
    }
    //
    // Build device string for CreateFile
    //
    if ( fileHandle ) {
        sprintf( deviceName, "\\\\.\\PhysicalDrive%d", ResourceEntry->DiskInfo.PhysicalDrive );

        *fileHandle = CreateFile( deviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL );
        if ( (*fileHandle == INVALID_HANDLE_VALUE) ||
             (*fileHandle == NULL) ) {
            status = GetLastError();
            mbstowcs( wDeviceName, deviceName, strlen(deviceName) );
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%3!ws!: error opening device '%1!ws!'. Error: %2!u!\n",
                wDeviceName,
                status, InfoString );
            return(status);
        }
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb]DisksOpenResourceFileHandle: CreateFile successful.\n");
        
    return(ERROR_SUCCESS);
} // DisksOpenResourceFileHandle



DWORD
DiskspSsyncDiskInfo(
    IN PWCHAR InfoLabel,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  Options
    )
/*++

Routine Description:

    Restores the disk registry information
    if necessary.

Arguments:

    InfoLabel - Supplies a label to be printed with error messages

    ResourceEntry - Supplies the disk resource structure.

    Options - 0 or combination of the following:
    
        MOUNTIE_VALID: ResourceEntry contains up to date MountieInfo.
                       If this flag is not set, MountieInfo will be recomputed
                       
        MOUNTIE_THREAD: If ERROR_SHARING_PAUSED prevents updating cluster registry,
                        launch a thread to do it later
                        
        MOUNTIE_QUIET: Quiet mode. Less noise in logs.
                       

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
   DWORD status;
   DWORD errorLevel;
   
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"%1!ws!: sync disk registry info \n",
        InfoLabel );
   
   if ( !(Options & MOUNTIE_VALID) ) {
      HANDLE fileHandle;
      status = DisksOpenResourceFileHandle(ResourceEntry, InfoLabel, &fileHandle);
      if (status != ERROR_SUCCESS) {
         return status;
      }
      status = MountieRecreateVolumeInfoFromHandle(fileHandle, 
                                       ResourceEntry->DiskInfo.PhysicalDrive,
                                       ResourceEntry->ResourceHandle,
                                       &ResourceEntry->MountieInfo);
      CloseHandle(fileHandle);
      if (status != ERROR_SUCCESS) {
         if ( !(Options & MOUNTIE_QUIET) ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%1!ws!: MountieCreateFromHandle failed, error: %2!u!\n",
                InfoLabel, status );
         }
         return status;
      }
   }

   status = MountieVerify(&ResourceEntry->MountieInfo, ResourceEntry, FALSE);
   if (status != ERROR_SUCCESS) {
      if ( !(Options & MOUNTIE_QUIET) ) {

         if ( !DisksGetLettersForSignature( ResourceEntry ) ) {
             // No drive letters, we are using mount points and this is not an error.
             errorLevel = LOG_WARNING;
         } else {
             // Drive letters exist, this is likely an error.
             errorLevel = LOG_ERROR;
         }

         (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             errorLevel,
             L"%1!ws!: MountieVerify failed, error: %2!u! \n",
             InfoLabel, status );
      }
   }


   status = MountieUpdate(&ResourceEntry->MountieInfo, ResourceEntry);
   if (status != ERROR_SUCCESS) {
      if (status != ERROR_SHARING_PAUSED) {
         if ( !(Options & MOUNTIE_QUIET) ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%1!ws!: MountieUpdate failed, error: %2!u!\n",
                InfoLabel, status );
         }
         return status;
      }

      if ( Options & MOUNTIE_THREAD ) {

         if ( InterlockedCompareExchange(
                &ResourceEntry->MountieInfo.UpdateThreadIsActive,
                1, 0) 
            )
         {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%1!ws!: update thread is already running.\n",
                InfoLabel );
            status = ERROR_ALREADY_EXISTS;
         
         } else {
            HANDLE thread;
            DWORD threadId;


            thread = CreateThread( NULL,
                                   0,
                                   DisksSetDiskInfoThread,
                                   ResourceEntry,
                                   0,
                                   &threadId );
            if ( thread == NULL ) {
                status = GetLastError();
                if ( !(Options & MOUNTIE_QUIET) ) {
                   (DiskpLogEvent)(
                       ResourceEntry->ResourceHandle,
                       LOG_ERROR,
                       L"%1!ws!: CreateThread failed, error: %2!u!\n",
                       InfoLabel, status );
                }
                InterlockedExchange(
                  &ResourceEntry->MountieInfo.UpdateThreadIsActive, 0);
            } else {
               CloseHandle( thread );
               status = ERROR_SUCCESS;
            }
         }

      }
   }

   return status;

} // DiskspSsyncDiskInfo



DWORD
DisksIsVolumeDirty(
    IN PWCHAR         DeviceName,
    IN PDISK_RESOURCE ResourceEntry,
    OUT PBOOL         Dirty
    )
/*++

Routine Description:

    This routine opens the given nt drive and sends down
    FSCTL_IS_VOLUME_DIRTY to determine the state of that volume's
    dirty bit.

Arguments:

    DeviceName      -- name of the form: 
                       \Device\HarddiskX\PartitionY    [Note: no trailing backslash]
                       
    Dirty           -- receives TRUE if the dirty bit is set

Return Value:

    dos error code

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    DWORD               status;
    NTSTATUS            ntStatus;
    IO_STATUS_BLOCK     iosb;
    HANDLE              fileHandle;
    DWORD               result = 0;
    DWORD               bytesReturned;

    ntStatus = DevfileOpen( &fileHandle, DeviceName );

    if ( !NT_SUCCESS(ntStatus) ) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Error opening %1!ws!, error %2!x!.\n",
           DeviceName, ntStatus );
       return RtlNtStatusToDosError(ntStatus);
    }

    status = ERROR_SUCCESS;
    if ( !DeviceIoControl( fileHandle,
                           FSCTL_IS_VOLUME_DIRTY,
                           NULL,
                           0,
                           &result,
                           sizeof(result),
                           &bytesReturned,
                           NULL ) ) {
        status = GetLastError();
        (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"FSCTL_IS_VOLUME_DIRTY for volume %1!ws! returned error %2!u!.\n",
                DeviceName, status );
    }

    DevfileClose( fileHandle );
    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    if (result & VOLUME_IS_DIRTY) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_INFORMATION,
           L"DisksIsVolumeDirty: Volume is dirty \n");
        *Dirty = TRUE;
    } else {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_INFORMATION,
           L"DisksIsVolumeDirty: Volume is clean \n");
        *Dirty = FALSE;
    }
    return ERROR_SUCCESS;

} // DisksIsVolumeDirty


#define IS_SPECIAL_DIR(x)  ( (x)[0]=='.' && ( (x)[1]==0 || ( (x)[1]=='.'&& (x)[2] == 0) ) )
#define FA_SUPER_HIDDEN    (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)
#define IS_SUPER_HIDDEN(x) ( ((x) & FA_SUPER_HIDDEN) == FA_SUPER_HIDDEN )

#define DISKP_CHECK_PATH_BUF_SIZE (MAX_PATH)

typedef struct _DISKP_CHECK_PATH_DATA {
    WCHAR FileName[DISKP_CHECK_PATH_BUF_SIZE];
    WIN32_FIND_DATAW FindData;
    PDISK_RESOURCE   ResourceEntry;
    BOOL             OpenFiles;
    DWORD            FileCount;
    DWORD            Level;
    BOOL             LogFileNotFound;
} DISKP_CHECK_PATH_DATA, *PDISKP_CHECK_PATH_DATA;


DWORD
DiskspCheckPathInternal(
    IN OUT PDISKP_CHECK_PATH_DATA data,
    IN DWORD FileNameLength
)

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    HANDLE FindHandle;
    DWORD Status;
    DWORD i, len;
    DWORD adjust;

    if ( !FileNameLength ) {
        return ERROR_INVALID_DATA;
    }
    
    data->FileName[FileNameLength] = 0; 
    
    //
    // GetFileAttributes must use a trailing slash on the Volume{GUID} name.
    //
    
    Status = GetFileAttributesW(data->FileName);
    if (Status == 0xFFFFFFFF) {
        Status = GetLastError();
        (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"DiskspCheckPath: GetFileAttrs(%1!s!) returned status of %2!d!.\n",
                        data->FileName,
                        Status);
        return Status;
    }
    Status = ERROR_SUCCESS;
        
    if ( data->FileName[FileNameLength - 1] == L'\\' ) {

        //
        // If path ends in backslash, simply add the asterisk.
        //
        
        if ( FileNameLength + 1 >= DISKP_CHECK_PATH_BUF_SIZE ) {
            (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskspCheckPath: FileNameLength > buffer size (#1) \n" );
            return(ERROR_ALLOTTED_SPACE_EXCEEDED);
        }
    
        data->FileName[FileNameLength + 0] = '*'; 
        data->FileName[FileNameLength + 1] = 0; 
        
        adjust = 0;
        
    } else {
    
        if ( FileNameLength + 2 >= DISKP_CHECK_PATH_BUF_SIZE ) {
            (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskspCheckPath: FileNameLength > buffer size (#2) \n" );
            return(ERROR_ALLOTTED_SPACE_EXCEEDED);
        }
    
        data->FileName[FileNameLength + 0] = '\\'; 
        data->FileName[FileNameLength + 1] = '*'; 
        data->FileName[FileNameLength + 2] = 0; 
        
        adjust = 1;
    }

    FindHandle = FindFirstFileW(data->FileName, &data->FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        if (Status != ERROR_FILE_NOT_FOUND || data->LogFileNotFound) {
            (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskspCheckPath: fff(%1!s!) returned status of %2!d!.\n",
                            data->FileName,
                            Status);
        }
        if (Status == ERROR_FILE_NOT_FOUND) {
            Status = ERROR_EMPTY;
        }
        return Status;
    }
    
    ++ data->Level;
    ++ data->FileCount;
    
    if (data->OpenFiles) {
        do {
            if ( data->ResourceEntry->OnlineThread.Terminate ) {
                // Returning SUCCESS means that we've closed all
                // FindFile handles.
                return(ERROR_SHUTDOWN_CLUSTER);
            }
            if ( IS_SPECIAL_DIR(data->FindData.cFileName ) 
              || IS_SUPER_HIDDEN(data->FindData.dwFileAttributes) )
            {
                continue;
            }
            len = wcslen(data->FindData.cFileName);
            if (FileNameLength + len + 1 >= DISKP_CHECK_PATH_BUF_SIZE ) {
                return(ERROR_ALLOTTED_SPACE_EXCEEDED);
            }
            MoveMemory(data->FileName + FileNameLength + adjust, 
                       data->FindData.cFileName, 
                       sizeof(WCHAR) * (len + 1) );
            
            if ( data->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) { 
                
                Status = DiskspCheckPathInternal(data, FileNameLength + len + adjust);
                if (Status != ERROR_SUCCESS) {
                    goto exit;
                }
            } else {
                HANDLE FileHandle;
                //
                // Open with the same parameters that LogpCreate uses to try to catch quorum
                // log corruption during online.
                //
                // We previously used OPEN_EXISTING parameter.  Try OPEN_ALWAYS to match exactly what
                // LogpCreate is using.  
                //
                
                FileHandle = CreateFileW(data->FileName,
                                         GENERIC_READ | GENERIC_WRITE,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,       
                                         FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                                         NULL );
                if ( FileHandle == INVALID_HANDLE_VALUE ) {
                    Status = GetLastError();
                    (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                                        LOG_ERROR,
                                        L"DiskspCheckPath: Open %1!ws! failed, status %2!d!.\n",
                                        data->FileName, 
                                        Status
                                        );
                    if (Status != ERROR_SHARING_VIOLATION) {
                        goto exit;
                    }
                } else {
                    
                    (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                                        LOG_INFORMATION,
                                        L"DiskspCheckPath: Open %1!ws! succeeded. \n",
                                        data->FileName
                                        );

                    CloseHandle( FileHandle );
                }
            }
            ++(data->FileCount);
        } while ( FindNextFileW( FindHandle, &data->FindData ) );
        --(data->FileCount);
        Status = GetLastError();
        if (Status != ERROR_NO_MORE_FILES) {
            (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskspCheckPath: fnf(%1!s!) returned status of %2!d!.\n",
                            data->FileName,
                            Status);
        } else {
            Status = ERROR_SUCCESS;
        }
    }
exit:
    FindClose(FindHandle);
    --(data->Level);
    return Status;
} // DiskspCheckPathInternal
    


DWORD
DiskspCheckPath(
    IN LPWSTR VolumeName,
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL OpenFiles,
    IN BOOL LogFileNotFound
    )
/*++

Routine Description:

    Checks out a drive letter to see if the filesystem has mounted
    it and it's working. We will also run CHKDSK if the partition/certain
    files are Corrupt

Arguments:

    VolumeName - Supplies the device name of the form: 
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the disk resource entry.

    OpenFiles - Span subdirectories and open files if TRUE.
    
    Online - FILE_NOT_FOUND error is logged if TRUE

Return Value:

    ERROR_SUCCESS if no corruption or corruption was found and corrected.

    Win32 error code otherwise
    
--*/

{
    DISKP_CHECK_PATH_DATA data;
    DWORD                 len;
    DWORD                 status;
    ZeroMemory( &data, sizeof(data) );
    
    data.OpenFiles = OpenFiles;
    data.LogFileNotFound = LogFileNotFound;
    data.ResourceEntry = ResourceEntry;

    len = wcslen( VolumeName );
    if (len >= DISKP_CHECK_PATH_BUF_SIZE) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"DiskspCheckPath: VolumeName length > buffer size \n" );
        return ERROR_ALLOTTED_SPACE_EXCEEDED;
    }
    wcsncpy(data.FileName, VolumeName, DISKP_CHECK_PATH_BUF_SIZE);

    //
    // Send the path with trailing backslash to DiskspCheckPathInternal.
    //

    status = DiskspCheckPathInternal( &data, len );
    data.FileName[len] = 0;

    if (status != ERROR_SUCCESS || data.FileCount == 0) {
        if (status != ERROR_EMPTY || data.LogFileNotFound) {
            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskspCheckPath: DCPI(%1!s!) returned status of %2!d!, files scanned %3!d!.\n",
                            data.FileName, status, data.FileCount);
        }
        
        if ( (status == ERROR_DISK_CORRUPT) ||
             (status == ERROR_FILE_CORRUPT) ) 
        {
            
            if ( ResourceEntry->OnlineThread.Terminate ) {
                return(ERROR_SHUTDOWN_CLUSTER);
            }
            // Should FixCorruption take forever?  For now, "yes".
            status = DisksFixCorruption( VolumeName,
                                         ResourceEntry,
                                         status );
            if ( status != ERROR_SUCCESS ) {
                (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                                LOG_ERROR,
                                L"DiskspCheckPath: FixCorruption for drive <%1!ws!:> returned status of %2!d!.\n",
                                VolumeName,
                                status);
            }
        } else {
            // Some other error 
            // Assume that the error is benign if data.FileCount > 0
            // ERROR_FILE_NOT_FOUND will be returned if there is no files on the volume
            if (data.FileCount > 0 || status == ERROR_EMPTY) {
                status = ERROR_SUCCESS;
            }
        }
    }
    return status;
} // DiskspCheckPath

     
DWORD
WaitForVolumes(
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  timeOutInSeconds
    )
{
    PMOUNTIE_PARTITION entry;
    
    DWORD retryInterval = 2000;
    DWORD retries = timeOutInSeconds / (retryInterval / 1000);
    
    DWORD i;
    DWORD partMap;
    DWORD tempPartMap;
    DWORD status;
    DWORD nPartitions = MountiePartitionCount( &ResourceEntry->MountieInfo );
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;

    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];

    //
    // Check drive letters, if any.  If no drive letters, check only volumes.
    // If drive letters, we still fall through and check volumes.
    //
    
    status = WaitForDriveLetters( DisksGetLettersForSignature( ResourceEntry ),
                                  ResourceEntry,
                                  30                // seconds timeout
                                  );

    if ( NO_ERROR != status ) {
        return status;
    }
    
    //
    // Make sure the partition count is not too large for the bitmap.
    //

    if ( nPartitions > ( sizeof(partMap) * 8 ) ) {

        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"WaitForVolumes: Partition count (%1!u!) greater than bitmap (%2!u!) \n",
                        nPartitions, sizeof(partMap) );

        return ERROR_INVALID_DATA;    
    }

    //
    // Convert the partition count to a bitmap.  
    //
    
    partMap = 0;
    for (i = 0; i < nPartitions; i++) {
        partMap |= (1 << i);
    }
    
    while ( TRUE ) {
        
        tempPartMap = partMap;
            
        for ( i = 0; tempPartMap; i++ ) {
        
            if ( (1 << i) & tempPartMap ) {
                
                tempPartMap &= ~(1 << i);

                entry = MountiePartition( &ResourceEntry->MountieInfo, i );
        
                if ( !entry ) {
                    (DiskpLogEvent)(
                          ResourceEntry->ResourceHandle,
                          LOG_ERROR,
                          L"WaitForVolumes no partition entry for partition %1!u! \n", i );
                    
                    // 
                    // Something bad happened to our data structures.  We want to keep checking
                    // each of the other partitions.
                    
                    continue;
                }
                
                //
                // Given the DiskPartName, get the VolGuid name.  This name must have a trailing
                // backslash to work correctly.
                //
        
                _snwprintf( szGlobalDiskPartName,
                            MAX_PATH,
                            GLOBALROOT_HARDDISK_PARTITION_FMT, 
                            physicalDrive,
                            entry->PartitionNumber );

                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_INFORMATION,
                      L"WaitForVolumes: Calling GetVolumeNameForVolumeMountPoint for %1!ws! \n", 
                      szGlobalDiskPartName );

                if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                         szVolumeName,
                                                         sizeof(szVolumeName)/sizeof(WCHAR) )) {
                                                         
                    status = GetLastError();
            
                    (DiskpLogEvent)(
                          ResourceEntry->ResourceHandle,
                          LOG_ERROR,
                          L"WaitForVolumes: GetVolumeNameForVolumeMountPoint for %1!ws! returned %2!u!\n", 
                          szGlobalDiskPartName,
                          status );

                    // 
                    // Disk is corrupt.  Immediately return an error so chkdsk can run during
                    // online processing.
                    //
                    
                    if ( ERROR_DISK_CORRUPT == status || ERROR_FILE_CORRUPT == status ) {
                        return status;
                    }
                    
                    // 
                    // Something bad happened.  Continue with the next partition.
                    
                    continue;
                }

                status = DiskspCheckPathLite( szVolumeName, ResourceEntry );

                switch (status) {
                case ERROR_SUCCESS: 
                case ERROR_EMPTY:
                    // Not an error 
                    // Clear this partition number from the check list
                    partMap &= ~(1 << i);
                    break;
                case ERROR_FILE_NOT_FOUND: 
                case ERROR_INVALID_PARAMETER:
                    // This is an error we expect to get when the volume
                    // wasn't mounted yet
                    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                                    LOG_ERROR,
                                    L"WaitForVolumes: Volume (%1!ws!) file system not mounted (%2!u!) \n",
                                    szVolumeName, status );
                    break;
                default:
                    // This is not an error we expect.
                    // Probably something is very wrong with the system
                    // bail out
                    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                                    LOG_ERROR,
                                    L"WaitForVolumes: Volume (%1!ws!) returns (%2!u!) \n",
                                    szVolumeName, status );
                    return status; 
                }
            }
        }
        
        if ( !partMap ) {
            // All partitions are verified //
            return ERROR_SUCCESS;
        }
        if ( retries-- == 0 ) {
            return status;
        }
        Sleep(retryInterval);
            
    }

    return ERROR_SUCCESS;
                                                
}   // WaitForVolumes


DWORD
DiskspCheckPathLite(
    IN LPWSTR VolumeName,
    IN PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Checks out a disk partition to see if the filesystem has mounted
    it and it's working. 

Arguments:

    VolumeName - Supplies the device name of the form: 
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the disk resource entry.

Return Value:

    ERROR_SUCCESS if no corruption or corruption was found and corrected.

    Win32 error code otherwise
    
--*/

{
    DISKP_CHECK_PATH_DATA data;
    DWORD                 len;
    DWORD                 status;
    
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DiskspCheckPathLite: Volume name %1!ws! \n", 
          VolumeName );
    
    ZeroMemory( &data, sizeof(data) );
    
    data.OpenFiles = FALSE;
    data.LogFileNotFound = FALSE;
    data.ResourceEntry = ResourceEntry;

    len = wcslen( VolumeName );
    if (len >= DISKP_CHECK_PATH_BUF_SIZE) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"DiskspCheckPathLite: VolumeName length > buffer size \n" );
        return ERROR_ALLOTTED_SPACE_EXCEEDED;
    }
    wcsncpy(data.FileName, VolumeName, DISKP_CHECK_PATH_BUF_SIZE);
    
    //
    // Send the path with trailing backslash to DiskspCheckPathInternal.
    //
        
    status = DiskspCheckPathInternal( &data, len );

    return status;
    
}   // DiskspCheckPathLite


DWORD
DiskspCheckDriveLetter(
    IN WCHAR  DriveLetter,
    IN PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Checks out a drive letter to see if the filesystem has mounted
    it and it's working. This is lightweight version of DiskspCheckPath

Arguments:

    DriveLetter - Supplies find first file failed

    ResourceEntry - Supplies a pointer to the disk resource entry.

Return Value:

    ERROR_SUCCESS or
    Win32 error code otherwise
    
--*/

{
    DISKP_CHECK_PATH_DATA data;
    DWORD                 len;
    DWORD                 status;
    ZeroMemory( &data, sizeof(data) );
    
    data.OpenFiles = FALSE;
    data.LogFileNotFound = FALSE;
    data.ResourceEntry = ResourceEntry;

    data.FileName[0] = DriveLetter;
    data.FileName[1] = L':';
    // data->FileName is zero initialized  data->FileName[2] = 0 //
    len = 2;

    status = DiskspCheckPathInternal( &data, len );
    
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DiskspCheckDriveLetter: Checking drive name (%1!ws!) returns %2!u! \n", 
          data.FileName,
          status );
    
    return status;
} // DiskspCheckDriveLetter


DWORD
WaitForDriveLetters(
    IN DWORD DriveLetters,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  timeOutInSeconds
    )
{
    DWORD retryInterval = 2000;
    DWORD retries = timeOutInSeconds / (retryInterval / 1000);
    
    if ( !DriveLetters ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"WaitForDriveLetters: No drive letters for volume, skipping drive letter check \n" );
        return ERROR_SUCCESS;
    }
    
    for(;;) {
        DWORD tempDriveLetters = DriveLetters;
        UINT  i = 0;
        DWORD status = ERROR_SUCCESS;

        while (tempDriveLetters) {
            if ( (1 << i) & tempDriveLetters ) {
                tempDriveLetters &= ~(1 << i);
                status = DiskspCheckDriveLetter( (WCHAR)(i + L'A'), ResourceEntry);
                switch (status) {
                case ERROR_SUCCESS: 
                case ERROR_EMPTY:
                    // Not an error 
                    // Clear this drive letter from the check list
                    DriveLetters &= ~(1 << i);
                    break;
                case ERROR_FILE_NOT_FOUND: 
                case ERROR_INVALID_PARAMETER:
                    // This is an error we expect to get when the volume
                    // wasn't mounted yet
                    break;
                default:
                    // This is not an error we expect.
                    // Probably something is very wrong with the system
                    // bail out
                    return status; 
                }
            }
            ++i;
        }
        if (!DriveLetters) {
            // All drive letters are verified //
            return ERROR_SUCCESS;
        }
        if (retries-- == 0) {
            return status;
        }
        Sleep(retryInterval);
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\extdll\dll\passthru.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define BOOT_SECTOR_SIZE    512



BOOLEAN
WINAPI
PassThruDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
/*++

Routine Description:

    Main DLL entrypoint

Arguments:

    DllHandle - Supplies the DLL handle.

    Reason - Supplies the call reason

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
   switch ( Reason ) {

   case DLL_PROCESS_ATTACH:
      // DLL is attaching to the address
      // space of the current process.

      break;

   case DLL_THREAD_ATTACH:
      // A new thread is being created in the current process.
      break;

   case DLL_THREAD_DETACH:
      // A thread is exiting cleanly.
      break;

   case DLL_PROCESS_DETACH:
      // The calling process is detaching
      // the DLL from its address space.

      break;
   }

   return(TRUE);
}


DWORD
WINAPI
TestDllGetBootSector(
    IN LPSTR DeviceName,
    IN LPSTR ContextStr,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    HANDLE  hDisk = NULL;
    
    DWORD   dwStatus = NO_ERROR;
    
    UNREFERENCED_PARAMETER( ContextStr );
    
    if ( !DeviceName || !OutBuffer || !BytesReturned ) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    if ( OutBufferSize < BOOT_SECTOR_SIZE ) {
        *BytesReturned = BOOT_SECTOR_SIZE;
        dwStatus = ERROR_MORE_DATA;
        goto FnExit;    
    }
    
    //
    // Open a handle to the disk drive.
    //

    hDisk = CreateFile( DeviceName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        0,                               // No security attributes
                        OPEN_EXISTING,
                        FILE_FLAG_NO_BUFFERING,
                        NULL                             // No template file
                        );


    if ( INVALID_HANDLE_VALUE ==  hDisk ) {
        dwStatus = GetLastError();
        goto FnExit;
    }

    //
    // Clear out the array holding the boot sector.
    //

    ZeroMemory( OutBuffer, BOOT_SECTOR_SIZE );

    //
    // Read the boot sector.
    //

    if ( !ReadFile( hDisk,
                    OutBuffer,
                    BOOT_SECTOR_SIZE,
                    BytesReturned,
                    NULL
                    ) ) {

        dwStatus = GetLastError();
        goto FnExit;
    }

    if ( *BytesReturned != BOOT_SECTOR_SIZE ) {
        dwStatus = ERROR_BAD_LENGTH;
        goto FnExit;
    }

FnExit:

    if ( hDisk ) {
        CloseHandle( hDisk );
    }
    
    return dwStatus;
    

}   // TestDllGetBootSector


DWORD
WINAPI
TestDllReturnContextAsError(
    IN LPSTR DeviceName,
    IN LPSTR ContextStr,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    DWORD   dwStatus = NO_ERROR;
    
    UNREFERENCED_PARAMETER( DeviceName );
    UNREFERENCED_PARAMETER( OutBuffer );
    UNREFERENCED_PARAMETER( OutBufferSize );

    if ( !BytesReturned ) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    *BytesReturned = 0;

    //
    // Convert context string to a DWORD value.  Note that
    // strtol will return zero if it can't convert the string.
    // Zero happens to be NO_ERROR.
    //
    
    dwStatus = strtol( ContextStr, NULL, 10 );
    
FnExit:
    
    return dwStatus;

}   // TestDllReturnContextAsError


DWORD
WINAPI
TestDllNotEnoughParms(
    IN LPSTR DeviceName
    )
{
    //
    // This routine _should_ fail and possibly cause a stack exception.
    //
    
    UNREFERENCED_PARAMETER( DeviceName );

    return NO_ERROR;    

}   // TestDllNotEnoughParms

       
DWORD
WINAPI
TestDllTooManyParms(
    IN LPSTR DeviceName,
    IN LPSTR ContextStr,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    IN PVOID Nada1,
    IN PVOID Nada2,
    IN PVOID Nada3
    )
{
    //
    // This routine _should_ fail and possibly cause a stack exception.
    //
    
    UNREFERENCED_PARAMETER( DeviceName );
    UNREFERENCED_PARAMETER( ContextStr );
    UNREFERENCED_PARAMETER( OutBuffer );
    UNREFERENCED_PARAMETER( OutBufferSize );
    UNREFERENCED_PARAMETER( BytesReturned );
    UNREFERENCED_PARAMETER( Nada1 );
    UNREFERENCED_PARAMETER( Nada2 );
    UNREFERENCED_PARAMETER( Nada3 );

    return NO_ERROR;
    
}   // TestDllTooManyParms
    
    
DWORD
WINAPI
TestDllCauseException(
    IN LPSTR DeviceName,
    IN LPSTR ContextStr,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    DWORD   x = 0;
    DWORD   y;
    
    UNREFERENCED_PARAMETER( DeviceName );
    UNREFERENCED_PARAMETER( ContextStr );
    UNREFERENCED_PARAMETER( OutBuffer );
    UNREFERENCED_PARAMETER( OutBufferSize );
    UNREFERENCED_PARAMETER( BytesReturned );

    //
    // How about divide by zero?
    //
    
    y = 7 / x;
    
    return NO_ERROR;

}   // CauseException
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummy\dummy.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//
//		Dummy.cpp
//
//	Abstract:
//
//		Resource DLL for Dummy (Dummy).
//
//	Author:
//
//		Galen Barbee (galenb)	Sept 03, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma comment(lib, "clusapi.lib")
#pragma comment(lib, "resutils.lib")

#define UNICODE 1

#pragma warning( disable : 4115 )	// named type definition in parentheses
#pragma warning( disable : 4201 )	// nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )	// nonstandard extension used : bit field types other than int

#include <windows.h>

#pragma warning( default : 4214 )	// nonstandard extension used : bit field types other than int
#pragma warning( default : 4201 )	// nonstandard extension used : nameless struct/union
#pragma warning( default : 4115 )	// named type definition in parentheses

#include <clusapi.h>
#include <resapi.h>
#include <stdio.h>

//
// Type and constant definitions.
//
#define DUMMY_RESNAME	L"Dummy"
#define DBG_PRINT		printf

#define MAX_WAIT		(10000)			 // wait for 10 seconds

#define DUMMY_FLAG_VALID	0x00000001
#define DUMMY_FLAG_ASYNC	0x00000002		// Asynchronous failure mode
#define DUMMY_FLAG_PENDING	0x00000004		// Pending mode on shutdown

#define AsyncMode(Resource)		 (Resource->Flags &	DUMMY_FLAG_ASYNC)
#define PendingMode(Resource)		(Resource->Flags &	DUMMY_FLAG_PENDING)
#define EnterAsyncMode(Resource)	(Resource->Flags |= DUMMY_FLAG_ASYNC)

#define DummyAcquireResourceLock(_res)	EnterCriticalSection(&((_res)->Lock))
#define DummyReleaseResourceLock(_res)	LeaveCriticalSection(&((_res)->Lock))

#define DummyAcquireGlobalLock()	\
			{						\
				DWORD status;		\
				status = WaitForSingleObject( DummyGlobalMutex, INFINITE );	\
			}

#define DummyReleaseGlobalLock()	\
			{						\
				BOOLEAN released;	\
				released = ReleaseMutex( DummyGlobalMutex );	\
			}

//
// ADDPARAM: Add new parameters here.
//
#define PARAM_NAME__PENDING		 L"Pending"
#define PARAM_NAME__PENDTIME		L"PendTime"
#define PARAM_NAME__OPENSFAIL		L"OpensFail"
#define PARAM_NAME__FAILED			L"Failed"
#define PARAM_NAME__ASYNCHRONOUS	L"Asynchronous"

#define PARAM_MIN__PENDING			(0)
#define PARAM_MAX__PENDING			(1)
#define PARAM_DEFAULT__PENDING		(0)
#define PARAM_MIN__PENDTIME		 (0)
#define PARAM_MAX__PENDTIME		 (4294967295)
#define PARAM_DEFAULT__PENDTIME	 (0)
#define PARAM_MIN__OPENSFAIL		(0)
#define PARAM_MAX__OPENSFAIL		(1)
#define PARAM_DEFAULT__OPENSFAIL	(0)
#define PARAM_MIN__FAILED			(0)
#define PARAM_MAX__FAILED			(1)
#define PARAM_DEFAULT__FAILED		(0)
#define PARAM_MIN__ASYNCHRONOUS	 (0)
#define PARAM_MAX__ASYNCHRONOUS	 (1)
#define PARAM_DEFAULT__ASYNCHRONOUS (0)

typedef enum TimerType
{
	TimerNotUsed = 0,
	TimerErrorPending,
	TimerOnlinePending,
	TimerOfflinePending
};

//
// ADDPARAM: Add new parameters here.
//
typedef struct _DUMMY_PARAMS
{
	DWORD	Pending;
	DWORD	PendTime;
	DWORD	OpensFail;
	DWORD	Failed;
	DWORD	Asynchronous;
} DUMMY_PARAMS, *PDUMMY_PARAMS;

typedef struct _DUMMY_RESOURCE
{
	RESID					ResId; // for validation
	DUMMY_PARAMS			Params;
	HKEY					ParametersKey;
	RESOURCE_HANDLE		 ResourceHandle;
	LPWSTR					ResourceName;
	CLUS_WORKER			 OnlineThread;
	CLUS_WORKER			 OfflineThread;
	CLUSTER_RESOURCE_STATE	State;
	DWORD					Flags;
	HANDLE					SignalEvent;
	HANDLE					TimerThreadWakeup;
	DWORD					TimerType;
	CRITICAL_SECTION		Lock;
} DUMMY_RESOURCE, *PDUMMY_RESOURCE;

//
// Global data.
//

// Sync Mutex

HANDLE	DummyGlobalMutex = NULL;

// Event Logging routine.

PLOG_EVENT_ROUTINE g_LogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_DummyFunctionTable;

//
// Dummy resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
DummyResourcePrivateProperties[] =
{
	{ PARAM_NAME__PENDING,		NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__PENDING,		PARAM_MIN__PENDING,		 PARAM_MAX__PENDING,		 0, FIELD_OFFSET(DUMMY_PARAMS,Pending) },
	{ PARAM_NAME__PENDTIME,	 NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__PENDTIME,		PARAM_MIN__PENDTIME,		PARAM_MAX__PENDTIME,		0, FIELD_OFFSET(DUMMY_PARAMS,PendTime) },
	{ PARAM_NAME__OPENSFAIL,	NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__OPENSFAIL,		PARAM_MIN__OPENSFAIL,		PARAM_MAX__OPENSFAIL,		0, FIELD_OFFSET(DUMMY_PARAMS,OpensFail) },
	{ PARAM_NAME__FAILED,		NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__FAILED,		 PARAM_MIN__FAILED,			PARAM_MAX__FAILED,			0, FIELD_OFFSET(DUMMY_PARAMS,Failed) },
	{ PARAM_NAME__ASYNCHRONOUS, NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__ASYNCHRONOUS,	PARAM_MIN__ASYNCHRONOUS,	PARAM_MAX__ASYNCHRONOUS,	0, FIELD_OFFSET(DUMMY_PARAMS,Asynchronous) },
	{ 0 }
};

//
// Function prototypes.
//

DWORD WINAPI Startup(
	IN LPCWSTR ResourceType,
	IN DWORD MinVersionSupported,
	IN DWORD MaxVersionSupported,
	IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
	IN PLOG_EVENT_ROUTINE LogEvent,
	OUT PCLRES_FUNCTION_TABLE *FunctionTable
	);

RESID WINAPI DummyOpen(
	IN LPCWSTR ResourceName,
	IN HKEY ResourceKey,
	IN RESOURCE_HANDLE ResourceHandle
	);

void WINAPI DummyClose(
	IN RESID ResourceId
	);

DWORD WINAPI DummyOnline(
	IN RESID		ResourceId,
	IN OUT PHANDLE	EventHandle
	);

DWORD WINAPI DummyOnlineThread(
	IN PCLUS_WORKER	 WorkerPtr,
	IN PDUMMY_RESOURCE	ResourceEntry
	);

DWORD WINAPI DummyOffline(
	IN RESID ResourceId
	);

DWORD WINAPI DummyOfflineThread(
	PCLUS_WORKER		WorkerPtr,
	IN PDUMMY_RESOURCE	ResourceEntry
	);

void WINAPI DummyTerminate(
	IN RESID ResourceId
	);

DWORD DummyDoTerminate(
	IN PDUMMY_RESOURCE ResourceEntry
	);

BOOL WINAPI DummyLooksAlive(
	IN RESID ResourceId
	);

BOOL WINAPI DummyIsAlive(
	IN RESID ResourceId
	);

BOOL DummyCheckIsAlive(
	IN PDUMMY_RESOURCE ResourceEntry
	);

DWORD WINAPI DummyResourceControl(
	IN RESID	ResourceId,
	IN DWORD	ControlCode,
	IN void *	InBuffer,
	IN DWORD	InBufferSize,
	OUT void *	OutBuffer,
	IN DWORD	OutBufferSize,
	OUT LPDWORD BytesReturned
	);

DWORD DummyGetPrivateResProperties(
	IN OUT PDUMMY_RESOURCE	ResourceEntry,
	OUT void *				OutBuffer,
	IN DWORD				OutBufferSize,
	OUT LPDWORD			 BytesReturned
	);

DWORD DummyValidatePrivateResProperties(
	IN OUT PDUMMY_RESOURCE	ResourceEntry,
	IN const PVOID			InBuffer,
	IN DWORD				InBufferSize,
	OUT PDUMMY_PARAMS		Params
	);

DWORD DummySetPrivateResProperties(
	IN OUT PDUMMY_RESOURCE	ResourceEntry,
	IN const PVOID			InBuffer,
	IN DWORD				InBufferSize
	);

DWORD DummyTimerThread(
	IN PDUMMY_RESOURCE	ResourceEntry,
	IN PCLUS_WORKER	 WorkerPtr
	);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyInit
//
//	Routine Description:
//
//		Process attach initialization routine.
//
//	Arguments:
//
//		None.
//
//	Return Value:
//
//		TRUE if initialization succeeded. FALSE otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
static BOOLEAN DummyInit(
	void
	)
{
	DummyGlobalMutex = CreateMutex( NULL, FALSE, NULL );

	return DummyGlobalMutex != NULL;

} //*** DummyInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyCleanup
//
//	Routine Description:
//
//		Process detach cleanup routine.
//
//	Arguments:
//
//		None.
//
//	Return Value:
//
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void DummyCleanup(
	void
	)
{
	if ( DummyGlobalMutex != NULL )
	{
		CloseHandle( DummyGlobalMutex );
		DummyGlobalMutex = NULL;
	}

	return;

} //*** DummyCleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllMain
//
//	Routine Description:
//
//		Main DLL entry point.
//
//	Arguments:
//
//		DllHandle - DLL instance handle.
//
//		Reason - Reason for being called.
//
//		Reserved - Reserved argument.
//
//	Return Value:
//
//		TRUE - Success.
//
//		FALSE - Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI DllMain(
	IN HINSTANCE	DllHandle,
	IN DWORD		Reason,
	IN void *		//Reserved
	)
{
	BOOLEAN bRet = TRUE;

	switch( Reason )
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls( DllHandle );
			bRet = DummyInit();
			break;

		case DLL_PROCESS_DETACH:
			DummyCleanup();
			break;
	}

	return bRet;

} //*** DllMain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Startup
//
//	Routine Description:
//
//		Startup the resource DLL. This routine verifies that at least one
//		currently supported version of the resource DLL is between
//		MinVersionSupported and MaxVersionSupported. If not, then the resource
//		DLL should return ERROR_REVISION_MISMATCH.
//
//		If more than one version of the resource DLL interface is supported by
//		the resource DLL, then the highest version (up to MaxVersionSupported)
//		should be returned as the resource DLL's interface. If the returned
//		version is not within range, then startup fails.
//
//		The ResourceType is passed in so that if the resource DLL supports more
//		than one ResourceType, it can pass back the correct function table
//		associated with the ResourceType.
//
//	Arguments:
//
//		ResourceType - The type of resource requesting a function table.
//
//		MinVersionSupported - The minimum resource DLL interface version
//			supported by the cluster software.
//
//		MaxVersionSupported - The maximum resource DLL interface version
//			supported by the cluster software.
//
//		SetResourceStatus - Pointer to a routine that the resource DLL should
//			call to update the state of a resource after the Online or Offline
//			routine returns a status of ERROR_IO_PENDING.
//
//		LogEvent - Pointer to a routine that handles the reporting of events
//			from the resource DLL.
//
//		FunctionTable - Returns a pointer to the function table defined for the
//			version of the resource DLL interface returned by the resource DLL.
//
//	Return Value:
//
//		ERROR_SUCCESS - The operation was successful.
//
//		ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.
//
//		ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
//			match the versrion of the DLL.
//
//		Win32 error code - The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI Startup(
	IN	LPCWSTR						 ResourceType,
	IN	DWORD							MinVersionSupported,
	IN	DWORD							MaxVersionSupported,
	IN	PSET_RESOURCE_STATUS_ROUTINE	SetResourceStatus,
	IN	PLOG_EVENT_ROUTINE				LogEvent,
	OUT PCLRES_FUNCTION_TABLE *		 FunctionTable
	)
{
	if ( ( MinVersionSupported > CLRES_VERSION_V1_00 ) ||
		 ( MaxVersionSupported < CLRES_VERSION_V1_00 ) )
	{
		return ERROR_REVISION_MISMATCH;
	}

	if ( lstrcmpiW( ResourceType, DUMMY_RESNAME ) != 0 )
	{
		return ERROR_MOD_NOT_FOUND;
	}

	if ( g_LogEvent == NULL )
	{
		g_LogEvent = LogEvent;
		g_SetResourceStatus = SetResourceStatus;
	}

	if ( FunctionTable != NULL )
	{
		*FunctionTable = &g_DummyFunctionTable;
	}

	return ERROR_SUCCESS;

} //*** Startup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOpen
//
//	Routine Description:
//
//		Open routine for Dummy resources.
//
//		Open the specified resource (create an instance of the resource).
//		Allocate all structures necessary to bring the specified resource
//		online.
//
//	Arguments:
//
//		ResourceName - Supplies the name of the resource to open.
//
//		ResourceKey - Supplies handle to the resource's cluster configuration
//			database key.
//
//		ResourceHandle - A handle that is passed back to the resource monitor
//			when the SetResourceStatus or LogEvent method is called. See the
//			description of the SetResourceStatus and LogEvent methods on the
//			DummyStatup routine. This handle should never be closed or used
//			for any purpose other than passing it as an argument back to the
//			Resource Monitor in the SetResourceStatus or LogEvent callback.
//
//	Return Value:
//
//		RESID of created resource.
//
//		NULL on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
RESID WINAPI DummyOpen(
	IN LPCWSTR			ResourceName,
	IN HKEY				ResourceKey,
	IN RESOURCE_HANDLE	ResourceHandle
	)
{
	DWORD			status;
	RESID			resid = 0;
	HKEY			parametersKey = NULL;
	PDUMMY_RESOURCE ResourceEntry = NULL;
	LPWSTR			nameOfPropInError;

	//
	// Open the Parameters registry key for this resource.
	//
	status = ClusterRegOpenKey( ResourceKey, L"Parameters", KEY_ALL_ACCESS, &parametersKey );
	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)( ResourceHandle, LOG_ERROR,	L"Unable to open Parameters key. Error: %1!u!.\n", status );
		goto exit;
	}

	//
	// Allocate a resource entry.
	//
	ResourceEntry = (PDUMMY_RESOURCE)LocalAlloc( LMEM_ZEROINIT, sizeof( DUMMY_RESOURCE ) );
	if ( ResourceEntry == NULL )
	{
		status = GetLastError();
		(g_LogEvent)(
			ResourceHandle,
			LOG_ERROR,
			L"Unable to allocate resource entry structure.	Error: %1!u!.\n",
			status
			);
		goto exit;
	}

	//
	// Initialize the resource entry..
	//

	ZeroMemory( ResourceEntry, sizeof( DUMMY_RESOURCE ) );

	ResourceEntry->ResId = (RESID)ResourceEntry; // for validation
	ResourceEntry->ResourceHandle = ResourceHandle;
	ResourceEntry->ParametersKey = parametersKey;
	ResourceEntry->State = ClusterResourceOffline;

	InitializeCriticalSection( &( ResourceEntry->Lock ) );

	//
	// Save the name of the resource.
	//
	ResourceEntry->ResourceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, (lstrlenW( ResourceName ) + 1 ) * sizeof( WCHAR ) );
	if ( ResourceEntry->ResourceName == NULL )
	{
		goto exit;
	}

	lstrcpyW( ResourceEntry->ResourceName, ResourceName );

	//
	// Startup for the resource.
	//
	// TODO: Add your resource startup code here.

	//
	// Read parameters.
	//
	status = ResUtilGetPropertiesToParameterBlock(
										ResourceEntry->ParametersKey,
										DummyResourcePrivateProperties,
										(LPBYTE)&ResourceEntry->Params,
										FALSE, //	CheckForRequiredProperties
										&nameOfPropInError
										);
	if ( status == ERROR_SUCCESS )
	{
		if ( ResourceEntry->Params.OpensFail )
		{
			goto exit;
		}
		else
		{
			resid = (RESID)ResourceEntry;
		}
	}
	else
	{
		goto exit;
	}

	//
	// Create a TimerThreadWakeup event
	//
	ResourceEntry->TimerThreadWakeup = CreateEvent( NULL, FALSE, FALSE, NULL );
	if ( ResourceEntry->TimerThreadWakeup == NULL )
	{
		(g_LogEvent)( ResourceHandle, LOG_ERROR, L"Failed to create timer thread wakeup event\n" );
		resid = 0;
		goto exit;
	}

	if ( ResourceEntry->Params.Pending )
	{
		ResourceEntry->Flags |= DUMMY_FLAG_PENDING;
	}

	if ( ResourceEntry->Params.Asynchronous )
	{
		EnterAsyncMode( ResourceEntry );
		ResourceEntry->SignalEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

		if ( ResourceEntry->SignalEvent == NULL )
		{
			(g_LogEvent)( ResourceHandle, LOG_ERROR, L"Failed to create a timer event\n");
			resid = 0;
			goto exit;
		}
	}

exit:

	if ( resid == 0 )
	{
		if ( parametersKey != NULL )
		{
			ClusterRegCloseKey( parametersKey );
		}

		if ( ResourceEntry != NULL )
		{
			LocalFree( ResourceEntry->ResourceName );
			LocalFree( ResourceEntry );
		}
	}

	if ( status != ERROR_SUCCESS )
	{
		SetLastError( status );
	}

	return resid;

} //*** DummyOpen()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyClose
//
//	Routine Description:
//
//		Close routine for Dummy resources.
//
//		Close the specified resource and deallocate all structures, etc.,
//		allocated in the Open call. If the resource is not in the offline state,
//		then the resource should be taken offline (by calling Terminate) before
//		the close operation is performed.
//
//	Arguments:
//
//		ResourceId - Supplies the RESID of the resource to close.
//
//	Return Value:
//
//		None.
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI DummyClose(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE ResourceEntry;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT( "Dummy: Close request for a nonexistent resource id 0x%p\n", ResourceId );
		return;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Close resource sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return;
	}

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Close request.\n"	);
#endif

	DeleteCriticalSection( &( ResourceEntry->Lock ) );

	if ( ResourceEntry->TimerThreadWakeup != NULL )
	{
		CloseHandle( ResourceEntry->TimerThreadWakeup );
	}

	if ( ResourceEntry->SignalEvent != NULL )
	{
		CloseHandle( ResourceEntry->SignalEvent );
	}

	//
	// Close the Parameters key.
	//
	if ( ResourceEntry->ParametersKey )
	{
		ClusterRegCloseKey( ResourceEntry->ParametersKey );
	}

	//
	// Deallocate the resource entry.
	//

	// ADDPARAM: Add new parameters here.

	LocalFree( ResourceEntry->ResourceName );
	LocalFree( ResourceEntry );

	return;

} //*** DummyClose()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOnline
//
//	Routine Description:
//
//		Online routine for Dummy resources.
//
//		Bring the specified resource online (available for use). The resource
//		DLL should attempt to arbitrate for the resource if it is present on a
//		shared medium, like a shared SCSI bus.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to be brought
//			online (available for use).
//
//		EventHandle - Returns a signalable handle that is signaled when the
//			resource DLL detects a failure on the resource. This argument is
//			NULL on input, and the resource DLL returns NULL if asynchronous
//			notification of failures is not supported, otherwise this must be
//			the address of a handle that is signaled on resource failures.
//
//	Return Value:
//
//		ERROR_SUCCESS - The operation was successful, and the resource is now
//			online.
//
//		ERROR_RESOURCE_NOT_FOUND - RESID is not valid.
//
//		ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some
//			other systems and one of the other systems won the arbitration.
//
//		ERROR_IO_PENDING - The request is pending, a thread has been activated
//			to process the online request. The thread that is processing the
//			online request will periodically report status by calling the
//			SetResourceStatus callback method, until the resource is placed into
//			the ClusterResourceOnline state (or the resource monitor decides to
//			timeout the online request and Terminate the resource. This pending
//			timeout value is settable and has a default value of 3 minutes.).
//
//		Win32 error code - The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyOnline(
	IN RESID	ResourceId,
	IN OUT		PHANDLE //EventHandle
	)
{
	PDUMMY_RESOURCE ResourceEntry = NULL;
	DWORD			status;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT( "Dummy: Online request for a nonexistent resource id 0x%p.\n",	ResourceId );
		return ERROR_RESOURCE_NOT_FOUND;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Online service sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return ERROR_RESOURCE_NOT_FOUND;
	}

	DummyAcquireResourceLock( ResourceEntry );

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Online request.\n" );
#endif

	ResourceEntry->State = ClusterResourceOffline;
	ClusWorkerTerminate( &ResourceEntry->OnlineThread );
	ClusWorkerTerminate( &ResourceEntry->OfflineThread );

	status = ClusWorkerCreate( &ResourceEntry->OnlineThread, (PWORKER_START_ROUTINE)DummyOnlineThread, ResourceEntry );
	if ( status != ERROR_SUCCESS )
	{
		ResourceEntry->State = ClusterResourceFailed;
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Online: Unable to start thread, status %1!u!.\n",
			status
			);
	}
	else
	{
		status = ERROR_IO_PENDING;
	}

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOnlineThread
//
//	Routine Description:
//
//		Worker function which brings a resource from the resource table online.
//		This function is executed in a separate thread.
//
//	Arguments:
//
//		WorkerPtr - Supplies the worker structure
//
//		ResourceEntry - A pointer to the DUMMY_RESOURCE block for this resource.
//
//	Return Value:
//
//		ERROR_SUCCESS - The operation completed successfully.
//
//		Win32 error code - The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyOnlineThread(
	IN PCLUS_WORKER	 WorkerPtr,
	IN PDUMMY_RESOURCE	ResourceEntry
	)
{
	RESOURCE_STATUS	 resourceStatus;
	DWORD				status = ERROR_SUCCESS;
	LPWSTR				nameOfPropInError;

	DummyAcquireResourceLock( ResourceEntry );

	ResUtilInitializeResourceStatus( &resourceStatus );

	resourceStatus.ResourceState = ClusterResourceFailed;
	resourceStatus.WaitHint = 0;
	resourceStatus.CheckPoint = 1;

	//
	// Read parameters.
	//
	status = ResUtilGetPropertiesToParameterBlock(
										ResourceEntry->ParametersKey,
										DummyResourcePrivateProperties,
										(LPBYTE)&ResourceEntry->Params,
										TRUE, //	CheckForRequiredProperties
										&nameOfPropInError
										);
	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Unable to read the '%1' property. Error: %2!u!.\n",
			(nameOfPropInError == NULL ? L"" : nameOfPropInError),
			status
			);
		goto exit;
	}

	//
	// Bring the resource online.
	//
	if ( ResourceEntry->Params.Pending )
	{
		ResourceEntry->Flags |= DUMMY_FLAG_PENDING;
		ResourceEntry->TimerType = TimerOnlinePending;

		status = DummyTimerThread( ResourceEntry, WorkerPtr );
	}

exit:

	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_ERROR, L"Error %1!u! bringing resource online.\n", status );
	}
	else
	{
		resourceStatus.ResourceState = ClusterResourceOnline;
	}

	// _ASSERTE(g_SetResourceStatus != NULL);
	g_SetResourceStatus( ResourceEntry->ResourceHandle, &resourceStatus );
	ResourceEntry->State = resourceStatus.ResourceState;

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyOnlineThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOffline
//
//	Routine Description:
//
//		Offline routine for Dummy resources.
//
//		Take the specified resource offline gracefully (unavailable for use).
//		Wait for any cleanup operations to complete before returning.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to be shutdown
//			gracefully.
//
//	Return Value:
//
//		ERROR_SUCCESS - The request completed successfully and the resource is
//			offline.
//
//		ERROR_RESOURCE_NOT_FOUND - RESID is not valid.
//
//		ERROR_IO_PENDING - The request is still pending, a thread has been
//			activated to process the offline request. The thread that is
//			processing the offline will periodically report status by calling
//			the SetResourceStatus callback method, until the resource is placed
//			into the ClusterResourceOffline state (or the resource monitor decides
//			to timeout the offline request and Terminate the resource).
//
//		Win32 error code - Will cause the resource monitor to log an event and
//			call the Terminate routine.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyOffline(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE ResourceEntry;
	DWORD			status = ERROR_SUCCESS;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT( "Dummy: Offline request for a nonexistent resource id 0x%p\n",	ResourceId );
		return ERROR_RESOURCE_NOT_FOUND;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return ERROR_RESOURCE_NOT_FOUND;
	}

	DummyAcquireResourceLock( ResourceEntry );

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Offline request.\n" );
#endif

	// TODO: Offline code

	// NOTE: Offline should try to shut the resource down gracefully, whereas
	// Terminate must shut the resource down immediately. If there are no
	// differences between a graceful shut down and an immediate shut down,
	// Terminate can be called for Offline, as it is below.	However, if there
	// are differences, replace the call to Terminate below with your graceful
	// shutdown code.

	ResourceEntry->State = ClusterResourceOnline;
	ClusWorkerTerminate( &ResourceEntry->OfflineThread );
	ClusWorkerTerminate( &ResourceEntry->OnlineThread );

	status = ClusWorkerCreate( &ResourceEntry->OfflineThread, (PWORKER_START_ROUTINE)DummyOfflineThread, ResourceEntry );
	if ( status != ERROR_SUCCESS )
	{
		ResourceEntry->State = ClusterResourceFailed;
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Online: Unable to start thread, status %1!u!.\n",
			status
			);
	}
	else
	{
		status = ERROR_IO_PENDING;
	}

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOfflineThread
//
//	Routine Description:
//
//		Worker function which brings a resource from the resource table online.
//		This function is executed in a separate thread.
//
//	Arguments:
//
//		WorkerPtr - Supplies the worker structure
//
//		ResourceEntry - A pointer to the DUMMY_RESOURCE block for this resource.
//
//	Return Value:
//
//		ERROR_SUCCESS - The operation completed successfully.
//
//		Win32 error code - The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyOfflineThread(
	IN PCLUS_WORKER	 WorkerPtr,
	IN PDUMMY_RESOURCE	ResourceEntry
	)
{
	RESOURCE_STATUS	 resourceStatus;
	DWORD				status = ERROR_SUCCESS;
	LPWSTR				nameOfPropInError;

	DummyAcquireResourceLock( ResourceEntry );

	ResUtilInitializeResourceStatus( &resourceStatus );

	resourceStatus.ResourceState = ClusterResourceFailed;
	resourceStatus.WaitHint = 0;
	resourceStatus.CheckPoint = 1;

	//
	// Read parameters.
	//
	status = ResUtilGetPropertiesToParameterBlock(
										ResourceEntry->ParametersKey,
										DummyResourcePrivateProperties,
										(LPBYTE)&ResourceEntry->Params,
										FALSE, //	CheckForRequiredProperties
										&nameOfPropInError
										);
	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Unable to read the '%1' property. Error: %2!u!.\n",
			(nameOfPropInError == NULL ? L"" : nameOfPropInError),
			status
			);
		goto exit;
	}

	//
	// Bring the resource online.
	//
	if ( ResourceEntry->Params.Pending )
	{
		ResourceEntry->Flags |= DUMMY_FLAG_PENDING;
		ResourceEntry->TimerType = TimerOfflinePending;

		status = DummyTimerThread( ResourceEntry, WorkerPtr );
	}

exit:

	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_ERROR, L"Error %1!u! bringing resource online.\n", status );
	}
	else
	{
		resourceStatus.ResourceState = ClusterResourceOffline;
	}

	// _ASSERTE(g_SetResourceStatus != NULL);
	g_SetResourceStatus( ResourceEntry->ResourceHandle, &resourceStatus );
	ResourceEntry->State = resourceStatus.ResourceState;

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyOfflineThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyTerminate
//
//	Routine Description:
//
//		Terminate routine for Dummy resources.
//
//		Take the specified resource offline immediately (the resource is
//		unavailable for use).
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to be brought
//			offline.
//
//	Return Value:
//
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI DummyTerminate(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE ResourceEntry;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT( "Dummy: Terminate request for a nonexistent resource id 0x%p\n", ResourceId );
		return;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return;
	}

	DummyAcquireResourceLock( ResourceEntry );

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Terminate request.\n" );
#endif

	//
	// Terminate the resource.
	//
	DummyDoTerminate( ResourceEntry );
	ResourceEntry->State = ClusterResourceOffline;

	DummyReleaseResourceLock( ResourceEntry );

	return;

} //*** DummyTerminate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyDoTerminate
//
//	Routine Description:
//
//		Do the actual Terminate work for Dummy resources.
//
//	Arguments:
//
//		ResourceEntry - Supplies resource entry for resource to be terminated
//
//	Return Value:
//
//		ERROR_SUCCESS - The request completed successfully and the resource is
//			offline.
//
//		Win32 error code - Will cause the resource monitor to log an event and
//			call the Terminate routine.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyDoTerminate(
	IN PDUMMY_RESOURCE ResourceEntry
	)
{
	DWORD	status = ERROR_SUCCESS;

	if ( ResourceEntry->TimerType != TimerNotUsed )
	{
		SetEvent( ResourceEntry->TimerThreadWakeup );
	}
	//
	// Kill off any pending threads.
	//
	ClusWorkerTerminate( &ResourceEntry->OnlineThread );
	ClusWorkerTerminate( &ResourceEntry->OfflineThread );

	//
	// Terminate the resource.
	//
	// TODO: Add code to terminate your resource.
	if ( status == ERROR_SUCCESS )
	{
		ResourceEntry->State = ClusterResourceOffline;
	}

	return status;

} //*** DummyDoTerminate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyLooksAlive
//
//	Routine Description:
//
//		LooksAlive routine for Dummy resources.
//
//		Perform a quick check to determine if the specified resource is probably
//		online (available for use).	This call should not block for more than
//		300 ms, preferably less than 50 ms.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to polled.
//
//	Return Value:
//
//		TRUE - The specified resource is probably online and available for use.
//
//		FALSE - The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DummyLooksAlive(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE	ResourceEntry;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT("Dummy: LooksAlive request for a nonexistent resource id 0x%p\n", ResourceId );
		return FALSE;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return FALSE;
	}

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"LooksAlive request.\n" );
#endif

	// TODO: LooksAlive code

	// NOTE: LooksAlive should be a quick check to see if the resource is
	// available or not, whereas IsAlive should be a thorough check.	If
	// there are no differences between a quick check and a thorough check,
	// IsAlive can be called for LooksAlive, as it is below.	However, if there
	// are differences, replace the call to IsAlive below with your quick
	// check code.

	//
	// Check to see if the resource is alive.
	//
	return DummyCheckIsAlive( ResourceEntry );

} //*** DummyLooksAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyIsAlive
//
//	Routine Description:
//
//		IsAlive routine for Dummy resources.
//
//		Perform a thorough check to determine if the specified resource is online
//		(available for use). This call should not block for more than 400 ms,
//		preferably less than 100 ms.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to polled.
//
//	Return Value:
//
//		TRUE - The specified resource is online and functioning normally.
//
//		FALSE - The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DummyIsAlive(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE	ResourceEntry;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT("Dummy: IsAlive request for a nonexistent resource id 0x%p\n", ResourceId );
		return FALSE;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return FALSE;
	}

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"IsAlive request.\n" );
#endif

	//
	// Check to see if the resource is alive.
	//
	return DummyCheckIsAlive( ResourceEntry );

} //*** DummyIsAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyCheckIsAlive
//
//	Routine Description:
//
//		Check to see if the resource is alive for Dummy resources.
//
//	Arguments:
//
//		ResourceEntry - Supplies the resource entry for the resource to polled.
//
//	Return Value:
//
//		TRUE - The specified resource is online and functioning normally.
//
//		FALSE - The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DummyCheckIsAlive(
	IN PDUMMY_RESOURCE ResourceEntry
	)
{
	DummyAcquireResourceLock( ResourceEntry );

	//
	// Check to see if the resource is alive.
	//
	// TODO: Add code to determine if your resource is alive.

	DummyReleaseResourceLock( ResourceEntry );

	return TRUE;

} //*** DummyCheckIsAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyResourceControl
//
//	Routine Description:
//
//		ResourceControl routine for Dummy resources.
//
//		Perform the control request specified by ControlCode on the specified
//		resource.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the specific resource.
//
//		ControlCode - Supplies the control code that defines the action
//			to be performed.
//
//		InBuffer - Supplies a pointer to a buffer containing input data.
//
//		InBufferSize - Supplies the size, in bytes, of the data pointed
//			to by InBuffer.
//
//		OutBuffer - Supplies a pointer to the output buffer to be filled in.
//
//		OutBufferSize - Supplies the size, in bytes, of the available space
//			pointed to by OutBuffer.
//
//		BytesReturned - Returns the number of bytes of OutBuffer actually
//			filled in by the resource. If OutBuffer is too small, BytesReturned
//			contains the total number of bytes for the operation to succeed.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_RESOURCE_NOT_FOUND - RESID is not valid.
//
//		ERROR_INVALID_FUNCTION - The requested control code is not supported.
//			In some cases, this allows the cluster software to perform the work.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyResourceControl(
	IN RESID	ResourceId,
	IN DWORD	ControlCode,
	IN void *	InBuffer,
	IN DWORD	InBufferSize,
	OUT void *	OutBuffer,
	IN DWORD	OutBufferSize,
	OUT LPDWORD BytesReturned
	)
{
	DWORD			status;
	PDUMMY_RESOURCE ResourceEntry;
	DWORD			required;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT("Dummy: ResourceControl request for a nonexistent resource id 0x%p\n", ResourceId );
		return ERROR_RESOURCE_NOT_FOUND;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return ERROR_RESOURCE_NOT_FOUND;
	}

	DummyAcquireResourceLock( ResourceEntry );

	switch ( ControlCode )
	{

		case CLUSCTL_RESOURCE_UNKNOWN:
			*BytesReturned = 0;
			status = ERROR_SUCCESS;
			break;

		case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
			status = ResUtilEnumProperties(
								DummyResourcePrivateProperties,
								(LPWSTR)OutBuffer,
								OutBufferSize,
								BytesReturned,
								&required
								);
			if ( status == ERROR_MORE_DATA )
			{
				*BytesReturned = required;
			}

			break;

		case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
			status = DummyGetPrivateResProperties(
												ResourceEntry,
												OutBuffer,
												OutBufferSize,
												BytesReturned
												);
			break;

		case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
			status = DummyValidatePrivateResProperties( ResourceEntry, InBuffer, InBufferSize, NULL );
			break;

		case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
			status = DummySetPrivateResProperties( ResourceEntry, InBuffer, InBufferSize );
			break;

		default:
			status = ERROR_INVALID_FUNCTION;
			break;
	}

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyResourceControl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyResourceTypeControl
//
//	Routine Description:
//
//		ResourceTypeControl routine for Dummy resources.
//
//		Perform the control request specified by ControlCode.
//
//	Arguments:
//
//		ResourceTypeName - Supplies the name of the resource type.
//
//		ControlCode - Supplies the control code that defines the action
//			to be performed.
//
//		InBuffer - Supplies a pointer to a buffer containing input data.
//
//		InBufferSize - Supplies the size, in bytes, of the data pointed
//			to by InBuffer.
//
//		OutBuffer - Supplies a pointer to the output buffer to be filled in.
//
//		OutBufferSize - Supplies the size, in bytes, of the available space
//			pointed to by OutBuffer.
//
//		BytesReturned - Returns the number of bytes of OutBuffer actually
//			filled in by the resource. If OutBuffer is too small, BytesReturned
//			contains the total number of bytes for the operation to succeed.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_INVALID_FUNCTION - The requested control code is not supported.
//			In some cases, this allows the cluster software to perform the work.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyResourceTypeControl(
	IN LPCWSTR, //ResourceTypeName,
	IN DWORD	ControlCode,
	IN void *,	//InBuffer,
	IN DWORD,	//InBufferSize,
	OUT void *	OutBuffer,
	IN DWORD	OutBufferSize,
	OUT LPDWORD BytesReturned
	)
{
	DWORD				status;
	DWORD				required;

	switch ( ControlCode )
	{

		case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
			*BytesReturned = 0;
			status = ERROR_SUCCESS;
			break;

		case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
			status = ResUtilEnumProperties(
									DummyResourcePrivateProperties,
									(LPWSTR)OutBuffer,
									OutBufferSize,
									BytesReturned,
									&required
									);
			if ( status == ERROR_MORE_DATA )
			{
				*BytesReturned = required;
			}

			break;

		default:
			status = ERROR_INVALID_FUNCTION;
			break;
	}

	return status;

} //*** DummyResourceTypeControl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyGetPrivateResProperties
//
//	Routine Description:
//
//		Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
//			for resources of type Dummy.
//
//	Arguments:
//
//		ResourceEntry - Supplies the resource entry on which to operate.
//
//		OutBuffer - Returns the output data.
//
//		OutBufferSize - Supplies the size, in bytes, of the data pointed
//			to by OutBuffer.
//
//		BytesReturned - The number of bytes returned in OutBuffer.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_INVALID_PARAMETER - The data is formatted incorrectly.
//
//		ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyGetPrivateResProperties(
	IN OUT	PDUMMY_RESOURCE ResourceEntry,
	OUT	 void *			OutBuffer,
	IN		DWORD			OutBufferSize,
	OUT	 LPDWORD		 BytesReturned
	)
{
	DWORD	status;
	DWORD	required;

	DummyAcquireResourceLock( ResourceEntry );

	status = ResUtilGetAllProperties(
							ResourceEntry->ParametersKey,
							DummyResourcePrivateProperties,
							OutBuffer,
							OutBufferSize,
							BytesReturned,
							&required
							);
	if ( status == ERROR_MORE_DATA )
	{
		*BytesReturned = required;
	}

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyGetPrivateResProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyValidatePrivateResProperties
//
//	Routine Description:
//
//		Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
//			function for resources of type Dummy.
//
//	Arguments:
//
//		pResourceEntry - Supplies the resource entry	on which to operate.
//
//		InBuffer - Supplies a pointer to a buffer containing input data.
//
//		InBufferSize - Supplies the size, in bytes, of the data pointed
//			to by InBuffer.
//
//		Params - Supplies the parameter block to fill in.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_INVALID_PARAMETER - The data is formatted incorrectly.
//
//		ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyValidatePrivateResProperties(
	IN OUT	PDUMMY_RESOURCE pResourceEntry,
	IN		const PVOID	 InBuffer,
	IN		DWORD			InBufferSize,
	OUT	 PDUMMY_PARAMS	Params
	)
{
	DWORD			status = ERROR_SUCCESS;
	DUMMY_PARAMS	propsCurrent;
	DUMMY_PARAMS	propsNew;
	PDUMMY_PARAMS	pParams;
	LPWSTR			pszNameOfPropInError;

	DummyAcquireResourceLock( pResourceEntry );

	//
	// Check if there is input data.
	//
	if ( ( InBuffer == NULL ) || ( InBufferSize < sizeof( DWORD ) ) )
	{
		status = ERROR_INVALID_DATA;
		goto exit;
	}

	//
	// Retrieve the current set of private properties from the
	// cluster database.
	//
	ZeroMemory( &propsCurrent, sizeof( propsCurrent ) );

	status = ResUtilGetPropertiesToParameterBlock(
				 pResourceEntry->ParametersKey,
				 DummyResourcePrivateProperties,
				 reinterpret_cast< LPBYTE >( &propsCurrent ),
				 FALSE, /*CheckForRequiredProperties*/
				 &pszNameOfPropInError
				 );

	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)(
			pResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Unable to read the '%1' property. Error: %2!u!.\n",
			(pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
			status
			);
		goto exit;
	} // if:	error getting properties


	//
	// Duplicate the resource parameter block.
	//
	if ( Params == NULL )
	{
		pParams = &propsNew;
	}
	else
	{
		pParams = Params;
	}

	ZeroMemory( pParams, sizeof(DUMMY_PARAMS) );
	status = ResUtilDupParameterBlock(
					reinterpret_cast< LPBYTE >( pParams ),
					reinterpret_cast< LPBYTE >( &propsCurrent ),
					DummyResourcePrivateProperties
					);
	if ( status != ERROR_SUCCESS )
	{
		goto cleanup;
	}

	//
	// Parse and validate the properties.
	//
	status = ResUtilVerifyPropertyTable(
								DummyResourcePrivateProperties,
								NULL,
								TRUE, // AllowUnknownProperties
								InBuffer,
								InBufferSize,
								(LPBYTE)pParams
								);

	if ( status == ERROR_SUCCESS )
	{
		//
		// Validate the parameter values.
		//
		// TODO: Code to validate interactions between parameters goes here.
	}

cleanup:
	//
	// Cleanup our parameter block.
	//
	if (	(pParams == &propsNew)
		||	(	(status != ERROR_SUCCESS)
			&&	(pParams != NULL)
			)
		)
	{
		ResUtilFreeParameterBlock(
			reinterpret_cast< LPBYTE >( pParams ),
			reinterpret_cast< LPBYTE >( &propsCurrent ),
			DummyResourcePrivateProperties
			);
	} // if:	we duplicated the parameter block

	ResUtilFreeParameterBlock(
		reinterpret_cast< LPBYTE >( &propsCurrent ),
		NULL,
		DummyResourcePrivateProperties
		);

exit:

	DummyReleaseResourceLock( pResourceEntry );

	return status;

} //*** DummyValidatePrivateResProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummySetPrivateResProperties
//
//	Routine Description:
//
//		Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
//			for resources of type Dummy.
//
//	Arguments:
//
//		ResourceEntry - Supplies the resource entry on which to operate.
//
//		InBuffer - Supplies a pointer to a buffer containing input data.
//
//		InBufferSize - Supplies the size, in bytes, of the data pointed
//			to by InBuffer.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_INVALID_PARAMETER - The data is formatted incorrectly.
//
//		ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummySetPrivateResProperties(
	IN OUT	PDUMMY_RESOURCE ResourceEntry,
	IN		void *			InBuffer,
	IN		DWORD			InBufferSize
	)
{
	DWORD			status = ERROR_SUCCESS;
	DUMMY_PARAMS	params;

	DummyAcquireResourceLock( ResourceEntry );

	//
	// Parse the properties so they can be validated together.
	// This routine does individual property validation.
	//
	status = DummyValidatePrivateResProperties( ResourceEntry, InBuffer, InBufferSize, &params );
	if ( status != ERROR_SUCCESS )
	{
		ResUtilFreeParameterBlock( (LPBYTE)&params, (LPBYTE)&ResourceEntry->Params, DummyResourcePrivateProperties );
		goto exit;
	}

	//
	// Save the parameter values.
	//

	status = ResUtilSetPropertyParameterBlock(
								ResourceEntry->ParametersKey,
								DummyResourcePrivateProperties,
								NULL,
								(LPBYTE) &params,
								InBuffer,
								InBufferSize,
								(LPBYTE) &ResourceEntry->Params
								);

	ResUtilFreeParameterBlock( (LPBYTE)&params, (LPBYTE)&ResourceEntry->Params, DummyResourcePrivateProperties );

	//
	// If the resource is online, return a non-success status.
	//
	// TODO: Modify the code below if your resource can handle
	// changes to properties while it is still online.
	if ( status == ERROR_SUCCESS )
	{
		if ( ResourceEntry->State == ClusterResourceOnline )
		{
			status = ERROR_RESOURCE_PROPERTIES_STORED;
		}
		else if ( ResourceEntry->State == ClusterResourceOnlinePending )
		{
			status = ERROR_RESOURCE_PROPERTIES_STORED;
		}
		else
		{
			status = ERROR_SUCCESS;
		}
	}

exit:

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummySetPrivateResProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyDoPending
//
//	Routine Description:
//
//		Does the online and offline pending and waiting processing
//
//	Arguments:
//
//		resource - A pointer to the DummyResource block for this resource.
//
//		nDelay - How long should we wait?
//
//		WorkerPtr - Supplies the worker structure
//
//	Return Value:
//
//		ERROR_SUCCESS if successful.
//
//		Win32 error code on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyDoPending(
	IN PDUMMY_RESOURCE	ResourceEntry,
	IN DWORD			nDelay,
	IN PCLUS_WORKER	 WorkerPtr
	)
{
	RESOURCE_STATUS	 resourceStatus;
	DWORD				status;
	DWORD				nWait = MAX_WAIT;
	RESOURCE_EXIT_STATE exit;

	ResUtilInitializeResourceStatus( &resourceStatus );

	resourceStatus.ResourceState = ( ResourceEntry->TimerType == TimerOnlinePending
									? ClusterResourceOnlinePending
									: ClusterResourceOfflinePending );
	resourceStatus.WaitHint = 0;
	resourceStatus.CheckPoint = 1;

	(g_SetResourceStatus)( ResourceEntry->ResourceHandle, &resourceStatus );

	if ( nDelay < nWait )
	{
		nWait = nDelay;
		nDelay = 0;
	}

	for ( ; ; )
	{
		status = WaitForSingleObject( ResourceEntry->TimerThreadWakeup, nWait );

		//
		// Check to see if the online operation was aborted while this thread
		// was starting up.
		//
		if ( ClusWorkerCheckTerminate( WorkerPtr ) )
		{
			status = ERROR_OPERATION_ABORTED;
			ResourceEntry->State = ( ResourceEntry->TimerType == TimerOnlinePending )
									? ClusterResourceOnlinePending
									: ClusterResourceOfflinePending;
			break;
		}

		//
		// Either the terminate routine was called, or we timed out.
		// If we timed out, then indicate that we've completed.
		//
		if ( status == WAIT_TIMEOUT )
		{

			if ( nDelay == 0 )
			{
				status = ERROR_SUCCESS;
				break;
			}

			nDelay -= nWait;

			if ( nDelay < nWait )
			{
				nWait = nDelay;
				nDelay = 0;
			}
		}
		else
		{
			(g_LogEvent)(
				ResourceEntry->ResourceHandle,
				LOG_INFORMATION,
				( ResourceEntry->TimerType == TimerOnlinePending ) ? L"Online pending terminated\n" : L"Offline pending terminated\n"
				);
			if ( ResourceEntry->State == ClusterResourceOffline )
			{
				ResourceEntry->TimerType = TimerOfflinePending;
				break;
			}
			else if ( ResourceEntry->State == ClusterResourceOnline )
			{
				ResourceEntry->TimerType	= TimerOnlinePending;
				break;
			}
		}

		exit = (_RESOURCE_EXIT_STATE)(g_SetResourceStatus)( ResourceEntry->ResourceHandle, &resourceStatus );
		if ( exit == ResourceExitStateTerminate )
		{
			ResourceEntry->State = ( ResourceEntry->TimerType == TimerOnlinePending )
										? ClusterResourceOnline
										: ClusterResourceOffline;

			status = ERROR_SUCCESS; //TODO

			if ( ResourceEntry->TimerType == TimerOnlinePending )
			{
				break;
			}
		}
		else
		{
			ResourceEntry->State = ( ResourceEntry->TimerType == TimerOnlinePending )
									? ClusterResourceOnline
									: ClusterResourceOffline;
			status = ERROR_SUCCESS;
		}
	} // for:

	resourceStatus.ResourceState = ( ResourceEntry->TimerType == TimerOnlinePending ? ClusterResourceOnline : ClusterResourceOffline );
	(g_SetResourceStatus)( ResourceEntry->ResourceHandle, &resourceStatus );

	return status;

} //*** DummyDoPending()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyTimerThread
//
//	Routine Description:
//
//		Starts a timer thread to wait and signal failures
//
//	Arguments:
//
//		resource - A pointer to the DummyResource block for this resource.
//
//		WorkerPtr - Supplies the worker structure
//
//	Return Value:
//
//		ERROR_SUCCESS if successful.
//
//		Win32 error code on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyTimerThread(
	IN PDUMMY_RESOURCE	ResourceEntry,
	IN PCLUS_WORKER	 WorkerPtr
	)
{
	RESOURCE_STATUS	 resourceStatus;
	SYSTEMTIME			time;
	DWORD				delay;
	DWORD				status = ERROR_SUCCESS;

	DummyAcquireResourceLock( ResourceEntry );

	(g_LogEvent)( NULL, LOG_INFORMATION, L"TimerThread Entry\n" );

	//
	// If we are not running in async failure mode, or
	// pending mode then exit now.
	//
	if ( !AsyncMode( ResourceEntry ) && !PendingMode( ResourceEntry ) )
	{
		status = ERROR_SUCCESS;
		goto exit;
	}

	//
	// Check to see if the online/offline operation was aborted while this thread
	// was starting up.
	//
	if ( ClusWorkerCheckTerminate( WorkerPtr ) )
	{
		status = ERROR_OPERATION_ABORTED;
		ResourceEntry->State = ClusterResourceOfflinePending;
		goto exit;
	}

more_pending:

	ResUtilInitializeResourceStatus( &resourceStatus );

	//
	// Otherwise, get system time for random delay.
	//
	if ( ResourceEntry->Params.PendTime == 0 )
	{
		GetSystemTime( &time );
		delay = ( time.wMilliseconds + time.wSecond ) * 6;
	}
	else
	{
		delay = ResourceEntry->Params.PendTime * 1000;
	}

	//
	// Use longer delays for errors
	//
	if ( ResourceEntry->TimerType == TimerErrorPending )
	{
		delay *= 10;
	}

	//
	// This routine is either handling an Offline Pending or an error timeout.
	//
	switch ( ResourceEntry->TimerType )
	{

		case TimerOnlinePending :
		{
			(g_LogEvent)(
				ResourceEntry->ResourceHandle,
				LOG_INFORMATION,
				L"Will complete online in approximately %1!u! seconds\n",
				( delay + 500 ) / 1000
				);

			status = DummyDoPending( ResourceEntry, delay, WorkerPtr );

			break;
		}

		case TimerOfflinePending :
		{
			(g_LogEvent)(
				ResourceEntry->ResourceHandle,
				LOG_INFORMATION,
				L"Will complete offline in approximately %1!u! seconds\n",
				(delay+500)/1000
				);

			status = DummyDoPending( ResourceEntry, delay, WorkerPtr );

			break;
		}

		case TimerErrorPending :
		{
			(g_LogEvent)(
				ResourceEntry->ResourceHandle,
				LOG_INFORMATION,
				L"Will fail in approximately %1!u! seconds\n",
				( delay + 500 ) / 1000
				);

			if ( !ResetEvent( ResourceEntry->SignalEvent	) )
			{
				(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_ERROR, L"Failed to reset the signal event\n");
				status = ERROR_GEN_FAILURE;
				goto exit;
			}

			status = WaitForSingleObject( ResourceEntry->TimerThreadWakeup, delay );

			//
			// Either the terminate routine was called, or we timed out.
			// If we timed out, then signal the waiting event.
			//
			if ( status == WAIT_TIMEOUT )
			{
				(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Failed randomly\n");
				ResourceEntry->TimerType	= TimerNotUsed;
				SetEvent( ResourceEntry->SignalEvent	);
			}
			else
			{
				if ( ResourceEntry->State ==	ClusterResourceOfflinePending )
				{
					ResourceEntry->TimerType	= TimerOfflinePending;
					goto more_pending;
				}
			}

			break;
		}

		default:
			(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_ERROR, L"DummyTimer internal error, timer %1!u!\n", ResourceEntry->TimerType);
			break;

	}

	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"TimerThread Exit\n" );


	ResourceEntry->TimerType = TimerNotUsed;

exit:

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} // DummyTimerThread

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE(
						g_DummyFunctionTable,		// Name
						CLRES_VERSION_V1_00,		// Version
						Dummy,						// Prefix
						NULL,						// Arbitrate
						NULL,						// Release
						DummyResourceControl,		// ResControl
						DummyResourceTypeControl	// ResTypeControl
						);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Description:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

IWCWizardCallback * CBasePropertyPage::PiWizardCallback(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->PiWizardCallback();
}

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

CLUADMEX_OBJECT_TYPE CBasePropertyPage::Cot(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Cot();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\disks\extdll\exe\tstdllex.c ===
#include <windows.h>
#include <stdio.h>

#include <resapi.h>
#include <clusapi.h>
#include <clusstor.h>

#define ERROR_BUFFER_SIZE   1024
#define MAX_NAME_SIZE       MAX_PATH
#define START_BUFFER_SIZE   2048

#define PHYSICAL_DISK_WSTR  L"Physical Disk"

//
// Always specify the fully qualified path name to the DLL.  
//

#define MODULE_NAME_VALID       "%SystemRoot%\\cluster\\passthru.dll"

#define PROC_EXCEPTION          "TestDllCauseException"
#define PROC_GET_BOOT_SECTOR    "TestDllGetBootSector"
#define PROC_CONTEXT_AS_ERROR   "TestDllReturnContextAsError"
#define PROC_NOT_ENOUGH_PARMS   "TestDllNotEnoughParms"
#define PROC_TOO_MANY_PARMS     "TestDllTooManyParms"

// 6118L    ERROR_NO_BROWSER_SERVERS_FOUND
#define CONTEXT_ERROR_STR       "6118"      
    
#define MODULE_NAME_INVALID     "NoSuchModule.dll"
#define PROC_NAME_INVALID       "NoSuchProc"

#define MAX_OUT_BUFFER_SIZE 2048

#define BOOT_SECTOR_SIZE        512

//
// Use this to verify the parse routine.
//
// #define TEST_PARSE_ROUTINE  11


typedef struct _RESOURCE_STATE {
    CLUSTER_RESOURCE_STATE  State;
    LPWSTR  ResNodeName;
    LPWSTR  ResGroupName;
} RESOURCE_STATE, *PRESOURCE_STATE;


DWORD 
GetResourceInfo(
    RESOURCE_HANDLE hOriginal,   
    RESOURCE_HANDLE hResource,  
    PVOID lpParams   
    );

DWORD
GetResourceState(
    HRESOURCE Resource,
    PRESOURCE_STATE ResState
    );

DWORD
GetSignature(
    RESOURCE_HANDLE hResource,
    DWORD *dwSignature
    );

BOOLEAN
GetSignatureFromDiskInfo(
    PBYTE DiskInfo,
    DWORD *Signature,
    DWORD DiskInfoSize
    );


LPBYTE
ParseDiskInfo(
    PBYTE DiskInfo,
    DWORD DiskInfoSize,
    DWORD SyntaxValue
    );

VOID
PrintBootRecord(
    IN PUCHAR bootSector,
    IN DWORD byteCount
    );

VOID
PrintError(
    DWORD ErrorCode
    );


DWORD 
ResourceCallback(
    RESOURCE_HANDLE hOriginal,   
    RESOURCE_HANDLE hResource,  
    PVOID lpParams   
    );

CLUSTER_RESOURCE_STATE 
WINAPI 
WrapGetClusterResourceState(
	IN HRESOURCE hResource,
	OUT OPTIONAL LPWSTR * ppwszNodeName,
	OUT OPTIONAL LPWSTR * ppwszGroupName
	);

DWORD
WrapClusterResourceControl(
    RESOURCE_HANDLE hResource,
    DWORD dwControlCode,    
    LPVOID *ppwszOutBuffer,
    DWORD *dwBytesReturned
    );


DWORD
__cdecl
main(
    int argc,
    char *argv[]
    )

{
    DWORD dwStatus = NO_ERROR;

    //
    // No parameter validation...
    //

    dwStatus = ResUtilEnumResources( NULL,
                                     PHYSICAL_DISK_WSTR,
                                     ResourceCallback,
                                     NULL
                                     );

    if ( NO_ERROR != dwStatus ) {
        printf("\nResUtilEnumResources returns: %d \n", dwStatus);
        PrintError(dwStatus);    
    }
        
    return dwStatus;

}   // main



DWORD 
ResourceCallback(
    RESOURCE_HANDLE hOriginal,   
    RESOURCE_HANDLE hResource,  
    PVOID lpParams   
    )
{
    PCHAR outBuffer = NULL;
    
    DWORD dwStatus = NO_ERROR;

    DWORD   inBufferSize = sizeof(DISK_DLL_EXTENSION_INFO);
    DWORD   outBufferSize = MAX_OUT_BUFFER_SIZE;
    DWORD   bytesReturned;
    
    DISK_DLL_EXTENSION_INFO inBuffer;
    
    // printf("hOriginal 0x%x  hResource 0x%x  lpParams 0x%x \n", hOriginal, hResource, lpParams);
    
    //
    // Demonstrate how to get various resource info.
    //
    
    dwStatus = GetResourceInfo( hOriginal,
                                hResource,
                                lpParams );

    //////////////////////////////////////////////////////////////////////////
    //
    // Demonstrate calling into the disk extension DLL.
    //
    //////////////////////////////////////////////////////////////////////////

    printf("\nStarting disk extension DLL tests \n");
    
    outBuffer = LocalAlloc( LMEM_FIXED, outBufferSize );
    
    if ( !outBuffer ) {
        
        dwStatus = GetLastError();
        goto FnExit;
    }
    
    //////////////////////////////////////////////////////////////////////////
    //
    // Buffer verification tests
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // No input buffer - should fail.
    //
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       NULL,                                    // Error
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("Input buffer missing: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

    //
    // Incorrect input buffer size - should fail.
    //
                                          
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       28,                                      // Error
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("Input buffer size incorrect: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);
    
    //
    // Input buffer incorrect version - should fail.
    //
    
    ZeroMemory( &inBuffer, sizeof(inBuffer) );

    inBuffer.MajorVersion = NT4_MAJOR_VERSION;                                  // Error
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );
    
    printf("Input buffer version incorrect: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);
    
    //
    // No output buffer - should fail.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       NULL,                                    // Error
                                       outBufferSize,
                                       &bytesReturned );

    printf("Output buffer missing: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);
    
    //////////////////////////////////////////////////////////////////////////
    //
    // DLL verification tests
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Invalid DLL name - should fail.
    // 

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy( inBuffer.DllModuleName, MODULE_NAME_INVALID );                      // Error
    strcpy( inBuffer.DllProcName, PROC_NAME_INVALID );
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL name invalid: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);
    
    //
    // Valid DLL, invalid proc name - should fail.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy( inBuffer.DllModuleName, MODULE_NAME_VALID );
    strcpy( inBuffer.DllProcName, PROC_NAME_INVALID );                          // Error
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL valid, Proc invalid: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

    //
    // DLL procedure generates exception - should fail gracefully.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy( inBuffer.DllModuleName, MODULE_NAME_VALID );
    strcpy( inBuffer.DllProcName, PROC_EXCEPTION );                          
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL proc generates exception: %d (0x%x) [failure expected] \n", dwStatus, dwStatus);
    PrintError(dwStatus);
    
#if 0
    //
    // We can't protect against this type of error, so don't test it.
    //
    
    //
    // DLL procedure has less parameters then we are calling - should fail gracefully.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy( inBuffer.DllModuleName, MODULE_NAME_VALID );
    strcpy( inBuffer.DllProcName, PROC_NOT_ENOUGH_PARMS );                          
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL proc doesn't support required number of parms: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);
    
    //
    // DLL procedure has more parameters then we are calling - should fail gracefully.
    //                                               

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy( inBuffer.DllModuleName, MODULE_NAME_VALID );
    strcpy( inBuffer.DllProcName, PROC_TOO_MANY_PARMS );                          
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL proc supports more parms than expected: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);
#endif
    
    //
    // DLL procedure returns error based on context.
    //
    
    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy( inBuffer.DllModuleName, MODULE_NAME_VALID );
    strcpy( inBuffer.DllProcName, PROC_CONTEXT_AS_ERROR );
    strcpy( inBuffer.ContextStr, CONTEXT_ERROR_STR );
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL proc returns error based on context (%s) : %d [failure expected] \n", 
           CONTEXT_ERROR_STR, 
           dwStatus);
    PrintError(dwStatus);
        
    //
    // Amount of data returned is larger than the buffer we specified.  Should 
    // indicate an error and bytesReturned should show how many bytes we need.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy( inBuffer.DllModuleName, MODULE_NAME_VALID );
    strcpy( inBuffer.DllProcName, PROC_GET_BOOT_SECTOR );
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       55,
                                       &bytesReturned );
    
    printf("Output buffer too small (bytes returned %d): %d [failure expected] \n", bytesReturned, dwStatus);
    PrintError(dwStatus);
         
    //
    // This one should work.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    ZeroMemory( outBuffer, outBufferSize );
    
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy( inBuffer.DllModuleName, MODULE_NAME_VALID );
    strcpy( inBuffer.DllProcName, PROC_GET_BOOT_SECTOR );
    
    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("Boot sector (bytes returned %d): %d \n", bytesReturned, dwStatus);
    PrintError(dwStatus);

    if ( bytesReturned == BOOT_SECTOR_SIZE ) {
        PrintBootRecord( outBuffer, BOOT_SECTOR_SIZE );    
    } 
    
FnExit:

    if ( outBuffer ) {
        LocalFree( outBuffer);
    }
    
    //
    // If you return any kind of error, the enumeration stops.  Since we want to enumerate all
    // the disks, always return success.
    //
    
    return NO_ERROR;
    
}   // ResourceCallBack


DWORD 
GetResourceInfo(
    RESOURCE_HANDLE hOriginal,   
    RESOURCE_HANDLE hResource,  
    PVOID lpParams   
    )
{
    DWORD dwSignature;
    DWORD dwStatus;

    RESOURCE_STATE resState;
    
    ZeroMemory( &resState, sizeof(RESOURCE_STATE) );
    
    dwStatus = GetSignature( hResource, &dwSignature );    

    if ( NO_ERROR != dwStatus ) {
        printf("Unable to get signature: %d \n", dwStatus);
        PrintError(dwStatus);
        goto FnExit;
    }
    
    dwStatus = GetResourceState( hResource, &resState );

    if ( NO_ERROR != dwStatus ) {
        printf("Unable to get resource state: %d \n", dwStatus);
        PrintError(dwStatus);
        goto FnExit;
    }

    printf("\n");
    printf("Signature: %08X \n", dwSignature);
    printf("Node     : %ws \n",  resState.ResNodeName); 
    printf("Group    : %ws \n", resState.ResGroupName); 
    
    printf("Status   : %08X - ", resState.State);

    switch( resState.State )
    {
        case ClusterResourceInherited:
            printf("Inherited");
            break;

        case ClusterResourceInitializing:
            printf("Initializing");
            break;

        case ClusterResourceOnline:
            printf("Online");
            break;

        case ClusterResourceOffline:
            printf("Offline");
            break;

        case ClusterResourceFailed:
            printf("Failed");
            break;

        case ClusterResourcePending:
            printf("Pending");
            break;

        case ClusterResourceOnlinePending:
            printf("Online Pending");
            break;

        case ClusterResourceOfflinePending:
            printf("Offline Pending");
            break;

        default:
            printf("Unknown");
    }

    printf("\n");

FnExit:

    if ( resState.ResNodeName ) {
        LocalFree( resState.ResNodeName );
    }
    
    if ( resState.ResGroupName ) {
        LocalFree( resState.ResGroupName );            
    }
    
    return dwStatus;
    
} // GetResourceInfo


DWORD
GetResourceState(
    HRESOURCE Resource,
    PRESOURCE_STATE ResState
    )
{
    CLUSTER_RESOURCE_STATE  nState;

    LPWSTR  lpszResNodeName = NULL;
    LPWSTR  lpszResGroupName = NULL;

    DWORD   dwStatus = NO_ERROR;                
        
    nState = WrapGetClusterResourceState( Resource,
                                          &lpszResNodeName,
                                          &lpszResGroupName
                                          );
                                          
    if ( nState == ClusterResourceStateUnknown ) {
    
        dwStatus = GetLastError();
        printf("WrapGetClusterResourceState failed: %d \n", dwStatus);
        PrintError(dwStatus);
        goto FnExit;
    }
    
    ResState->State = nState;
    ResState->ResNodeName = lpszResNodeName;
    ResState->ResGroupName = lpszResGroupName;

FnExit:
    
    return dwStatus;
                                          
}   // GetResourceState


DWORD
DisplayResourceName(
    RESOURCE_HANDLE hResource
    )
{
    LPWSTR  lpszOutBuffer = NULL;
    DWORD   dwStatus;
    DWORD   dwBytesReturned;

    dwStatus = WrapClusterResourceControl( hResource,
                                          CLUSCTL_RESOURCE_GET_NAME,
                                          &lpszOutBuffer,
                                          &dwBytesReturned );

    if ( NO_ERROR == dwStatus ) {
        wprintf( L"Resource Name: %ls\n", lpszOutBuffer );

    } else {
        printf("CLUSCTL_RESOURCE_GET_NAME failed: %d \n", dwStatus);
        PrintError(dwStatus);
    }

    if (lpszOutBuffer) {
        LocalFree(lpszOutBuffer);
    }
    
    return dwStatus;
                                      
}   // DisplayResourceName


DWORD
GetSignature(
    RESOURCE_HANDLE hResource,
    DWORD *dwSignature
    )
{
    PBYTE   outBuffer = NULL;
    
    DWORD   dwStatus;
    DWORD   dwBytesReturned;

    dwStatus = WrapClusterResourceControl( hResource,
                                          CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                                          &outBuffer,
                                          &dwBytesReturned );

    if ( NO_ERROR == dwStatus ) {
        
        if ( !GetSignatureFromDiskInfo(outBuffer, dwSignature, dwBytesReturned) ) {
            printf("Unable to get signature from DiskInfo. \n");
            dwStatus = ERROR_BAD_FORMAT;
        }
    
    } else {
        printf("CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO failed: %d \n", dwStatus);
        PrintError(dwStatus);
    }

    if (outBuffer) {
        LocalFree(outBuffer);
    }
    
    return dwStatus;
                                      
}   // GetSignature

BOOLEAN
GetSignatureFromDiskInfo(
    PBYTE DiskInfo,
    DWORD *Signature,
    DWORD DiskInfoSize
    )
{
#if TEST_PARSE_ROUTINE

    PCLUSPROP_DISK_NUMBER   diskNumber = NULL;
    PCLUSPROP_SCSI_ADDRESS  scsiAddress = NULL;
    PCLUSPROP_PARTITION_INFO    partInfo = NULL;
    
    PBYTE   junkInfo = NULL;
    PDWORD  dumpInfo = (PDWORD)DiskInfo;
    
#endif
    
    PCLUSPROP_DISK_SIGNATURE    diskSignature = NULL;
    
    diskSignature = (PCLUSPROP_DISK_SIGNATURE)ParseDiskInfo( DiskInfo, 
                                                             DiskInfoSize, 
                                                             CLUSPROP_SYNTAX_DISK_SIGNATURE );

    if ( !diskSignature ) {
        return FALSE;
    }

    *Signature = diskSignature->dw;
    
#if TEST_PARSE_ROUTINE

    diskNumber = (PCLUSPROP_DISK_NUMBER)ParseDiskInfo( DiskInfo,
                                                       DiskInfoSize,
                                                       CLUSPROP_SYNTAX_DISK_NUMBER );

    if ( diskNumber ) {
        printf("diskNumber->Syntax:   %08X \n", diskNumber->Syntax);
        printf("diskNumber->cbLength: %08X \n", diskNumber->cbLength);
        printf("diskNumber->dw:       %08X \n", diskNumber->dw);
    }
    
    scsiAddress = (PCLUSPROP_SCSI_ADDRESS)ParseDiskInfo( DiskInfo,
                                                         DiskInfoSize,
                                                         CLUSPROP_SYNTAX_SCSI_ADDRESS );

    if ( scsiAddress ) {
        printf("scsiAddress->Syntax:     %08X \n", scsiAddress->Syntax);
        printf("scsiAddress->cbLength:   %08X \n", scsiAddress->cbLength);
        printf("scsiAddress->PortNumber: %02X \n", scsiAddress->PortNumber);
        printf("scsiAddress->PathId:     %02X \n", scsiAddress->PathId);
        printf("scsiAddress->TargetId:   %02X \n", scsiAddress->TargetId);
        printf("scsiAddress->Lun:        %02X \n", scsiAddress->Lun);
    }

    partInfo = (PCLUSPROP_PARTITION_INFO)ParseDiskInfo( DiskInfo,
                                                        DiskInfoSize,
                                                        CLUSPROP_SYNTAX_PARTITION_INFO );    

    if ( partInfo ) {
    
        printf("Partition info... \n");    
    }
    
    
    //
    // The following should fail...
    //
                                                            
    junkInfo = ParseDiskInfo( DiskInfo,
                              DiskInfoSize,
                              -1 );
                              
    if (junkInfo) {
        printf("Problem parsing list.  Used invalid syntax and pointer returned! \n");
    }

#endif

    
    return TRUE;
    
}   // GetSignatureFromDiskInfo
    

LPBYTE
ParseDiskInfo(
    PBYTE DiskInfo,
    DWORD DiskInfoSize,
    DWORD SyntaxValue
    )
{
    CLUSPROP_BUFFER_HELPER ListEntry; // used to parse the value list

    DWORD  cbOffset    = 0;    // offset to next entry in the value list
    DWORD  cbPosition  = 0;    // tracks the advance through the value list buffer

    LPBYTE returnPtr = 0;
                                  
    ListEntry.pb = DiskInfo;

    while (TRUE) {
        
        if ( CLUSPROP_SYNTAX_ENDMARK == *ListEntry.pdw ) {
            break;
        }
        
        cbOffset = ALIGN_CLUSPROP( ListEntry.pValue->cbLength + sizeof(CLUSPROP_VALUE) );

        //
        // Check for specific syntax in the property list.
        //
        
        if ( SyntaxValue == *ListEntry.pdw ) {
            
            // 
            // Make sure the complete entry fits in the buffer specified.
            //

            if ( cbPosition + cbOffset > DiskInfoSize ) {
                
                printf("Possibly corrupt list!  \n");
                
            } else {
            
                returnPtr = ListEntry.pb;
            }
            
            break;
        }
    
        //
        // Verify that the offset to the next entry is
        // within the value list buffer, then advance
        // the CLUSPROP_BUFFER_HELPER pointer.
        //
        cbPosition += cbOffset;
        if ( cbPosition > DiskInfoSize ) break;
        ListEntry.pb += cbOffset;
    }

    return returnPtr;
    
}   // ParseDiskInfo
      
      

VOID
PrintError(
    DWORD ErrorCode
    )
{
    UCHAR errorBuffer[ERROR_BUFFER_SIZE];
    ULONG count;

    count = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          ErrorCode,
                          0,
                          errorBuffer,
                          sizeof(errorBuffer),
                          NULL
                          );

    if (count != 0) {
        printf("   %s\n", errorBuffer);
    } else {
        printf("Format message failed.  Error: %d \n\n", GetLastError());
    }

}   // PrintError

                                                   
DWORD
WrapClusterResourceControl(
    RESOURCE_HANDLE hResource,
    DWORD dwControlCode,    
    LPVOID *OutBuffer,
    DWORD *dwBytesReturned
    )
{
    DWORD dwStatus;

    DWORD  cbOutBufferSize  = MAX_NAME_SIZE; 
    DWORD  cbResultSize     = MAX_NAME_SIZE; 
    LPVOID tempOutBuffer    = LocalAlloc( LPTR, cbOutBufferSize );

    dwStatus = ClusterResourceControl( hResource,
                                      NULL,
                                      dwControlCode,
                                      NULL, 
                                      0, 
                                      tempOutBuffer,
                                      cbOutBufferSize, 
                                      &cbResultSize );

    //
    // Reallocation routine if buffer is too small
    //
    
    if ( ERROR_MORE_DATA == dwStatus )
    {
        LocalFree( tempOutBuffer );

        cbOutBufferSize = cbResultSize;

        tempOutBuffer = LocalAlloc( LPTR, cbOutBufferSize );

        dwStatus = ClusterResourceControl( hResource,
                                          NULL,
                                          dwControlCode,
                                          NULL, 
                                          0, 
                                          tempOutBuffer, 
                                          cbOutBufferSize, 
                                          &cbResultSize );
    }

    //
    // On success, give the user the allocated buffer.  The user is responsible
    // for freeing this buffer.  On failure, free the buffer and return a status.
    //
    
    if ( NO_ERROR == dwStatus ) {
        *OutBuffer = tempOutBuffer;
        *dwBytesReturned = cbResultSize;
    } else {
        *OutBuffer = NULL;
        *dwBytesReturned = 0;
        LocalFree( tempOutBuffer );
    }
    
    return dwStatus;

}   // WrapClusterResourceControl



CLUSTER_RESOURCE_STATE WINAPI WrapGetClusterResourceState(
	IN HRESOURCE hResource,
	OUT OPTIONAL LPWSTR * ppwszNodeName,
	OUT OPTIONAL LPWSTR * ppwszGroupName
	)
{
	CLUSTER_RESOURCE_STATE	cState = ClusterResourceStateUnknown;
	LPWSTR					pwszNodeName = NULL;
	DWORD					cchNodeName = 128;
	LPWSTR					pwszGroupName = NULL;
	DWORD					cchGroupName = 128;
	DWORD					cchTempNodeName = cchNodeName;
	DWORD					cchTempGroupName = cchGroupName;

	// Zero the out parameters
	if ( ppwszNodeName != NULL )
	{
		*ppwszNodeName = NULL;
	}

	if ( ppwszGroupName != NULL )
	{
		*ppwszGroupName = NULL;
	}

	pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
	if ( pwszNodeName != NULL )
	{
		pwszGroupName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchGroupName * sizeof( *pwszGroupName ) );
		if ( pwszGroupName != NULL )
		{
			cState = GetClusterResourceState( hResource, pwszNodeName, &cchTempNodeName, pwszGroupName, &cchTempGroupName );
			if ( GetLastError() == ERROR_MORE_DATA )
			{
				cState = ClusterResourceStateUnknown;	// reset to error condition

				LocalFree( pwszNodeName );
				pwszNodeName = NULL;
				cchNodeName = ++cchTempNodeName;

				LocalFree( pwszGroupName );
				pwszGroupName = NULL;
				cchGroupName = ++cchTempGroupName;

				pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
				if ( pwszNodeName != NULL )
				{
					pwszGroupName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchGroupName * sizeof( *pwszGroupName ) );
					if ( pwszGroupName != NULL )
					{
						cState = GetClusterResourceState( hResource,
															pwszNodeName,
															&cchNodeName,
															pwszGroupName,
															&cchGroupName );
					}
				}
			}
		}
	}

	//
	// if there was not an error and the argument was not NULL, then return the string.
	//
	if ( ( cState != ClusterResourceStateUnknown ) && ( ppwszNodeName != NULL ) )
	{
		*ppwszNodeName = pwszNodeName;
	}

	//
	// if there was not an error and the argument was not NULL, then return the string.
	//
	if ( ( cState != ClusterResourceStateUnknown ) && ( ppwszGroupName != NULL ) )
	{
		*ppwszGroupName = pwszGroupName;
	}

	//
	// if there was an error or the argument was NULL, then free the string.
	//
	if ( ( cState == ClusterResourceStateUnknown ) || ( ppwszNodeName == NULL ) )
	{
		LocalFree( pwszNodeName );
	}

	//
	// if there was an error or the argument was NULL, then free the string.
	//
	if ( ( cState == ClusterResourceStateUnknown ) || ( ppwszGroupName == NULL ) )
	{
		LocalFree( pwszGroupName );
	}

	return cState;

} //*** WrapGetClusterResourceState()



VOID
PrintBootRecord(
    IN PUCHAR bootSector,
    IN DWORD byteCount
    )
{
    USHORT  i;
    USHORT  j;

    CHAR    tempC;

    if (byteCount != BOOT_SECTOR_SIZE) {
        printf("Invalid number of bytes in boot sector: %d \n", byteCount);
        return;
    }

    //
    // Print header.
    //

    printf("Addr  ");

    for (i = 0; i < 16; i++) {

        printf("%02x ", i);

        if (i == 7) {

            printf("- ");

        }
    }

    printf("\n----  ");

    for (i = 0; i < 16; i++) {

        printf("-- ");

        if (i == 7) {

            printf("  ");
        }

    }

    //
    // Print boot sector.
    //

    for (i = 0; i < BOOT_SECTOR_SIZE; i += 16) {

        if (i % 16 == 0) {
            printf("\n%03x:  ", i);
        }

        for (j = 0; j < 16; j++) {

            if (j == 8) {
                printf("- ");
            }

            printf("%02x ", bootSector[i+j]);
        }

        printf("   ");

        for (j = 0; j < 16; j++) {

            tempC = bootSector[i+j];

            if (!isascii(tempC) || isspace(tempC)  ||
                tempC == 0 || tempC == 0x07) {

                printf(".");

            } else {

                printf("%c", tempC);

            }

        }

    }

    printf("\n\n");

}   // PrintBootRecord
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.cpp
//
//	Description:
//		Implementation of custom dialog data exchange/dialog data validation
//		routines.
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//		The IDS_REQUIRED_FIELD_EMPTY string resource must be defined in
//		the resource file.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DDxDDv.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////
static void CleanupLabel(LPTSTR psz);


/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_Number
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		dwValue		[IN OUT] Value to set or get.
//		dwMin		[IN] Minimum value.
//		dwMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned
	)
{
	HWND	hwndCtrl;
	DWORD	dwValue;

	ASSERT(pDX != NULL);
#ifdef _DEBUG
	if (bSigned)
	{
		ASSERT((LONG) dwMin < (LONG) dwMax);
	}
	else
	{
		ASSERT(dwMin < dwMax);
	}
#endif // _DEBUG

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Get the control window handle.
	hwndCtrl = pDX->PrepareEditCtrl(nIDC);

	if (pDX->m_bSaveAndValidate)
	{
		BOOL	bTranslated;

		// Get the number from the control.
		dwValue = GetDlgItemInt(pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned);

		// If the retrival failed, it is a signed number, and the minimum
		// value is the smallest negative value possible, check the string itself.
		if (!bTranslated && bSigned && (dwMin == 0x80000000))
		{
			UINT	cch;
			TCHAR	szNumber[20];

			// See if it is the smallest negative number.
			cch = GetDlgItemText(pDX->m_pDlgWnd->m_hWnd, nIDC, szNumber, sizeof(szNumber) / sizeof(TCHAR));
			if ((cch != 0) && (lstrcmp(szNumber, _T("-2147483648")) == 0))
			{
				dwValue = 0x80000000;
				bTranslated = TRUE;
			}  // if:  text retrieved successfully and is highest negative number
		}  // if:  error translating number and getting signed number

		// If the retrieval failed or the specified number is
		// out of range, display an error.
		if (   !bTranslated
			|| (bSigned && (((LONG) dwValue < (LONG) dwMin) || ((LONG) dwValue > (LONG) dwMax)))
			|| (!bSigned && ((dwValue < dwMin) || (dwValue > dwMax)))
			)
		{
			TCHAR szMin[32];
			TCHAR szMax[32];
			CString strPrompt;

			if (bSigned)
			{
				wsprintf(szMin, _T("%d%"), dwMin);
				wsprintf(szMax, _T("%d%"), dwMax);
			}  // if:  signed number
			else
			{
				wsprintf(szMin, _T("%u%"), dwMin);
				wsprintf(szMax, _T("%u%"), dwMax);
			}  // else:  unsigned number
			AfxFormatString2(strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
			strPrompt.Empty(); // exception prep
			pDX->Fail();
		}  // if:  invalid string
		else
			rdwValue = dwValue;
	}  // if:  saving data
	else
	{
		CString		strMinValue;
		CString		strMaxValue;
		UINT		cchMax;

		// Set the maximum number of characters that can be entered.
		if (bSigned)
		{
			strMinValue.Format(_T("%d"), dwMin);
			strMaxValue.Format(_T("%d"), dwMax);
		}  // if:  signed value
		else
		{
			strMinValue.Format(_T("%u"), dwMin);
			strMaxValue.Format(_T("%u"), dwMax);
		}  // else:  unsigned value
		cchMax = max(strMinValue.GetLength(), strMaxValue.GetLength());
		SendMessage(hwndCtrl, EM_LIMITTEXT, cchMax, 0);

		// Set the value into the control.
		if (bSigned)
		{
			LONG lValue = (LONG) rdwValue;
			DDX_Text(pDX, nIDC, lValue);
		}  // if:  signed value
		else
			DDX_Text(pDX, nIDC, rdwValue);
	}  // else:  setting data onto the dialog

}  //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_RequiredText
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Value to set or get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	)
{
	ASSERT(pDX != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (pDX->m_bSaveAndValidate)
	{
		if (rstrValue.GetLength() == 0)
		{
			HWND		hwndLabel;
			TCHAR		szLabel[1024];
			CString		strPrompt;

			// Get the label window handle
			hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

			// Get the text of the label.
			GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

			// Remove ampersands (&) and colons (:).
			CleanupLabel(szLabel);

			// Format and display a message.
			strPrompt.FormatMessage(IDS_REQUIRED_FIELD_EMPTY, szLabel);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

			// Do this so that the control receives focus.
			(void) pDX->PrepareEditCtrl(nIDC);

			// Fail the call.
			strPrompt.Empty();	// exception prep
			pDX->Fail();
		}  // if:  field not specified
	}  // if:  saving data

}  //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupLabel
//
//	Routine Description:
//		Prepare a label read from a dialog to be used as a string in a
//		message by removing ampersands (&) and colons (:).
//
//	Arguments:
//		pszLabel	[IN OUT] Label to be cleaned up.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void CleanupLabel(LPTSTR pszLabel)
{
	LPTSTR	pIn, pOut;
	LANGID	langid;
	WORD	primarylangid;
	BOOL	bFELanguage;

	// Get the language ID.
	langid = GetUserDefaultLangID();
	primarylangid = (WORD) PRIMARYLANGID(langid);
	bFELanguage = ((primarylangid == LANG_JAPANESE)
					|| (primarylangid == LANG_CHINESE)
					|| (primarylangid == LANG_KOREAN));

	//
	// copy the name sans '&' and ':' chars
	//

	pIn = pOut = pszLabel;
	do
	{
		//
		// strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
		//
		if (   bFELanguage
			&& (pIn[0] == _T('('))
			&& (pIn[1] == _T('&'))
			&& (pIn[2] != _T('\0'))
			&& (pIn[3] == _T(')')))
		{
			pIn += 3;
		}
		else if ((*pIn != _T('&')) && (*pIn != _T(':')))
			*pOut++ = *pIn;
	} while (*pIn++ != _T('\0')) ;

}  //*** CleanupLabel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.cpp
//
//	Description:
//		Implementation of the CBasePropertyPage class.
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <clusapi.h>
#include "DummyEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBasePropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CBasePropertyPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
	CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		nIDTemplate		[IN] Dialog template resource ID.
//		nIDCaption		[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN UINT		nIDTemplate,
	IN UINT		nIDCaption
	)
	: CPropertyPage(nIDTemplate, nIDCaption)
{
	CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CommonConstruct
//
//	Routine Description:
//		Common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct(void)
{
	//{{AFX_DATA_INIT(CBasePropertyPage)
	//}}AFX_DATA_INIT

	m_peo = NULL;
	m_hpage = NULL;
	m_bBackPressed = FALSE;

	m_iddPropertyPage = NULL;
	m_iddWizardPage = NULL;
	m_idsCaption = NULL;

	m_bDoDetach = FALSE;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		peo			[IN OUT] Pointer to the extension object.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BInit(IN OUT CExtObject * peo)
{
	ASSERT(peo != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	m_peo = peo;

	// Don't display a help button.
	m_psp.dwFlags &= ~PSP_HASHELP;

	// Construct the property page.
	if (Peo()->BWizard())
	{
		ASSERT(IddWizardPage() != NULL);
		Construct(IddWizardPage(), IdsCaption());
	}  // if:  adding page to wizard
	else
	{
		ASSERT(IddPropertyPage() != NULL);
		Construct(IddPropertyPage(), IdsCaption());
	}  // else:  adding page to property sheet

	// Read the properties private to this resource and parse them.
	{
		DWORD			dwStatus = ERROR_SUCCESS;
		CClusPropList	cpl;

		ASSERT(Peo() != NULL);
		ASSERT(Peo()->PodObjData());

		// Read the properties.
		switch (Cot())
		{
			case CLUADMEX_OT_NODE:
				ASSERT(Peo()->PndNodeData()->m_hnode != NULL);
				dwStatus = cpl.DwGetNodeProperties(
										Peo()->PndNodeData()->m_hnode,
										CLUSCTL_NODE_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_GROUP:
				ASSERT(Peo()->PgdGroupData()->m_hgroup != NULL);
				dwStatus = cpl.DwGetGroupProperties(
										Peo()->PgdGroupData()->m_hgroup,
										CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_RESOURCE:
				ASSERT(Peo()->PrdResData()->m_hresource != NULL);
				dwStatus = cpl.DwGetResourceProperties(
										Peo()->PrdResData()->m_hresource,
										CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_RESOURCETYPE:
				ASSERT(Peo()->PodObjData()->m_strName.GetLength() > 0);
				dwStatus = cpl.DwGetResourceTypeProperties(
										Hcluster(),
										Peo()->PodObjData()->m_strName,
										CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_NETWORK:
				ASSERT(Peo()->PndNetworkData()->m_hnetwork != NULL);
				dwStatus = cpl.DwGetNetworkProperties(
										Peo()->PndNetworkData()->m_hnetwork,
										CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_NETINTERFACE:
				ASSERT(Peo()->PndNetInterfaceData()->m_hnetinterface != NULL);
				dwStatus = cpl.DwGetNetInterfaceProperties(
										Peo()->PndNetInterfaceData()->m_hnetinterface,
										CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
										);
				break;
			default:
				ASSERT(0);
		}  // switch:  object type

		// Parse the properties.
		if (dwStatus == ERROR_SUCCESS)
		{
			// Parse the properties.
			try
			{
				dwStatus = DwParseProperties(cpl);
			}  // try
			catch (CMemoryException * pme)
			{
				dwStatus = ERROR_NOT_ENOUGH_MEMORY;
				pme->Delete();
			}  // catch:  CMemoryException
		}  // if:  properties read successfully

		if (dwStatus != ERROR_SUCCESS)
		{
			return FALSE;
		}  // if:  error parsing getting or parsing properties
	}  // Read the properties private to this resource and parse them

	return TRUE;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DwParseProperties
//
//	Routine Description:
//		Parse the properties of the resource.  This is in a separate function
//		from BInit so that the optimizer can do a better job.
//
//	Arguments:
//		rcpl			[IN] Cluster property list to parse.
//
//	Return Value:
//		ERROR_SUCCESS	Properties were parsed successfully.
//
//	Exceptions Thrown:
//		Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwParseProperties(IN const CClusPropList & rcpl)
{
	DWORD							cProps;
	DWORD							cprop;
	DWORD							cbProps;
	const CObjectProperty *			pprop;
	CLUSPROP_BUFFER_HELPER			props;
	CLUSPROP_PROPERTY_NAME const *	pName;

	ASSERT(rcpl.PbProplist() != NULL);

	props.pb = rcpl.PbProplist();
	cbProps = rcpl.CbProplist();

	// Loop through each property.
	for (cProps = *(props.pdw++) ; cProps > 0 ; cProps--)
	{
		pName = props.pName;
		ASSERT(pName->Syntax.dw == CLUSPROP_SYNTAX_NAME);
		props.pb += sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

		// Decrement the counter by the size of the name.
		ASSERT(cbProps > sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength));
		cbProps -= sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

		ASSERT(cbProps > sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength));

		// Parse known properties.
		for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
		{
			if (lstrcmpiW(pName->sz, pprop->m_pwszName) == 0)
			{
				ASSERT(props.pSyntax->wFormat == pprop->m_propFormat);
				switch (pprop->m_propFormat)
				{
					case CLUSPROP_FORMAT_SZ:
					case CLUSPROP_FORMAT_EXPAND_SZ:
						ASSERT((props.pValue->cbLength == (lstrlenW(props.pStringValue->sz) + 1) * sizeof(WCHAR))
								|| ((props.pValue->cbLength == 0) && (props.pStringValue->sz[0] == L'\0')));
						*pprop->m_value.pstr = props.pStringValue->sz;
						*pprop->m_valuePrev.pstr = props.pStringValue->sz;
						break;
					case CLUSPROP_FORMAT_DWORD:
					case CLUSPROP_FORMAT_LONG:
						ASSERT(props.pValue->cbLength == sizeof(DWORD));
						*pprop->m_value.pdw = props.pDwordValue->dw;
						*pprop->m_valuePrev.pdw = props.pDwordValue->dw;
						break;
					case CLUSPROP_FORMAT_BINARY:
					case CLUSPROP_FORMAT_MULTI_SZ:
						*pprop->m_value.ppb = props.pBinaryValue->rgb;
						*pprop->m_value.pcb = props.pBinaryValue->cbLength;
						*pprop->m_valuePrev.ppb = props.pBinaryValue->rgb;
						*pprop->m_valuePrev.pcb = props.pBinaryValue->cbLength;
						break;
					default:
						ASSERT(0);	// don't know how to deal with this type
				}  // switch:  property format

				// Exit the loop since we found the parameter.
				break;
			}  // if:  found a match
		}  // for:  each property

		// If the property wasn't known, ask the derived class to parse it.
		if (cprop == 0)
		{
			DWORD		dwStatus;

			dwStatus = DwParseUnknownProperty(pName->sz, props, cbProps);
			if (dwStatus != ERROR_SUCCESS)
				return dwStatus;
		}  // if:  property not parsed

		// Advance the buffer pointer past the value in the value list.
		while ((props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
				&& (cbProps > 0))
		{
			ASSERT(cbProps > sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength));
			cbProps -= sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
			props.pb += sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
		}  // while:  more values in the list

		// Advance the buffer pointer past the value list endmark.
		ASSERT(cbProps >= sizeof(*props.pSyntax));
		cbProps -= sizeof(*props.pSyntax);
		props.pb += sizeof(*props.pSyntax); // endmark
	}  // for:  each property

	return ERROR_SUCCESS;

}  //*** CBasePropertyPage::DwParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCreate
//
//	Routine Description:
//		Handler for the WM_CREATE message.
//
//	Arguments:
//		lpCreateStruct	[IN OUT] Window create structure.
//
//	Return Value:
//		-1		Error.
//		0		Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Attach the window to the property page structure.
	// This has been done once already in the main application, since the
	// main application owns the property sheet.  It needs to be done here
	// so that the window handle can be found in the DLL's handle map.
	if (FromHandlePermanent(m_hWnd) == NULL) // is the window handle already in the handle map
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach(hWnd);
		m_bDoDetach = TRUE;
	} // if: is the window handle in the handle map

	return CPropertyPage::OnCreate(lpCreateStruct);

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnDestroy
//
//	Routine Description:
//		Handler for the WM_DESTROY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Detach the window from the property page structure.
	// This will be done again by the main application, since it owns the
	// property sheet.  It needs to be done here so that the window handle
	// can be removed from the DLL's handle map.
	if (m_bDoDetach)
	{
		if (m_hWnd != NULL)
		{
			HWND hWnd = m_hWnd;

			Detach();
			m_hWnd = hWnd;
		} // if: do we have a window handle?
	} // if: do we need to balance the attach we did with a detach?

	CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//{{AFX_DATA_MAP(CBasePropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
	DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_PP_TITLE, m_staticTitle);

	if (pDX->m_bSaveAndValidate)
	{
		if (!BBackPressed())
		{
			CWaitCursor	wc;

			// Validate the data.
			if (!BSetPrivateProps(TRUE /*bValidateOnly*/))
				pDX->Fail();
		}  // if:  Back button not pressed
	}  // if:  saving data from dialog
	else
	{
		// Set the title.
		DDX_Text(pDX, IDC_PP_TITLE, m_strTitle);
	}  // if:  not saving data

	CPropertyPage::DoDataExchange(pDX);

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog(void)
{
	ASSERT(Peo() != NULL);
	ASSERT(Peo()->PodObjData() != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Set the title string.
	m_strTitle = Peo()->PodObjData()->m_strName;

	// Call the base class method.
	CPropertyPage::OnInitDialog();

	// Display an icon for the object.
	if (Peo()->Hicon() != NULL)
		m_staticIcon.SetIcon(Peo()->Hicon());

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive(void)
{
	HRESULT		hr;

	ASSERT(Peo() != NULL);
	ASSERT(Peo()->PodObjData() != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Reread the data.
	hr = Peo()->HrGetObjectInfo();
	if (hr != NOERROR)
		return FALSE;

	// Set the title string.
	m_strTitle = Peo()->PodObjData()->m_strName;

	m_bBackPressed = FALSE;
	return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnApply
//
//	Routine Description:
//		Handler for the PSM_APPLY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply(void)
{
	ASSERT(!BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	if (!BApplyChanges())
		return FALSE;

	return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardBack
//
//	Routine Description:
//		Handler for the PSN_WIZBACK message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack(void)
{
	LRESULT		lResult;

	ASSERT(BWizard());

	lResult = CPropertyPage::OnWizardBack();
	if (lResult != -1)
		m_bBackPressed = TRUE;

	return lResult;

}  //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardNext
//
//	Routine Description:
//		Handler for the PSN_WIZNEXT message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext(void)
{
	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return -1;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return -1;

	// Create the object.

	return CPropertyPage::OnWizardNext();

}  //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardFinish
//
//	Routine Description:
//		Handler for the PSN_WIZFINISH message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		FALSE	Don't change the page.
//		TRUE	Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish(void)
{
	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return FALSE;

	return CPropertyPage::OnWizardFinish();

}  //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnChangeCtrl
//
//	Routine Description:
//		Handler for the messages sent when a control is changed.  This
//		method can be specified in a message map if all that needs to be
//		done is enable the Apply button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SetModified(TRUE);

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::EnableNext
//
//	Routine Description:
//		Enables or disables the NEXT or FINISH button.
//
//	Arguments:
//		bEnable		[IN] TRUE = enable the button, FALSE = disable the button.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext(IN BOOL bEnable /*TRUE*/)
{
	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	PiWizardCallback()->EnableNext((LONG *) Hpage(), bEnable);

}  //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Save data.
	return BSetPrivateProps();

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BuildPropList
//
//	Routine Description:
//		Build the property list.
//
//	Arguments:
//		rcpl		[IN OUT] Cluster property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CClusPropList::AddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::BuildPropList(
	IN OUT CClusPropList & rcpl
	)
{
	DWORD					cprop;
	const CObjectProperty *	pprop;

	for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
	{
		switch (pprop->m_propFormat)
		{
			case CLUSPROP_FORMAT_SZ:
			case CLUSPROP_FORMAT_EXPAND_SZ:
				rcpl.AddProp(
						pprop->m_pwszName,
						*pprop->m_value.pstr,
						*pprop->m_valuePrev.pstr
						);
				break;
			case CLUSPROP_FORMAT_DWORD:
				rcpl.AddProp(
						pprop->m_pwszName,
						*pprop->m_value.pdw,
						*pprop->m_valuePrev.pdw
						);
				break;
			case CLUSPROP_FORMAT_BINARY:
			case CLUSPROP_FORMAT_MULTI_SZ:
				rcpl.AddProp(
						pprop->m_pwszName,
						*pprop->m_value.ppb,
						*pprop->m_value.pcb,
						*pprop->m_valuePrev.ppb,
						*pprop->m_valuePrev.pcb
						);
				break;
			default:
				ASSERT(0);	// don't know how to deal with this type
				return;
		}  // switch:  property format
	}  // for:  each property

}  //*** CBasePropertyPage::BuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BSetPrivateProps
//
//	Routine Description:
//		Set the private properties for this object.
//
//	Arguments:
//		bValidateOnly	[IN] TRUE = only validate the data.
//
//	Return Value:
//		ERROR_SUCCESS	The operation was completed successfully.
//		!0				Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BSetPrivateProps(IN BOOL bValidateOnly)
{
	BOOL			bSuccess	= TRUE;
	CClusPropList	cpl(BWizard() /*bAlwaysAddProp*/);
	CWaitCursor	wc;

	ASSERT(Peo() != NULL);

	// Build the property list.
	try
	{
		BuildPropList(cpl);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		bSuccess = FALSE;
	}  // catch:  CException

	// Set the data.
	if (bSuccess)
	{
		if ((cpl.PbProplist() != NULL) && (cpl.CbProplist() > 0))
		{
			DWORD		dwStatus = ERROR_SUCCESS;
			DWORD		dwControlCode;
			DWORD		cbProps;

			switch (Cot())
			{
				case CLUADMEX_OT_NODE:
					ASSERT(Peo()->PndNodeData() != NULL);
					ASSERT(Peo()->PndNodeData()->m_hnode != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_NODE_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterNodeControl(
									Peo()->PndNodeData()->m_hnode,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_GROUP:
					ASSERT(Peo()->PgdGroupData() != NULL);
					ASSERT(Peo()->PgdGroupData()->m_hgroup != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterGroupControl(
									Peo()->PgdGroupData()->m_hgroup,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_RESOURCE:
					ASSERT(Peo()->PrdResData() != NULL);
					ASSERT(Peo()->PrdResData()->m_hresource != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterResourceControl(
									Peo()->PrdResData()->m_hresource,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_RESOURCETYPE:
					ASSERT(Peo()->PodObjData() != NULL);
					ASSERT(Peo()->PodObjData()->m_strName.GetLength() > 0);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterResourceTypeControl(
									Hcluster(),
									Peo()->PodObjData()->m_strName,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_NETWORK:
					ASSERT(Peo()->PndNetworkData() != NULL);
					ASSERT(Peo()->PndNetworkData()->m_hnetwork != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterNetworkControl(
									Peo()->PndNetworkData()->m_hnetwork,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_NETINTERFACE:
					ASSERT(Peo()->PndNetInterfaceData() != NULL);
					ASSERT(Peo()->PndNetInterfaceData()->m_hnetinterface != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterNetInterfaceControl(
									Peo()->PndNetInterfaceData()->m_hnetinterface,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				default:
					ASSERT(0);
			}  // switch:  object type

			// Handle errors.
			if (dwStatus != ERROR_SUCCESS)
			{
				CString strMsg;
				FormatError(strMsg, dwStatus);
				AfxMessageBox(strMsg);
				if (bValidateOnly
						|| (dwStatus != ERROR_RESOURCE_PROPERTIES_STORED))
					bSuccess = FALSE;
			}  // if:  error setting/validating data
		}  // if:  there is data to set
	}  // if:  no errors building the property list

	// Save data locally.
	if (!bValidateOnly && bSuccess)
	{
		// Save new values as previous values.
		try
		{
			DWORD					cprop;
			const CObjectProperty *	pprop;

			for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
			{
				switch (pprop->m_propFormat)
				{
					case CLUSPROP_FORMAT_SZ:
					case CLUSPROP_FORMAT_EXPAND_SZ:
						ASSERT(pprop->m_value.pstr != NULL);
						ASSERT(pprop->m_valuePrev.pstr != NULL);
						*pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
						break;
					case CLUSPROP_FORMAT_DWORD:
						ASSERT(pprop->m_value.pdw != NULL);
						ASSERT(pprop->m_valuePrev.pdw != NULL);
						*pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
						break;
					case CLUSPROP_FORMAT_BINARY:
					case CLUSPROP_FORMAT_MULTI_SZ:
						ASSERT(pprop->m_value.ppb != NULL);
						ASSERT(*pprop->m_value.ppb != NULL);
						ASSERT(pprop->m_value.pcb != NULL);
						ASSERT(pprop->m_valuePrev.ppb != NULL);
						ASSERT(*pprop->m_valuePrev.ppb != NULL);
						ASSERT(pprop->m_valuePrev.pcb != NULL);
						delete [] *pprop->m_valuePrev.ppb;
						*pprop->m_valuePrev.ppb = new BYTE[*pprop->m_value.pcb];
						CopyMemory(*pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb);
						*pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
						break;
					default:
						ASSERT(0);	// don't know how to deal with this type
				}  // switch:  property format
			}  // for:  each property
		}  // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  // if:  not just validating and successful so far

	return bSuccess;

}  //*** CBasePropertyPage::BSetPrivateProps()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.h
//
//	Description:
//		Definition of the CBasePropertyPage class.  This class provides base
//		functionality for extension DLL property pages.
//
//	Implementation File:
//		BasePage.cpp
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _EXTOBJ_H_
#include "ExtObj.h"		// for CExtObject
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
	CBasePropertyPage(void);
	CBasePropertyPage(IN UINT nIDTemplate, IN UINT nIDCaption = 0);
	virtual ~CBasePropertyPage(void) { }

	// Second phase construction.
	virtual BOOL			BInit(IN OUT CExtObject * peo);
	BOOL					BCreateParamsKey(void);

protected:
	void					CommonConstruct(void);

// Attributes
protected:
	CExtObject *			m_peo;
	HPROPSHEETPAGE			m_hpage;

	IDD						m_iddPropertyPage;
	IDD						m_iddWizardPage;
	IDS						m_idsCaption;

	HPROPSHEETPAGE			Hpage(void) const				{ return m_hpage; }

	IDD						IddPropertyPage(void) const		{ return m_iddPropertyPage; }
	IDD						IddWizardPage(void) const		{ return m_iddWizardPage; }
	IDS						IdsCaption(void) const			{ return m_idsCaption; }

public:
	CExtObject *			Peo(void) const					{ return m_peo; }
	void					SetHpage(IN OUT HPROPSHEETPAGE hpage) { m_hpage = hpage; }
	CLUADMEX_OBJECT_TYPE	Cot(void) const;

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;
	CString	m_strTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual DWORD			DwParseUnknownProperty(
								IN LPCWSTR							pwszName,
								IN const CLUSPROP_BUFFER_HELPER &	rvalue,
								IN DWORD							cbBuf
								)		{ return ERROR_SUCCESS; }
	virtual BOOL			BApplyChanges(void);
	virtual void			BuildPropList(IN OUT CClusPropList & rcpl);

	virtual const CObjectProperty *	Pprops(void) const	{ return NULL; }
	virtual DWORD					Cprops(void) const	{ return 0; }

// Implementation
protected:
	BOOL					m_bBackPressed;
	BOOL					m_bDoDetach;

	BOOL					BBackPressed(void) const		{ return m_bBackPressed; }
	IWCWizardCallback *		PiWizardCallback(void) const;
	BOOL					BWizard(void) const;
	HCLUSTER				Hcluster(void) const;
	void					EnableNext(IN BOOL bEnable = TRUE);

	DWORD					DwParseProperties(IN const CClusPropList & rcpl);
	BOOL					BSetPrivateProps(IN BOOL bValidateOnly = FALSE);

	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Description:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DDXDDV_H_
#define _DDXDDV_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

inline void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT LONG &			rnValue,
	IN LONG					nMin,
	IN LONG					nMax,
	IN BOOL					bSigned
	)
{
	DDX_Number(pDX, nIDC, (DWORD &) rnValue, (DWORD) nMin, (DWORD) nMax, bSigned);
}

/////////////////////////////////////////////////////////////////////////////

#endif // _DDXDDV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\dummyex.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		DummyEx.h
//
//	Abstract:
//		Global definitions across the DLL.
//
//	Implementation File:
//		DummyEx.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DUMMYEX_H_
#define _DUMMYEX_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_DUMMY_PENDING L"Pending"
#define REGPARAM_DUMMY_PENDTIME L"PendTime"
#define REGPARAM_DUMMY_OPENSFAIL L"OpensFail"
#define REGPARAM_DUMMY_FAILED L"Failed"
#define REGPARAM_DUMMY_ASYNCHRONOUS L"Asynchronous"

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

// Defined in Extensn.cpp
extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // _DUMMYEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Description:
//		Implementation of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DummyEx.h"
#include "ExtObj.h"
#include "ResProp.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
		L"Dummy\0"
		;
const DWORD g_cchResourceTypeNames	= sizeof(g_wszResourceTypeNames) / sizeof(WCHAR);

static CRuntimeClass * g_rgprtcResPSPages[]	= {
	RUNTIME_CLASS(CDummyParamsPage),
	NULL
	};
static CRuntimeClass ** g_rgpprtcResPSPages[]	= {
	g_rgprtcResPSPages,
	};
static CRuntimeClass ** g_rgpprtcResWizPages[]	= {
	g_rgprtcResPSPages,
	};

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CExtObject
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
	m_piData = NULL;
	m_piWizardCallback = NULL;
	m_bWizard = FALSE;
	m_istrResTypeName = 0;

	m_lcid = NULL;
	m_hfont = NULL;
	m_hicon = NULL;
	m_hcluster = NULL;
	m_cobj = 0;
	m_podObjData = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::~CExtObject
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
	// Release the data interface.
	if (PiData() != NULL)
	{
		PiData()->Release();
		m_piData = NULL;
	}  // if:  we have a data interface pointer

	// Release the wizard callback interface.
	if (PiWizardCallback() != NULL)
	{
		PiWizardCallback()->Release();
		m_piWizardCallback = NULL;
	}  // if:  we have a wizard callback interface pointer

	// Delete the pages.
	{
		POSITION	pos;

		pos = Lpg().GetHeadPosition();
		while (pos != NULL)
			delete Lpg().GetNext(pos);
	}  // Delete the pages

	delete m_podObjData;

}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//	Routine Description:
//		Indicates whether an interface suportes the IErrorInfo interface.
//		This interface is provided by ATL.
//
//	Arguments:
//		riid		Interface ID.
//
//	Return Value:
//		S_OK		Interface supports IErrorInfo.
//		S_FALSE		Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID * rgiid[] =
	{
		&IID_IWEExtendPropertySheet,
		&IID_IWEExtendWizard,
	};
	int		iiid;

	for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
	{
		if (InlineIsEqualGUID(*rgiid[iiid], riid))
			return S_OK;
	}
	return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//	Routine Description:
//		Create property sheet pages and add them to the sheet.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the sheet is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
	IN IUnknown *					piData,
	IN IWCPropertySheetCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	CRuntimeClass **	pprtc	= NULL;
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		// Create property pages.
		ASSERT(PodObjData() != NULL);
		switch (PodObjData()->m_cot)
		{
			case CLUADMEX_OT_RESOURCE:
				pprtc = g_rgpprtcResPSPages[IstrResTypeName()];
				break;
			default:
				hr = E_NOTIMPL;
				throw &exc;
				break;
		}  // switch:  object type

		// Create each page.
		for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++)
		{
			// Create the page.
			ppage = (CBasePropertyPage *) pprtc[irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(pprtc[irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddPropertySheetPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page in the list

	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreateWizardPages (IWEExtendWizard)
//
//	Routine Description:
//		Create property sheet pages and add them to the wizard.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the wizard is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
	IN IUnknown *			piData,
	IN IWCWizardCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	CRuntimeClass **	pprtc	= NULL;
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		m_piWizardCallback = piCallback;
		m_bWizard = TRUE;

		// Create property pages.
		ASSERT(PodObjData() != NULL);
		switch (PodObjData()->m_cot)
		{
			case CLUADMEX_OT_RESOURCE:
				pprtc = g_rgpprtcResWizPages[IstrResTypeName()];
				break;
			default:
				hr = E_NOTIMPL;
				throw &exc;
				break;
		}  // switch:  object type

		// Create each page.
		for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++)
		{
			// Create the page.
			ppage = (CBasePropertyPage *) pprtc[irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(pprtc[irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddWizardPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page in the list

	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreateWizardPages() - Failed to add wizard page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreateWizardPages() - Failed to add wizard page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piCallback->Release();
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	return hr;

}  //*** CExtObject::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetUIInfo
//
//	Routine Description:
//		Get info about displaying UI.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	// Save info about all types of objects.
	{
		IGetClusterUIInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_lcid = pi->GetLocale();
		m_hfont = pi->GetFont();
		m_hicon = pi->GetIcon();

		pi->Release();
	}  // Save info about all types of objects

	return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrSaveData
//
//	Routine Description:
//		Save data from the object so that it can be used for the life
//		of the object.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	if (piData != m_piData)
	{
		if (m_piData != NULL)
			m_piData->Release();
		m_piData = piData;
	}  // if:  different data interface pointer

	// Save info about all types of objects.
	{
		IGetClusterDataInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_hcluster = pi->GetClusterHandle();
		m_cobj = pi->GetObjectCount();
		if (Cobj() != 1)	// Only have support for one selected object.
			hr = E_NOTIMPL;

		pi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Save info about all types of objects

	// Save info about this object.
	hr = HrGetObjectInfo();
	if (hr != NOERROR)
		return hr;

	return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectInfo
//
//	Routine Description:
//		Get information about the object.
//
//	Arguments:
//		None.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
	HRESULT						hr	= NOERROR;
	IGetClusterObjectInfo *		piGcoi;
	CLUADMEX_OBJECT_TYPE		cot = CLUADMEX_OT_NONE;
	CException					exc(FALSE /*bAutoDelete*/);
	const CString *				pstrResTypeName = NULL;

	ASSERT(PiData() != NULL);

	// Get object info.
	{
		// Get an IGetClusterObjectInfo interface pointer.
		hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
		if (hr != NOERROR)
			return hr;

		// Read the object data.
		try
		{
			// Delete the previous object data.
			delete m_podObjData;
			m_podObjData = NULL;

			// Get the type of the object.
			cot = piGcoi->GetObjectType(0);
			switch (cot)
			{
				case CLUADMEX_OT_RESOURCE:
					{
						IGetClusterResourceInfo *	pi;

						m_podObjData = new CResData;

						// Get an IGetClusterResourceInfo interface pointer.
						hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &pi);
						if (hr != NOERROR)
							throw &exc;

						PrdResDataRW()->m_hresource = pi->GetResourceHandle(0);
						ASSERT(PrdResDataRW()->m_hresource != NULL);
						if (PrdResDataRW()->m_hresource == NULL)
							hr = E_INVALIDARG;
						else
							hr = HrGetResourceTypeName(pi);
						pi->Release();
						if (hr != NOERROR)
							throw &exc;

						pstrResTypeName = &PrdResDataRW()->m_strResTypeName;
					}  // if:  object is a resource
					break;
				default:
					hr = E_NOTIMPL;
					throw &exc;
			}  // switch:  object type

			PodObjDataRW()->m_cot = cot;
			hr = HrGetObjectName(piGcoi);
		}  // try
		catch (CException * pe)
		{
			pe->Delete();
		}  // catch:  CException

		piGcoi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Get object info

	// If this is a resource or resource type, see if we know about this type.
	if (((cot == CLUADMEX_OT_RESOURCE)
			|| (cot == CLUADMEX_OT_RESOURCETYPE))
		&& (hr == NOERROR))
	{
		LPCWSTR	pwszResTypeName;

		// Find the resource type name in our list.
		// Save the index for use in other arrays.
		for (m_istrResTypeName = 0, pwszResTypeName = g_wszResourceTypeNames
				; *pwszResTypeName != L'\0'
				; m_istrResTypeName++, pwszResTypeName += lstrlenW(pwszResTypeName) + 1
				)
		{
			if (pstrResTypeName->CompareNoCase(pwszResTypeName) == 0)
				break;
		}  // for:  each resource type in the list
		if (*pwszResTypeName == L'\0')
			hr = E_NOTIMPL;
	}  // See if we know about this resource type

	return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectName
//
//	Routine Description:
//		Get the name of the object.
//
//	Arguments:
//		piData			IGetClusterObjectInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IGetClusterObjectInfo::GetObjectInfo().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
	IN OUT IGetClusterObjectInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetObjectName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetObjectName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting object name

		PodObjDataRW()->m_strName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetResourceTypeName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		piData			IGetClusterResourceInfo interface pointer for getting
//							the resource type name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IGetClusterResourceInfo::GetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
	IN OUT IGetClusterResourceInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetResourceTypeName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetResourceTypeName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting resource type name

		PrdResDataRW()->m_strResTypeName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetResourceTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\dummyex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2000 <company name>
//
//	Module Name:
//		DummyEx.cpp
//
//	Abstract:
//		Implementation of the CDummyApp class and DLL initialization
//		routines.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//		NOTE: You must use the MIDL compiler from NT 4.0,
//		version 3.00.44 or greater
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "DummyEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning(disable : 4701) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning(default : 4701)

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CoDummyEx, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hcluster);
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hcluster);

/////////////////////////////////////////////////////////////////////////////
// class CDummyApp
/////////////////////////////////////////////////////////////////////////////

class CDummyApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

/////////////////////////////////////////////////////////////////////////////
// The one and only CDummyApp object

CDummyApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyApp::InitInstance
//
//	Routine Description:
//		Initialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any return codes from CWinApp::InitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDummyApp::InitInstance(void)
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();

}  //*** CDummyApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyApp::ExitInstance
//
//	Routine Description:
//		Deinitialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any return codes from CWinApp::ExitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
int CDummyApp::ExitInstance(void)
{
	_Module.Term();
	return CWinApp::ExitInstance();

}  //*** CDummyApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	FormatError
//
//	Routine Description:
//		Format an error.
//
//	Arguments:
//		rstrError	[OUT] String in which to return the error message.
//		dwError		[IN] Error code to format.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
	DWORD	_cch;
	TCHAR	_szError[512];

	_cch = FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					dwError,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					_szError,
					sizeof(_szError) / sizeof(TCHAR),
					0
					);
	if (_cch == 0)
	{
		// Format the NT status code from NTDLL since this hasn't been
		// integrated into the system yet.
		_cch = FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
						::GetModuleHandle(_T("NTDLL.DLL")),
						dwError,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
						_szError,
						sizeof(_szError) / sizeof(TCHAR),
						0
						);
	}  // if:  error formatting status code from system

	if (_cch > 0)
	{
		rstrError = _szError;
	}  // if:  no error
	else
	{

#ifdef _DEBUG

		DWORD	_sc = GetLastError();

		TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError);

#endif

		rstrError.Format(_T("Error 0x%08.8x"), dwError);

	}  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;

}  //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);

}  //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hRes = S_OK;
	// registers object, typelib and all interfaces in typelib
	hRes = _Module.RegisterServer(FALSE /*bRegTypeLib*/);
	return hRes;

}  //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hRes = S_OK;
	_Module.UnregisterServer();
	return hRes;

}  //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterCluAdminExtension
//
//	Routine Description:
//		Register the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
	HRESULT		hr;
	HRESULT		hrReturn = S_OK;
	LPCWSTR		pwszResTypes = g_wszResourceTypeNames;

	while (*pwszResTypes != L'\0')
	{
		wprintf(L"  %s\n", pwszResTypes);
		hr = RegisterCluAdminResourceTypeExtension(
					hCluster,
					pwszResTypes,
					&CLSID_CoDummyEx
					);
		if (hr != S_OK)
			hrReturn = hr;
		pwszResTypes += lstrlenW(pwszResTypes) + 1;
	}  // while:  more resource types

	return hrReturn;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllUnregisterCluAdminExtension
//
//	Routine Description:
//		Unregister the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
	HRESULT		hr;
	HRESULT		hrReturn = S_OK;
	LPCWSTR		pwszResTypes = g_wszResourceTypeNames;

	while (*pwszResTypes != L'\0')
	{
		wprintf(L"  %s\n", pwszResTypes);
		hr = UnregisterCluAdminResourceTypeExtension(
					hCluster,
					pwszResTypes,
					&CLSID_CoDummyEx
					);
		if (hr != S_OK)
			hrReturn = hr;
		pwszResTypes += lstrlenW(pwszResTypes) + 1;
	}  // while:  more resource types

	return hrReturn;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\proplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		PropList.cpp
//
//	Abstract:
//		Implementation of the CClusPropList class.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define BUFFER_GROWTH_FACTOR 256

/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CClusPropList, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CClusPropList
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropList::CClusPropList(IN BOOL bAlwaysAddProp)
{
	m_proplist.pList = NULL;
	m_propCurrent.pb = NULL;
	m_cbBufferSize = 0;
	m_cbDataSize = 0;

	m_bAlwaysAddProp = bAlwaysAddProp;

}  //*** CClusPropList::CClusPropList();

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::~CClusPropList
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropList::~CClusPropList(void)
{
	delete [] m_proplist.pb;

}  //*** CClusPropList::~CClusPropList();

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		rstrValue		[IN] Value of the property to set in the list.
//		rstrPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR			pwszName,
	IN const CString &	rstrValue,
	IN const CString &	rstrPrevValue
	)
{
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_SZ			pValue;

	ASSERT(pwszName != NULL);

	if (m_bAlwaysAddProp || (rstrValue != rstrPrevValue))
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_SZ)
						+ ALIGN_CLUSPROP((rstrValue.GetLength() + 1) * sizeof(WCHAR))
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pStringValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, rstrValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value has changed

}  //*** CClusPropList::AddProp(CString)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a DWORD property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		dwValue			[IN] Value of the property to set in the list.
//		dwPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR		pwszName,
	IN DWORD		dwValue,
	IN DWORD		dwPrevValue
	)
{
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_DWORD			pValue;

	ASSERT(pwszName != NULL);

	if (m_bAlwaysAddProp || (dwValue != dwPrevValue))
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_DWORD)
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pDwordValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, dwValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value has changed

}  //*** CClusPropList::AddProp(DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a binary property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pbValue			[IN] Value of the property to set in the list.
//		cbValue			[IN] Count of bytes in pbValue.
//		pbPrevValue		[IN] Previous value of the property.
//		cbPrevValue		[IN] Count of bytes in pbPrevValue.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR			pwszName,
	IN const PBYTE		pbValue,
	IN DWORD			cbValue,
	IN const PBYTE		pbPrevValue,
	IN DWORD			cbPrevValue
	)
{
	BOOL					bChanged = FALSE;
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_BINARY		pValue;

	ASSERT(pwszName != NULL);
	ASSERT(((cbValue == 0) && (cbPrevValue == 0)) || (pbValue != pbPrevValue));

	// Determine if the buffer has changed.
	if (m_bAlwaysAddProp || (cbValue != cbPrevValue))
		bChanged = TRUE;
	else if (!((cbValue == 0) && (cbPrevValue == 0)))
		bChanged = memcmp(pbValue, pbPrevValue, cbValue) == 0;

	if (bChanged)
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_BINARY)
						+ ALIGN_CLUSPROP(cbValue)
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pBinaryValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value changed

}  //*** CClusPropList::AddProp(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of string.
//		pwsz		[IN] String to copy.
//		cbsz		[IN] Count of bytes in pwsz string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN LPCWSTR					pwsz,
	IN DWORD					cbsz
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);
	ASSERT(pwsz != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
	pprop->Syntax.wType = (WORD) proptype;
	if (cbsz == 0)
		cbsz = (lstrlenW(pwsz) + 1) * sizeof(WCHAR);
	ASSERT(cbsz == (lstrlenW(pwsz) + 1) * sizeof(WCHAR));
	pprop->cbLength = cbsz;
	lstrcpyW(pprop->sz, pwsz);

	// Set an endmark.
	props.pStringValue = pprop;
	props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cbsz);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(CString)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a DWORD property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of DWORD.
//		dw			[IN] DWORD to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_DWORD			pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN DWORD					dw
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
	pprop->Syntax.wType = (WORD) proptype;
	pprop->cbLength = sizeof(DWORD);
	pprop->dw = dw;

	// Set an endmark.
	props.pDwordValue = pprop;
	props.pb += sizeof(*props.pDwordValue);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a binary property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of string.
//		pb			[IN] Block to copy.
//		cbsz		[IN] Count of bytes in pb buffer.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_BINARY		pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN const PBYTE				pb,
	IN DWORD					cb
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
	pprop->Syntax.wType = (WORD) proptype;
	pprop->cbLength = cb;
	if (cb > 0)
		CopyMemory(pprop->rgb, pb, cb);

	// Set an endmark.
	props.pBinaryValue = pprop;
	props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cb);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AllocPropList
//
//	Routine Description:
//		Allocate a property list buffer that's big enough to hold the next
//		property.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by BYTE::operator new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AllocPropList(
	IN DWORD	cbMinimum
	)
{
	DWORD		cbTotal;

	ASSERT(cbMinimum > 0);

	// Add the size of the item count and final endmark.
	cbMinimum += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
	cbTotal = m_cbDataSize + cbMinimum;

	if (m_cbBufferSize < cbTotal)
	{
		PBYTE	pbNewProplist;

		cbMinimum = max(BUFFER_GROWTH_FACTOR, cbMinimum);
		cbTotal = m_cbDataSize + cbMinimum;

		// Allocate and zero a new buffer.
		pbNewProplist = new BYTE[cbTotal];
		ZeroMemory(pbNewProplist, cbTotal);

		// If there was a previous buffer, copy it and the delete it.
		if (m_proplist.pb != NULL)
		{
			if (m_cbDataSize != 0)
				CopyMemory(pbNewProplist, m_proplist.pb, m_cbDataSize);
			delete [] m_proplist.pb;
			m_propCurrent.pb = pbNewProplist + (m_propCurrent.pb - m_proplist.pb);
		}  // if:  there was a previous buffer
		else
			m_propCurrent.pb = pbNewProplist + sizeof(DWORD); // move past prop count

		// Save the new buffer.
		m_proplist.pb = pbNewProplist;
		m_cbBufferSize = cbTotal;
	}  // if:  buffer isn't big enough

}  //*** CClusPropList::AllocPropList(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNodeProperties
//
//	Routine Description:
//		Get properties on a node.
//
//	Arguments:
//		hNode			[IN] Handle for the node to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNodeProperties(
	IN HNODE		hNode,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hNode != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterNodeControl(
							hNode,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetGroupProperties
//
//	Routine Description:
//		Get properties on a group.
//
//	Arguments:
//		hGroup			[IN] Handle for the group to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetGroupProperties(
	IN HGROUP		hGroup,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hGroup != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterGroupControl(
							hGroup,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetResourceProperties
//
//	Routine Description:
//		Get properties on a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetResourceProperties(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hResource != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterResourceControl(
							hResource,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetResourceTypeProperties
//
//	Routine Description:
//		Get properties on a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetResourceTypeProperties(
	IN HCLUSTER		hCluster,
	IN LPCWSTR		pwszResTypeName,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hCluster != NULL);
	ASSERT(pwszResTypeName != NULL);
	ASSERT(*pwszResTypeName != L'\0');
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterResourceTypeControl(
							hCluster,
							pwszResTypeName,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNetworkProperties
//
//	Routine Description:
//		Get properties on a network.
//
//	Arguments:
//		hNetwork		[IN] Handle for the network to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNetworkProperties(
	IN HNETWORK		hNetwork,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hNetwork != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterNetworkControl(
							hNetwork,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNetInterfaceProperties
//
//	Routine Description:
//		Get properties on a network interface.
//
//	Arguments:
//		hNetInterface	[IN] Handle for the network interface to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNetInterfaceProperties(
	IN HNETINTERFACE	hNetInterface,
	IN DWORD			dwControlCode,
	IN HNODE			hHostNode,
	IN LPVOID			lpInBuffer,
	IN DWORD			cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hNetInterface != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterNetInterfaceControl(
							hNetInterface,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNetInterfaceProperties()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		ExtObj.h
//
//	Description:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoDummyEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CNodeData
/////////////////////////////////////////////////////////////////////////////

class CNodeData : public CObjData
{
public:
	HNODE		m_hnode;

};  //*** class CNodeData

/////////////////////////////////////////////////////////////////////////////
// class CGroupData
/////////////////////////////////////////////////////////////////////////////

class CGroupData : public CObjData
{
public:
	HGROUP		m_hgroup;

};  //*** class CGroupData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CNetworkData
/////////////////////////////////////////////////////////////////////////////

class CNetworkData : public CObjData
{
public:
	HNETWORK	m_hnetwork;

};  //*** class CNetworkData

/////////////////////////////////////////////////////////////////////////////
// class CNetInterfaceData
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceData : public CObjData
{
public:
	HNETINTERFACE	m_hnetinterface;

};  //*** class CNetInterfaceData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoDummyEx>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.DummyEx"), _T("CLUADMEX.DummyEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW(void) const		{ return m_podObjData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) m_podObjData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CObjData *			PodObjData(void) const			{ return m_podObjData; }
	const CNodeData *			PndNodeData(void) const			{ ASSERT(Cot() == CLUADMEX_OT_NODE); return (CNodeData *) m_podObjData; }
	const CGroupData *			PgdGroupData(void) const		{ ASSERT(Cot() == CLUADMEX_OT_GROUP); return (CGroupData *) m_podObjData; }
	const CResData *			PrdResData(void) const			{ ASSERT(Cot() == CLUADMEX_OT_RESOURCE); return (CResData *) m_podObjData; }
	const CNetworkData *		PndNetworkData(void) const		{ ASSERT(Cot() == CLUADMEX_OT_NETWORK); return (CNetworkData *) m_podObjData; }
	const CNetInterfaceData *	PndNetInterfaceData(void) const	{ ASSERT(Cot() == CLUADMEX_OT_NETINTERFACE); return (CNetInterfaceData *) m_podObjData; }

	CLUADMEX_OBJECT_TYPE		Cot(void) const					{ ASSERT(PodObjData() != NULL); return PodObjData()->m_cot; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		PropList.h
//
//	Abstract:
//		Definition of the CClusPropList class.
//
//	Implementation File:
//		PropList.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _PROPLIST_H_
#define _PROPLIST_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CObjectProperty
/////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

class CObjectProperty
{
public:
	LPCWSTR					m_pwszName;
	CLUSTER_PROPERTY_FORMAT	m_propFormat;

	union CValue
	{
		CString *	pstr;
		LONG *		pl;
		DWORD *		pdw;
		BOOL *		pb;
		struct
		{
			PBYTE *	ppb;
			DWORD *	pcb;
		};
	};
	CValue					m_value;
	CValue					m_valuePrev;

	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_value.pcb = NULL;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN LONG & rnValue,
				IN LONG & rnPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pl = &rnValue;
		m_value.pcb = NULL;
		m_valuePrev.pl = &rnPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN DWORD & rdwValue,
				IN DWORD & rdwPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pdw = &rdwValue;
		m_value.pcb = NULL;
		m_valuePrev.pdw = &rdwPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN BOOL & rbValue,
				IN BOOL & rbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pb = &rbValue;
		m_value.pcb = NULL;
		m_valuePrev.pb = &rbPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN PBYTE & rpbValue,
				IN DWORD & rcbValue,
				IN PBYTE & rpbPrevValue,
				IN DWORD & rcbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_BINARY;
		m_value.ppb = &rpbValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = &rpbPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN LPWSTR & rpwszValue,
				IN DWORD & rcbValue,
				IN LPWSTR & rpwszPrevValue,
				IN DWORD & rcbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
		m_value.ppb = (PBYTE *) &rpwszValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = (PBYTE *) &rpwszPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
	}

};  //*** class CObjectProperty

/////////////////////////////////////////////////////////////////////////////
// CClusPropList dialog
/////////////////////////////////////////////////////////////////////////////

class CClusPropList : public CObject
{
	DECLARE_DYNAMIC(CClusPropList);

// Construction
public:
	CClusPropList(IN BOOL bAlwaysAddProp = FALSE);
	~CClusPropList(void);

// Attributes
protected:
	BOOL					m_bAlwaysAddProp;

	CLUSPROP_BUFFER_HELPER	m_proplist;
	CLUSPROP_BUFFER_HELPER	m_propCurrent;
	DWORD					m_cbBufferSize;
	DWORD					m_cbDataSize;

public:
	CLUSPROP_BUFFER_HELPER const *	Proplist(void) const	{ return &m_proplist; }
	PBYTE					PbProplist(void) const	{ return m_proplist.pb; }
	DWORD					CbProplist(void) const	{ return m_cbDataSize + sizeof(CLUSPROP_SYNTAX); /*endmark*/ }
	DWORD					Cprops(void) const
	{
		if (m_proplist.pb == NULL)
			return 0;
		return m_proplist.pList->nPropertyCount;
	}

	void					AddProp(
								IN LPCWSTR			pwszName,
								IN const CString &	rstrValue,
								IN const CString &	rstrPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN DWORD			dwValue,
								IN DWORD			dwPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN LONG				nValue,
								IN LONG				nPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN const PBYTE		pbValue,
								IN DWORD			cbValue,
								IN const PBYTE		pbPrevValue,
								IN DWORD			cbPrevValue
								);

	void					AllocPropList(IN DWORD cbMinimum);

// Operations
public:
	DWORD					DwGetNodeProperties(
								IN HNODE		hNode,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetGroupProperties(
								IN HGROUP		hGroup,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetResourceProperties(
								IN HRESOURCE	hResource,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetResourceTypeProperties(
								IN HCLUSTER		hCluster,
								IN LPCWSTR		pwszResTypeName,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetNetworkProperties(
								IN HNETWORK		hNetwork,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetNetInterfaceProperties(
								IN HNETINTERFACE	hNetInterface,
								IN DWORD			dwControlCode,
								IN HNODE			hHostNode		= NULL,
								IN LPVOID			lpInBuffer		= NULL,
								IN DWORD			cbInBufferSize	= 0
								);

// Overrides

// Implementation
protected:
	void					CopyProp(
								IN PCLUSPROP_SZ				pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN LPCWSTR					pwsz,
								IN DWORD					cbsz = 0
								);
	void					CopyProp(
								IN PCLUSPROP_DWORD			pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN DWORD					dw
								);
	void					CopyProp(
								IN PCLUSPROP_BINARY			pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN const PBYTE				pb,
								IN DWORD					cb
								);

	DWORD					DwGetPrivateProps(
								OUT PBYTE *					ppbProps,
								IN CLUSTER_CONTROL_OBJECT	ccobjtype = CLUS_OBJECT_RESOURCE
								);
	DWORD					DwSetPrivateProps(
								IN PBYTE					pbProps,
								IN DWORD					cbProps,
								IN CLUSTER_CONTROL_OBJECT	ccobjtype = CLUS_OBJECT_RESOURCE
								);

};  //*** class CClusPropList

#pragma warning( default : 4201 )

/////////////////////////////////////////////////////////////////////////////

#endif // _PROPLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DummyEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Dummy.rc
//
#define IDD_PP_DUMMY_PARAMETERS      130
#define IDD_WIZ_DUMMY_PARAMETERS     131
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_DUMMY_PENDING_LABEL 1010
#define IDC_PP_DUMMY_PENDING       1011
#define IDC_PP_DUMMY_PENDTIME_LABEL 1012
#define IDC_PP_DUMMY_PENDTIME       1013
#define IDC_PP_DUMMY_OPENSFAIL_LABEL 1014
#define IDC_PP_DUMMY_OPENSFAIL       1015
#define IDC_PP_DUMMY_FAILED_LABEL 1016
#define IDC_PP_DUMMY_FAILED       1017
#define IDC_PP_DUMMY_ASYNCHRONOUS_LABEL 1018
#define IDC_PP_DUMMY_ASYNCHRONOUS       1019
#define IDS_CLUADMEX_COMOBJ_DESC        31100
#define IDS_REQUIRED_FIELD_EMPTY        31101
#define IDS_APPLY_PARAM_CHANGES_ERROR   31200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1110
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		RegExt.h
//
//	Abstract:
//		Definitions of routines for extension registration.
//
//	Implementation File:
//		RegExt.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGEXT_H_
#define _REGEXT_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _REGEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\resprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		ResProp.cpp
//
//	Abstract:
//		Implementation of the resource extension property page classes.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DummyEx.h"
#include "ResProp.h"
#include "ExtObj.h"
#include "DDxDDv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDummyParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CDummyParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CDummyParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CDummyParamsPage)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
	ON_EN_CHANGE(IDC_PP_DUMMY_PENDING, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_DUMMY_PENDTIME, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_DUMMY_OPENSFAIL, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_DUMMY_FAILED, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_DUMMY_ASYNCHRONOUS, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::CDummyParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDummyParamsPage::CDummyParamsPage(void) : CBasePropertyPage(CDummyParamsPage::IDD)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CDummyParamsPage)
	m_bPending = 0;
	m_nPendTime = (DWORD) (0);
	m_bOpensFail = 0;
	m_bFailed = 0;
	m_bAsynchronous = 0;
	//}}AFX_DATA_INIT

	// Setup the property array.
	{
		m_rgProps[epropPending].Set(REGPARAM_DUMMY_PENDING, m_bPending, m_bPrevPending);
		m_rgProps[epropPendTime].Set(REGPARAM_DUMMY_PENDTIME, m_nPendTime, m_nPrevPendTime);
		m_rgProps[epropOpensFail].Set(REGPARAM_DUMMY_OPENSFAIL, m_bOpensFail, m_bPrevOpensFail);
		m_rgProps[epropFailed].Set(REGPARAM_DUMMY_FAILED, m_bFailed, m_bPrevFailed);
		m_rgProps[epropAsynchronous].Set(REGPARAM_DUMMY_ASYNCHRONOUS, m_bAsynchronous, m_bPrevAsynchronous);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_DUMMY_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_DUMMY_PARAMETERS;

}  //*** CDummyParamsPage::CDummyParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDummyParamsPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CDummyParamsPage)
	DDX_Text(pDX, IDC_PP_DUMMY_PENDING, m_bPending);
	DDX_Text(pDX, IDC_PP_DUMMY_PENDTIME, m_nPendTime);
	DDX_Text(pDX, IDC_PP_DUMMY_OPENSFAIL, m_bOpensFail);
	DDX_Text(pDX, IDC_PP_DUMMY_FAILED, m_bFailed);
	DDX_Text(pDX, IDC_PP_DUMMY_ASYNCHRONOUS, m_bAsynchronous);
	//}}AFX_DATA_MAP

	// Handle numeric parameters.
	if (!BBackPressed())
	{
		DDX_Number(pDX, IDC_PP_DUMMY_PENDTIME, m_nPendTime, (DWORD) (0), (DWORD) (4294967295), FALSE /*bSigned*/);
	}  // if:  back button not pressed

	// TODO: Add any additional field validation here.
	if (pDX->m_bSaveAndValidate)
	{
		// Make sure all required fields are present.
		if (!BBackPressed())
		{
		}  // if:  back button not pressed
	}  // if:  saving data from dialog

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CDummyParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDummyParamsPage::OnInitDialog(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CBasePropertyPage::OnInitDialog();

	// TODO:
	// Limit the size of the text that can be entered in edit controls.

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CDummyParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDummyParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Enable/disable the Next/Finish button.
	if (BWizard())
		EnableNext(BAllRequiredFieldsPresent());

	return CBasePropertyPage::OnSetActive();

}  //*** CDummyParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::OnChangeRequiredField
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDummyParamsPage::OnChangeRequiredField(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
		EnableNext(BAllRequiredFieldsPresent());

}  //*** CDummyParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::BAllRequiredFieldsPresent
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDummyParamsPage::BAllRequiredFieldsPresent(void) const
{
	return TRUE;

}  //*** CDummyParamsPage::BAllRequiredFieldsPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\resprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		ResProp.h
//
//	Abstract:
//		Definition of the resource extension property page classes.
//
//	Implementation File:
//		ResProp.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESPROP_H_
#define _RESPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDummyParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CDummyParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CDummyParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CDummyParamsPage)

// Construction
public:
	CDummyParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CDummyParamsPage)
	enum { IDD = IDD_PP_DUMMY_PARAMETERS };
	BOOL	m_bPending;
	DWORD	m_nPendTime;
	BOOL	m_bOpensFail;
	BOOL	m_bFailed;
	BOOL	m_bAsynchronous;
	//}}AFX_DATA
	BOOL	m_bPrevPending;
	DWORD	m_nPrevPendTime;
	BOOL	m_bPrevOpensFail;
	BOOL	m_bPrevFailed;
	BOOL	m_bPrevAsynchronous;

protected:
	enum
	{
		epropPending,
		epropPendTime,
		epropOpensFail,
		epropFailed,
		epropAsynchronous,
		epropMAX
	};
	CObjectProperty		m_rgProps[epropMAX];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDummyParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:
	BOOL	BAllRequiredFieldsPresent(void) const;

	// Generated message map functions
	//{{AFX_MSG(CDummyParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CDummyParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _RESPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		RegExt.cpp
//
//	Abstract:
//		Implementation of routines for extension registration.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminClusterExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** RegisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** RegisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNetworksExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all networks.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Networks", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNetInterfacesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all network interfaces.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"NetInterfaces", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** RegisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminClusterExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** UnregisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNetworksExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all networks.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Networks", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNetInterfacesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all network interfaces.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"NetInterfaces", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** UnregisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Register the extension.
			hr = RegisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyRegistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been registered yet.
			if (pwszValue == NULL)
				bAlreadyRegistered = FALSE;
			else
			{
				LPCWSTR	pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpiW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyRegistered = (*pwszValueBuf != L'\0');
			}  // else:  extension value exists

			// Register the extension.
			if (!bAlreadyRegistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize + (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				if (cbSize == 0) // Add size of final NULL if first entry.
					cbNewSize += sizeof(WCHAR);
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	cch;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if (pwszValue != NULL)
					{
						while (*pwszValueBuf != L'\0')
						{
							lstrcpyW(pwszNewValueBuf, pwszValueBuf);
							cch = lstrlenW(pwszValueBuf);
							pwszValueBuf += cch + 1;
							pwszNewValueBuf += cch + 1;
						}  // while:  more strings in the extension list
					}  // if:  previous value buffer existed

					// Add the new CLSID to the list.
					lstrcpyW(pwszNewValueBuf, pwszClsid);
					pwszNewValueBuf += lstrlenW(pwszClsid) + 1;
					*pwszNewValueBuf = L'\0';

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not registered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Unregister the extension.
			hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyUnregistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been unregistered yet.
			if (pwszValue == NULL)
				bAlreadyUnregistered = TRUE;
			else
			{
				LPCWSTR pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpiW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyUnregistered = (*pwszValueBuf == L'\0');
			}  // else:  extension value exists

			// Unregister the extension.
			if (!bAlreadyUnregistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize - (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				if (cbNewSize == sizeof(WCHAR))
					cbNewSize = 0;
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if ((cbNewSize > 0) && (pwszValue != NULL))
					{
						while (*pwszValueBuf != L'\0')
						{
							if (lstrcmpiW(pwszClsid, pwszValueBuf) != 0)
							{
								lstrcpyW(pwszNewValueBuf, pwszValueBuf);
								pwszNewValueBuf += lstrlenW(pwszNewValueBuf) + 1;
							}  // if:  not CLSID being removed
							pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
						}  // while:  more strings in the extension list
						*pwszNewValueBuf = L'\0';
					}  // if:  previous value buffer existed

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not unregistered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReadValue
//
//	Routine Description:
//		Reads a value from the cluster database.
//
//	Arguments:
//		hkey			[IN] Handle for the key to read from.
//		pwszValueName	[IN] Name of value to read.
//		ppwszValue		[OUT] Address of pointer in which to return data.
//							The string is allocated using LocalAlloc and must
//							be deallocated by the calling LocalFree.
//		pcbSize			[OUT] Size in bytes of the allocated value buffer.
//
//	Return Value:
//		Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	)
{
	DWORD		dwStatus;
	DWORD		cbSize;
	DWORD		dwType;
	LPWSTR		pwszValue;

	*ppwszValue = NULL;
	*pcbSize = 0;

	// Get the length of the value.
	dwStatus = ClusterRegQueryValue(
					hkey,
					pwszValueName,
					&dwType,
					NULL,
					&cbSize
					);
	if (   (dwStatus != ERROR_SUCCESS)
		&& (dwStatus != ERROR_MORE_DATA))
	{
		if (dwStatus  == ERROR_FILE_NOT_FOUND)
			dwStatus = ERROR_SUCCESS;
		return dwStatus;
	}  // if:  error occurred

	if (cbSize > 0)
	{
		// Allocate a value string.
		pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbSize);
		if (pwszValue == NULL)
		{
			dwStatus = GetLastError();
			return dwStatus;
		}  // if:  error allocating memory

		// Read the the value.
		dwStatus = ClusterRegQueryValue(
						hkey,
						pwszValueName,
						&dwType,
						(LPBYTE) pwszValue,
						&cbSize
						);
		if (dwStatus != ERROR_SUCCESS)
		{
			LocalFree(pwszValue);
			pwszValue = NULL;
			cbSize = 0;
		}  // if:  error occurred

		*ppwszValue = pwszValue;
		*pcbSize = cbSize;
	}  // if:  value is not empty

	return dwStatus;

}  //*** ReadValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\dummyex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE			// Microsoft Windows NT Cluster Administrator
							//   Extension DLLs need to be Unicode
							//   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

// Link against Resource Utilities library.
#pragma comment(lib, "resutils.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h>			// MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <clusapi.h>

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT	IDS;
typedef UINT	IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\exchange\xchgdat.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    localsvc.h

Abstract:

    Header file for definitions and structure for the NT Cluster
    Special generic services.

Author:

    John Vert (jvert) 23-May-1997

Revision History:

--*/

#ifndef _XCHGDAT_H_
#define _XCHGDAT_H_


#ifdef __cplusplus
extern "C" {
#endif

SERVICE_INFOLIST    ServiceInfoList=
                    {
                      2,
                      {
                        {
                            L"MsExchangeMTA",   //name
                            2,                  //dependency count
                            {L"MSExchangeDS", L"MSExchangeSA", L""} //dependencylist
                        },
                        {
                            L"MsExchangeIS",   //name
                            2,  //dependency count
                            {L"MSExchangeDS",L"MSExchangeSA", L""}
                        },
                        {   
                            L"",   //name
                            0,  //dependency count
                            {L"",L"",L""}
                        },
                        {   
                            L"",   //name
                            0,  //dependency count
                            {L"",L"",L""}
                        },
                        {   
                            L"",   //name
                            0,  //dependency count
                            {L"",L"",L""}
                        }
                      }
                    };

static HANDLE  CommonMutex = NULL;
static DWORD   RegSyncCount = SYNC_VALUE_COUNT;
static LPWSTR  RegSync[SYNC_VALUE_COUNT] = {
    L"System\\CurrentControlSet\\Services\\MSExchangeSA",
    L"System\\CurrentControlSet\\Services\\MSExchangeDS",
    L"System\\CurrentControlSet\\Services\\MSExchangeIS",
    L"System\\CurrentControlSet\\Services\\MSExchangeMTA",
    };


#ifdef _cplusplus
}
#endif


#endif // ifndef _XCHGDAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\exchange\xchgclus.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xchgclus.h

Abstract:

    Header file for definitions and structure for a resource dll
    for a backoffice server comprised of serveral services.
    This is specifically for exchange.  
    
Author:

    Sunita Shrivastava (sunitas) 23-June-1997

Revision History:

--*/

#ifndef _XCHGCLUS_H_
#define _XCHGCLUS_H_


#ifdef __cplusplus
extern "C" {
#endif

#define RESOURCE_NAME       L"Exchange"

#define SYNC_VALUE_COUNT    4
#define REG_SYNC_VALUE 

#define ENVIRONMENT         1   // GetComputerName must return cluster name
#define COMMON_MUTEX        L"Cluster$ExchangeMutex" // Limit of one resource of this type
#define LOG_CURRENT_MODULE  LOG_MODULE_EXCHANGE

//define the resource type

#define EXCHANGE_RESOURCE_NAME  L"Exchange"

#ifdef _cplusplus
}
#endif


#endif // ifndef _XCHGCLUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\exchange\boclus.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    exchange.c

Abstract:

    Resource DLL to control and monitor the exchange service.

Author:


    Robs 3/28/96, based on RodGa's generic resource dll

Revision History:

--*/


//***********************************************************
//
// Define Exchange Function Table
//
//***********************************************************
#define UNICODE 1

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
//#include "stdio.h"
//#include "stdlib.h"
#include "clusapi.h"
#include "clusudef.h"
#include "resapi.h"
#include "bosvc.h"
#include "xchgclus.h"
//#include "svc.c"

PLOG_EVENT_ROUTINE              g_LogEvent = NULL;
PSET_RESOURCE_STATUS_ROUTINE    g_SetResourceStatus = NULL;
extern CLRES_FUNCTION_TABLE ExchangeFunctionTable;


DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup a particular resource type. This means verifying the version
    requested, and returning the function table for this resource type.

Arguments:

    ResourceType - Supplies the type of resource.

    MinVersionSupported - The minimum version number supported by the cluster
                    service on this system.

    MaxVersionSupported - The maximum version number supported by the cluster
                    service on this system.

    FunctionTable - Returns the Function Table for this resource type.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{

    //
    // Search for a valid service name supported by this DLL
    //
    if ( lstrcmpiW( ResourceType, EXCHANGE_RESOURCE_NAME ) != 0 ) {
        return(ERROR_UNKNOWN_REVISION);
    }

    g_LogEvent = LogEvent;
    g_SetResourceStatus  = SetResourceStatus;

    if ( (MinVersionSupported <= CLRES_VERSION_V1_00) &&
         (MaxVersionSupported >= CLRES_VERSION_V1_00) ) {

        *FunctionTable = &ExchangeFunctionTable;
        return(ERROR_SUCCESS);
    }

    return(ERROR_REVISION_MISMATCH);

} // Startup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\exchange\bosvc.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    gensvc.c

Abstract:

    Resource DLL to control and monitor NT services.

Author:


    Robs 3/28/96, based on RodGa's generic resource dll

Revision History:

--*/

#define UNICODE 1
//
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "clusapi.h"
#include "clusudef.h"
#include "resapi.h"
#include "bosvc.h"
#include "xchgclus.h"
#include "xchgdat.h"

extern  PLOG_EVENT_ROUTINE              g_LogEvent;
extern  PSET_RESOURCE_STATUS_ROUTINE    g_SetResourceStatus;

#define DBG_PRINT printf


//
// Global Data
//

// Handle to service controller,  set by the first create resource call.

static SC_HANDLE g_ScHandle = NULL;

//
// Forward routines
//

DWORD
XchgOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    );

BOOL
XchgVerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag
    );

HANDLE
XchgOpenSvc(
    IN SERVICE_NAME ServiceName,
    IN PCOMMON_RESOURCE ResourceEntry
    );

DWORD
XchgSetSvcEnv(
    IN HKEY             ServicesKey,
    IN SERVICE_NAME     ServiceName,
    IN LPVOID           Environment,
    IN DWORD            ValueSize,
    IN PCOMMON_RESOURCE ResourceEntry
    );


#ifdef COMMON_ONLINE_THREAD
#define COMMON_ONLINE_THREAD_ROUTINE COMMON_ONLINE_THREAD
#else
#define COMMON_ONLINE_THREAD_ROUTINE XchgOnlineThread
#endif

//
// Local Routines
//


#ifndef COMMON_ONLINE_THREAD
DWORD
XchgOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the DiskInfo block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    SERVICE_STATUS  ServiceStatus;
    DWORD           status = ERROR_SUCCESS;
    DWORD           numchars;
    RESOURCE_STATUS resourceStatus;
    HANDLE          serviceHandle;
    DWORD           valueSize;
    WCHAR *         p;
    LPVOID          Environment = NULL;
    HKEY            ServicesKey;
    DWORD           dwSvcCnt;
    DWORD           dwDependencyCnt;
    PSERVICE_INFO   pSvcInfo;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

#if ENVIRONMENT
    //
    // Create the new environment with the simulated net name when the
    // services queries GetComputerName.
    //
    Environment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    if (!Environment)
    {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"XchgOnlineThread:Failed to get environment with netname, error = %1!u!.\n",
            status );
        goto error_exit;
    }
    
    //
    // Compute the size of the environment. We are looking for
    // the double NULL terminator that ends the environment block.
    //
    p = (WCHAR *)Environment;
    while (*p) {
        while (*p++) {
        }
    }
    
    valueSize = (DWORD)((PUCHAR)p - (PUCHAR)Environment) + sizeof(WCHAR);
    //
    // Set the environment value in the service's registry key.
    //

    status = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                            LOCAL_SERVICES,
                            0,
                            KEY_READ,
                            &ServicesKey );
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"XchgOnlineThread:Failed to open services key, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    for (dwSvcCnt=0; dwSvcCnt< ServiceInfoList.dwMaxSvcCnt; dwSvcCnt++)
    {
        pSvcInfo = &ServiceInfoList.SvcInfo[dwSvcCnt];

        status = XchgSetSvcEnv(ServicesKey, pSvcInfo->snSvcName,
                        Environment, valueSize, ResourceEntry);
        
        if (status != ERROR_SUCCESS)
            goto error_exit;

        for (dwDependencyCnt=0; dwDependencyCnt < pSvcInfo->dwDependencyCnt; dwDependencyCnt++)
        {
            status = XchgSetSvcEnv(ServicesKey, pSvcInfo->snProvidorSvc[dwDependencyCnt],
                        Environment, valueSize, ResourceEntry);

            if (status != ERROR_SUCCESS)
                goto error_exit;
                            
        }            
    }
    RegCloseKey(ServicesKey);

#endif //ENVIRONMENT

    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    for (dwSvcCnt=0;dwSvcCnt< ServiceInfoList.dwMaxSvcCnt; dwSvcCnt++)
    {

        pSvcInfo = &ServiceInfoList.SvcInfo[dwSvcCnt];

        //
        // Now open the requested service and the handle to its providor services
        //
        serviceHandle = 
            XchgOpenSvc(pSvcInfo->snSvcName, ResourceEntry);

        if (serviceHandle == NULL)
        {
            status = GetLastError();
            goto error_exit;
        }
        ResourceEntry->ServiceHandle[dwSvcCnt][0] = serviceHandle;

        //get the handles for the child services
        for (dwDependencyCnt=0; dwDependencyCnt < pSvcInfo->dwDependencyCnt; dwDependencyCnt++)
        {
            serviceHandle = 
                XchgOpenSvc(pSvcInfo->snSvcName, ResourceEntry);

            if (serviceHandle == NULL)
            {
                status = GetLastError();
                goto error_exit;
            }
            ResourceEntry->ServiceHandle[dwSvcCnt][dwDependencyCnt+1] = serviceHandle;

        }

        //start the top level services
        // the providor services will be started by scm
        if ( !StartServiceW( ResourceEntry->ServiceHandle[dwSvcCnt][0],
                             0,
                             NULL ) ) 
        {

            status = GetLastError();

            if (status != ERROR_SERVICE_ALREADY_RUNNING) {
/*
                ClusResLogEventByKeyData(ResourceEntry->ResourceKey,
                                         LOG_CRITICAL,
                                         RES_GENSVC_START_FAILED,
                                         sizeof(status),
                                         &status);
*/                                         
                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_ERROR,
                             L"Failed to start %1!ws! service. Error: %2!u!.\n",
                             ServiceInfoList.SvcInfo[dwSvcCnt].snSvcName,
                             status );
                status = ERROR_SERVICE_NEVER_STARTED;
                goto error_exit;
            }
        }

    }
    
    for (dwSvcCnt=0;dwSvcCnt< ServiceInfoList.dwMaxSvcCnt; dwSvcCnt++)
    {
        while (TRUE)  
        {
            if ( !QueryServiceStatus( ResourceEntry->ServiceHandle[dwSvcCnt][0],
                                      &ServiceStatus ) ) {

                status = GetLastError();

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"XchgOnlineThread:Query Service Status failed %1!u!.\n",
                    status );

                goto error_exit;
            }

            if ( ServiceStatus.dwCurrentState != SERVICE_START_PENDING ) {
                break;
            }

            Sleep(250);
        }            
        if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING ) {
/*
            ClusResLogEventByKeyData(ResourceEntry->ResourceKey,
                                     LOG_CRITICAL,
                                     RES_GENSVC_FAILED_AFTER_START,
                                     sizeof(status),
                                     &status);
*/                                     
            (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Failed to start service %1!ws!, Error: %2!u!.\n",
                    ServiceInfoList.SvcInfo[dwSvcCnt].snSvcName,
                    ERROR_SERVICE_NEVER_STARTED );

            status = ERROR_SERVICE_NEVER_STARTED;
            goto error_exit;
        }

    }


    resourceStatus.ResourceState = ClusterResourceOnline;

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Service is now on line.\n" );

error_exit:

#if ENVIRONMENT

    if ( Environment != NULL ) {
        RtlDestroyEnvironment( Environment );
    }

#endif

    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }

    return(status);

} // CommonOnlineThread
#endif



RESID
WINAPI
XchgOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic service resource.
    This routine gets a handle to the service controller, if we don't already have one,
    and then gets a handle to the specified service.  The service handle is saved
    in the COMMON structure.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    RESID   svcResid = 0;
    DWORD   status;
    HKEY    parametersKey = NULL;
    HKEY    resKey = NULL;
    PCOMMON_RESOURCE resourceEntry = NULL;
    LPWSTR  resourceName = NULL;
    DWORD   paramNameSize = 0;
    DWORD   paramNameMaxSize = 0;
    HCLUSTER hCluster;
    DWORD   returnSize;
    DWORD   i;
    HANDLE  hMutex;
    DWORD   dwDependencyCnt, dwSvcCnt;
    PSERVICE_INFO    pSvcInfo;

    //
    // Save the resource name.
    //
    resourceName = LocalAlloc( LMEM_FIXED,
                               (wcslen(ResourceName) + 1) * sizeof(WCHAR) );
    if ( resourceName == NULL ) {
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate name string.\n" );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    wcscpy( resourceName, ResourceName );

    //
    // Open registry parameters key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                L"Parameters",
                                KEY_READ,
                                &parametersKey );

    if ( status != NO_ERROR ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key. Error: %1!u!.\n",
            status);
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // First get a handle to the service controller.
    //

    if ( g_ScHandle == NULL ) {

        g_ScHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS);

        if ( g_ScHandle == NULL ) {
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to open service control manager, error = %1!u!.\n",
                GetLastError());
            goto error_exit;
        }
    }

    resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(COMMON_RESOURCE) );

    if ( resourceEntry == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a service info structure.\n");
        goto error_exit;
    }

    ZeroMemory( resourceEntry, sizeof(COMMON_RESOURCE) );

    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->ResourceName = resourceName;

    //initialize the service handles to NULL
    for (dwSvcCnt=0; dwSvcCnt< ServiceInfoList.dwMaxSvcCnt; dwSvcCnt++)
    {
        pSvcInfo = &ServiceInfoList.SvcInfo[dwSvcCnt];

        for (dwDependencyCnt=0; dwDependencyCnt <= pSvcInfo->dwDependencyCnt; dwDependencyCnt++)
        {
            resourceEntry->ServiceHandle[dwSvcCnt][dwDependencyCnt] = NULL;   
        }
    }        


    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open cluster" );
        goto error_exit;
    }
    resourceEntry->hResource = OpenClusterResource(hCluster, ResourceName);
    CloseCluster(hCluster);
    if ( resourceEntry->hResource == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource" );
        goto error_exit;
    }

    //
    // Set any registry checkpoints that we need.
    //
    if ( RegSyncCount != 0 ) {
        returnSize = 0;
        status = ClusterResourceControl( resourceEntry->hResource,
                                         NULL,
                                         CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         &returnSize );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to get registry checkpoints, status %1!u!.\n",
                status );
            goto error_exit;
        }

        //
        // Set registry sync keys if we need them.
        //
        if ( returnSize == 0 ) {
            for ( i = 0; i < RegSyncCount; i++ ) {
                status = ClusterResourceControl( resourceEntry->hResource,
                                                 NULL,
                                                 CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                                                 RegSync[i],
                                                 (lstrlenW(RegSync[i]) + 1) * sizeof(WCHAR),
                                                 NULL,
                                                 0,
                                                 &returnSize );
                if ( status != ERROR_SUCCESS ) {
                    (g_LogEvent)(
                        ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set registry checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

#ifdef COMMON_PARAMS_DEFINED
    //
    // Get any parameters... so we can handle the GET_DEPENDENCIES request.
    //
    CommonReadParameters( resourceEntry );
    // ignore status return
#endif // COMMON_PARAMS_DEFINED

#ifdef COMMON_MUTEX
    //
    // Check if more than one resource of this type.
    // N.B. Must have a lock for this case!
    //
    hMutex = CreateMutexW( NULL,
                           FALSE,
                           COMMON_MUTEX );
    if ( hMutex == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to create global mutex, status %1!us!.\n",
            status );
        goto error_exit;
    }
    if ( WaitForSingleObject( hMutex, 0 ) == WAIT_TIMEOUT ) {
        //
        // A version of this service is already running
        //
        CloseHandle( hMutex );
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Service is already running.\n" );
        status = ERROR_SERVICE_ALREADY_RUNNING;
        goto error_exit;
    }

    ASSERT( CommonMutex == NULL );
    CommonMutex = hMutex;

#endif // COMMON_MUTEX

    svcResid = (RESID)resourceEntry;
    return(svcResid);

error_exit:

    LocalFree( resourceName );
    LocalFree( resourceEntry );

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }
    if ( resKey != NULL) {
        ClusterRegCloseKey( resKey );
    }

    return(FALSE);

} // XchgOpen


DWORD
WINAPI
XchgOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Common Service resource.

Arguments:

    ResourceId - Supplies resource id to be brought online

    EventHandle - Supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    DWORD   status;
    PCOMMON_RESOURCE resourceEntry;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Online request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    ClusWorkerTerminate( &resourceEntry->OnlineThread );
    status = ClusWorkerCreate( &resourceEntry->OnlineThread,
                               COMMON_ONLINE_THREAD_ROUTINE,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // XchgOnline


VOID
WINAPI
XchgTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Common Service resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    SERVICE_STATUS      ServiceStatus;
    PCOMMON_RESOURCE    resourceEntry;
    DWORD               dwSvcCnt;
    PSERVICE_INFO       pSvcInfo;
    DWORD               dwDependencyCnt;
    
    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Offline request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Offline request.\n" );

    ClusWorkerTerminate( &resourceEntry->OnlineThread );
    for (dwSvcCnt=0;dwSvcCnt< ServiceInfoList.dwMaxSvcCnt; dwSvcCnt++)
    {
        pSvcInfo = &ServiceInfoList.SvcInfo[dwSvcCnt];
        //stop the service, lowest order service first
        for (dwDependencyCnt= 0; dwDependencyCnt<= pSvcInfo->dwDependencyCnt; dwDependencyCnt++)
        {
            if ( resourceEntry->ServiceHandle[dwSvcCnt][pSvcInfo->dwDependencyCnt-dwDependencyCnt] 
                    != NULL ) 
            {

                DWORD retryTime = 30*1000;  // wait 30 secs for shutdown
                DWORD retryTick = 300;      // 300 msec at a time
                DWORD status;
                BOOL  didStop = FALSE;

                //stop the child service
                for (;;) 
                {

                    status = (ControlService(
                                resourceEntry->ServiceHandle[dwSvcCnt][pSvcInfo->dwDependencyCnt - dwDependencyCnt],
                                (didStop
                                 ? SERVICE_CONTROL_INTERROGATE
                                 : SERVICE_CONTROL_STOP),
                                &ServiceStatus )
                    ? NO_ERROR
                    : GetLastError());

                    if (status == NO_ERROR) {

                        didStop = TRUE;

                        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                            (g_LogEvent)(
                                resourceEntry->ResourceHandle,
                                LOG_INFORMATION,
                                L"Service stopped.\n" );

                            break;
                        }
                    }

                    if (status == ERROR_EXCEPTION_IN_SERVICE ||
                        status == ERROR_PROCESS_ABORTED ||
                        status == ERROR_SERVICE_NOT_ACTIVE) {

                        (g_LogEvent)(
                            resourceEntry->ResourceHandle,
                            LOG_INFORMATION,
                            L"Service died; status = %1!u!.\n",
                            status);

                        break;

                    }

                    if ((retryTime -= retryTick) <= 0) {

                        (g_LogEvent)(
                            resourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"Service did not stop; giving up.\n" );

                        break;
                    }

                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"Offline: retrying...\n" );

                    Sleep(retryTick);
                }

                CloseServiceHandle( resourceEntry->ServiceHandle[dwSvcCnt][pSvcInfo->dwDependencyCnt - dwDependencyCnt] );
                resourceEntry->ServiceHandle[dwSvcCnt][pSvcInfo->dwDependencyCnt - dwDependencyCnt] = NULL;
            }

        }
        
    }
    resourceEntry->Online = FALSE;

} // XchgTerminate



static
DWORD
WINAPI
XchgOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Common Service resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    XchgTerminate( ResourceId );

    return(ERROR_SUCCESS);

} // XchgOffline


BOOL
WINAPI
XchgIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Common service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - if service is running

    FALSE - if service is in any other state

--*/
{

    return( XchgVerifyService( ResourceId, TRUE ) );

} // CommonIsAlive



BOOL
XchgVerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag)

/*++

Routine Description:

        Verify that a specified service is running

Arguments:

        ResourceId - Supplies the resource id
        IsAliveFlag - Says this is an IsAlive call - used only for debug print

Return Value:

        TRUE - if service is running or starting

        FALSE - service is in any other state

--*/
{
    SERVICE_STATUS ServiceStatus;
    PCOMMON_RESOURCE resourceEntry;
    DWORD   status = ERROR_SUCCESS;
    BOOL    bRet = TRUE;
    DWORD   dwSvcCnt;
    
    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: IsAlive request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        bRet = FALSE;
        goto error_exit;
    }

    for (dwSvcCnt=0; dwSvcCnt< ServiceInfoList.dwMaxSvcCnt; dwSvcCnt++)
    {
        if ( !QueryServiceStatus( resourceEntry->ServiceHandle[dwSvcCnt][0],
                                  &ServiceStatus ) ) 
        {

            status = GetLastError();

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"XchgOnlineThread:Query Service Status failed %1!u!.\n",
                status );
            bRet = FALSE;
            goto error_exit;
        }
        if ((ServiceStatus.dwCurrentState != SERVICE_RUNNING)&&(ServiceStatus.dwCurrentState != SERVICE_START_PENDING))
        {
           (g_LogEvent)(
              resourceEntry->ResourceHandle,
              LOG_ERROR,
              L"Failed the IsAlive test. Current State is %1!u!.\n",
              ServiceStatus.dwCurrentState );
            bRet = FALSE;
            goto error_exit;
        }
        
   }

error_exit:
    return(bRet);

} // Verify Service


BOOL
WINAPI
XchgLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Common Service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return( XchgVerifyService( ResourceId, FALSE ) );

} // CommonLooksAlive



VOID
WINAPI
XchgClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Common Services resource.
    This routine will stop the service, and delete the cluster
    information regarding that service.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PCOMMON_RESOURCE resourceEntry;
    DWORD   errorCode;
    HANDLE  hMutex;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );

    //
    // Shut it down if it's on line
    //

    XchgTerminate( ResourceId );
    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );

#ifdef COMMON_MUTEX
    hMutex = CommonMutex;
    CommonMutex = NULL;
    ReleaseMutex( hMutex );
    CloseHandle( hMutex );
#endif

    LocalFree( resourceEntry->ResourceName );
    LocalFree( resourceEntry );

} // XchgClose

HANDLE
XchgOpenSvc(
    IN SERVICE_NAME ServiceName,
    IN PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    opens the service and sets it to manual mode.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    HANDLE  serviceHandle=NULL;
    DWORD   status=ERROR_SUCCESS;
    
    serviceHandle = OpenService( g_ScHandle, ServiceName, SERVICE_ALL_ACCESS );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
/*
        ClusResLogEventByKeyData(ResourceEntry->ResourceKey,
                                 LOG_CRITICAL,
                                 RES_GENSVC_OPEN_FAILED,
                                 sizeof(status),
                                 &status);
*/                                 
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    //
    // Make sure service is set to manual start.
    //
    ChangeServiceConfig( serviceHandle,
                         SERVICE_NO_CHANGE,
                         SERVICE_DEMAND_START, // Manual start
                         SERVICE_NO_CHANGE,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL );

error_exit:
    if (status != ERROR_SUCCESS)
        SetLastError(status);
    return(serviceHandle);
}// XchgOpenSvc

DWORD
XchgSetSvcEnv(
    IN HKEY             ServicesKey,
    IN SERVICE_NAME     ServiceName,
    IN LPVOID           Environment,
    IN DWORD            ValueSize,
    IN PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    opens the service and sets it to manual mode.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    HKEY    hKey;

    status = RegOpenKeyExW( ServicesKey,
                            ServiceName,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hKey );
    if (status != ERROR_SUCCESS) 
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"XchgSet: Failed to open service key for %1!ws!, error = %2!u!.\n",
            ServiceName, status );
        goto error_exit;
    }
    status = RegSetValueExW( hKey,
                             L"Environment",
                             0,
                             REG_MULTI_SZ,
                             Environment,
                             ValueSize );

    RegCloseKey(hKey);
    if (status != ERROR_SUCCESS) 
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"XchgSet:Failed to set service environment value, error = %1!u!.\n",
            status );
            goto error_exit;
    }

error_exit:
    return(status);
}
// CommonSetSvcEnv

/*
VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    )
*/    
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
/*
{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    DWORD dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof(ResourceName);
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)ResourceName,
                                   &BufSize );
    if (Status != ERROR_SUCCESS) {
        ResourceName[0] = '\0';
    } else {
        ResourceName[79] = '\0';
    }

    ClusterLogEvent1(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     ResourceName);

    return;
}
*/

CLRES_V1_FUNCTION_TABLE( ExchangeFunctionTable,    // Name
                         CLRES_VERSION_V1_00,  // Version
                         Xchg,                  // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         NULL,                 // ResControl
                         NULL );               // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\exchange\bosvc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bosvc.h

Abstract:

    Header file for definitions and structure for a generic backoffice
    server cluster resource dll.

Author:

    Sunita Shrivastava (sunitas) 23-June-1997

Revision History:

--*/

#ifndef _BOSVC_H
#define _BOSVC_H


#ifdef __cplusplus
extern "C" {
#endif

//defines
#define LOCAL_SERVICES  L"System\\CurrentControlSet\\Services"    

#define MAX_INDEPENDENT_SERVICES    5
#define MAX_PROVIDOR_SERVICES       3


/*
#define ClusResLogEventByKeyData(_hKey_, _level_, _msgid_, dwBytes, pData)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL)

*/

//
//typdefs
//

typedef WCHAR   SERVICE_NAME[32];

typedef SERVICE_NAME *PSERVICE_NAME;

//the main services start atmost 2 levels deep in the service dependency tree
//leaf is at level 0
typedef struct _SERVICE_INFO{
    SERVICE_NAME        snSvcName;
    DWORD               dwDependencyCnt;
    SERVICE_NAME        snProvidorSvc[MAX_PROVIDOR_SERVICES];    
}SERVICE_INFO, *PSERVICE_INFO;

//at most we can start 10 independent services
typedef struct _SERVICE_INFOLIST{
    DWORD               dwMaxSvcCnt; //at most 5
    SERVICE_INFO        SvcInfo[MAX_INDEPENDENT_SERVICES];
} SERVICE_INFOLIST, *PSERVICE_INFOLIST;



//typedefs
typedef struct _COMMON_RESOURCE {
#ifdef COMMON_PARAMS_DEFINED
    COMMON_PARAMS   Params;
#endif
    HRESOURCE       hResource;
    HANDLE          ServiceHandle[MAX_INDEPENDENT_SERVICES][1+MAX_PROVIDOR_SERVICES];
    DWORD           ServiceCnt;     //at most 5
    RESOURCE_HANDLE ResourceHandle;
    LPWSTR          ResourceName;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    CLUS_WORKER     OnlineThread;
    BOOL            Online;
} COMMON_RESOURCE, *PCOMMON_RESOURCE;


//prototypes
/*
VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );
*/

#ifdef _cplusplus
}
#endif


#endif // ifndef _BOSVC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genapp\genapp.c ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation

Module Name:

    genapp.c

Abstract:

    Resource DLL for Generic Applications.

Author:

    Rod Gamache (rodga) 8-Jan-1996

Revision History:

--*/
#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "userenv.h"

#define LOG_CURRENT_MODULE LOG_MODULE_GENAPP

#define DBG_PRINT printf


#define PARAM_NAME__COMMANDLINE         CLUSREG_NAME_GENAPP_COMMAND_LINE
#define PARAM_NAME__CURRENTDIRECTORY    CLUSREG_NAME_GENAPP_CURRENT_DIRECTORY
#define PARAM_NAME__USENETWORKNAME      CLUSREG_NAME_GENAPP_USE_NETWORK_NAME
#define PARAM_NAME__INTERACTWITHDESKTOP CLUSREG_NAME_GENAPP_INTERACT_WITH_DESKTOP

#define PARAM_MIN__USENETWORKNAME           0
#define PARAM_MAX__USENETWORKNAME           1
#define PARAM_DEFAULT__USENETWORKNAME       0

#define PARAM_MIN__INTERACTWITHDESKTOP      0
#define PARAM_MAX__INTERACTWITHDESKTOP      1
#define PARAM_DEFAULT__INTERACTWITHDESKTOP  0

typedef struct _GENAPP_PARAMS {
    PWSTR           CommandLine;
    PWSTR           CurrentDirectory;
    DWORD           UseNetworkName;
    DWORD           InteractWithDesktop;
} GENAPP_PARAMS, *PGENAPP_PARAMS;

typedef struct _GENAPP_RESOURCE {
    GENAPP_PARAMS   Params;
    HRESOURCE       hResource;
    HANDLE          hProcess;
    DWORD           ProcessId;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    RESOURCE_HANDLE ResourceHandle;
    CLUS_WORKER     PendingThread;
    BOOL            Online;
} GENAPP_RESOURCE, *PGENAPP_RESOURCE;


//
// Global Data
//
RESUTIL_PROPERTY_ITEM
GenAppResourcePrivateProperties[] = {
    { PARAM_NAME__COMMANDLINE,         NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(GENAPP_PARAMS,CommandLine) },
    { PARAM_NAME__CURRENTDIRECTORY,    NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(GENAPP_PARAMS,CurrentDirectory) },
    { PARAM_NAME__INTERACTWITHDESKTOP, NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__INTERACTWITHDESKTOP, PARAM_MIN__INTERACTWITHDESKTOP, PARAM_MAX__INTERACTWITHDESKTOP, 0, FIELD_OFFSET(GENAPP_PARAMS,InteractWithDesktop) },
    { PARAM_NAME__USENETWORKNAME,      NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__USENETWORKNAME, PARAM_MIN__USENETWORKNAME, PARAM_MAX__USENETWORKNAME, 0, FIELD_OFFSET(GENAPP_PARAMS,UseNetworkName) },
    { 0 }
};

//
// critsec to synchronize calling of SetProcessWindowStation in ClRtl routine
//
CRITICAL_SECTION GenAppWinsta0Lock;

// Event Logging routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE GenAppFunctionTable;



//
// Forward routines
//
BOOLEAN
VerifyApp(
    IN RESID ResourceId,
    IN BOOLEAN IsAliveFlag
    );

BOOL
FindOurWindow(
    HWND    WindowHandle,
    LPARAM  OurProcessId
    );

DWORD
GenAppGetPrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
GenAppValidatePrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENAPP_PARAMS Params
    );

DWORD
GenAppSetPrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
GenAppGetPids(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

//
// end of forward declarations
//

BOOL
GenAppInit(
    VOID
    )
{
    BOOL    success;
    DWORD   spinCount;

    //
    // set spinCount so system pre-allocates the event for critical
    // sections. use the same spin count that the heap mgr uses as doc'ed in
    // MSDN
    //
    spinCount = 0x80000000 | 4000;
    success = InitializeCriticalSectionAndSpinCount(&GenAppWinsta0Lock,
                                                    spinCount);

    return success;
}


VOID
GenAppUninit(
    VOID
    )
{
    DeleteCriticalSection( &GenAppWinsta0Lock );
}


BOOLEAN
WINAPI
GenAppDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !GenAppInit() ) {
            return(FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:
        GenAppUninit();
        break;

    default:
        break;
    }

    return(TRUE);

} // GenAppDllEntryPoint


RESID
WINAPI
GenAppOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic application resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    RESID   appResid = 0;
    DWORD   errorCode;
    HKEY    parametersKey = NULL;
    HKEY    resKey = NULL;
    PGENAPP_RESOURCE resourceEntry = NULL;
    DWORD   paramNameMaxSize = 0;
    HCLUSTER hCluster;

    //
    // Get registry parameters for this resource.
    //

    errorCode = ClusterRegOpenKey( ResourceKey,
                                   CLUSREG_KEYNAME_PARAMETERS,
                                   KEY_READ,
                                   &parametersKey );

    if ( errorCode != NO_ERROR ) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open parameters key. Error: %1!u!.\n",
                     errorCode );
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    errorCode = ClusterRegOpenKey( ResourceKey,
                                   L"",
                                   KEY_READ,
                                   &resKey);
    if (errorCode != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     errorCode );
        goto error_exit;
    }

    resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(GENAPP_RESOURCE) );
    if ( resourceEntry == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a process info structure.\n" );
        errorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEntry, sizeof(GENAPP_RESOURCE) );

    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;
    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) {
        errorCode = GetLastError();
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Failed to open cluster, error %1!u!.\n",
                     errorCode);
        goto error_exit;
    }
    resourceEntry->hResource = OpenClusterResource( hCluster, ResourceName );
    errorCode = GetLastError();
    CloseCluster(hCluster);
    if (resourceEntry->hResource == NULL) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource, error %1!u!.\n",
            errorCode
            );
        goto error_exit;
    }

    appResid = (RESID)resourceEntry;

error_exit:

    if ( appResid == NULL) {
        if (parametersKey != NULL) {
            ClusterRegCloseKey( parametersKey );
        }
        if (resKey != NULL) {
            ClusterRegCloseKey( resKey );
        }
    }

    if ( (appResid == 0) && (resourceEntry != NULL) ) {
        LocalFree( resourceEntry );
    }

    if ( errorCode != ERROR_SUCCESS ) {
        SetLastError( errorCode );
    }

    return(appResid);

} // GenAppOpen



DWORD
WINAPI
GenAppOnlineWorker(
    IN PCLUS_WORKER     Worker,
    IN PGENAPP_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Does the work of bringing a genapp resource online.

Arguments:

    Worker - Supplies the worker structure

    ResourceEntry - A pointer to the GenApp block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    RESOURCE_STATUS     resourceStatus;
    DWORD               status = ERROR_SUCCESS;
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION Process;
    LPWSTR              nameOfPropInError;
    LPWSTR              expandedDir = NULL;
    LPWSTR              expandedCommand = NULL;


    // Create Process parameters

    LPVOID   Environment = NULL;
    LPVOID   OldEnvironment;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    //
    // Read our parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   GenAppResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto error_exit;
    }

    if ( ResourceEntry->Params.UseNetworkName ) {
        //
        // Create the new environment with the simulated net name.
        //
        Environment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    } else {
        HANDLE processToken;

        //
        // get the current process token. If it fails, we revert to using just the
        // system environment area
        //
        OpenProcessToken( GetCurrentProcess(), MAXIMUM_ALLOWED, &processToken );

        //
        // Clone the current environment, picking up any changes that might have
        // been made after resmon started
        //
        CreateEnvironmentBlock(&Environment, processToken, FALSE );

        if ( processToken != NULL ) {
            CloseHandle( processToken );
        }
    }

    ZeroMemory( &StartupInfo, sizeof(StartupInfo) );
    StartupInfo.cb = sizeof(StartupInfo);
    //StartupInfo.lpTitle = NULL;
    //StartupInfo.lpDesktop = NULL;
    StartupInfo.wShowWindow = SW_HIDE;
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    if ( ResourceEntry->Params.InteractWithDesktop ) {

        //
        // don't blindly hang waiting for the lock to become available.
        //
        while ( !TryEnterCriticalSection( &GenAppWinsta0Lock )) {
            if ( ClusWorkerCheckTerminate( Worker )) {
                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_WARNING,
                             L"Aborting online due to worker thread terminate request. lock currently "
                             L"owned by thread %1!u!.\n",
                             GenAppWinsta0Lock.OwningThread );
                
                goto error_exit;
            }

            Sleep( 1000 );
        }

        status = ClRtlAddClusterServiceAccountToWinsta0DACL();
        LeaveCriticalSection( &GenAppWinsta0Lock );

        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Unable to set DACL on interactive window station and its desktop. Error: %1!u!.\n",
                         status );
            goto error_exit;
        }

        StartupInfo.lpDesktop = L"WinSta0\\Default";
        StartupInfo.wShowWindow = SW_SHOW;
    }

    //
    // Expand the current directory parameter
    //
    if ( ResourceEntry->Params.CurrentDirectory ) {

        expandedDir = ResUtilExpandEnvironmentStrings( ResourceEntry->Params.CurrentDirectory );
        if ( expandedDir == NULL ) {
            status = GetLastError();
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Error expanding the current directory, %1!ls!. Error: %2!u!.\n",
                     ResourceEntry->Params.CurrentDirectory,
                     status );
            goto error_exit;
        }
    }

    //
    // Expand the command line parameter
    //
    if ( ResourceEntry->Params.CommandLine ) {

        expandedCommand = ResUtilExpandEnvironmentStrings( ResourceEntry->Params.CommandLine );
        if ( expandedCommand == NULL ) {
            status = GetLastError();
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Error expanding the command line, %1!ls!. Error: %2!u!.\n",
                     ResourceEntry->Params.CommandLine,
                     status );
            goto error_exit;
        }
    }

    if ( !CreateProcess( NULL,
                         expandedCommand,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_UNICODE_ENVIRONMENT,
                         Environment,
                         expandedDir,
                         &StartupInfo,
                         &Process ) )
    {
        status = GetLastError();
        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_GENAPP_CREATE_FAILED,
                                       sizeof(status),
                                       &status);
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Failed to create process. Error: %1!u!.\n",
                         status );
        goto error_exit;
    }

    //
    // Save the handle to the process
    //
    ResourceEntry->hProcess = Process.hProcess;
    ResourceEntry->ProcessId = Process.dwProcessId;
    CloseHandle( Process.hThread );

    ResourceEntry->Online = TRUE;

    //
    // When the process fails EventHandle will be signaled.
    // Because of this no polling is necessary.
    //

    resourceStatus.EventHandle = ResourceEntry->hProcess;
    resourceStatus.ResourceState = ClusterResourceOnline;

error_exit:

    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }

    if ( expandedDir != NULL ) {
        LocalFree( expandedDir );
    }

    if ( expandedCommand != NULL ) {
        LocalFree( expandedCommand );
    }

    if (Environment != NULL) {
        RtlDestroyEnvironment(Environment);
    }

    return(status);

} // GenAppOnlineWorker



DWORD
WINAPI
GenAppOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Generic Application resource.

Arguments:

    ResourceId - Supplies resource id to be brought online

    EventHandle - Supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PGENAPP_RESOURCE resourceEntry;
    DWORD   status = ERROR_SUCCESS;

    resourceEntry = (PGENAPP_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
#if DBG
        OutputDebugStringA( "GenApp: Online request for a nonexistent resource\n" );
#endif
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->hProcess != NULL ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online request and process handle is not NULL!\n" );
        return(ERROR_NOT_READY);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               GenAppOnlineWorker,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenAppOnline

VOID
WINAPI
GenAppTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate entry point for the Generic Application resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PGENAPP_RESOURCE    pResource;

    DWORD   errorCode;

    pResource = ( PGENAPP_RESOURCE ) ResourceId;

    //
    // synchronize with any existing pending operation
    //
    ClusWorkerTerminate( &pResource->PendingThread );

    if ( pResource->hProcess != NULL ) {

        if ( !TerminateProcess( pResource->hProcess, 1 ) ) {
            errorCode = GetLastError();
            if ( errorCode != ERROR_ACCESS_DENIED ) {
                (g_LogEvent)(pResource->ResourceHandle,
                             LOG_ERROR,
                             L"Failed to terminate Process ID %1!u!. Error: %2!u!.\n",
                             pResource->ProcessId,
                             errorCode );
            }
        }

        pResource->ProcessId = 0;

        CloseHandle( pResource->hProcess );
        pResource->hProcess = NULL;

        pResource->Online = FALSE;
    }
} // GenAppTerminate

DWORD
WINAPI
GenAppOfflineWorker(
    IN PCLUS_WORKER     Worker,
    IN PGENAPP_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Real worker routine for offlining a Generic Application resource.

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the GenApp block for this resource.

Return Value:

    None.

--*/

{
    DWORD   errorCode = ERROR_SUCCESS;
    BOOL    switchedDesktop = FALSE;
    HDESK   previousDesktop = NULL;
    HDESK   inputDesktop;
    HDESK   desktopHandle = NULL;
    BOOL    success;
    BOOL    callTerminateProc = TRUE;
    HWINSTA winsta0 = NULL;
    HWINSTA previousWinsta;

    RESOURCE_STATUS     resourceStatus;

    //
    // init resource status structure
    //
    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //
    // get a handle to the appropriate desktop so we enum the correct window
    // set.
    //
    if ( ResourceEntry->Params.InteractWithDesktop ) {

        //
        // periodically check to see if we should terminate
        //
        while ( !TryEnterCriticalSection( &GenAppWinsta0Lock )) {
            if ( ClusWorkerCheckTerminate( Worker )) {
                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_WARNING,
                             L"Aborting offline while trying to acquire desktop lock. lock currently "
                             L"owned by thread %1!u!.\n",
                             GenAppWinsta0Lock.OwningThread );
                
                goto error_exit;
            }

            Sleep( 500 );
        }

        winsta0 = OpenWindowStation( L"winsta0", FALSE, GENERIC_ALL );
        if ( winsta0 != NULL ) {

            previousWinsta = GetProcessWindowStation();
            if ( previousWinsta != NULL ) {

                success = SetProcessWindowStation( winsta0 );
                if ( success ) {
                    //
                    // if we have window station access, we should have desktop as well
                    //

                    desktopHandle = OpenInputDesktop( 0, FALSE, GENERIC_ALL );
                    if ( desktopHandle != NULL ) {
                        switchedDesktop = TRUE;
                    }
                }
            }
        }

        if ( !switchedDesktop ) {
            errorCode = GetLastError();
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Unable to switch to interactive desktop for process %1!u!, status %2!u!.\n",
                         ResourceEntry->ProcessId,
                         errorCode );

            LeaveCriticalSection( &GenAppWinsta0Lock );

            if ( winsta0 != NULL ) {
                CloseWindowStation( winsta0 );
            }
        }
    } else {
        desktopHandle = GetThreadDesktop( GetCurrentThreadId() );
    }

    //
    // find our window. If found, we'll post a WM_CLOSE and zero out the PID
    // field.
    //
    if ( desktopHandle ) {
        EnumDesktopWindows( desktopHandle, FindOurWindow, (LPARAM)&ResourceEntry->ProcessId );
    }

    if ( switchedDesktop ) {
        SetProcessWindowStation( previousWinsta );

        CloseDesktop( desktopHandle );
        CloseWindowStation( winsta0 );

        LeaveCriticalSection( &GenAppWinsta0Lock );
    }

    if ( ResourceEntry->ProcessId == 0 ) {
        //
        // we found our toplevel window. wait on the process handle until the
        // handle is signalled or a pending timeout has occurred
        //
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_INFORMATION,
                     L"Sent WM_CLOSE to top level window - waiting for process to terminate.\n");

    process_wait_retry:
        errorCode = WaitForSingleObject( ResourceEntry->hProcess, 1000 );
        if ( errorCode == WAIT_OBJECT_0 ) {
            callTerminateProc = FALSE;
        } else {
            if ( !ClusWorkerCheckTerminate( Worker )) {
                goto process_wait_retry;
            } else {
                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_WARNING,
                             L"Aborting offline while waiting for process to terminate.\n");
            }
        }
    }

    if ( callTerminateProc ) {
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_WARNING,
                     L"No top level window found or WM_CLOSE post failed - terminating process %1!u!\n",
                     ResourceEntry->ProcessId);

        if ( !TerminateProcess( ResourceEntry->hProcess, 1 ) ) {
            errorCode = GetLastError();
            if ( errorCode != ERROR_ACCESS_DENIED ) {
                (g_LogEvent)(
                             ResourceEntry->ResourceHandle,
                             LOG_ERROR,
                             L"Failed to terminate Process ID %1!u!. Error: %2!u!.\n",
                             ResourceEntry->ProcessId,
                             errorCode );
            }
        }
    }

    ResourceEntry->ProcessId = 0;

    CloseHandle( ResourceEntry->hProcess );
    ResourceEntry->hProcess = NULL;

    ResourceEntry->Online = FALSE;

    resourceStatus.ResourceState = ClusterResourceOffline;

error_exit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return ERROR_SUCCESS;
} // GenAppOfflineThread


DWORD
WINAPI
GenAppOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Generic Application resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    PGENAPP_RESOURCE resourceEntry;
    DWORD   status = ERROR_SUCCESS;

    resourceEntry = (PGENAPP_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
#if DBG
        OutputDebugStringA( "GenApp: Offline request for a nonexistent resource\n" );
#endif
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->hProcess == NULL ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline request and process handle is NULL!\n" );
        return(ERROR_NOT_READY);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               GenAppOfflineWorker,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenAppOffline


BOOL
WINAPI
GenAppIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Generice Applications resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    return VerifyApp( ResourceId, TRUE );

} // GenAppIsAlive



BOOLEAN
VerifyApp(
    IN RESID ResourceId,
    IN BOOLEAN IsAliveFlag
    )

/*++

Routine Description:

    Verify that a Generic Applications resource is running

Arguments:

    ResourceId - Supplies the resource id to be polled.

    IsAliveFlag - TRUE if called from IsAlive, otherwise called from LooksAlive.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/
{

    return TRUE;

} // VerifyApp



BOOL
WINAPI
GenAppLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Generic Applications resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return VerifyApp( ResourceId, FALSE );

} // GenAppLooksAlive



VOID
WINAPI
GenAppClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Generic Applications resource.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PGENAPP_RESOURCE resourceEntry;
    DWORD   errorCode;

    resourceEntry = (PGENAPP_RESOURCE)ResourceId;
    if ( resourceEntry == NULL ) {
#if DBG
        OutputDebugStringA( "GenApp: Close request for a nonexistent resource\n" );
#endif
        return;
    }

    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );

    LocalFree( resourceEntry->Params.CommandLine );
    LocalFree( resourceEntry->Params.CurrentDirectory );

    LocalFree( resourceEntry );

} // GenAppClose



DWORD
GenAppResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Generic Application resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PGENAPP_RESOURCE    resourceEntry;
    DWORD               required;

    resourceEntry = (PGENAPP_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
#if DBG
        OutputDebugStringA( "GenApp: ResourceControl request for a nonexistent resource\n" );
#endif
        return(FALSE);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenAppResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenAppResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = GenAppGetPrivateResProperties( resourceEntry,
                                                    OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = GenAppValidatePrivateResProperties( resourceEntry,
                                                         InBuffer,
                                                         InBufferSize,
                                                         NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = GenAppSetPrivateResProperties( resourceEntry,
                                                    InBuffer,
                                                    InBufferSize );
            break;

        case CLUSCTL_RESOURCE_GET_LOADBAL_PROCESS_LIST:
            status = GenAppGetPids( resourceEntry,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenAppResourceControl



DWORD
GenAppResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Generic Application resources.

    Perform the control request specified by ControlCode for this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenAppResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenAppResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenAppResourceTypeControl



DWORD
GenAppGetPrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type GenApp.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      GenAppResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // GenAppGetPrivateResProperties



DWORD
GenAppValidatePrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENAPP_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Generic Application.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    ERROR_DEPENDENCY_NOT_FOUND - Trying to set UseNetworkName when there
        is no dependency on a Network Name resource.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENAPP_PARAMS   currentProps;
    GENAPP_PARAMS   newProps;
    PGENAPP_PARAMS  pParams = NULL;
    BOOL            hResDependency;
    LPWSTR          nameOfPropInError;
    WCHAR           netnameBuffer[ MAX_PATH + 1 ];
    DWORD           netnameBufferSize = sizeof( netnameBuffer ) / sizeof( WCHAR );

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 GenAppResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(GENAPP_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       GenAppResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( GenAppResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the CurrentDirectory
        //
        if ( pParams->CurrentDirectory &&
             !ResUtilIsPathValid( pParams->CurrentDirectory ) ) {
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

        //
        // If the resource should use the network name as the computer
        // name, make sure there is a dependency on a Network Name
        // resource.
        //
        if ( pParams->UseNetworkName ) {
            hResDependency = GetClusterResourceNetworkName(ResourceEntry->hResource,
                                                           netnameBuffer,
                                                           &netnameBufferSize);
            if ( !hResDependency ) {
                status = ERROR_DEPENDENCY_NOT_FOUND;
            }
        }
    }

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL)
           )
        || ( pParams == &newProps )
       )
    {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   GenAppResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        GenAppResourcePrivateProperties
        );

    return(status);

} // GenAppValidatePrivateResProperties



DWORD
GenAppSetPrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Generic Application.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENAPP_PARAMS   params;

    ZeroMemory( &params, sizeof(GENAPP_PARAMS) );

    //
    // Parse and validate the properties.
    //
    status = GenAppValidatePrivateResProperties( ResourceEntry,
                                                 InBuffer,
                                                 InBufferSize,
                                                 &params );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               GenAppResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               GenAppResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( ResourceEntry->Online ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // GenAppSetPrivateResProperties

DWORD
GenAppGetPids(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Get array of PIDs (as DWORDS) to return for load balancing purposes.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Supplies a pointer to a buffer for output data.

    OutBufferSize - Supplies the size, in bytes, of the buffer pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER props;

    props.pb = OutBuffer;
    *BytesReturned = sizeof(*props.pdw);

    if ( OutBufferSize < sizeof(*props.pdw) ) {
        return(ERROR_MORE_DATA);
    }

    *(props.pdw) = ResourceEntry->ProcessId;

    return(ERROR_SUCCESS);

} // GenAppGetPids



BOOL
FindOurWindow(
    HWND    WindowHandle,
    LPARAM  OurProcessId
    )

/*++

Routine Description:

    Find our window handle in the midst of all of this confusion.

Arguments:

    WindowHandle - a handle to the current window being enumerated.

    OurProcessId - the process Id of the process we are looking for.

Return Value:

    TRUE - if we should continue enumeration.

    FALSE - if we should not continue enumeration.

--*/

{
    LPDWORD ourProcessId = (LPDWORD)OurProcessId;
    DWORD   processId;
    BOOL    success;

    GetWindowThreadProcessId( WindowHandle,
                              &processId );


    if ( processId == *ourProcessId ) {
        success = PostMessage(WindowHandle, WM_CLOSE, 0, 0);
        if ( success ) {
            *ourProcessId = 0;      // Indicate that we found one.
        }
#if DBG
        else {
            (g_LogEvent)(L"rtGenApp Debug",
                         LOG_ERROR,
                         L"WM_CLOSE post to window handle %1!u! failed - status %2!u!\n",
                         WindowHandle,
                         GetLastError());

            if ( IsDebuggerPresent()) {
                OutputDebugStringW(L"Genapp PostMessage failed\n");
                DebugBreak();
            }
        }
#endif

        return(FALSE);
    }

    return(TRUE);

} // FindOurWindow



//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( GenAppFunctionTable,  // Name
                         CLRES_VERSION_V1_00,  // Version
                         GenApp,               // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         GenAppResourceControl,// ResControl
                         GenAppResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genjob\dll\process.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    genapp.c

Abstract:

    Resource DLL for Generic Applications.

Author:

    Rod Gamache (rodga) 8-Jan-1996

Revision History:

--*/

#include "nt.h"
#include "ntpsapi.h"
#include "windef.h"
#include "winerror.h"



DWORD
GetProcessId(
    IN HANDLE ProcessHandle,
    OUT LPDWORD ProcessId
    )

/*++

Routine Description:

    Get the process Id for a process, given its process handle.

Arguments:

    ProcessHandle - the handle for the process to query.

    ProcessId - pointer to a DWORD to receive the process Id.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_PARAMETER on error.

--*/

{
    DWORD   status;
    DWORD   returnLength;
    PROCESS_BASIC_INFORMATION basicProcessInfo;

    //
    // Find the process id.
    //
    status = NtQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &basicProcessInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        &returnLength );
    if ( !NT_SUCCESS(status) ) {
        *ProcessId = 0;
        return(ERROR_INVALID_PARAMETER);
    }

    *ProcessId = (DWORD)basicProcessInfo.UniqueProcessId;

    return(ERROR_SUCCESS);

} // GetProcessId
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genjob\dll\genjob.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    GenJob.c

Abstract:

    Resource DLL for Generic Job Objects (based on genapp)

Author:

    Charlie Wickham (charlwi) 4-14-99

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "jobmsg.h"

// move to clusres.h
#define LOG_MODULE_GENJOB   0x80F

#define LOG_CURRENT_MODULE LOG_MODULE_GENJOB

#define DBG_PRINT printf

// move to clusudef.h
#define CLUS_RESTYPE_NAME_GENJOB                    L"Generic Job Object"
#define CLUSREG_NAME_GENJOB_COMMAND_LINE            L"CommandLine"
#define CLUSREG_NAME_GENJOB_CURRENT_DIRECTORY       L"CurrentDirectory"
#define CLUSREG_NAME_GENJOB_INTERACT_WITH_DESKTOP   L"InteractWithDesktop"
#define CLUSREG_NAME_GENJOB_USE_NETWORK_NAME        L"UseNetworkName"

// delete these when moving to clusres
PSET_RESOURCE_STATUS_ROUTINE ClusResSetResourceStatus = NULL;
PLOG_EVENT_ROUTINE ClusResLogEvent = NULL;

//
// Private properties structure.
//
typedef struct _GENJOB_PROPS
{
    PWSTR   CommandLine;                    // first process in job
    PWSTR   CurrentDirectory;               // directory to associated with process
    DWORD   InteractWithDesktop;            // true sets desktop to "winsta0\default"
    DWORD   UseNetworkName;                 // true if associated netname should be replaced in environment
    BOOL    UseDefaults;                    // true if all job obj defaults are used

    BOOL    ProcsCanBreakaway;              // true sets JOB_OBJECT_LIMIT_BREAKAWAY_OK
    BOOL    ProcsCanSilentlyBreakaway;      // true sets JOB_OBJECT_LIMIT_SILENT_BREAKAWAY
    BOOL    SetActiveProcessLimit;          // true sets JOB_OBJECT_LIMIT_ACTIVE_PROCESS
    DWORD   ActiveProcessLimit;             // sets BasicLimitInformation.ActiveProcessLimit
    BOOL    SetAffinity;                    // true sets JOB_OBJECT_LIMIT_AFFINITY
    DWORD   Affinity;                       // sets BasicLimitInformation.Affinity
    BOOL    SetJobUserTimeLimit;            // true sets JOB_OBJECT_LIMIT_JOB_TIME
    DWORD   PerJobUserTimeLimit;            // sets BasicLimitInformation.PerJobUserTimeLimit
    BOOL    SetPriorityClass;               // true sets JOB_OBJECT_LIMIT_PRIORITY_CLASS
    DWORD   PriorityClass;                  // sets BasicLimitInformation.PriorityClass
    BOOL    SetProcessUserTimeLimit;        // true sets JOB_OBJECT_LIMIT_PROCESS_TIME
    DWORD   PerProcessUserTimeLimit;        // sets BasicLimitInformation.PerProcessUserTimeLimit
    BOOL    SetSchedulingClass;             // true sets JOB_OBJECT_LIMIT_SCHEDULING_CLASS
    DWORD   SchedulingClass;                // sets BasicLimitInformation.SchedulingClass
    BOOL    SetWorkingSetSize;              // true sets JOB_OBJECT_LIMIT_WORKINGSET
    DWORD   MaximumWorkingSetSize;          // sets BasicLimitInformation.MaximumWorkingSetSize
    DWORD   MinimumWorkingSetSize;          // sets BasicLimitInformation.MinimumWorkingSetSize

    BOOL    ManipulateDesktops;             // false sets JOB_OBJECT_UILIMIT_DESKTOP
    BOOL    ChangeDisplaySettings;          // false sets JOB_OBJECT_UILIMIT_DISPLAYSETTINGS
    BOOL    AllowSystemShutdown;            // false sets JOB_OBJECT_UILIMIT_EXITWINDOWS
    BOOL    AccessGlobalAtoms;              // false sets JOB_OBJECT_UILIMIT_GLOBALATOMS
    BOOL    AllowOtherProcessUSERHandles;   // false sets JOB_OBJECT_UILIMIT_HANDLES
    BOOL    ReadFromClipboard;              // false sets JOB_OBJECT_UILIMIT_READCLIPBOARD
    BOOL    ChangeSystemParameters;         // false sets JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS
    BOOL    WriteToClipboard;               // false sets JOB_OBJECT_UILIMIT_WRITECLIPBOARD

    BOOL    TerminateOnTimeLimit;           // false sets JOB_OBJECT_POST_AT_END_OF_JOB

    BOOL    SetJobMemoryLimit;              // true sets JOB_OBJECT_LIMIT_JOB_MEMORY in Basic.LimitFlags
    DWORD   JobMemoryLimit;                 // sets ExtendedLimits.JobMemoryLimit
    BOOL    SetProcessMemoryLimit;          // true sets JOB_OBJECT_LIMIT_PROCESS_MEMORY
    DWORD   ProcessMemoryLimit;             // sets ExtendedLimits.ProcessMemoryLimit

    BOOL    AllowLocalAdminTokens;          // false sets JOB_OBJECT_SECURITY_NO_ADMIN
    BOOL    AllowUseOfRestrictedTokens;     // false sets JOB_OBJECT_SECURITY_RESTRICTED_TOKEN
} GENJOB_PROPS, * PGENJOB_PROPS;

//
// top level per-resource instance structure
//
typedef struct _GENJOB_RESOURCE {
    GENJOB_PROPS    OperationalProps;   // props associated with online resource
    GENJOB_PROPS    StoredProps;        // props to be used next time resource is online
    HRESOURCE       hResource;          // cluster handle to this resource
    DWORD           ProcessId;          // PID of initial process
    HKEY            ResourceKey;        // handle to this resource's key
    HKEY            ParametersKey;      // handle to this resource's params key
    HANDLE          JobHandle;          // backing job object handle
    HANDLE          OfflineEvent;       // signalled when resource goes offline
    RESOURCE_HANDLE ResourceHandle;     // resmon pointer to its structure
    CLUS_WORKER     OnlineThread;       // background online processing thread
    BOOL            Online;             // true if online
} GENJOB_RESOURCE, *PGENJOB_RESOURCE;

//
// property definitions
//
#define PROP_NAME__COMMANDLINE                  CLUSREG_NAME_GENJOB_COMMAND_LINE
#define PROP_NAME__CURRENTDIRECTORY             CLUSREG_NAME_GENJOB_CURRENT_DIRECTORY
#define PROP_NAME__INTERACTWITHDESKTOP          CLUSREG_NAME_GENJOB_INTERACT_WITH_DESKTOP
#define PROP_NAME__USENETWORKNAME               CLUSREG_NAME_GENJOB_USE_NETWORK_NAME
#define PROP_NAME__USEDEFAULTS                  L"UseDefaults"

#define PROP_NAME__PROCSCANBREAKAWAY            L"ProcsCanBreakaway"
#define PROP_NAME__PROCSCANSILENTLYBREAKAWAY    L"ProcsCanSilentlyBreakaway"
#define PROP_NAME__SETACTIVEPROCESSLIMIT        L"SetActiveProcessLimit"
#define PROP_NAME__ACTIVEPROCESSLIMIT           L"ActiveProcessLimit"
#define PROP_NAME__SETAFFINITY                  L"SetAffinity"
#define PROP_NAME__AFFINITY                     L"Affinity"
#define PROP_NAME__SETJOBUSERTIMELIMIT          L"SetJobUserTimeLimit"
#define PROP_NAME__PERJOBUSERTIMELIMIT          L"PerJobUserTimeLimit"
#define PROP_NAME__SETPRIORITYCLASS             L"SetPriorityClass"
#define PROP_NAME__PRIORITYCLASS                L"PriorityClass"
#define PROP_NAME__SETPROCESSUSERTIMELIMIT      L"SetProcessUserTimeLimit"
#define PROP_NAME__PERPROCESSUSERTIMELIMIT      L"PerProcessUserTimelimit"
#define PROP_NAME__SETSCHEDULINGCLASS           L"SetSchedulingClass"
#define PROP_NAME__SCHEDULINGCLASS              L"SchedulingClass"
#define PROP_NAME__SETWORKINGSETSIZE            L"SetWorkingSetSize"
#define PROP_NAME__MAXIMUMWORKINGSETSIZE        L"MaximumWorkingSetSize"
#define PROP_NAME__MINIMUMWORKINGSETSIZE        L"MinimumWorkingSetSize"

#define PROP_NAME__MANIPULATEDESKTOPS           L"ManipulateDesktops"
#define PROP_NAME__CHANGEDISPLAYSETTINGS        L"ChangeDisplaySettings"
#define PROP_NAME__ALLOWSYSTEMSHUTDOWN          L"Allowsystemshutdown"
#define PROP_NAME__ACCESSGLOBALATOMS            L"AccessGlobalAtoms"
#define PROP_NAME__ALLOWOTHERPROCESSUSERHANDLES L"AllowOtherProcessUSERHandles"
#define PROP_NAME__READFROMCLIPBOARD            L"ReadFromClipboard"
#define PROP_NAME__CHANGESYSTEMPARAMETERS       L"ChangeSystemParameters"
#define PROP_NAME__WRITETOCLIPBOARD             L"WriteToClipboard"

#define PROP_NAME__TERMINATEONTIMELIMIT         L"TerminateOnTimeLimit"

#define PROP_NAME__SETJOBMEMORYLIMIT            L"SetJobMemoryLimit"
#define PROP_NAME__JOBMEMORYLIMIT               L"JobMemoryLimit"
#define PROP_NAME__SETPROCESSMEMORYLIMIT        L"SetProcessMemoryLimit"
#define PROP_NAME__PROCESSMEMORYLIMIT           L"ProcessMemoryLimit"

#define PROP_NAME__ALLOWLOCALADMINTOKENS        L"AllowLocalAdminTokens"
#define PROP_NAME__ALLOWUSEOFRESTRICTEDTOKENS   L"AllowUseOfRestrictedTokens"

//
// min, max, defaults for each non-string property
//

#define PROP_MIN__INTERACTWITHDESKTOP               0
#define PROP_MAX__INTERACTWITHDESKTOP               1
#define PROP_DEFAULT__INTERACTWITHDESKTOP           0

#define PROP_MIN__USENETWORKNAME                    0
#define PROP_MAX__USENETWORKNAME                    1
#define PROP_DEFAULT__USENETWORKNAME                0

#define PROP_MIN__USEDEFAULTS                       0
#define PROP_MAX__USEDEFAULTS                       1
#define PROP_DEFAULT__USEDEFAULTS                   1

#define PROP_MIN__PROCSCANBREAKAWAY                 (0)
#define PROP_MAX__PROCSCANBREAKAWAY                 (1)
#define PROP_DEFAULT__PROCSCANBREAKAWAY             (0)

#define PROP_MIN__PROCSCANSILENTLYBREAKAWAY         (0)
#define PROP_MAX__PROCSCANSILENTLYBREAKAWAY         (1)
#define PROP_DEFAULT__PROCSCANSILENTLYBREAKAWAY     (0)

#define PROP_MIN__SETACTIVEPROCESSLIMIT             (0)
#define PROP_MAX__SETACTIVEPROCESSLIMIT             (1)
#define PROP_DEFAULT__SETACTIVEPROCESSLIMIT         (0)

#define PROP_MIN__ACTIVEPROCESSLIMIT                (1)
#define PROP_MAX__ACTIVEPROCESSLIMIT                (4294967295)
#define PROP_DEFAULT__ACTIVEPROCESSLIMIT            (1)

#define PROP_MIN__SETAFFINITY                       (0)
#define PROP_MAX__SETAFFINITY                       (1)
#define PROP_DEFAULT__SETAFFINITY                   (0)

#define PROP_MIN__AFFINITY                          (1)
#define PROP_MAX__AFFINITY                          (4294967295)
#define PROP_DEFAULT__AFFINITY                      (1)

#define PROP_MIN__SETJOBUSERTIMELIMIT               (0)
#define PROP_MAX__SETJOBUSERTIMELIMIT               (1)
#define PROP_DEFAULT__SETJOBUSERTIMELIMIT           (0)

#define PROP_MIN__PERJOBUSERTIMELIMIT               (1)
#define PROP_MAX__PERJOBUSERTIMELIMIT               (4294967295)
#define PROP_DEFAULT__PERJOBUSERTIMELIMIT           (1)

#define PROP_MIN__SETPRIORITYCLASS                  (0)
#define PROP_MAX__SETPRIORITYCLASS                  (1)
#define PROP_DEFAULT__SETPRIORITYCLASS              (0)

#define PROP_MIN__PRIORITYCLASS                     (0)
#define PROP_MAX__PRIORITYCLASS                     (31)
#define PROP_DEFAULT__PRIORITYCLASS                 (0)

#define PROP_MIN__SETPROCESSUSERTIMELIMIT           (0)
#define PROP_MAX__SETPROCESSUSERTIMELIMIT           (1)
#define PROP_DEFAULT__SETPROCESSUSERTIMELIMIT       (0)

#define PROP_MIN__PERPROCESSUSERTIMELIMIT           (1)
#define PROP_MAX__PERPROCESSUSERTIMELIMIT           (4294967295)
#define PROP_DEFAULT__PERPROCESSUSERTIMELIMIT       (1)

#define PROP_MIN__SETSCHEDULINGCLASS                (0)
#define PROP_MAX__SETSCHEDULINGCLASS                (1)
#define PROP_DEFAULT__SETSCHEDULINGCLASS            (0)

#define PROP_MIN__SCHEDULINGCLASS                   (0)
#define PROP_MAX__SCHEDULINGCLASS                   (9)
#define PROP_DEFAULT__SCHEDULINGCLASS               (5)

#define PROP_MIN__SETWORKINGSETSIZE                 (0)
#define PROP_MAX__SETWORKINGSETSIZE                 (1)
#define PROP_DEFAULT__SETWORKINGSETSIZE             (0)

#define PROP_MIN__MAXIMUMWORKINGSETSIZE             (0)
#define PROP_MAX__MAXIMUMWORKINGSETSIZE             (4294967295)
#define PROP_DEFAULT__MAXIMUMWORKINGSETSIZE         (0)

#define PROP_MIN__MINIMUMWORKINGSETSIZE             (0)
#define PROP_MAX__MINIMUMWORKINGSETSIZE             (4294967295)
#define PROP_DEFAULT__MINIMUMWORKINGSETSIZE         (0)

#define PROP_MIN__MANIPULATEDESKTOPS                (0)
#define PROP_MAX__MANIPULATEDESKTOPS                (1)
#define PROP_DEFAULT__MANIPULATEDESKTOPS            (1)

#define PROP_MIN__CHANGEDISPLAYSETTINGS             (0)
#define PROP_MAX__CHANGEDISPLAYSETTINGS             (1)
#define PROP_DEFAULT__CHANGEDISPLAYSETTINGS         (1)

#define PROP_MIN__ALLOWSYSTEMSHUTDOWN               (0)
#define PROP_MAX__ALLOWSYSTEMSHUTDOWN               (1)
#define PROP_DEFAULT__ALLOWSYSTEMSHUTDOWN           (1)

#define PROP_MIN__ACCESSGLOBALATOMS                 (0)
#define PROP_MAX__ACCESSGLOBALATOMS                 (1)
#define PROP_DEFAULT__ACCESSGLOBALATOMS             (1)

#define PROP_MIN__ALLOWOTHERPROCESSUSERHANDLES      (0)
#define PROP_MAX__ALLOWOTHERPROCESSUSERHANDLES      (1)
#define PROP_DEFAULT__ALLOWOTHERPROCESSUSERHANDLES  (1)

#define PROP_MIN__READFROMCLIPBOARD                 (0)
#define PROP_MAX__READFROMCLIPBOARD                 (1)
#define PROP_DEFAULT__READFROMCLIPBOARD             (1)

#define PROP_MIN__CHANGESYSTEMPARAMETERS            (0)
#define PROP_MAX__CHANGESYSTEMPARAMETERS            (1)
#define PROP_DEFAULT__CHANGESYSTEMPARAMETERS        (1)

#define PROP_MIN__WRITETOCLIPBOARD                  (0)
#define PROP_MAX__WRITETOCLIPBOARD                  (1)
#define PROP_DEFAULT__WRITETOCLIPBOARD              (1)

#define PROP_MIN__TERMINATEONTIMELIMIT              (0)
#define PROP_MAX__TERMINATEONTIMELIMIT              (1)
#define PROP_DEFAULT__TERMINATEONTIMELIMIT          (1)

#define PROP_MIN__SETJOBMEMORYLIMIT                 (0)
#define PROP_MAX__SETJOBMEMORYLIMIT                 (1)
#define PROP_DEFAULT__SETJOBMEMORYLIMIT             (0)

#define PROP_MIN__JOBMEMORYLIMIT                    (0)
#define PROP_MAX__JOBMEMORYLIMIT                    (4294967295)
#define PROP_DEFAULT__JOBMEMORYLIMIT                (0)

#define PROP_MIN__SETPROCESSMEMORYLIMIT             (0)
#define PROP_MAX__SETPROCESSMEMORYLIMIT             (1)
#define PROP_DEFAULT__SETPROCESSMEMORYLIMIT         (0)

#define PROP_MIN__PROCESSMEMORYLIMIT                (0)
#define PROP_MAX__PROCESSMEMORYLIMIT                (4294967295)
#define PROP_DEFAULT__PROCESSMEMORYLIMIT            (0)

#define PROP_MIN__ALLOWLOCALADMINTOKENS             (0)
#define PROP_MAX__ALLOWLOCALADMINTOKENS             (1)
#define PROP_DEFAULT__ALLOWLOCALADMINTOKENS         (1)

#define PROP_MIN__ALLOWUSEOFRESTRICTEDTOKENS        (0)
#define PROP_MAX__ALLOWUSEOFRESTRICTEDTOKENS        (1)
#define PROP_DEFAULT__ALLOWUSEOFRESTRICTEDTOKENS    (1)

//
// genjob resource read-write private properties.
//

RESUTIL_PROPERTY_ITEM
GenJobResourcePrivateProperties[] = {
    { PROP_NAME__COMMANDLINE,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0, 0, 0,
      RESUTIL_PROPITEM_REQUIRED,
      FIELD_OFFSET(GENJOB_PROPS, CommandLine)
    },
    { PROP_NAME__CURRENTDIRECTORY,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0, 0, 0,
      RESUTIL_PROPITEM_REQUIRED,
      FIELD_OFFSET(GENJOB_PROPS, CurrentDirectory)
    },
    { PROP_NAME__INTERACTWITHDESKTOP,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__INTERACTWITHDESKTOP,
      PROP_MIN__INTERACTWITHDESKTOP,
      PROP_MAX__INTERACTWITHDESKTOP,
      0,
      FIELD_OFFSET(GENJOB_PROPS, InteractWithDesktop)
    },
    { PROP_NAME__USENETWORKNAME,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__USENETWORKNAME,
      PROP_MIN__USENETWORKNAME,
      PROP_MAX__USENETWORKNAME,
      0,
      FIELD_OFFSET(GENJOB_PROPS, UseNetworkName)
    },
    { PROP_NAME__USEDEFAULTS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__USEDEFAULTS,
      PROP_MIN__USEDEFAULTS,
      PROP_MAX__USEDEFAULTS,
      0,
      FIELD_OFFSET(GENJOB_PROPS, UseDefaults)
    },

    { PROP_NAME__PROCSCANBREAKAWAY,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__PROCSCANBREAKAWAY,
      PROP_MIN__PROCSCANBREAKAWAY,
      PROP_MAX__PROCSCANBREAKAWAY,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, ProcsCanBreakaway )
    },
    { PROP_NAME__PROCSCANSILENTLYBREAKAWAY,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__PROCSCANSILENTLYBREAKAWAY,
      PROP_MIN__PROCSCANSILENTLYBREAKAWAY,
      PROP_MAX__PROCSCANSILENTLYBREAKAWAY,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, ProcsCanSilentlyBreakaway )
    },
    { PROP_NAME__SETACTIVEPROCESSLIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETACTIVEPROCESSLIMIT,
      PROP_MIN__SETACTIVEPROCESSLIMIT,
      PROP_MAX__SETACTIVEPROCESSLIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetActiveProcessLimit )
    },
    { PROP_NAME__ACTIVEPROCESSLIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__ACTIVEPROCESSLIMIT,
      PROP_MIN__ACTIVEPROCESSLIMIT,
      PROP_MAX__ACTIVEPROCESSLIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, ActiveProcessLimit )
    },
#if AFFINITY_SUPPORT
    { PROP_NAME__SETAFFINITY,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETAFFINITY,
      PROP_MIN__SETAFFINITY,
      PROP_MAX__SETAFFINITY,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetAffinity )
    },
    { PROP_NAME__AFFINITY,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__AFFINITY,
      PROP_MIN__AFFINITY,
      PROP_MAX__AFFINITY,
      0,
      FIELD_OFFSET( GENJOB_PROPS, Affinity )
    },
#endif
    { PROP_NAME__SETJOBUSERTIMELIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETJOBUSERTIMELIMIT,
      PROP_MIN__SETJOBUSERTIMELIMIT,
      PROP_MAX__SETJOBUSERTIMELIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetJobUserTimeLimit )
    },
    { PROP_NAME__PERJOBUSERTIMELIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__PERJOBUSERTIMELIMIT,
      PROP_MIN__PERJOBUSERTIMELIMIT,
      PROP_MAX__PERJOBUSERTIMELIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, PerJobUserTimeLimit )
    },
    { PROP_NAME__SETPRIORITYCLASS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETPRIORITYCLASS,
      PROP_MIN__SETPRIORITYCLASS,
      PROP_MAX__SETPRIORITYCLASS,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetPriorityClass )
    },
    { PROP_NAME__PRIORITYCLASS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__PRIORITYCLASS,
      PROP_MIN__PRIORITYCLASS,
      PROP_MAX__PRIORITYCLASS,
      0,
      FIELD_OFFSET( GENJOB_PROPS, PriorityClass )
    },
    { PROP_NAME__SETPROCESSUSERTIMELIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETPROCESSUSERTIMELIMIT,
      PROP_MIN__SETPROCESSUSERTIMELIMIT,
      PROP_MAX__SETPROCESSUSERTIMELIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetProcessUserTimeLimit )
    },
    { PROP_NAME__PERPROCESSUSERTIMELIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__PERPROCESSUSERTIMELIMIT,
      PROP_MIN__PERPROCESSUSERTIMELIMIT,
      PROP_MAX__PERPROCESSUSERTIMELIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, PerProcessUserTimeLimit )
    },
    { PROP_NAME__SETSCHEDULINGCLASS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETSCHEDULINGCLASS,
      PROP_MIN__SETSCHEDULINGCLASS,
      PROP_MAX__SETSCHEDULINGCLASS,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetSchedulingClass )
    },
    { PROP_NAME__SCHEDULINGCLASS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SCHEDULINGCLASS,
      PROP_MIN__SCHEDULINGCLASS,
      PROP_MAX__SCHEDULINGCLASS,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SchedulingClass )
    },
    { PROP_NAME__SETWORKINGSETSIZE,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETWORKINGSETSIZE,
      PROP_MIN__SETWORKINGSETSIZE,
      PROP_MAX__SETWORKINGSETSIZE,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetWorkingSetSize )
    },
    { PROP_NAME__MAXIMUMWORKINGSETSIZE,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__MAXIMUMWORKINGSETSIZE,
      PROP_MIN__MAXIMUMWORKINGSETSIZE,
      PROP_MAX__MAXIMUMWORKINGSETSIZE,
      0,
      FIELD_OFFSET( GENJOB_PROPS, MaximumWorkingSetSize )
    },
    { PROP_NAME__MINIMUMWORKINGSETSIZE,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__MINIMUMWORKINGSETSIZE,
      PROP_MIN__MINIMUMWORKINGSETSIZE,
      PROP_MAX__MINIMUMWORKINGSETSIZE,
      0,
      FIELD_OFFSET( GENJOB_PROPS, MinimumWorkingSetSize )
    },

    { PROP_NAME__MANIPULATEDESKTOPS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__MANIPULATEDESKTOPS,
      PROP_MIN__MANIPULATEDESKTOPS,
      PROP_MAX__MANIPULATEDESKTOPS,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, ManipulateDesktops )
    },
    { PROP_NAME__CHANGEDISPLAYSETTINGS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__CHANGEDISPLAYSETTINGS,
      PROP_MIN__CHANGEDISPLAYSETTINGS,
      PROP_MAX__CHANGEDISPLAYSETTINGS,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, ChangeDisplaySettings )
    },
    { PROP_NAME__ALLOWSYSTEMSHUTDOWN,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__ALLOWSYSTEMSHUTDOWN,
      PROP_MIN__ALLOWSYSTEMSHUTDOWN,
      PROP_MAX__ALLOWSYSTEMSHUTDOWN,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, AllowSystemShutdown )
    },
    { PROP_NAME__ACCESSGLOBALATOMS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__ACCESSGLOBALATOMS,
      PROP_MIN__ACCESSGLOBALATOMS,
      PROP_MAX__ACCESSGLOBALATOMS,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, AccessGlobalAtoms )
    },
    { PROP_NAME__ALLOWOTHERPROCESSUSERHANDLES,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__ALLOWOTHERPROCESSUSERHANDLES,
      PROP_MIN__ALLOWOTHERPROCESSUSERHANDLES,
      PROP_MAX__ALLOWOTHERPROCESSUSERHANDLES,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, AllowOtherProcessUSERHandles )
    },
    { PROP_NAME__READFROMCLIPBOARD,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__READFROMCLIPBOARD,
      PROP_MIN__READFROMCLIPBOARD,
      PROP_MAX__READFROMCLIPBOARD,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, ReadFromClipboard )
    },
    { PROP_NAME__CHANGESYSTEMPARAMETERS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__CHANGESYSTEMPARAMETERS,
      PROP_MIN__CHANGESYSTEMPARAMETERS,
      PROP_MAX__CHANGESYSTEMPARAMETERS,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, ChangeSystemParameters )
    },
    { PROP_NAME__WRITETOCLIPBOARD,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__WRITETOCLIPBOARD,
      PROP_MIN__WRITETOCLIPBOARD,
      PROP_MAX__WRITETOCLIPBOARD,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, WriteToClipboard )
    },

    { PROP_NAME__TERMINATEONTIMELIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__TERMINATEONTIMELIMIT,
      PROP_MIN__TERMINATEONTIMELIMIT,
      PROP_MAX__TERMINATEONTIMELIMIT,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, TerminateOnTimeLimit )
    },

    { PROP_NAME__SETJOBMEMORYLIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETJOBMEMORYLIMIT,
      PROP_MIN__SETJOBMEMORYLIMIT,
      PROP_MAX__SETJOBMEMORYLIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetJobMemoryLimit )
    },
    { PROP_NAME__JOBMEMORYLIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__JOBMEMORYLIMIT,
      PROP_MIN__JOBMEMORYLIMIT,
      PROP_MAX__JOBMEMORYLIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, JobMemoryLimit )
    },
    { PROP_NAME__SETPROCESSMEMORYLIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__SETPROCESSMEMORYLIMIT,
      PROP_MIN__SETPROCESSMEMORYLIMIT,
      PROP_MAX__SETPROCESSMEMORYLIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, SetProcessMemoryLimit )
    },
    { PROP_NAME__PROCESSMEMORYLIMIT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__PROCESSMEMORYLIMIT,
      PROP_MIN__PROCESSMEMORYLIMIT,
      PROP_MAX__PROCESSMEMORYLIMIT,
      0,
      FIELD_OFFSET( GENJOB_PROPS, ProcessMemoryLimit )
    },

    { PROP_NAME__ALLOWLOCALADMINTOKENS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__ALLOWLOCALADMINTOKENS,
      PROP_MIN__ALLOWLOCALADMINTOKENS,
      PROP_MAX__ALLOWLOCALADMINTOKENS,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, AllowLocalAdminTokens )
    },
    { PROP_NAME__ALLOWUSEOFRESTRICTEDTOKENS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      PROP_DEFAULT__ALLOWUSEOFRESTRICTEDTOKENS,
      PROP_MIN__ALLOWUSEOFRESTRICTEDTOKENS,
      PROP_MAX__ALLOWUSEOFRESTRICTEDTOKENS,
      RESUTIL_PROPITEM_SIGNED,
      FIELD_OFFSET( GENJOB_PROPS, AllowUseOfRestrictedTokens )
    },
    { 0 }
};

//
// completion port vars. A separate thread is spun up when the first resource
// goes online. This thread waits for activity on the completion port
// handle. When the last resource goes offline, the port is closed and the
// thread exits. Each time a resource comes online, it is associated with the
// port.
//
CRITICAL_SECTION    GenJobPortLock;
HANDLE              GenJobPort;
LONG                GenJobOnlineResources = 0;
HANDLE              GenJobPortThread = NULL;

// Event Logging routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE GenJobFunctionTable;


//
// Forward routines
//

BOOLEAN
VerifyApp(
    IN RESID ResourceId,
    IN BOOLEAN IsAliveFlag
    );

DWORD
GenJobGetPrivateResProperties(
    IN OUT PGENJOB_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
GenJobValidatePrivateResProperties(
    IN OUT PGENJOB_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENJOB_PROPS Params
    );

DWORD
GenJobSetPrivateResProperties(
    IN OUT PGENJOB_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

#if LOADBAL_SUPPORT
DWORD
GenJobGetPids(
    IN OUT PGENJOB_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );
#endif

VOID
GenJobTearDownCompletionPort(
    VOID
    );

BOOLEAN
GenJobInit(
    VOID
    )
{
    return(TRUE);
}

BOOLEAN
WINAPI
GenJobDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !GenJobInit() ) {
            return(FALSE);
        }

        InitializeCriticalSection( &GenJobPortLock );
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return(TRUE);

} // GenJobDllEntryPoint

RESID
WINAPI
GenJobOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic job object resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    RESID   appResid = 0;
    DWORD   status;
    HKEY    parametersKey = NULL;
    HKEY    resKey = NULL;
    PGENJOB_RESOURCE resourceEntry = NULL;
    DWORD   paramNameMaxSize = 0;
    HCLUSTER hCluster;

    //
    // Get registry parameters for this resource.
    //
    status = ClusterRegOpenKey(ResourceKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               KEY_READ,
                               &parametersKey );

    if ( status != NO_ERROR ) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open parameters key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey(ResourceKey,
                               L"",
                               KEY_READ,
                               &resKey);
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(GENJOB_RESOURCE) );
    if ( resourceEntry == NULL ) {
        (g_LogEvent)(
                     ResourceHandle,
                     LOG_ERROR,
                     L"Failed to allocate a process info structure.\n" );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEntry, sizeof(GENJOB_RESOURCE) );

    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->OfflineEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( resourceEntry->OfflineEvent == NULL ) {
        status = GetLastError();
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Failed to create offline event, error %1!u!.\n",
                     status);
        goto error_exit;
    }

    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) {
        status = GetLastError();
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Failed to open cluster, error %1!u!.\n",
                     status);
        goto error_exit;
    }

    //
    // get a cluster resource handle to this resource
    //
    resourceEntry->hResource = OpenClusterResource( hCluster, ResourceName );
    status = GetLastError();
    CloseCluster(hCluster);

    if (resourceEntry->hResource == NULL) {
        (g_LogEvent)(
                     ResourceHandle,
                     LOG_ERROR,
                     L"Failed to open resource, error %1!u!.\n",
                     status
                     );
        goto error_exit;
    }

    appResid = (RESID)resourceEntry;

error_exit:

    if ( appResid == NULL) {
        if (parametersKey != NULL) {
            ClusterRegCloseKey( parametersKey );
        }
        if (resKey != NULL) {
            ClusterRegCloseKey( resKey );
        }
    }

    if ( (appResid == 0) && (resourceEntry != NULL) ) {
        LocalFree( resourceEntry );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return(appResid);

} // GenJobOpen

DWORD
WINAPI
GenJobPortRoutine(
    LPVOID Parameter
    )

/*++

Routine Description:

    Monitors IO on completion port. Exits if terminate event is signalled

Arguments:

    Parameter - not used

Return Value:

    None

--*/

{
    PGENJOB_RESOURCE    resource;
    DWORD               msgId;
    DWORD               msgValue;
    LPWSTR              logMessage;

    do {
        if ( GetQueuedCompletionStatus(GenJobPort,
                                       &msgId,
                                       (PULONG_PTR)&resource,
                                       (LPOVERLAPPED *)&msgValue,
                                       INFINITE))
        {
            if ( resource == NULL ) {
                break;
            }

            switch ( msgId ) {
            case JOB_OBJECT_MSG_END_OF_JOB_TIME:
                logMessage = L"End of job time limit has been reached.\n";
                break;

            case JOB_OBJECT_MSG_END_OF_PROCESS_TIME:
                logMessage = L"End of process time limit has been reached for process ID %1!u!.\n";
                break;

            case JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT:
                logMessage = L"The active process limit has been exceeded.\n";
                break;

            case JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO:
                logMessage = L"The active process count has reached zero.\n";

                //
                // signal that the last process in the job exited.
                //
                SetEvent( resource->OfflineEvent );
                break;

            case JOB_OBJECT_MSG_NEW_PROCESS:
                logMessage = L"Process ID %1!u! has been added to the job.\n";
                break;

            case JOB_OBJECT_MSG_EXIT_PROCESS:
                logMessage = L"Process ID %1!u! has exited.\n";
                break;

            case JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS:
                logMessage = L"Process ID %1!u! has abnormally exited.\n";
                break;

            case JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT:
                logMessage = L"Process ID %1!u! has exceeded its memory limit\n";
                break;

            case JOB_OBJECT_MSG_JOB_MEMORY_LIMIT:
                logMessage = L"Process ID %1!u! has caused the job has to exceed its memory limit.\n";
                break;

            default:
                (g_LogEvent)(resource->ResourceHandle,
                             LOG_ERROR,
                             L"Unknown Job message; message ID = %1!u!, msg value = %2!u!\n",
                             msgId,
                             msgValue);

                goto skip_message;
            }

            //
            // log the appropriate msg
            //
            (g_LogEvent)(resource->ResourceHandle,
                         LOG_ERROR,
                         logMessage,
                         msgValue);
skip_message:
            ;
        }
    } while (1);

    return 0;
}

DWORD
GenJobInitializeCompletionPort(
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Init all the giblets associatd with the completion port, i.e., create the
    port, spin up the thread that waits on the port, etc. Must be called with
    GenJobPortLock held.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything worked

--*/

{
    DWORD status = ERROR_SUCCESS;
    DWORD threadId;

    //
    // create the completion port
    //
    GenJobPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, 0, 0 );

    if ( GenJobPort == NULL ) {
        status = GetLastError();
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to create completion port. Error: %1!u!.\n",
                     status );

        return status;
    }

    //
    // create the thread that waits on the port
    //
    GenJobPortThread = CreateThread(NULL,       // default security
                                    0,          // default stack
                                    GenJobPortRoutine,
                                    0,          // routine parameter
                                    0,          // creation flags
                                    &threadId);

    if ( GenJobPortThread == NULL ) {
        status = GetLastError();
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to create completion port thread. Error: %1!u!.\n",
                     status );
    }

    return status;
}

DWORD
SetJobObjectClasses(
    IN  PGENJOB_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    build the job object class struct from the operational data in the
    resource entry and call SetInformationJobObject

Arguments:

    ResourceEntry - pointer to netname resource being manipulated

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    DWORD                                   status = ERROR_SUCCESS;
    PGENJOB_PROPS                           jobProps = &ResourceEntry->OperationalProps;
    JOBOBJECT_BASIC_UI_RESTRICTIONS         basicUiLimits;
    JOBOBJECT_END_OF_JOB_TIME_INFORMATION   timeLimits;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION    extendedLimits;
    JOBOBJECT_SECURITY_LIMIT_INFORMATION    securityLimits;

    //
    // init various flag members to their defaults
    //
    basicUiLimits.UIRestrictionsClass = JOB_OBJECT_UILIMIT_NONE;
    securityLimits.SecurityLimitFlags = 0;
    extendedLimits.BasicLimitInformation.LimitFlags =
        JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;
    timeLimits.EndOfJobTimeAction = JOB_OBJECT_TERMINATE_AT_END_OF_JOB;

    if ( !jobProps->UseDefaults ) {

        //
        // set basic limits. convert time limits from secs to 100ns units
        //
        if ( jobProps->SetProcessUserTimeLimit ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_TIME;
            extendedLimits.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart =
                jobProps->PerProcessUserTimeLimit * 10 * 1000 * 1000;
        }

        if ( jobProps->SetJobUserTimeLimit ) {
            extendedLimits.BasicLimitInformation.LimitFlags |=
                JOB_OBJECT_LIMIT_JOB_TIME;
            extendedLimits.BasicLimitInformation.PerJobUserTimeLimit.QuadPart =
                jobProps->PerJobUserTimeLimit * 10 * 1000 * 1000;
        }

        if ( jobProps->SetWorkingSetSize ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_WORKINGSET;
            extendedLimits.BasicLimitInformation.MinimumWorkingSetSize = jobProps->MinimumWorkingSetSize;
            extendedLimits.BasicLimitInformation.MaximumWorkingSetSize = jobProps->MaximumWorkingSetSize;
        }

        if ( jobProps->SetActiveProcessLimit ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
            extendedLimits.BasicLimitInformation.ActiveProcessLimit = jobProps->ActiveProcessLimit;
        }

#if 0
        if ( jobProps->SetAffininty ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_AFFINITY;
            extendedLimits.BasicLimitInformation.Affinity = jobProps->Affinity;
        }
#endif

        if ( jobProps->SetPriorityClass ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;
            extendedLimits.BasicLimitInformation.PriorityClass = jobProps->PriorityClass;
        }

        if ( jobProps->SetSchedulingClass ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
            extendedLimits.BasicLimitInformation.SchedulingClass = jobProps->SchedulingClass;
        }

        if ( jobProps->ProcsCanBreakaway ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_BREAKAWAY_OK;
        }

        if ( jobProps->ProcsCanSilentlyBreakaway ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;
        }

        //
        // basic UI limits
        //
        if ( !jobProps->ManipulateDesktops ) {
            basicUiLimits.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_DESKTOP;
        }
        if ( !jobProps->ChangeDisplaySettings ) {
            basicUiLimits.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_DISPLAYSETTINGS;
        }
        if ( !jobProps->AllowSystemShutdown ) {
            basicUiLimits.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_EXITWINDOWS;
        }
        if ( !jobProps->AccessGlobalAtoms ) {
            basicUiLimits.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_GLOBALATOMS;
        }
        if ( !jobProps->AllowOtherProcessUSERHandles ) {
            basicUiLimits.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_HANDLES;
        }
        if ( !jobProps->ReadFromClipboard ) {
            basicUiLimits.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_READCLIPBOARD;
        }
        if ( !jobProps->ChangeSystemParameters ) {
            basicUiLimits.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS;
        }
        if ( !jobProps->WriteToClipboard ) {
            basicUiLimits.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_WRITECLIPBOARD;
        }

        //
        // time limits
        //
        if ( !jobProps->TerminateOnTimeLimit ) {
            timeLimits.EndOfJobTimeAction = JOB_OBJECT_POST_AT_END_OF_JOB;
        }

        //
        // extended limits
        //
        if ( jobProps->SetProcessMemoryLimit ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
            extendedLimits.ProcessMemoryLimit = jobProps->ProcessMemoryLimit;
        }

        if ( jobProps->SetJobMemoryLimit ) {
            extendedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_JOB_MEMORY;
            extendedLimits.JobMemoryLimit = jobProps->JobMemoryLimit;
        }

        //
        // security limits
        //
        if ( !jobProps->AllowUseOfRestrictedTokens ) {
            securityLimits.SecurityLimitFlags |= JOB_OBJECT_SECURITY_RESTRICTED_TOKEN;
        }

        if ( !jobProps->AllowLocalAdminTokens ) {
            securityLimits.SecurityLimitFlags |= JOB_OBJECT_SECURITY_NO_ADMIN;
        }
    }

    //
    // extended limits which includes basic. we always do this since there are
    // some basic limit flags we want to set regardless of whether defaults
    // are used
    //
    if ( !SetInformationJobObject(ResourceEntry->JobHandle,
                                  JobObjectExtendedLimitInformation,
                                  &extendedLimits,
                                  sizeof( extendedLimits )))
    {
        status = GetLastError();
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Can't set extended limit information. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // set the other limits as appropriate
    //
    if ( !SetInformationJobObject(ResourceEntry->JobHandle,
                                  JobObjectBasicUIRestrictions,
                                  &basicUiLimits,
                                  sizeof( basicUiLimits )))
    {
        status = GetLastError();
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Can't set basic UI limit information. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // time is special in that we only set if they want something other than
    // the default
    //
    if ( !SetInformationJobObject(ResourceEntry->JobHandle,
                                  JobObjectEndOfJobTimeInformation,
                                  &timeLimits,
                                  sizeof( timeLimits )))
    {
        status = GetLastError();
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Can't set end of job time information. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    if ( !SetInformationJobObject(ResourceEntry->JobHandle,
                                  JobObjectSecurityLimitInformation,
                                  &securityLimits,
                                  sizeof( securityLimits )))
    {
        status = GetLastError();
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Can't set security limit information. Error: %1!u!.\n",
                     status );
    }

error_exit:

    return status;
}

DWORD
GenJobOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PGENJOB_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the GenJob block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    RESOURCE_STATUS                     resourceStatus;
    DWORD                               status = ERROR_SUCCESS;
    STARTUPINFO                         startupInfo;
    PROCESS_INFORMATION                 processInfo;
    LPWSTR                              nameOfPropInError;
    LPVOID                              Environment = NULL;
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT portInfo;

    //
    // initial resource status struct
    //
    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    //
    // create the unnamed completion port if necessary. If online fails at
    // some point, resmon will call GenJobTerminate which decrements the count
    //
    EnterCriticalSection( &GenJobPortLock );
    if ( ++GenJobOnlineResources == 1 ) {
        status = GenJobInitializeCompletionPort( ResourceEntry->ResourceHandle );

        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Unable to create completon port. Error: %1!u!.\n",
                         status );

            LeaveCriticalSection( &GenJobPortLock );
            goto error_exit;
        }
    }
    LeaveCriticalSection( &GenJobPortLock );

    //
    // create an un-named job object
    //
    ResourceEntry->JobHandle = CreateJobObject( NULL, NULL );
    if ( ResourceEntry->JobHandle == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to create job object. Error: %1!u!.\n",
            status );

        goto error_exit;
    }

    //
    // Read our parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   GenJobResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->OperationalProps,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Unable to read the '%1' property. Error: %2!u!.\n",
                     (nameOfPropInError == NULL ? L"" : nameOfPropInError),
                     status );
        goto error_exit;
    }

    //
    // move our prop values into the job object structs
    //
    status = SetJobObjectClasses( ResourceEntry );
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // set the job object completion port data
    //
    portInfo.CompletionKey = ResourceEntry;
    portInfo.CompletionPort = GenJobPort;
    if ( !SetInformationJobObject(ResourceEntry->JobHandle,
                                  JobObjectAssociateCompletionPortInformation,
                                  &portInfo,
                                  sizeof( portInfo )))
    {
        status = GetLastError();
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Unable to associate completion port with job. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // fake the network name if told to
    //
    if ( ResourceEntry->OperationalProps.UseNetworkName ) {
        Environment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    }

    //
    // fire it up!
    //
    ZeroMemory( &startupInfo, sizeof(startupInfo) );
    startupInfo.cb = sizeof(startupInfo);
    startupInfo.dwFlags = STARTF_USESHOWWINDOW;

    if ( ResourceEntry->OperationalProps.InteractWithDesktop ) {
        startupInfo.lpDesktop = L"WinSta0\\Default";
        startupInfo.wShowWindow = SW_SHOW;
    } else {
        startupInfo.wShowWindow = SW_HIDE;
    }

    if ( !CreateProcess( NULL,
                         ResourceEntry->OperationalProps.CommandLine,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_UNICODE_ENVIRONMENT,
                         Environment,
                         ResourceEntry->OperationalProps.CurrentDirectory,
                         &startupInfo,
                         &processInfo))
    {
        status = GetLastError();
        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_GENJOB_CREATE_FAILED,
                                       sizeof(status),
                                       &status);

        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Failed to create process. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // associate the proc with the job
    //
    if ( !AssignProcessToJobObject(ResourceEntry->JobHandle,
                                   processInfo.hProcess))
    {
        status = GetLastError();
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Failed to assign process to job. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // Save the process Id and close the process/thread handles
    //
    ResourceEntry->ProcessId = processInfo.dwProcessId;
    CloseHandle( processInfo.hThread );
    CloseHandle( processInfo.hProcess );

    ResourceEntry->Online = TRUE;

    //
    // job objects are signalled only when a limit is exceeded so an event is
    // used to indicate when the last process in the job has exited.
    //
    resourceStatus.EventHandle = ResourceEntry->OfflineEvent;
    resourceStatus.ResourceState = ClusterResourceOnline;

error_exit:

    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }

    if (Environment != NULL) {
        RtlDestroyEnvironment(Environment);
    }

    return(status);

} // GenJobOnlineThread


DWORD
WINAPI
GenJobOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Generic Job Object resource.

Arguments:

    ResourceId - Supplies resource id to be brought online

    EventHandle - Supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PGENJOB_RESOURCE resourceEntry;
    DWORD   status = ERROR_SUCCESS;

    resourceEntry = (PGENJOB_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenJob: Online request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->JobHandle != NULL ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online request and job object handle is not NULL!\n" );
        return(ERROR_NOT_READY);
    }

    (g_LogEvent)(resourceEntry->ResourceHandle,
                 LOG_ERROR,
                 L"Online request.\n");

    ClusWorkerTerminate( &resourceEntry->OnlineThread );
    status = ClusWorkerCreate( &resourceEntry->OnlineThread,
                               GenJobOnlineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenJobOnline

VOID
GenJobTearDownCompletionPort(
    VOID
    )

/*++

Routine Description:

    Clean up all the mechanisms associated with the completion port. Must be
    called with GenJobPortLock critsec held.

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    //
    // setting lpOverlapped to NULL signals the GenJobPortRoutine to exit
    //
    if ( GenJobPortThread != NULL ) {
        PostQueuedCompletionStatus( GenJobPort, 0, 0, NULL );
        status = WaitForSingleObject( GenJobPortThread, INFINITE );
        CloseHandle( GenJobPortThread );
        GenJobPortThread = NULL;
    }

    if ( GenJobPort != NULL ) {
        CloseHandle( GenJobPort );
        GenJobPort = NULL;
    }
}

VOID
WINAPI
GenJobTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Generic Job Object resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PGENJOB_RESOURCE resourceEntry;
    DWORD   status;

    resourceEntry = (PGENJOB_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenJob: Terminate request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    if ( !TerminateJobObject( resourceEntry->JobHandle, 1 ) ) {
        status = GetLastError();
        if ( status != ERROR_ACCESS_DENIED ) {
            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to terminate job object, handle %1!u!. Error: %2!u!.\n",
                resourceEntry->JobHandle,
                status );
        }
    }

    CloseHandle( resourceEntry->JobHandle );
    resourceEntry->JobHandle = NULL;

    //
    // get rid of the completion port if there are no more open resources
    //
    if ( resourceEntry->Online == TRUE ) {
        EnterCriticalSection( &GenJobPortLock );
        ASSERT( GenJobOnlineResources > 0 );
        if ( --GenJobOnlineResources == 0 ) {
            GenJobTearDownCompletionPort();
        }
        LeaveCriticalSection( &GenJobPortLock );
    }

    resourceEntry->Online = FALSE;

} // GenJobTerminate


DWORD
WINAPI
GenJobOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Generic Job Object resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    PGENJOB_RESOURCE resourceEntry = (PGENJOB_RESOURCE)ResourceId;

    (g_LogEvent)(resourceEntry->ResourceHandle,
                 LOG_ERROR,
                 L"Offline request.\n");

    GenJobTerminate( ResourceId );

    return(ERROR_SUCCESS);

} // GenJobOffline


BOOL
WINAPI
GenJobIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Generice job object resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    return VerifyApp( ResourceId, TRUE );

} // GenJobIsAlive


BOOLEAN
VerifyApp(
    IN RESID ResourceId,
    IN BOOLEAN IsAliveFlag
    )

/*++

Routine Description:

    Verify that a Generic Job Objects resource is running

Arguments:

    ResourceId - Supplies the resource id to be polled.

    IsAliveFlag - TRUE if called from IsAlive, otherwise called from LooksAlive.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/
{

    return TRUE;

} // VerifyApp


BOOL
WINAPI
GenJobLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Generic Job Objects resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return VerifyApp( ResourceId, FALSE );

} // GenJobLooksAlive


VOID
WINAPI
GenJobClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Generic Job Objects resource.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PGENJOB_RESOURCE resourceEntry;
    DWORD   status;

    resourceEntry = (PGENJOB_RESOURCE)ResourceId;
    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenJob: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );

    CloseHandle( resourceEntry->OfflineEvent );

    LocalFree( resourceEntry->OperationalProps.CommandLine );
    LocalFree( resourceEntry->OperationalProps.CurrentDirectory );

    LocalFree( resourceEntry );

} // GenJobClose


DWORD
GenJobResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Generic Job Object resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PGENJOB_RESOURCE    resourceEntry;
    DWORD               required;

    resourceEntry = (PGENJOB_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenJob: ResourceControl request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenJobResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;


        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenJobResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = GenJobGetPrivateResProperties( resourceEntry,
                                                    OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = GenJobValidatePrivateResProperties( resourceEntry,
                                                         InBuffer,
                                                         InBufferSize,
                                                         NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = GenJobSetPrivateResProperties( resourceEntry,
                                                    InBuffer,
                                                    InBufferSize );
            break;

#if LOADBAL_SUPPORT
        case CLUSCTL_RESOURCE_GET_LOADBAL_PROCESS_LIST:
            status = GenJobGetPids( resourceEntry,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned );
            break;
#endif

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenJobResourceControl


DWORD
GenJobResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Generic Job Object resources.

    Perform the control request specified by ControlCode for this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenJobResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;


        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenJobResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenJobResourceTypeControl


DWORD
GenJobGetPrivateResProperties(
    IN OUT PGENJOB_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type GenJob.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      GenJobResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // GenJobGetPrivateResProperties


DWORD
GenJobValidatePrivateResProperties(
    IN OUT PGENJOB_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENJOB_PROPS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Generic Job Object.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    ERROR_DEPENDENCY_NOT_FOUND - Trying to set UseNetworkName when there
        is no dependency on a Network Name resource.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENJOB_PROPS    currentProps;
    GENJOB_PROPS    newProps;
    PGENJOB_PROPS   pParams;
    HRESOURCE       hResDependency;
    LPWSTR          nameOfPropInError;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 GenJobResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(GENJOB_PROPS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       GenJobResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( GenJobResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the CurrentDirectory
        //
        if ( pParams->CurrentDirectory &&
             !ResUtilIsPathValid( pParams->CurrentDirectory ) ) {
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

        //
        // If the resource should use the network name as the computer
        // name, make sure there is a dependency on a Network Name
        // resource.
        //
        if ( pParams->UseNetworkName ) {
            hResDependency = ResUtilGetResourceDependency(ResourceEntry->hResource,
                                                          CLUS_RESTYPE_NAME_NETNAME);
            if ( hResDependency == NULL ) {
                status = ERROR_DEPENDENCY_NOT_FOUND;
            } else {
                CloseClusterResource( hResDependency );
            }
        }
    }

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL) )
        || ( pParams == &newProps )
        ) {
        ResUtilFreeParameterBlock( (LPBYTE) &pParams,
                                   (LPBYTE) &currentProps,
                                   GenJobResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        GenJobResourcePrivateProperties
        );

    return(status);

} // GenJobValidatePrivateResProperties


DWORD
GenJobSetPrivateResProperties(
    IN OUT PGENJOB_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function for
    resources of type Generic Job Object. Some parameters (command line,
    current dir, desktop, and netname) cause no change in the resource if it
    is online and the parameters have changed value. If any job object
    parameters are specified at the same time, they DO NOT get set.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENJOB_PROPS    params;

    ZeroMemory( &params, sizeof(GENJOB_PROPS) );

    //
    // Parse and validate the properties.
    //
    status = GenJobValidatePrivateResProperties( ResourceEntry,
                                                 InBuffer,
                                                 InBufferSize,
                                                 &params );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Save the parameter values.
    //
    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               GenJobResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->StoredProps );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->OperationalProps,
                               GenJobResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( ResourceEntry->Online ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // GenJobSetPrivateResProperties

#if LOADBAL_SUPPORT
DWORD
GenJobGetPids(
    IN OUT PGENJOB_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Get array of PIDs (as DWORDS) to return for load balancing purposes.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Supplies a pointer to a buffer for output data.

    OutBufferSize - Supplies the size, in bytes, of the buffer pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER props;

    props.pb = OutBuffer;
    *BytesReturned = sizeof(*props.pdw);

    if ( OutBufferSize < sizeof(*props.pdw) ) {
        return(ERROR_MORE_DATA);
    }

    *(props.pdw) = ResourceEntry->ProcessId;

    return(ERROR_SUCCESS);

} // GenJobGetPids
#endif

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup a particular resource type. This means verifying the version
    requested, and returning the function table for this resource type.

    remove when moving to clusres

Arguments:

    ResourceType - Supplies the type of resource.

    MinVersionSupported - The minimum version number supported by the cluster
                    service on this system.

    MaxVersionSupported - The maximum version number supported by the cluster
                    service on this system.

    SetResourceStatus - xxx

    LogEvent - xxx

    FunctionTable - Returns the Function Table for this resource type.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( !ClusResLogEvent ) {
        ClusResLogEvent = LogEvent;
        ClusResSetResourceStatus = SetResourceStatus;
    }

    if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_GENJOB ) == 0 ) {
        *FunctionTable = &GenJobFunctionTable;
        return(ERROR_SUCCESS);
    } else {
        return(ERROR_CLUSTER_RESNAME_NOT_FOUND);
    }
} // Startup

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( GenJobFunctionTable,  // Name
                         CLRES_VERSION_V1_00,  // Version
                         GenJob,               // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         GenJobResourceControl,// ResControl
                         GenJobResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genjob\dll\utils.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Common utility routines for clusters resources

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/
#include "clusres.h"
#include "clusrtl.h"
#include "clusudef.h"



DWORD
ClusResOpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    )
/*++

Routine Description:

    This function opens a specified IO drivers.

Arguments:

    Handle - pointer to location where the opened drivers handle is
        returned.

    DriverName - name of the driver to be opened.

Return Value:

    Windows Error Code.

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      nameString;
    NTSTATUS            status;

    *Handle = NULL;

    //
    // Open a Handle to the IP driver.
    //

    RtlInitUnicodeString(&nameString, DriverName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile(
        Handle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        NULL,
        0
        );

    return( RtlNtStatusToDosError( status ) );

} // ClusResOpenDriver



NTSTATUS
ClusResDoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    )
/*++

Routine Description:

    Utility routine used to issue a filtering ioctl to the tcpip driver.

Arguments:

    Handle - An open file handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output buffer.

Return Value:

    NT Status Code.

--*/
{
    IO_STATUS_BLOCK    ioStatusBlock;
    NTSTATUS           status;


    ioStatusBlock.Information = 0;

    status = NtDeviceIoControlFile(
                                 Handle,                          // Driver handle
                 NULL,                            // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IoctlCode,                       // Control code
                 Request,                         // Input buffer
                 RequestSize,                     // Input buffer size
                 Response,                        // Output buffer
                 *ResponseSize                    // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     Handle,
                     TRUE,
                     NULL
                     );
    }

    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
        *ResponseSize = (DWORD)ioStatusBlock.Information;
    }
    else {
        *ResponseSize = 0;
    }

    return(status);

} // ClusResDoIoctl



VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    DWORD dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof(ResourceName);
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)ResourceName,
                                   &BufSize );
    if (Status != ERROR_SUCCESS) {
        ResourceName[0] = '\0';
    } else {
        ResourceName[79] = '\0';
    }

    ClusterLogEvent1(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     ResourceName);

    return;
}


VOID
ClusResLogEventWithName1(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    DWORD dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof(ResourceName);
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)ResourceName,
                                   &BufSize );
    if (Status != ERROR_SUCCESS) {
        ResourceName[0] = '\0';
    } else {
        ResourceName[79] = '\0';
    }

    ClusterLogEvent2(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     ResourceName,
                     Arg1);

    return;
}


VOID
ClusResLogEventWithName2(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

    Arg2 - Supplies the second insertion string

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    DWORD dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof(ResourceName);
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)ResourceName,
                                   &BufSize );
    if (Status != ERROR_SUCCESS) {
        ResourceName[0] = '\0';
    } else {
        ResourceName[79] = '\0';
    }

    ClusterLogEvent3(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     ResourceName,
                     Arg1,
                     Arg2);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\activescriptsite.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ActiveScriptSite.cpp
//
//  Description:
//      CActiveScript class implementation.
//
//  Maintained By:
//      gpease 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ResourceObject.h"
#include "ActiveScriptSite.h"

DEFINE_THISCLASS( "CActiveScriptSite" );

//////////////////////////////////////////////////////////////////////
// 
//  Constructor
//
//////////////////////////////////////////////////////////////////////
CActiveScriptSite::CActiveScriptSite(
    RESOURCE_HANDLE     hResourceIn,
    PLOG_EVENT_ROUTINE  plerIn,
    HKEY                hkeyIn,
    LPCWSTR             pszNameIn
    ) :
    m_hResource( hResourceIn ),
    m_pler( plerIn ),
    m_hkey( hkeyIn ),
    m_pszName( pszNameIn )
{
    TraceClsFunc( "CActiveScriptSite\n" );
    Assert( m_cRef == 0 );
    Assert( m_punkResource == 0 );
    AddRef( );

    TraceFuncExit( );
}

//////////////////////////////////////////////////////////////////////
// 
//  Destructor
//
//////////////////////////////////////////////////////////////////////
CActiveScriptSite::~CActiveScriptSite()
{
    TraceClsFunc( "~CActiveScriptSite\n" );

    // Don't close m_hkey.
    // Don't free m_pszName
    
    if ( m_punkResource != NULL )
    {
        m_punkResource->Release( );
    }

    TraceFuncExit( );
}

//****************************************************************************
//
//  IUnknown
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::[IUnknown] QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::QueryInterface( 
    REFIID riid, 
    void** ppUnk 
    )
{
    TraceClsFunc( "[IUnknown] QueryInterface( )\n" );

    HRESULT hr = E_NOINTERFACE;

    *ppUnk = NULL;

    if ( riid == IID_IUnknown )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IUnknown, (IActiveScriptSite*) this, 0 );
        hr = S_OK;
    }
    else if ( riid == IID_IActiveScriptSite )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IActiveScriptSite, (IActiveScriptSite*) this, 0 );
        hr = S_OK;
    }
    else if ( riid == IID_IActiveScriptSiteInterruptPoll )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IActiveScriptSiteInterruptPoll, (IActiveScriptSiteInterruptPoll*) this, 0 );
        hr = S_OK;
    }
    else if ( riid == IID_IActiveScriptSiteWindow )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IActiveScriptSiteWindow, (IActiveScriptSiteWindow*) this, 0 );
        hr = S_OK;
    }
    else if ( riid == IID_IDispatchEx )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IDispatchEx, (IDispatchEx*) this, 0 );
        hr = S_OK;
    }
    else if ( riid == IID_IDispatch )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IDispatch, (IDispatchEx*) this, 0 );
        hr = S_OK;
    }

    if ( hr == S_OK )
    {
        ((IUnknown *) *ppUnk)->AddRef( );
    }

    QIRETURN( hr, riid );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
CActiveScriptSite::AddRef( )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );
    InterlockedIncrement( &m_cRef );
    RETURN( m_cRef );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
CActiveScriptSite::Release( )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );
    InterlockedDecrement( &m_cRef );
    if ( m_cRef )
        RETURN( m_cRef );

    delete this;

    RETURN( 0 );
}

//****************************************************************************
//
// IActiveScriptSite
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetLCID( 
//      LCID *plcid // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetLCID( 
    LCID *plcid // out
    )
{
    TraceClsFunc( "[IActiveScriptSite] GetLCID( ... )\n" );
    if ( !plcid )
        HRETURN( E_POINTER );
    
    HRETURN( S_FALSE );   // use system-defined locale
}
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetItemInfo( 
//      LPCOLESTR pstrName,     // in
//      DWORD dwReturnMask,     // in
//      IUnknown **ppiunkItem,  // out
//      ITypeInfo **ppti        // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetItemInfo( 
    LPCOLESTR pstrName,     // in
    DWORD dwReturnMask,     // in
    IUnknown **ppiunkItem,  // out
    ITypeInfo **ppti        // out
    )
{
    TraceClsFunc( "[IActiveScriptSite] GetItemInfo( )\n" );

    if ( (dwReturnMask & SCRIPTINFO_IUNKNOWN) && !ppiunkItem )
        HRETURN( E_POINTER );

    if ( (dwReturnMask & SCRIPTINFO_ITYPEINFO) && !ppti )
        HRETURN( E_POINTER );

    if ( pstrName == NULL )
        HRETURN( E_INVALIDARG );

    HRESULT hr = TYPE_E_ELEMENTNOTFOUND;

    if ( StrCmpI( pstrName, L"Resource" ) == 0 )
    {
        if ( dwReturnMask & SCRIPTINFO_IUNKNOWN )
        {
            if ( m_punkResource == NULL )
            {
                m_punkResource = new CResourceObject( m_hResource, m_pler, m_hkey, m_pszName );
                if ( m_punkResource == NULL )
                    goto OutOfMemory;

                //
                //  No need to AddRef() as the constructor does that for us.
                //
            }

            hr = m_punkResource->TypeSafeQI( IUnknown, ppiunkItem );
        }

        if ( SUCCEEDED( hr ) 
          && ( dwReturnMask & SCRIPTINFO_ITYPEINFO )
           )
        {
            *ppti = NULL;
            hr = THR( E_FAIL );
        }
    }

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetDocVersionString( 
//      BSTR *pbstrVersion  // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetDocVersionString( 
    BSTR *pbstrVersion  // out
    )
{
    TraceClsFunc( "[IActiveScriptSite] GetDocVersionString( )\n" );
    *pbstrVersion = SysAllocString( L"Cluster Scripting Host Version 1.0" );
    if ( *pbstrVersion == NULL )
    {
        HRETURN( E_OUTOFMEMORY );
    }
    HRETURN( S_OK );
}
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnScriptTerminate( 
//      const VARIANT *pvarResult,      // in
//      const EXCEPINFO *pexcepinfo     // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnScriptTerminate( 
    const VARIANT *pvarResult,      // in
    const EXCEPINFO *pexcepinfo     // in
    )
{
    TraceClsFunc( "[IActiveScriptSite] OnScriptTerminate( )\n" );
    HRETURN( S_OK );    // nothing to do
}
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnStateChange( 
//      SCRIPTSTATE ssScriptState   // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnStateChange( 
    SCRIPTSTATE ssScriptState   // in
    )
{
    TraceClsFunc( "[IActiveScriptSite] OnStateChange( )\n" );

#if defined(DEBUG)
    //
    // We don't really care.
    //
    switch ( ssScriptState )
    {
    case SCRIPTSTATE_UNINITIALIZED:
        TraceMsg( mtfCALLS, "OnStateChange: Uninitialized\n" );
        break;

    case SCRIPTSTATE_INITIALIZED:
        TraceMsg( mtfCALLS, "OnStateChange: Initialized\n" );
        break;

    case SCRIPTSTATE_STARTED:
        TraceMsg( mtfCALLS, "OnStateChange: Started\n" );
        break;

    case SCRIPTSTATE_CONNECTED:
        TraceMsg( mtfCALLS, "OnStateChange: Connected\n" );
        break;

    case SCRIPTSTATE_DISCONNECTED:
        TraceMsg( mtfCALLS, "OnStateChange: Disconnected\n" );
        break;

    case SCRIPTSTATE_CLOSED:
        TraceMsg( mtfCALLS, "OnStateChange: Closed\n" );
        break;

    default:
        TraceMsg( mtfCALLS, "OnStateChange: Unknown value\n" );
        break;
    }
#endif // defined(DEBUG)

    HRETURN( S_OK );
}
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnScriptError( 
//      IActiveScriptError *pscripterror    // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnScriptError( 
    IActiveScriptError *pscripterror    // in
    )
{
    TraceClsFunc( "[IActiveScriptSite] OnScriptError( )\n" );

    HRESULT hr;
    BSTR bstrSourceLine = NULL;
    DWORD dwSourceContext;
    ULONG ulLineNumber;
    LONG lCharacterPosition;
    EXCEPINFO excepinfo;
    LPTSTR pszMsgBuf = NULL;

    hr = pscripterror->GetSourcePosition( &dwSourceContext, &ulLineNumber, &lCharacterPosition );

    hr = pscripterror->GetSourceLineText( &bstrSourceLine );
    if (SUCCEEDED( hr ))
    {
        TraceMsg( mtfCALLS, "Script Error: Line=%u, Character=%u: %s\n", ulLineNumber, lCharacterPosition, bstrSourceLine );
        (ClusResLogEvent)( m_hResource, 
                           LOG_ERROR, 
                           L"Script Error: Line=%1!u!, Character=%2!u!: %3\n", 
                           ulLineNumber, 
                           lCharacterPosition, 
                           bstrSourceLine 
                           );
        SysFreeString( bstrSourceLine );
    }
    else
    {
        TraceMsg( mtfCALLS, "Script Error: ulLineNumber = %u, lCharacter = %u\n", ulLineNumber, lCharacterPosition );
        (ClusResLogEvent)( m_hResource, 
                           LOG_ERROR, 
                           L"Script Error: Line=%1!u!, Character = %2!u!\n", 
                           ulLineNumber, 
                           lCharacterPosition 
                           );
    }

    hr = pscripterror->GetExceptionInfo( &excepinfo );
    if (SUCCEEDED( hr ))
    {
        if ( excepinfo.bstrSource )
        {
            TraceMsg( mtfCALLS, "Source: %s\n", excepinfo.bstrSource );
            (ClusResLogEvent)( m_hResource, LOG_ERROR, L"Source: %1\n", excepinfo.bstrSource );
        }

        if ( excepinfo.bstrDescription )
        {
            TraceMsg( mtfCALLS, "Description: %s\n", excepinfo.bstrDescription );
            (ClusResLogEvent)( m_hResource, LOG_ERROR, L"Description: %1\n", excepinfo.bstrDescription );
        }

        if ( excepinfo.bstrHelpFile )
        {
            TraceMsg( mtfCALLS, "Help File: %s\n", excepinfo.bstrHelpFile );
            (ClusResLogEvent)( m_hResource, LOG_ERROR, L"Help File: %1\n", excepinfo.bstrHelpFile );
        }

		hr = THR( excepinfo.scode );
    }

    HRETURN( S_FALSE );
}
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnEnterScript( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnEnterScript( void )
{
    TraceClsFunc( "[IActiveScriptSite] OnEnterScript( )\n" );
    HRETURN( S_OK );
}
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnLeaveScript( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnLeaveScript( void )
{
    TraceClsFunc( "[IActiveScriptSite] OnLeaveScript( )\n" );
    HRETURN( S_OK );
}


//****************************************************************************
//
//  IActiveScriptSiteInterruptPoll 
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::QueryContinue( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::QueryContinue( void )
{
    TraceClsFunc( "[IActiveScriptSiteInterruptPoll] QueryContinue( )\n" );
    HRETURN( S_OK );
}

//****************************************************************************
//
//  IActiveScriptSiteWindow
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetWindow ( 
//      HWND *phwnd // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetWindow ( 
    HWND *phwnd // out
    )
{
    TraceClsFunc( "[IActiveScriptSiteWindow] GetWindow( )\n" );
    *phwnd = NULL;  // desktop;
    HRETURN( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::EnableModeless( 
//      BOOL fEnable // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::EnableModeless( 
    BOOL fEnable // in
    )
{
    TraceClsFunc( "[IActiveScriptSiteWindow] EnableModeless( )\n" );
    HRETURN( S_OK );
}


//****************************************************************************
//
//  IDispatch
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetTypeInfoCount ( 
//      UINT * pctinfo // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetTypeInfoCount ( 
    UINT * pctinfo // out
    )
{
    TraceClsFunc( "[IDispatch] GetTypeInfoCount( )\n" );

    *pctinfo = 0;

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetTypeInfo ( 
//      UINT iTInfo,            // in
//      LCID lcid,              // in
//      ITypeInfo * * ppTInfo   // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetTypeInfo ( 
    UINT iTInfo,            // in
    LCID lcid,              // in
    ITypeInfo * * ppTInfo   // out
    )
{
    TraceClsFunc( "[IDispatch] GetTypeInfo( )\n" );

    if ( !ppTInfo )
        HRETURN( E_POINTER );

    *ppTInfo = NULL;

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetIDsOfNames ( 
//      REFIID      riid,       // in
//      LPOLESTR *  rgszNames,  // in
//      UINT        cNames,     // in
//      LCID        lcid,       // in
//      DISPID *    rgDispId    // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetIDsOfNames ( 
    REFIID      riid,       // in
    LPOLESTR *  rgszNames,  // in
    UINT        cNames,     // in
    LCID        lcid,       // in
    DISPID *    rgDispId    // out
    )
{
    TraceClsFunc( "[IDispatch] GetIDsOfName( )\n" );

    ZeroMemory( rgDispId, cNames * sizeof(DISPID) );

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::Invoke ( 
//      DISPID dispIdMember,        // in
//      REFIID riid,                // in
//      LCID lcid,                  // in
//      WORD wFlags,                // in
//      DISPPARAMS *pDispParams,    // out in
//      VARIANT *pVarResult,        // out
//      EXCEPINFO *pExcepInfo,      // out
//      UINT *puArgErr              // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::Invoke ( 
    DISPID dispIdMember,        // in
    REFIID riid,                // in
    LCID lcid,                  // in
    WORD wFlags,                // in
    DISPPARAMS *pDispParams,    // out in
    VARIANT *pVarResult,        // out
    EXCEPINFO *pExcepInfo,      // out
    UINT *puArgErr              // out
    )
{
    TraceClsFunc( "[IDispatch] Invoke( )\n" );

    HRETURN( E_NOTIMPL );
}


//****************************************************************************
//
//  IDispatchEx
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetDispID (
//      BSTR bstrName,  // in
//      DWORD grfdex,   //in
//      DISPID *pid     //out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetDispID (
    BSTR bstrName,  // in
    DWORD grfdex,   //in
    DISPID *pid     //out
    )
{
    if ( !pid )
        HRETURN( E_POINTER );

    TraceClsFunc( "[IDispatchEx] GetDispID( )\n" );

    HRESULT hr = S_OK;

    if ( StrCmpI( bstrName, L"Resource" ) == 0 )
    {
        *pid = 0;
    }
    else
    {
        hr = DISP_E_UNKNOWNNAME;
    }

    HRETURN( hr );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::InvokeEx ( 
//      DISPID id,                  // in
//      LCID lcid,                  // in
//      WORD wFlags,                // in
//      DISPPARAMS *pdp,            // in
//      VARIANT *pvarRes,           // out
//      EXCEPINFO *pei,             // out
//      IServiceProvider *pspCaller // in
//      )
//      
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::InvokeEx ( 
    DISPID id,                  // in
    LCID lcid,                  // in
    WORD wFlags,                // in
    DISPPARAMS *pdp,            // in
    VARIANT *pvarRes,           // out
    EXCEPINFO *pei,             // out
    IServiceProvider *pspCaller // in
    )
{
    TraceClsFunc2( "[IDispatchEx] InvokeEx( id = %u, ..., wFlags = 0x%08x, ... )\n", id, wFlags );

    HRESULT hr = S_OK;

    switch ( id )
    {
    case 0:
        pvarRes->vt = VT_DISPATCH;
        hr = THR( QueryInterface( IID_IDispatch, (void **) &pvarRes->pdispVal ) );
        break;

    default:
        hr = THR( DISP_E_MEMBERNOTFOUND );
        break;
    }
    HRETURN( hr );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::DeleteMemberByName ( 
//      BSTR bstr,   // in
//      DWORD grfdex // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::DeleteMemberByName ( 
    BSTR bstr,   // in
    DWORD grfdex // in
    )
{
    TraceClsFunc( "[IDispatchEx] DeleteMemberByName( )\n" );
    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::DeleteMemberByDispID ( 
//      DISPID id   // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::DeleteMemberByDispID ( 
    DISPID id   // in
    )
{
    TraceClsFunc1( "[IDispatchEx] DeleteMemberByDispID( id = %u )\n", id );
    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetMemberProperties ( 
//      DISPID id,          // in
//      DWORD grfdexFetch,  // in
//      DWORD * pgrfdex     // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetMemberProperties ( 
    DISPID id,          // in
    DWORD grfdexFetch,  // in
    DWORD * pgrfdex     // out
    )
{
    TraceClsFunc2( "[IDispatchEx] GetMemberProperties( id = %u, grfdexFetch = 0x%08x )\n", id, grfdexFetch );
    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetMemberName ( 
//      DISPID id,          // in
//      BSTR * pbstrName    // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetMemberName ( 
    DISPID id,          // in
    BSTR * pbstrName    // out
    )
{
    TraceClsFunc1( "[IDispatchEx] GetMemberName( id = %u, ... )\n", id );
    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetNextDispID ( 
//      DWORD grfdex,  // in
//      DISPID id,     // in
//      DISPID * pid   // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetNextDispID ( 
    DWORD grfdex,  // in
    DISPID id,     // in
    DISPID * pid   // out
    )
{
    TraceClsFunc2( "[IDispatchEx] GetNextDispId( grfdex = 0x%08x, id = %u, ... )\n", grfdex, id );
    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetNameSpaceParent ( 
//      IUnknown * * ppunk  // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetNameSpaceParent ( 
    IUnknown * * ppunk  // out
    )
{
    TraceClsFunc( "[IDispatchEx] GetNameSpaceParent( ... )\n" );

    if ( !ppunk )
        HRETURN( E_POINTER );

    *ppunk = NULL;

    HRETURN( E_NOTIMPL );
}


//****************************************************************************
//
// Private Methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CActiveScriptSite::LogError(
//      HRESULT hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveScriptSite::LogError(
    HRESULT hrIn
    )
{
    TraceClsFunc1( "LogError( hrIn = 0x%08x )\n", hrIn );

    TraceMsg( mtfCALLS, "HRESULT: 0x%08x\n", hrIn );
    (ClusResLogEvent)( m_hResource, LOG_ERROR, L"HRESULT: 0x%1!08x!.\n", hrIn );

    HRETURN( S_OK );

} //*** LogError( )


//****************************************************************************
//
// Automation Methods
//
//****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\activescriptsite.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      ActiveScriptSite.h
//
//  Description:
//      CActiveScriptSite class header file.
//
//  Maintained By:
//      gpease 14-DEC-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CActiveScriptSite :
    public IActiveScriptSite,
    public IActiveScriptSiteInterruptPoll,
    public IActiveScriptSiteWindow,
    public IDispatchEx
{
private:
    LONG m_cRef;

    RESOURCE_HANDLE     m_hResource;        
    PLOG_EVENT_ROUTINE  m_pler;
    HKEY                m_hkey;
    IUnknown *          m_punkResource;
    LPCWSTR             m_pszName;      // DONT'T FREE

private:
    STDMETHOD(LogError)( HRESULT hrIn );

public:
    explicit CActiveScriptSite( RESOURCE_HANDLE     hResourceIn,
                                PLOG_EVENT_ROUTINE  plerIn,
                                HKEY                hkeyIn,
                                LPCWSTR             pszName
                                );
    virtual ~CActiveScriptSite();

    // IUnknown
    STDMETHOD( QueryInterface )(
        REFIID riid,
        void ** ppUnk );
    STDMETHOD_(ULONG, AddRef )( );
    STDMETHOD_(ULONG, Release )( );

    // IActiveScriptSite
    STDMETHOD( GetLCID )( 
            /* [out] */ LCID __RPC_FAR *plcid );
        
    STDMETHOD( GetItemInfo )( 
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwReturnMask,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti );
        
    STDMETHOD( GetDocVersionString )( 
            /* [out] */ BSTR __RPC_FAR *pbstrVersion );
        
    STDMETHOD( OnScriptTerminate )( 
            /* [in] */ const VARIANT __RPC_FAR *pvarResult,
            /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo );
        
    STDMETHOD( OnStateChange )( 
            /* [in] */ SCRIPTSTATE ssScriptState );
        
    STDMETHOD( OnScriptError )( 
            /* [in] */ IActiveScriptError __RPC_FAR *pscripterror );
        
    STDMETHOD( OnEnterScript )( void );
        
    STDMETHOD( OnLeaveScript )( void );

    // IActiveScriptSiteInterruptPoll 
    STDMETHOD( QueryContinue )( void );

    // IActiveScriptSiteWindow
    STDMETHOD( GetWindow )( 
            /* [out] */ HWND __RPC_FAR *phwnd );        
    STDMETHOD( EnableModeless)( 
            /* [in] */ BOOL fEnable );

    // IDispatch
    STDMETHOD( GetTypeInfoCount )( 
            /* [out] */ UINT __RPC_FAR *pctinfo );        
    STDMETHOD( GetTypeInfo )( 
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo );        
    STDMETHOD( GetIDsOfNames )( 
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId );        
    STDMETHOD( Invoke )( 
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr );
 
    // IDispatchEx
    STDMETHOD( GetDispID )( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid );        
    STDMETHOD( InvokeEx )( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller );        
    STDMETHOD( DeleteMemberByName )( 
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex );        
    STDMETHOD( DeleteMemberByDispID )( 
            /* [in] */ DISPID id );        
    STDMETHOD( GetMemberProperties )( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex );        
    STDMETHOD( GetMemberName )( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName );        
    STDMETHOD( GetNextDispID )( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid );        
    STDMETHOD( GetNameSpaceParent )( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\gencmd\gencmd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    gencmd.c

Abstract:

    Resource DLL for Generic Command line services.
    This is a modified version of generic app.
    Online and offline events each create a command window, execute a command,
    then delete the command window.

Author:

    Rod Gamache (rodga) 8-Jan-1996
    Robs - modified to make gencmd version

Revision History:

--*/

#define UNICODE 1
#include "windows.h"
#include "stdio.h"

#include "clusapi.h"
#include "resapi.h"

#define MAX_APPS    200

#define GENCMD_PRINT printf

typedef struct _MY_PROCESS_INFORMATION {
    PROCESS_INFORMATION;
    ULONG       Index;
    RESOURCE_HANDLE ResourceHandle;
    PTSTR       AppName;
    PTSTR       OnCommandLine;
    PTSTR       OffCommandLine;
    PTSTR       CurDir;
} MY_PROCESS_INFORMATION, *PMY_PROCESS_INFORMATION;


//
// Global Data
//

// Lock to protect the ProcessInfo table

CRITICAL_SECTION ProcessLock;

// The list of handles for active apps

PMY_PROCESS_INFORMATION ProcessInfo[MAX_APPS];

// Event Logging routine

PLOG_EVENT_ROUTINE GenCmdLogEvent = NULL;

extern CLRES_FUNCTION_TABLE GenCmdFunctionTable;


//
// Forward routines
//

LPWSTR
GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    );




BOOLEAN
GenCmdInit(
    VOID
    )
{
    InitializeCriticalSection( &ProcessLock );
    return(TRUE);
}


BOOLEAN
WINAPI
GenCmdDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{

    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !GenCmdInit() ) {
            return(FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return(TRUE);

} // GenCmd DllEntryPoint



DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup a particular resource type. This means verifying the version
    requested, and returning the function table for this resource type.

Arguments:

    ResourceType - Supplies the type of resource.

    MinVersionSupported - The minimum version number supported by the cluster
                    service on this system.

    MaxVersionSupported - The maximum version number supported by the cluster
                    service on this system.

    FunctionTable - Returns the Function Table for this resource type.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    if ( _wcsicmp( ResourceType, L"Generic Command" ) != 0 ) {
        return(ERROR_UNKNOWN_REVISION);
    }

    if ( (MinVersionSupported <= CLRES_VERSION_V1_00) &&
         (MaxVersionSupported >= CLRES_VERSION_V1_00) ) {
        *FunctionTable = &GenCmdFunctionTable;
        return(ERROR_SUCCESS);
    }
    GenCmdLogEvent = LogEvent;

    return(ERROR_REVISION_MISMATCH);

} // Startup



RESID
WINAPI
GenCmdOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic service resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    ULONG   index;
    RESID   appResid = 0;
    DWORD   errorCode;
    HKEY    parametersKey = NULL;
    PMY_PROCESS_INFORMATION processInfo = NULL;
    DWORD   paramNameSize = 0;
    DWORD   paramNameMaxSize = 0;

    // Create Process parameters

    LPWSTR   appName;
    LPWSTR   OncommandLine;
    LPWSTR   OffcommandLine;
    LPWSTR   curDir;

    //
    // Get registry parameters for this resource.
    //
    (GenCmdLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Creating generic command resource.\n" );

    errorCode = ClusterRegOpenKey( ResourceKey,
                                   L"Parameters",
                                   KEY_READ,
                                   &parametersKey );

    if ( errorCode != NO_ERROR ) {
        (GenCmdLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key. Error: %1!u!.\n",
            errorCode);
        goto error_exit;
    }

    //
    // Read our parameters.
    //

    // Get the ImageName parameter

    appName = GetParameter(parametersKey, L"ImageName");

    if ( appName == NULL ) {
        (GenCmdLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to read ImageName parameter. Error: %1!u!.\n",
            GetLastError() );
        goto error_exit;
    }

    // Get the CommandLine parameter

    OncommandLine = GetParameter(parametersKey, L"OnCommandLine");

    if ( OncommandLine == NULL ) {
        (GenCmdLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Resource create request but no Online command supplied.\n");
        OncommandLine = L"";
    }

    OffcommandLine = GetParameter(parametersKey, L"OffCommandLine");

    if ( OncommandLine == NULL ) {
        (GenCmdLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Resource create request but no Offline command supplied.\n");
        OncommandLine = L"";

    }

    // Get the CurrentDirectory parameter

    curDir = GetParameter(parametersKey, L"CurrentDirectory");

    if ( (curDir == NULL) ||
         (wcslen(curDir) == 0) ) {
        curDir = NULL;
    }

    //
    // Find a free index in the process info table for this new app.
    //

    EnterCriticalSection( &ProcessLock );

    for ( index = 1; index <= MAX_APPS; index++ ) {
        if ( ProcessInfo[index-1] == NULL ) {
            break;
        }
    }

    // Check if there was room in the process table.

    if ( index > MAX_APPS ) {
        LeaveCriticalSection( &ProcessLock );
        (GenCmdLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Too many applications to watch.\n");
        goto error_exit;
    }

    processInfo = LocalAlloc( LMEM_FIXED, sizeof(MY_PROCESS_INFORMATION) );

    if ( processInfo == NULL ) {
        LeaveCriticalSection( &ProcessLock );
        (GenCmdLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a process info structure.\n");
        goto error_exit;
    }

    ProcessInfo[index-1] = processInfo;


    LeaveCriticalSection( &ProcessLock );

    ZeroMemory( processInfo, sizeof(MY_PROCESS_INFORMATION) );

    processInfo->Index = index;
    processInfo->AppName = appName;
    processInfo->OnCommandLine = OncommandLine;
    processInfo->OffCommandLine = OffcommandLine;
    processInfo->CurDir = curDir;
    processInfo->ResourceHandle = ResourceHandle;

    appResid = (RESID)index;

error_exit:

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }

    if ( (appResid == 0) && (processInfo != NULL) ) {
        ProcessInfo[processInfo->Index] = NULL;
        LocalFree( processInfo );
    }

    return(appResid);

} // GenCmdOpen


DWORD
WINAPI
GenCmdOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Generic Application resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PMY_PROCESS_INFORMATION processInfo;
    DWORD   status = ERROR_SUCCESS;
    DWORD   index;
    SECURITY_ATTRIBUTES process = {0};
    SECURITY_ATTRIBUTES thread = {0};
    DWORD   create = 0;
    STARTUPINFO startupInfo = {0};

    startupInfo.cb = sizeof(STARTUPINFO);

    index = PtrToUlong(Resource) - 1;
    processInfo = ProcessInfo[index];

    if ( processInfo == NULL ) {
        GENCMD_PRINT("GenCmd: Online request for a nonexistent resource id %u.\n",
            PtrToUlong(Resource));
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( processInfo->Index != PtrToUlong(Resource) ) {
        (GenCmdLogEvent)(
            processInfo->ResourceHandle,
            LOG_ERROR,
            L"Online process index sanity checked failed! Index = %1!u!.\n",
            PtrToUlong(Resource));
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    (GenCmdLogEvent)(
        processInfo->ResourceHandle,
        LOG_ERROR,
        L"About to create process, cmd = %1!ws!.\n",
        processInfo->OnCommandLine);

    if ( !CreateProcess( processInfo->AppName,
                         processInfo->OnCommandLine,
                         &process,      // Process security attributes
                         &thread,       // Thread security attributes
                         FALSE,         // Don't inherit handles from us
                         create,        // Creation Flags
                         NULL,          // No environmet block
                         processInfo->CurDir,    // Current Directory
                         &startupInfo,  // Startup info
                         (PPROCESS_INFORMATION)processInfo ) ) {

        (GenCmdLogEvent)(
            processInfo->ResourceHandle,
            LOG_ERROR,
            L"Failed to create process. Error: %1!u!.\n",
            status = GetLastError() );
        return(status);
    }

    return(status);

} // GenCmdOnline


VOID
WINAPI
GenCmdTerminate(
    IN RESID Resource
    )

/*++

Routine Description:

    Terminate routine for Generic Application resource.

Arguments:

    Resource - supplies resource id to be terminated

Return Value:

    None.

--*/

{

 PMY_PROCESS_INFORMATION processInfo;
 DWORD   index;
 SECURITY_ATTRIBUTES process = {0};
 SECURITY_ATTRIBUTES thread = {0};
 DWORD   create = 0;
 STARTUPINFO startupInfo = {0};
 DWORD   errorCode;

 index = PtrToUlong(Resource) - 1;
 processInfo = ProcessInfo[index];

 if ( processInfo == NULL ) {
     GENCMD_PRINT("GenCmd: Offline request for a nonexistent resource id %u.\n",
         PtrToUlong(Resource));
     return;
 }

 if ( processInfo->Index != PtrToUlong(Resource) ) {
     (GenCmdLogEvent)(
        processInfo->ResourceHandle,
        LOG_ERROR,
        L"Offline process index sanity checked failed! Index = %1!u!.\n",
        PtrToUlong(Resource));
     return;
 }

 if ( !CreateProcess( processInfo->AppName,
                      processInfo->OffCommandLine,
                      &process,      // Process security attributes
                      &thread,       // Thread security attributes
                      FALSE,         // Don't inherit handles from us
                      create,        // Creation Flags
                      NULL,          // No environmet block
                      processInfo->CurDir,    // Current Directory
                      &startupInfo,  // Startup info
                      (PPROCESS_INFORMATION)processInfo ) ) {

     (GenCmdLogEvent)(
        processInfo->ResourceHandle,
        LOG_ERROR,
        L"Offline failed to create process. Error: %1!u!.\n",
        GetLastError() );
 }

} // GenCmdTerminate


DWORD
WINAPI
GenCmdOffline(
    IN RESID Resource
    )

/*++

Routine Description:

    Offline routine for Generic Command resource.

Arguments:

    Resource - supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    GenCmdTerminate( Resource );

    return(ERROR_SUCCESS);

} // GenCmdOffline


BOOL
WINAPI
GenCmdIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for Generice service resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Always, we just pretend everything is fine



--*/

{
    return(TRUE);

} // GenCmdIsAlive


BOOL
WINAPI
GenCmdLooksAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    LooksAlive routine for Generic Applications resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PMY_PROCESS_INFORMATION processInfo;
    DWORD index;


    index = PtrToUlong(Resource) - 1;
    processInfo = ProcessInfo[index];

    if ( processInfo == NULL ) {
        GENCMD_PRINT("GenCmd: Offline request for a nonexistent resource id %u.\n",
            PtrToUlong(Resource));
        return(FALSE);
    }

    return(TRUE);

} // GenCmdLooksAlive



VOID
WINAPI
GenCmdClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for Generic Applications resource.

Arguments:

    Resource - supplies resource id to be closed

Return Value:

    None.

--*/

{
    PMY_PROCESS_INFORMATION processInfo;
    DWORD   errorCode;
    DWORD   index;


    index = PtrToUlong(Resource) - 1;
    processInfo = ProcessInfo[index];

    if ( processInfo == NULL ) {
        GENCMD_PRINT("GenCmd: Close request for a nonexistent resource id %u\n",
            PtrToUlong(Resource));
        return;
    }

    if ( processInfo->Index != PtrToUlong(Resource) ) {
        (GenCmdLogEvent)(
            processInfo->ResourceHandle,
            LOG_ERROR,
            L"Close process index sanity check failed! Index = %1!u!.\n",
            PtrToUlong(Resource) );
        return;
    }

    (GenCmdLogEvent)(
        processInfo->ResourceHandle,
        LOG_INFORMATION,
        L"Close request for Process%1!d!.\n",
        PtrToUlong(Resource));

    ProcessInfo[index] = NULL;

    LocalFree( processInfo );

} // GenCmdClose


LPWSTR
GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )

/*++

Routine Description:

    Queries a REG_SZ parameter out of the registry and allocates the
    necessary storage for it.

Arguments:

    ClusterKey - Supplies the cluster key where the parameter is stored

    ValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter if successful.

    NULL if unsuccessful.

--*/

{
    LPWSTR Value;
    DWORD ValueLength;
    DWORD ValueType;
    DWORD Status;

    ValueLength = 0;
    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  NULL,
                                  &ValueLength);
    if ( (Status != ERROR_SUCCESS) &&
         (Status != ERROR_MORE_DATA) ) {
        SetLastError(Status);
        return(NULL);
    }
    if ( ValueType == REG_SZ ) {
        ValueLength += sizeof(UNICODE_NULL);
    }
    Value = LocalAlloc(LMEM_FIXED, ValueLength);
    if (Value == NULL) {
        return(NULL);
    }
    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  (LPBYTE)Value,
                                  &ValueLength);
    if (Status != ERROR_SUCCESS) {
        LocalFree(Value);
        SetLastError(Status);
        Value = NULL;
    }

    return(Value);
} // GetParameter


//***********************************************************
//
// Define Function Table
//
//***********************************************************


CLRES_V1_FUNCTION_TABLE( GenCmdFunctionTable,
                         CLRES_VERSION_V1_00,
                         GenCmd,
                         NULL,
                         NULL,
                         NULL,
                         NULL );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 - 2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.CPP
//
//  Description:
//      Implementation of a COM interface tracker.
//
//  [Documentation:]
//      Debugging.PPT - A power-point presentation of the debug utilities.
//
//  Maintained By:
//      Geoffrey Pease (gpease) 19-NOV-1999
//
//  Notes:
//      This is X86 specific for now. It can be adapted for other platforms
//      as required. Since today, most of our developement is done on the
//      X86 platform, there is not a need to do this.
//
//      Define NO_TRACE_INTERFACES to disable interface tracking in DEBUG
//      builds.
//
//      Define TRACE_INTERFACES_ENABLED to enable interface tracking in RETAIL
//      builds.
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <shlwapi.h>

#if defined( _X86_ )
///////////////////////////////////////
//
// BEGIN _X86_
//

#if defined( TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN TRACE_INTERFACES_ENABLED
//

//
// Globals
//
static IDeadObjTracker * g_pidoTracker = NULL;  // dead object - there is only one.

#ifndef NOISY_TRACE_INTERFACES
///////////////////////////////////////
//
// DEBUG !NOISY_TRACE_INTERFACES
//

//
// Undefining these macros to make the CITracker quiet.
//
#undef  TraceFunc     
#define TraceFunc       1 ? (void)0 : (void) 
#undef  TraceFunc1     
#define TraceFunc1       1 ? (void)0 : (void) 
#undef  TraceFunc2     
#define TraceFunc2       1 ? (void)0 : (void) 
#undef  TraceFunc3     
#define TraceFunc3       1 ? (void)0 : (void) 
#undef  TraceClsFunc     
#define TraceClsFunc    1 ? (void)0 : (void) 
#undef  TraceClsFunc1
#define TraceClsFunc1    1 ? (void)0 : (void) 
#undef  TraceClsFunc2     
#define TraceClsFunc2    1 ? (void)0 : (void) 
#undef  TraceClsFunc3
#define TraceClsFunc3    1 ? (void)0 : (void) 
#undef  TraceClsFunc4
#define TraceClsFunc4    1 ? (void)0 : (void) 
#undef  TraceClsFunc5
#define TraceClsFunc5    1 ? (void)0 : (void) 
#undef  TraceFuncExit
#define TraceFuncExit()
#undef  FRETURN
#define FRETURN( _u )
#undef  HRETURN
#define HRETURN(_hr)    return(_hr)
#undef  RETURN
#define RETURN(_fn)     return(_fn)  
#undef  RRETURN
#define RRETURN( _fn )  return(_fn)

//
// END !NOISY_TRACE_INTERFACES
//
///////////////////////////////////////
#endif // NOISY_TRACE_INTERFACES

#if defined( DEBUG )

//
// These are internal to debug.cpp but not published in debug.h.
//
BOOL
IsDebugFlagSet( 
    TRACEFLAG   tfIn
    );

void
DebugOutputString(
    LPCTSTR  pszIn
    );

void
DebugInitializeBuffer(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPTSTR      pszBufIn,
    INT *       pcchInout,
    LPTSTR *    ppszBufOut
    );

//////////////////////////////////////////////////////////////////////////////
//
// LPCTSTR
// DebugInterface(
//      REFIID      riidIn,
//      LPTSTR      pszBufOut
//      )
//
// Description:
//      Uses the Interface Tracking Table (g_itTable) to lookup a human 
//      readable name for the riidIn. If no matching interface is found. it
//      will use the pszBufOut to format a GUID string and return it.
//
// Arguments:
//      riidIn      - The interface ID to lookup.
//      pszBufOut   - Buffer to use if interface not found to format GUID.
//
// Return Value:
//      Never NULL. It will always a valid string pointer to either the
//      interface name or to pszBufOut.
//
// Notes:
//      pszBufOut must be at least cchGUID_STRING_SIZE in size.
//
//////////////////////////////////////////////////////////////////////////////
LPCTSTR
PszDebugFindInterface(
    REFIID      riidIn,
    LPTSTR      pszBufOut
    )
{
    if ( IsTraceFlagSet( mtfQUERYINTERFACE )
       )
    {
        int idx;

        for ( idx = 0; g_itTable[ idx ].riid != NULL; idx++ )
        {
            if ( riidIn == *g_itTable[ idx ].riid 
               )
            {
                return g_itTable[ idx ].pszName;

            } // if: found interface

        } // for: searching for interface

        wnsprintf( pszBufOut, 
                   cchGUID_STRING_SIZE, 
                   TEXT("{%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"),
                   riidIn.Data1, 
                   riidIn.Data2, 
                   riidIn.Data3,  
                   riidIn.Data4[0], 
                   riidIn.Data4[1], 
                   riidIn.Data4[2], 
                   riidIn.Data4[3], 
                   riidIn.Data4[4], 
                   riidIn.Data4[5], 
                   riidIn.Data4[6], 
                   riidIn.Data4[7]
                   );
    } // if: query interface is on
    else
    {
        return TEXT("riid");
    } // else: just print riid

    return pszBufOut;

} //*** DebugInterface( )
#endif // DEBUG

///////////////////////////////////////
//
// CITracker Definition
//
//

DEFINE_THISCLASS("CITracker");
#define THISCLASS CITracker
#define LPTHISCLASS CITracker*

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// Special new( ) for CITracker
//
// Description:
//      Creates an object the size of the object plus nExtraIn bytes. This
//      allows the Vtable that the CITracker object is tracking to be 
//      appended to the end of the CITracker object.
//
//////////////////////////////////////////////////////////////////////////////
#ifdef new
#undef new
#endif
void* 
__cdecl 
operator new( 
    unsigned int    nSizeIn,
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    UINT            nExtraIn,
    LPCTSTR         pszNameIn
    )
{
    HGLOBAL hGlobal = GlobalAlloc( GPTR, nSizeIn + nExtraIn );

    return TraceMemoryAdd( mmbtOBJECT, hGlobal, pszFileIn, nLineIn, pszModuleIn, GPTR, nSizeIn + nExtraIn, TEXT("CITracker") );

} //*** operator new( )

//////////////////////////////////////////////////////////////////////////////
//
// LPUNKNOWN
// DebugTrackInterface(
//      LPCTSTR     pszNameIn,
//      REFIID      riidIn,
//      LPUNKNOWN   punkIn,
//      LONG        cRefIn
//      )
//
// Description:
//      Create an interface tracker for the given interface.
//
// Arguments:
//      pszNameIn   - Name to associate with object that the punk references.
//      riidIn      - Interface IID of the interface to be tracked.
//      punkIn      - Interface pointer to track.
//      cRefIn      - Initialize ref count on the interface.
//
// Return Type:
//      On failure, this will be punkIn.
//      On success, pointer to an object that implements the interface to
//          be tracked.
//
//////////////////////////////////////////////////////////////////////////////
LPUNKNOWN
DebugTrackInterface(
    LPCTSTR   pszFileIn,
    const int nLineIn,
    LPCTSTR   pszModuleIn,
    LPCTSTR   pszNameIn,
    REFIID    riidIn,
    LPUNKNOWN punkIn,
    LONG      cRefIn
    )
{
    TraceFunc3( "DebugTrackInterface( ... pszNameIn = '%s', riidIn, punkIn = 0x%08x, cRefIn = %u )\n", 
                pszNameIn,
                punkIn,
                cRefIn
                );

    UINT      nEntry  = 0;
    LPUNKNOWN punkOut = punkIn;

    //
    // Scan the table looking for the matching interface definition.
    //
    for( nEntry = 0; g_itTable[ nEntry ].riid != NULL; nEntry++ )
    {
        if ( riidIn == *g_itTable[ nEntry ].riid )
        {
            //
            // Figure out how much "extra" to allocate onto the CITracker.
            //
            UINT nExtra = ( 3 + g_itTable[ nEntry ].cFunctions ) * sizeof(LPVOID);

            //
            // Create a name for the tracker.
            //
            // TODO:    gpease  19-NOV-1999
            //          Maybe merge this in with the nExtra(??).
            //
            LPTSTR psz;
            LPTSTR pszName = 
                (LPTSTR) LocalAlloc( LMEM_FIXED, 
                                     ( lstrlen( g_itTable[ nEntry ].pszName ) + lstrlen( pszNameIn ) + 3 + 2 ) * sizeof(TCHAR) );

            psz = StrCpy( pszName, pszNameIn );                 // object name
            psz = StrCat( psz, TEXT("::[") );                   // + 3
            psz = StrCat( psz, g_itTable[ nEntry ].pszName );   // + interface name
            psz = StrCat( psz, TEXT("]") );                     // + 2

            //
            // Create the tracker.
            //
            LPTHISCLASS pc = new( pszFileIn, nLineIn, pszModuleIn, nExtra, pszName ) THISCLASS( );
            if ( pc != NULL )
            {
                HRESULT hr;

                //
                // Initialize the tracker.
                //
                hr = THR( pc->Init( &punkOut, punkIn, &g_itTable[ nEntry ], pszName, cRefIn ) );
                if ( FAILED( hr ) )
                {
                    //
                    // If it failed, delete it.
                    //
                    delete pc;

                } // if: failed to initialize

            } // if: got memory
            
            break; // exit loop

        } // if: matched interface

    } // for: more entries in table

    RETURN( punkOut );

} //*** DebugTrackInterface( )

//////////////////////////////////////////////////////////////////////////////
//
// CITracker::CITracker( )
//
//////////////////////////////////////////////////////////////////////////////
THISCLASS::THISCLASS( )
{
    TraceClsFunc1( "%s()\n", __THISCLASS__ );

    //
    // KB: gpease 10-OCT-1998
    // This class will leak objects to help catch bad components
    // that call back into released interfaces therefore this
    // DLL will not be able to be released.
    //
	InterlockedIncrement( &g_cObjects );

    TraceFuncExit();
} //*** CITracker::ctor( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CITracker::Init(
//      LPUNKNOWN *                     ppunkOut, 
//      LPUNKNOWN                       punkIn, 
//      const INTERFACE_TABLE_ENTRY *   piteIn,
//      LPCTSTR                         pszNameIn,
//      BOOL                            fAddRefIn
//      )
//
// Description:
//      Initializes the CITracker object. It creates a copy of the VTable
//      of the interface to be tracked replacing the QI, AddRef and Release
//      methods with its own IUnknown. This allows CITracker to be "in the
//      loop" for those calls.
//
// Arguments:
//      ppunkOut    - The "punk" to be passed around.
//      punkIn      - The interface to be copied and tracked.
//      piteIn      - The interface table entry for the interface.
//      pszNameIn   - The name to be given to this CITracker.
//      fAddRefIn   - TRUE is the CITracker should start with a Ref Count of 1.
//
// Return Value:
//      S_OK        - Success.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
THISCLASS::Init(    
    LPUNKNOWN *                     ppunkOut, 
    LPUNKNOWN                       punkIn, 
    const INTERFACE_TABLE_ENTRY *   piteIn,
    LPCTSTR                         pszNameIn,
    LONG                            cRefIn
    )
{
    HRESULT hr = S_OK;

    TraceClsFunc5( "Init( ppunkOut = 0x%08x, punkIn = 0x%08x, iteIn = %s, pszNameIn = '%s', cRefIn = %u )\n", 
                   ppunkOut, 
                   punkIn, 
                   piteIn->pszName,
                   pszNameIn,
                   cRefIn
                   );

    //
    // Generate new Vtbls for each interface
    //
    LPVOID * pthisVtbl  = (LPVOID*) (IUnknownTracker *) this;
    LPVOID * ppthatVtbl = (LPVOID*) punkIn;
    DWORD    dwSize     = ( 3 + piteIn->cFunctions ) * sizeof(LPVOID);

    AssertMsg( dwSize < 30 * sizeof(LPVOID), "Need to make Dead Obj and IUnknownTracker larger!" );

    //
    // Interface tracking information initialization
    //
    m_vtbl.cRef         = cRefIn;
    m_vtbl.pszInterface = pszNameIn;
    m_vtbl.dwSize       = dwSize;

    //
    // Copy our IUnknownTracker vtbl to our "fix-up-able" vtbl
    //
    CopyMemory( &m_vtbl.lpfnQueryInterface, *pthisVtbl, dwSize );

    //
    // Remember the "punk" pointer so we can pass it back in when
    // we jump to the orginal objects IUnknown functions.
    //
    m_vtbl.punk = (LPUNKNOWN) punkIn;

    //
    // And finally, point the objects vtbl for this interface to
    // our newly created vtbl.
    //
    m_vtbl.pNewVtbl = (VTBL *) &m_vtbl.lpfnQueryInterface;
    *pthisVtbl      = m_vtbl.pNewVtbl;
    *ppunkOut       = (LPUNKNOWN) (IUnknownTracker *) this;

    TraceMsg( mtfCITRACKERS, L"TRACK: Tracking %s Interface (0x%08x)\n", m_vtbl.pszInterface, punkIn );

    HRETURN(hr);

} //*** CITracker::Init( )

//////////////////////////////////////////////////////////////////////////////
//
// CITracker::~CITracker( )
//
//////////////////////////////////////////////////////////////////////////////
THISCLASS::~THISCLASS( )
{
    TraceClsFunc2( "~%s() for %s\n", __THISCLASS__, m_vtbl.pszInterface );

    if ( m_vtbl.pszInterface != NULL )
    {
        LocalFree( (LPVOID) m_vtbl.pszInterface );
    } // if: have interface pointer

	InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CITracker::dtor( )

// ************************************************************************
//
// IUnknownTracker 
//
// ************************************************************************

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CITracker::QueryInterface()
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv 
    )
{
    TraceClsFunc1( "{%s} QueryInterface( ... )\n", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s QueryInterface( )\n", m_vtbl.pszInterface );

    //
    // Call the punk's QueryInterface( ).
    //
    HRESULT hr = m_vtbl.punk->QueryInterface( riid, ppv );

    //
    // KB:  TRACK_ALL_QIED_INTERFACES   gpease 25-NOV-1999
    //      Thinking out loud, should we track all interfaces QI'ed from
    //      a tracked interface auto-magically? If so, turn this #define
    //      on.
    //
    // #define TRACK_ALL_QIED_INTERFACES 
#if defined( TRACK_ALL_QIED_INTERFACES )
    if ( !IsEqualIID( riid, IID_IUnknown ) 
       )
    {
        *ppv = DebugTrackInterface( TEXT("<Unknown>"), 
                                    0, 
                                    __MODULE__, 
                                    m_vtbl.pszInterface, 
                                    riid, 
                                    (IUnknown*) *ppv, 
                                    TRUE 
                                    );
    } // if: not the IUnknown
#endif

    TraceMsg( mtfCITRACKERS, 
              "TRACK: V %s QueryInterface( ) [ *ppv = 0x%08x ]\n", 
              m_vtbl.pszInterface, 
              *ppv
              );

    HRETURN(hr);
} //** CITracker::QueryInterface( )

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CITracker::AddRef()
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc1( "{%s} AddRef( )\n", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s AddRef( )\n", m_vtbl.pszInterface );

    //
    // Call the punk's AddRef( ).
    //
    ULONG ul = m_vtbl.punk->AddRef( );

    //
    // Increment our counter.
    //
    ULONG ulvtbl = InterlockedIncrement( (LONG *) &m_vtbl.cRef );

    TraceMsg( mtfCITRACKERS, 
              "TRACK: V %s AddRef( ) [ I = %u, O = %u ]\n", 
              m_vtbl.pszInterface, 
              ulvtbl, 
              ul 
              );

    AssertMsg( ul >= ulvtbl, "The objects ref should be higher than the interfaces." );

    RETURN(ul);
} //*** CITracker::AddRef( )

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CITracker::Release()
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc1( "{%s} Release( )\n", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s Release( )\n", m_vtbl.pszInterface );

    //
    // Call the punk's Release( ).
    //
    ULONG ul = m_vtbl.punk->Release( );    

    //
    // Decrement our counter.
    //
    ULONG ulvtbl = InterlockedDecrement( (LONG *) &m_vtbl.cRef );

    TraceMsg( mtfCITRACKERS, 
              "TRACK: V %s Release( ) [ I = %u, O = %u ]\n", 
              m_vtbl.pszInterface, 
              ulvtbl, 
              ul 
              );

    //
    // Our ref count should always be less than the punk's ref count.
    //
    AssertMsg( ul >= ulvtbl, "The objects ref should be higher than the interfaces." );

    if ( ulvtbl ) 
    {
        RETURN( ulvtbl );
    } // if: we still have a ref

    if ( g_pidoTracker == NULL )
    {
        //
        // Create a dead object - if more than one is created at a time, we might leak it.
        //
        // TODO:    gpease 19-NOV-1999
        //          Work on not leaking "extra" dead objects.
        //
        g_pidoTracker = new( TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT("Dead Object") ) IDeadObjTracker( );

        // Don't track this object
        TraceMemoryDelete( g_pidoTracker, FALSE );

    } // if: no dead object

    Assert( g_pidoTracker != NULL );
    if ( g_pidoTracker != NULL )
    {
        LPVOID *pthisVtbl  = (LPVOID*) (IUnknownTracker *) this;
        LPVOID *ppthatVtbl = (LPVOID*) (IDeadObjTracker *) g_pidoTracker;

        // Copy the DeadObj vtbl.
        CopyMemory( &m_vtbl.lpfnQueryInterface, *ppthatVtbl, m_vtbl.dwSize );

        //
        // Don't really delete it, but fake the debug output as if we did.
        //
        TraceClsFunc2( "~%s() for %s\n", __THISCLASS__, m_vtbl.pszInterface );
        TraceMsg( mtfCITRACKERS, "TRACK: # %s set to dead object [ punk = 0x%08x ]\n", m_vtbl.pszInterface, pthisVtbl );
        FRETURN( 0 );

        // Stop tracking this object.
        TraceMemoryDelete( this, FALSE );

    } // if: dead object created
    else
    {
        //
        // No dead object; nuke ourselves. This will at least cause an AV if
        // the program tries to call on our interface alerting the programmer 
        // that somethings wrong.
        //
        delete this;

    } // else: no dead object

    RETURN(0);

} //*** CITracker::Release( )

//****************************************************************************
//
// IDeadObjTracker - The dead interface object tracker.
//
// This object is shunted into release interfaces that were being tracked by
// the CITracker class. Any calls to a released interface will end up causing
// an Assert and if execution continues it will return E_FAIL.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// IDeadObjTracker:Stub(x)
//
//////////////////////////////////////////////////////////////////////////////
#define IDeadObjTrackerStub( i ) \
STDMETHODIMP \
IDeadObjTracker::Stub##i( LPVOID* punk ) \
{ \
    const int   cchDebugMessageSize = 255; \
    TCHAR       szMessage[ cchDebugMessageSize ]; \
    LRESULT     lResult;\
    \
    DebugMsg( "*ERROR* %s: Entered %s (0x%08x) after it was released. Returning E_FAIL.\n", \
              __MODULE__, \
              m_vtbl.pszInterface, \
              this \
              ); \
\
    wnsprintf( szMessage, \
               cchDebugMessageSize, \
               TEXT("Entered %s (0x%08x) after it was released.\n\nDo you want to break here?\n\n(If you do not break, E_FAIL will be returned.)"), \
               m_vtbl.pszInterface, \
               this \
               );\
\
    lResult = MessageBox( NULL, szMessage, TEXT("Dead Interface"), MB_YESNO | MB_ICONWARNING );\
    if ( lResult == IDYES \
       ) \
    { \
        DEBUG_BREAK; \
    } \
\
    return E_FAIL; \
}

IDeadObjTrackerStub(0);
IDeadObjTrackerStub(1);
IDeadObjTrackerStub(2);
IDeadObjTrackerStub(3);
IDeadObjTrackerStub(4);
IDeadObjTrackerStub(5);
IDeadObjTrackerStub(6);
IDeadObjTrackerStub(7);
IDeadObjTrackerStub(8);
IDeadObjTrackerStub(9);
IDeadObjTrackerStub(10);
IDeadObjTrackerStub(11);
IDeadObjTrackerStub(12);
IDeadObjTrackerStub(13);
IDeadObjTrackerStub(14);
IDeadObjTrackerStub(15);
IDeadObjTrackerStub(16);
IDeadObjTrackerStub(17);
IDeadObjTrackerStub(18);
IDeadObjTrackerStub(19);
IDeadObjTrackerStub(20);
IDeadObjTrackerStub(21);
IDeadObjTrackerStub(22);
IDeadObjTrackerStub(23);
IDeadObjTrackerStub(24);
IDeadObjTrackerStub(25);
IDeadObjTrackerStub(26);
IDeadObjTrackerStub(27);
IDeadObjTrackerStub(28);
IDeadObjTrackerStub(29);
IDeadObjTrackerStub(30);

//****************************************************************************
//
// IUnknownTracker stub
//
// This merely directs the incoming call back to the orginal object. The
// IUnknown methods will be remapped the the CITracker methods.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// IUnknownTracker::QueryInterface()
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
IUnknownTracker::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    ErrorMsg( "IUnknownTracker::QueryInterface( ): How did you get here?\n", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return E_FAIL;
} //*** IUnknownTracker::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// IUnknownTracker::AddRef()
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
IUnknownTracker::AddRef( void )
{
    ErrorMsg( "IUnknownTracker::AddRef( ): How did you get here?\n", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return -1;
} //*** IUnknownTracker::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// IUnknownTracker::Release()
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
IUnknownTracker::Release( void )
{
    ErrorMsg( "IUnknownTracker::Release( ): How did you get here?\n", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return -1;
} //*** IUnknownTracker::Release( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(void)
// IUnknownTracker::Stub(x)
//
// These are just stubs to redirect the call to the "real" method on the punk.
// We actually dissappear from the call stack.
// 
//////////////////////////////////////////////////////////////////////////////
#define IUnknownTrackerStub( i ) \
void \
_declspec(naked) \
IUnknownTracker::Stub##i() \
{ \
    _asm mov eax, ss:4[esp]          \
    _asm mov ecx, 8[eax]             \
    _asm mov eax, [ecx]              \
    _asm mov ss:4[esp], ecx          \
    _asm jmp dword ptr cs:(4*i)[eax] \
}

IUnknownTrackerStub(3);
IUnknownTrackerStub(4);
IUnknownTrackerStub(5);
IUnknownTrackerStub(6);
IUnknownTrackerStub(7);
IUnknownTrackerStub(8);
IUnknownTrackerStub(9);
IUnknownTrackerStub(10);
IUnknownTrackerStub(11);
IUnknownTrackerStub(12);
IUnknownTrackerStub(13);
IUnknownTrackerStub(14);
IUnknownTrackerStub(15);
IUnknownTrackerStub(16);
IUnknownTrackerStub(17);
IUnknownTrackerStub(18);
IUnknownTrackerStub(19);
IUnknownTrackerStub(20);
IUnknownTrackerStub(21);
IUnknownTrackerStub(22);
IUnknownTrackerStub(23);
IUnknownTrackerStub(24);
IUnknownTrackerStub(25);
IUnknownTrackerStub(26);
IUnknownTrackerStub(27);
IUnknownTrackerStub(28);
IUnknownTrackerStub(29);
IUnknownTrackerStub(30);


//
// END TRACE_INTERFACES_ENABLED
//
///////////////////////////////////////
#endif // TRACE_INTERFACES_ENABLED

//
// END _X86_
//
///////////////////////////////////////
#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\genscript.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CFactory.h
//
//  Description:
//      Class Factory implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#define CCH(sz)     (sizeof(sz)/sizeof(sz[0]))

//
// DLL Globals
//
extern HINSTANCE g_hInstance;
extern LONG      g_cObjects;
extern LONG      g_cLock;
extern TCHAR     g_szDllFilename[ MAX_PATH ];

extern LPVOID    g_GlobalMemoryList;            // Global memory tracking list

#define DllExport   __declspec( dllimport )

#define SCRIPTRES_RESTYPE_NAME                  L"ScriptRes"

//
// Class Definitions for DLLGetClassObject
//
typedef LPUNKNOWN (*LPCREATEINST)();

typedef struct _ClassTable {
    LPCREATEINST    pfnCreateInstance;  // creation function for class
    const CLSID *   rclsid;             // classes in this DLL
    LPCTSTR         pszName;            // Class name for debugging
    LPCTSTR         pszComModel;        // String indicating COM threading model
} CLASSTABLE[], *LPCLASSTABLE;

//
// Class Table Macros
//
#define BEGIN_CLASSTABLE const CLASSTABLE g_DllClasses = {
#define DEFINE_CLASS( _pfn, _riid, _name, _model ) { _pfn, &_riid, TEXT(_name), TEXT(_model) },
#define END_CLASSTABLE  { NULL, NULL, NULL, NULL } };
extern const CLASSTABLE  g_DllClasses;

//
// DLL required headers
//
#include "debug.h"          // debugging
#include "citracker.h"

#if defined( _X86_ ) && defined( TRACE_INTERFACES_ENABLED )
//
// DLL Interface Table Macros
//
#define BEGIN_INTERFACETABLE const INTERFACE_TABLE g_itTable = {
#define DEFINE_INTERFACE( _iid, _name, _count ) { &_iid, TEXT(_name), _count },
#define END_INTERFACETABLE { NULL, NULL, NULL } };
#else   // !TRACE_INTERFACES_ENABLED
#define BEGIN_INTERFACETABLE
#define DEFINE_INTERFACE( _iid, _name, _count )
#define END_INTERFACETABLE
#endif  // TRACE_INTERFACES_ENABLED

//
// DLL Useful Macros
//
#define ARRAYSIZE( _x ) ((UINT) ( sizeof( _x ) / sizeof( _x[ 0 ] ) ))
#define PtrToByteOffset(base, offset)   (((LPBYTE)base)+offset)
#define StrLen( _sz ) lstrlen( _sz )    // why isn't this in SHLWAPI?

//
// COM Macros to gain type checking.
//
#define TypeSafeParams( _interface, _ppunk ) \
    IID_##_interface, reinterpret_cast<void**>( static_cast<_interface **>( _ppunk ) )
#define TypeSafeQI( _interface, _ppunk ) \
    QueryInterface( TypeSafeParams( _interface, _ppunk ) )
#define TypeSafeQS( _clsid, _interface, _ppunk ) \
    QueryService( _clsid, TypeSafeParams( _interface, _ppunk ) )

//
// DLL Global Function Prototypes
//
HRESULT
HrClusCoCreateInstance(
    REFCLSID rclsidIn,
    LPUNKNOWN pUnkOuterIn,
    DWORD dwClsContextIn,
    REFIID riidIn,
    LPVOID * ppvOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\guids.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Guids.cpp
//
//  Description:
//      Guids definition instantiation and DEBUG interface table definitions.
//
//  Maintained By:
//      gpease 08-FEB-1999
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>

#undef _GUIDS_H_
#include "guids.h"

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map a name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out
// a runtime or compile time way to do this). To improve speed, put the most
// used interfaces first such as IUnknown (the search routine is a simple
// linear search).
//
BEGIN_INTERFACETABLE
    // most used interfaces
DEFINE_INTERFACE( IID_IUnknown,                 "IUnknown",                 0   )
DEFINE_INTERFACE( IID_IDispatch,                "IDispatch",                4   )
DEFINE_INTERFACE( IID_IDispatchEx,              "IDispatchEx",              12  )
DEFINE_INTERFACE( IID_IActiveScript,            "IActiveScript",            13  )
DEFINE_INTERFACE( IID_IActiveScriptSite,        "IActiveScriptSite",        8   )
DEFINE_INTERFACE( IID_IActiveScriptParse,       "IActiveScriptParse",       3   )
DEFINE_INTERFACE( IID_IActiveScriptError,       "IActiveScriptError",       3   )
DEFINE_INTERFACE( IID_IActiveScriptSiteWindow,  "IActiveScriptSiteWindow",  2   )
END_INTERFACETABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\citracker.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 - 2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.H
//
//  Description:
//      Implementation of a COM interface tracker.
//
//  [Documentation:]
//      Debugging.PPT - A power-point presentation of the debug utilities.
//
//  Maintained By:
//      Geoffrey Pease (gpease) 19-NOV-1999
//
//  Notes:
//      This is X86 specific for now. It can be adapted for other platforms
//      as required. Since today, most of our developement is done on the
//      X86 platform, there is not a need to do this (yet).
//
//      Define NO_TRACE_INTERFACES to disable interface tracking in DEBUG
//      builds.
//
//      Define TRACE_INTERFACES_ENABLED to enable interface tracking in RETAIL
//      builds.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// Combine this complex expression in to one simple #define.
//
#if ( DBG==1 || defined( _DEBUG ) ) && !defined( NO_TRACE_INTERFACES )
#define TRACE_INTERFACES_ENABLED
#endif

#if defined( _X86_ )
///////////////////////////////////////
//
// BEGIN _X86_
//

#if defined( TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//
#pragma message("BUILD: Interface Tracking Enabled")

///////////////////////////////////////
//
// TraceInterface definitions
//
typedef struct {
    const struct _GUID *    riid;
    LPCTSTR                 pszName;
    ULONG                   cFunctions;
} INTERFACE_TABLE[], INTERFACE_TABLE_ENTRY, * LPINTERFACE_TABLE_ENTRY;

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map an name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out 
// a runtime or compile time way to do this).
// 
extern const INTERFACE_TABLE g_itTable;

//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// _interface *
// TraceInterface(
//      _nameIn,
//      _interface,
//      _punkIn,
//      _addrefIn
//      )
//
// Description:
//      This is the macro wrapper for DebugTrackInterface( ) which is only
//      defined in DEBUG builds. Using the TraceInterface( ) macro eliminates
//      the need for specifying compile time parameters as well as the
//      #ifdef/#endif definitions around the call.
//
//      This "routine" creates a CITracker for the interface specified by
//      _interface and returns a new punk to the interface. You specify the
//      initial ref count on the interface using the _addrefIn parameter. You
//      can assign a name to the object that the interface refereneces in the
//      _nameIn parameter. The returned punk will be cast to the _interface
//      parameter.
//
//      If there is insufficent memory to create the CITracker, the _punkIn
//      will be returned instead. There is no need to check the output for
//      failures as they are all handle internally to provide worry-free use.
//
//      If you are getting an AV after adding tracing to the interface, this
//      usually indicates that the Interface Table entry for that interface
//      is incorrect. Double check the number of methods on the interface
//      against the tables.
//
// Arguments:
//      _nameIn     - Name of the object this interface references (string).
//      _interface  - Name of the interface (typedef).
//      _punkIn     - Pointer to interface to track
//      _addrefIn   - Initial reference count on the interface.
//
// Return Values:
//      a VALID _interface pointer
//          Points to the CITracker that can be used as if it were the
//          orginal _punkIn. If there was insufficent memory, the orginal
//          _punkIn will be returned.
//
//  NOTES:
//      _addrefIn should be 0 if your going to be giving out the interface 
//      from your QueryInterface routine if you AddRef( ) before giving it 
//      out (typical QueryInterface( ) routines do this ).
//
//////////////////////////////////////////////////////////////////////////////
#define  TraceInterface( _nameIn, _interface, _punkIn, _addrefIn ) \
    reinterpret_cast<_interface*>( \
        DebugTrackInterface( TEXT(__FILE__), \
                             __LINE__, \
                             __MODULE__, \
                             _nameIn, \
                             IID_##_interface, \
                             static_cast<_interface*>( _punkIn), \
                             _addrefIn \
                             ) )

///////////////////////////////////////
//
// IID --> Name lookup stuff
//
#if defined( DEBUG )
static const cchGUID_STRING_SIZE = sizeof("{12345678-1234-1234-1234-123456789012}");

#define PszTraceFindInterface( _riid, _szguid ) \
    ( g_tfModule ? PszDebugFindInterface( _riid, _szguid ) : TEXT("riid") )

LPCTSTR
PszDebugFindInterface(
    REFIID      riidIn,
    LPTSTR      pszGuidBufOut
    );
#endif // DEBUG

///////////////////////////////////////
//
// CITracker Structures
//
typedef HRESULT (CALLBACK *LPFNQUERYINTERFACE)(
    LPUNKNOWN punk, 
    REFIID    riid, 
    LPVOID*   ppv );

typedef ULONG (CALLBACK *LPFNADDREF)(
    LPUNKNOWN punk );

typedef ULONG (CALLBACK *LPFNRELEASE)( 
    LPUNKNOWN punk );

typedef struct __vtbl {
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
} VTBL, *LPVTBL;

typedef struct __vtbl2 {
    ULONG              cRef;
    LPUNKNOWN          punk;
    LPCTSTR            pszInterface;
    DWORD              dwSize;
    LPVTBL             pNewVtbl;
    // These must be last and in this order: QI, AddRef, Release.
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
    // additional vtbl entries hang off the end
} VTBL2, *LPVTBL2;

#define VTBL2OFFSET ( sizeof( VTBL2 ) - ( 3 * sizeof(LPVOID) ) )

///////////////////////////////////////
//
// CITracker Functions
//
LPUNKNOWN
DebugTrackInterface(
    LPCTSTR   pszFileIn,
    const int nLineIn,
    LPCTSTR   pszModuleIn,
    LPCTSTR   pszNameIn,
    REFIID    riidIn,
    LPUNKNOWN pvtblIn,
    LONG      cRefIn
    );
    
///////////////////////////////////////
//
// interface IUnknownTracker
//
//
class
IUnknownTracker :
    public IUnknown
{
public:
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)( void );
    STDMETHOD_(ULONG, Release)( void );
    STDMETHOD_(void, Stub3 )( void );
    STDMETHOD_(void, Stub4 )( void );
    STDMETHOD_(void, Stub5 )( void );
    STDMETHOD_(void, Stub6 )( void );
    STDMETHOD_(void, Stub7 )( void );
    STDMETHOD_(void, Stub8 )( void );
    STDMETHOD_(void, Stub9 )( void );
    STDMETHOD_(void, Stub10 )( void );
    STDMETHOD_(void, Stub11 )( void );
    STDMETHOD_(void, Stub12 )( void );
    STDMETHOD_(void, Stub13 )( void );
    STDMETHOD_(void, Stub14 )( void );
    STDMETHOD_(void, Stub15 )( void );
    STDMETHOD_(void, Stub16 )( void );
    STDMETHOD_(void, Stub17 )( void );
    STDMETHOD_(void, Stub18 )( void );
    STDMETHOD_(void, Stub19 )( void );
    STDMETHOD_(void, Stub20 )( void );
    STDMETHOD_(void, Stub21 )( void );
    STDMETHOD_(void, Stub22 )( void );
    STDMETHOD_(void, Stub23 )( void );
    STDMETHOD_(void, Stub24 )( void );
    STDMETHOD_(void, Stub25 )( void );
    STDMETHOD_(void, Stub26 )( void );
    STDMETHOD_(void, Stub27 )( void );
    STDMETHOD_(void, Stub28 )( void );
    STDMETHOD_(void, Stub29 )( void );
    STDMETHOD_(void, Stub30 )( void );

}; //*** interface IUnknownTracker

///////////////////////////////////////
//
// interface IDeadObjTracker
//
class
IDeadObjTracker
{
private: // Members
    VTBL2 m_vtbl;

public:
    STDMETHOD( Stub0 )( LPVOID* punk );
    STDMETHOD( Stub1 )( LPVOID* punk );
    STDMETHOD( Stub2 )( LPVOID* punk );
    STDMETHOD( Stub3 )( LPVOID* punk );
    STDMETHOD( Stub4 )( LPVOID* punk );
    STDMETHOD( Stub5 )( LPVOID* punk );
    STDMETHOD( Stub6 )( LPVOID* punk );
    STDMETHOD( Stub7 )( LPVOID* punk );
    STDMETHOD( Stub8 )( LPVOID* punk );
    STDMETHOD( Stub9 )( LPVOID* punk );
    STDMETHOD( Stub10 )( LPVOID* punk );
    STDMETHOD( Stub11 )( LPVOID* punk );
    STDMETHOD( Stub12 )( LPVOID* punk );
    STDMETHOD( Stub13 )( LPVOID* punk );
    STDMETHOD( Stub14 )( LPVOID* punk );
    STDMETHOD( Stub15 )( LPVOID* punk );
    STDMETHOD( Stub16 )( LPVOID* punk );
    STDMETHOD( Stub17 )( LPVOID* punk );
    STDMETHOD( Stub18 )( LPVOID* punk );
    STDMETHOD( Stub19 )( LPVOID* punk );
    STDMETHOD( Stub20 )( LPVOID* punk );
    STDMETHOD( Stub21 )( LPVOID* punk );
    STDMETHOD( Stub22 )( LPVOID* punk );
    STDMETHOD( Stub23 )( LPVOID* punk );
    STDMETHOD( Stub24 )( LPVOID* punk );
    STDMETHOD( Stub25 )( LPVOID* punk );
    STDMETHOD( Stub26 )( LPVOID* punk );
    STDMETHOD( Stub27 )( LPVOID* punk );
    STDMETHOD( Stub28 )( LPVOID* punk );
    STDMETHOD( Stub29 )( LPVOID* punk );
    STDMETHOD( Stub30 )( LPVOID* punk );

}; //*** interface IDeadObject


///////////////////////////////////////
//
// CITracker Class
//
class
CITracker:
    public IUnknownTracker
{
private: // Members
    VTBL2 m_vtbl;

private: // Methods
    CITracker( );
    ~CITracker( );
    STDMETHOD(Init)( LPUNKNOWN * ppunkOut, 
                     LPUNKNOWN punkIn, 
                     const INTERFACE_TABLE_ENTRY * piteIn, 
                     LPCTSTR pszNameIn, 
                     LONG cRefIn 
                     );

public: // Methods
    friend LPUNKNOWN DebugTrackInterface( LPCTSTR    pszFileIn,
                                          const int  nLineIn,
                                          LPCTSTR    pszModuleIn,
                                          LPCTSTR    pszNameIn, 
                                          REFIID     riidIn, 
                                          LPUNKNOWN  pvtblIn, 
                                          LONG      cRefIn
                                          );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

}; //*** class CITracker

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#else // !TRACE_INTERFACES_ENABLED
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT INTERFACE TRACKING
//

#define  TraceInterface( _nameIn, _interface, _punkIn, _faddrefIn ) static_cast<##_interface *>( _punkIn );
#define  PszDebugFindInterface( _riid, _szGuid ) L"<unknown>"

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#endif // TRACE_INTERFACES_ENABLED

//
// END _X86_
//
///////////////////////////////////////
#else   // !_X86_
///////////////////////////////////////
//
// BEGIN !_X86_
//

#define  TraceInterface( _nameIn, _riidIn, _punkIn, _faddrefIn ) _punkIn
#define  PszDebugFindInterface( _riid, _szGuid ) L"<unknown>"
//
// END !_X86_
//
///////////////////////////////////////
#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Debugging utilities.
//
//  Documentation:
//      Spec\Admin\Debugging.ppt
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <shlwapi.h>

//
// Why aren't these in SHLWAPI?
//
#if ! defined( StrLen )
#define StrLen( _sz ) lstrlen( _sz )
#endif // ! defined( StrLen )
#if ! defined( StrLenA )
#define StrLenA( _sz ) lstrlenA( _sz )
#endif // ! defined( StrLenA )
#if ! defined( StrLenW )
#define StrLenW( _sz ) lstrlenW( _sz )
#endif // ! defined( StrLenW )

#if defined( DEBUG )
//
// Include the WINERROR, HRESULT and NTSTATUS codes
//
#include <winerror.dbg>
//#include <ntstatus.dbg>

//
// Constants
//
static const int cchDEBUG_OUTPUT_BUFFER_SIZE = 512;
static const int cchFILEPATHLINESIZE         = 85;

//
// Globals
//
DWORD       g_TraceMemoryIndex = -1;
DWORD       g_TraceFlagsIndex  = -1;
DWORD       g_ThreadCounter    = 0;
DWORD       g_dwCounter        = 0;
TRACEFLAG   g_tfModule         = mtfNEVER;
LONG        g_lDebugSpinLock   = FALSE;

//
// Strings
// 
static const TCHAR g_szNULL[]       = TEXT("");
static const TCHAR g_szTrue[]       = TEXT("True");
static const TCHAR g_szFalse[]      = TEXT("False");
static const TCHAR g_szFileLine[]   = TEXT("%s(%u):");
static const TCHAR g_szFormat[]     = TEXT("%-60s  %-10.10s ");
static const TCHAR g_szUnknown[]    = TEXT("<unknown>");


//
// ImageHlp Stuff - not ready for prime time yet.
//
#if defined(IMAGEHLP_ENABLED)
//
// ImageHelp
//
typedef VOID (*PFNRTLGETCALLERSADDRESS)(PVOID*,PVOID*);

HINSTANCE                g_hImageHlp                = NULL;
PFNSYMGETSYMFROMADDR     g_pfnSymGetSymFromAddr     = NULL;
PFNSYMGETLINEFROMADDR    g_pfnSymGetLineFromAddr    = NULL;
PFNSYMGETMODULEINFO      g_pfnSymGetModuleInfo      = NULL;
PFNRTLGETCALLERSADDRESS  g_pfnRtlGetCallersAddress  = NULL;
#endif // IMAGEHLP_ENABLED

//
// Per thread structure.
//
typedef struct _SPERTHREADDEBUG {
    DWORD   dwFlags;
    DWORD   dwStackCounter;
} SPerThreadDebug;




//****************************************************************************
//
//  WMI Tracing Routines
//
//  These routines are only in the DEBUG version.
//
//****************************************************************************











//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugDumpWMITraceFlags(
//      DEBUG_WMI_CONTROL_GUIDS * pdwcgIn
//      )
//
//  Description:
//      Dumps the currently set flags.
//
//  Arguments:
//      pdwcgIn     - Pointer to the DEBUG_WMI_CONTROL_GUIDS to explore.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugDumpWMITraceFlags(
    DEBUG_WMI_CONTROL_GUIDS * pdwcgIn
    )
{
    DWORD      dwFlag;
    signed int nCount;

    if ( pdwcgIn->pMapFlagsToComments == NULL )
    {
        DebugMsg( "DEBUG:        no flag mappings available.\n" );
        return; // NOP
    } // if: no mapping table

    dwFlag = 0x80000000;
    for ( nCount = 31; nCount >= 0; nCount-- )
    {
        if ( pdwcgIn->dwFlags & dwFlag )
        {
            DebugMsg( "DEBUG:       0x%08x = %s\n", 
                      dwFlag, 
                      ( pdwcgIn->pMapFlagsToComments[ nCount ].pszName != NULL ? pdwcgIn->pMapFlagsToComments[ nCount ].pszName : g_szUnknown ) 
                      );

        } // if: flag set

        dwFlag = dwFlag >> 1;

    } // for: nCount

} //*** DebugDumpWMITraceFlags( )











//****************************************************************************
//
//  Debugging and Tracing Routines
//
//****************************************************************************














//////////////////////////////////////////////////////////////////////////////
//
// void 
// DebugIncrementStackDepthCounter( void )
//
// Description:
//      Increases the stack scope depth counter. If "per thread" tracking is
//      on it will increment the "per thread" counter. Otherwise, it will
//      increment the "global" counter.
//
// Arguments:
//      None.
//
// Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////////////
void 
DebugIncrementStackDepthCounter( void )
{
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            ptd->dwStackCounter++;
        } // if: ptd
    } // if: per thread
    else
    {
        InterlockedIncrement( (LONG*) &g_dwCounter );
    } // else: global

} // DebugIncrementStackDepthCounter( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugDecrementStackDepthCounter( void )
//
//  Description:
//      Decreases the stack scope depth counter. If "per thread" tracking is
//      on it will decrement the "per thread" counter. Otherwise, it will
//      decrement the "global" counter.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugDecrementStackDepthCounter( void )
{
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            ptd->dwStackCounter--;
        } // if: ptd
    } // if: per thread
    else
    {
        InterlockedDecrement( (LONG*) &g_dwCounter );
    } // else: global

} // DebugDecrementStackDepthCounter( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugAcquireSpinLock(
//      LONG * pLock
//      )
//
//  Description:
//      Acquires the spin lock pointed to by pLock.
//
//  Arguments:
//      pLock   - Pointer to the spin lock.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugAcquireSpinLock(
    LONG * pLock
    )
{
    for(;;)
    {
        LONG lInitialValue;

        lInitialValue = InterlockedCompareExchange( pLock, TRUE, FALSE );
        if ( lInitialValue == FALSE )
        {
            //
            // Lock acquired.
            //
            break;
        } // if: got lock
        else
        {
            //
            // Sleep to give other thread a chance to give up the lock.
            //
            Sleep( 1 );
        } // if: lock not acquired

    } // for: forever

} // DebugAcquireSpinLock( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugReleaseSpinLock(
//      LONG * pLock
//      )
//
//  Description:
//      Releases the spin lock pointer to by pLock.
//
//  Arguments:
//      pLock       - Pointer to the spin lock.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugReleaseSpinLock(
    LONG * pLock
    )
{
    *pLock = FALSE;

} // DebugReleaseSpinLock( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  IsDebugFlagSet(
//      TRACEFLAG   tfIn
//      )
//
//  Description:
//      Checks the global g_tfModule and the "per thread" Trace Flags to
//      determine if the flag (any of the flags) are turned on.
//
//  Arguments:
//      tfIn        - Trace flags to compare.
//
//  Return Values:
//      TRUE        At least of one of the flags are present.
//      FALSE       None of the flags match.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    )
{
    if ( g_tfModule & tfIn )
    {
        return TRUE;
    } // if: global flag set

    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL
          && ptd->dwFlags & tfIn
           )
        {
            return TRUE;
        }   // if: per thread flag set

    } // if: per thread settings

    return FALSE;

} //*** IsDebugFlagSet( )
    
//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugOutputString(
//      LPCTSTR  pszIn
//      )
//
//  Description:
//      Dumps the spew to the appropriate orafice.
//
//  Arguments:
//      pszIn       Message to dump.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugOutputString(
    LPCTSTR  pszIn
    )
{
    if ( IsTraceFlagSet( mtfOUTPUTTODISK ) )
    {
        LogMsg( pszIn );
    } // if: log to file
    else
    {
        DebugAcquireSpinLock( &g_lDebugSpinLock );
        OutputDebugString( pszIn );
        DebugReleaseSpinLock( &g_lDebugSpinLock );
    } // else: debugger

} //*** DebugOutputString( )

#if 0
/*
//////////////////////////////////////////////////////////////////////////////
//++
//  void
//  DebugFindNTStatusSymbolicName( 
//      DWORD   dwStatusIn,
//      LPTSTR  pszNameOut,
//      LPDWORD pcchNameInout
//  )
//
//  Description:
//      Uses the NTBUILD generated ntstatusSymbolicNames table to lookup
//      the symbolic name for the status code. The name will be returned in
//      pszNameOut. pcchNameInout should indicate the size of the buffer that
//      pszNameOut points too. pcchNameInout will return the number of 
//      characters copied out.
//
//  Arguments:
//      dwStatusIn    - Status code to lookup.
//      pszNameOut    - Buffer to store the string name
//      pcchNameInout - The length of the buffer in and the size out.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugFindNTStatusSymbolicName(
    NTSTATUS dwStatusIn,
    LPTSTR   pszNameOut,
    LPDWORD  pcchNameInout
    )
{
    Assert( pszNameOut != NULL );
    Assert( pcchNameInout != NULL );
    int idx = 0;

    while ( ntstatusSymbolicNames[ idx ].SymbolicName 
          ) 
    {
        if ( ntstatusSymbolicNames[ idx ].MessageId == dwStatusIn
           ) 
        {
#if defined ( UNICODE )
            *pcchNameInout = mbstowcs( pszNameOut, ntstatusSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            Assert( *pcchNameInout != -1 );
#else // ASCII
            StrCpyN( pszNameOut, ntstatusSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            *pcchNameInout = StrLen( pszNameOut );
#endif // UNICODE
            return;

        } // if: matched

        idx++;

    } // while: entries in list

    //
    // If we made it here, we did not find an entry.
    //
    StrCpyN( pszNameOut, TEXT("<unknown>"), *pcchNameInout );
    *pcchNameInout = StrLen( pszNameOut );
    return;

} //*** DebugFindNTStatusSymbolicName( )
*/
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//  void
//  DebugFindWinerrorSymbolicName( 
//      DWORD   dwErrIn,
//      LPTSTR  pszNameOut,
//      LPDWORD pcchNameInout
//  )
//
//  Description:
//      Uses the NTBUILD generated winerrorSymbolicNames table to lookup
//      the symbolic name for the error code. The name will be returned in
//      pszNameOut. pcchNameInout should indicate the size of the buffer that
//      pszNameOut points too. pcchNameInout will return the number of 
//      characters copied out.
//
//  Arguments:
//      dwErrIn       - Error code to lookup.
//      pszNameOut    - Buffer to store the string name
//      pcchNameInout - The length of the buffer in and the size out.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugFindWinerrorSymbolicName(
    DWORD dwErrIn,
    LPTSTR  pszNameOut,
    LPDWORD pcchNameInout
    )
{
    Assert( pszNameOut != NULL );
    Assert( pcchNameInout != NULL );
    int idx = 0;
    DWORD scode;

    //
    // If this is a Win32 wrapped in HRESULT stuff, remove the
    // HRESULT stuff so that the code will be found in the table.
    //
    if ( SCODE_FACILITY( dwErrIn ) == FACILITY_WIN32 )
    {
        scode = SCODE_CODE( dwErrIn );
    } // if: Win32 error code
    else
    {
        scode = dwErrIn;
    } // else: not Win32 error code

    while ( winerrorSymbolicNames[ idx ].SymbolicName ) 
    {
        if ( winerrorSymbolicNames[ idx ].MessageId == scode ) 
        {
#if defined ( UNICODE )
            *pcchNameInout = mbstowcs( pszNameOut, winerrorSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            Assert( *pcchNameInout != -1 );
#else // ASCII
            StrCpyN( pszNameOut, winerrorSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            *pcchNameInout = StrLen( pszNameOut );
#endif // UNICODE
            return;

        } // if: matched

        idx++;

    } // while: entries in list

    //
    // If we made it here, we did not find an entry.
    //
    StrCpyN( pszNameOut, TEXT("<unknown>"), *pcchNameInout );
    *pcchNameInout = StrLen( pszNameOut );
    return;

} //*** DebugFindWinerrorSymbolicName( )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugReturnMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPTSTR      pszBufIn,
//      INT *       pcchInout,
//      LPTSTR *    ppszBufOut
//      )
//
//  Description:
//      Prints the spew for a function return with error code. 
// 
//      The primary reason for doing this is to isolate the stack from adding 
//      the extra size of szSymbolicName to every function.
//
//  Argument:
//      pszFileIn   - File path to insert
//      nLineIn     - Line number to insert
//      pszModuleIn - Module name to insert
//      pszBufIn    - The buffer to initialize
//      pcchInout   - IN:  Size of the buffer in pszBufIn
//                  - OUT: Remaining characters in buffer not used.
//      ppszBufOut  - Next location to write to append more text
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugReturnMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszMessageIn,
    DWORD       dwErrIn
    )
{
    TCHAR szSymbolicName[ 64 ]; // random
    DWORD cchSymbolicName;

    cchSymbolicName = sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] );
    DebugFindWinerrorSymbolicName( dwErrIn, szSymbolicName, &cchSymbolicName );
    Assert( cchSymbolicName != sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] ) );
    TraceMessage( pszFileIn, nLineIn, pszModuleIn, mtfFUNC, pszMessageIn, dwErrIn, szSymbolicName );

} //*** DebugReturnMessage( )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeBuffer(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPTSTR      pszBufIn,
//      INT *       pcchInout,
//      LPTSTR *    ppszBufOut
//      )
//
//  Description:
//      Intializes the output buffer with "File(Line)  Module  ".
//
//  Argument:
//      pszFileIn   - File path to insert
//      nLineIn     - Line number to insert
//      pszModuleIn - Module name to insert
//      pszBufIn    - The buffer to initialize
//      pcchInout   - IN:  Size of the buffer in pszBufIn
//                  - OUT: Remaining characters in buffer not used.
//      ppszBufOut  - Next location to write to append more text
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeBuffer(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPTSTR      pszBufIn,
    INT *       pcchInout,
    LPTSTR *    ppszBufOut
    )
{
    INT cch = 0;

    static TCHAR szBarSpace[] =
        TEXT("| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ");
        //                      1                   2                   3                   4                   5
        //    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0

    //
    // Add date/time stamp
    //
    if ( IsTraceFlagSet( mtfADDTIMEDATE ) )
    {
        static TCHAR      szBuffer[ 25 ];
        static SYSTEMTIME OldSystemTime = { 0 };

        SYSTEMTIME SystemTime;
        int        iCmp;

        GetLocalTime( &SystemTime );

        //
        // Avoid expensive printf by comparing times
        //
        iCmp = memcmp( (PVOID)&SystemTime, (PVOID)&OldSystemTime, sizeof( SYSTEMTIME ) );
        if ( iCmp != 0 )
        {
            cch = wnsprintf( szBuffer, 
                             25, 
                             TEXT("%02u/%02u/%04u %02u:%02u:%02u.%03u "),
                             SystemTime.wMonth,
                             SystemTime.wDay,
                             SystemTime.wYear,
                             SystemTime.wHour,
                             SystemTime.wMinute,
                             SystemTime.wSecond,
                             SystemTime.wMilliseconds
                             );

            if ( cch != 24 )
            {
                DEBUG_BREAK;    // can't assert!
            } // if: cch != 24

        } // if: didn't match

        StrCpy( pszBufIn, szBuffer );
        cch = 24;

    } // if: time/date
    else
    {
        //
        // Add the filepath and line number
        //
        if ( pszFileIn != NULL )
        {
            LPTSTR psz;

            cch = wnsprintf( pszBufIn, *pcchInout, g_szFileLine, pszFileIn, nLineIn );
            if ( cch < 0 )
            {
                cch = StrLen( pszBufIn );
            } // if: error

            for ( psz = pszBufIn + cch; cch < cchFILEPATHLINESIZE; cch++ )
            {
                *psz = 32;
                psz++;
            } // for: cch < 60
            *psz = 0;

            if ( cch != cchFILEPATHLINESIZE )
            {
                DEBUG_BREAK;    // can't assert!
            } // if: cch != cchFILEPATHLINESIZE 

        } // if: have a filepath

    } // else: normal (no time/date)

    //
    // Add module name
    //
    if ( IsTraceFlagSet( mtfBYMODULENAME ) )
    {
        if ( pszModuleIn == NULL )
        {
            StrCpy( pszBufIn + cch, g_szUnknown );
            cch += sizeof( g_szUnknown ) / sizeof( g_szUnknown[ 0 ] ) - 1;

        } // if:
        else
        {
            static LPCTSTR pszLastTime = NULL;
            static DWORD   cchLastTime = 0;

            StrCpy( pszBufIn + cch, pszModuleIn );
            if ( pszLastTime != pszModuleIn )
            {
                pszLastTime = pszModuleIn;
                cchLastTime = StrLen( pszModuleIn );
            } // if: not the same as last time

            cch += cchLastTime;

        } // else:

        StrCat( pszBufIn + cch, TEXT(": ") );
        cch += 2;

    } // if: add module name

    //
    // Add the thread id if "per thread" tracing is on.
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        //
        // And check the "per thread" to see if this particular thread
        // is supposed to be displaying its ID.
        //
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL
          && ptd->dwFlags & mtfPERTHREADTRACE 
           )
        {
            int cchPlus;
            cchPlus = wnsprintf( pszBufIn + cch,
                                 *pcchInout - cch,
                                 TEXT("~%08x~ "),
                                 GetCurrentThreadId( )
                                 );
            if ( cchPlus < 0 )
            {
                cch = StrLen( pszBufIn );
            } // if: failure
            else
            {
                cch += cchPlus;
            } // else: success

        } // if: turned on in the thread

    } // if: tracing by thread

    *ppszBufOut = pszBufIn + cch;
    *pcchInout -= cch;

    //
    // Add the "Bar Space" for stack scoping
    //

    // There must be something to output, both flags must be set,
    // and there must to be a filepath.
    if ( IsDebugFlagSet( mtfSTACKSCOPE ) 
      && IsDebugFlagSet( mtfFUNC ) 
      && pszFileIn != NULL
       )
    {
        DWORD dwCounter;

        //
        // Choose "per thread" or "global" counter.
        //
        if ( g_tfModule & mtfPERTHREADTRACE )
        {
            SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
            if ( ptd != NULL )
            {
                dwCounter = ptd->dwStackCounter;
            } // if: ptd
            else
            {
                dwCounter = 0;
            } // else: assume nothing
        } // if: per thread
        else
        {
            dwCounter = g_dwCounter;
        } // else: global counter

        if ( dwCounter >= 50 )
        {
            DEBUG_BREAK;    // can't assert!
        } // if: dwCounter not vaild

        if ( dwCounter > 1
          && dwCounter < 50
           )
        {
            INT nCount = ( dwCounter - 1 ) * 2;
            StrNCpy( *ppszBufOut, szBarSpace, nCount + 1 ); // extra character for bug in StrNCpyNXW( )
            *ppszBufOut += nCount;
            *pcchInout -= nCount;
        } // if: within range

    } // if: stack scoping on

} //*** DebugInitializeBuffer( )


#if defined(IMAGEHLP_ENABLED)
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  FALSE
//  DebugNoOp( void )
//
//  Description:
//      Returns FALSE. Used to replace ImageHlp routines it they weren't
//      loaded or not found.
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE, always.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
DebugNoOp( void )
{
    return FALSE;

} //*** DebugNoOp( )
*/
#endif // IMAGEHLP_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeTraceFlags( void )
//
//  Description:
//      Retrieves the default tracing flags for this module from an INI file
//      that is named the same as the EXE file (e.g. MMC.EXE -> MMC.INI).
//      Typically, this is called from the TraceInitializeProcess() macro.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeTraceFlags( void )
{
    TCHAR  szSection[ 64 ];
    TCHAR  szFiles[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    TCHAR  szPath[ MAX_PATH ];
    LPTSTR psz;
    DWORD  dwLen;

    //
    // Allocate TLS for memory tracking
    //
    Assert( g_TraceMemoryIndex == -1 );
    g_TraceMemoryIndex = TlsAlloc( );
    TlsSetValue( g_TraceMemoryIndex, NULL);

    //
    // Initialize module trace flags
    //

    //
    // Get the EXEs filename and change the extension to INI.
    //
    dwLen = GetModuleFileName( NULL, szPath, MAX_PATH );
    Assert( dwLen != 0 ); // error in GetModuleFileName
    StrCpy( &szPath[ dwLen - 3 ], TEXT("ini") );
    g_tfModule = (TRACEFLAG) GetPrivateProfileInt( __MODULE__,
                                                   TEXT("TraceFlags"),
                                                   0,
                                                   szPath
                                                   );
    DebugMsg( "DEBUG: Reading %s\n%s: DEBUG: g_tfModule = 0x%08x\n",
              szPath,
              __MODULE__,
              g_tfModule
              );

    //
    // Initialize thread trace flags
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        Assert( g_TraceFlagsIndex == -1 );
        g_TraceFlagsIndex = TlsAlloc( );
        DebugInitializeThreadTraceFlags( NULL );
    } // if: per thread tracing

    //
    // Force the loading of certain modules
    //
    GetPrivateProfileString( __MODULE__, TEXT("ForcedDLLsSection"), g_szNULL, szSection, 64, szPath );
    ZeroMemory( szFiles, cchDEBUG_OUTPUT_BUFFER_SIZE );
    GetPrivateProfileSection( szSection, szFiles, cchDEBUG_OUTPUT_BUFFER_SIZE, szPath );
    psz = szFiles;
    while ( *psz )
    {
        TCHAR szExpandedPath[ MAX_PATH ];
        ExpandEnvironmentStrings( psz, szExpandedPath, MAX_PATH );
        DebugMsg( "DEBUG: Forcing %s to be loaded.\n", szExpandedPath );
        LoadLibrary( szExpandedPath );
        psz += StrLen( psz ) + 1;
    } // while: entry found

#if defined(IMAGEHLP_ENABLED)
    /*
    //
    // Load symbols for our module
    //
    g_hImageHlp = LoadLibraryEx( TEXT("imagehlp.dll"), NULL, 0 );
    if ( g_hImageHlp != NULL )
    {
        // Typedef this locally since it is only needed once.
        typedef BOOL (*PFNSYMINITIALIZE)(HANDLE, PSTR, BOOL);
        PFNSYMINITIALIZE pfnSymInitialize;
        pfnSymInitialize = (PFNSYMINITIALIZE) GetProcAddress( g_hImageHlp, "SymInitialize" );
        if ( pfnSymInitialize != NULL )
        {
            pfnSymInitialize( GetCurrentProcess( ), NULL, TRUE );
        } // if: got address

        //
        // Grab the other addresses we need. Replace them with a "no op" if they are not found
        //
        g_pfnSymGetSymFromAddr  = (PFNSYMGETSYMFROMADDR)    GetProcAddress( g_hImageHlp, "SymGetSymFromAddr"    );
        g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR)   GetProcAddress( g_hImageHlp, "SymGetLineFromAddr"   );
        g_pfnSymGetModuleInfo   = (PFNSYMGETMODULEINFO)     GetProcAddress( g_hImageHlp, "SymGetModuleInfo"     );

    } // if: imagehlp loaded

    //
    // If loading IMAGEHLP failed, we need to point these to the "no op" routine.
    //
    if ( g_pfnSymGetSymFromAddr == NULL )
    {
        g_pfnSymGetSymFromAddr = (PFNSYMGETSYMFROMADDR) &DebugNoOp;
    } // if: failed
    if ( g_pfnSymGetLineFromAddr == NULL )
    {
        g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR) &DebugNoOp;
    } // if: failed
    if ( g_pfnSymGetModuleInfo == NULL )
    {
        g_pfnSymGetModuleInfo = (PFNSYMGETMODULEINFO) &DebugNoOp;
    } // if: failed

    HINSTANCE hMod = LoadLibrary( TEXT("NTDLL.DLL") );
    g_pfnRtlGetCallersAddress = (PFNRTLGETCALLERSADDRESS) GetProcAddress( hMod, "RtlGetCallersAddress" );
    if ( g_pfnRtlGetCallersAddress == NULL )
    {
        g_pfnRtlGetCallersAddress = (PFNRTLGETCALLERSADDRESS) &DebugNoOp;
    } // if: failed
    */
#endif // IMAGEHLP_ENABLED


} //*** DebugInitializeTraceFlags( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugTerminateProcess( void )
//
//  Description:
//      Cleans up anything that the debugging routines allocated or
//      initialized. Typically, you should call the TraceTerminateProcess() 
//      macro just before your process exits.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugTerminateProcess( void )
{
#if defined(IMAGEHLP_ENABLED)
    /*
    //
    // ImageHlp Cleanup
    //
    if ( g_hImageHlp != NULL )
    {
        // Typedef this locally since it is only needed once.
        typedef BOOL (*PFNSYMCLEANUP)(HANDLE);
        PFNSYMCLEANUP pfnSymCleanup;
        pfnSymCleanup = (PFNSYMCLEANUP) GetProcAddress( g_hImageHlp, "SymCleanup" );
        if ( pfnSymCleanup != NULL )
        {
            pfnSymCleanup( GetCurrentProcess( ) );
        } // if: found proc

        FreeLibrary( g_hImageHlp );

    } // if: imagehlp loaded
    */
#endif // IMAGEHLP_ENABLED

    //
    // Free the TLS storage
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        TlsFree( g_TraceFlagsIndex );
    } // if: per thread tracing

    TlsFree( g_TraceMemoryIndex );

} //*** DebugTerminateProcess( )

#if defined(IMAGEHLP_ENABLED)
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugGetFunctionName(
//      LPSTR pszNameOut,
//      DWORD cchNameIn
//      )
//
//  Description:
//      Retrieves the calling functions name.
//
//  Arguments:
//      pszNameOut  - The buffer that will contain the functions name.
//      cchNameIn   - The size of the the out buffer.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugGetFunctionName(
    LPSTR pszNameOut,
    DWORD cchNameIn
    )
{
    PVOID CallersAddress;
    PVOID CallersCaller;
    BOOL  fSuccess;
    union
    {
        IMAGEHLP_SYMBOL sym; 
        BYTE            buf[ 255 ];
    } SymBuf;

    SymBuf.sym.SizeOfStruct = sizeof( SymBuf );

    g_pfnRtlGetCallersAddress( &CallersAddress, &CallersCaller );

    fSuccess = g_pfnSymGetSymFromAddr( GetCurrentProcess( ), (LONG) CallersAddress, 0, (PIMAGEHLP_SYMBOL) &SymBuf );
    if ( fSuccess ) 
    {
        StrCpyNA( pszNameOut, SymBuf.sym.Name, cchNameIn );
    } // if: success
    else
    { 
        DWORD dwErr = GetLastError( );
        StrCpyNA( pszNameOut, "<unknown>", cchNameIn );
    } // if: failed

} //*** DebugGetFunctionName( )
*/
#endif // IMAGEHLP_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeThreadTraceFlags(
//      LPCTSTR pszThreadNameIn
//      )
//
//  Description:
//      If enabled (g_tfModule & mtfPERTHREADTRACE), retrieves the default
//      tracing flags for this thread from an INI file that is named the
//      same as the EXE file (e.g. MMC.EXE -> MMC.INI). The particular
//      TraceFlag level is determined by either the thread name (handed in
//      as a parameter) or by the thread counter ID which is incremented
//      every time a new thread is created and calls this routine. The
//      incremental name is "ThreadTraceFlags%u".
//
//      This routine is called from the TraceInitliazeThread() macro.
//
//  Arguments:
//      pszThreadNameIn 
//          - If the thread has an assoc. name with it, use it instead of the
//          incremented version. NULL indicate no naming.
//          
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeThreadTraceFlags(
    LPCTSTR pszThreadNameIn
    )
{
    //
    // Read per thread flags
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        TCHAR szPath[ MAX_PATH ];
        DWORD dwTraceFlags;
        DWORD dwLen;
        SPerThreadDebug * ptd;
        LPCTSTR pszThreadTraceFlags;

        //
        // Get the EXEs filename and change the extension to INI.
        //

        dwLen = GetModuleFileName( NULL, szPath, sizeof( szPath ) );
        Assert( dwLen != 0 ); // error in GetModuleFileName
        StrCpy( &szPath[ dwLen - 3 ], TEXT("ini") );


        if ( pszThreadNameIn == NULL )
        {
            TCHAR szThreadTraceFlags[ 50 ];
            //
            // No name thread - use generic name
            //
            wnsprintf( szThreadTraceFlags, sizeof( szThreadTraceFlags ), TEXT("ThreadTraceFlags%u"), g_ThreadCounter );
            dwTraceFlags = GetPrivateProfileInt( __MODULE__, szThreadTraceFlags, 0, szPath );
            InterlockedIncrement( (LONG *) &g_ThreadCounter );
            pszThreadTraceFlags = szThreadTraceFlags;

        } // if: no thread name
        else
        {
            //
            // Named thread
            //
            dwTraceFlags = GetPrivateProfileInt( __MODULE__, pszThreadNameIn, 0, szPath );
            pszThreadTraceFlags = pszThreadNameIn;

        } // else: named thread

        Assert( g_TraceFlagsIndex != 0 );

        // don't track this.
        ptd = (SPerThreadDebug *) GlobalAlloc( GMEM_FIXED, sizeof( SPerThreadDebug ) );
        Assert( ptd != NULL );

        ptd->dwFlags        = dwTraceFlags;
        ptd->dwStackCounter = 0;

        TlsSetValue( g_TraceFlagsIndex, ptd );

        DebugMsg( "DEBUG: Starting ThreadId = 0x%08x - %s = 0x%08x\n", 
                  GetCurrentThreadId( ), 
                  pszThreadTraceFlags, 
                  dwTraceFlags 
                  );
    } // if: per thread tracing turned on

} //*** DebugInitializeThreadTraceFlags( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugTerminiateThreadTraceFlags( void )
//
//  Description:
//      Cleans up the mess create by DebugInitializeThreadTraceFlags( ). One
//      should use the TraceTerminateThread( ) macro instead of calling this
//      directly.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugTerminiateThreadTraceFlags( void )
{
    //
    // If "per thread" is on, clean up the memory allocation.
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        Assert( g_TraceFlagsIndex != -1 );

        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            GlobalFree( ptd );
            TlsSetValue( g_TraceFlagsIndex, NULL );
        } // if: ptd

    } // if: per thread

} // DebugTerminiateThreadTraceFlags( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
// 
//  void
//  TraceMsg(
//      TRACEFLAG   tfIn,
//      LPCSTR      pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger.
//
//  Arguments:
//      tfIn        - Flags to be checked.
//      pszFormatIn - Formatted string to spewed to the debugger.
//      ...         - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
TraceMsg(
    TRACEFLAG   tfIn,
    LPCSTR      pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        int     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;

        DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

#ifdef UNICODE
        //
        // Convert the format buffer to wide chars
        //
        WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        mbstowcs( szFormat, pszFormatIn, StrLenA( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        wvnsprintf( pszBuf, cchSize, szFormat, valist );
        va_end( valist );
#else
        va_start( valist, pszFormatIn );
        wvnsprintf( pszBuf, cchSize, pszFormatIn, valist );
        va_end( valist );
#endif // UNICODE

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMsg( ) - ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  void
//  TraceMsg(
//      TRACEFLAG   tfIn,
//      LPCWSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger.
//
//  Arguments:
//      tfIn            - Flags to be checked.
//      pszFormatIn     - Formatted string to spewed to the debugger.
//      ...             - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
TraceMsg(
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        int     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;

        DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

#ifndef UNICODE
        //
        // Convert the format buffer to ascii chars
        //
        CHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        wvnsprintf( pszBuf, cchSize, szFormat, valist );
        va_end( valist );
#else
        va_start( valist, pszFormatIn );
        wvnsprintf( pszBuf, cchSize, pszFormatIn, valist );
        va_end( valist );
#endif // UNICODE

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMsg( ) - UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  TraceMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      TRACEFLAG   tfIn,
//      LPCTSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger
//      along with the filename, line number and module name supplied. This is
//      used by many of the debugging macros.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module.
//      tfIn            - Flags to be checked.
//      pszFormatIn     - Formatted message to be printed.
//      ...             - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
TraceMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        INT     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;   
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  psz;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &psz );

        va_start( valist, pszFormatIn );
        wvnsprintf( psz, cchSize, pszFormatIn, valist );
        va_end( valist );

        DebugOutputString( szBuf );
    } // if: flags set

} //*** TraceMessage( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  TraceMessageDo(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      TRACEFLAG   tfIn,
//      LPCTSTR     pszFormatIn,
//      LPCTSTR     pszFuncIn,
//      ...
//      )
//
//  Description:
//      Works like TraceMessage() but takes has a function argument that is
//      broken into call/result in the debug spew. This is called from the
//      TraceMsgDo macro.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module.
//      tfIn            - Flags to be checked
//      pszFormatIn     - Formatted return value string
//      pszFuncIn       - The string version of the function call.
//      ...             - Return value from call.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
TraceMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        int     nLen;

        INT     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;
        LPCTSTR psz     = pszFuncIn;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

        //
        // Prime the buffer
        //
        StrCpy( pszBuf, TEXT("V ") );
        pszBuf += 2;

        //
        // Copy the l-var part of the expression
        //
        while ( *psz 
             && *psz != TEXT('=')
              )
        {
            *pszBuf = *psz;
            psz++;
            pszBuf++;

        } // while:

        //
        // Add the " = "
        //
        StrCpy( pszBuf, TEXT(" = ") );
        pszBuf += 3;

        //
        // Add the formatted result
        //
        va_start( valist, pszFuncIn );
        nLen = wvnsprintf( pszBuf, (int)(cchDEBUG_OUTPUT_BUFFER_SIZE - 2 - (pszBuf - &szBuf[0])), pszFormatIn, valist );
        va_end( valist );
        if ( nLen < 0 )
        {
            StrCat( szBuf, TEXT("\n") );
        } // if: error
        else
        {
            pszBuf += nLen;
            StrCpy( pszBuf, TEXT("\n") );
        } // else: success

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMessageDo( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      Displays a message only in CHKed/DEBUG builds. Also appends the source
//      filename, linenumber and module name to the ouput.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszFormatIn - Formatted message to be printed.
//      ...         - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    INT     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;
    LPTSTR  pszBuf;

    DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

    va_start( valist, pszFormatIn );
    wvnsprintf( pszBuf, cchSize, pszFormatIn, valist );
    va_end( valist );

    DebugOutputString( szBuf );

} //*** DebugMessage( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMessageDo(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszFormatIn,
//      LPCTSTR     pszFuncIn,
//      ...
//      )
//
//  Description:
//      Just like TraceMessageDo() except in CHKed/DEBUG version it will
//      always spew. The DebugMsgDo macros uses this function.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszFormatIn - Formatted result message.
//      pszFuncIn   - The string version of the function call.
//      ...         - The return value of the function call.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMessageDo(
    LPCTSTR pszFileIn,
    const int nLineIn,
    LPCTSTR pszModuleIn,
    LPCTSTR pszFormatIn,
    LPCTSTR pszFuncIn,
    ...
    )
{
    va_list valist;
    
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    LPTSTR  pszBuf;
    int     nLen;

    INT     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;
    LPCTSTR psz = pszFuncIn;

    DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

    //
    // Prime the buffer
    //
    StrCpy( pszBuf, TEXT("V ") );
    pszBuf += 2;

    //
    // Copy the l-var part of the expression
    //
    while ( *psz 
         && *psz != TEXT('=')
          )
    {
        *pszBuf = *psz;
        psz++;
        pszBuf++;

    } // while:

    //
    // Add the " = "
    //
    StrCpy( pszBuf, TEXT(" = ") );
    pszBuf += 3;

    //
    // Add the formatted result
    //
    va_start( valist, pszFuncIn );
    nLen = wvnsprintf( pszBuf, (int)(cchDEBUG_OUTPUT_BUFFER_SIZE - 2 - (pszBuf - &szBuf[ 0 ])), pszFormatIn, valist );
    va_end( valist );
    if ( nLen < 0 )
    {
        StrCat( szBuf, TEXT("\n") );
    } // if: error
    else
    {
        pszBuf += nLen;
        StrCpy( pszBuf, TEXT("\n") );
    } // else: success

    DebugOutputString( szBuf );

} //*** DebugMessageDo( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  void
//  DebugMsg(
//      LPCSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMsg(
    LPCSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    LPTSTR  pszBuf;
    int     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

#ifdef UNICODE
    //
    // Convert the format buffer to wide chars
    //
    WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormatIn, StrLenA( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    wvnsprintf( pszBuf, cchSize, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormatIn );
    wvnsprintf( pszBuf, cchSize, pszFormatIn, valist);
    va_end( valist );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsg( ) - ASCII version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  void
//  DebugMsg(
//      LPCWSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMsg(
    LPCWSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    LPTSTR  pszBuf;
    int     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

#ifndef UNICODE
    //
    // Convert the format buffer to ascii chars
    //
    CHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    wvnsprintf( pszBuf, cchSize, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormatIn );
    wvnsprintf( pszBuf, cchSize, pszFormatIn, valist);
    va_end( valist );
#endif // UNICODE


    DebugOutputString( szBuf );

} //*** DebugMsg( ) - UNICODE version


//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  AssertMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      BOOL        fTrueIn 
//      )
//
//  Description:
//      Displays a dialog box with the failed assertion. User has the option of
//      breaking. The Assert macro calls this to display assertion failures.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the expression to assert.
//      fTrueIn     - Result of the evaluation of the expression.
//
//  Return Values:
//      TRUE    - Caller should call DEBUG_BREAK.
//      FALSE   - Caller should not call DEBUG_BREAK.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
AssertMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    BOOL        fTrueIn 
    )
{
    BOOL fTrue = fTrueIn;

    if ( ! fTrueIn )
    {
        LRESULT lResult;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR   szFileLine[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        LPCTSTR pszfn = pszfnIn;
        int     cchSize = cchDEBUG_OUTPUT_BUFFER_SIZE;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        wnsprintf( pszBuf, cchSize, TEXT("ASSERT: %s\n"), pszfn );

        //
        // Dump the buffers
        //
        DebugOutputString( szBuf );

        wnsprintf( szBuf, 
                   cchDEBUG_OUTPUT_BUFFER_SIZE, 
                   TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
                   pszModuleIn, 
                   nLineIn, 
                   pszFileIn, 
                   pszfn 
                   );

        lResult = MessageBox( NULL, szBuf, TEXT("Assertion Failed!"), MB_YESNO | MB_ICONWARNING );
        if ( lResult == IDNO )
        {
            fTrue = TRUE;   // don't break
        } // if:

    } // if: assert false

    return ! fTrue;

} //*** AssertMessage( )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  TraceHR(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      HRESULT     hrIn,
//      BOOL        fSuccessIn
//      )
//
//  Description:
//      Traces HRESULT errors. A dialog will appear if the hrIn is not equal
//      to S_OK. The dialog will ask if the user wants to break-in or continue
//      execution. This is called from the THR macro.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the function call.
//      hrIn        - HRESULT of the function call.
//      fSuccessIn  - If TRUE, only if FAILED( hr ) is TRUE will it report.
//
//  Return Values:
//      Whatever hrIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
TraceHR(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    HRESULT     hrIn,
    BOOL        fSuccessIn
    )
{
    if (    ( fSuccessIn 
           && FAILED( hrIn )
            )
      ||    ( ! fSuccessIn 
           && hrIn != S_OK
            )
       )
    {
        TCHAR   szSymbolicName[ 64 ]; // random
        DWORD   cchSymbolicName;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        LPTSTR  pszMsgBuf;
        LRESULT lResult;

        INT     cchSize         = cchDEBUG_OUTPUT_BUFFER_SIZE;
        bool    fAllocatedMsg   = false;

        switch ( hrIn )
        {
        case S_FALSE:
            pszMsgBuf = TEXT("S_FALSE\n");

            //
            // Find the symbolic name for this error.
            //
            cchSymbolicName = sizeof( TEXT("S_FALSE") ) / sizeof( TEXT("S_FALSE") );
            Assert( cchSymbolicName <= sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] ) );
            StrCpy( szSymbolicName, TEXT("S_FALSE") );
            break;

        default:
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hrIn,
                MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
                (LPTSTR) &pszMsgBuf,
                0,
                NULL
                );

            //
            // Make sure everything is cool before we blow up somewhere else.
            //
            if ( pszMsgBuf == NULL )
            {
                pszMsgBuf = TEXT("<unknown error code returned>\n");
            } // if: status code not found
            else
            {
                fAllocatedMsg = true;
            } // else: found the status code

            //
            // Find the symbolic name for this error.
            //
            cchSymbolicName = sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] );
            DebugFindWinerrorSymbolicName( hrIn, szSymbolicName, &cchSymbolicName );
            Assert( cchSymbolicName != sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] ) );

            break;
        } // switch: hrIn

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        wnsprintf( pszBuf,
                   cchSize,
                   TEXT("*HRESULT* hr = 0x%08x (%s) - %s"),
                   hrIn,
                   szSymbolicName, 
                   pszMsgBuf
                   );
        DebugOutputString( szBuf );

        //
        // If trace flag set, generate a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            wnsprintf( szBuf, 
                       cchDEBUG_OUTPUT_BUFFER_SIZE, 
                       TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x (%s) - %s\t\nDo you want to break here?"),
                       pszModuleIn, 
                       nLineIn, 
                       pszFileIn, 
                       pszfnIn, 
                       hrIn, 
                       szSymbolicName,
                       pszMsgBuf 
                       );

            lResult = MessageBox( NULL, szBuf, TEXT("Trace HRESULT"), MB_YESNO | MB_ICONWARNING );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success HRESULTs

        if ( fAllocatedMsg )
        {
            LocalFree( pszMsgBuf );
        } // if: message buffer was allocated by FormateMessage( )

    } // if: hrIn != S_OK

    return hrIn;

} //*** TraceHR( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ULONG
//  TraceWin32(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      ULONG       ulErrIn
//      )
//
//  Description:
//      Traces WIN32 errors. A dialog will appear is the ulErrIn is not equal
//      to ERROR_SUCCESS. The dialog will ask if the user wants to break-in or
//      continue execution.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the function call.
//      ulErrIn     - Error code to check.
//
//  Return Values:
//      Whatever ulErrIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
TraceWin32(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    ULONG       ulErrIn
    )
{
    if ( ulErrIn != ERROR_SUCCESS )
    {
        TCHAR   szSymbolicName[ 64 ]; // random
        DWORD   cchSymbolicName;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        LPTSTR  pszMsgBuf;
        LRESULT lResult;

        INT     cchSize         = cchDEBUG_OUTPUT_BUFFER_SIZE;
        bool    fAllocatedMsg   = false;

        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER
            | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            ulErrIn,
            MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
            (LPTSTR) &pszMsgBuf,
            0,
            NULL
            );

        //
        // Make sure everything is cool before we blow up somewhere else.
        //
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = TEXT("<unknown error code returned>\n");
        } // if: status code not found
        else
        {
            fAllocatedMsg = true;
        } // else: found the status code

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Find the symbolic name for this error.
        //
        cchSymbolicName = sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] );
        DebugFindWinerrorSymbolicName( ulErrIn, szSymbolicName, &cchSymbolicName );
        Assert( cchSymbolicName != sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] ) );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        wnsprintf( pszBuf,
                   cchSize,
                   TEXT("*WIN32Err* ulErr = %u (%s) - %s"),
                   ulErrIn,
                   szSymbolicName,
                   pszMsgBuf
                   );
        DebugOutputString( szBuf );

        //
        // If trace flag set, invoke a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            wnsprintf( szBuf,
                       cchDEBUG_OUTPUT_BUFFER_SIZE,
                       TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nulErr =\t%u (%s) - %s\t\nDo you want to break here?"),
                       pszModuleIn,
                       nLineIn,
                       pszFileIn,
                       pszfnIn,
                       ulErrIn,
                       szSymbolicName,
                       pszMsgBuf
                       );

            lResult = MessageBox( NULL, szBuf, TEXT("Trace Win32"), MB_YESNO | MB_ICONWARNING );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success status codes

        if ( fAllocatedMsg )
        {
            LocalFree( pszMsgBuf );
        } // if: message buffer was allocated by FormateMessage( )

    } // if: ulErrIn != ERROR_SUCCESS

    return ulErrIn;

} //*** TraceWin32( )












//****************************************************************************
//****************************************************************************
//
//  Memory allocation and tracking
//
//****************************************************************************
//****************************************************************************









//
// This is a private structure and should not be known to the application.
//
typedef struct MEMORYBLOCK
{
    EMEMORYBLOCKTYPE    mbtType;    // What type of memory this is tracking
    union
    {
        HGLOBAL         hGlobal;    // handle/pointer/object to allocated memory to track
        BSTR            bstr;       // BSTR to allocated memory
    };
    DWORD               dwBytes;    // size of the memory
    UINT                uFlags;     // flags used to allocate memory
    LPCTSTR             pszFile;    // source filename where memory was allocated
    int                 nLine;      // source line number where memory was allocated
    LPCTSTR             pszModule;  // source module name where memory was allocated
    LPCTSTR             pszComment; // optional comments about the memory
    MEMORYBLOCK *       pNext;      // pointer to next MEMORYBLOCK structure
} MEMORYBLOCK;

typedef struct MEMORYBLOCKLIST
{
    LONG          lSpinLock;        // Spin lock protecting the list
    MEMORYBLOCK * pmbList;          // List of MEMORYBLOCKs.
    BOOL          fDeadList;        // The list is dead.
} MEMORYBLOCKLIST;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemorySpew(
//      MEMORYBLOCK *   pmb,
//      LPTSTR          pszMessage
//      )
//
//  Description:
//      Displays a message about the memory block.
//
//  Arugments:
//      pmb         - pointer to MEMORYBLOCK desciptor.
//      pszMessage  - message to display
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemorySpew(
    MEMORYBLOCK *   pmb,
    LPTSTR          pszMessage
    )
{
    switch ( pmb->mbtType )
    {
    case mmbtMEMORYALLOCATION:
        DebugMessage( pmb->pszFile,
                      pmb->nLine,
                      pmb->pszModule,
                      TEXT("%s %s - %u bytes at 0x%08x\n"),
                      pszMessage,
                      pmb->pszComment,
                      pmb->dwBytes,
                      pmb->hGlobal
                      );
        break;

    case mmbtOBJECT:
    case mmbtPUNK:
    case mmbtHANDLE:
        DebugMessage( pmb->pszFile,
                      pmb->nLine,
                      pmb->pszModule,
                      TEXT("%s %s = 0x%08x\n"),
                      pszMessage,
                      pmb->pszComment,
                      pmb->hGlobal
                      );
        break;

    } // switch: pmb->mbtType

} //*** DebugMemorySpew( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HGLOBAL
//  DebugMemoryAdd(
//      EMEMORYBLOCKTYPE    mbtType,
//      HGLOBAL             hGlobalIn,
//      LPCTSTR             pszFileIn,
//      const int           nLineIn,
//      LPCTSTR             pszModuleIn,
//      UINT                uFlagsIn,
//      DWORD               dwBytesIn,
//      LPCTSTR             pszCommentIn
//      )
//
//  Description:
//      Adds memory to be tracked to the memory tracking list.
//
//  Arguments:
//      mbtType         - Type of memory block of the memory to track.
//      hGlobalIn       - Handle/pointer to memory to track.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Whatever was in hGlobalIn.
//
//--
//////////////////////////////////////////////////////////////////////////////
HGLOBAL
DebugMemoryAdd(
    EMEMORYBLOCKTYPE    mbtType,
    HGLOBAL             hGlobalIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    UINT                uFlagsIn,
    DWORD               dwBytesIn,
    LPCTSTR             pszCommentIn
    )
{
    if ( hGlobalIn != NULL )
    {
        MEMORYBLOCK *   pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        MEMORYBLOCK *   pmb     = (MEMORYBLOCK *) GlobalAlloc( GMEM_FIXED, sizeof( MEMORYBLOCK ) );

        if ( pmb == NULL )
        {
            GlobalFree( hGlobalIn );
            return NULL;

        } // if: memory block allocation failed

        pmb->mbtType    = mbtType;
        pmb->hGlobal    = hGlobalIn;
        pmb->dwBytes    = dwBytesIn;
        pmb->uFlags     = uFlagsIn;
        pmb->pszFile    = pszFileIn;
        pmb->nLine      = nLineIn;
        pmb->pszModule  = pszModuleIn;
        pmb->pszComment = pszCommentIn;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );

        //
        // Spew if needed
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            DebugMemorySpew( pmb, TEXT("Alloced") );
        } // if: tracing

    } // if: something to trace

    return hGlobalIn;

} //*** DebugMemoryAdd( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryDelete(
//      EMEMORYBLOCKTYPE    mbtTypeIn,
//      HGLOBAL             hGlobalIn
//      LPCTSTR             pszFileIn,
//      const int           nLineIn,
//      LPCTSTR             pszModuleIn,
//      BOOL                fClobberIn
//      )
//
//  Description:
//      Removes a MEMORYBLOCK to the memory tracking list.
//
//  Arguments:
//      mbtTypeIn   - Memory block type.
//      hGlobalIn   - Handle/pointer to memory block to stop tracking.
//      pszFileIn   - Source file that is deleteing.
//      nLineIn     - Source line number that is deleteing.
//      pszModuleIn - Source module name that is deleteing.
//      fClobberIn  - True is memory should be scrambled.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryDelete(
    EMEMORYBLOCKTYPE    mbtTypeIn,
    HGLOBAL             hGlobalIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    BOOL                fClobberIn
    )
{
    if ( hGlobalIn != NULL )
    {
        MEMORYBLOCK *   pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        MEMORYBLOCK *   pmbLast = NULL;

        //
        // Find the memory in the memory block list
        //
        if ( mbtTypeIn == mmbtMEMORYALLOCATION )
        {
            while ( pmbHead != NULL 
                 && !(  pmbHead->hGlobal == hGlobalIn 
                    &&  pmbHead->mbtType == mbtTypeIn 
                     )
                  )
            {
                AssertMsg( !( pmbHead->hGlobal == hGlobalIn && pmbHead->mbtType == mmbtSYSALLOCSTRING ),
                           "Should be freed by SysAllocFreeString( )." );
                pmbLast = pmbHead;
                pmbHead = pmbLast->pNext;

            } // while: finding the entry in the list
        } // if: memory allocation type
        else if ( mbtTypeIn == mmbtSYSALLOCSTRING )
        {
            while ( pmbHead != NULL 
                 && !(  pmbHead->hGlobal == hGlobalIn
                    &&  pmbHead->mbtType == mbtTypeIn
                     )
                  )
            {
                AssertMsg( !( pmbHead->hGlobal == hGlobalIn && pmbHead->mbtType == mmbtMEMORYALLOCATION ),
                           "Should be freed by TraceFree( )." );
                pmbLast = pmbHead;
                pmbHead = pmbLast->pNext;

            } // while: finding the entry in the list
        } // if: SysAllocString type
        else if ( mbtTypeIn == mmbtUNKNOWN )
        {
            while ( pmbHead != NULL 
                 && pmbHead->hGlobal != hGlobalIn 
                  )
            {
                pmbLast = pmbHead;
                pmbHead = pmbLast->pNext;

            } // while: finding the entry in the list
        } // if: don't care what type
        else
        {
            while ( pmbHead != NULL 
                 && !(  pmbHead->hGlobal == hGlobalIn 
                    &&  pmbHead->mbtType == mbtTypeIn 
                     )
                  )
            {
                pmbLast = pmbHead;
                pmbHead = pmbLast->pNext;

            } // while: finding the entry in the list
        } // else: other types, but they must match

        if ( pmbHead != NULL )
        {
            //
            // Remove the memory block from the tracking list
            //
            if ( pmbLast != NULL )
            {
                pmbLast->pNext = pmbHead->pNext;

            } // if: not first entry
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("Freeing") );
            } // if: tracing

            //
            // Nuke the memory
            //
            if ( fClobberIn
              && pmbHead->mbtType == mmbtMEMORYALLOCATION
               )
            {
                if ( pmbHead->uFlags & GMEM_MOVEABLE )
                {
                    LPVOID pv = GlobalLock( pmbHead->hGlobal );
                    memset( pv, 0xFA, pmbHead->dwBytes );
                    GlobalUnlock( pmbHead->hGlobal );

                } // if: moveable memory
                else
                {
                    Assert( pmbHead->uFlags == 0 || pmbHead->uFlags == LPTR || pmbHead->dwBytes == 0 );
                    memset( pmbHead->hGlobal, 0xFA, pmbHead->dwBytes );

                } // else: fixed memory

            } // if: block is memory alloction

            //
            // Nuke the memory tracking block
            //
            memset( pmbHead, 0xFB, sizeof( MEMORYBLOCK ) );
            GlobalFree( pmbHead );

        } // if: found entry
        else
        {
            DebugMessage( pszFileIn,
                          nLineIn,
                          pszModuleIn,
                          TEXT("***** Attempted to free 0x%08x not owned by thread (ThreadID = 0x%08x) *****\n"),
                          hGlobalIn, 
                          GetCurrentThreadId( ) 
                          );
        } // else: entry not found

    } // if: something to delete

} //*** DebugMemoryDelete( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HGLOBAL
//  DebugAlloc(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      UINT        uFlagsIn,
//      DWORD       dwBytesIn,
//      LPCTSTR     pszCommentIn
//      )
//
//  Description:
//      Replacement for Local/GlobalAlloc for CHKed/DEBUG builds. Memory 
//      allocations be tracked. Use the TraceAlloc macro to make memory
//      allocations switch in RETAIL.
//
//  Arguments:
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Handle/pointer to the new allocation. NULL is allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HGLOBAL
DebugAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    )
{
    HGLOBAL hGlobal = GlobalAlloc( uFlagsIn, dwBytesIn );

    //
    // Initialize the memory if needed
    //
    if ( IsTraceFlagSet( mtfMEMORYINIT )
      && !( uFlagsIn & GMEM_ZEROINIT )
       )
    {
        if ( uFlagsIn & GMEM_MOVEABLE )
        {
            LPVOID pv = GlobalLock( hGlobal );
            if ( pv != NULL )
            {
                memset( pv, 0xAA, dwBytesIn );
                GlobalUnlock( hGlobal );
            } // if: lock granted

        } // if: moveable block
        else
        {
            //
            // KB: gpease 8-NOV-1999
            //     Initialize to anything but ZERO. We will use 0xAA to
            //     indicate "Available Address". Initializing to zero
            //     is bad because it usually has meaning.
            //
            memset( hGlobal, 0xAA, dwBytesIn );

        } // else: fixed block

    } // if: zero memory requested

    return DebugMemoryAdd( mmbtMEMORYALLOCATION,
                           hGlobal,
                           pszFileIn,
                           nLineIn,
                           pszModuleIn,
                           uFlagsIn,
                           dwBytesIn,
                           pszCommentIn
                           );

} //*** DebugAlloc( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HGLOBAL
//  DebugReAlloc(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      HGLOBAL     hMemIn,
//      UINT        uFlagsIn,
//      DWORD       dwBytesIn,
//      LPCTSTR     pszCommentIn
//      )
//
//  Description:
//      Replacement for Local/GlobalAlloc for CHKed/DEBUG builds. Memory 
//      allocations be tracked. Use the TraceAlloc macro to make memory
//      allocations switch in RETAIL.
//
//  Arguments:
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Handle/pointer to the new allocation.
//      NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HGLOBAL
DebugReAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    HGLOBAL     hMemIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    )
{
    MEMORYBLOCK * pmbHead       = NULL;
    HGLOBAL       hGlobalOld    = hMemIn;

    HGLOBAL hGlobal;

    AssertMsg( !( uFlagsIn & GMEM_MODIFY ), "This doesn't handle modified memory blocks, yet." );
    
    if ( hMemIn != NULL )
    {
        MEMORYBLOCK * pmbLast = NULL;

        pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );

        //
        // Find the memory in the memory block list
        //
        while ( pmbHead != NULL 
             && pmbHead->hGlobal != hMemIn
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;

        } // while: finding the entry in the list

        if ( pmbHead != NULL )
        {
            AssertMsg( pmbHead->mbtType == mmbtMEMORYALLOCATION, "You can only realloc memory allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbLast != NULL )
            {
                pmbLast->pNext = pmbHead->pNext;

            } // if: not first entry
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("Freeing") );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            hGlobalOld = GlobalAlloc( pmbHead->uFlags, pmbHead->dwBytes );
            if ( hGlobalOld != NULL )
            {
                if ( pmbHead->uFlags & GMEM_MOVEABLE
                   )
                {
                    LPVOID pvDest = GlobalLock( hGlobalOld );
                    LPVOID pvSrc  = GlobalLock( hMemIn );

                    CopyMemory( pvDest, pvSrc, pmbHead->dwBytes );

                    //
                    // Nuke the old memory if the allocation is to be smaller.
                    //
                    if ( dwBytesIn < pmbHead->dwBytes )
                    {
                        LPBYTE pb = (LPBYTE) pvDest + dwBytesIn;
                        memset( pb, 0xFA, pmbHead->dwBytes - dwBytesIn );

                    } // if: smaller memory

                    GlobalUnlock( hMemIn );
                    GlobalUnlock( hGlobalOld );

                } // if: moveable memory
                else
                {
                    CopyMemory( hGlobalOld, hMemIn, pmbHead->dwBytes );

                    //
                    // Nuke the old memory if the allocation is to be smaller.
                    //
                    if ( dwBytesIn < pmbHead->dwBytes )
                    {
                        LPBYTE pb = (LPBYTE) hGlobalOld + dwBytesIn;
                        memset( pb, 0xFA, pmbHead->dwBytes - dwBytesIn );

                    } // if: smaller memory

                } // else: fixed memory

                pmbHead->hGlobal = hGlobalOld;

            } // if: got new memory
            else
            {
                hGlobalOld = hMemIn;

            } // else: allocation failed

        } // if: found entry
        else
        {
            DebugMessage( pszFileIn,
                          nLineIn,
                          pszModuleIn,
                          TEXT("***** Attempted to realloc 0x%08x not owned by thread (ThreadID = 0x%08x) *****\n"),
                          hMemIn,
                          GetCurrentThreadId( )
                          );

        } // else: entry not found

    } // if: something to delete

    //
    // We do this any way because the flags and input still need to be 
    // verified by GlobalReAlloc( ).
    //
    hGlobal = GlobalReAlloc( hGlobalOld, dwBytesIn, uFlagsIn );

    if ( hGlobal == NULL )
    {
        DWORD dwErr = GetLastError( );
        AssertMsg( dwErr == 0, "GlobalReAlloc() failed!" );

        if ( hMemIn != hGlobalOld )
        {
            GlobalFree( hGlobalOld );

        } // if: forced a move

        SetLastError( dwErr );

        if ( pmbHead != NULL )
        {
            //
            // Continue tracking the memory by re-adding it to the tracking list.
            //
            pmbHead->hGlobal    = hMemIn;
            pmbHead->pNext      = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            TlsSetValue( g_TraceMemoryIndex, (LPVOID) pmbHead );

        } // if: reuse the old entry
        else
        {
            //
            // Create a new block
            //
            DebugMemoryAdd( mmbtMEMORYALLOCATION,
                            hGlobalOld,
                            pszFileIn,
                            nLineIn,
                            pszModuleIn,
                            uFlagsIn,
                            dwBytesIn,
                            pszCommentIn
                            );

        } // else: make new entry
        
    } // if: allocation failed
    else 
    {
        if ( hGlobal != hMemIn )
        {
            if ( pmbHead != NULL )
            {
                //
                // Nuke the old memory
                //
                if ( pmbHead->uFlags & GMEM_MOVEABLE )
                {
                    LPVOID pv = GlobalLock( hMemIn );
                    memset( pv, 0xFA, pmbHead->dwBytes );
                    GlobalUnlock( hMemIn );
                } // if: moveable memory
                else
                {
                    memset( hMemIn, 0xFA, pmbHead->dwBytes );
                } // else: fixed memory

            } // if: entry found

            //
            // Free the old memory
            //
            GlobalFree( hMemIn );

        } // if: new memory location


        //
        // Add the allocation to the tracking table.
        //
        if ( pmbHead != NULL )
        {
            //
            // If the block is bigger, initialize the "new" memory
            //
            if ( IsTraceFlagSet( mtfMEMORYINIT )
              && dwBytesIn > pmbHead->dwBytes
               )
            {
                //
                // Initialize the expaned memory block
                //
                if ( pmbHead->uFlags & GMEM_MOVEABLE )
                {
                    LPBYTE pb = (LPBYTE) GlobalLock( hGlobal );
                    memset( pb + pmbHead->dwBytes, 0xAA, dwBytesIn - pmbHead->dwBytes );
                    GlobalUnlock( hGlobal );
                } // if: moveable memory
                else
                {
                    LPBYTE pb = (LPBYTE) hGlobal + pmbHead->dwBytes;
                    memset( pb, 0xAA, dwBytesIn - pmbHead->dwBytes );
                } // else: fixed memory

            } // if: initialize memory

            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbHead->hGlobal    = hGlobal;
            pmbHead->dwBytes    = dwBytesIn;
            pmbHead->uFlags     = uFlagsIn;
            pmbHead->pszFile    = pszFileIn;
            pmbHead->nLine      = nLineIn;
            pmbHead->pszModule  = pszModuleIn;
            pmbHead->pszComment = pszCommentIn;
            pmbHead->pNext      = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            TlsSetValue( g_TraceMemoryIndex, (LPVOID) pmbHead );

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("ReAlloced") );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            // Create a new block
            //
            DebugMemoryAdd( mmbtMEMORYALLOCATION,
                            hGlobalOld,
                            pszFileIn,
                            nLineIn,
                            pszModuleIn,
                            uFlagsIn,
                            dwBytesIn,
                            pszCommentIn
                            );

        } // else: make new entry

    } // else: allocation succeeded

    return hGlobal;

} //*** DebugRealloc( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HGLOBAL
//  DebugFree(
//      HGLOBAL     hGlobalIn
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      )
//
//  Description:
//      Replacement for Local/GlobalFree for CHKed/DEBUG builds. Removes the
//      memory allocation for the memory tracking list. Use the TraceFree
//      macro to make memory allocation switch in RETAIL. The memory of the
//      freed block will be set to 0xFE.
//
//  Arguments:
//      hGlobalIn   - Handle/pointer to memory block to free.
//      pszFileIn   - Source file path to the caller
//      nLineIn     - Line number of the caller in the source file
//      pszModuleIn - Source module name of the caller
//
//  Return Values: (see GlobalFree())
//      NULL if success.
//      Otherwise it is equal to hGlobalIn.
//
//--
//////////////////////////////////////////////////////////////////////////////
HGLOBAL
DebugFree(
    HGLOBAL     hGlobalIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtMEMORYALLOCATION, hGlobalIn, pszFileIn, nLineIn, pszModuleIn, TRUE );

    return GlobalFree( hGlobalIn );

} //*** DebugFree( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryCheck( 
//      LPVOID  pvListIn,
//      LPCTSTR pszListNameIn
//      )
//
//  Description:
//      Called just before a thread/process dies to verify that all the memory
//      allocated by the thread/process was properly freed. Anything that was
//      not freed will be listed in the debugger.
//
//      If pmbListIn is NULL, it will check the current threads tracking list.
//      The list is destroyed as it is checked.
//
//  Arguments:
//      pvListIn      - The list to check. 
//      pszListNameIn - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryCheck(
    LPVOID  pvListIn,
    LPCTSTR pszListNameIn
    )
{
    BOOL          fFoundLeak = FALSE;
    MEMORYBLOCK * pmb;

    //
    // Determine which list to use.
    //
    if ( pvListIn == NULL )
    {
        pmb = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );

    } // if: use the thread list
    else
    {
        MEMORYBLOCKLIST * pmbl = (MEMORYBLOCKLIST *) pvListIn;

        Assert( pszListNameIn != NULL );

        //
        // Make sure nobody tries to use the list again.
        //
        DebugAcquireSpinLock( &pmbl->lSpinLock );
        pmbl->fDeadList = TRUE;     
        DebugReleaseSpinLock( &pmbl->lSpinLock );

        pmb = pmbl->pmbList;
    } // else: use the given list

    //
    // Print banner if needed.
    //
    if ( pmb != NULL )
    {
        if ( pvListIn == NULL )
        {
            DebugMsg( "DEBUG: ******** Memory leak detected ******************* ThreadID = 0x%08x ********\n", GetCurrentThreadId( ) );
            DebugMsg( "DEBUG: M = Moveable, A = Address, O = Object(new), P = Punk, H = Handle, B = BSTR\n" );
            DebugMsg( "Filename(Line Number):                                                            Module     Addr/Hndl/Obj Size   Comment\n" );
                    //"         1         2         3         4         5         6         7         8                                        "
                    //"12345678901234567890123456789012345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1....."
        } // if: thread leak
        else
        {
            DebugMsg( "DEBUG: ******** Memory leak detected ******************* %s ********\n", pszListNameIn );
            DebugMsg( "DEBUG: M = Moveable, A = Address, O = Object(new), P = Punk, H = Handle, B = BSTR\n" );
            DebugMsg( "Filename(Line Number):                                                            Module     Addr/Hndl/Obj Size   Comment\n" );
                    //"         1         2         3         4         5         6         7         8                                        "
                    //"12345678901234567890123456789012345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1....."
        } // else: list leak
        fFoundLeak = TRUE;

    } // if: leak found

    //
    // Dump the entries.
    //
    while ( pmb != NULL )
    {
        LPCTSTR pszFormat;
        TCHAR   szOutput[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR   szFileLine[ cchDEBUG_OUTPUT_BUFFER_SIZE ];

        switch ( pmb->mbtType )
        {
        case mmbtMEMORYALLOCATION:
            {
                if ( pmb->uFlags & GMEM_MOVEABLE )
                {
                    pszFormat = TEXT("%-80s  %-10s M 0x%08x  %-5u  \"%s\"\n");

                } // if: moveable
                else
                {
                    pszFormat = TEXT("%-80s  %-10s A 0x%08x  %-5u  \"%s\"\n");

                } // else: fixed address
            }
            break;

        case mmbtOBJECT:
            pszFormat = TEXT("%-80s  %-10s O 0x%08x  %-5u  \"%s\"\n");
            break;

        case mmbtPUNK:
            pszFormat = TEXT("%-80s  %-10s P 0x%08x  %-5u  \"%s\"\n");
            break;

        case mmbtHANDLE:
            pszFormat = TEXT("%-80s  %-10s H 0x%08x  %-5u  \"%s\"\n");
            break;

        case mmbtSYSALLOCSTRING:
            pszFormat = TEXT("%-80s  %-10s B 0x%08x  %-5u  \"%s\"\n");
            break;

        default:
            AssertMsg( 0, "Unknown memory block type!" );
            break;
        } // switch: pmb->mbtType

        wnsprintf( szFileLine, 
                   cchDEBUG_OUTPUT_BUFFER_SIZE, 
                   g_szFileLine, 
                   pmb->pszFile, 
                   pmb->nLine 
                   );
        wnsprintf( szOutput, 
                   cchDEBUG_OUTPUT_BUFFER_SIZE, 
                   pszFormat,
                   szFileLine,
                   pmb->pszModule,
                   pmb->hGlobal,
                   pmb->dwBytes,
                   pmb->pszComment
                   );

        DebugMsg( szOutput );

        pmb = pmb->pNext;

    } // while: something in the list

    //
    // Print trailer if needed.
    //
    if ( fFoundLeak == TRUE )
    {
        DebugMsg( "DEBUG: ***************************** Memory leak detected *****************************\n\n" );

    } // if: leaking

    //
    // Assert if needed.
    //
    if ( IsDebugFlagSet( mtfMEMORYLEAKS ) )
    {
        Assert( !fFoundLeak );

    } // if: yell at leaks

} //*** DebugMemoryCheck( )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugCreateMemoryList(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPVOID *    ppvListOut,
//      LPCTSTR     pszListNameIn
//      )
//
//  Description:
//      Creates a memory block list for tracking possible "global" scope
//      memory allocations.
//
//  Arguments:
//      pszFileIn     - Source file of caller.
//      nLineIn       - Source line number of caller.
//      pszModuleIn   - Source module name of caller.
//      ppvListOut    - Location to the store address of the list head.
//      pszListNameIn - Name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugCreateMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPVOID *    ppvListOut,
    LPCTSTR     pszListNameIn
    )
{
    MEMORYBLOCKLIST * pmbl;

    Assert( ppvListOut != NULL );
    Assert( *ppvListOut == NULL );

    *ppvListOut = DebugAlloc( pszFileIn, nLineIn, pszModuleIn, GPTR, sizeof(MEMORYBLOCKLIST), TEXT("Memory Tracking List") );
    AssertMsg( * ppvListOut != NULL, "Low memory situation." );

    pmbl = (MEMORYBLOCKLIST*) *ppvListOut;

    Assert( pmbl->lSpinLock == FALSE );
    Assert( pmbl->pmbList == NULL );
    Assert( pmbl->fDeadList == FALSE );

    if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
    {
        DebugMessage( pszFileIn, nLineIn, pszModuleIn, TEXT("Created new memory list %s\n"), pszListNameIn );
    } // if: tracing

} // DebugCreateMemoryList( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryListDelete(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      HGLOBAL     hGlobalIn,
//      LPVOID      pvListIn,
//      LPCTSTR     pszListNameIn,
//      BOOL        fClobberIn
//      )
//
//  Description:
//      Removes the memory from the tracking list and adds it back to the
//      "per thread" tracking list in order to called DebugMemoryDelete( )
//      to do the proper destruction of the memory. Not highly efficent, but
//      reduces code maintenance by having "destroy" code in one (the most
//      used) location.
//
//  Arguments:
//      pszFileIn    - Source file of caller.
//      nLineIn      - Source line number of caller.
//      pszModuleIn  - Source module name of caller.
//      hGlobalIn    - Memory to be freed.
//      pvListIn     - List from which the memory is to be freed.
//      pvListNameIn - Name of the list.
//      fClobberIn   - TRUE - destroys memory; FALSE just removes from list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryListDelete(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    HGLOBAL     hGlobalIn,
    LPVOID      pvListIn,
    LPCTSTR     pszListNameIn,
    BOOL        fClobberIn
    )
{
    if ( hGlobalIn != NULL 
      && pvListIn != NULL
       )
    {
        MEMORYBLOCK *   pmbHead;

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbLast = NULL;

        Assert( pszListNameIn != NULL );

        DebugAcquireSpinLock( &pmbl->lSpinLock );
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        pmbHead = pmbl->pmbList;

        //
        // Find the memory in the memory block list
        //

        while ( pmbHead != NULL
             && pmbHead->hGlobal != hGlobalIn
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        } // while: finding the entry in the list

        //
        // Remove the memory block from the tracking list.
        //

        if ( pmbLast != NULL )
        {
            pmbLast->pNext = pmbHead->pNext;

        } // if: not first entry
        else
        {
            pmbl->pmbList = pmbHead->pNext;

        } // else: first entry

        DebugReleaseSpinLock( &pmbl->lSpinLock );

        //
        // Add it back to the per thread list.
        //

        pmbLast = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        pmbHead->pNext = pmbLast;
        TlsSetValue( g_TraceMemoryIndex, pmbHead );

        //
        // Finally delete it.
        //

        DebugMemoryDelete( pmbHead->mbtType, pmbHead->hGlobal, pszFileIn, nLineIn, pszModuleIn, fClobberIn );

    } // if: pvIn != NULL

} // DebugMemoryListDelete( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMoveToMemoryList( 
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      HGLOBAL     hGlobalIn,
//      LPVOID      pvListIn,
//      LPCTSTR     pszListNameIn
//      )
//
//  Description:
//      Moves the memory pvIn from the per thread tracking list to the thread
//      independent list "pmbListIn". Useful when memory is being handed from
//      one thread to another. Also useful for objects that live past the
//      lifetime of the thread that created them.
//
//  Arguments:
//      LPCTSTR pszFileIn   - Source file of the caller.
//      const int nLineIn   - Source line number of the caller.
//      LPCTSTR pszModuleIn - Source module name of the caller.
//      hGlobalIn           - Memory to move to list.
//      pvListIn            - The list to move to.
//      pszListNameIn       - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMoveToMemoryList( 
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    HGLOBAL     hGlobalIn, 
    LPVOID      pvListIn,
    LPCTSTR     pszListNameIn
    )
{
    if ( hGlobalIn != NULL 
      && pvListIn != NULL
       )
    {
        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        MEMORYBLOCK *   pmbLast = NULL;

        Assert( pszListNameIn != NULL );

        //
        // Find the memory in the memory block list
        //
        while ( pmbHead != NULL 
             && pmbHead->hGlobal != hGlobalIn 
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        } // while: finding the entry in the list

        AssertMsg( pmbHead != NULL, "Memory not in list. Check your code." );

        //
        // Remove the memory block from the "per thread" tracking list.
        //
        if ( pmbLast != NULL )
        {
            pmbLast->pNext = pmbHead->pNext;

        } // if: not first entry
        else
        {
            TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

        } // else: first entry

        //
        // Update the "source" data.
        //
        pmbHead->pszFile   = pszFileIn;
        pmbHead->nLine     = nLineIn;
        pmbHead->pszModule = pszModuleIn;

        //
        // Spew if needed.
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            TCHAR szMessage[ 128 ]; // random

            StrCpy( szMessage, TEXT("Transferring to ") );
            StrCat( szMessage, pszListNameIn );

            DebugMemorySpew( pmbHead, szMessage );
        } // if: tracing

        //
        // Add to list.
        //
        DebugAcquireSpinLock( &pmbl->lSpinLock );
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        pmbHead->pNext = pmbl->pmbList;
        pmbl->pmbList  = pmbHead;
        DebugReleaseSpinLock( &pmbl->lSpinLock );

    } // if: pvIn != NULL

} // DebugMoveToMemoryList( )

#if defined( USES_SYSALLOCSTRING )
//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT
//  DebugSysReAllocString( 
//      LPCTSTR         pszFileIn,
//      const int       nLineIn,
//      LPCTSTR         pszModuleIn,
//      BSTR *          pbstrIn, 
//      const OLECHAR * pszIn,
//      LPCTSTR         pszCommentIn
//      )
//
//  Description:
//      Adds memory tracing to SysReAllocString( ).
//
//  Arguments:
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrIn         - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
    //--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocString( 
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    LPCTSTR         pszCommentIn
    )
{
    BSTR bstrOld;
    BSTR bstr;

    MEMORYBLOCK *   pmbHead = NULL;
    BOOL            fReturn = FALSE;

    //
    // Some assertions that SysReAllocString( ) makes. These would be fatal
    // in retail.
    //
    Assert( pbstrIn != NULL );
    Assert( pszIn != NULL );
    Assert( pszIn < *pbstrIn || pszIn > *pbstrIn + wcslen( *pbstrIn ) + 1 );

    bstrOld = *pbstrIn;

    if ( bstrOld != NULL )
    {
        MEMORYBLOCK * pmbLast = NULL;

        pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );

        //
        // Find the memory in the memory block list
        //
        while ( pmbHead != NULL 
             && pmbHead->bstr != bstrOld
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;

        } // while: finding the entry in the list

        if ( pmbHead != NULL )
        {
            AssertMsg( pmbHead->mbtType == mmbtSYSALLOCSTRING, "You can only SysReAlloc sysstring allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbLast != NULL )
            {
                pmbLast->pNext = pmbHead->pNext;

            } // if: not first entry
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("Freeing") );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            bstrOld = SysAllocString( *pbstrIn );
            if ( bstrOld != NULL )
            {
                StrCpy( bstrOld, *pbstrIn );
                pmbHead->bstr = bstrOld;
            } // if: success
            else
            {
                bstrOld = *pbstrIn;
            } // else: failed

        } // if: found entry
        else
        {
            DebugMessage( pszFileIn,
                          nLineIn,
                          pszModuleIn,
                          TEXT("***** Attempted to SysReAlloc 0x%08x not owned by thread (ThreadID = 0x%08x) *****\n"),
                          bstrOld,
                          GetCurrentThreadId( )
                          );

        } // else: entry not found

    } // if: something to delete

    //
    // We do this any way because the flags and input still need to be 
    // verified by SysReAllocString( ).
    //
    fReturn = SysReAllocString( &bstrOld, pszIn );
    if ( ! fReturn )
    {
        DWORD dwErr = GetLastError( );
        AssertMsg( dwErr == 0, "GlobalReAlloc() failed!" );

        if ( *pbstrIn != bstrOld )
        {
            SysFreeString( bstrOld );

        } // if: forced a move

        SetLastError( dwErr );

    } // if: allocation failed
    else 
    {
        if ( bstrOld != *pbstrIn )
        {
            if ( pmbHead != NULL )
            {
                //
                // Nuke the old memory
                //
                Assert( pmbHead->dwBytes != 0 ); // invalid string
                memset( *pbstrIn, 0xFA, pmbHead->dwBytes );

            } // if: entry found

            //
            // Free the old memory
            //
            SysFreeString( *pbstrIn );

        } // if: new memory location

        if ( pmbHead != NULL )
        {
            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbHead->bstr       = bstrOld;
            pmbHead->dwBytes    = wcslen( pszIn ) + 1;
            // pmbHead->uFlags     = uFlagsIn; - not used
            pmbHead->pszFile    = pszFileIn;
            pmbHead->nLine      = nLineIn;
            pmbHead->pszModule  = pszModuleIn;
            pmbHead->pszComment = pszCommentIn;
            pmbHead->pNext      = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            TlsSetValue( g_TraceMemoryIndex, (LPVOID) pmbHead );

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("SysReAlloced") );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            // Create a new block
            //
            DebugMemoryAdd( mmbtSYSALLOCSTRING,
                            bstrOld,
                            pszFileIn,
                            nLineIn,
                            pszModuleIn,
                            0,
                            wcslen( pszIn ) + 1,
                            pszCommentIn
                            );

        } // else: make new entry

    } // else: allocation succeeded

    *pbstrIn = bstrOld;
    return fReturn;

} //*** DebugSysReAllocString( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT
//  DebugSysReAllocStringLen( 
//      LPCTSTR         pszFileIn,
//      const int       nLineIn,
//      LPCTSTR         pszModuleIn,
//      BSTR *          pbstrIn, 
//      const OLECHAR * pszIn,
//      LPCTSTR         pszCommentIn
//      )
//
//  Description:
//      Adds memory tracing to SysReAllocString( ).
//
//  Arguments:
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrIn         - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocStringLen( 
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn, 
    const OLECHAR * pszIn,
    unsigned int    ucchIn,
    LPCTSTR         pszCommentIn
    )
{
    BSTR bstrOld;
    BSTR bstr;

    MEMORYBLOCK *   pmbHead = NULL;
    BOOL            fReturn = FALSE;

    //
    // Some assertions that SysReAllocString( ) makes. These would be fatal
    // in retail.
    //
    Assert( pbstrIn != NULL );
    Assert( pszIn != NULL );
    Assert( pszIn < *pbstrIn || pszIn > *pbstrIn + ucchIn  + 1 );

    bstrOld = *pbstrIn;

    if ( bstrOld != NULL )
    {
        MEMORYBLOCK * pmbLast = NULL;

        pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );

        //
        // Find the memory in the memory block list
        //
        while ( pmbHead != NULL 
             && pmbHead->bstr != bstrOld
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;

        } // while: finding the entry in the list

        if ( pmbHead != NULL )
        {
            AssertMsg( pmbHead->mbtType == mmbtSYSALLOCSTRING, "You can only SysReAlloc sysstring allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbLast != NULL )
            {
                pmbLast->pNext = pmbHead->pNext;

            } // if: not first entry
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("Freeing") );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            bstrOld = SysAllocString( *pbstrIn );
            if ( bstrOld != NULL )
            {
                StrCpy( bstrOld, *pbstrIn );
                pmbHead->bstr = bstrOld;
            } // if: success
            else
            {
                bstrOld = *pbstrIn;
            } // else: failed

        } // if: found entry
        else
        {
            DebugMessage( pszFileIn,
                          nLineIn,
                          pszModuleIn,
                          TEXT("***** Attempted to SysReAlloc 0x%08x not owned by thread (ThreadID = 0x%08x) *****\n"),
                          bstrOld, 
                          GetCurrentThreadId( ) 
                          );

        } // else: entry not found

    } // if: something to delete

    //
    // We do this any way because the flags and input still need to be 
    // verified by SysReAllocString( ).
    //
    fReturn = SysReAllocStringLen( &bstrOld, pszIn, ucchIn );
    if ( ! fReturn )
    {
        DWORD dwErr = GetLastError( );
        AssertMsg( dwErr == 0, "GlobalReAlloc() failed!" );

        if ( *pbstrIn != bstrOld )
        {
            SysFreeString( bstrOld );

        } // if: forced a move

        SetLastError( dwErr );

    } // if: allocation failed
    else 
    {
        if ( bstrOld != *pbstrIn )
        {
            if ( pmbHead != NULL )
            {
                //
                // Nuke the old memory
                //
                Assert( pmbHead->dwBytes != 0 ); // invalid string
                memset( *pbstrIn, 0xFA, pmbHead->dwBytes );

            } // if: entry found

            //
            // Free the old memory
            //
            SysFreeString( *pbstrIn );

        } // if: new memory location

        if ( pmbHead != NULL )
        {
            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbHead->bstr       = bstrOld;
            pmbHead->dwBytes    = ucchIn;
            // pmbHead->uFlags     = uFlagsIn; - not used
            pmbHead->pszFile    = pszFileIn;
            pmbHead->nLine      = nLineIn;
            pmbHead->pszModule  = pszModuleIn;
            pmbHead->pszComment = pszCommentIn;
            pmbHead->pNext      = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            TlsSetValue( g_TraceMemoryIndex, (LPVOID) pmbHead );

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("SysReAlloced") );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            // Create a new block
            //
            DebugMemoryAdd( mmbtSYSALLOCSTRING,
                            bstrOld,
                            pszFileIn,
                            nLineIn,
                            pszModuleIn,
                            0,
                            ucchIn + 1,
                            pszCommentIn
                            );

        } // else: make new entry

    } // else: allocation succeeded

    *pbstrIn = bstrOld;
    return fReturn;

} //*** DebugSysReAllocStringLen( )
#endif // USES_SYSALLOCSTRING

//****************************************************************************
//
//  Global Management Functions -
//
//  These are in debug and retail but internally they change
//  depending on the build.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void *
//  _cdecl
//  operator new(
//      size_t      stSizeIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//      
//  Description:
//      Replacment for the operator new() in the CRTs. This should be used
//      in conjunction with the "new" macro. It will track the allocations.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
#undef new
void *
__cdecl
operator new(
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    HGLOBAL hGlobal = GlobalAlloc( GPTR, stSizeIn );

    return DebugMemoryAdd( mmbtOBJECT,
                           hGlobal,
                           pszFileIn,
                           nLineIn,
                           pszModuleIn,
                           GPTR,
                           stSizeIn,
                           TEXT(" new( ) ")
                           );

} //*** operator new( pszFileIn, etc. ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void * 
//  __cdecl 
//  operator new(
//      size_t stSizeIn
//      )
//
//  Description:
//      Stub to prevent someone from not using the "new" macro or if somehow
//      the new macro was undefined. It routine will always Assert if called.
//
//  Arguments:
//      stSizeIn    - Not used.
//
//  Return Values:
//      NULL always.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new(
    size_t stSizeIn
    )
{
    return GlobalAlloc( GPTR, stSizeIn );

} //*** operator new( ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void 
//  __cdecl 
//  operator delete(
//      void * pvIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void *      pvIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, g_szUnknown, 0, g_szUnknown, TRUE );
    GlobalFree( pvIn );

} //*** operator delete( ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  int 
//  __cdecl 
//  _purecall( void )
//
//  Description:
//      Stub for purecall functions. It will always Assert.
//
//  Arguments:
//      None.
//
//  Return Values:
//      E_UNEXPECTED always.
//
//////////////////////////////////////////////////////////////////////////////
int
__cdecl
_purecall( void )
{
    AssertMsg( 0, "Purecall" );
    return E_UNEXPECTED;

} //*** _purecall( ) - DEBUG

#else // ! DEBUG -- It's retail

//****************************************************************************
//
//  Global Management Functions -
//
//  These are the retail version.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  void *
//  _cdecl
//  operator new(
//      size_t      stSizeIn, 
//      )
//      
//  Description:
//      Replacment for the operator new() in the CRTs. Simply allocates a
//      block of memory for the object to use.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new(
    size_t stSizeIn
    )
{
    return LocalAlloc( GPTR, stSizeIn );

} //*** operator new( ) - RETAIL

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  void
//  __cdecl
//  operator delete(
//      void * pvIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. Simply frees the
//      memory.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void * pv
    )
{
    LocalFree( pv );

} //*** operator delete( ) - RETAIL

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  int 
//  __cdecl 
//  _purecall( void )
//
//  Description:
//      Stub for purecall functions.
//
//  Arguments:
//      None.
//
//  Return Values:
//      E_UNEXPECTED always.
//
//--
//////////////////////////////////////////////////////////////////////////////
int
__cdecl
_purecall( void )
{
    // BUGBUG: DavidP 08-DEC-1999 Shouldn't we assert?
    return E_UNEXPECTED;

} //*** _purecall( ) - RETAIL


#define DebugDumpWMITraceFlags( _arg )  // NOP
#define __MODULE__  NULL

//
// TODO: remove this when WMI is more dynamic
//
static const int cchDEBUG_OUTPUT_BUFFER_SIZE = 512;

#endif // DEBUG







//****************************************************************************
//****************************************************************************
//
//  Logging Functions
//
//  These are in both DEBUG and RETAIL.
//
//****************************************************************************
//****************************************************************************







//
// Constants
//
static const int LOG_OUTPUT_BUFFER_SIZE = 512;

//
// Globals
//
CRITICAL_SECTION * g_pcsLogging = NULL;

HANDLE g_hLogFile = INVALID_HANDLE_VALUE;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrLogCreateDirectoryPath(
//      LPWSTR pszDirectoryPathInOut
//      )
//
//  Descriptions:
//      Creates the directory tree as required.
//
//  Arguments:
//      pszDirectoryPathOut
//          Must be MAX_PATH big. It will contain the log file path to create.
//
//  Return Values:
//      S_OK - Success
//      other HRESULTs for failures
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLogCreateDirectoryPath(
    LPWSTR pszDirectoryPath
    )
{
    LPTSTR psz;
    BOOL   fReturn;
    DWORD  dwAttr;

    HRESULT hr = S_OK;

    //
    // Find the \ that indicates the root directory. There should be at least
    // one \, but if there isn't, we just fall through.
    //

    // skip X:\ part
    psz = wcschr( pszDirectoryPath, L'\\' );
    Assert( psz != NULL );
    if ( psz != NULL ) 
    {
        //
        // Find the \ that indicates the end of the first level directory. It's
        // probable that there won't be another \, in which case we just fall
        // through to creating the entire path.
        //
        psz = wcschr( psz + 1, L'\\' );
        while ( psz != NULL ) 
        {
            // Terminate the directory path at the current level.
            *psz = 0;

            //
            // Create a directory at the current level.
            //
            dwAttr = GetFileAttributes( pszDirectoryPath );
            if ( 0xFFFFffff == dwAttr ) 
            {
                DebugMsg( "DEBUG: Creating %s\n", pszDirectoryPath );
                fReturn = CreateDirectory( pszDirectoryPath, NULL );
                if ( ! fReturn ) 
                {
                    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                    goto Error;
                } // if: creation failed

            }  // if: directory not found
            else if ( ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
            {
                hr = THR( E_FAIL );
                goto Error;
            } // else: file found

            //
            // Restore the \ and find the next one.
            //
            *psz = L'\\';
            psz = wcschr( psz + 1, L'\\' );

        } // while: found slash

    } // if: found slash

    //
    // Create the target directory.
    //
    dwAttr = GetFileAttributes( pszDirectoryPath );
    if ( 0xFFFFffff == dwAttr ) 
    {
        fReturn = CreateDirectory( pszDirectoryPath, NULL );
        if ( ! fReturn )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );

        } // if: creation failed

    } // if: path not found

Error:
    return hr;

} //*** HrCreateDirectoryPath( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrLogOpen( void )
//
//  Description:
//      This function:
//          - initializes the log critical section
//          - enters the log critical section assuring only one thread is
//            writing to the log at a time
//          - creates the directory tree to the log file (if needed)
//          - initializes the log file by:
//              - creating a new log file if one doesn't exist.
//              - opens an existing log file (for append)
//              - appends a time/date stamp that the log was (re)opened.
//
//      Use LogClose() to exit the log critical section.
//
//      If there is a failure inside this function, the log critical
//      section will be released before returning.
//
//  Arguments:
//      None.
//
//  Return Values: 
//      S_OK - log critical section held and log open successfully
//      Otherwize HRESULT error code.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLogOpen( void )
{
    TCHAR   szFilePath[ MAX_PATH ];
    TCHAR   szModulePath[ MAX_PATH ];
    CHAR    szBuffer[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HANDLE  hTemp;
    BOOL    fReturn;
    HRESULT hr;

    SYSTEMTIME SystemTime;

    //
    // Create a critical section to prevent lines from being fragmented.
    //
    if ( g_pcsLogging == NULL ) 
    {
        PCRITICAL_SECTION pNewCritSect =
            (PCRITICAL_SECTION) LocalAlloc( LPTR, sizeof( CRITICAL_SECTION ) );
        if ( pNewCritSect == NULL ) 
        {
            DebugMsg( "DEBUG: Out of Memory. Logging disabled.\nv" );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } // if: creation failed

        InitializeCriticalSection( pNewCritSect );

        // Make sure we only have one log critical section
        InterlockedCompareExchangePointer( (PVOID *) &g_pcsLogging, pNewCritSect, 0 );
        if ( g_pcsLogging != pNewCritSect ) 
        {
            DebugMsg( "DEBUG: Another thread already created the CS. Deleting this one.\n" );
            DeleteCriticalSection( pNewCritSect );
            LocalFree( pNewCritSect );

        } // if: already have another critical section

    } // if: no critical section created yet

    Assert( g_pcsLogging != NULL );
    EnterCriticalSection( g_pcsLogging );

    //
    // Make sure the log file is open
    //
    if ( g_hLogFile == INVALID_HANDLE_VALUE ) 
    {
        DWORD  dwLen;
        LPTSTR psz;
        //
        // Create the directory tree
        //
        ExpandEnvironmentStrings( TEXT("%windir%\\debug"), szFilePath, MAX_PATH );
        hr = HrLogCreateDirectoryPath( szFilePath );
        if ( FAILED( hr ) ) 
        {
#if defined( DEBUG )
            if ( !( g_tfModule & mtfOUTPUTTODISK ) )
            {
                DebugMsg( "*ERROR* Failed to create directory tree %s\n", szFilePath );
            } // if: not logging to disk
#endif
            goto Error;
        } // if: failed

        //
        // Add filename
        //
        dwLen = GetModuleFileName( g_hInstance, szModulePath, sizeof( szModulePath ) / sizeof( szModulePath[ 0 ] ) );
        Assert( dwLen != 0 );
        StrCpy( &szModulePath[ dwLen - 3 ], TEXT("log") );
        psz = StrRChr( szModulePath, &szModulePath[ dwLen ], TEXT('\\') );
        Assert( psz != NULL );
        if ( psz == NULL )
        {
            hr = THR( E_POINTER );
            goto Error;
        }
        StrCat( szFilePath, psz );

        //
        // Create it
        //
        g_hLogFile = CreateFile( szFilePath,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_FLAG_WRITE_THROUGH,
                                 NULL 
                                 );
        if ( g_hLogFile == INVALID_HANDLE_VALUE ) 
        {
#if defined( DEBUG )
            if ( !( g_tfModule & mtfOUTPUTTODISK ) )
            {
                DebugMsg( "*ERROR* Failed to create log at %s\n", szFilePath );
            } // if: not logging to disk
#endif
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            goto Error;
        } // if: failed

        // Seek to the end
        SetFilePointer( g_hLogFile, 0, NULL, FILE_END );

        //
        // Write the time/date the log was (re)openned.
        //
        GetLocalTime( &SystemTime );
        wnsprintfA( szBuffer,
                    LOG_OUTPUT_BUFFER_SIZE,
                    "*\n* %02u/%02u/%04u %02u:%02u:%02u.%03u\n*\n",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond,
                    SystemTime.wMilliseconds
                    );

        fReturn = WriteFile( g_hLogFile, szBuffer, StrLenA(szBuffer), &dwWritten, NULL );
        if ( ! fReturn ) 
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
            goto Error;
        } // if: failed

        DebugMsg( "DEBUG: Created log at %s\n", szFilePath );

    } // if: file not already openned

    hr = S_OK;

Cleanup:
    return hr;
Error:
    DebugMsg( "LogOpen: Failed hr = 0x%08x\n", hr );
    if ( g_hLogFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open
    LeaveCriticalSection( g_pcsLogging );
    goto Cleanup;

} //*** HrLogOpen( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrLogClose( void )
//
//  Description:
//      This actually just leaves the log critical section.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLogClose( void )
{
    Assert( g_pcsLogging != NULL );
    LeaveCriticalSection( g_pcsLogging );
    return S_OK;

} //*** HrLogClose( )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  LogDateTime( void )
//
//  Description:
//      Adds date/time stamp to the log without a CR. This should be done
//      while holding the Logging critical section which is done by calling
//      HrLogOpen( ).
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogDateTime( void )
{
    static CHAR       szBuffer[ 25 ];
    static SYSTEMTIME OldSystemTime = { 0 };
    static DWORD      dwWritten;

    SYSTEMTIME SystemTime;
    DWORD      dwWhoCares;
    int        iCmp;

    GetLocalTime( &SystemTime );

    //
    // Avoid expensive printf by comparing times
    //
    iCmp = memcmp( (PVOID) &SystemTime, (PVOID) &OldSystemTime, sizeof( SYSTEMTIME ) );
    if ( iCmp != 0 )
    {
        dwWritten = wnsprintfA( szBuffer,
                                LOG_OUTPUT_BUFFER_SIZE,
                                "%02u/%02u/%04u %02u:%02u:%02u.%03u ",
                                SystemTime.wMonth,
                                SystemTime.wDay,
                                SystemTime.wYear,
                                SystemTime.wHour,
                                SystemTime.wMinute,
                                SystemTime.wSecond,
                                SystemTime.wMilliseconds
                                );
        Assert( dwWritten < 25 && dwWritten != -1 );

        CopyMemory( (PVOID) &OldSystemTime, (PVOID) &SystemTime, sizeof( SYSTEMTIME ) );

    } // if: time last different from this time

    WriteFile( g_hLogFile, szBuffer, dwWritten, &dwWhoCares, NULL );

} //*** LogDateTime( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  void
//  LogMsg(
//      LPCSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Logs a message to the log file.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogMsg(
    LPCSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szFormat[ LOG_OUTPUT_BUFFER_SIZE ];
    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    mbstowcs( szFormat, pszFormat, StrLenA( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, szFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == - 1 )
    {
        dwWritten = StrLenA( szBuf );
    } // if: bad character found
#else
    va_start( valist, pszFormat );
    dwWritten = wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

    hr = HrLogOpen( );
    if ( hr != S_OK ) 
    {
        return;
    } // if: failed

    // LogDateTime( );
    WriteFile( g_hLogFile, szBuf, dwWritten, &dwWritten, NULL );

    HrLogClose( );

} //*** LogMsg( ) ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  void
//  LogMsg(
//      LPCWSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Logs a message to the log file.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogMsg(
    LPCWSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, pszFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == -1 )
    {
        dwWritten = StrLenA( szBuf );
    } // if: bad character found
#else
    CHAR szFormat[ LOG_OUTPUT_BUFFER_SIZE ];

    wcstombs( szFormat, pszFormat, wcslen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    dwWritten = wvsprintf( szBuf, szFormat, valist);
    va_end( valist );

#endif // UNICODE

    hr = HrLogOpen( );
    if ( hr != S_OK ) 
    {
        return;
    } // if: failed

    // LogDateTime( );
    WriteFile( g_hLogFile, szBuf, dwWritten, &dwWritten, NULL );

    HrLogClose( );

} //*** LogMsg( ) UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  LogTerminiateProcess( void )
//
//  Description:
//      Cleans up anything the logging routines may have created or 
//      initialized. Typical called from the TraceTerminateProcess() macro.
//
//  Arugments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogTerminateProcess( void )
{
} //*** LogTerminateProcess( )









//****************************************************************************
//
//  WMI Tracing Routines
//
//  These routines are in both DEBUG and RETAIL versions.
//
//****************************************************************************










//////////////////////////////////////////////////////////////////////////////
//++
//
//  ULONG
//  UlWMIControlCallback(
//      IN WMIDPREQUESTCODE RequestCode,
//      IN PVOID            RequestContext,
//      IN OUT ULONG *      BufferSize,
//      IN OUT PVOID        Buffer
//      )
//
//  Description:
//      WMI's tracing control callback entry point.
//
//  Arguments:
//      See EVNTRACE.H
//
//  Return Values:
//      ERROR_SUCCESS           - success.
//      ERROR_INVALID_PARAMETER - invalid RequestCode passed in.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
WINAPI
UlWMIControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID            RequestContext,
    IN OUT ULONG *      BufferSize,
    IN OUT PVOID        Buffer
    )
{
    ULONG ulResult = ERROR_SUCCESS;
    DEBUG_WMI_CONTROL_GUIDS * pdwcg = (DEBUG_WMI_CONTROL_GUIDS *) RequestContext;
    
    switch ( RequestCode )
    {
    case WMI_ENABLE_EVENTS:
        {
            TRACEHANDLE hTrace;

            if ( pdwcg->hTrace == NULL )
            {
                hTrace = GetTraceLoggerHandle( Buffer );

            } // if:
            else
            {
                hTrace = pdwcg->hTrace;

            } // else:

            pdwcg->dwFlags = GetTraceEnableFlags( hTrace );
            pdwcg->bLevel  = GetTraceEnableLevel( hTrace );
            if ( pdwcg->dwFlags == 0 )
            {
                if ( pdwcg->pMapLevelToFlags != NULL 
                  && pdwcg->bSizeOfLevelList != 0 
                   )
                {
                    if ( pdwcg->bLevel >= pdwcg->bSizeOfLevelList )
                    {
                        pdwcg->bLevel = pdwcg->bSizeOfLevelList - 1;
                    }

                    pdwcg->dwFlags = pdwcg->pMapLevelToFlags[ pdwcg->bLevel ].dwFlags;
                    DebugMsg( "DEBUG: WMI tracing level set to %u - %s, flags = 0x%08x\n", 
                              pdwcg->pszName,
                              pdwcg->bLevel, 
                              pdwcg->pMapLevelToFlags[ pdwcg->bLevel ].pszName, 
                              pdwcg->dwFlags 
                              );

                } // if: level->flag mapping available
                else
                {
                    DebugMsg( "DEBUG: WMI tracing level set to %u, flags = 0x%08x\n", 
                              pdwcg->pszName,
                              pdwcg->bLevel, 
                              pdwcg->dwFlags 
                              );

                } // else: no mappings

            } // if: no flags set
            else
            {
                DebugMsg( "DEBUG: WMI tracing level set to %u, flags = 0x%08x\n", 
                          pdwcg->pszName,
                          pdwcg->bLevel, 
                          pdwcg->dwFlags 
                          );

            } // else: flags set

            DebugDumpWMITraceFlags( pdwcg );

            pdwcg->hTrace  = hTrace;

        } // WMI_ENABLE_EVENTS
        break;

    case WMI_DISABLE_EVENTS:
        pdwcg->dwFlags = 0;
        pdwcg->bLevel  = 0;
        pdwcg->hTrace  = NULL;
        DebugMsg( "DEBUG: %s WMI tracing disabled.\n", pdwcg->pszName );
        break;

    default:
        ulResult = ERROR_INVALID_PARAMETER;
        break;

    } // switch: RequestCode

    return ulResult;

} //*** UlWMIControlCallback( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMIInitializeTracing(
//      DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
//      int                     nCountOfCOntrolGuidsIn
//      )
//
//  Description:
//      Initialize the WMI tracing.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
WMIInitializeTracing(
    DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
    int                     nCountOfControlGuidsIn
    )
{
    TCHAR szPath[ MAX_PATH ];
    ULONG ulStatus;
    int   nCount;
    

#if defined( DEBUG )
    static BOOL fRegistered = FALSE;
    AssertMsg( fRegistered == FALSE, "Re-entrance into InitializeWMITracing!!!" );
#endif // DEBUG

    GetModuleFileName( g_hInstance, szPath, MAX_PATH );

    for( nCount = 0; nCount < nCountOfControlGuidsIn; nCount++ )
    {
        TRACE_GUID_REGISTRATION * pList;
        pList = (TRACE_GUID_REGISTRATION *) 
            LocalAlloc( LMEM_FIXED, 
                        sizeof( TRACE_GUID_REGISTRATION ) * dwcgControlListIn[ nCount ].dwSizeOfTraceList );

        if ( pList != NULL )
        {
            CopyMemory( pList, 
                        dwcgControlListIn[ nCount ].pTraceList, 
                        sizeof( TRACE_GUID_REGISTRATION ) * dwcgControlListIn[ nCount ].dwSizeOfTraceList );

            ulStatus = RegisterTraceGuids( UlWMIControlCallback,                            // IN  RequestAddress
                                           dwcgControlListIn,                               // IN  RequestContext
                                           dwcgControlListIn[ nCount ].guidControl,         // IN  ControlGuid
                                           dwcgControlListIn[ nCount ].dwSizeOfTraceList,   // IN  GuidCount
                                           pList,                                           // IN  GuidReg
                                           (LPCTSTR) szPath,                                // IN  MofImagePath
                                           __MODULE__,                                      // IN  MofResourceName
                                           &dwcgControlListIn[ nCount ].hRegistration       // OUT RegistrationHandle
                                           );

            AssertMsg( ulStatus == ERROR_SUCCESS, "Trace registration failed\n" );

            LocalFree( pList );
        } // if: list allocated successfully
    } // for: each control GUID

#if defined( DEBUG )
    fRegistered = TRUE;
#endif // DEBUG

} //*** WMIInitializeTracing( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMITerminateTracing(
//      DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
//      int                     nCountOfCOntrolGuidsIn
//      )
//
//  Description:
//      Terminates WMI tracing and unregisters the interfaces.
//
//  Arguments:
//      dwcgControlListIn       - 
//      nCountOfControlGuidsIn  - 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
WMITerminateTracing(
    DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
    int                     nCountOfControlGuidsIn
    )
{
    int nCount;

    for( nCount = 0; nCount < nCountOfControlGuidsIn; nCount++ )
    {
        dwcgControlListIn[ nCount ].dwFlags = 0;
        dwcgControlListIn[ nCount ].bLevel  = 0;
        dwcgControlListIn[ nCount ].hTrace  = NULL;
        UnregisterTraceGuids( dwcgControlListIn[ nCount ].hRegistration );
    } // for: each control GUID

} //*** WMITerminateTracing( )


typedef struct
{
    EVENT_TRACE_HEADER    EHeader;                              // storage for the WMI trace event header
    BYTE                  bSize;                                // Size of the string - MAX 255!
    WCHAR                 szMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ]; // Message
} DEBUG_WMI_EVENT_W;

typedef struct
{
    EVENT_TRACE_HEADER    EHeader;                              // storage for the WMI trace event header
    BYTE                  bSize;                                // Size of the string - MAX 255!
    CHAR                  szMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ]; // Message
} DEBUG_WMI_EVENT_A;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMIMessageByFlags(
//      DEBUG_WMI_CONTROL_GUIDS *   pEntryIn,
//      const DWORD                 dwFlagsIn,
//      LPCWSTR                     pszFormatIn,
//      ...
//      )
//
//  Description:
//
//  Arguments:
//      pEntry      - 
//      dwFlagsIn   - 
//      pszFormatIn - 
//      ...         - 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
WMIMessageByFlags(
    DEBUG_WMI_CONTROL_GUIDS *   pEntry,
    const DWORD                 dwFlagsIn,
    LPCWSTR                     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( pEntry->hTrace == NULL )
    {
        return; // NOP
    } // if: no trace logger

    if ( dwFlagsIn == mtfALWAYS
      || pEntry->dwFlags & dwFlagsIn
       )
    {
        ULONG ulStatus;
        DEBUG_WMI_EVENT_W DebugEvent;
        PEVENT_TRACE_HEADER peth = (PEVENT_TRACE_HEADER ) &DebugEvent;
        PWNODE_HEADER pwnh = (PWNODE_HEADER) &DebugEvent;

        ZeroMemory( &DebugEvent, sizeof( DebugEvent ) );

#ifndef UNICODE
        TCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        wvnsprintf( DebugEvent.szMsg, 256,szFormat, valist);
        va_end( valist );
#else
        va_start( valist, pszFormatIn );
        wvnsprintf( DebugEvent.szMsg, 256,pszFormatIn, valist);
        va_end( valist );
#endif // UNICODE

        //
        // Fill in the blanks
        //
        DebugEvent.bSize    = (BYTE) wcslen( DebugEvent.szMsg );
        peth->Size          = sizeof( DebugEvent );
        peth->Class.Type    = 10;
        peth->Class.Level   = pEntry->bLevel;
        // peth->Class.Version = 0;
        // peth->ThreadId      = GetCurrentThreadId( ); - done by system
        pwnh->Guid          = *pEntry->guidControl;
        // peth->ClientContext = NULL;
        pwnh->Flags         = WNODE_FLAG_TRACED_GUID;

        // GetSystemTimeAsFileTime( (FILETIME *) &peth->TimeStamp ); - done by the system

        ulStatus = TraceEvent( pEntry->hTrace, (PEVENT_TRACE_HEADER) &DebugEvent );

    } // if: flags set

} //*** WMIMsg( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMIMessageByFlagsAndLevel(
//      DEBUG_WMI_CONTROL_GUIDS *   pEntry,
//      const DWORD                 dwFlagsIn,
//      const BYTE                  bLogLevelIn,
//      LPCWSTR                     pszFormatIn,
//      ...
//      )
//
//  Description:
//
//  Arguments:
//      pEntry      - 
//      dwFlagsIn   - 
//      bLogLevelIn - 
//      pszFormatIn - 
//      ...         - 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
WMIMessageByFlagsAndLevel(
    DEBUG_WMI_CONTROL_GUIDS *   pEntry,
    const DWORD                 dwFlagsIn,
    const BYTE                  bLogLevelIn,
    LPCWSTR                     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( pEntry->hTrace == NULL )
    {
        return; // NOP
    } // if: no trace logger

    if ( bLogLevelIn > pEntry->bLevel )
    {
        return; // NOP
    } // if: level not high enough

    if ( dwFlagsIn == mtfALWAYS
      || pEntry->dwFlags & dwFlagsIn 
       )
    {
        ULONG               ulStatus;
        DEBUG_WMI_EVENT_W   DebugEvent;
        PEVENT_TRACE_HEADER peth = (PEVENT_TRACE_HEADER ) &DebugEvent;
        PWNODE_HEADER       pwnh = (PWNODE_HEADER) &DebugEvent;

        ZeroMemory( &DebugEvent, sizeof( DebugEvent ) );

#ifndef UNICODE
        TCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        wvnsprintf( DebugEvent.szMsg, 256,szFormat, valist);
        va_end( valist );
#else
        va_start( valist, pszFormatIn );
        wvnsprintf( DebugEvent.szMsg, 256,pszFormatIn, valist);
        va_end( valist );
#endif // UNICODE

        //
        // Fill in the blanks
        //
        DebugEvent.bSize    = (BYTE) wcslen( DebugEvent.szMsg );
        peth->Size          = sizeof( DebugEvent );
        peth->Class.Type    = 10;
        peth->Class.Level   = pEntry->bLevel;
        // peth->Class.Version = 0;
        // peth->ThreadId      = GetCurrentThreadId( ); - done by system
        pwnh->Guid          = *pEntry->guidControl;
        // peth->ClientContext = NULL;
        pwnh->Flags         = WNODE_FLAG_TRACED_GUID;

        // GetSystemTimeAsFileTime( (FILETIME *) &peth->TimeStamp ); - done by the system

        ulStatus = TraceEvent( pEntry->hTrace, (PEVENT_TRACE_HEADER) &DebugEvent );

    } // if: flags set

} //*** WMIMessageByFlagsAndLevel( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMIMessageByLevel(
//      DEBUG_WMI_CONTROL_GUIDS *   pEntry,
//      const BYTE                  bLogLevelIn,
//      LPCWSTR                     pszFormatIn,
//      ...
//      )
//
//  Description:
//
//  Arguments:
//      pEntry      - 
//      bLogLevelIn - 
//      pszFormatIn - 
//      ...         - 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
WMIMessageByLevel(
    DEBUG_WMI_CONTROL_GUIDS * pEntry,
    const BYTE bLogLevelIn,
    LPCWSTR pszFormatIn,
    ...
    )
{
    ULONG ulStatus;
    DEBUG_WMI_EVENT_W DebugEvent;
    PEVENT_TRACE_HEADER peth = (PEVENT_TRACE_HEADER ) &DebugEvent;
    PWNODE_HEADER pwnh = (PWNODE_HEADER) &DebugEvent;
    va_list valist;

    if ( pEntry->hTrace == NULL )
    {
        return; // NOP
    } // if: no trace logger

    if ( bLogLevelIn > pEntry->bLevel )
    {
        return; // NOP
    } // if: level no high enough

    ZeroMemory( &DebugEvent, sizeof( DebugEvent ) );

#ifndef UNICODE
    TCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    wvnsprintf( DebugEvent.szMsg, 256,szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormatIn );
    wvnsprintf( DebugEvent.szMsg, 256,pszFormatIn, valist);
    va_end( valist );
#endif // UNICODE

    //
    // Fill in the blanks
    //
    DebugEvent.bSize    = (BYTE) wcslen( DebugEvent.szMsg );
    peth->Size          = sizeof( DebugEvent );
    peth->Class.Type    = 10;
    peth->Class.Level   = pEntry->bLevel;
    // peth->Class.Version = 0;
    // peth->ThreadId      = GetCurrentThreadId( ); - done by system
    pwnh->Guid          = *pEntry->guidControl;
    // peth->ClientContext = NULL;
    pwnh->Flags         = WNODE_FLAG_TRACED_GUID;

    // GetSystemTimeAsFileTime( (FILETIME *) &peth->TimeStamp ); - done by the system

    ulStatus = TraceEvent( pEntry->hTrace, (PEVENT_TRACE_HEADER) &DebugEvent );

} //*** WMIMessageByLevel( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\guids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      GUIDS.H
//
//  Description:
//      Guid definition file.
//
//  Maintained By:
//      Geoffrey Pease (GPEASE) 22-NOV-1999
//
//  Notes:
//      File gets re-include after INITGUID.H is included in GUIDS.CPP. You
//      should not use "#pragma once" in this file.
//
//////////////////////////////////////////////////////////////////////////////

// not pragma once
#ifndef _GUIDS_H_
#define _GUIDS_H_

//
// External CLSIDs
//


#endif // _GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\debug.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.h
//
//  Description:
//      Debugging utilities header.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// KB: USES_SYSALLOCSTRING gpease 8-NOV-1999
//      Turn this on if you are going to use the OLE automation
//      functions: SysAllocString, SysFreeString, etc..
//
// #define USES_SYSALLOCSTRING

//
// WMI tracing needs these defined
//
#include <wmistr.h>
#include <evntrace.h>

//
// Trace Flags
//
typedef enum _TRACEFLAGS
{
    mtfALWAYS           = 0xFFFFFFFF,
    mtfNEVER            = 0x00000000,
    // function entry/exits, call, scoping
    mtfCALLS            = 0x00000001,   // Function calls that use the TraceMsgDo macro
    mtfFUNC             = 0x00000002,   // Functions entrances w/parameters
    mtfQUERYINTERFACE   = 0x00000004,   // Query Interface details
    mtfSTACKSCOPE       = 0x00000008,   // if set, debug spew will generate bar/space for level each of the call stack
    // other
    mtfWM               = 0x00000010,   // Window Messages
    mtfDLL              = 0x00000020,   // DLL specific
    mtfASSERT_HR        = 0x00000040,   // Assert if HRESULT is an error
    // memory
    mtfMEMORYLEAKS      = 0x01000000,   // Halts when a memory leak is detected on thread exit.
    mtfMEMORYINIT       = 0x02000000,   // Initializes new memory allocations
    mtfMEMORYALLOCS     = 0x04000000,   // Turns on spew to display each de/allocation.
    // citracker spew
    mtfCITRACKERS       = 0x08000000,   // CITrackers will spew entrances and exits
    // output prefixes
    mtfADDTIMEDATE      = 0x10000000,   // Replaces Filepath(Line) with Date/Time
    mtfBYMODULENAME     = 0x20000000,   // Puts the module name at the beginning of the line
    // per thread
    mtfPERTHREADTRACE   = 0x40000000,   // Enables per thread tracing
    // ouput to disk
    mtfOUTPUTTODISK     = 0x80000000,   // Logs output to disk
} TRACEFLAGS;

typedef DWORD TRACEFLAG;

#ifdef DEBUG

#pragma message( "BUILD: DEBUG macros being built" )

//
// Globals
//
extern DWORD         g_TraceMemoryIndex;    // TLS index for the memory tracking link list
extern DWORD         g_dwCounter;           // Stack depth counter
extern TRACEFLAG     g_tfModule;            // Global tracing flags
extern const LPCTSTR g_pszModuleIn;         // Local module name - use DEFINE_MODULE
extern const TCHAR   g_szTrue[];            // Array "TRUE"
extern const TCHAR   g_szFalse[];           // Array "FALSE"

//
// Definition Macros
//
#define DEFINE_MODULE( _module )    const LPCTSTR g_pszModuleIn = TEXT(_module);
#define __MODULE__                  g_pszModuleIn
#define DEFINE_THISCLASS( _class )  static const TCHAR g_szClass[] = TEXT(_class);
#define __THISCLASS__               g_szClass
#define DEFINE_BASECLASS( _class )  static const TCHAR g_szBaseClass[] = TEXT(_class);
#define __BASECLASS__               g_szBaseClass

//
// ImageHlp Stuff - not ready for prime time yet.
//
#if defined( IMAGEHLP_ENABLED )
#include <imagehlp.h>
typedef BOOL ( * PFNSYMGETSYMFROMADDR )( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL );
typedef BOOL ( * PFNSYMGETLINEFROMADDR )( HANDLE, DWORD, PDWORD, PIMAGEHLP_LINE );
typedef BOOL ( * PFNSYMGETMODULEINFO )( HANDLE, DWORD, PIMAGEHLP_MODULE );

extern HINSTANCE                g_hImageHlp;                // IMAGEHLP.DLL instance handle
extern PFNSYMGETSYMFROMADDR     g_pfnSymGetSymFromAddr;
extern PFNSYMGETLINEFROMADDR    g_pfnSymGetLineFromAddr;
extern PFNSYMGETMODULEINFO      g_pfnSymGetModuleInfo;
#endif // IMAGEHLP_ENABLED


void
DebugIncrementStackDepthCounter( void );

void
DebugDecrementStackDepthCounter( void );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceInitializeProcess(
//      _rgControl,
//      _sizeofControl
//      )
//
//  Description:
//      Should be called in the DLL main on process attach or in the entry
//      routine of an EXE. Initializes debugging globals and TLS. Registers
//      the WMI tracing facilities.
//
//  Arguments:
//      _rgControl      WMI control block (see DEBUG_WMI_CONTROL_GUIDS)
//      _sizeofControl  The sizeof( _rgControl )
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceInitializeProcess( _rgControl, _sizeofControl ) \
    { \
        DebugInitializeTraceFlags( ); \
        WMIInitializeTracing( _rgControl, _sizeofControl ); \
    }

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceInitializeThread(
//      _name
//      )
// 
//  Description:
//      Should be called in the DLL thread attach or when a new thread is
//      created. Sets up the memory tracing for that thread as well as
//      establishing the tfThread for each thread (if mtfPERTHREADTRACE
//      is set in g_tfModule).
//
//  Arguments:
//      _name       NULL or the name of the thread.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceInitializeThread( _name ) \
    do \
    { \
        TlsSetValue( g_TraceMemoryIndex, NULL); \
        DebugInitializeThreadTraceFlags( _name ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceRundownThread( void )
//
//  Description:
//      Should be called before a thread terminates. It will check to make 
//      sure all memory allocated by the thread was released properly. It
//      will also cleanup any per thread structures.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceRundownThread( ) \
    do \
    { \
        DebugMemoryCheck( NULL, NULL ); \
        DebugTerminiateThreadTraceFlags( ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceCreateMemoryList(
//      _pmbIn
//      )
//
//  Description:
//      Creates a thread independent list to track objects.
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceCreateMemoryList( _pmbIn ) \
    DebugCreateMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, &_pmbIn, TEXT(#_pmbIn) );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateMemoryList(
//      _pmbIn
//      )
//
//  Description:
//      Checks to make sure the list is empty before destroying the list.
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _pmbIn is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceTerminateMemoryList( _pmbIn ) \
    do \
    { \
        DebugMemoryCheck( _pmbIn, TEXT(#_pmbIn) ); \
        DebugFree( _pmbIn, TEXT(__FILE__), __LINE__, __MODULE__ ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMoveToMemoryList(
//      _addr
//      _pmbIn
//      )
//
//  Description:
//      Moves and object from the thread tracking list to a thread independent
//      memory list (_pmbIn).
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to move.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMoveToMemoryList( _addr, _pmbIn ) \
    DebugMoveToMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn) );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMemoryListDelete(
//      _addr
//      _pmbIn
//      )
//
//  Description:
//      Moves and object from the thread tracking list to a thread independent
//      memory list (_pmbIn).
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to delete.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMemoryListDelete( _addr, _pmbIn, _fClobberIn ) \
    DebugMemoryListDelete( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn), _fClobberIn );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateProcess
//
//  Description:
//      Should be called before a process terminates. It cleans up anything
//      that the Debug APIs created. It will check to make sure all memory 
//      allocated by the main thread was released properly. It will also 
//      terminate WMI tracing. It also closes the logging handle.
//
//  Arguments:
//      _rgControl     - WMI control block (see DEBUG_WMI_CONTROL_GUIDS)
//      _sizeofControl - the sizeof( _rgControl )
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceTerminateProcess( _rgControl, _sizeofControl ) \
    do \
    { \
        LogTerminateProcess( ); \
        WMITerminateTracing( _rgControl, _sizeofControl ); \
        DebugMemoryCheck( NULL, NULL ); \
        DebugTerminateProcess( ); \
    } while ( 0 )

//****************************************************************************
//
// Debug initialization routines
//
// Uses should use the TraceInitializeXXX and TraceTerminateXXX macros, not
// these routines.
//
//****************************************************************************
void
DebugInitializeTraceFlags( void );

void
DebugInitializeThreadTraceFlags(
    LPCTSTR pszThreadNameIn
    );

void
DebugTerminateProcess( void );

void
DebugTerminiateThreadTraceFlags( void );

void
DebugCreateMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPVOID *    ppvListOut,
    LPCTSTR     pszListNameIn
    );

void
DebugMemoryListDelete(
    LPCTSTR pszFileIn,
    const int nLineIn,
    LPCTSTR pszModuleIn,
    HGLOBAL hGlobalIn,
    LPVOID  pvListIn,
    LPCTSTR pszListNameIn,
    BOOL    fClobberIn
    );

void
DebugMoveToMemoryList( 
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    HGLOBAL     hGlobal, 
    LPVOID      pmbListIn,
    LPCTSTR     pszListNameIn
    );

//****************************************************************************
//
// Memmory Allocation Subsitution Macros
//
// Replaces LocalAlloc/LocalFree and GlobalAlloc/GlobalFree
//
//****************************************************************************
#define TraceAlloc( _flags, _size )             DebugAlloc( TEXT(__FILE__), __LINE__, __MODULE__, _flags, _size, TEXT(#_size) )
#define TraceReAlloc( _hmem, _size, _flags )    DebugReAlloc( TEXT(__FILE__), __LINE__, __MODULE__, _hmem, _flags, _size, TEXT(#_size) )
#define TraceFree( _hmem )                      DebugFree( _hmem, TEXT(__FILE__), __LINE__, __MODULE__ )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceAllocString(
//      _flags,
//      _size
//      )
//
//  Description:
//      Quick way to allocation a string that is the proper size and that will
//      be tracked by memory tracking.
//
//  Arguments:
//      _flags  - Allocation attributes.
//      _size   - Number of characters in the string to be allocated.
//
//  Return Values:
//      Handle/pointer to memory to be used as a string.
//
//////////////////////////////////////////////////////////////////////////////
#define TraceAllocString( _flags, _size ) \
    (LPTSTR) DebugAlloc( TEXT(__FILE__), \
                         __LINE__, \
                         __MODULE__, \
                         _flags, \
                         (_size) * sizeof( TCHAR ), \
                         TEXT(#_size) \
                         )

//****************************************************************************
//
// Code Tracing Macros
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFunc(
//      _pszfn
//      )
//
//  Description:
//      Displays file, line number, module and "_pszfn" only if the mtfFUNC is
//      set in g_tfModule. "_pszfn" is the name of the function just
//      entered. It also increments the stack counter.
//
//  Arguments:
//      _pszfn  - Name of the function just entered.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFunc( _pszfn ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(_pszfn) ); \
        } \
    } while ( 0 )

//
// These next macros are just like TraceFunc except they take additional
// arguments to display the values passed into the function call. "_pszfn"
// should contain a printf string on how to display the arguments.
//
#define TraceFunc1( _pszfn, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(_pszfn), _arg1 ); \
        } \
    } while ( 0 )

#define TraceFunc2( _pszfn, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(_pszfn), _arg1, _arg2 ); \
        } \
    } while ( 0 )

#define TraceFunc3( _pszfn, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(_pszfn), _arg1, _arg2, _arg3 ); \
        } \
    } while ( 0 )

#define TraceFunc4( _pszfn, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(_pszfn), _arg1, _arg2, _arg3, _arg4 ); \
        } \
    } while ( 0 )

#define TraceFunc5( _pszfn, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(_pszfn), _arg1, _arg2, _arg3, _arg4, arg5 ); \
        } \
    } while ( 0 )

#define TraceFunc6( _pszfn, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(_pszfn), _arg1, _arg2, _arg3, _arg4, arg5, arg6 ); \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceClsFunc(
//      _pszfn
//      )
//
//  Description:
//      Displays file, line number, module, class name and "_msg" only if the
//      mtfFUNC is set in g_tfModule. It also increments the stack counter
//
//  Arguments:
//      _pszfn - Name of the method just entered.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceClsFunc( _pszfn ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ %s::") TEXT(_pszfn), g_szClass ); \
        } \
    } while ( 0 )

//
// These next macros are just like TraceClsFunc except they take additional
// arguments to display the values passed into the function call. "_pszfn"
// should contain a printf string on how to display the arguments.
//
#define TraceClsFunc1( _pszfn, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ %s::") TEXT(_pszfn), g_szClass, _arg1 ); \
        } \
    } while ( 0 )

#define TraceClsFunc2( _pszfn, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ %s::") TEXT(_pszfn), g_szClass, _arg1, _arg2 ); \
        } \
    } while ( 0 )

#define TraceClsFunc3( _pszfn, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ %s::") TEXT(_pszfn), g_szClass, _arg1, _arg2, _arg3 ); \
        } \
    } while ( 0 )

#define TraceClsFunc4( _pszfn, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ %s::") TEXT(_pszfn), g_szClass, _arg1, _arg2, _arg3, _arg4 ); \
        } \
    } while ( 0 )

#define TraceClsFunc5( _pszfn, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ %s::") TEXT(_pszfn), g_szClass, _arg1, _arg2, _arg3, _arg4, _arg5 ); \
        } \
    } while ( 0 )

#define TraceClsFunc6( _pszfn, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ %s::") TEXT(_pszfn), g_szClass, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFuncExit( void )
//
//  Description:
//      Return macro for TraceFunc() and TraceClsFunc() if the return type is
//      void. It also decrements the stack counter.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFuncExit( ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V\n") ); \
            DebugDecrementStackDepthCounter( ); \
        } \
        return; \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  RETURN(
//      _rval
//      )
//
//  Description:
//      Return macro for TraceFunc() and TraceClsFunc(). The _rval will be
//      returned as the result of the function. It also decrements the stack
//      counter.
//
//  Arguments:
//      _rval   - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define RETURN( _rval ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V\n") ); \
            DebugDecrementStackDepthCounter( ); \
        } \
        return _rval; \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  FRETURN(
//      _rval
//      )
//
//  Description:
//      This is a fake version of the return macro for TraceFunc() and
//      TraceClsFunc(). *** This doesn't return. *** It also decrements
//      the stack counter.
//
//  Arguments:
//      _rval   - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define FRETURN( _rval ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V\n") ); \
            DebugDecrementStackDepthCounter( ); \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  HRETURN(
//      _hr
//      )
//
//  Description:
//      Return macro for TraceFunc() and TraceClsFunc(). The _hr will be
//      returned as the result of the function. If the value is not S_OK, it 
//      will be displayed in the debugger. It also decrements the stack
//      counter.
//
//  Arguments:
//      _hr - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define HRETURN( _hr ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            if ( _hr != S_OK ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)\n"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V\n") ); \
            } \
            DebugDecrementStackDepthCounter( ); \
        } \
        return _hr; \
    } while ( 0 )

//
// These next macros are just like HRETURN except they allow other
// exceptable values to be passed.back without causing extra spew.
//
#define HRETURN1( _hr, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)\n"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V\n") ); \
            } \
            DebugDecrementStackDepthCounter( ); \
        } \
        return _hr; \
    } while ( 0 )

#define HRETURN2( _hr, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) && ( _hr != _arg2 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)\n"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V\n") ); \
            } \
            DebugDecrementStackDepthCounter( ); \
        } \
        return _hr; \
    } while ( 0 )

#define HRETURN3( _hr, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) && ( _hr != _arg2 ) && ( _hr != _arg3 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)\n"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V\n") ); \
            } \
            DebugDecrementStackDepthCounter( ); \
        } \
        return _hr; \
    } while ( 0 )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceDo(
//      _szExp
//      )
//
//  Description:
//      Displays the file, line number, module and function call and return
//      from the function call (no return value displayed) for "_szExp" only
//      if the mtfCALLS is set in g_tfModule. Note return value is not
//      displayed. _szExp will be in RETAIL version of the product.
//
//  Arguments:
//      _szExp
//          The expression to be traced including assigment to the return
//          variable.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceDo( _szExp ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_szExp ) TEXT("\n") ); \
            _szExp; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("V\n") ); \
            DebugDecrementStackDepthCounter( ); \
        } \
        else \
        { \
            _szExp; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgDo(
//      _szExp,
//      _szMsg
//      )
//
//  Description:
//      Displays the file, line number, module and function call and return
//      value which is formatted in "_szMsg" for "_szExp" only if the mtfCALLS
//      is set in g_tfModule. _szExp will be in the RETAIL version of the
//      product.
//
//  Arguments:
//      _szExp
//          The expression to be traced including assigment to the return
//          variable.
//      _szMsg
//          A format string on how the return value should be displayed in the
//          debugger.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMsgDo( _szExp, _szMsg ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter( ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_szExp) TEXT("\n") ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_szMsg), TEXT(#_szExp), _szExp ); \
            DebugDecrementStackDepthCounter( ); \
        } \
        else \
        { \
            _szExp; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgGUID(
//      _flags,
//      _msg
//      _guid
//      )
//
//  Description:
//      Dumps a GUID to the debugger only if one of the flags in _flags is
//      set in g_tfModule.
//
//  Arguments:
//      _flags   - Flags to check
//      _msg     - msg to print before GUID
//      _guid    - GUID to dump
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _guid is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceMsgGUID( _flags, _msg, _guid ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), \
                          __LINE__, \
                          __MODULE__, \
                          _flags, \
                          TEXT("%s {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n"), \
                          _msg, \
                          _guid.Data1, _guid.Data2, _guid.Data3,  \
                          _guid.Data4[ 0 ], _guid.Data4[ 1 ], _guid.Data4[ 2 ], _guid.Data4[ 3 ], \
                          _guid.Data4[ 4 ], _guid.Data4[ 5 ], _guid.Data4[ 6 ], _guid.Data4[ 7 ] ); \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  ErrorMsg(
//      _szMsg,
//      _err
//      )
//
//  Description:
//      Print an error out. Can be used to log errors to a log file. Note that
//      it will also print the source filename, line number and module name.
//
//  Arguments:
//      _szMsg  - Format string to be displayed.
//      _err    - Error code of the error.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define ErrorMsg( _szMsg, _err ) \
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfALWAYS, TEXT(_szMsg), _err );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  WndMsg(
//      _hwnd,
//      _umsg,
//      _wparam,
//      _lparam
//      )
//
//  Description:
//      Prints out a message to trace windows messages.
//
//  Arguments:
//      _hwnd   - The HWND
//      _umsg   - The uMsg
//      _wparam - The WPARAM
//      _lparam _ The LPARAM
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _wparam and _lparam are evaluated multiple times but the name
//          of the macro is mixed case.
#define WndMsg( _hwnd, _umsg, _wparam, _lparam ) \
    do \
    { \
        if ( g_tfModule & mtfWM ) \
        { \
            DebugMsg( TEXT("%s: WM   : hWnd = 0x%08x, uMsg = %u, wParam = 0x%08x (%u), lParam = 0x%08x (%u)\n"), __MODULE__, _hwnd, _umsg, _wparam, _wparam, _lparam, _lparam ); \
        } \
    } while ( 0 )

//****************************************************************************
//
//  Debug Macros
//
//  These calls are only compiled in DEBUG. They are a NOP in RETAIL
//  (not even compiled in).
//
//****************************************************************************

//
// Same as TraceDo() but only compiled in DEBUG.
//
#define DebugDo( _fn ) \
    do \
    { \
        DebugIncrementStackDepthCounter( ); \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("+ ") TEXT(#_fn ) TEXT("\n") ); \
        _fn; \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("V\n") ); \
        DebugDecrementStackDepthCounter( ); \
    } while ( 0 )


//
// Same as TraceMsgDo() but only compiled in DEBUG.
//
#define DebugMsgDo( _fn, _msg ) \
    do \
    { \
        DebugIncrementStackDepthCounter( ); \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("+ ") TEXT(#_fn) TEXT("\n") ); \
        DebugMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), TEXT(#_fn), _fn ); \
        DebugDecrementStackDepthCounter( ); \
    } while ( 0 )

//****************************************************************************
//
//  HRESULT testing macros
//
//  These functions check HRESULT return values and display UI if conditions
//  warrant only in DEBUG.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  IsTraceFlagSet(
//      _flag
//      )
//
//  Description:
//      Checks to see of the flag is set in the global flags or in the per
//      thread flags. If you specify more than one flag and if any of them are
//      set, it will return TRUE.
//
//      In RETAIL this always return FALSE thereby effectively deleting the
//      block of the if statement. Example:
//          
//          if ( IsTraceFlagSet( mtfPERTHREADTRACE ) )
//          {
//              //
//              // This code only exists in DEBUG.
//              .
//              .
//              .
//          }
//
//  Arguments:
//      _flags  - Flag to check for.
//
//  Return Values:
//      TRUE    - If DEBUG and flag set.
//      FLASE   - If RETAIL or flag not set.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define IsTraceFlagSet( _flag )    ( g_tfModule && IsDebugFlagSet( _flag ) )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  THR(
//      _hr
//      )
//
//  Description:
//      Warning is display if HRESULT is anything but S_OK (0). This can be
//      use in an expression. Example:
//
//      hr = THR( pSomething->DoSomething( arg ) );
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      Result of the "_hr" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define THR( _hr ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  STHR(
//      _hr
//      )
//
//  Description:
//      Warning is display if FAILED( _hr ) is TRUE. This can be use in an
//      expression. Example:
//
//      hr = STHR( pSomething->DoSomething( arg ) );
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      Result of the "_hr" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define STHR( _hr ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, TRUE )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TW32(
//      _fn
//      )
//
//  Description:
//      Warning is display if result is anything but ERROR_SUCCESS (0). This 
//      can be use in an expression. Example:
//
//      dwErr = TW32( RegOpenKey( HKLM, "foobar", &hkey ) );
//
//  Arguments:
//      _fn - Function expression to check.
//
//  Return Values:
//      Result of the "_fn" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TW32( _fn ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), _fn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  RRETURN(
//      _fn
//      )
//
//  Description:
//      Warning is display if return value is anything but ERROR_SUCCESS (0).
//
//  Argument:
//      _fn - Value to return.
//
//  Return Values:
//      _fn always.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define RRETURN( _fn ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            if ( _fn != ERROR_SUCCESS ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V ") TEXT(#_fn) TEXT(" = 0x%08x (%s)\n"), _fn ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V\n") ); \
            } \
            DebugDecrementStackDepthCounter( ); \
        } \
        return _fn; \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  QIRETURN(
//      _hr,
//      _riid
//      )
//
//  Description:
//      Warning is display if HRESULT is anything but S_OK (0) only if 
//      mtfQUERYINTERFACE is set in g_tfModule, otherwise only a debug 
//      message will be printed. Note that TraceFunc or TraceClsFunc must
//      have been called on the call stack counter must be incremented
//      prior to using.
//
//  Arguments:
//      _hr     - Result of the query interface call.
//      _riid   - The reference ID of the interfaced queried for.
//
//  Return Values:
//      None - calls RETURN macro.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define QIRETURN( _hr, _riid ) \
    do \
    { \
        if ( _hr ) \
        { \
            TCHAR szGuid[ 40 ]; \
            TCHAR szSymbolicName[ 64 ]; \
            DWORD cchSymbolicName = 64; \
            DebugFindWinerrorSymbolicName( _hr, szSymbolicName, &cchSymbolicName ); \
            Assert( cchSymbolicName != 64 ); \
            DebugMessage( TEXT(__FILE__), \
                          __LINE__, \
                          __MODULE__, \
                          TEXT("*HRESULT* QueryInterface( %s, ppv ) failed(), hr = 0x%08x (%s)\n"), \
                          PszDebugFindInterface( _riid, szGuid ), \
                          _hr, \
                          szSymbolicName \
                          ); \
        } \
        if ( g_tfModule & mtfQUERYINTERFACE ) \
        { \
            TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE ); \
        } \
        HRETURN( _hr ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  BOOLTOSTRING(
//      _fBool
//      )
//
//  Desfription:
//      If _fBool is true, returns address of "TRUE" else returns address of
//      "FALSE".
//
//  Argument:
//      _fBool  - Expression to evaluate.
//
//  Return Values:
//      address of "TRUE" if _fBool is true.
//      address of "FALSE" if _fBool is false.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define BOOLTOSTRING( _fBool ) ( (_fBool) ? g_szTrue : g_szFalse )

//****************************************************************************
//
// Trace/Debug Functions - these do not exist in RETAIL.
//
//****************************************************************************

BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    );

void
TraceMsg(
    TRACEFLAG   tfIn,
    LPCSTR      pszFormatIn,
    ... 
    );

void
TraceMsg(
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ... 
    );

void
DebugMsg(
    LPCSTR      pszFormatIn,
    ... 
    );

void
DebugMsg(
    LPCWSTR     pszFormatIn,
    ... 
    );

void
TraceMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    ... 
    );

void
TraceMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    );

void
DebugMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    ... 
    );

void
DebugMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    );

BOOL
AssertMessage( 
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    BOOL        fTrueIn
    );

HRESULT
TraceHR(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    HRESULT     hrIn,
    BOOL        fSuccessIn
    );

ULONG
TraceWin32(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    ULONG       ulErrIn
    );

#if 0
//
// Trying to get the NTSTATUS stuff to play in "user world"
// is just about impossible. This is here in case it is needed
// and one could find the right combination of headers to 
// make it work. Inflicting such pain on others is the reason
// why this function is #ifdef'fed.
//
void
DebugFindNTStatusSymbolicName(
    NTSTATUS dwStatusIn,
    LPTSTR   pszNameOut,
    LPDWORD  pcchNameInout
    );
#endif

void
DebugFindWinerrorSymbolicName(
    DWORD dwErrIn,
    LPTSTR  pszNameOut,
    LPDWORD pcchNameInout
    );

void
DebugReturnMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszMessageIn,
    DWORD       dwErrIn
    );

//****************************************************************************
//
//  Use the TraceMemoryXXX wrappers, not the DebugMemoryXXX functions.
//  The memory tracking functions do not exist in RETAIL (converted to NOP).
//
//****************************************************************************

typedef enum EMEMORYBLOCKTYPE
{
    mmbtUNKNOWN = 0,           // Never used
    mmbtMEMORYALLOCATION,      // Global/LocalAlloc
    mmbtOBJECT,                // Object pointer
    mmbtHANDLE,                // Object handle
    mmbtPUNK,                  // IUnknown pointer
    mmbtSYSALLOCSTRING         // SysAllocString
} EMEMORYBLOCKTYPE;

#define TraceMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _uFlagsIn, _dwBytesIn, _pszCommentIn ) \
    DebugMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _uFlagsIn, _dwBytesIn, _pszCommentIn )
    
#define TraceMemoryAddAddress( _pv ) \
    DebugMemoryAdd( mmbtMEMORYALLOCATION, _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT(#_pv) )

#define TraceMemoryAddHandle( _handle ) \
    DebugMemoryAdd( mmbtHANDLE, _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT(#_handle) )

#define TraceMemoryAddObject( _pv ) \
    DebugMemoryAdd( mmbtOBJECT, _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_INVALID_HANDLE, 0, TEXT(#_pv) )

#define TraceMemoryAddPunk( _punk ) \
    DebugMemoryAdd( mmbtPUNK, _punk, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_INVALID_HANDLE, 0, TEXT(#_punk) )

#define TraceMemoryDelete( _hGlobalIn, _fClobberIn ) \
    DebugMemoryDelete( mmbtUNKNOWN, _hGlobalIn, TEXT(__FILE__), __LINE__, __MODULE__, _fClobberIn )

#define TraceStrDup( _sz ) \
    (LPTSTR) DebugMemoryAdd( mmbtMEMORYALLOCATION, StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("StrDup( ") TEXT(#_sz) TEXT(" )") )

#if defined( USES_SYSALLOCSTRING )
// BUGBUG:  DavidP 09-DEC-1999
//          _sz is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocString( _sz ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocString( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, 0, wcslen( _sz ) + 1, TEXT("SysAllocString( ") TEXT(#_sz) TEXT(")") )

// BUGBUG:  DavidP 09-DEC-1999
//          _sz and _len are evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocStringByteLen( _sz, _len ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocStringByteLen( _sz, _len ), TEXT(__FILE__), __LINE__, __MODULE__, 0, _len, TEXT("SysAllocStringByteLen( ") TEXT(#_sz) TEXT(")") )

// BUGBUG:  DavidP 09-DEC-1999
//          _sz and _len are evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocStringLen( _sz, _len ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocStringLen( _sz, _len ), TEXT(__FILE__), __LINE__, __MODULE__, 0, _len + 1, TEXT("SysAllocStringLen( ") TEXT(#_sz) TEXT(")") )

#define TraceSysReAllocString( _bstrOrg, _bstrNew ) \
    DebugSysReAllocString( TEXT(__FILE__), __LINE__, __MODULE__, _bstrOrg, _bstrNew, TEXT("TraceSysReAllocString(") TEXT(#_bstrOrg) TEXT(", ") TEXT(#_bstrNew) TEXT(" )") )

#define TraceSysReAllocStringLen( _bstrOrg, _bstrNew, _cch ) \
    DebugSysReAllocStringLen( TEXT(__FILE__), __LINE__, __MODULE__, _bstrOrg, _bstrNew, _cch, TEXT("TraceSysReAllocString(") TEXT(#_bstrOrg) TEXT(", ") TEXT(#_bstrNew) TEXT(", ") TEXT(#_cch) TEXT(" )") )

#define TraceSysFreeString( _bstr ) \
    DebugMemoryDelete( mmbtSYSALLOCSTRING, _bstr, TEXT(__FILE__), __LINE__, __MODULE__, TRUE ); \
    SysFreeString( _bstr )
#endif // USES_SYSALLOCSTRING

//****************************************************************************
//
//  Memory tracing functions - these are remapped to the GlobalAlloc/GlobalFree
//  heap functions when in RETAIL. Use the TraceMemoryXXX wrappers, not the 
//  DebugMemoryXXX functions.
//
//****************************************************************************
HGLOBAL
DebugAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    );

HGLOBAL
DebugReAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    HGLOBAL     hMemIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    );

HGLOBAL
DebugFree(
    HGLOBAL     hMemIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );

HGLOBAL
DebugMemoryAdd(
    EMEMORYBLOCKTYPE    mbtType,
    HGLOBAL             hGlobalIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    UINT                uFlagsIn,
    DWORD               dwBytesIn,
    LPCTSTR             pszCommentIn
    );

void
DebugMemoryDelete(
    EMEMORYBLOCKTYPE    mbtTypeIn,
    HGLOBAL             hGlobalIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    BOOL                fClobberIn
    );

#if defined( USES_SYSALLOCSTRING )

INT
DebugSysReAllocString(
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    LPCTSTR         pszCommentIn
    );

INT
DebugSysReAllocStringLen(
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    unsigned int    ucchIn,
    LPCTSTR         pszCommentIn
    );

#endif // USES_SYSALLOCSTRING

void
DebugMemoryCheck(
    LPVOID  pvListIn,
    LPCTSTR pszListNameIn
    );

//****************************************************************************
//
//  operator new( ) for C++
//
//****************************************************************************
#ifdef __cplusplus
extern
void *
__cdecl
operator new(
    size_t      nSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );

//
// Remap "new" to our macro so "we" don't have to type anything extra and
// so it magically dissappears in RETAIL.
// 
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )
#endif

//****************************************************************************
//
//
#else // it's RETAIL    ******************************************************
//
//
//****************************************************************************

#pragma message("BUILD: RETAIL macros being built")

//
// Debugging -> NOPs
//
#define DEFINE_MODULE( _module )
#define __MODULE__                                  NULL
#define DEFINE_THISCLASS( _class )
#define __THISCLASS__                               NULL
#define DEFINE_SUPER( _super )
#define __SUPERCLASS__                              NULL
#define BOOLTOSTRING( _fBool )                      NULL

#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define TraceMsgGUID( _f, _m, _g )      

#define AssertMessage( _f, _l, _m, _e, _msg )       TRUE

//
// TODO: gpease 08-NOV-1999
//  We probably want to do something special for ErrorMsg( )
//
#define ErrorMsg                    1 ? (void)0 : (void)

#define TraceMsg                    1 ? (void)0 : (void) 
#define WndMsg                      1 ? (void)0 : (void)
#define DebugMsg                    1 ? (void)0 : (void) 
#define TraceMessage                1 ? (void)0 : (void) 
#define DebugMessage                1 ? (void)0 : (void) 
#define TraceHR                     1 ? (void)0 : (void) 
#define TraceFunc                   1 ? (void)0 : (void) 
#define TraceFunc1                  1 ? (void)0 : (void) 
#define TraceFunc2                  1 ? (void)0 : (void) 
#define TraceFunc3                  1 ? (void)0 : (void) 
#define TraceFunc4                  1 ? (void)0 : (void) 
#define TraceFunc5                  1 ? (void)0 : (void) 
#define TraceFunc6                  1 ? (void)0 : (void) 
#define TraceClsFunc                1 ? (void)0 : (void) 
#define TraceClsFunc1               1 ? (void)0 : (void) 
#define TraceClsFunc2               1 ? (void)0 : (void) 
#define TraceClsFunc3               1 ? (void)0 : (void) 
#define TraceClsFunc4               1 ? (void)0 : (void) 
#define TraceClsFunc5               1 ? (void)0 : (void) 
#define TraceClsFunc6               1 ? (void)0 : (void) 
#define TraceFuncExit()             return
#define TraceInitializeThread( _name )
#define TraceRundownThread( )
#define TraceMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _uFlagsIn, _dwBytesIn, _pszCommentIn ) _hGlobalIn
#define TraceMemoryAddHandle( _handle ) _handle
#define TraceMemoryAddAddress( _pv )    _pv
#define TraceMemoryAddHandle( _obj )    _obj
#define TraceMemoryAddPunk( _punk )     _punk
#define TraceMemoryDelete( _h, _b )     _h
#define TraceMemoryAddObject( _pv )     _pv
#define IsTraceFlagSet( _flag )         FALSE

//
// Enable WMI
//
#define TraceInitializeProcess( _rg, _sizeof ) \
    WMIInitializeTracing( _rg, _sizeof );
#define TraceTerminateProcess( _rg, _sizeof ) \
    WMITerminateTracing( _rg, _sizeof );

//
// Tracing -> just do operation
//
#define TraceDo( _fn )              _fn
#define TraceMsgDo( _fn, _msg )     _fn
#define TraceAssertIfZero( _fn )    _fn

//
// RETURN testing -> do retail
//
#define THR
#define STHR
#define TW32
#define RETURN( _fn )               return _fn
#define FRETURN( _fn )
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi

//
// Memory Functions -> do retail
//
#define TraceAlloc( _flags, _size )                             GlobalAlloc( _flags, _size )
#define TraceAllocString( _flags, _size )                       (LPTSTR) GlobalAlloc( _flags, (_size) * sizeof( TCHAR ) )
#define TraceReAlloc( _hGlobal, _uBytes, _uFlags )              GlobalReAlloc( _hGlobal, _uBytes, _uFlags )
#define TraceFree( _pv )                                        GlobalFree( _pv )
#define TraceStrDup( _sz )                                      StrDup( _sz )
#define TraceSysAllocString( _sz )                              SysAllocString( _sz )
#define TraceSysAllocStringByteLen( _sz, _len )                 SysAllocStringByteLen( _sz, _len )
#define TraceSysAllocStringLen( _sz, _len )                     SysAllocStringLen( _sz, _len )
#define TraceSysReAllocString( _bstrOrg, _bstrNew )             SysReAllocString( _bstrOrg, _bstrNew )
#define TraceSysReAllocStringLen( _bstrOrg, _bstrNew, _cch )    SysReAllocStringLen( _bstrOrg, _bstrNew, _cch )
#define TraceSysFreeString( _bstr )                             SysFreeString( _bstr )
#define TraceCreateMemoryList( _pvIn )
#define TraceMoveToMemoryList( _addr, _pvIn )
#define TraceMemoryListDelete( _addr, _pvIn, _fClobber )
#define TraceTerminateMemoryList( _pvIn )

#endif // DEBUG

#if DBG==1 || defined( _DEBUG )
//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// DEBUG_BREAK
//
// Description:
//      Because the system expection handler can hick-up over INT 3s and 
//      DebugBreak()s, This x86 only macro causes the program to break in the 
//      right spot.
//
//////////////////////////////////////////////////////////////////////////////
#if defined( _X86_ )
#define DEBUG_BREAK         do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak( )
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  Assert(
//      _fn
//      )
//
//  Description:
//      Checks to see if the Expression is TRUE. If not, a message will be
//      displayed to the user on wether the program should break or continue.
//
//  Arguments:
//      _fn     - Expression being asserted.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef Assert
#undef Assert
#endif
// BUGBUG:  DavidP 09-DEC-1999
//          __fn is evaluated multiple times but the name of the
//          macro is mixed case.
#define Assert( _fn ) \
    do \
    { \
        if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), !!(_fn) ) ) \
            DEBUG_BREAK; \
    } while ( 0 )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  AssertMsg(
//      _fn,
//      _msg
//      )
//
//  Descrption:
//      Just like an Assert but has an (hopefully) informative message
//      associated with it.
//
//  Arguments:
//      _fn     - Expression to be evaluated.
//      _msg    - Message to be display if assertion fails.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////     
#ifdef AssertMsg
#undef AssertMsg
#endif
// BUGBUG:  DavidP 09-DEC-1999
//          _fn is evaluated multiple times but the name of the
//          macro is mixed case.
#define AssertMsg( _fn, _msg ) \
    do \
    { \
        if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), !!(_fn) ) ) \
            DEBUG_BREAK; \
    } while ( 0 )
#else // DBG!=1 && !_DEBUG

#define DEBUG_BREAK DebugBreak( );

#ifndef Assert
#define Assert( _e )
#endif

#ifndef AssertMsg
#define AssertMsg( _e, _m )
#endif

#endif // DBG==1 || _DEBUG

//****************************************************************************
//
// WMI Tracing stuctures and prototypes
//
//****************************************************************************

typedef struct
{
    DWORD       dwFlags;        // Flags to be set
    LPCTSTR     pszName;        // Usefull description of the level
} DEBUG_MAP_LEVEL_TO_FLAGS;

typedef struct
{
    LPCTSTR     pszName;        // Usefull description of the flag
} DEBUG_MAP_FLAGS_TO_COMMENTS;

typedef struct
{
    LPCGUID                             guidControl;            // Control guid to register
    LPCTSTR                             pszName;                // Internal associative name
    DWORD                               dwSizeOfTraceList;      // Count of the guids in pTraceList
    const TRACE_GUID_REGISTRATION *     pTraceList;             // List of the of Tracing guids to register
    BYTE                                bSizeOfLevelList;       // Count of the level<->flags
    const DEBUG_MAP_LEVEL_TO_FLAGS *    pMapLevelToFlags;       // List of level->flags mapping. NULL if no mapping.
    const DEBUG_MAP_FLAGS_TO_COMMENTS * pMapFlagsToComments;    // List of descriptions describing the flag bits. NULL if no mapping.

    // Controlled by WMI tracing - these should be NULL/ZERO to start.
    DWORD                               dwFlags;                // Log flags
    BYTE                                bLevel;                 // Log level
    TRACEHANDLE                         hTrace;                 // Active logger handle

    // From here down is initialized by InitializeWMITracing
    TRACEHANDLE                         hRegistration;          // Return control handle
} DEBUG_WMI_CONTROL_GUIDS;

void
WMIInitializeTracing(
    DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
    int                     nCountOfControlGuidsIn
    );

void
WMITerminateTracing(     
    DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
    int                     nCountOfControlGuidsIn
    );

void
WMIMessageByFlags(
    DEBUG_WMI_CONTROL_GUIDS *   pEntryIn,
    const DWORD                 dwFlagsIn,
    LPCWSTR                     pszFormatIn,
    ...
    );

void
WMIMessageByLevel(
    DEBUG_WMI_CONTROL_GUIDS *   pEntryIn,
    const BYTE                  bLogLevelIn,
    LPCWSTR                     pszFormatIn,
    ...
    );

void
WMIMessageByFlagsAndLevel(
    DEBUG_WMI_CONTROL_GUIDS *   pEntryIn,
    const DWORD                 dwFlagsIn,
    const BYTE                  bLogLevelIn,
    LPCWSTR                     pszFormatIn,
    ...
    );

//
// Sample WMI message macros
//
// Typically you will want a particular level to map to a set of flags. This 
// way as you increase the level, you activate more and more messages.
//
// To be versatile, there there types of filtering. Choose the one that suits
// the situation that you supports your logging needs. Remember that depending
// on the use, you might need to specify additional parameters.
//
// These macros on x86 turn into 2 ops ( cmp and jnz ) in the regular code path
// thereby lessening the impact of keeping the macros enabled in RETAIL. Since
// other platforms were not available while developing these macros, you should
// wrap the definitions in protecting against other architectures.
//
// #if defined( _X86_ )
// #define WMIMsg ( g_pTraceGuidControl[0].dwFlags == 0 ) ? (void)0 : WMIMessageByFlags
// #define WMIMsg ( g_pTraceGuidControl[0].dwFlags == 0 ) ? (void)0 : WMIMessageByLevel
// #define WMIMsg ( g_pTraceGuidControl[0].dwFlags == 0 ) ? (void)0 : WMIMessageByFlagsAndLevel
// #else // not X86
// #define WMIMsg 1 ? (void)0 : (void)
// #endif // defined( _X86_ )
//
// 


//****************************************************************************
// 
// Logging Functions
//
//****************************************************************************
void
LogMsg(
    LPCSTR  pszFormatIn,
    ...
    );

void
LogMsg(
    LPCWSTR pszFormatIn,
    ...
    );

void
LogTerminateProcess( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\genscript.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      GenScript.cpp
//
//  Description:
//      DLL services/entry points for the generic script resource.
//
//  Maintained By:
//      gpease 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ActiveScriptSite.h"
#include "ScriptResource.h"
#include "SpinLock.h"

//
// Debugging Module Name
//
DEFINE_MODULE("SCRIPTRES")

//
// DLL Globals
//
HINSTANCE g_hInstance = NULL;
LONG      g_cObjects  = 0;
LONG      g_cLock     = 0;
TCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };

#if defined(DEBUG)
LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list
#endif

PSET_RESOURCE_STATUS_ROUTINE    g_prsrCallback  = NULL;

extern "C"
{

extern CLRES_FUNCTION_TABLE     GenScriptFunctionTable;


#define PARAM_NAME__PATH                L"Path"


// GenScript resource read-write private properties
RESUTIL_PROPERTY_ITEM
GenScriptResourcePrivateProperties[] = {
    { PARAM_NAME__PATH,             NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, 0 },
    { NULL, NULL, 0, 0, 0, 0 }
};


//****************************************************************************
//
// DLL Entry Points
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// BOOL
// WINAPI
// GenScriptDllEntryPoint(
//      HANDLE  hInstIn, 
//      ULONG   ulReasonIn, 
//      LPVOID  lpReservedIn
//      )
//        
// Description:
//      Dll entry point.
//
// Arguments:
//      hInstIn      - DLL instance handle.
//      ulReasonIn   - DLL reason code for entrance.
//      lpReservedIn - Not used.
//
//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
GenScriptDllEntryPoint(
    HANDLE  hInstIn, 
    ULONG   ulReasonIn, 
    LPVOID  // lpReservedIn
    )
{
    //
    // KB: NO_THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By not defining this you can prvent the linker
    // from calling you DllEntry for every new thread.
    // This makes creating new thread significantly
    // faster if every DLL in a process does it. 
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if defined( DEBUG )
    #define NO_THREAD_OPTIMIZATIONS
#endif // DEBUG

#if defined(DEBUG) || defined(NO_THREAD_OPTIMIZATIONS)
    switch( ulReasonIn )
    {
    case DLL_PROCESS_ATTACH:
        TraceInitializeProcess( NULL, NULL );
        TraceCreateMemoryList( g_GlobalMemoryList );

#if defined( DEBUG )
        TraceFunc( "GenScriptDllEntryPoint( )\n" );
        TraceMessage( TEXT(__FILE__), 
                      __LINE__, 
                      __MODULE__, 
                      mtfDLL, 
                      TEXT("DLL: DLL_PROCESS_ATTACH - ThreadID = 0x%08x\n"), 
                      GetCurrentThreadId( ) 
                      );
        FRETURN( TRUE );
#endif // DEBUG
        g_hInstance = (HINSTANCE) hInstIn;
        GetModuleFileName( g_hInstance, g_szDllFilename, MAX_PATH ); 
        break;

    case DLL_PROCESS_DETACH:
#if defined( DEBUG )
        TraceFunc( "GenScriptDllEntryPoint( )\n" );
        TraceMessage( TEXT(__FILE__), 
                      __LINE__, 
                      __MODULE__, 
                      mtfDLL, 
                      TEXT("DLL: DLL_PROCESS_DETACH - ThreadID = 0x%08x [ g_cLock=%u, g_cObjects=%u ]\n"), 
                      GetCurrentThreadId( ), 
                      g_cLock, 
                      g_cObjects  
                      );
        FRETURN( TRUE );
#endif // DEBUG
        TraceTerminateMemoryList( g_GlobalMemoryList );
        TraceTerminateProcess( NULL, NULL );
        break;

    case DLL_THREAD_ATTACH:
        TraceInitializeThread( NULL );
#if defined( DEBUG )
        DebugMsg( "The thread 0x%x has started.\n", GetCurrentThreadId( ) );
        TraceFunc( "GenScriptDllEntryPoint( )\n" );
        TraceMessage( TEXT(__FILE__), 
                      __LINE__, 
                      __MODULE__, 
                      mtfDLL, 
                      TEXT("DLL: DLL_THREAD_ATTACH - ThreadID = 0x%08x [ g_cLock=%u, g_cObjects=%u ]\n"), 
                      GetCurrentThreadId( ), 
                      g_cLock, 
                      g_cObjects
                      );
        FRETURN( TRUE );
#endif // DEBUG
        break;

    case DLL_THREAD_DETACH:
#if defined( DEBUG )
        TraceFunc( "GenScriptDllEntryPoint( )\n" );
        TraceMessage( TEXT(__FILE__), 
                      __LINE__, 
                      __MODULE__, 
                      mtfDLL, 
                      TEXT("DLL: DLL_THREAD_DETACH - ThreadID = 0x%08x [ g_cLock=%u, g_cObjects=%u ]\n"), 
                      GetCurrentThreadId( ), 
                      g_cLock, 
                      g_cObjects
                      );
        FRETURN( TRUE );
#endif // DEBUG
        TraceRundownThread( );;
        break;

    default:
#if defined( DEBUG )
        TraceFunc( "GenScriptDllEntryPoint( )\n" );
        TraceMessage( TEXT(__FILE__), 
                      __LINE__, 
                      __MODULE__, 
                      mtfDLL, 
                      TEXT("DLL: UNKNOWN ENTRANCE REASON - ThreadID = 0x%08x [ g_cLock=%u, g_cObjects=%u ]\n"), 
                      GetCurrentThreadId( ), 
                      g_cLock, 
                      g_cObjects
                      );
        FRETURN( TRUE );
#endif // DEBUG
        break;
    }

    return TRUE;

#else // !NO_THREAD_OPTIMIZATIONS
    BOOL f;
    Assert( ulReasonIn == DLL_PROCESS_ATTACH || ulReasonIn == DLL_PROCESS_DETACH );
    TraceInitializeProcess( NULL, NULL );
    g_hInstance = (HINSTANCE) hInstIn;
    GetModuleFileName( g_hInstance, g_szDllFilename, MAX_PATH ); 
    f = DisableThreadLibraryCalls( g_hInstance );
    if ( !f )
    {
        OutputDebugString( TEXT("*ERROR* DisableThreadLibraryCalls( ) failed.") );
    }
    return TRUE;
#endif // NO_THREAD_OPTIMIZATIONS

} //*** GenScriptDllEntryPoint()


//****************************************************************************
//
// Cluster Resource Entry Points
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  void
//  WINAPI
//  ScriptResClose(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
void 
WINAPI 
ScriptResClose(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResClose( residIn = 0x%08x )\n", residIn );

    HRESULT hr;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
        goto Cleanup;

    hr = THR( pres->Close( ) );

    //
    // Matching Release() for object creation in ScriptResOpen( ).
    //

    pres->Release( );

Cleanup:
    TraceFuncExit( );

} //*** ScriptResClose( )

//////////////////////////////////////////////////////////////////////////////
//
//  RESID
//  WINAPI
//  ScriptResOpen(
//      LPCWSTR         pszNameIn,
//      HKEY            hkeyIn,
//      RESOURCE_HANDLE hResourceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
RESID 
WINAPI 
ScriptResOpen(
    LPCWSTR             pszNameIn,
    HKEY                hkeyIn,
    RESOURCE_HANDLE     hResourceIn
    )
{
    TraceFunc1( "ScriptResOpen( pszNameIn = '%s', hkeyIn, hResourceIn )\n", pszNameIn );

    HRESULT hr;
    CScriptResource * pres;

    pres = CScriptResource_CreateInstance( pszNameIn, hkeyIn, hResourceIn );
    if ( pres == NULL )
        goto OutOfMemory;

    hr = THR( pres->Open( ) );

Cleanup:
    //
    // KB:  Don't pres->Release( ) as we are handing it out as out RESID.
    //
    RETURN( pres );

OutOfMemory:
    hr = ERROR_OUTOFMEMORY;
    goto Cleanup;
} //*** ScriptResOpen( )

//////////////////////////////////////////////////////////////////////////////
// 
//  DWORD
//  WINAPI
//  ScriptResOnline(
//      RESID   residIn,
//      PHANDLE hEventInout
//      )
//
//////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI 
ScriptResOnline(
    RESID       residIn,
    PHANDLE     hEventInout
    )
{
    TraceFunc2( "ScriptResOnline( residIn = 0x%08x, hEventInout = 0x%08x )\n",
                residIn, hEventInout );

    HRESULT hr;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
        goto InvalidArg;

    hr = THR( pres->Online( ) );

Cleanup:
    RETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** ScriptResOnline( )

//////////////////////////////////////////////////////////////////////////////
//
//  DWORD
//  WINAPI
//  ScriptResOffline(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI 
ScriptResOffline(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResOffline( residIn = 0x%08x )\n", residIn );

    HRESULT hr;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
        goto InvalidArg;

    hr = THR( pres->Offline( ) );

Cleanup:
    RETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** ScriptResOffline( )

//////////////////////////////////////////////////////////////////////////////
//
//  void
//  WINAPI
//  ScriptResTerminate(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
void 
WINAPI 
ScriptResTerminate(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResTerminate( residIn = 0x%08x )\n", residIn );

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
        goto InvalidArg;

    THR( pres->Terminate( ) );

Cleanup:
    TraceFuncExit( );

InvalidArg:
    THR( E_INVALIDARG );
    goto Cleanup;

} // ScriptResTerminate( )

//////////////////////////////////////////////////////////////////////////////
//
//  BOOL
//  WINAPI
//  ScriptResLooksAlive(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
BOOL 
WINAPI 
ScriptResLooksAlive(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResLooksAlive( residIn = 0x%08x )\n", residIn );

    HRESULT hr;
    BOOL    bLooksAlive = FALSE;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
        goto InvalidArg;

    hr = STHR( pres->LooksAlive( ) );
    if ( hr == S_OK )
    {
        bLooksAlive = TRUE;
    } // if: S_OK

Cleanup:
    RETURN( bLooksAlive );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** ScriptResLooksAlive( )

//////////////////////////////////////////////////////////////////////////////
//
//  BOOL
//  WINAPI
//  ScriptResIsAlive(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
BOOL 
WINAPI 
ScriptResIsAlive(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResIsAlive( residIn = 0x%08x )\n", residIn );

    HRESULT hr;
    BOOL    bIsAlive = FALSE;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
        goto InvalidArg;

    hr = STHR( pres->IsAlive( ) );
    if ( hr == S_OK )
    {
        bIsAlive = TRUE;
    } // if: S_OK

Cleanup:
    RETURN( bIsAlive );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** ScriptResIsAlive( )


DWORD
ScriptResResourceControl(
    RESID residIn,
    DWORD dwControlCodeIn,
    PVOID pvBufferIn,
    DWORD dwBufferInSizeIn,
    PVOID pvBufferOut,
    DWORD dwBufferOutSizeIn,
    LPDWORD pdwBytesReturnedOut
    )
{
    TraceFunc( "ScriptResResourceControl( ... )\n " );

    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwBytesRequired;

    *pdwBytesReturnedOut = 0;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );
    if ( pres == NULL )
    {
        dwErr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    switch ( dwControlCodeIn )
    {
    case CLUSCTL_RESOURCE_UNKNOWN:
        break;

    case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
        dwErr = ResUtilGetPropertyFormats( GenScriptResourcePrivateProperties,
                                           pvBufferOut,
                                           dwBufferOutSizeIn,
                                           pdwBytesReturnedOut,
                                           &dwBytesRequired );
        if ( dwErr == ERROR_MORE_DATA ) {
            *pdwBytesReturnedOut = dwBytesRequired;
        }
        break;

    default:
        dwErr = ERROR_INVALID_FUNCTION;
        break;
    }

Cleanup:
    RETURN( dwErr );
} //*** ScriptResResourceControl( )


DWORD
ScriptResTypeControl(
    LPCWSTR ResourceTypeName,
    DWORD dwControlCodeIn,
    PVOID pvBufferIn,
    DWORD dwBufferInSizeIn,
    PVOID pvBufferOut,
    DWORD dwBufferOutSizeIn,
    LPDWORD pdwBytesReturnedOut
    )
{
    TraceFunc( "ScriptResTypeControl( ... )\n " );

    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwBytesRequired;

    *pdwBytesReturnedOut = 0;

    switch ( dwControlCodeIn )
    {
    case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
        break;

    case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
        dwErr = ResUtilGetPropertyFormats( GenScriptResourcePrivateProperties,
                                           pvBufferOut,
                                           dwBufferOutSizeIn,
                                           pdwBytesReturnedOut,
                                           &dwBytesRequired );
        if ( dwErr == ERROR_MORE_DATA ) {
            *pdwBytesReturnedOut = dwBytesRequired;
        }
        break;

    default:
        dwErr = ERROR_INVALID_FUNCTION;
        break;
    }

    RETURN( dwErr );

} //*** ScriptResTypeControl( )

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( GenScriptFunctionTable,    // Name
                         CLRES_VERSION_V1_00,       // Version
                         ScriptRes,                 // Prefix
                         NULL,                      // Arbitrate
                         NULL,                      // Release
                         ScriptResResourceControl,  // ResControl
                         ScriptResTypeControl       // ResTypeControl
                         );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-OCT-1999
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to 
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <dispex.h>
#include <shlwapi.h>
#include <resapi.h>
#include <activscp.h>

extern "C" {
extern PLOG_EVENT_ROUTINE ClusResLogEvent;
}

#include "debug.h"
#include "CITracker.h"
#include "genscript.h"
#define cchGUID_STRING_SIZE (sizeof("{12345678-1234-1234-1234-123456789012}"))

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\resourceobject.h ===
// ResourceObject.h: interface for the CResourceObject class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

class CResourceObject :
    public IDispatchEx
{
private:
    LONG m_cRef;

    RESOURCE_HANDLE     m_hResource;        
    PLOG_EVENT_ROUTINE  m_pler;
    HKEY                m_hkey;
    LPCWSTR             m_pszName;  // DON'T FREE

private:
    STDMETHOD(LogInformation)( BSTR bstrIn );
    STDMETHOD(ReadPrivateProperty)( DISPID idIn, VARIANT * pvarResOut );
    STDMETHOD(WritePrivateProperty)( DISPID idIn, DISPPARAMS * pdpIn );
    STDMETHOD(AddPrivateProperty)( DISPPARAMS * pdpIn );
    STDMETHOD(RemovePrivateProperty)( DISPPARAMS * pdpIn );

    STDMETHOD(LogError)( HRESULT hrIn );

public:
    explicit CResourceObject( RESOURCE_HANDLE     hResourceIn,
                              PLOG_EVENT_ROUTINE  plerIn, 
                              HKEY                hkeyIn,
                              LPCWSTR             pszNameIn
                              );
    virtual ~CResourceObject();

    // IUnknown
    STDMETHOD( QueryInterface )(
        REFIID riid,
        void ** ppUnk );
    STDMETHOD_(ULONG, AddRef )( );
    STDMETHOD_(ULONG, Release )( );

    // IDispatch
    STDMETHOD( GetTypeInfoCount )( 
            /* [out] */ UINT __RPC_FAR *pctinfo );        
    STDMETHOD( GetTypeInfo )( 
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo );        
    STDMETHOD( GetIDsOfNames )( 
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId );        
    STDMETHOD( Invoke )( 
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr );
 
    // IDispatchEx
    STDMETHOD( GetDispID )( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid );        
    STDMETHOD( InvokeEx )( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller );        
    STDMETHOD( DeleteMemberByName )( 
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex );        
    STDMETHOD( DeleteMemberByDispID )( 
            /* [in] */ DISPID id );        
    STDMETHOD( GetMemberProperties )( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex );        
    STDMETHOD( GetMemberName )( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName );        
    STDMETHOD( GetNextDispID )( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid );        
    STDMETHOD( GetNameSpaceParent )( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\scriptresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      ScriptResource.h
//
//  Description:
//      CScriptResource class header file.
//
//  Maintained By:
//      gpease 14-DEC-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// Forward declarations
//
class CScriptResource;

typedef enum _EMESSAGE {
    msgUNKNOWN = 0,
    msgOPEN,
    msgCLOSE,
    msgONLINE,
    msgOFFLINE,
    msgTERMINATE,
    msgLOOKSALIVE,
    msgISALIVE,
    msgDIE,
    msgMAX
} EMESSAGE;

//
// CreateInstance
//
CScriptResource *
CScriptResource_CreateInstance( 
    LPCWSTR pszNameIn, 
    HKEY hkeyIn, 
    RESOURCE_HANDLE hResourceIn
    );

//
// Class CScriptResource
//
class
CScriptResource :
    public IUnknown
{
private:    // data
    LONG                    m_cRef;

    LPWSTR                  m_pszName;
    LPWSTR                  m_pszScriptFilePath;
    LPWSTR                  m_pszScriptEngine;
    HKEY                    m_hkeyParams;
    IActiveScriptSite *     m_pass;
    IDispatch *             m_pidm;
    IActiveScriptParse *    m_pasp;
    IActiveScript *         m_pas;

    HANDLE                  m_hThread;
    DWORD                   m_dwThreadId;
    HANDLE                  m_hEventWait;
    HANDLE                  m_hEventDone;
    LONG                    m_lockSerialize;

    // Task stuff
    EMESSAGE                m_msg;          // task to do.
    HRESULT                 m_hr;           // result of doing m_msg.

    // the following don't need to be freed, closed or released.
    RESOURCE_HANDLE         m_hResource;

    DISPID                  m_dispidOpen;
    DISPID                  m_dispidClose;
    DISPID                  m_dispidOnline;
    DISPID                  m_dispidOffline;
    DISPID                  m_dispidTerminate;
    DISPID                  m_dispidLooksAlive;
    DISPID                  m_dispidIsAlive;

    BOOL                    m_fLastLooksAlive;

private:    // methods
    CScriptResource( );
    ~CScriptResource( );
    HRESULT
        Init( LPCWSTR pszNameIn, 
              HKEY hkeyIn, 
              RESOURCE_HANDLE hResourceIn
              );
    LPWSTR
        MakeScriptEngineAssociation(
            IN    LPCWSTR     pszScriptFileName 
            );
    HRESULT
        DoConnect( IN  LPWSTR  szScriptFilePath = NULL );
    void
        DoDisconnect( );

    static DWORD WINAPI
        S_ThreadProc( LPVOID pParam );

    STDMETHOD(LogError)( HRESULT hrIn );
    STDMETHOD(LogScriptError)( EXCEPINFO ei );

    HRESULT
        OnOpen( );
    HRESULT
        OnClose( );
    HRESULT
        OnOnline( );
    HRESULT
        OnOffline( );
    HRESULT
        OnTerminate( );
    HRESULT
        OnLooksAlive( );
    HRESULT
        OnIsAlive( );

    HRESULT
        WaitForMessageToComplete( EMESSAGE msgIn );

public:     // methods
    friend CScriptResource *
        CScriptResource_CreateInstance( LPCWSTR pszNameIn, 
                                        HKEY hkeyIn, 
                                        RESOURCE_HANDLE hResourceIn
                                        );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // Publics
    STDMETHOD(Open)( );
    STDMETHOD(Close)( );
    STDMETHOD(Online)( );
    STDMETHOD(Offline)( );
    STDMETHOD(Terminate)( );
    STDMETHOD(LooksAlive)( );
    STDMETHOD(IsAlive)( );

}; // class CScriptResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\resourceobject.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResourceObject.cpp
//
//  Description:
//      CResourceObject automation class implementation.
//
//  Maintained By:
//      gpease 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ResourceObject.h"

DEFINE_THISCLASS( "CResourceObject" );
#define STATIC_AUTOMATION_METHODS 4

//////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
//////////////////////////////////////////////////////////////////////////////
CResourceObject::CResourceObject(
    RESOURCE_HANDLE     hResourceIn,
    PLOG_EVENT_ROUTINE  plerIn,
    HKEY                hkeyIn,
    LPCWSTR             pszNameIn
    ) :
    m_hResource( hResourceIn ),
    m_pler( plerIn ),
    m_hkey( hkeyIn ),
    m_pszName( pszNameIn )
{
    TraceClsFunc( "CResourceObject\n" );
    Assert( m_cRef == 0 );
    AddRef( );

    TraceFuncExit( );
}

//////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
//////////////////////////////////////////////////////////////////////////////
CResourceObject::~CResourceObject()
{
    TraceClsFunc( "~CResourceObject\n" );

    // Don't free m_pszName.
    // Don't close m_hkey.

    TraceFuncExit( );
}


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::[IUnknown] QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::QueryInterface( 
    REFIID riid, 
    void** ppUnk 
    )
{
    TraceClsFunc( "[IUnknown] QueryInterface( )\n" );

    HRESULT hr = E_NOINTERFACE;

    *ppUnk = NULL;

    if ( riid == IID_IUnknown )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IUnknown, (IDispatchEx*) this, 0 );
        hr = S_OK;
    }
    else if ( riid == IID_IDispatchEx )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IDispatchEx, (IDispatchEx*) this, 0 );
        hr = S_OK;
    }
    else if ( riid == IID_IDispatch )
    {
        *ppUnk = TraceInterface( __THISCLASS__, IDispatch, (IDispatchEx*) this, 0 );
        hr = S_OK;
    }

    if ( hr == S_OK )
    {
        ((IUnknown *) *ppUnk)->AddRef( );
    }

    QIRETURN( hr, riid );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
CResourceObject::AddRef( )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );
    InterlockedIncrement( &m_cRef );
    RETURN( m_cRef );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
CResourceObject::Release( )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );
    InterlockedDecrement( &m_cRef );
    if ( m_cRef )
        RETURN( m_cRef );

    delete this;

    RETURN( 0 );
}


//****************************************************************************
//
//  IDispatch
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetTypeInfoCount ( 
//      UINT * pctinfo // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetTypeInfoCount ( 
    UINT * pctinfo // out
    )
{
    TraceClsFunc( "[IDispatch] GetTypeInfoCount( )\n" );

    *pctinfo = 0;

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetTypeInfo ( 
//      UINT iTInfo,            // in
//      LCID lcid,              // in
//      ITypeInfo * * ppTInfo   // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetTypeInfo ( 
    UINT iTInfo,            // in
    LCID lcid,              // in
    ITypeInfo * * ppTInfo   // out
    )
{
    TraceClsFunc( "[IDispatch] GetTypeInfo( )\n" );

    if ( !ppTInfo )
        HRETURN( E_POINTER );

    *ppTInfo = NULL;

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetIDsOfNames ( 
//      REFIID      riid,       // in
//      LPOLESTR *  rgszNames,  // in
//      UINT        cNames,     // in
//      LCID        lcid,       // in
//      DISPID *    rgDispId    // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetIDsOfNames ( 
    REFIID      riid,       // in
    LPOLESTR *  rgszNames,  // in
    UINT        cNames,     // in
    LCID        lcid,       // in
    DISPID *    rgDispId    // out
    )
{
    TraceClsFunc( "[IDispatch] GetIDsOfName( )\n" );

    ZeroMemory( rgDispId, cNames * sizeof(DISPID) );

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::Invoke ( 
//      DISPID dispIdMember,        // in
//      REFIID riid,                // in
//      LCID lcid,                  // in
//      WORD wFlags,                // in
//      DISPPARAMS *pDispParams,    // out in
//      VARIANT *pVarResult,        // out
//      EXCEPINFO *pExcepInfo,      // out
//      UINT *puArgErr              // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::Invoke ( 
    DISPID dispIdMember,        // in
    REFIID riid,                // in
    LCID lcid,                  // in
    WORD wFlags,                // in
    DISPPARAMS *pDispParams,    // out in
    VARIANT *pVarResult,        // out
    EXCEPINFO *pExcepInfo,      // out
    UINT *puArgErr              // out
    )
{
    TraceClsFunc( "[IDispatch] Invoke( )\n" );

    HRETURN( E_NOTIMPL );
}


//****************************************************************************
//
//  IDispatchEx
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetDispID (
//      BSTR bstrName,  // in
//      DWORD grfdex,   //in
//      DISPID *pid     //out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetDispID (
    BSTR bstrName,  // in
    DWORD grfdex,   //in
    DISPID *pid     //out
    )
{
    TraceClsFunc( "[IDispatchEx] GetDispID( )\n" );

    if ( pid == NULL
      || bstrName == NULL 
       )
    {
        HRETURN( E_POINTER );
    }

    HRESULT hr = S_OK;

    TraceMsg( mtfCALLS, "Looking for: %s\n", bstrName );

    if ( StrCmpI( bstrName, L"Name" ) == 0 )
    {
        *pid = 0;
    }
    else if ( StrCmpI( bstrName, L"LogInformation" ) == 0 )
    {
        *pid = 1;
    }
    else if ( StrCmpI( bstrName, L"AddProperty" ) == 0 )
    {
        *pid = 2;
    }
    else if ( StrCmpI( bstrName, L"RemoveProperty" ) == 0 )
    {
        *pid = 3;
    }
    else
    {
        //
        //  See if it is a private property.
        //

        DWORD dwIndex;
        DWORD dwErr = ERROR_SUCCESS;

        hr = DISP_E_UNKNOWNNAME;

        //
        // Enum all the value under the \Cluster\Resources\{Resource}\Parameters.
        //
        for( dwIndex = 0; dwErr == ERROR_SUCCESS; dwIndex ++ )
        {
            WCHAR szName[ 1024 ];   // randomly large
            DWORD cbName = sizeof(szName)/sizeof(szName[0]);

            dwErr = ClusterRegEnumValue( m_hkey, 
                                         dwIndex,
                                         szName,
                                         &cbName,
                                         NULL,
                                         NULL,
                                         NULL
                                         );
            if ( dwErr == ERROR_NO_MORE_ITEMS )
                break;  // done!

            if ( dwErr != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( dwErr ) );
                goto Error;
            }

            if ( StrCmpI( bstrName, szName ) == 0 )
            {
                //
                //  Found a match.
                //
                *pid = STATIC_AUTOMATION_METHODS + dwIndex;
                hr   = S_OK;
                break;
            }

            //
            // ...else keep going.
            //
        }
    }

Cleanup:
    HRETURN( hr );

Error:
    LogError( hr );
    goto Cleanup;
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::InvokeEx ( 
//      DISPID             idIn,
//      LCID               lcidIn,
//      WORD               wFlagsIn,
//      DISPPARAMS *       pdpIn,
//      VARIANT *          pvarResOut,
//      EXCEPINFO *        peiOut,
//      IServiceProvider * pspCallerIn
//      )
//      
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::InvokeEx ( 
    DISPID             idIn,
    LCID               lcidIn,
    WORD               wFlagsIn,
    DISPPARAMS *       pdpIn,
    VARIANT *          pvarResOut,
    EXCEPINFO *        peiOut,
    IServiceProvider * pspCallerIn
    )
{
    TraceClsFunc2( "[IDispatchEx] InvokeEx( idIn = %u, ..., wFlagsIn = 0x%08x, ... )\n", idIn, wFlagsIn );

    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    switch ( idIn )
    {
    case 0: // Name
        if ( wFlagsIn & DISPATCH_PROPERTYGET )
        {
            pvarResOut->vt = VT_BSTR;
            pvarResOut->bstrVal = SysAllocString( m_pszName );
            if ( pvarResOut->bstrVal == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = S_OK;
            }
        }
        break;

    case 1: // Log
        if ( wFlagsIn & DISPATCH_METHOD )
        {
            hr = THR( LogInformation( pdpIn->rgvarg->bstrVal ) );
        }
        break;

    case 2: // AddProperty
        if ( wFlagsIn & DISPATCH_METHOD )
        {
            hr = THR( AddPrivateProperty( pdpIn ) );
        }
        break;

    case 3: // AddProperty
        if ( wFlagsIn & DISPATCH_METHOD )
        {
            hr = THR( RemovePrivateProperty( pdpIn ) );
        }
        break;

    default:
        //
        //  See if it is a private property.
        //
        if ( wFlagsIn & DISPATCH_PROPERTYGET )
        {
            hr = THR( ReadPrivateProperty( idIn - STATIC_AUTOMATION_METHODS, pvarResOut ) );
        }
        else if ( wFlagsIn & DISPATCH_PROPERTYPUT )
        {
            hr = THR( WritePrivateProperty( idIn - STATIC_AUTOMATION_METHODS, pdpIn ) );
        }
        break;

    } // switch: id

    HRETURN( hr );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::DeleteMemberByName ( 
//      BSTR bstr,   // in
//      DWORD grfdex // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::DeleteMemberByName ( 
    BSTR bstr,   // in
    DWORD grfdex // in
    )
{
    TraceClsFunc( "[IDispatchEx] DeleteMemberByName( )\n" );

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::DeleteMemberByDispID ( 
//      DISPID id   // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::DeleteMemberByDispID ( 
    DISPID id   // in
    )
{
    TraceClsFunc1( "[IDispatchEx] DeleteMemberByDispID( id = %u )\n", id );

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetMemberProperties ( 
//      DISPID id,          // in
//      DWORD grfdexFetch,  // in
//      DWORD * pgrfdex     // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetMemberProperties ( 
    DISPID id,          // in
    DWORD grfdexFetch,  // in
    DWORD * pgrfdex     // out
    )
{
    TraceClsFunc2( "[IDispatchEx] GetMemberProperties( id = %u, grfdexFetch = 0x%08x )\n",
        id, grfdexFetch );

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetMemberName ( 
//      DISPID id,          // in
//      BSTR * pbstrName    // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetMemberName ( 
    DISPID id,          // in
    BSTR * pbstrName    // out
    )
{
    TraceClsFunc1( "[IDispatchEx] GetMemberName( id = %u, ... )\n", id );

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetNextDispID ( 
//      DWORD grfdex,  // in
//      DISPID id,     // in
//      DISPID * pid   // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetNextDispID ( 
    DWORD grfdex,  // in
    DISPID id,     // in
    DISPID * pid   // out
    )
{
    TraceClsFunc2( "[IDispatchEx] GetNextDispId( grfdex = 0x%08x, id = %u, ... )\n",
        grfdex, id );

    HRETURN( E_NOTIMPL );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetNameSpaceParent ( 
//      IUnknown * * ppunk  // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetNameSpaceParent ( 
    IUnknown * * ppunk  // out
    )
{
    TraceClsFunc( "[IDispatchEx] GetNameSpaceParent( ... )\n" );

    if ( !ppunk )
        HRETURN( E_POINTER );

    *ppunk = NULL;

    HRETURN( E_NOTIMPL );
}


//****************************************************************************
//
// Private Methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::LogError(
//      HRESULT hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::LogError(
    HRESULT hrIn
    )
{
    TraceClsFunc1( "LogError( hrIn = 0x%08x )\n", hrIn );

    TraceMsg( mtfCALLS, "HRESULT: 0x%08x\n", hrIn );
    (ClusResLogEvent)( m_hResource, LOG_ERROR, L"HRESULT: 0x%1!08x!.\n", hrIn );

    HRETURN( S_OK );

} //*** LogError( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::ReadPrivateProperty(
//      DISPID      idIn,
//      VARIANT *   pvarResOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::ReadPrivateProperty(
    DISPID      idIn,
    VARIANT *   pvarResOut
    )
{
    TraceClsFunc( "ReadPrivateProperty( ... )\n" );

    BSTR *  pbstrList;

    BYTE    rgbData[ 1024 ];    // randomly large
    WCHAR   szName[ 1024 ];     // randomly large
    DWORD   dwType;
    DWORD   dwIndex;
    DWORD   dwErr;

    DWORD   cbName = sizeof(szName)/sizeof(szName[0]);
    DWORD   cbData = sizeof(rgbData);
    BOOL    fFreepData = FALSE;
    LPBYTE  pData = NULL;
    
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    //  We can jump to the exact entry because the script called 
    //  GetDispID() before calling this method. 
    //
    for ( ;; )
    {
        dwErr = ClusterRegEnumValue( m_hkey, 
                                     idIn,
                                     szName,
                                     &cbName,
                                     &dwType,
                                     rgbData,
                                     &cbData
                                     );
        if ( dwErr == ERROR_MORE_DATA )
        {
            //
            //  Make some space if our stack buffer is too small.
            //
            pData = (LPBYTE) TraceAlloc( LMEM_FIXED, cbData );
            if ( pData == NULL )
                goto OutOfMemory;

            fFreepData = TRUE;

            continue;   // try again
        }

        if ( dwErr == ERROR_NO_MORE_ITEMS )
            goto Cleanup;   // item must have dissappeared

        if ( dwErr != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( dwErr ) );
            goto Error;
        }

        Assert( dwErr == ERROR_SUCCESS );
        break;  // exit loop
    }

    //
    //  It's a private property. Convert the data into the appropriate
    //  VARIANT.
    //

    switch ( dwType )
    {
    case REG_DWORD:
        {
            DWORD * pdw = (DWORD *) rgbData;
            pvarResOut->vt = VT_I4;
            pvarResOut->intVal = *pdw;
            hr = S_OK;
        }
        break;

    case REG_EXPAND_SZ:
        {
            DWORD cbNeeded;
            WCHAR szExpandedString[ 2 * MAX_PATH ]; // randomly large
            DWORD cbSize = sizeof(szExpandedString)/sizeof(szExpandedString[0]);
            LPCWSTR pszData = (LPCWSTR) rgbData;

            cbNeeded = ExpandEnvironmentStrings( pszData, szExpandedString, cbSize );
            if ( cbSize == 0 )
                goto Win32Error;

            if ( cbNeeded > cbSize )
                goto OutOfMemory;

            pvarResOut->vt = VT_BSTR;
            pvarResOut->bstrVal = SysAllocString( szExpandedString );
            if ( pvarResOut->bstrVal == NULL )
                goto OutOfMemory;

            hr = S_OK;
        }
        break;

    case REG_MULTI_SZ:
        {
            //
            //  KB: gpease  08-FEB-2000
            //      Currently VBScript doesn't support SAFEARRAYs. So someone
            //      trying to access a multi-sz will get the following error:
            //
            //      Error: 2148139466
            //      Source: Microsoft VBScript runtime error
            //      Description: Variable uses an Automation type not supported in VBScript
            //
            //      The code is correct as far as I can tell, so I am just
            //      going to leave it in (it doesn't AV or cause bad things
            //      to happen).
            //
            VARIANT var;
            LPWSTR psz;
            DWORD  nCount;
            DWORD  cbCount;
            DWORD  cbBiggestOne;

            LPWSTR pszData = (LPWSTR) rgbData;
            LPWSTR pszEnd  = (LPWSTR) &rgbData[ cbData ];

            SAFEARRAYBOUND rgsabound[ 1 ];

            //
            //  Figure out how many item there are in the list.
            //
            cbBiggestOne = cbCount = nCount = 0;
            psz = pszData;
            while ( *psz != 0 )
            {
                psz++;
                cbCount ++;
                if ( *psz == 0 )
                {
                    if ( cbCount > cbBiggestOne )
                    {
                        cbBiggestOne = cbCount;
                    }
                    cbCount = 0;
                    nCount++;
                    psz++;
                }
            }

            Assert( psz <= pszEnd );

            //
            //  Create a safe array to package the string into.
            //
            rgsabound[0].lLbound   = 0;
            rgsabound[0].cElements = nCount;
            pvarResOut->vt = VT_SAFEARRAY;
            pvarResOut->parray = SafeArrayCreate( VT_BSTR, 1, rgsabound );
            if ( pvarResOut->parray == NULL )
                goto OutOfMemory;

            //
            //  Fix the memory location of the array so it can be accessed
            //  thru an array pointer.
            //
            hr = THR( SafeArrayAccessData( pvarResOut->parray, (void**) &pbstrList ) );
            if ( FAILED( hr ) )
                goto Error;

            //
            //  Convert the multi-string into BSTRs
            //
            psz = pszData;
            for( nCount = 0; *psz != 0 ; nCount ++ )
            {
                pbstrList[ nCount ] = SysAllocString( psz );
                if ( pbstrList[ nCount ] == NULL )
                    goto OutOfMemory;
                
                //
                //  Skip the next entry.
                //
                while ( *psz != 0 )
                {
                    psz++;
                }
                psz++;
            }

            Assert( psz <= pszEnd );

            //
            //  Release the array.
            //
            hr = THR( SafeArrayUnaccessData( pvarResOut->parray ) );
            if ( FAILED( hr ) )
                goto Error;

            hr = S_OK;
        }
        break;

    case REG_SZ:
        {
            LPCWSTR pszData = (LPCWSTR) rgbData;
            pvarResOut->bstrVal = SysAllocString( pszData );
            if ( pvarResOut->bstrVal == NULL )
                goto OutOfMemory;

            pvarResOut->vt = VT_BSTR;
            hr = S_OK;
        }
        break;

    case REG_BINARY:
    default:
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATATYPE );
        goto Error;
    } // switch: dwType

Cleanup:
    if ( fFreepData 
      && pData != NULL 
       )
    {
        TraceFree( pData );
    }

    // 
    // Make sure this has been wiped if there is a problem.
    //
    if ( FAILED( hr ) )
    {
        VariantClear( pvarResOut );
    }

    HRETURN( hr );

Error:
    LogError( hr );
    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( GetLastError( ) );
    goto Error;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::WritePrivateProperty(
//      DISPID       idIn,
//      DISPPARAMS * pdpIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::WritePrivateProperty(
    DISPID       idIn,
    DISPPARAMS * pdpIn
    )
{
    TraceClsFunc( "WritePrivateProperty( ... )\n" );

    DWORD   dwType;
    DWORD   dwErr;
    DWORD   cbData;
    UINT    uiArg;

    WCHAR   szName [ 1024 ];    // randomly large

    DWORD   cbName = sizeof(szName)/sizeof(szName[0]);
    
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    //  Do some parameter validation.
    //
    if ( pdpIn->cArgs != 1 || pdpIn->cNamedArgs > 1 )
        goto BadParamCount;

    //
    //  We can jump to the exact entry because the script called 
    //  GetDispID() before calling this method. Here we are only
    //  going to validate that the value exists and what type
    //  the value is.
    //
    dwErr = ClusterRegEnumValue( m_hkey, 
                                 idIn,
                                 szName,
                                 &cbName,
                                 &dwType,
                                 NULL,
                                 NULL
                                 );
    if ( dwErr == ERROR_NO_MORE_ITEMS )
        goto Cleanup;   // item must have dissappeared

    if ( dwErr != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( dwErr ) );
        goto Error;
    }

    //
    //  It's a private property. Convert the script data into the 
    //  appropriate VARIANT and then write it into the hive.
    //
    switch ( dwType )
    {
    case REG_DWORD:
        {
            VARIANT var;

            VariantInit( &var );

            hr = THR( DispGetParam( pdpIn, DISPID_PROPERTYPUT, VT_I4, &var, &uiArg ) );
            if ( FAILED( hr ) )
                goto Error;

            cbData = sizeof( var.intVal );
            dwErr = TW32( ClusterRegSetValue( m_hkey, szName, dwType, (LPBYTE) &var.intVal, cbData ) );
            if ( dwErr != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( dwErr );
                goto Error;
            }

            VariantClear( &var );

            hr = S_OK;
        }
        break;

    case REG_EXPAND_SZ:
    case REG_SZ:
        {
            VARIANT var;

            VariantInit( &var );

            hr = THR( DispGetParam( pdpIn, DISPID_PROPERTYPUT, VT_BSTR, &var, &uiArg ) );
            if ( FAILED( hr ) )
                goto Error;

            cbData = sizeof(WCHAR) * ( SysStringLen( var.bstrVal ) + 1 );

            dwErr = TW32( ClusterRegSetValue( m_hkey, szName, dwType, (LPBYTE) var.bstrVal, cbData ) );
            if ( dwErr != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( dwErr );
                goto Error;
            }

            VariantClear( &var );

            hr = S_OK;
        }
        break;

    case REG_MULTI_SZ:
    case REG_BINARY:
        //
        //  Can't handle these since VBScript can't generate them.
        //
    default:
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATATYPE );
        goto Error;
    } // switch: dwType

Cleanup:
    HRETURN( hr );

Error:
    LogError( hr );
    goto Cleanup;

BadParamCount:
    hr = THR( DISP_E_BADPARAMCOUNT );
    goto Error;
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::RemovePrivateProperty(
//      DISPPARAMS * pdpIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::RemovePrivateProperty(
    DISPPARAMS * pdpIn
    )
{
    TraceClsFunc( "RemovePrivateProperty( ... )\n" );

    HRESULT hr;
    DWORD   dwErr;
    UINT    uiArg;
    VARIANT var;

    VariantInit( &var );

    //
    //  Do some parameter validation.
    //
    if ( pdpIn->cArgs != 1 || pdpIn->cNamedArgs > 1 )
        goto BadParamCount;

    //
    //  Retrieve the name of the property to remove.
    //
    hr = THR( DispGetParam( pdpIn, 0, VT_BSTR, &var, &uiArg ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Delete the value from the hive.
    //
    dwErr = TW32( ClusterRegDeleteValue( m_hkey, var.bstrVal ) );
    if ( dwErr == ERROR_FILE_NOT_FOUND )
    {
        hr = THR( DISP_E_UNKNOWNNAME );
        goto Error;
    }
    else if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    }

    hr = S_OK;

Cleanup:
    VariantClear( &var );

    HRETURN( hr );

Error:
    LogError( hr );
    goto Cleanup;

BadParamCount:
    hr = THR( DISP_E_BADPARAMCOUNT );
    goto Error;
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::AddPrivateProperty(
//      DISPPARAMS * pdpIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::AddPrivateProperty(
    DISPPARAMS * pdpIn
    )
{
    TraceClsFunc( "AddPrivateProperty( ... )\n" );

    DWORD   dwType;
    DWORD   dwErr;
    DWORD   cbName;
    DWORD   cbData;
    UINT    uiArg;

    LPBYTE  pData;

    VARIANT varProperty;
    VARIANT varValue;

    HRESULT hr;

    WCHAR szNULL [] = L"";

    VariantInit( &varProperty );
    VariantInit( &varValue );

    //
    //  Do some parameter validation.
    //
    if ( pdpIn->cArgs == 0 
      || pdpIn->cArgs > 2 
      || pdpIn->cNamedArgs > 2 
       )
        goto BadParamCount;

    //
    //  Retrieve the name of the property. 
    //
    hr = THR( DispGetParam( pdpIn, 0, VT_BSTR, &varProperty, &uiArg ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  If there are 2 args, the second one indicates the default value.
    //
    if ( pdpIn->cArgs == 2 )
    {
        //
        //  DISPPARAMS are parsed in reverse order so "1" is actually the name 
        //  and "0" is the default value.
        //
        switch ( pdpIn->rgvarg[0].vt )
        {
        case VT_I4:
        case VT_I2:
        case VT_BOOL:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_INT:
        case VT_UINT:
            hr = THR( DispGetParam( pdpIn, 1, VT_I4, &varValue, &uiArg ) );
            if ( FAILED( hr ) )
                goto Error;

            dwType = REG_DWORD;
            pData  = (LPBYTE) &varValue.intVal;
            cbData = sizeof(DWORD);
            break;

        case VT_BSTR:
            hr = THR( DispGetParam( pdpIn, 1, VT_BSTR, &varValue, &uiArg ) );
            if ( FAILED( hr ) )
                goto Error;

            dwType = REG_SZ;
            pData  = (LPBYTE) varValue.bstrVal;
            cbData = sizeof(WCHAR) * ( SysStringLen( varValue.bstrVal ) + 1 );
            break;

        default:
            hr = THR( E_INVALIDARG );
            goto Error;
        }
    }
    else
    {
        //
        //  Provide a default of a NULL string.
        //
        dwType = REG_SZ;
        pData = (LPBYTE) &szNULL[0];
        cbData = sizeof(szNULL);
    }

    //
    //  Create the value in the hive.
    //
    dwErr = TW32( ClusterRegSetValue( m_hkey, varProperty.bstrVal, dwType, pData, cbData ) );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    }

    hr = S_OK;

Cleanup:
    VariantClear( &varProperty );
    VariantClear( &varValue );
    HRETURN( hr );

Error:
    LogError( hr );
    goto Cleanup;

BadParamCount:
    hr = THR( DISP_E_BADPARAMCOUNT );
    goto Error;
}

//****************************************************************************
//
// Automation Methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::LogInformation(
//      BSTR bstrString
//      )
// 
//////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::LogInformation(
    BSTR bstrString
    )
{
    TraceClsFunc1( "LogInformation( %ws )\n", bstrString );

    TraceMsg( mtfCALLS, "LOG_INFORMATION: %s\n", bstrString );

    m_pler( m_hResource, LOG_INFORMATION, L"%1\n", bstrString );

    HRETURN( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\gensvc\gensvc.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    gensvc.c

Abstract:

    Resource DLL to control and monitor NT services.

Author:


    Robs 3/28/96, based on RodGa's generic resource dll

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "userenv.h"

// Uncomment the next line to test the Terminate() function when
// a shutdown is in progress.
//#define TEST_TERMINATE_ON_SHUTDOWN

#define LOG_CURRENT_MODULE LOG_MODULE_GENSVC

#define SERVICES_ROOT L"SYSTEM\\CurrentControlSet\\Services\\"

#define DBG_PRINT printf

#define PARAM_NAME__SERVICENAME         CLUSREG_NAME_GENSVC_SERVICE_NAME
#define PARAM_NAME__STARTUPPARAMETERS   CLUSREG_NAME_GENSVC_STARTUP_PARAMS
#define PARAM_NAME__USENETWORKNAME      CLUSREG_NAME_GENSVC_USE_NETWORK_NAME

#define PARAM_MIN__USENETWORKNAME     0
#define PARAM_MAX__USENETWORKNAME     1
#define PARAM_DEFAULT__USENETWORKNAME 0

typedef struct _GENSVC_PARAMS {
    PWSTR           ServiceName;
    PWSTR           StartupParameters;
    DWORD           UseNetworkName;
} GENSVC_PARAMS, *PGENSVC_PARAMS;

typedef struct _GENSVC_RESOURCE {
    GENSVC_PARAMS   Params;
    HRESOURCE       hResource;
    HANDLE          ServiceHandle;
    RESOURCE_HANDLE ResourceHandle;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    CLUS_WORKER     PendingThread;
    BOOL            Online;
    DWORD           dwServicePid;
    HANDLE          hSem;
} GENSVC_RESOURCE, *PGENSVC_RESOURCE;

//
// Global Data
//

// Handle to service controller,  set by the first create resource call.

SC_HANDLE g_ScHandle = NULL;

// Log Event Routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE GenSvcFunctionTable;

//
// Generic Service resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
GenSvcResourcePrivateProperties[] = {
    { PARAM_NAME__SERVICENAME,       NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(GENSVC_PARAMS,ServiceName) },
    { PARAM_NAME__STARTUPPARAMETERS, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(GENSVC_PARAMS,StartupParameters) },
    { PARAM_NAME__USENETWORKNAME,    NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__USENETWORKNAME, PARAM_MIN__USENETWORKNAME, PARAM_MAX__USENETWORKNAME, 0, FIELD_OFFSET(GENSVC_PARAMS,UseNetworkName) },
    { 0 }
};

//
// Forward routines
//

BOOL
VerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag
    );

void
wparse_cmdline (
    WCHAR *cmdstart,
    WCHAR **argv,
    WCHAR *args,
    int *numargs,
    int *numchars
    );

DWORD
GenSvcGetPrivateResProperties(
    IN const PGENSVC_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
GenSvcValidatePrivateResProperties(
    IN const PGENSVC_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENSVC_PARAMS Params
    );

DWORD
GenSvcSetPrivateResProperties(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
GenSvcInvalidGenericServiceCheck(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN LPCWSTR ServiceName,
    IN HKEY ServiceKey
    );

DWORD
GenSvcIsValidService(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN LPCWSTR ServiceName
    );

DWORD
GenSvcOfflineThread(
    PCLUS_WORKER pWorker,
    IN PGENSVC_RESOURCE ResourceEntry
    );

BOOLEAN
GenSvcInit(
    VOID
    )
{
    return(TRUE);
}


BOOLEAN
WINAPI
GenSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{

    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !GenSvcInit() ) {
            return(FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return(TRUE);

} // GenSvc DllEntryPoint


DWORD
GenSvcOnlineThread(
    PCLUS_WORKER pWorker,
    IN PGENSVC_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the DiskInfo block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    SERVICE_STATUS_PROCESS      ServiceStatus;
    DWORD                       status = ERROR_SUCCESS;
    DWORD                       numchars;
    LPWSTR *                    serviceArgArray = NULL;
    DWORD                       serviceArgCount;
    SC_HANDLE                   serviceHandle;
    RESOURCE_STATUS             resourceStatus;
    DWORD                       valueSize;
    LPVOID                      Environment = NULL;
    WCHAR *                     p;
    LPWSTR                      nameOfPropInError;
    LPSERVICE_FAILURE_ACTIONS   pSvcFailureActions = NULL;
    DWORD                       cbBytesNeeded, i;
    LPQUERY_SERVICE_CONFIG      lpquerysvcconfig=NULL;
    HANDLE                      processToken = NULL;
    DWORD                       dwRetryCount = 2400; // Try 10 min max.
    DWORD                       dwRetryTick = 250; // msec

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //set it to NULL, when it is brought online and if the
    //service is not running in the system or lsa process
    //then store the process id for forceful termination
    ResourceEntry->dwServicePid = 0;
    //
    // Read our parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   GenSvcResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1!ls!' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto error_exit;
    }

    //
    // Parse the startup parameters
    //
    if ( ResourceEntry->Params.StartupParameters != NULL ) {
        //
        // Crack the startup parameters into its component arguments because
        // the service controller is not good enough to do this for us.
        // First, find out how many args we have.
        //
        wparse_cmdline( ResourceEntry->Params.StartupParameters, NULL, NULL, &serviceArgCount, &numchars );

        //
        // Allocate space for vector and strings
        //
        serviceArgArray = LocalAlloc( LMEM_FIXED,
                                      serviceArgCount * sizeof(WCHAR *) +
                                      numchars * sizeof(WCHAR) );
        if ( serviceArgArray == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        wparse_cmdline( ResourceEntry->Params.StartupParameters,
                        serviceArgArray,
                        (WCHAR *)(((char *)serviceArgArray) + serviceArgCount * sizeof(WCHAR *)),
                        &serviceArgCount,
                        &numchars );
    } else {
        serviceArgCount = 0;
        serviceArgArray = NULL;
    }

    //
    // Now open the requested service
    //

    ResourceEntry->ServiceHandle = OpenService( g_ScHandle,
                                                ResourceEntry->Params.ServiceName,
                                                SERVICE_ALL_ACCESS );

    if ( ResourceEntry->ServiceHandle == NULL ) {
        status = GetLastError();

        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_GENSVC_OPEN_FAILED,
                                       sizeof(status),
                                       &status);
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    valueSize = sizeof(QUERY_SERVICE_CONFIG);
AllocSvcConfig:
    // Query the service to make sure it is not disabled
    lpquerysvcconfig=(LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_FIXED, valueSize);
    if(lpquerysvcconfig==NULL){
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[Gensvc] Failed to allocate memory for query_service_config, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    if (!QueryServiceConfig(ResourceEntry->ServiceHandle,
                            lpquerysvcconfig,
                            valueSize,
                            &cbBytesNeeded))
    {
        status=GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER){
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"svc: Failed to query service configuration, error= %1!u!.\n",
                         status );
            goto error_exit;
        }

        status=ERROR_SUCCESS; 
        LocalFree(lpquerysvcconfig);
        lpquerysvcconfig=NULL;
        valueSize = cbBytesNeeded;
        goto AllocSvcConfig;
    }

    if (lpquerysvcconfig->dwStartType == SERVICE_DISABLED)
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"svc:The service is DISABLED\n");    
        status=ERROR_SERVICE_DISABLED;
        goto error_exit;
    }

    //
    // Make sure service is set to manual start.
    //
    ChangeServiceConfig( ResourceEntry->ServiceHandle,
                         SERVICE_NO_CHANGE,
                         SERVICE_DEMAND_START, // Manual start
                         SERVICE_NO_CHANGE,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL );

    //if any of the service action is set to service restart, set it to
    // none
    if (!(QueryServiceConfig2(ResourceEntry->ServiceHandle, SERVICE_CONFIG_FAILURE_ACTIONS,
        (LPBYTE)&valueSize, sizeof(DWORD), &cbBytesNeeded)))
    {
        status = GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER)
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"svc: Failed to query service configuration for size, error= %1!u!.\n",
                status );
            goto error_exit;
        }
        else
            status = ERROR_SUCCESS;
    }

    pSvcFailureActions = (LPSERVICE_FAILURE_ACTIONS)LocalAlloc(LMEM_FIXED, cbBytesNeeded);

    if ( pSvcFailureActions == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[Gensvc] Failed to allocate memory, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    if (!(QueryServiceConfig2(ResourceEntry->ServiceHandle, SERVICE_CONFIG_FAILURE_ACTIONS,
        (LPBYTE)pSvcFailureActions, cbBytesNeeded, &cbBytesNeeded)))
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[Gensvc] Failed to query service configuration, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    for (i=0; i<pSvcFailureActions->cActions;i++)
    {
        if (pSvcFailureActions->lpsaActions[i].Type == SC_ACTION_RESTART)
            pSvcFailureActions->lpsaActions[i].Type = SC_ACTION_NONE;
    }

    ChangeServiceConfig2(ResourceEntry->ServiceHandle,
                         SERVICE_CONFIG_FAILURE_ACTIONS,
                         pSvcFailureActions);

    if ( ResourceEntry->Params.UseNetworkName ) 
    {
        //
        // Create the new environment with the simulated net name.
        //
        Environment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    }
    else        
    {
        BOOL success;

        //
        // get the current process token. If it fails, we revert to using just the
        // system environment area
        //
        OpenProcessToken( GetCurrentProcess(), MAXIMUM_ALLOWED, &processToken );

        //
        // Clone the current environment, picking up any changes that might have
        // been made after resmon started
        //
        success = CreateEnvironmentBlock(&Environment, processToken, FALSE );
        if ( processToken != NULL ) {
            CloseHandle( processToken );
        }

        if ( !success ) {
            status = GetLastError();
            goto error_exit;
        }
    }

    if (Environment != NULL) {
        HKEY ServicesKey;
        HKEY hKey;

        //
        // Compute the size of the environment. We are looking for
        // the double NULL terminator that ends the environment block.
        //
        p = (WCHAR *)Environment;
        while (*p) {
            while (*p++) {
            }
        }
        valueSize = (DWORD)((PUCHAR)p - (PUCHAR)Environment) + 
                    sizeof(WCHAR);

        //
        // Set the environment value in the service's registry key.
        //
        status = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                LOCAL_SERVICES,
                                0,
                                KEY_READ,
                                &ServicesKey );
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to open services key, error = %1!u!.\n",
                status );
            goto error_exit;
        }

        status = RegOpenKeyExW( ServicesKey,
                                ResourceEntry->Params.ServiceName,
                                0,
                                KEY_READ | KEY_WRITE,
                                &hKey );
        RegCloseKey(ServicesKey);
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to open service key, error = %1!u!.\n",
                status );
            goto error_exit;
        }

        status = RegSetValueExW( hKey,
                                 L"Environment",
                                 0,
                                 REG_MULTI_SZ,
                                 Environment,
                                 valueSize );
        RegCloseKey(hKey);
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to set service environment value, error = %1!u!.\n",
                status );
            goto error_exit;
        }
    }

    if ( !StartServiceW( ResourceEntry->ServiceHandle,
                         serviceArgCount,
                         serviceArgArray ) )
    {
        status = GetLastError();

        if (status != ERROR_SERVICE_ALREADY_RUNNING) {

            ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                           LOG_CRITICAL,
                                           RES_GENSVC_START_FAILED,
                                           sizeof(status),
                                           &status);
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Failed to start service. Error: %1!u!.\n",
                         status );
            goto error_exit;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    //wait for the service to comeonline unless we are asked to terminate
    while (!ClusWorkerCheckTerminate(pWorker) && dwRetryCount--)  {

        //
        // Tell the Resource Monitor that we are still working.
        //
        resourceStatus.ResourceState = ClusterResourceOnlinePending;
        resourceStatus.CheckPoint++;
        (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                               &resourceStatus );
        resourceStatus.ResourceState = ClusterResourceFailed;

        if ( !QueryServiceStatusEx( ResourceEntry->ServiceHandle,
                SC_STATUS_PROCESS_INFO, (LPBYTE)&ServiceStatus, 
                sizeof(SERVICE_STATUS_PROCESS), &cbBytesNeeded ) )
        {
            status = GetLastError();

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Query Service Status failed %1!u!.\n",
                status );

            goto error_exit;
        }

        if ( ServiceStatus.dwCurrentState != SERVICE_START_PENDING ) {
            break;
        }

        Sleep(dwRetryTick);
    }

    //
    // If we terminated the loop above before setting ServiceStatus,
    // then return now.
    //
    if (ClusWorkerCheckTerminate(pWorker) || (dwRetryCount == (DWORD)-1))  {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"GensvcOnlineThread: Asked to terminate or retry period expired...\n");
        goto error_exit;
    }

    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING ) {
        
        if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
            status = ServiceStatus.dwServiceSpecificExitCode;
        } else {
            status = ServiceStatus.dwWin32ExitCode;
        }

        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_GENSVC_FAILED_AFTER_START,
                                       sizeof(status),
                                       &status);

        (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Service failed during initialization. Error: %1!u!.\n",
                status );

        goto error_exit;
    }

    resourceStatus.ResourceState = ClusterResourceOnline;
    if (!(ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS)) {
        ResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
    }

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Service is now on line.\n" );

error_exit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }

    //cleanup
    if (pSvcFailureActions) 
        LocalFree(pSvcFailureActions);
    if (lpquerysvcconfig)
        LocalFree(lpquerysvcconfig);
    LocalFree( serviceArgArray );
    if (Environment != NULL) {
        RtlDestroyEnvironment(Environment);
    }

    return(status);

} // GenSvcOnlineThread



RESID
WINAPI
GenSvcOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic service resource.
    This routine gets a handle to the service controller, if we don't already have one,
    and then gets a handle to the specified service.  The service handle is saved
    in the GENSVC_RESOURCE structure.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    RESID   svcResid = 0;
    DWORD   status;
    HKEY    parametersKey = NULL;
    HKEY    resKey = NULL;
    PGENSVC_RESOURCE resourceEntry = NULL;
    DWORD   paramNameSize = 0;
    DWORD   paramNameMaxSize = 0;
    HCLUSTER hCluster;
    LPWSTR  nameOfPropInError;    
    LPWSTR  lpwTemp=NULL;
    //
    // Open registry parameters key for this resource.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                CLUSREG_KEYNAME_PARAMETERS,
                                KEY_READ,
                                &parametersKey );

    if ( status != NO_ERROR ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key. Error: %1!u!.\n",
            status);
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // First get a handle to the service controller.
    //

    if ( g_ScHandle == NULL ) {

        g_ScHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS);

        if ( g_ScHandle == NULL ) {
            status = GetLastError();
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to open service control manager, error %1!u!.\n",
                status);
            goto error_exit;
        }
    }

    resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(GENSVC_RESOURCE) );

    if ( resourceEntry == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a service info structure.\n");
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEntry, sizeof(GENSVC_RESOURCE) );

    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;

    resourceEntry->hSem= NULL;
    status = ResUtilGetPropertiesToParameterBlock( resourceEntry->ParametersKey,
                                                   GenSvcResourcePrivateProperties,
                                                   (LPBYTE) &resourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status == ERROR_SUCCESS ) {

        // Create the Semaphore - this will be executed only if this is not a new
        // GenericService Type resource being created for the first time
        lpwTemp = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                     (lstrlenW(resourceEntry->Params.ServiceName)+
                                      lstrlenW(L"GenSvc$")+1)*sizeof(WCHAR));
        if (lpwTemp==NULL)
        {
            status=GetLastError();
            (g_LogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Service '%1!ls!': Not enough memory for storing semaphore name. Error: %2!u!.\n",
                    resourceEntry->Params.ServiceName,
                    status );
            goto error_exit;
        }

        lstrcpyW(lpwTemp,L"GenSvc$");
        lstrcat(lpwTemp,resourceEntry->Params.ServiceName);        

        resourceEntry->hSem=CreateSemaphore(NULL,0,1,lpwTemp); 
        status=GetLastError();
        if(resourceEntry->hSem)
        {
            // Check if there is another resource controlling the same service
            if(status==ERROR_OBJECT_ALREADY_EXISTS)
            {
                (g_LogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Service '%1!ls!' is controlled by another resource. Error: %2!u!.\n",
                    resourceEntry->Params.ServiceName,
                    status );
                CloseHandle(resourceEntry->hSem);
                resourceEntry->hSem = NULL;
                goto error_exit;
            }  
        }
        else
        {
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to create semaphore for Service '%1!ls!' . Error: %2!u!.\n",
                resourceEntry->Params.ServiceName,
                status );
            goto error_exit;
        }    
        
    }
    else {
        (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to read parameters from registry  for Service '%1!ls!' . Error: %2!u!, property in error is '%3!ls!' .\n",
                resourceEntry->Params.ServiceName,
                status,
                nameOfPropInError);
    }

    status = ERROR_SUCCESS;

    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open cluster, error %1!u!.\n",
            status );
        goto error_exit;
    }

    resourceEntry->hResource = OpenClusterResource(hCluster, ResourceName);
    status = GetLastError();
    CloseCluster(hCluster);
    if ( resourceEntry->hResource == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource, error %1!u!.\n", status );
        goto error_exit;
    }

    svcResid = (RESID)resourceEntry;

    return(svcResid);

error_exit:

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }
    if ( resKey != NULL) {
        ClusterRegCloseKey( resKey );
    }

    if ( resourceEntry != NULL)  {
        LocalFree( resourceEntry );
    }

    if (lpwTemp) {
        LocalFree(lpwTemp);
    }

    SetLastError( status );

    return((RESID)NULL);

} // GenSvcOpen


DWORD
WINAPI
GenSvcOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Generic Service resource.

Arguments:

    ResourceId - Supplies resource id to be brought online

    EventHandle - Supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    DWORD   status;
    PGENSVC_RESOURCE resourceEntry;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: Online request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               GenSvcOnlineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenSvcOnline


VOID
WINAPI
GenSvcTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Generic Application resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    SERVICE_STATUS ServiceStatus;
    PGENSVC_RESOURCE resourceEntry;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: Terminate request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Terminate request.\n" );

#ifdef TEST_TERMINATE_ON_SHUTDOWN
    {
        DWORD   dwStatus;
        BOOLEAN fWasEnabled;

        //
        // Test terminate on shutdown code.
        //
        (g_LogEvent)(
           resourceEntry->ResourceHandle,
           LOG_ERROR,
           L"GenSvcTerminate: TEST_TERMINATE_ON_SHUTDOWN - enabling shutdown privilege.\n"
           );
        dwStatus = ClRtlEnableThreadPrivilege(
                    SE_SHUTDOWN_PRIVILEGE,
                    &fWasEnabled
                    );
        if ( dwStatus != ERROR_SUCCESS ) {
            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"GetSvcTerminate: TEST_TERMINATE_ON_SHUTDOWN - Unable to enable shutdown privilege. Error: %1!u!...\n",
                dwStatus
                );
        } else {
            AbortSystemShutdown( NULL );
            (g_LogEvent)(
               resourceEntry->ResourceHandle,
               LOG_ERROR,
               L"GenSvcTerminate: TEST_TERMINATE_ON_SHUTDOWN - initiating system shutdown.\n"
               );
            if ( ! InitiateSystemShutdown(
                        NULL,   // lpMachineName
                        L"Testing Generic Service cluster resource DLL",
                        0,      // dwTimeout
                        TRUE,   // bForceAppsClosed
                        TRUE    // bRebootAfterShutdown
                        ) ) {
                dwStatus = GetLastError();
                (g_LogEvent)(
                   resourceEntry->ResourceHandle,
                   LOG_ERROR,
                   L"GenSvcTerminate: TEST_TERMINATE_ON_SHUTDOWN - Unable to shutdown the system. Error: %1!u!.\n",
                   dwStatus
                   );
            } else {
                Sleep( 30000 );
            }
            ClRtlRestoreThreadPrivilege(
                SE_SHUTDOWN_PRIVILEGE,
                fWasEnabled
                );
        }
    }
#endif

    //if there is a pending thread close it
    //if the online pending thread is active, the service may be online
    //if the offline pending thread is active, the service might be offline
    ClusWorkerTerminate( &resourceEntry->PendingThread );

    //if the service isnt gone by now, terminate it forcibly
    if ( resourceEntry->ServiceHandle != NULL ) 
    {
        DWORD   dwRetryCount= 100;
        BOOL    didStop = FALSE;
        DWORD   dwRetryTick = 300;      // 300 msec at a time
        DWORD   dwStatus;  

            
        while (dwRetryCount--)
        {

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"GenSvcTerminate : calling SCM (didStop=%1!d!)\n",
                didStop
                );

            dwStatus = (ControlService(
                            resourceEntry->ServiceHandle,
                            (didStop
                             ? SERVICE_CONTROL_INTERROGATE
                             : SERVICE_CONTROL_STOP),
                            &ServiceStatus )
                      ? NO_ERROR
                      : GetLastError());

            if (dwStatus == NO_ERROR) 
            {
                didStop = TRUE;
                if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
                {

                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"Service stopped.\n" );

                    //set the status                                    
                    resourceEntry->Online = FALSE;
                    resourceEntry->dwServicePid = 0;
                    break;
                }
            }

            // 
            //  Chittur Subbaraman (chitturs) - 2/21/2000
            //
            //  Since SCM doesn't accept any control requests during
            //  windows shutdown, don't send any more control
            //  requests. Just exit from this loop and terminate
            //  the process brute force.
            //
            if ( dwStatus == ERROR_SHUTDOWN_IN_PROGRESS )
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"System shutdown in progress. Will try to terminate process brute force...\n" );
                break;
            }

            if (dwStatus == ERROR_EXCEPTION_IN_SERVICE ||
                dwStatus == ERROR_PROCESS_ABORTED ||
                dwStatus == ERROR_SERVICE_NOT_ACTIVE) 
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service died; status = %1!u!.\n",
                    dwStatus);
                
                //set the status                                    
                resourceEntry->Online = FALSE;
                resourceEntry->dwServicePid = 0;
                break;
            }

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"GenSvcTerminate: retrying...\n" );

            Sleep(dwRetryTick);

        }
        //declare this service is offline
        //if there is a pid for this, try and terminate that process
        //note that terminating a process doesnt terminate all
        //the child processes
        //also if it is running in a system process, we do nothing
        //about it
        if (resourceEntry->dwServicePid)
        {
            DWORD dwResourceState;

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"GenSvcTerminate: Attempting to terminate process with pid=%1!u!...\n",
                resourceEntry->dwServicePid );

            ResUtilTerminateServiceProcessFromResDll( resourceEntry->dwServicePid,
                                                      FALSE, // bOffline
                                                      &dwResourceState,
                                                      g_LogEvent,
                                                      resourceEntry->ResourceHandle );
        }                
        CloseServiceHandle( resourceEntry->ServiceHandle );
        resourceEntry->ServiceHandle = NULL;
        resourceEntry->dwServicePid = 0;
    }        
    resourceEntry->Online = FALSE;

    return;

} // GenSvcTerminate



DWORD
WINAPI
GenSvcOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Generic Service resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    PGENSVC_RESOURCE resourceEntry;
    DWORD            status;
    
    resourceEntry = (PGENSVC_RESOURCE)ResourceId;
    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: Offline request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               GenSvcOfflineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenSvcOffline


DWORD
GenSvcOfflineThread(
    PCLUS_WORKER pWorker,
    IN PGENSVC_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a generic resource offline

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the DiskInfo block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    RESOURCE_STATUS resourceStatus;
    DWORD           retryTick = 300;      // 300 msec at a time
    DWORD           status = ERROR_SUCCESS;
    BOOL            didStop = FALSE;
    SERVICE_STATUS  ServiceStatus;
    DWORD           dwRetryCount = 2000; //  Try 10 min max.

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //check if the service has gone offline or was never brought online
    if ( ResourceEntry->ServiceHandle == NULL )
    {
        resourceStatus.ResourceState = ClusterResourceOffline;
        goto FnExit;
    }

    //try to stop the cluster service, wait for it to be terminated
    //as long as we are not asked to terminate
    while (!ClusWorkerCheckTerminate(pWorker) && dwRetryCount--) {


        //
        // Tell the Resource Monitor that we are still working.
        //
        resourceStatus.ResourceState = ClusterResourceOfflinePending;
        resourceStatus.CheckPoint++;
        (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                               &resourceStatus );
        resourceStatus.ResourceState = ClusterResourceFailed;

        //
        // Request that the service be stopped, or if we already did that,
        // request the current status of the service.
        //
        status = (ControlService(
                        ResourceEntry->ServiceHandle,
                        (didStop
                         ? SERVICE_CONTROL_INTERROGATE
                         : SERVICE_CONTROL_STOP),
                        &ServiceStatus )
                  ? NO_ERROR
                  : GetLastError());

        if (status == NO_ERROR) {

            didStop = TRUE;

            if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service stopped.\n" );

                //set the status                                    
                ResourceEntry->Online = FALSE;
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service is now offline.\n" );
                break;
            }
        }

        if (status == ERROR_EXCEPTION_IN_SERVICE ||
            status == ERROR_PROCESS_ABORTED ||
            status == ERROR_SERVICE_NOT_ACTIVE) {

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service died or not active any more; status = %1!u!.\n",
                status);
                
            //set the status                                    
            ResourceEntry->Online = FALSE;
            resourceStatus.ResourceState = ClusterResourceOffline;
            CloseServiceHandle( ResourceEntry->ServiceHandle );
            ResourceEntry->ServiceHandle = NULL;
            ResourceEntry->dwServicePid = 0;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service is now offline.\n" );
            break;

        }

        //
        //  Chittur Subbaraman (chitturs) - 2/21/2000
        //
        //  Handle the case in which the SCM refuses to accept control
        //  requests since windows is shutting down.
        //
        if ( status == ERROR_SHUTDOWN_IN_PROGRESS ) 
        {
            DWORD   dwResourceState;
            
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"GenSvcOfflineThread: System shutting down. Attempt to terminate service process %1!u!...\n",
                ResourceEntry->dwServicePid );

            status = ResUtilTerminateServiceProcessFromResDll( ResourceEntry->dwServicePid,
                                                               TRUE, // bOffline
                                                               &dwResourceState,
                                                               g_LogEvent,
                                                               ResourceEntry->ResourceHandle );
            if ( status == ERROR_SUCCESS )
            {
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                ResourceEntry->Online = FALSE;
            }
            resourceStatus.ResourceState = dwResourceState;
            break;            
        }
        
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Offline: retrying...\n" );

        Sleep(retryTick);
    }


FnExit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return(status);

} // GenSvcOfflineThread


BOOL
WINAPI
GenSvcIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Generic service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - if service is running

    FALSE - if service is in any other state

--*/
{
    return( VerifyService( ResourceId, TRUE ) );

} // GenSvcIsAlive


BOOL
VerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag
    )

/*++

Routine Description:

        Verify that a specified service is running

Arguments:

        ResourceId - Supplies the resource id
        IsAliveFlag - Says this is an IsAlive call - used only for debug print

Return Value:

        TRUE - if service is running or starting

        FALSE - service is in any other state

--*/
{
    SERVICE_STATUS ServiceStatus;
    PGENSVC_RESOURCE resourceEntry;
    DWORD   status = TRUE;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: IsAlive request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(FALSE);
    }

#ifdef TEST_TERMINATE_ON_SHUTDOWN
    //
    // Test terminate on shutdown.
    //
    if ( IsAliveFlag ) {
         (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"GenSvcIsAlive: TEST_TERMINATE_ON_SHUTDOWN - Artificially failing IsAlive call.\n",
            GetLastError() );
        return FALSE;
    }
#endif

    if ( !QueryServiceStatus( resourceEntry->ServiceHandle,
                              &ServiceStatus ) ) {

         (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Query Service Status failed %1!u!.\n",
            GetLastError() );
         return(FALSE);
    }

    //
    //  Now check the status of the service
    //

    if ( (ServiceStatus.dwCurrentState != SERVICE_RUNNING) &&
         (ServiceStatus.dwCurrentState != SERVICE_START_PENDING) ) {
        status = FALSE;
    }

    if (!status) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed the IsAlive test. Current State is %1!u!.\n",
            ServiceStatus.dwCurrentState );
    }

    return(status);

} // Verify Service


BOOL
WINAPI
GenSvcLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Generic Service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return( VerifyService( ResourceId, FALSE ) );

} // GenSvcLooksAlive



VOID
WINAPI
GenSvcClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Generic Applications resource.
    This routine will stop the service, and delete the cluster
    information regarding that service.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PGENSVC_RESOURCE resourceEntry;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );

    //
    // Shut it down if it's on line
    //

    GenSvcTerminate( ResourceId );

    ResUtilFreeParameterBlock( (LPBYTE) &(resourceEntry->Params), 
                               NULL,
                               GenSvcResourcePrivateProperties );

    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );
    CloseHandle(resourceEntry->hSem);

    LocalFree( resourceEntry );

} // GenSvcClose

//
// Following logic stolen from the CRTs so that our command line parsing
// works the same as the standard CRT parsing.
//
void
wparse_cmdline (
    WCHAR *cmdstart,
    WCHAR **argv,
    WCHAR *args,
    int *numargs,
    int *numchars
    )
{
    WCHAR *p;
    WCHAR c;
    int inquote;                /* 1 = inside quotes */
    int copychar;               /* 1 = copy char to *args */
    unsigned numslash;                  /* num of backslashes seen */

    *numchars = 0;
    *numargs = 0;

    p = cmdstart;

    inquote = 0;

    /* loop on each argument */
    for(;;) {

        if ( *p ) {
            while (*p == L' ' || *p == L'\t')
                ++p;
        }

        if (*p == L'\0')
            break;              /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = args;     /* store ptr to arg */
        ++*numargs;


    /* loop through scanning one argument */
        for (;;) {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
               2N+1 backslashes + " ==> N backslashes + literal "
               N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == L'\\') {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == L'\"') {
                /* if 2N backslashes before, start/end quote, otherwise
                    copy literally */
                if (numslash % 2 == 0) {
                    if (inquote) {
                        if (p[1] == L'\"')
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    } else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--) {
                if (args)
                    *args++ = L'\\';
                ++*numchars;
            }

            /* if at end of arg, break loop */
            if (*p == L'\0' || (!inquote && (*p == L' ' || *p == L'\t')))
                break;

            /* copy character into argument */
            if (copychar) {
                if (args)
                    *args++ = *p;
                ++*numchars;
            }
            ++p;
        }

        /* null-terminate the argument */

        if (args)
            *args++ = L'\0';          /* terminate string */
        ++*numchars;
    }

} // wparse_cmdline



DWORD
GenSvcResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Generic Service resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PGENSVC_RESOURCE    resourceEntry;
    DWORD               required;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: ResourceControl request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenSvcResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenSvcResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = GenSvcGetPrivateResProperties( resourceEntry,
                                                    OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = GenSvcValidatePrivateResProperties( resourceEntry,
                                                         InBuffer,
                                                         InBufferSize,
                                                         NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = GenSvcSetPrivateResProperties( resourceEntry,
                                                    InBuffer,
                                                    InBufferSize );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenSvcResourceControl



DWORD
GenSvcResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Generic Service resources.

    Perform the control request specified by ControlCode on this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenSvcResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenSvcResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenSvcResourceTypeControl



DWORD
GenSvcGetPrivateResProperties(
    IN const PGENSVC_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type Generic Service.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      GenSvcResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // GenSvcGetPrivateResProperties



DWORD
GenSvcValidatePrivateResProperties(
    IN const PGENSVC_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENSVC_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Generic Service.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    ERROR_DEPENDENCY_NOT_FOUND - Trying to set UseNetworkName when there
        is no dependency on a Network Name resource.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENSVC_PARAMS   currentProps;
    GENSVC_PARAMS   newProps;
    PGENSVC_PARAMS  pParams = NULL;
    BOOL            hResDependency;
    LPWSTR          lpwTemp=NULL;
    LPWSTR          nameOfPropInError;
    WCHAR           netnameBuffer[ MAX_PATH + 1 ];
    DWORD           netnameBufferSize = sizeof( netnameBuffer ) / sizeof( WCHAR );

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 GenSvcResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1!ls!' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status
            );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(GENSVC_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       GenSvcResourcePrivateProperties
                                       );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( GenSvcResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams
                                         );
    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //
    // Validate the parameter values.
    //
    status = GenSvcIsValidService( ResourceEntry, pParams->ServiceName );
    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //
    // If the resource should use the network name as the computer
    // name, make sure there is a dependency on a Network Name
    // resource.
    //
    if ( pParams->UseNetworkName ) {
        hResDependency = GetClusterResourceNetworkName( ResourceEntry->hResource,
                                                        netnameBuffer,
                                                        &netnameBufferSize
                                                        );
        if ( ! hResDependency ) {
            status = ERROR_DEPENDENCY_NOT_FOUND;
        }
    }

    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }


    if ( ResourceEntry->hSem == NULL ) {
        // This is executed only if this is a new resource being created
        lpwTemp = (LPWSTR) LocalAlloc( LMEM_FIXED,
                                       ( lstrlenW( pParams->ServiceName ) + lstrlenW( L"GenSvc$" ) + 1 ) * sizeof(WCHAR) );
        if ( lpwTemp == NULL ) {
            status = GetLastError();
            (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Service '%1!ls!': Not enough memory for storing semaphore name. Error: %2!u!.\n",
                    pParams->ServiceName,
                    status
                    );
            goto FnExit;
        }
        lstrcpyW( lpwTemp, L"GenSvc$" );
        lstrcat( lpwTemp, pParams->ServiceName ); 
        
        ResourceEntry->hSem = CreateSemaphore( NULL, 0, 1,lpwTemp );
        status=GetLastError();
    
        if ( ResourceEntry->hSem ) {
            // Check if there is another resource controlling the same service
            if ( status == ERROR_OBJECT_ALREADY_EXISTS ) {   
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Service '%1!ls!' is controlled by another resource. Error: %2!u!.\n",
                    pParams->ServiceName,
                    status
                    );
                CloseHandle( ResourceEntry->hSem );
                ResourceEntry->hSem = NULL;
                goto FnExit;
            }
        } else {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SetPrivateProperties: Unable to create Semaphore %1!ls! for Service '%2!ls!' . Error: %3!u!.\n",
                lpwTemp,
                pParams->ServiceName,
                status
                );
            return(status);
        }
    }

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL) )
        || ( pParams == &newProps )
        ) {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   GenSvcResourcePrivateProperties
                                   );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        GenSvcResourcePrivateProperties
        );

    if ( lpwTemp ) {
        LocalFree( lpwTemp );
    }

    return(status);

} // GenSvcValidatePrivateResProperties



DWORD
GenSvcSetPrivateResProperties(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Generic Service.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENSVC_PARAMS   params;

    ZeroMemory( &params, sizeof(GENSVC_PARAMS) );

    //
    // Parse and validate the properties.
    //
    status = GenSvcValidatePrivateResProperties( ResourceEntry,
                                                 InBuffer,
                                                 InBufferSize,
                                                 &params );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               GenSvcResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );
  


    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               GenSvcResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( ResourceEntry->Online ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // GenSvcSetPrivateResProperties



DWORD
GenSvcInvalidGenericServiceCheck(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN LPCWSTR ServiceName,
    IN HKEY ServiceKey
    )

/*++

Routine Description:

    Determines if the specified service is an invalid service for
    use as a generic service.  Invalid services include the cluster
    service and any services upon which it depends.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    ServiceName - Service name to verify.

    ServiceKey - Key for the root to begin checking at.  If specified as
        NULL, the cluster service key will be opened.

Return Value:

    ERROR_SUCCESS - Service is valid for a Generic Service resource.

    ERROR_NOT_SUPPORTED - Service can not be used for a Generic Service resource.

--*/

{
    DWORD   status;
    DWORD   valueType;
    DWORD   valueLength;
    LPWSTR  value = NULL;
    LPWSTR  currentValue;
    HKEY    clusterServiceKey = NULL;
    HKEY    serviceKey = NULL;
    WCHAR   serviceKeyName[2048];

    //
    // If no key specified, check against cluster service.
    //
    if ( ServiceKey == NULL ) {
        if ( lstrcmpiW( ServiceName, L"ClusSvc" ) == 0 ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Resource for ClusSvc is not supported.\n"
                );
            return(ERROR_NOT_SUPPORTED);
        }

        status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               SERVICES_ROOT L"ClusSvc",
                               0,
                               KEY_READ,
                               &clusterServiceKey
                               );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to open the '" SERVICES_ROOT L"ClusSvc' registry key. Error: %1!u!.\n",
                status
                );
            return(status);
        }
        ServiceKey = clusterServiceKey;
    }

    //
    // Read the DependOnService value.
    //
    status = RegQueryValueEx( ServiceKey,
                              L"DependOnService",
                              NULL,
                              &valueType,
                              NULL,
                              &valueLength
                              );
    if ( status != ERROR_SUCCESS ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        } else {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to get the length of the DependOnService value. Error: %1!u!.\n",
                status
                );
        }
        goto done;
    }
    value = LocalAlloc( LMEM_FIXED, valueLength );
    if ( value == NULL ) {
        status = GetLastError();
        goto done;
    }
    status = RegQueryValueEx( ServiceKey,
                              L"DependOnService",
                              NULL,
                              &valueType,
                              (LPBYTE) value,
                              &valueLength
                              );
    if ( status != ERROR_SUCCESS ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        } else {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to read the DependOnService value. Error: %1!u!.\n",
                status
                );
        }
        goto done;
    }

    //
    // Loop through each entry in the string.
    //
    for ( currentValue = value ; 
          ( ( currentValue-value ) * sizeof ( WCHAR ) < valueLength );
          currentValue += lstrlenW( currentValue ) + 1 ) {

        //
        // Break out once you reach the end of the REG_MULTI_SZ 
        //
        if ( *currentValue == L'\0' ) {
            status = ERROR_SUCCESS;
            goto done;
        }

        //
        // Compare against this service.
        //
        if ( lstrcmpiW( ServiceName, currentValue ) == 0 ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Creating a resource for a service (%1!ls!) upon which ClusSvc is dependent, either directly or indirectly, is not supported.\n",
                ServiceName
                );
            status = ERROR_NOT_SUPPORTED;
            goto done;
        }

        //
        // Open this service's key.
        //
        if ( (lstrlenW( ServiceName ) * sizeof( WCHAR )) + sizeof( SERVICES_ROOT ) > sizeof( serviceKeyName ) ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Registry key for the '%1!ls!' service is longer than %2!d! bytes.\n",
                ServiceName,
                sizeof( serviceKeyName )
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
        wsprintfW( serviceKeyName, SERVICES_ROOT L"%s", currentValue );
        status = RegOpenKey( HKEY_LOCAL_MACHINE,
                             serviceKeyName,
                             &serviceKey
                             );
        if ( status != ERROR_SUCCESS ) {
            if ( status == ERROR_FILE_NOT_FOUND ) {
                // Ignore services that don't exist in the registry.
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Unable to open the '%1!ls!' registry key. Error: %2!u!. Error ignored.\n",
                    serviceKeyName,
                    status
                    );
                status = ERROR_SUCCESS;
                continue;
            } else {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to open the '%1!ls!' registry key. Error: %2!u!.\n",
                    serviceKeyName,
                    status
                    );
                goto done;
            }
        }

        //
        // Check this service's dependencies.
        //
        status = GenSvcInvalidGenericServiceCheck( ResourceEntry, ServiceName, serviceKey );
        if ( status != ERROR_SUCCESS ) {
            goto done;
        }
        RegCloseKey( serviceKey );
        serviceKey = NULL;
    }

done:
    if ( clusterServiceKey != NULL ) {
        RegCloseKey( clusterServiceKey );
    }
    if ( serviceKey != NULL ) {
        RegCloseKey( serviceKey );
    }
    if ( value != NULL ) {
        LocalFree( value );
    }
    return(status);

} // GenSvcInvalidGenericServiceCheck



DWORD
GenSvcIsValidService(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN LPCWSTR ServiceName
    )

/*++

Routine Description:

    Determines if the specified service is a valid service or not.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    ServiceName - Service name to verify.

Return Value:

    ERROR_SUCCESS - Service is valid for a Generic Service resource.

    Any status returned by OpenSCManager(), OpenService(), or
    GenSvcInvalidGenericServiceCheck.

--*/

{
    DWORD   status;
    HANDLE  scManagerHandle;
    HANDLE  serviceHandle;

    scManagerHandle = OpenSCManager( NULL,        // local machine
                                     NULL,        // ServicesActive database
                                     SC_MANAGER_ALL_ACCESS ); // all access

    if ( scManagerHandle == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Cannot access service controller for validating service '%1!ws!'. Error: %2!u!....\n",
            ServiceName,
            status
            );
        return(status);
    }

    serviceHandle = OpenService( scManagerHandle,
                                 ServiceName,
                                 SERVICE_ALL_ACCESS );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Cannot open service '%1!ws!'. Error: %2!u!....\n",
            ServiceName,
            status
            );
    } else {
        status = GenSvcInvalidGenericServiceCheck( ResourceEntry, ServiceName, NULL );
    }

    CloseServiceHandle( serviceHandle );
    CloseServiceHandle( scManagerHandle );
    return(status);

} // GenSvcIsValidService

//***********************************************************
//
// Define Function Table
//
//***********************************************************


CLRES_V1_FUNCTION_TABLE( GenSvcFunctionTable,  // Name
                         CLRES_VERSION_V1_00,  // Version
                         GenSvc,               // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         GenSvcResourceControl,// ResControl
                         GenSvcResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\spinlock.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      SpinLock.h
//
//  Description:
//      Spin Lock implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CSpinLock
class 
CSpinLock
{
private: // Data
    LONG *  m_plLock;           // pointer to the lock
    LONG    m_lSpinCount;       // counts the number of sleeps
    LONG    m_lTimeout;         // count until acquire lock fails
#if DBG==1
    BOOL    m_fAcquired;        // DEBUG: internal state of the lock
    BOOL    m_fAcquiredOnce;    // DEBUG: lock was acquired at least once.
#endif

public: // Methods
    explicit 
        CSpinLock( LONG * plLock, LONG lTimeout ) : 
            m_plLock( plLock ),
            m_lTimeout( lTimeout )
    { 
        Assert( m_lTimeout >= 0 || m_lTimeout == INFINITE );
#if DBG==1
        m_fAcquired     = FALSE;
        m_fAcquiredOnce = FALSE;
#endif
    };

    //
    ~CSpinLock() 
    { 
#if DBG==1
        AssertMsg( m_fAcquired     == FALSE, "Lock was not released!" ); 
        AssertMsg( m_fAcquiredOnce != FALSE, "Lock was never acquired. Why was I needed?" );
#endif
    };

    //////////////////////////////////////////////////////////////////////////
    //
    // HRESULT
    // AcquireLock( void )
    //
    // Description:
    //      Acquires the spin lock. Does not return until the lock is 
    //      acquired.
    //
    // Arguments:
    //      None.
    //
    // Return Values:
    //      S_OK    - Sucess.
    //      HRESULT_FROM_WIN32( ERROR_LOCK_FAILED ) - Lock failed.
    //
    //////////////////////////////////////////////////////////////////////////
    HRESULT
        AcquireLock( void )
    {
        HRESULT hr;
        LONG l = TRUE;

#if DBG==1
        AssertMsg( m_fAcquired == FALSE, "Trying to acquire a lock that it already own. Thread is going to freeze up." );
        m_fAcquiredOnce = TRUE;
#endif

        m_lSpinCount = 0;

        for(;;)
        {
            l = InterlockedCompareExchange( m_plLock, TRUE, FALSE );
            if ( l == FALSE )
            {
                //
                // Lock acquired.
                //
                hr = S_OK;
                break;
            } // if: got lock
            else
            {
                m_lSpinCount++;
                if ( m_lSpinCount > m_lTimeout )
                {
                    AssertMsg( m_lSpinCount >= 0, "This lock doesn't seem to have been released properly." );
                    if ( m_lTimeout != INFINITE )
                    {
                        hr = THR( HRESULT_FROM_WIN32( ERROR_LOCK_FAILED ) );
                        break;

                    } // if: not infinite

                } // if: count exceeded

                //
                // Put a breakpoint here if you think that someone is double
                // locking.
                //
                Sleep( 1 );

            } // if: lock not acquired

        } // for: forever        

#if DBG==1
        m_fAcquired = TRUE;
#endif
        return hr;
    }; // AcquireLock( )

    //////////////////////////////////////////////////////////////////////////
    //
    // HRESULT
    // ReleaseLock( void )
    //
    // Description:
    //      Releases the spin lock. Return immediately.
    //
    // Arguments:
    //      None.
    //
    // Return Values:
    //      S_OK    - Success.
    //
    //////////////////////////////////////////////////////////////////////////
    HRESULT
        ReleaseLock( void )
    {
#if DBG==1
        AssertMsg( m_fAcquired == TRUE, "Releasing a lock that was not owned." );
#endif
        *m_plLock   = FALSE;
#if DBG==1
        m_fAcquired = FALSE;
#endif
        return S_OK;
    }; // ReleaseLock( )

}; // class CSpinLock
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\iis\iis.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    iis.c

Abstract:

    Resource DLL for IIS. This DLL supports the following IIS services
        WWW
        FTP
        GOPHER

    Each instance of a resouce is an IIS Virtual Roots. A
    Virtual root may have dependencies on IP Addresses, Names, Physical Disks, or UNC names.

    Known Limitations
    1. The current version expects that the IIS "Virtual Root" information is created
       using the Inet manager tool (inetmgr). The "Cluster" resource contains
         . Root Name
         . Directory
         . IP Address [OPTIONAL]
       Currently, this dll does not support Virtual Roots containing access information
       (i.e. password)

    2. The IIS management interfaces update the "Virtual Root" information in the registry. This
       means the OPEN call needs to remove any "Virtual Root" managed by the cluster. Otherwise,
       the it's possible for the resource to be incorrectly online after the Open (i.e., the
       cluster crashed without doing a offline).


Author:

    Pete Benoit (v-pbenoi) 12-SEP-1996

Revision History:
    Pete Benoit (v-pbenoi) 10-MAR-1997
        Updated to use clusres utility functions, add more error codes,
        get rid of routines replaced by clusres, added global mutext so
        iis resource dll's running in separate resource monitors have controled
        access to virtual root updates (NOTE: the IIS Management utility still
                breaks this exclusion)

--*/


#include "iisutil.h"
#include "resmonp.h"


//
// Names used to start service
//

LPCWSTR ActualServiceName[] = {
        L"W3SVC",                   // WWW
        L"MSFTPSVC",                // FTP
        L"GOPHERSVC"                // GOPHER
    };

#define IIS_SEMAPHORE_NAME                  L"$$$IIS$VIRTUAL$ROOT$MODIFY$SEMAPHORE$"

#define PARAM_NAME__SERVICENAME         L"ServiceName"
#define PARAM_NAME__ALIAS               L"Alias"
#define PARAM_NAME__DIRECTORY           L"Directory"
#define PARAM_NAME__ACCESSMASK          L"AccessMask"
/* Remove for the first release
#define PARAM_NAME__ACCOUNTNAME         L"AccountName"
#define PARAM_NAME__PASSWORD            L"Password"
*/

#define PARAM_MIN__ACCESSMASK       0
#define PARAM_MAX__ACCESSMASK       0xFFFFFFFF
#define PARAM_DEFAULT__ACCESSMASK       0


//
// Global data.
//
// The current IIS management (2-3.0) interface does not have
// an API to get/remove a single virtual root entry. Each update requires
// a read (all virtual roots) modify (a virtual root) write (all virtual roots) sequence.
// This mutex guards a read/modify/write sequence.
//
// This is a global mutex to guard for multiple iis resources (i.e., ones running in
// separate resource monitors) NOTE: This does not solve potential
// conflicts with the inetmgr application modifying a root at the same time
//
HANDLE                          g_hIISUpdateVirtualRootLock = NULL;

LPIIS_RESOURCE                  g_IISTable[MAX_IIS_RESOURCES] = { 0 };

PLOG_EVENT_ROUTINE              g_IISLogEvent = NULL;
PSET_RESOURCE_STATUS_ROUTINE    g_IISSetResourceStatus = NULL;

extern CLRES_FUNCTION_TABLE     IISFunctionTable;


//
// IIS resource private read-write parameters.
//
RESUTIL_PROPERTY_ITEM
IISResourcePrivateProperties[] = {
    { PARAM_NAME__SERVICENAME, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(IIS_PARAMS,ServiceName) },
    { PARAM_NAME__ALIAS,       NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(IIS_PARAMS,Alias) },
    { PARAM_NAME__DIRECTORY,   NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(IIS_PARAMS,Directory) },
    { PARAM_NAME__ACCESSMASK,  NULL, CLUSPROP_FORMAT_DWORD, 0, PARAM_MIN__ACCESSMASK, PARAM_MAX__ACCESSMASK, 0, FIELD_OFFSET(IIS_PARAMS,AccessMask) },
    { 0 }
};

//
// Forward routines
//
DWORD
OnlineVirtualRootExclusive(
    IN LPIIS_RESOURCE   ResourceEntry
    );

DWORD
OfflineVirtualRootExclusive(
    IN LPIIS_RESOURCE   ResourceEntry
    );

BOOL
WINAPI
IISIsAlive(
    IN RESID Resource
    );


LPIIS_RESOURCE
GetValidResource(
    IN RESID    Resource,
    IN LPWSTR   RoutineName
    );

DWORD
IISReadParameters(
    IN OUT LPIIS_RESOURCE ResourceEntry
    );

DWORD
IISGetPrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
IISValidatePrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PIIS_PARAMS Params
    );

DWORD
IISSetPrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


//
// Function definitions
//


BOOLEAN
IISInit(
    VOID
    )
{

    IISLoadMngtDll();
    g_hIISUpdateVirtualRootLock = CreateSemaphoreW(
                    NULL,
                    0,
                    1,
                    IIS_SEMAPHORE_NAME);
    if (g_hIISUpdateVirtualRootLock == NULL) {
        return(FALSE);
    }

    if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
        // set initial state to 1 if it didn't exist
        ReleaseSemaphore(g_hIISUpdateVirtualRootLock, 1, NULL);
    }

    return(TRUE);
}


VOID
IISCleanup()
{
    if (g_hIISUpdateVirtualRootLock) {
        CloseHandle(g_hIISUpdateVirtualRootLock);
    }
    IISUnloadMngtDll();
}


BOOLEAN
WINAPI
IISDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !IISInit() ) {
            return(FALSE);
        }
        break;

    case DLL_PROCESS_DETACH:
        IISCleanup();
        break;

    default:
        break;
    }

    return(TRUE);

} // IISShareDllEntryPoint



DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup a particular resource type. This means verifying the version
    requested, and returning the function table for this resource type.

Arguments:

    ResourceType - Supplies the type of resource.

    MinVersionSupported - The minimum version number supported by the cluster
                    service on this system.

    MaxVersionSupported - The maximum version number supported by the cluster
                    service on this system.

    FunctionTable - Returns the Function Table for this resource type.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD serviceType = MAX_SERVICE;
    DWORD i;

    //
    // Search for a valid service name supported by this DLL
    //
    if ( lstrcmpiW( ResourceType, IIS_RESOURCE_NAME ) != 0 ) {
        return(ERROR_UNKNOWN_REVISION);
    }

    g_IISLogEvent           = LogEvent;
    g_IISSetResourceStatus  = SetResourceStatus;

    if ( (MinVersionSupported <= CLRES_VERSION_V1_00) &&
         (MaxVersionSupported >= CLRES_VERSION_V1_00) ) {

        *FunctionTable = &IISFunctionTable;
        return(ERROR_SUCCESS);
    }

    return(ERROR_REVISION_MISMATCH);

} // Startup



DWORD
IISOpenThread(
    IN PCLUS_WORKER pWorker,
    IN LPIIS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Performs some additional initialization for the IIS service.
        1. Makes sure the service is running
        2. Make sure that any virtual roots contained in this resource are
           offline (i.e., removed from the IIS).

Arguments:
    PWorker - Worker thread structure
    ResourceEntry - A pointer to a IIS_RESOURCE block for this resource

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   retry   = MAX_OPEN_RETRY;
    //
    //HACKHACK:
    // The IIS mngt API updates the registry every time the resource
    // is brought online. This means that if the cluster terminated abnormally
    // (i.e., did not do offline), then the resource potentially could be
    // incorrectly ONLINE after the OPEN.
    //
    // Until the IIS mngt changes, filter out the "Virtual Root" managed by
    // the Cluster
    //

    //
    // Make sure the IIS is installed
    //
    status = IsIISMngtDllLoaded();
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    while (retry--) {
        //
        // Check to see if we were requested to terminate.
        // If so do so cleanly (i.e, no locks held)
        //
        if (ClusWorkerCheckTerminate(pWorker)){
            status = ERROR_OPERATION_ABORTED;
            break;
        }

        //
        // Read the Parameter specific information from the registry
        //
        // CAVEAT: Normally this is done in the online routine.
        // We do it here to make sure that the resource comes up
        // in an OFFLINE state. The problem is that any iis change
        // updates the registry. So its possible that if the cluster
        // did not terminate normall that a resource could be incorrectly
        // brought up in an ONLINE state.
        //
        //

        status = IISReadParameters(ResourceEntry);

        if (status == ERROR_SUCCESS){
            //
            // Try to offline the virtual roots.
            //
            status = OfflineVirtualRootExclusive(ResourceEntry);

            if (status == ERROR_SUCCESS) {
                break;
            }

            if ( ( status == ERROR_SERVICE_NOT_ACTIVE ) ||
                 ( status == RPC_S_SERVER_UNAVAILABLE ) ) {
                //
                // Try to start the service
                //
                ResUtilStartResourceService( ResourceEntry->Params.ServiceName,
                                             NULL );
                //
                // Cleanup for next retry
                //
                DestructVR(ResourceEntry->VirtualRoot);
                ResourceEntry->VirtualRoot = NULL;
            } else {
                break;
            }

        } else { //END (status == ERROR_SUCCESS)
            //
            // ERROR_RESOURCE_NOT_FOUND indicates that the IP Address
            // dependency could not be found. We may have to wait a bit
            // for the other resources to come online before this will succeed
            //
            // All other errors are non-recoverable and we should exit
            //
            if (status != ERROR_RESOURCE_NOT_FOUND) {
                goto error_exit;
            }
        }

        //
        // Check to see if we were requested to terminate.
        // If so do so cleanly (i.e, no locks held)
        //
        if (ClusWorkerCheckTerminate(pWorker)){
            status = ERROR_OPERATION_ABORTED;
            break;
        }

        status = ERROR_TIMEOUT;
        //
        // Give the service time to start
        //
        Sleep(SERVER_START_DELAY);
    }

error_exit:

    if (status != ERROR_SUCCESS) {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"[IISOpenthread] NON-CRITICAL Unable to initialize or offline virtual root  Error: %1!u!.\n",
            status );
    }

    //
    // The online thread will block until the openthread completes. The online
    // thread re-reads the parameters key so free up the storage here.
    //
    DestructVR(ResourceEntry->VirtualRoot);
    ResourceEntry->VirtualRoot = NULL;

    return(status);

} // END IISOpenThread


RESID
WINAPI
IISOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for IIS resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - Supplies handle to resource's cluster registry key.

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    DWORD           status;
    LPIIS_RESOURCE  ResourceEntry;
    IIS_RESOURCE    tmpResourceEntry;
    DWORD           count       = 0;
    DWORD           Index       = 0;
    DWORD           serviceType = MAX_SERVICE;
    DWORD           threadId;
    LPCWSTR         ResourceType;
    HCLUSTER        hCluster;

    ZeroMemory( &tmpResourceEntry, sizeof(tmpResourceEntry) );

    //
    // Set the resource handle for logging and init the virtual root entry
    //
    tmpResourceEntry.ResourceHandle             = ResourceHandle;
    tmpResourceEntry.VirtualRoot                = NULL;
    tmpResourceEntry.State                      = ClusterResourceOffline;

    //
    // Open the cluster.
    //
    hCluster = OpenCluster(NULL);
    if ( hCluster == NULL ) {
        status = GetLastError();
        (g_IISLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"[IISOpen] Unable to open cluster. Error: %1!u!.\n",
            status );
        goto error_exit;
    }

    tmpResourceEntry.hResource = OpenClusterResource( hCluster,
                                                      ResourceName );
    CloseCluster(hCluster);
    if ( tmpResourceEntry.hResource == NULL ) {
        status = GetLastError();
        (g_IISLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"[IISOpen] Unable to open cluster resource handle. Error: %1!u!.\n",
            status );
        goto error_exit;
    }

    //
    // Open the Parameters key for this resource.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"Parameters",
                                KEY_READ,
                                &tmpResourceEntry.ParametersKey );

    if ( status != ERROR_SUCCESS ) {
        (g_IISLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"[IISOpen] Unable to open parameters key for resource. Error: %1!u!.\n",
            status );
        goto error_exit;
    }

    //
    // Find a free slot in the resource table
    //
    for ( count = 1; count <= MAX_IIS_RESOURCES; count++ ) {
        if ( g_IISTable[count-1] == NULL ) {
            break;
        }
    }

    if ( count > MAX_IIS_RESOURCES ) {
        (g_IISLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"[IISOpen] No more IIS Resources available.\n");
        status = ERROR_RESOURCE_NOT_FOUND;
        goto error_exit;
    }

    //
    // Allocate a ResourceEntry
    //
    ResourceEntry = LocalAlloc( LPTR, sizeof(IIS_RESOURCE) );

    if ( ResourceEntry == NULL ) {
        (g_IISLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"[IISOpen] Unable to allocate IIS resource structure.\n");
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Save resource in the resource table
    //

    g_IISTable[count-1] = ResourceEntry;

    //
    // Copy the tmp resource entry
    //
    CopyMemory(ResourceEntry,&tmpResourceEntry,sizeof(IIS_RESOURCE));

    ResourceEntry->Index                = count;

    //
    // Make sure that the virtual roots contained in this resource
    // are offline. The IISOpenThread function performs this task.
    //
    status = ClusWorkerCreate( &ResourceEntry->OpenThread,
                               IISOpenThread,
                               ResourceEntry );
    if ( status != ERROR_SUCCESS ) {
        ResourceEntry->State = ClusterResourceFailed;
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[IISOpen] Unable to create open worker thread, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Log success
    //

    (g_IISLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"[IISOpen] Open request succeeded with id = %1!u!.\n",
        ResourceEntry->Index);

    return((RESID)ResourceEntry->Index);

error_exit:
    if (count > 0){
        g_IISTable[count -1] = NULL;
    }
    if (tmpResourceEntry.ParametersKey != NULL){
        ClusterRegCloseKey( tmpResourceEntry.ParametersKey );
    }
    if (tmpResourceEntry.hResource != NULL) {
        CloseClusterResource( tmpResourceEntry.hResource );
    }
    if (ResourceEntry != 0){
        DestructIISResource(ResourceEntry);
    } else {
        FreeIISResource(&tmpResourceEntry);
    }
    (g_IISLogEvent)(
        ResourceHandle,
        LOG_ERROR,
        L"[IISOpen] Error %1!u! opening iis resource %2!ws!.\n",
        status,
        ResourceName );

    SetLastError(status);

    return((RESID)(0));

} // IISOpen




DWORD
IISOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN LPIIS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a share resource online.

Arguments:

    pWorker - Supplies the worker structure

    ResourceEntry - A pointer to a IIS_RESOURCE block for this resource

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD           status;
    DWORD           retry;
    RESOURCE_STATUS resourceStatus;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState    = ClusterResourceOnlinePending;
    //resourceStatus.WaitHint         = 0;
    resourceStatus.CheckPoint       = 1;
    ResourceEntry->State            = ClusterResourceOnlinePending;

    //
    // See if the open worker thread has terminated
    //
    retry = MAX_OPEN_RETRY*2;
    while (retry--) {
        //
        // Check to see if we were requested to terminate.
        // If so do so cleanly (i.e, no locks held)
        //
        if (ClusWorkerCheckTerminate(pWorker)){
            status = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }
        //
        // See if the open thread terminated
        //
        if (ClusWorkerCheckTerminate(&ResourceEntry->OpenThread)){
            status = ERROR_SUCCESS;
            break;
        }
        //
        // Wait for a bit
        //
        status = ERROR_TIMEOUT;
        Sleep(SERVER_START_DELAY);
    } // END retry

#if 0
    if (status != ERROR_SUCCESS) {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ERROR [OnLineThread] TIMEOUT waiting for open thread to terminate \n");
    }
#endif
    //
    // Try to Read the Parameter specific information from
    // the registry. This must defer this till after open thread terminates
    // i.e., because open also reads the parameters
     status = IISReadParameters( ResourceEntry );
     if (status != ERROR_SUCCESS){
         (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ERROR [OnLineThread] Could not read resource parameters\n");
         goto error_exit;
     }

    retry = MAX_ONLINE_RETRY;

    while (retry--) {
        //
        // Check to see if we were requested to terminate.
        // If so do so cleanly (i.e, no locks held)
        //
        if (ClusWorkerCheckTerminate(pWorker)){
            status = ERROR_OPERATION_ABORTED;
            break;
        }

#if 0
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"INFO [OnLineThread] Root = %1!ws! IP = %2!ws! Dir = %3!ws! Mask = %4!u!\n",
            ResourceEntry->VirtualRoot->pszRoot,
            ResourceEntry->VirtualRoot->pszAddress,
            ResourceEntry->VirtualRoot->pszDirectory,
            ResourceEntry->VirtualRoot->dwMask);
#endif
        //
        // Try to Online the resources
        status = OnlineVirtualRootExclusive(ResourceEntry);

#if 0
        (g_IISLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_INFORMATION,
             L"INFO [OnLineThread] OnLineVirtualRoot status = %1!u!\n",
             status);
#endif

        if ( status == ERROR_SUCCESS) {
            break;
        }

        //
        // Check to see if we were requested to terminate.
        // If so do so cleanly (i.e, no locks held)
        //
        if (ClusWorkerCheckTerminate(pWorker)){
            status = ERROR_OPERATION_ABORTED;
            break;
        }

        //
        // If we failed for any reason except
        // the service is not active then fail
        //

        if ( ( status == ERROR_SERVICE_NOT_ACTIVE ) ||
             ( status == RPC_S_SERVER_UNAVAILABLE ) ) {
            //
            // Try to start the service
            //
            ResUtilStartResourceService( ResourceEntry->Params.ServiceName,
                                             NULL );
        } else {
            goto error_exit;
        }

        //
        // We restarted the service. It's possible that the service terminated
        // abnormally. If the resource is online, leave it and return success
        //
        if (VerifyIISService(ResourceEntry,FALSE,g_IISLogEvent)) {
            status = ERROR_SUCCESS;
            goto error_exit;
        }

        //
        // Check to see if we were requested to terminate.
        // If so do so cleanly (i.e, no locks held)
        //
        if (ClusWorkerCheckTerminate(pWorker)){
            status = ERROR_OPERATION_ABORTED;
            break;
        }

        status = ERROR_TIMEOUT;
        //
        // Give the service time to start
        //
        Sleep(SERVER_START_DELAY);

    } // END While retry--

error_exit:
    if ( status != ERROR_SUCCESS ) {
    //
    // Error
    //
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[IISOnlineThread] Error %1!u! cannot bring resource online.\n",
            status );
        resourceStatus.ResourceState    = ClusterResourceFailed;
        ResourceEntry->State            = ClusterResourceFailed;
    } else {
    //
    // Success, update state, log message
    //
        resourceStatus.ResourceState    = ClusterResourceOnline;
        ResourceEntry->State            = ClusterResourceOnline;
#if 0
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"[IISOnlineThread] Success bringing resource online.\n" );
#endif
    }

    //
    // Set the state of the resource
    //
    (g_IISSetResourceStatus)( ResourceEntry->ResourceHandle,
                             &resourceStatus );

    return(status);

} // IISOnlineThread


DWORD
WINAPI
IISOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for IIS resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
    ERROR_SERVICE_NOT_ACTIVE if it could not find the IIS management DLL
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    LPIIS_RESOURCE  ResourceEntry = NULL;
    DWORD           threadId;
    DWORD           status;

    //
    // Get a valid resource
    //
    ResourceEntry = GetValidResource(Resource,L"OnLine");
    if (ResourceEntry == NULL) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#if 0
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[IISOnline] Online request for IIS Resource %1!u!.\n",
        Resource );
#endif

    // Initialize the state to offline
    ResourceEntry->State = ClusterResourceOffline;

    // Terminate (or wait) for workers
    ClusWorkerTerminate( &ResourceEntry->OnlineThread );


    // Make sure the IIS is installed
    status = IsIISMngtDllLoaded();
    if (status != ERROR_SUCCESS) {
        // Set the state to failed AND log event
        ResourceEntry->State = ClusterResourceFailed;
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[IISOnline] Error loading IIS mngt dll or one of its functions error status: %1!u!\n",
            status);
        return(ERROR_SERVICE_NOT_ACTIVE);
    }

    // Create new online thread
    status = ClusWorkerCreate( &ResourceEntry->OnlineThread,
                               IISOnlineThread,
                               ResourceEntry );

    if (status != ERROR_SUCCESS){
        // Set the state to failed AND log event
        ResourceEntry->State = ClusterResourceFailed;
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[IISOnline] Unable to create cluster worker thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // IISOnline


VOID
WINAPI
IISTerminate(
    IN RESID Resource
    )

/*++

Routine Description:

    Terminate routine for IIS resource.

Arguments:

    Resource - supplies resource id to be terminated

Return Value:

    None.

--*/

{
    DWORD           status;
    LPIIS_RESOURCE  ResourceEntry;

    //
    // Get a valid resource entry, return on error
    //
    ResourceEntry = GetValidResource(Resource,L"Terminate");
    if (ResourceEntry == NULL) {
        return;
    } else {
        status = ERROR_SUCCESS;
    }

#if 0
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[IISTerminate] Terminate or offline request for Resource%1!u!.\n",
        Resource );
#endif

    ClusWorkerTerminate( &ResourceEntry->OnlineThread );
    ClusWorkerTerminate( &ResourceEntry->OpenThread );
    //
    // Try to take the resources offline, dont return if an error since
    // the resources may be offline when terminate called
    //
    if ((ResourceEntry->State == ClusterResourceOnlinePending) ||
        (ResourceEntry->State == ClusterResourceOnline)) {
        status = OfflineVirtualRootExclusive(ResourceEntry);
    }

    if ( status != ERROR_SUCCESS ) {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[IISTerminate] Error terminating Resource. NT Status %1!u!. Service. %2!ws!\n",
            status,
            ResourceEntry->Params.ServiceName);
    }
    //
    // Set status to offline
    //
    ResourceEntry->State = ClusterResourceOffline;


    //
    // Reclaim storage for parameters, close handles
    //
    DestructVR(ResourceEntry->VirtualRoot);
    ResourceEntry->VirtualRoot = NULL;

} // IISTerminate


DWORD
WINAPI
IISOffline(
    IN RESID Resource
    )

/*++

Routine Description:

    Offline routine for IIS resource.

Arguments:

    Resource - supplies the resource it to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    LPIIS_RESOURCE      ResourceEntry;

    //
    // Get a valid resource entry, return on error
    //
    ResourceEntry = GetValidResource(Resource,L"Offline");
    if (ResourceEntry == NULL) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#if 0
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[IISOffline] Offline request for Resource%1!u!.\n",
        Resource );
#endif
    IISTerminate(Resource);

    return(ERROR_SUCCESS);

} // IISOffline




BOOL
WINAPI
IISIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for IIS service resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - if service is running

    FALSE - if service is in any other state

--*/
{
    LPIIS_RESOURCE  ResourceEntry;

    //
    // Get a valid resource
    //
    ResourceEntry = GetValidResource(Resource,L"IsAlive");
    if (ResourceEntry == NULL) {
        return(FALSE);
    }
    //
    // Verify the resource
    //
    return( VerifyIISService( ResourceEntry, TRUE, g_IISLogEvent ));

} // IISIsAlive



BOOL
WINAPI
IISLooksAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    LooksAlive routine for IIS resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    LPIIS_RESOURCE      ResourceEntry;
    HANDLE              serviceHandle;
    HANDLE              scManagerHandle;
    DWORD               status;
    SERVICE_STATUS      serviceStatus;

    //
    // Get a valid resource
    //
    ResourceEntry = GetValidResource(Resource,L"LooksAlive");
    if (ResourceEntry == NULL) {
        return(FALSE);
    }

    //
    // Query the status of the server
    //

    scManagerHandle = OpenSCManager( NULL,        // local machine
                                     NULL,        // ServicesActive database
                                     SC_MANAGER_ALL_ACCESS ); // all access

    if ( scManagerHandle == NULL ) {
        status = GetLastError();
#if 0
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[IISLooksAlive] Cannot access service controller '%1!ws!' status = %2!u!\n",
        ResourceEntry->Params.ServiceName,
        status);
#endif
        return(FALSE);
    }

    serviceHandle = OpenService( scManagerHandle,
                                 ResourceEntry->Params.ServiceName,
                                 SERVICE_ALL_ACCESS );
    //
    // CLOSE Service Manager Handle
    //
    CloseServiceHandle( scManagerHandle );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
#if 0
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[IISLooksAlive] Cannot open service '%1!ws!' status = %2!u!\n",
        ResourceEntry->Params.ServiceName,
        status);
#endif
        return(FALSE);
    }

    if ( !QueryServiceStatus(serviceHandle, &serviceStatus) ) {
        status = GetLastError();

#if 0
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[IISLooksAlive] Error querying service '%1!ws!' status = %2!u!\n",
        ResourceEntry->Params.ServiceName,
        status);
#endif
        CloseServiceHandle( serviceHandle );
        return FALSE;
    }
    //
    // CLOSE Service Handle
    //
    CloseServiceHandle( serviceHandle );

    if ( serviceStatus.dwCurrentState == SERVICE_RUNNING ) {
       return TRUE;
    }


#if 1
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[IISLooksAlive] Service not running  '%1!ws!'  state = %2!u!\n",
        ResourceEntry->Params.ServiceName,
        serviceStatus.dwCurrentState);
#endif

   return FALSE;

} // IISLooksAlive





VOID
WINAPI
IISClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for IIS resource.

Arguments:

    Resource - supplies resource id to be closed

Return Value:

    None.

--*/

{
    LPIIS_RESOURCE      ResourceEntry = NULL;

    //
    // Get a valid resource
    //
    ResourceEntry = GetValidResource( Resource, L"Close");
    if (ResourceEntry == NULL) {
        return; // this should not happen
    }

#if 0
    (g_IISLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[IISClose] Close request for Service '%1!ws!' \n",
        ResourceEntry->Params.ServiceName);
#endif
    //
    // Clear the table entry
    //
    g_IISTable[ResourceEntry->Index -1] = NULL;

    DestructIISResource(ResourceEntry);


} // IISClose

DWORD
OnlineVirtualRootExclusive(
    IN LPIIS_RESOURCE   ResourceEntry
    )
/*++

Routine Description:

    This routine performs an atomic read modify write operation to
    ONline a virtual root

Arguments:

    ResourceEntry - Supplies the resource to offline

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    DWORD   status;

    WaitForSingleObject(g_hIISUpdateVirtualRootLock, INFINITE);
    status = OnLineVirtualRoot(ResourceEntry, g_IISLogEvent);
    ReleaseSemaphore( g_hIISUpdateVirtualRootLock, 1, 0);
    return status;
}

DWORD
OfflineVirtualRootExclusive(
    IN LPIIS_RESOURCE   ResourceEntry
    )
/*++

Routine Description:

    This routine performs an atomic read modify write operation to
    offline a virtual root

Arguments:

    ResourceEntry - Supplies the resource to offline

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    DWORD   status;

    WaitForSingleObject(g_hIISUpdateVirtualRootLock,INFINITE);
    status = OffLineVirtualRoot(ResourceEntry, g_IISLogEvent);
    ReleaseSemaphore( g_hIISUpdateVirtualRootLock, 1, 0);
    return status;
}


LPIIS_RESOURCE
GetValidResource(
    IN RESID    Resource,
    IN LPWSTR   RoutineName
    )

/*++

Routine Description:
    Validate the resource ID, log any error, return valid resource

Arguments:
    Resource - the resource to validate

    RoutineName - the routine that is requesting the validation

Return Value:
    Success - ResourceEntry
    NULL - Error


--*/
{
    DWORD           Index;
    LPIIS_RESOURCE  ResourceEntry;

    //
    // Validate the resource id is in the correct range
    //
    Index = (DWORD)Resource -1;
    if ( Index > MAX_IIS_RESOURCES) {
        (g_IISLogEvent)(
            NULL,
            LOG_ERROR,
            L"[%1!ws!] Invalid resource id (out of range) Resource Id = %2!u!\n",
            RoutineName,
            Index);
        return(NULL);
    }

    ResourceEntry = g_IISTable[Index];

    //
    // Check for a valid
    //
    if ( ResourceEntry == NULL ) {
        (g_IISLogEvent)(
            NULL,
            LOG_ERROR,
            L"[%1!ws!] Resource Entry is NULL for Resource Id = %2!u!\n",
            RoutineName,
            Index);
        return(NULL);
    }


    //
    // Sanity check the resource id
    //
    if ( ResourceEntry->Index != (DWORD)Resource ) {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[%1!ws!] IIS Resource index sanity checked failed! Index = %2!u!.\n",
            RoutineName,
            Resource );
        return(NULL);
    }


    return(ResourceEntry);
}  // END GetValidResource



LPWSTR
GetResourceParameter(
        IN HRESOURCE   hResource,
        IN LPCWSTR     ValueName
        )

/*++

Routine Description:

    Opens the parameter key for the resource. Then Queries a REG_SZ parameter
    out of the registry and allocates the necessary storage for it.

Arguments:

    hResource - the resource to query

    ValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter if successful.

    NULL if unsuccessful.

--*/
{
    HKEY        hKey            = NULL;
    HKEY        hParametersKey  = NULL;
    DWORD       status;
    LPWSTR      paramValue       = NULL;

    //
    // Get Resource key
    //
    hKey = GetClusterResourceKey(hResource,KEY_READ);
    if (hKey == NULL) {
        return(NULL);
    }

    //
    // Get parameters key
    //
    status = ClusterRegOpenKey(hKey,
                            L"Parameters",
                            KEY_READ,
                            &hParametersKey );
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    paramValue = ResUtilGetSzValue( hParametersKey,
                                    ValueName );


error_exit:
    if (hParametersKey != NULL) {
        ClusterRegCloseKey(hParametersKey);
    }
    if (hKey != NULL) {
        ClusterRegCloseKey(hKey);
    }
    return(paramValue);

} // GetResourceParameter



DWORD
IISReadParameters(
    IN OUT LPIIS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Reads all the parameters for a resource.

Arguments:

    ResourceEntry - Entry in the resource table.

Return Value:

    ERROR_SUCCESS - Success

  RECOVERABLE ERROR
    ERROR_RESOURCE_NOT_FOUND - The IP Address dependency was not found try again later

  FATAL ERRORS
    ERROR_INVALID_PARAMETER - One of the required parameters was incorrect or NULL
    ERROR_NOT_ENOUGH_MEMORY - Could not satisfy the memory request
    ERROR_INVALID_SERVICENAME - Service name is invalid for this resource dll
    ERROR_DUP_NAME           - Duplicate exclusive parameter name found
--*/

{
    DWORD                           status;
    LPCTSTR                         password        = NULL;
    LPINET_INFO_VIRTUAL_ROOT_ENTRY  tmpVr;
    DWORD                           accessMask;
    HRESOURCE                       hResource       = NULL;
    INT                             iServiceType;
    DWORD                           length;
    LPWSTR                          nameOfPropInError;

    //
    // Each offline (or at end of OpenThread) frees the VirtualRoot
    // Make sure the entry is NULL
    //
    if ( ResourceEntry->VirtualRoot != NULL ) {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[IISReadParameters] NON-Empty virtual root entry.\n" );
    }

    //
    // Allocate memory for the virtual root
    //
    tmpVr = LocalAlloc( LPTR, sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY) );
    if ( tmpVr == NULL ) {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[IISReadParameters] Cannot allocate storage for virtual root for resource\n" );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Read the parameters for the resource.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   IISResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );
    if ( status != ERROR_SUCCESS ) {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto error_exit;
    }


    //
    // Make sure we got passed a valid service name
    //

    for ( iServiceType = 0 ; iServiceType < MAX_SERVICE ; iServiceType++ ) {
        if ( lstrcmpiW( ResourceEntry->Params.ServiceName, ActualServiceName[iServiceType] ) == 0 ) {
            break;
        }
    }

    if ( iServiceType >= MAX_SERVICE ) {
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[IISReadParameters] Service name %1!ws! not supported or found\n",
            ResourceEntry->Params.ServiceName );
        status = ERROR_INVALID_SERVICENAME;
        goto error_exit;
    }

    ResourceEntry->ServiceType = iServiceType;

    //
    // Copy the parameters to where they are used.
    //
    tmpVr->pszRoot = LocalAlloc( LMEM_FIXED, (lstrlenW( ResourceEntry->Params.Alias ) + 1) * sizeof(WCHAR) );
    if ( tmpVr->pszRoot == NULL ) {
        status = GetLastError();
        goto error_exit;
    }
    lstrcpyW( tmpVr->pszRoot, ResourceEntry->Params.Alias );

    tmpVr->pszDirectory = LocalAlloc( LMEM_FIXED, (lstrlenW( ResourceEntry->Params.Directory ) + 1) * sizeof(WCHAR) );
    if ( tmpVr->pszDirectory == NULL ) {
        status = GetLastError();
        goto error_exit;
    }
    lstrcpyW( tmpVr->pszDirectory, ResourceEntry->Params.Directory );


    //
    // Get the Access Mask
    //
    if ( ResourceEntry->ServiceType != GOPHER_SERVICE ) {
        status = ResUtilGetDwordValue( ResourceEntry->ParametersKey,
                                       PARAM_NAME__ACCESSMASK,
                                       &accessMask,
                                       0 );

        if (status != ERROR_SUCCESS ) {
            (g_IISLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"[IISReadParameters] Unable to read virtual root Access Mask\n" );
            status = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }
        tmpVr->dwMask = accessMask;

    } // END != GOPHER_SERVICE

    if ( ResourceEntry->ServiceType == WWW_SERVICE ) {
        //
        // Get the IP Address
        //

        hResource = ResUtilGetResourceDependency( ResourceEntry->hResource,
                                                  IP_ADDRESS_RESOURCE_NAME );

        if ( hResource == NULL ) {
            status = GetLastError();
            (g_IISLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"[IISReadParameters] Unable to find IP Address dependency status =%1!u!\n",
                    status
                    );
            //
            // A status of ERROR_NO_DATA indicates that
            // there were no dependencies for this resource
            //
            if (status == ERROR_NO_DATA) {
                status = ERROR_INVALID_PARAMETER;
            } else {
                status = ERROR_RESOURCE_NOT_FOUND;
            }

            goto error_exit;
        }


        tmpVr->pszAddress = GetResourceParameter( hResource, L"Address" );
        if ( tmpVr->pszAddress == NULL ) {
            (g_IISLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"[IISReadParameters] Unable to get TPC/IP Address from Cluster Reg\n" );
            status = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }

    } else {  // ELSE NOT WWW_SERVICE

    //
    // Allocate memory for NULL ip address field
    //
        tmpVr->pszAddress = LocalAlloc( LPTR, sizeof(WCHAR)*10 );
        if (tmpVr->pszAddress == NULL) {
            (g_IISLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"[IISReadParameters] Cannot allocate storage for NULL (GOPHER, FTP) IP Address" );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        } // end pszAddress == NULL

        //
        // Copy a NULL character
        //
        lstrcpyW( tmpVr->pszAddress, L"\0" );

    } // END IF WWW_SERVICE

    //HACK HACK
    //make sure the password field is null terminated
    //
    lstrcpyW( tmpVr->AccountPassword, L"\0" );

    //
    // Get the [optional] AccountName
    //
/*BUGBUG
//This version does not support protecting UNC physical directories
//with an account name and password...
/*BUGBUG
    tmpVr->pszAccountName = ResUtilGetSzValue( ResourceEntry->ParametersKey,
                                               PARAM_NAME__ACCOUNTNAME );
*/

    if ( tmpVr->pszAccountName == NULL ) {
#if 0
        (g_IISLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"[IISReadParameters] NO Account name entered set to NULL\n" );
#endif
        tmpVr->pszAccountName = LocalAlloc( LPTR, sizeof(WCHAR)*2 );
        //
        // Make sure we can still allocate memory
        //
        if ( tmpVr->pszAccountName == NULL ) {
            (g_IISLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"[IISReadParameters] Cannot allocate memory for Account Name\n" );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        } //END pszAccountName == NULL

        //
        // Copy a NULL character
        //
        lstrcpyW( tmpVr->pszAccountName, L"\0" );

    } else {
    //
    // Get the [optional] Account password
    //
    //
    /* BUGBUG Add password after encryption in registry available
        password = ResUtilGetSzValue( ResourceEntry->ParametersKey,
                                      PARAM_NAME__PASSWORD );
    */

        if ( password == NULL ) {
#if 0
            (g_IISLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"[IISReadParameters] No password specified\n" );
#endif
        } else {
            lstrcpyW( tmpVr->AccountPassword, password );
        } // END password == NULL

    } // END else pszAccountName == NULL

    status = ERROR_SUCCESS;
    ResourceEntry->VirtualRoot = tmpVr;

error_exit:

    if (password != NULL) {
        LocalFree((PVOID)password);
    }

    if (status != ERROR_SUCCESS) {
        DestructVR(tmpVr);
    }

    if (hResource != NULL) {
        CloseClusterResource(hResource);
    }

    return(status);

} // IISReadParameters



DWORD
IISGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for resources of type IIS Virtual Root.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    typedef struct DEP_DATA {
        CLUSPROP_SZ_DECLARE( ipaddrEntry, sizeof(IP_ADDRESS_RESOURCE_NAME) / sizeof(WCHAR) );
        CLUSPROP_SYNTAX endmark;
    } DEP_DATA, *PDEP_DATA;
    PDEP_DATA   pdepdata = (PDEP_DATA)OutBuffer;
    DWORD       status;

    *BytesReturned = sizeof(DEP_DATA);
    if ( OutBufferSize < sizeof(DEP_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( pdepdata, sizeof(DEP_DATA) );
        pdepdata->ipaddrEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->ipaddrEntry.cbLength = sizeof(IP_ADDRESS_RESOURCE_NAME);
        lstrcpyW( pdepdata->ipaddrEntry.sz, IP_ADDRESS_RESOURCE_NAME );
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return status;

} // IISGetRequiredDependencies



DWORD
IISResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for IIS Virtual Root resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    LPIIS_RESOURCE  resourceEntry = NULL;
    DWORD           required;

    //
    // Get a valid resource
    //
    resourceEntry = GetValidResource( ResourceId, L"Close");
    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND); // this should not happen
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = IISGetRequiredDependencies( OutBuffer,
                                                 OutBufferSize,
                                                 BytesReturned
                                                 );
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( IISResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = IISGetPrivateResProperties( resourceEntry,
                                                 OutBuffer,
                                                 OutBufferSize,
                                                 BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = IISValidatePrivateResProperties( resourceEntry,
                                                      InBuffer,
                                                      InBufferSize,
                                                      NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = IISSetPrivateResProperties( resourceEntry,
                                                 InBuffer,
                                                 InBufferSize );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // IISResourceControl



DWORD
IISResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for IIS Virtual Root resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( IISResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = IISGetRequiredDependencies( OutBuffer,
                                                 OutBufferSize,
                                                 BytesReturned
                                                 );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // IISResourceTypeControl



DWORD
IISGetPrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type IIS.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      IISResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // IISGetPrivateResProperties


DWORD
IISValidateUniqueProperties(
    IN HRESOURCE       hSelf,
    IN HRESOURCE       hResource,
                PIIS_PARAMS     pParams
                )
/*++

Routine Description:
    Callback function to validate that a resources properties are unique.

    For the IIS resource the ALIAS property must be unique for a virtual
    server (i.e., same IP Address dependency)

Arguments:

    hSelf     - A handle to the original resource.

    hResource - A handle to a resource of the same Type. Check against this to make sure
                the new properties do not conflict.

    pParams   - Contains the properties for this resource

Return Value:

    ERROR_SUCCESS - The function completed successfully, the name is unique

    ERROR_DUP_NAME - The name is not unique (i.e., already claimed by another resource)

    Win32 error code - The function failed.

--*/
{
    DWORD       dwError;
    LPWSTR      lpszAlias = NULL;
    LPWSTR      lpszService = NULL;
    BYTE        szDependsName[MAX_DEFAULT_WSTRING_SIZE];
    HKEY        hKey = NULL;
    HKEY        hParamKey = NULL;
    DWORD       dwSize;
    DWORD       dwRetSize;
    HRESOURCE   hSelfDepends = NULL;
    HRESOURCE   hResDepends = NULL;

    hKey = GetClusterResourceKey( hResource, KEY_READ );


    if( !hKey ){
        return(GetLastError());
    }

    dwSize = MAX_DEFAULT_WSTRING_SIZE;

    dwError = ClusterRegOpenKey( hKey, L"Parameters", KEY_READ, &hParamKey);

    if (dwError != ERROR_SUCCESS) {
        goto error_exit;
    }

    if ( !pParams->Alias ||
         !pParams->ServiceName ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    lpszAlias = ResUtilGetSzValue(hParamKey, PARAM_NAME__ALIAS);

    if (!lpszAlias) {
        dwError =  GetLastError();
        goto error_exit;
    }


    lpszService = ResUtilGetSzValue(hParamKey, PARAM_NAME__SERVICENAME);

    if (!lpszService) {
        dwError =  GetLastError();
        goto error_exit;
    }

    // Assume success
    dwError = ERROR_SUCCESS;

    //
    // An Alias property must be unique in a group (i.e., ip address),
    // and service (i.e., WWW, FTP, GOPHER)
    //
    if ( !(_wcsicmp( lpszAlias, pParams->Alias) ) &&
         !(_wcsicmp( lpszService, pParams->ServiceName ) ) ){
        //
        // Get the dependent IP_ADDRESS resource for the callee
        //
        hSelfDepends = ResUtilGetResourceDependency(hSelf,
                                                    IP_ADDRESS_RESOURCE_NAME);

        if (!hSelfDepends) {
            dwError = GetLastError();
            goto error_exit;
        }

        //
        // Get the dependent IP_ADDRESS resource for hResource
        //
        dwError = ClusterResourceControl(
                hResource,            //Handle to the resource
                NULL,                 //Don't care about node
                CLUSCTL_RESOURCE_GET_NAME, //Get the name
                0,                    // &InBuffer
                0,                    // nInBufferSize,
                &szDependsName,       // &OutBuffer
                MAX_DEFAULT_WSTRING_SIZE,     // OutBufferSize,
                &dwRetSize );         // returned size

        if (dwError != ERROR_SUCCESS) {
            goto error_exit;
        }

        hResDepends  = ResUtilGetResourceNameDependency((LPWSTR)&szDependsName,
                                                        IP_ADDRESS_RESOURCE_NAME);

        if (!hResDepends) {
            dwError = GetLastError();
            CloseClusterResource( hSelfDepends);
            goto error_exit;
        }

        //
        // See if the name of the IP_ADDRESS dependencies match. If so
        // then we have a duplicate IIS VR
        //
        if ( ResUtilResourcesEqual( hSelfDepends, hResDepends) ) {
           dwError = ERROR_DUP_NAME;
        }

       CloseClusterResource( hResDepends );

       CloseClusterResource( hSelfDepends );
    }

error_exit:

   if (hKey) ClusterRegCloseKey(hKey);

   if (hParamKey) ClusterRegCloseKey(hParamKey);

   if (lpszService) LocalFree(lpszService);

   if (lpszAlias) LocalFree(lpszAlias);

    return( dwError );

}//IISValidateUniqueProperties


DWORD
IISValidatePrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PIIS_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type IIS Virtual Root.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_INVALID_DATA - Parameter data was invalid.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    IIS_PARAMS      params;
    PIIS_PARAMS     pParams;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &params;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(params) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &ResourceEntry->Params,
                                       IISResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( IISResourcePrivateProperties,
                                         NULL,
                                         TRUE,      // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // BUGBUG: Validate the parameter values.
        //

        if ( (pParams->Alias == NULL) ||
             (pParams->Alias[0] != L'/') ) {
            status = ERROR_INVALID_DATA;
        }

        //
        // Check for Unique Alias name within virtual server
        //
        status = ResUtilEnumResources(ResourceEntry->hResource,
                                 IIS_RESOURCE_NAME,
                                 IISValidateUniqueProperties,
                                 pParams);
        if (status != ERROR_SUCCESS) {
            (g_IISLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"[IISValidatePrivateResourceProperty]  status = %1!d!\n",
                  status);
            status = ERROR_INVALID_DATA;
        }
    }

    //
    // Cleanup our parameter block.
    //
    if ( pParams == &params ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   IISResourcePrivateProperties );
    }

    return(status);

} // IISValidatePrivateResProperties



DWORD
IISSetPrivateResProperties(
    IN OUT LPIIS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type IIS Virtual Root.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    IIS_PARAMS      params;

    ZeroMemory( &params, sizeof(IIS_PARAMS) );

    //
    // Parse and validate the properties.
    //
    status = IISValidatePrivateResProperties( ResourceEntry,
                                              InBuffer,
                                              InBufferSize,
                                              &params );
    if ( status != ERROR_SUCCESS ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   IISResourcePrivateProperties );
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               IISResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               IISResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( (ResourceEntry->State == ClusterResourceOnline) ||
             (ResourceEntry->State == ClusterResourceOnlinePending) ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // IISSetPrivateResProperties






//***********************************************************
//
// Define Function Table
//
//***********************************************************

// Define entry points


CLRES_V1_FUNCTION_TABLE( IISFunctionTable,
                         CLRES_VERSION_V1_00,
                         IIS,
                         NULL,
                         NULL,
                         IISResourceControl,
                         IISResourceTypeControl );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\iis\dummyiis.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dummyiis.c

Abstract:

    This file was adapted from \nt\private\cluster\resdll\dummy\dummy.c. It
    implements an NT Cluster resource DLL for the IIS Virtual Root resource type.
    This resource does nothing except read the value "Parameters\Failed" from the
    resource definition in the registry on each poll to determine whether or not the resource
    has failed.

    The DLL is to be installed during UPGRADE from NT 4.0. It will become obsolete
    with the availability of a IIS Virtual Root resource DLL that works with IIS 5.

Author:

    John Vert (jvert) 5-Dec-1995

Revision History:

    C. Brent Thomas (a-brentt) 29-May-1998

    Adapted for IIS Virtual Root reaource type.

--*/

#include <windows.h>
#include <stdio.h>
#include "clusapi.h"
#include "resapi.h"

//
// Local Types.
//

typedef enum TimerType {
    TimerNotUsed,
    TimerErrorPending,
    TimerOnlinePending,
    TimerOfflinePending
};

typedef struct {
    DWORD             Flags;
    CLUSTER_RESOURCE_STATE    State;
    HANDLE            SignalEvent;
    HANDLE            TimerThreadWakeup;
    HANDLE            ThreadHandle;
    HKEY              ParametersKey;
    RESID             ResourceId;
    DWORD             TimerType;
    RESOURCE_HANDLE   ResourceHandle;
    DWORD PendTime;
} DUMMY_RESOURCE, *PDUMMY_RESOURCE;
// 10 dwords ( 0x28 offset )

//
// Constants
//
#define DUMMY_RESOURCE_BLOCK_SIZE    4

#define DUMMY_FLAG_VALID    0x00000001
#define DUMMY_FLAG_ASYNC    0x00000002      // Asynchronous failure mode
#define DUMMY_FLAG_PENDING  0x00000004      // Pending mode on shutdown

#define DUMMY_PARAMETER_FAILED    L"Failed"
#define DUMMY_PARAMETER_ASYNC     L"Asynchronous"
#define DUMMY_PARAMETER_PENDING   L"Pending"
#define DUMMY_PARAMETER_OPENSFAIL L"OpensFail"
#define DUMMY_PARAMETER_PENDTIME  L"PendTime"

#define DUMMY_PRINT printf

//
// Macros
//
#define AsyncMode(Resource) (Resource->Flags & DUMMY_FLAG_ASYNC)
#define PendingMode(Resource) (Resource->Flags & DUMMY_FLAG_PENDING)

#define EnterAsyncMode(Resource) (Resource->Flags |= DUMMY_FLAG_ASYNC)

#define DummyAcquireResourceLock()  \
            {  \
                DWORD status;  \
                status = WaitForSingleObject(DummyResourceSemaphore, INFINITE);  \
            }

#define DummyReleaseResourceLock()  \
            { \
                ReleaseSemaphore(DummyResourceSemaphore, 1, NULL);  \
            }


//
// Local Variables
//
PDUMMY_RESOURCE   DummyResourceList = NULL;
DWORD             DummyResourceListSize = DUMMY_RESOURCE_BLOCK_SIZE;
HANDLE            DummyResourceSemaphore = NULL;
PLOG_EVENT_ROUTINE LogEvent;
PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus;

extern CLRES_FUNCTION_TABLE DumbFunctionTable;


//
// Local utility functions
//


DWORD
DummyInit(
    VOID
    )

/*++

Routine Description:

    Allocates and initializes global system resources for the Dummy resource.

Arguments:

    None.

Return Value:

    A Win32 error code.

--*/

{
    DWORD status;


    DummyResourceSemaphore = CreateSemaphore(NULL, 0, 1 , NULL);

    if (DummyResourceSemaphore == NULL) {
        status = GetLastError();
        DUMMY_PRINT(
            "DUMMY: unable to create resource mutex, error %u\n",
            status
            );
        return(status);
    }

    if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
        ReleaseSemaphore( DummyResourceSemaphore, 1, NULL );
    }

    DummyResourceList = LocalAlloc(
                          LMEM_FIXED,
                          DummyResourceListSize * sizeof(DUMMY_RESOURCE)
                          );

    if (DummyResourceList == NULL) {
        DUMMY_PRINT("DUMMY: unable to allocate resource list\n");
        status = ERROR_NOT_ENOUGH_MEMORY;
        CloseHandle(DummyResourceSemaphore);
        DummyResourceSemaphore = NULL;
        return(status);
    }

    ZeroMemory(
        DummyResourceList,
        DummyResourceListSize * sizeof(DUMMY_RESOURCE)
        );

    return(NO_ERROR);

} // DummyInit



VOID
DummyCleanup(
    VOID
    )

/*++

Routine Description:

    Deallocates any system resources in use by the Dummy resource.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (DummyResourceList != NULL) {
        LocalFree(DummyResourceList);
        DummyResourceList = NULL;
    }

    if (DummyResourceSemaphore != NULL) {
        CloseHandle(DummyResourceSemaphore);
        DummyResourceSemaphore = NULL;
    }

    return;

} // DummyCleanup



PDUMMY_RESOURCE
DummyAllocateResource(
    OUT RESID *ResourceId
    )

/*++

Routine Description:

    Allocates a resource structure from the free pool.

Arguments:

    ResourceId - Filled in with the RESID for the allocated resource
                 on return.

Return Value:

    A pointer to the allocated resource, or NULL on error.

--*/

{
    PDUMMY_RESOURCE  resource = NULL;
    PDUMMY_RESOURCE  newList;
    DWORD            i;
    DWORD            newSize = DummyResourceListSize +
                               DUMMY_RESOURCE_BLOCK_SIZE;

    for (i=1; i < DummyResourceListSize; i++) {
        if (!(DummyResourceList[i].Flags & DUMMY_FLAG_VALID)) {
            resource = DummyResourceList + i;
            *ResourceId = (RESID)ULongToPtr( i );
            break;
        }
    }

    if (resource == NULL) {
        newList = LocalReAlloc(
                      DummyResourceList,
                      newSize * sizeof(DUMMY_RESOURCE),
                      LMEM_MOVEABLE
                      );

        if (newList == NULL) {
            return(NULL);
        }

        DummyResourceList = newList;
        resource = DummyResourceList + DummyResourceListSize;
        *ResourceId = (RESID) ULongToPtr( DummyResourceListSize );
        DummyResourceListSize = newSize;
        ZeroMemory(resource, DUMMY_RESOURCE_BLOCK_SIZE * sizeof(DUMMY_RESOURCE));
    }

    ZeroMemory(resource, sizeof(DUMMY_RESOURCE));

    resource->Flags = DUMMY_FLAG_VALID;

    return(resource);

} // DummyAllocateResource



VOID
DummyFreeResource(
    IN PDUMMY_RESOURCE Resource
    )

/*++

Routine Description:

    Returns a resource structure to the free pool.

Arguments:

    Resource - A pointer to the resource structure to free.

Return Value:

    None.

--*/

{
    Resource->Flags = 0;

    return;

} // DummyFreeResource



PDUMMY_RESOURCE
DummyFindResource(
    IN RESID  ResourceId
    )

/*++

Routine Description:

    Locates the Dummy resource structure identified by a RESID.

Arguments:

    ResourceId  - The RESID of the resource to locate.

Return Value:

    A pointer to the resource strucuture, or NULL on error.

--*/

{
    DWORD          index = PtrToUlong(ResourceId);
    PDUMMY_RESOURCE  resource = NULL;


    if (index < DummyResourceListSize) {

        if (DummyResourceList[index].Flags & DUMMY_FLAG_VALID) {
            resource = DummyResourceList + index;
        }
    }

    return(resource);

} // DummyFindResource



DWORD
DummyTimerThread(
    IN LPVOID Context
    )

/*++

Routine Description:

    Starts a timer thread to wait and signal failures

Arguments:

    Context - A pointer to the DummyResource block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    PDUMMY_RESOURCE   resource = (PDUMMY_RESOURCE)Context;
    RESOURCE_STATUS   resourceStatus;
    SYSTEMTIME        time;
    DWORD             delay;
    DWORD             status;

    (LogEvent)(
            NULL,
            LOG_INFORMATION,
            L"TimerThread Entry\n");

    //
    // If we are not running in async failure mode, or
    // pending mode then exit now.
    //

    if ( !AsyncMode(resource) && !PendingMode(resource) ) {
        return(ERROR_SUCCESS);
    }

more_pending:

    ResUtilInitializeResourceStatus( &resourceStatus );

    //
    // Otherwise, get system time for random delay.
    //
    if (resource->PendTime == 0) {
        GetSystemTime(&time);

        delay = (time.wMilliseconds + time.wSecond) * 6;
    } else {
        delay = resource->PendTime * 1000;
    }


    // Use longer delays for errors
    if ( resource->TimerType == TimerErrorPending ) {
        delay = delay*10;
    }

    //
    // This routine is either handling an Offline Pending or an error timeout.
    //

    switch ( resource->TimerType ) {

    case TimerOnlinePending:

        (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Will complete online in approximately %1!u! seconds\n",
            (delay+500)/1000);

        resourceStatus.ResourceState = ClusterResourceOnline;
        resourceStatus.WaitHint = 0;
        resourceStatus.CheckPoint = 1;

        status = WaitForSingleObject( resource->TimerThreadWakeup, delay );

        //
        // Either the terminate routine was called, or we timed out.
        // If we timed out, then indicate that we've completed.
        //

        if ( status == WAIT_TIMEOUT ) {
            GetSystemTime(&time);
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Online resource state transition complete at %1!02d!:%2!02d!:%3!02d!.%4!03d!\n",
                time.wHour,
                time.wMinute,
                time.wSecond,
                time.wMilliseconds);

            resource->State = ClusterResourceOnline;
            (SetResourceStatus)(resource->ResourceHandle,
                                          &resourceStatus);
            if ( AsyncMode( resource ) ) {
                resource->TimerType = TimerErrorPending;
                goto more_pending;
            }
        } else {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Online pending terminated\n");
            if ( resource->State == ClusterResourceOffline ) {
                resource->TimerType = TimerOfflinePending;
                goto more_pending;
            }
        }
        break;

    case TimerOfflinePending:

        (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Will complete offline in approximately %1!u! seconds\n",
            (delay+500)/1000);

        resourceStatus.ResourceState = ClusterResourceOffline;
        resourceStatus.WaitHint = 0;
        resourceStatus.CheckPoint = 1;

        status = WaitForSingleObject( resource->TimerThreadWakeup, delay );

        //
        // Either the terminate routine was called, or we timed out.
        // If we timed out, then indicate that we've completed.
        //

        if ( status == WAIT_TIMEOUT ) {
            GetSystemTime(&time);
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Offline resource state transition complete at %1!02d!:%2!02d!:%3!02d!.%4!03d!\n",
                time.wHour,
                time.wMinute,
                time.wSecond,
                time.wMilliseconds);

            resource->State = ClusterResourceOffline;
            (SetResourceStatus)(resource->ResourceHandle,
                                          &resourceStatus);
        } else {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Offline pending terminated\n");
        }
        break;

    case TimerErrorPending:

        (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Will fail in approximately %1!u! seconds\n",
            (delay+500)/1000);

        if ( !ResetEvent( resource->SignalEvent ) ) {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_ERROR,
                L"Failed to reset the signal event\n");
            resource->ThreadHandle = NULL;
            return(ERROR_GEN_FAILURE);
        }

        status = WaitForSingleObject( resource->TimerThreadWakeup, delay );

        //
        // Either the terminate routine was called, or we timed out.
        // If we timed out, then signal the waiting event.
        //

        if ( status == WAIT_TIMEOUT ) {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Failed randomly\n");
            resource->TimerType = TimerNotUsed;
            SetEvent( resource->SignalEvent );
        } else {
            if ( resource->State == ClusterResourceOfflinePending ) {
                resource->TimerType = TimerOfflinePending;
                goto more_pending;
            }
        }
        break;

    default:
        (LogEvent)(
            resource->ResourceHandle,
            LOG_ERROR,
            L"DummyTimer internal error, timer %1!u!\n",
            resource->TimerType);
        break;

    }

    (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"TimerThread Exit\n");


    resource->TimerType = TimerNotUsed;
    resource->ThreadHandle = NULL;
    return(ERROR_SUCCESS);

} // DummyTimerThread



//
// Public Functions
//

BOOL
WINAPI
DummyDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD     Reason,
    IN LPVOID    Reserved
    )

/*++

Routine Description:

    Initialization & cleanup routine for Dummy resource DLL.

Arguments:

    DllHandle - Handle to the DLL.

    Reason    - The reason this routine is being invoked.

Return Value:

    On PROCESS_ATTACH: TRUE if the DLL initialized successfully
                       FALSE if it did not.

    The return value from all other calls is ignored.

--*/

{
    DWORD status;


    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        status = DummyInit();

        if (status != NO_ERROR) {
            SetLastError(status);
            return(FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:
        DummyCleanup();
        break;

    default:
        break;
    }

    return(TRUE);

} // DummyDllEntryPoint



//
// Define the resource Name
//
#define IIS_RESOURCE_NAME           L"IIS Virtual Root"

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE pSetResourceStatus,
    IN PLOG_EVENT_ROUTINE pLogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup a particular resource type. This means verifying the version
    requested, and returning the function table for this resource type.

Arguments:

    ResourceType - Supplies the type of resource.

    MinVersionSupported - The minimum version number supported by the cluster
                    service on this system.

    MaxVersionSupported - The maximum version number supported by the cluster
                    service on this system.

    FunctionTable - Returns the Function Table for this resource type.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
   if ( lstrcmpiW( ResourceType, IIS_RESOURCE_NAME ) != 0 )
   {
      return (ERROR_UNKNOWN_REVISION);
   }

   LogEvent = pLogEvent;
   SetResourceStatus = pSetResourceStatus;

   if ( (MinVersionSupported <= CLRES_VERSION_V1_00) &&
        (MaxVersionSupported >= CLRES_VERSION_V1_00) )
   {
      *FunctionTable = &DumbFunctionTable;
      return (ERROR_SUCCESS);
   }

   return (ERROR_REVISION_MISMATCH);

} // Startup



RESID
WINAPI
DumbOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open (initialize) routine for Dummy resource

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

    SetResourceStatus - a routine to call to update status for the resource.

    LogEvent - a routine to call to log an event for this resource.

Return Value:

    RESID of created resource
    NULL on failure

--*/

{
    DWORD             status;
    HKEY              parametersKey = NULL;
    PDUMMY_RESOURCE   resource = NULL;
    RESID             resourceId = 0;
    DWORD             asyncMode = FALSE;
    DWORD             valueSize;
    DWORD             valueType;
    DWORD             pendingMode = FALSE;
    DWORD             opensFail = FALSE;
    DWORD             pendingTime = 0;

    status = ClusterRegOpenKey(ResourceKey,
                               L"Parameters",
                               KEY_READ,
                               &parametersKey);

    if (status != NO_ERROR) {
        (LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key, status %1!u!\n",
            status);
        return(0);
    }

    //
    // Find out if we should just fail the open request.
    //
    valueSize = sizeof(opensFail);
    status = ClusterRegQueryValue(parametersKey,
                                  DUMMY_PARAMETER_OPENSFAIL,
                                  &valueType,
                                  (PBYTE)&opensFail,
                                  &valueSize);
    if ( status != NO_ERROR ) {
        opensFail = FALSE;
    }

    if ( opensFail ) {
        ClusterRegCloseKey(parametersKey);
        return(NULL);
    }

    //
    // Find out whether we should run in async failure mode.
    //

    valueSize = sizeof(asyncMode);
    status = ClusterRegQueryValue(parametersKey,
                                  DUMMY_PARAMETER_ASYNC,
                                  &valueType,
                                  (PBYTE)&asyncMode,
                                  &valueSize);

    if (status != NO_ERROR) {
        asyncMode = FALSE;
    }

    //
    // Find out whether we should return Pending on shutdown.
    //

    valueSize = sizeof(pendingMode);
    status = ClusterRegQueryValue(parametersKey,
                                  DUMMY_PARAMETER_PENDING,
                                  &valueType,
                                  (PBYTE)&pendingMode,
                                  &valueSize);

    if (status != NO_ERROR) {
        pendingMode = FALSE;
    } else {
        //
        // See if there is a defined time period
        //
        valueSize = sizeof(pendingTime);
        status = ClusterRegQueryValue(parametersKey,
                                      DUMMY_PARAMETER_PENDTIME,
                                      &valueType,
                                      (PBYTE)&pendingTime,
                                      &valueSize);
    }

    //
    // Now go allocate a resource structure.
    //

    DummyAcquireResourceLock();

    resource = DummyAllocateResource(&resourceId);

    if (resource == NULL) {
        (LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource structure\n");
        DummyReleaseResourceLock();
        ClusterRegCloseKey(parametersKey);
        return(0);
    }

    resource->State = ClusterResourceOffline;
    resource->ParametersKey = parametersKey;
    resource->ResourceId = resourceId;

    //
    // Copy stuff for returning pending status.
    //

    resource->ResourceHandle = ResourceHandle;

    DummyReleaseResourceLock();

    //
    // Create a TimerThreadWakeup event if needed.
    //

    if ( pendingMode || asyncMode ) {
        resource->TimerThreadWakeup = CreateEvent(NULL, FALSE, FALSE, NULL);

        if ( resource->TimerThreadWakeup == NULL ) {
            DummyFreeResource( resource );
            (LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to create timer thread wakeup event\n");
            ClusterRegCloseKey(parametersKey);
            return(0);
        }
    }

    if ( pendingMode ) {
        resource->Flags |= DUMMY_FLAG_PENDING;
        resource->PendTime = pendingTime;
    }

    if ( asyncMode ) {
        EnterAsyncMode( resource );

        resource->SignalEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if ( resource->SignalEvent == NULL ) {
            DummyFreeResource( resource );
            (LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to create a timer event\n");
            ClusterRegCloseKey(parametersKey);
            return(0);
        }
    }

    return(resourceId);

} // DumbOpen



DWORD
WINAPI
DumbOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Dummy resource.

Arguments:

    ResourceId - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PDUMMY_RESOURCE   resource;
    DWORD             status = ERROR_SUCCESS;
    DWORD             threadId;
    SYSTEMTIME        time;

    (LogEvent)(
            NULL,
            LOG_INFORMATION,
            L"Online Entry\n");

    DummyAcquireResourceLock();

    resource = DummyFindResource(ResourceId);

    if (resource == NULL) {
        status = ERROR_RESOURCE_NOT_FOUND;
        DUMMY_PRINT("DUMMY Online: resource %u not found.\n", PtrToUlong(ResourceId));
    } else {
        if ( resource->TimerType != TimerNotUsed ) {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_ERROR,
                L"Timer still running!\n");
            DummyReleaseResourceLock();
            return(ERROR_GEN_FAILURE);
        }
        if ( PendingMode( resource ) ) {
            if ( !resource->ThreadHandle ) {
                resource->TimerType = TimerOnlinePending;
                resource->ThreadHandle = CreateThread(
                                                NULL,
                                                0,
                                                DummyTimerThread,
                                                resource,
                                                0,
                                                &threadId
                                                );
                if ( resource->ThreadHandle == NULL ) {
                    (LogEvent)(
                        resource->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to start timer thread.\n");
                    resource->TimerType = TimerNotUsed;
                    status = ERROR_GEN_FAILURE;
                } else {
                    CloseHandle( resource->ThreadHandle );
                }
                status = ERROR_IO_PENDING;
            }
            if ( AsyncMode(resource) && (status != ERROR_GEN_FAILURE) ) {
                *EventHandle = resource->SignalEvent;
            }
        } else if ( AsyncMode( resource ) ) {
            if ( !ResetEvent( resource->TimerThreadWakeup ) ) {
                (LogEvent)(
                    resource->ResourceHandle,
                    LOG_ERROR,
                    L"Failed to reset timer wakeup event\n");
                status = ERROR_GEN_FAILURE;
            } else if ( !resource->ThreadHandle ) {
                resource->ThreadHandle = CreateThread(
                                            NULL,
                                            0,
                                            DummyTimerThread,
                                            resource,
                                            0,
                                            &threadId
                                            );

                if ( resource->ThreadHandle == NULL ) {
                    (LogEvent)(
                        resource->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to start timer thread.\n");
                    status = ERROR_GEN_FAILURE;
                } else {
                    CloseHandle(resource->ThreadHandle);
                }
                resource->TimerType = TimerErrorPending;
            }
            //
            // If we are successful, then return our signal event.
            //
            if ( status == ERROR_SUCCESS ) {
                *EventHandle = resource->SignalEvent;
            }
        }
    }

    if ( status == ERROR_SUCCESS ) {
        resource->State = ClusterResourceOnline;
        GetSystemTime(&time);
        (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Online at %1!02d!:%2!02d!:%3!02d!.%4!03d!\n",
            time.wHour,
            time.wMinute,
            time.wSecond,
            time.wMilliseconds);
    } else if ( status == ERROR_IO_PENDING ) {
        resource->State = ClusterResourceOnlinePending;
    }

    (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Online Exit\n");


    DummyReleaseResourceLock();

    return(status);

} // DumbOnline



VOID
WINAPI
DumbTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Dummy resource.

Arguments:

    ResourceId - supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PDUMMY_RESOURCE  resource;

    (LogEvent)(
            NULL,
            LOG_INFORMATION,
            L"Terminate Entry\n");

    DummyAcquireResourceLock();

    resource = DummyFindResource(ResourceId);

    if (resource == NULL) {
        DUMMY_PRINT("DUMMY Terminate: resource %u not found\n", PtrToUlong(ResourceId));
    }
    else {
        resource->State = ClusterResourceFailed;
        if ( resource->TimerType != TimerNotUsed ) {
            SetEvent( resource->TimerThreadWakeup );
        }
        (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Terminated\n");
    }

    (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Terminate Exit\n");

    resource->ThreadHandle = NULL;
    DummyReleaseResourceLock();

    return;

} // DumbTerminate



DWORD
WINAPI
DumbOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Dummy resource.

Arguments:

    ResourceId - supplies the resource it to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   threadId;
    PDUMMY_RESOURCE  resource;

    (LogEvent)(
            NULL,
            LOG_INFORMATION,
            L"Offline Entry\n");

    DumbTerminate(ResourceId);

    //
    // Now check if we are to return pending...
    //

    DummyAcquireResourceLock();

    resource = DummyFindResource(ResourceId);

    if (resource == NULL) {
        DUMMY_PRINT("DUMMY Offline: resource %u not found\n", PtrToUlong(ResourceId));
    } else {
        resource->State = ClusterResourceOfflinePending;
        if ( resource->TimerType != TimerNotUsed ) {
            DummyReleaseResourceLock();
            return(ERROR_IO_PENDING);
        }
        resource->State = ClusterResourceOffline;
        if ( PendingMode(resource) ) {
            //CL_ASSERT( resource->ThreadHandle == NULL );
            if ( !ResetEvent( resource->TimerThreadWakeup ) ) {
                (LogEvent)(
                    resource->ResourceHandle,
                    LOG_ERROR,
                    L"Failed to reset pending wakeup event\n");
                status = ERROR_GEN_FAILURE;
            } else if ( !resource->ThreadHandle ) {
                resource->ThreadHandle = CreateThread(
                                            NULL,
                                            0,
                                            DummyTimerThread,
                                            resource,
                                            0,
                                            &threadId
                                            );

                if ( resource->ThreadHandle == NULL ) {
                    (LogEvent)(
                        resource->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to start pending timer thread.\n");
                    status = GetLastError();
                } else {
                    CloseHandle( resource->ThreadHandle );
                    resource->TimerType = TimerOfflinePending;
                    status = ERROR_IO_PENDING;
                    resource->State = ClusterResourceOfflinePending;
                }
            }
        }
    }

    (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Offline Exit\n");

    DummyReleaseResourceLock();

    return(status);

} // DumbOffline



BOOL
WINAPI
DumbIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Dummy resource.

Arguments:

    ResourceId - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    SYSTEMTIME       Time;
    PDUMMY_RESOURCE  resource;
    BOOLEAN          returnValue = FALSE;
    DWORD            failed = FALSE;
    DWORD            status;
    DWORD ValueType;
    DWORD ValueSize;

    DummyAcquireResourceLock();

    resource = DummyFindResource(ResourceId);

    if (resource == NULL) {
        DUMMY_PRINT("DUMMY IsAlive: resource %u not found.\n", PtrToUlong(ResourceId));
        DummyReleaseResourceLock();
        return(FALSE);
    }

    GetSystemTime(&Time);

    ValueSize = sizeof(failed);
    status = ClusterRegQueryValue(resource->ParametersKey,
                                  DUMMY_PARAMETER_FAILED,
                                  &ValueType,
                                  (PBYTE)&failed,
                                  &ValueSize);

    if (status != NO_ERROR) {
        if (resource->State == ClusterResourceFailed) {
            failed = TRUE;
        }
    }

    if (resource->State == ClusterResourceFailed) {
        if (!failed) {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Recovered at      %1!2d!:%2!02d!:%3!02d!.%4!03d!  !!!!\n",
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds);
            resource->State = ClusterResourceOnline;
        }
        else {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Is Dead at        %1!2d!:%2!02d!:%3!02d!.%4!03d!\n",
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds);
        }
    }
    else if (resource->State == ClusterResourceOnline) {
        if (failed) {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Failed at         %1!2d!:%2!02d!:%3!02d!.%4!03d! !!!!\n",
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds);
            resource->State = ClusterResourceFailed;
        }
        else {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Is Alive at       %1!2d!:%2!02d!:%3!02d!.%4!03d!\n",
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds);
        }
    }
    else {
        (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Resource state %1!u! during IsAlive poll at %2!2d!:%3!02d!:%4!02d!.%5!03d! !!!!\n",
            resource->State,
            Time.wHour,
            Time.wMinute,
            Time.wSecond,
            Time.wMilliseconds);
    }

    returnValue = (resource->State == ClusterResourceOnline) ? TRUE : FALSE;

    DummyReleaseResourceLock();

    return(returnValue);

} // DumbIsAlive



BOOL
WINAPI
DumbLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Dummy resource.

Arguments:

    ResourceId - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    SYSTEMTIME       Time;
    PDUMMY_RESOURCE  resource;
    BOOLEAN          returnValue = FALSE;
    DWORD            failed = FALSE;
    DWORD            status;
    DWORD ValueType;
    DWORD ValueSize;


    DummyAcquireResourceLock();

    resource = DummyFindResource(ResourceId);

    if (resource == NULL) {
        DUMMY_PRINT("DUMMY LooksAlive: resource %u not found.\n", PtrToUlong(ResourceId));
        DummyReleaseResourceLock();
        return(FALSE);
    }

    GetSystemTime(&Time);

    ValueSize = sizeof(failed);
    status = ClusterRegQueryValue(resource->ParametersKey,
                                  DUMMY_PARAMETER_FAILED,
                                  &ValueType,
                                  (PBYTE)&failed,
                                  &ValueSize);

    if (status != NO_ERROR) {
        if (resource->State == ClusterResourceFailed) {
            failed = TRUE;
        }
    }

    if (resource->State == ClusterResourceFailed) {
        if (!failed) {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Recovered at      %1!2d!:%2!02d!:%3!02d!.%4!03d! !!!!\n",
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds);
            resource->State = ClusterResourceOnline;
        }
        else {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Looks Dead at     %1!2d!:%2!02d!:%3!02d!.%4!03d!\n",
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds);
        }
    }
    else if (resource->State == ClusterResourceOnline) {
        if (failed) {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Failed at         %1!2d!:%2!02d!:%3!02d!.%4!03d! !!!!\n",
                resource->ResourceHandle,
                LOG_INFORMATION,
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds);
            resource->State = ClusterResourceFailed;
        }
        else {
            (LogEvent)(
                resource->ResourceHandle,
                LOG_INFORMATION,
                L"Looks Alive at    %1!2d!:%2!02d!:%3!02d!.%4!03d!\n",
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds);
        }
    }
    else {
        (LogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Resource state %1!u! during LooksAlive poll at %2!2d!:%3!02d!:%4!02d!.%5!03d! !!!!\n",
            resource->State,
            Time.wHour,
            Time.wMinute,
            Time.wSecond,
            Time.wMilliseconds);
    }

    returnValue = (resource->State == ClusterResourceOnline) ? TRUE : FALSE;

    DummyReleaseResourceLock();

    return(returnValue);

} // DumbLooksAlive



VOID
WINAPI
DumbClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Dummy resource.

Arguments:

    ResourceId - supplies resource id to be closed.

Return Value:

    None.

--*/

{
    PDUMMY_RESOURCE  resource;
    PLIST_ENTRY      entry;


    DummyAcquireResourceLock();

    resource = DummyFindResource(ResourceId);

    if (resource == NULL) {
        DUMMY_PRINT("DUMMY: Close, resource %u not found\n", PtrToUlong(ResourceId));
    }
    else {
        if ( resource->TimerThreadWakeup != NULL ) {
            CloseHandle( resource->TimerThreadWakeup );
        }
        if ( resource->SignalEvent != NULL ) {
            CloseHandle( resource->SignalEvent );
        }
        ClusterRegCloseKey(resource->ParametersKey);
        DummyFreeResource(resource);
    }

    DummyReleaseResourceLock();

    (LogEvent)(
        resource->ResourceHandle,
        LOG_INFORMATION,
        L"Closed.\n");

    return;

} // DumbClose

//
// Define Function Table
//

CLRES_V1_FUNCTION_TABLE( DumbFunctionTable,
                         CLRES_VERSION_V1_00,
                         Dumb,
                         NULL,
                         NULL,
                         NULL,
                         NULL );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\genscript\scriptresource.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ScriptResource.cpp
//
//  Description:
//      CScriptResource class implementation.
//
//  Maintained By:
//      gpease 14-DEC-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <clusudef.h>
#include "ActiveScriptSite.h"
#include "ScriptResource.h"
#include "SpinLock.h"
#include "clusrtl.h"

DEFINE_THISCLASS("CScriptResource")

//
//  KB:  gpease  08-FEB-2000
//
//  The Generic Scripting Resource uses a separate working thread to do all
//  calls into the Script. This is because the Scripting Host Engines require
//  only the creating thread to call them (remember, scripting is designed
//  to be used in a user mode application where usually the UI thread runs
//  the script). To make this possible, we serialize the threads entering the
//  the script using a user-mode spinlock (m_lockSerialize). We then use two events
//  to signal the "worker thread" (m_EventWait) and to signal when the "worker 
//  thread" has completed the task (m_EventDone).
//
//  LooksAlive is implemented by returning the last result of a LooksAlive. It
//  will start the "worker thread" doing the LooksAlive, but not wait for the
//  thread to return the result. Because of this, all the other threads must
//  make sure that the "Done Event" (m_EventDone) is signalled before writing
//  into the common buffers (m_msg and m_hr).
//

//////////////////////////////////////////////////////////////////////////////
//
//  LPUNKNOWN
//  CScriptResource_CreateInstance( void )
//
//  Description:
//      Creates an intialized instance of CScriptResource.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NULL    - Failure to create or initialize.
//      valid pointer to a CScriptResource.
//
//////////////////////////////////////////////////////////////////////////////
CScriptResource *
CScriptResource_CreateInstance( 
    LPCWSTR pszNameIn, 
    HKEY hkeyIn, 
    RESOURCE_HANDLE hResourceIn
    )
{
    TraceFunc( "CScriptResource_CreateInstance( )\n" );

    CScriptResource * lpcc = new CScriptResource( );
    if ( lpcc != NULL )
    {
        HRESULT hr = THR( lpcc->Init( pszNameIn, hkeyIn, hResourceIn ) );
        if ( SUCCEEDED( hr ) )
        {
            RETURN( lpcc );
        } // if: success

        delete lpcc;

    } // if: got object

    RETURN(NULL);
} //*** CScriptResource_CreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
//////////////////////////////////////////////////////////////////////////////
CScriptResource::CScriptResource( ) :
    m_dispidOpen(DISPID_UNKNOWN),
    m_dispidClose(DISPID_UNKNOWN),
    m_dispidOnline(DISPID_UNKNOWN),
    m_dispidOffline(DISPID_UNKNOWN),
    m_dispidTerminate(DISPID_UNKNOWN),
    m_dispidLooksAlive(DISPID_UNKNOWN),
    m_dispidIsAlive(DISPID_UNKNOWN)
{
    TraceClsFunc1( "%s( )\n", __THISCLASS__ );
    Assert( m_cRef == 0 );

    TraceFuncExit( );
} //*** constructor

//////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
//////////////////////////////////////////////////////////////////////////////
CScriptResource::~CScriptResource( )
{
    TraceClsFunc1( "~%s( )\n", __THISCLASS__ );

    HRESULT hr;

    CSpinLock SpinLock( &m_lockSerialize, INFINITE );

    //
    // Make sure no one else has this lock.... else why are we going away?
    //
    hr = SpinLock.AcquireLock( );
    Assert( hr == S_OK );

    //
    //  Kill the worker thread.
    //
    if ( m_hThread != NULL )
    {
        //  Tell it to DIE
        m_msg = msgDIE;

        //  Signal the event.
        SetEvent( m_hEventWait );

        //  Wait for it to happen. This shouldn't take long at all.
        WaitForSingleObject( m_hThread, 30000 );    // 30 seconds

        //  Cleanup the handle.
        CloseHandle( m_hThread );
    }

    if ( m_hEventDone != NULL )
    {
        CloseHandle( m_hEventDone );
    }

    if ( m_hEventWait != NULL )
    {
        CloseHandle( m_hEventWait );
    }
    
    if ( m_pszName != NULL )
    {
        TraceFree( m_pszName );
    } // if: m_pszName

    if ( m_hkeyParams != NULL )
    {
        ClusterRegCloseKey( m_hkeyParams );
    } // if: m_hkeyParams

#if defined(DEBUG)
    //
    // Make the debug build happy. Not needed in RETAIL.
    //
    SpinLock.ReleaseLock( );
#endif // defined(DEBUG)

    TraceFuncExit( );

} //*** destructor

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::Init( 
//      LPCWSTR             pszNameIn,
//      HKEY                hkeyIn,
//      RESOURCE_HANDLE     hResourceIn
//      )
//
//  Description:
//      Initializes the class.
//
//  Arguments:
//      pszNameIn   - Name of resource instance.
//      hkeyIn      - The cluster key root for this resource instance.
//      hResourceIn - The hResource for this instance.
//
//  Return Value:
//      S_OK -
//          Success.
//      HRESULT_FROM_WIN32( ) error - 
//          if Win32 call failed.
//      E_OUTOFMEMORY - 
//          Out of memory.
//      other HRESULT errors.
//
//////////////////////////////////////////////////////////////////////////////

HRESULT
CScriptResource::Init( 
    LPCWSTR             pszNameIn,
    HKEY                hkeyIn,
    RESOURCE_HANDLE     hResourceIn
    )
{
    TraceClsFunc1( "Init( pszNameIn = '%s' )\n", pszNameIn );

    DWORD   dwErr;

    HRESULT hr = S_OK;

    // IUnknown
    AddRef( );

    // Other
    m_hResource = hResourceIn;
    Assert( m_pszName == NULL );
    Assert( m_pszScriptFilePath == NULL );
    Assert( m_pszScriptEngine == NULL );
    Assert( m_hEventWait == NULL );
    Assert( m_hEventDone == NULL );
    Assert( m_lockSerialize == FALSE );

    //
    // Create some event to wait on.
    //

    // scripting engine thread wait event
    m_hEventWait = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_hEventWait == NULL )
        goto Win32Error;

    // task completion event
    m_hEventDone = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_hEventDone == NULL )
        goto Win32Error;

    //
    // Copy the resource name.
    //

    m_pszName = TraceStrDup( pszNameIn );
    if ( m_pszName == NULL )
        goto OutOfMemory;

    //
    // Open the parameters key.
    //

    dwErr = ClusterRegOpenKey( hkeyIn, L"Parameters", KEY_ALL_ACCESS, &m_hkeyParams );
    if ( dwErr != ERROR_SUCCESS )
    {
        TW32( dwErr );
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    } // if: failed

    //
    // Create the scripting engine thread.
    //

    m_hThread = CreateThread( NULL,
                              0,
                              &S_ThreadProc,
                              this,
                              0,
                              &m_dwThreadId
                              );
    if ( m_hThread == NULL )
        goto Win32Error;

Cleanup:
    //
    // All class variable clean up should be done in the destructor.
    //
    HRETURN( hr );

Error:
    LogError( hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

Win32Error:
    dwErr = GetLastError( );
    TW32( dwErr );
    hr = HRESULT_FROM_WIN32( dwErr );
    goto Error;

} //*** Init( )

//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::[IUnknown] QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    TraceClsFunc1( "[IUnknown] QueryInterface( riid, ppv = 0x%08x )\n",                   
                   ppv
                   );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IUnknown, static_cast< IUnknown* >( this ), 0 );
        hr   = S_OK;
    } // if: IUnknown

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

    QIRETURN( hr, riid );

} //*** QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CScriptResource::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    LONG cRef = InterlockedIncrement( &m_cRef );

    RETURN( cRef );

} //*** AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CScriptResource::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    LONG cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    RETURN( cRef );

} //*** Release( )


//****************************************************************************
//
//  Publics
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::Close( 
//  )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Close( 
    )
{
    TraceClsFunc( "Close( )\n" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgCLOSE ) );

    HRETURN( hr );

} //*** Close( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::Open(
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Open(
    )
{
    TraceClsFunc( "Open( )\n" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgOPEN ) );

    // CMCM:+ 19-Dec-2000 commented this out to make the DBG PRINT quiet since we now return ERROR_RETRY
    // HRETURN( hr ); 
    return hr;

} //*** Open( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::Online(
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Online(
    )
{
    TraceClsFunc( "Online( )\n" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgONLINE ) );

    HRETURN( hr );
} //*** Online( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::Offline(
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Offline(
    )
{
    TraceClsFunc( "Offline( )\n" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgOFFLINE ) );

    HRETURN( hr );
} //*** Offline( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::Terminate(
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Terminate(
    )
{
    TraceClsFunc( "Terminate( )\n" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgTERMINATE ) );

    HRETURN( hr );
} //*** Terminate( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::LooksAlive(
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::LooksAlive(
    )
{
    TraceClsFunc( "LooksAlive( )\n" );

    HRESULT hr;
    BOOL    b;
    DWORD   dw;

    CSpinLock SerializeLock( &m_lockSerialize, INFINITE );

    //
    //  Acquire the serialization lock.
    //
    hr = THR( SerializeLock.AcquireLock( ) );
    if ( FAILED( hr ) )
    {
        //
        //  Can't "goto Error" because we didn't acquire the lock.
        //
        LogError( hr );
        goto Cleanup;
    }

    //
    //  Wait for the script thread to be "done." 
    //
    dw = WaitForSingleObject( m_hEventDone, INFINITE );
    if ( dw != WAIT_OBJECT_0 )
        goto Win32Error;

    //
    //  Reset the done event to indicate that the thread is not busy.
    //
    b = ResetEvent( m_hEventDone );
    if ( !b )
        goto Win32Error;

    //
    //  Store the message in the common memory buffer.
    //
    m_msg = msgLOOKSALIVE;

    //
    //  Signal the script thread to process the message, but don't wait for 
    //  it to complete.
    //
    dw = SetEvent( m_hEventWait );

    if ( m_fLastLooksAlive )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

ReleaseLockAndCleanup:
    SerializeLock.ReleaseLock( );

Cleanup:
    HRETURN( hr );

Error:
    LogError( hr );
    goto ReleaseLockAndCleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( GetLastError( ) );
    goto Error;

} //*** LooksAlive( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::IsAlive(
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::IsAlive(
    )
{
    TraceClsFunc( "IsAlive( )\n" );

    HRESULT hr;
    
    hr = THR( WaitForMessageToComplete( msgISALIVE ) );

    HRETURN( hr );
} //*** IsAlive( )

//****************************************************************************
//
//  Privates
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::WaitForMessageToComplete(
//      SMESSAGE msgIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::WaitForMessageToComplete(
    EMESSAGE msgIn
    )
{
    TraceClsFunc( "WaitForMessageToComplete( )\n" );

    HRESULT hr;
    BOOL    b;
    DWORD   dw;

    CSpinLock SerializeLock( &m_lockSerialize, INFINITE );

    //
    //  Acquire the serialization lock.
    //
    hr = THR( SerializeLock.AcquireLock( ) );
    if ( FAILED( hr ) )
    {
        //
        //  Can't "goto Error" because we didn't acquire the lock.
        //
        LogError( hr );
        goto Cleanup;
    }

    //
    //  Wait for the script thread to be "done."
    //
    dw = WaitForSingleObject( m_hEventDone, INFINITE );
    if ( dw != WAIT_OBJECT_0 )
        goto Win32Error;

    //
    //  Reset the done event to indicate that the thread is not busy.
    //
    b = ResetEvent( m_hEventDone );
    if ( !b )
        goto Win32Error;

    //
    //  Store the message in the common memory buffer.
    //
    m_msg = msgIn;

    //
    //  Signal the script thread to process the message.
    //
    b = SetEvent( m_hEventWait );
    if ( !b )
        goto Win32Error;

    //
    //  Wait for the thread to complete.
    //
    dw = WaitForSingleObject( m_hEventDone, INFINITE );
    if ( dw != WAIT_OBJECT_0 )
        goto Win32Error;

    //
    //  Get the result of the task from the common buffer.
    //
    hr = m_hr;

ReleaseLockAndCleanup:
    SerializeLock.ReleaseLock( );

Cleanup:
    HRETURN( hr );

Error:
    LogError( hr );
    goto ReleaseLockAndCleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( GetLastError( ) );
    goto Error;

} //*** WaitForMessageToComplete( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::LogError(
//      HRESULT hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::LogError(
    HRESULT hrIn
    )
{
    TraceClsFunc1( "LogError( hrIn = 0x%08x )\n", hrIn );

    TraceMsg( mtfCALLS, "%s failed. HRESULT: 0x%08x\n", m_pszName, hrIn );

    (ClusResLogEvent)( m_hResource, LOG_ERROR, L"HRESULT: 0x%1!08x!\n", hrIn );

    HRETURN( S_OK );

} //*** LogError( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::LogScriptError( 
//      EXCEPINFO ei 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::LogScriptError( 
    EXCEPINFO ei 
    )
{
    TraceClsFunc( "LogScriptError( ... )\n" );

    HRESULT hr;

    if ( ei.pfnDeferredFillIn != NULL )
    {
        hr = THR( ei.pfnDeferredFillIn( &ei ) );
    }

    TraceMsg( mtfCALLS, "%s failed.\nError: %u\nSource: %s\nDescription: %s\n", 
              m_pszName, 
              ( ei.wCode == 0 ? ei.scode : ei.wCode ), 
              ( ei.bstrSource == NULL ? L"<null>" : ei.bstrSource ),
              ( ei.bstrDescription == NULL ? L"<null>" : ei.bstrDescription )
              );
    (ClusResLogEvent)( m_hResource, 
                       LOG_ERROR, 
                       L"Error: %1!u! - Description: %2 (Source: %3)\n", 
                       ( ei.wCode == 0 ? ei.scode : ei.wCode ), 
                       ( ei.bstrDescription == NULL ? L"<null>" : ei.bstrDescription ),
                       ( ei.bstrSource == NULL ? L"<null>" : ei.bstrSource )
                       );
    HRETURN( S_OK );
} //*** LogScriptError( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnOpen(
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnOpen(
    )
{
    TraceClsFunc( "OnOpen( ... )\n" );

    HRESULT hr = S_OK;
    hr = HRESULT_FROM_WIN32( ERROR_RETRY );
    (ClusResLogEvent)( m_hResource, 
                       LOG_INFORMATION, 
                       L"Leave OnOpen without calling connect.  Fail call so we don't try to use it.\n");
    return hr;

} //*** OnOpen( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnClose(
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnClose(
    )
{
    TraceClsFunc( "OnClose( )\n" );

    HRESULT hr;
    
    EXCEPINFO   ei;
    VARIANT     varResult;

    DISPPARAMS  dispparamsNoArgs = { NULL, NULL, 0, 0 };

    VariantInit( &varResult );

    // Assert( m_pidm != NULL );

    if ( m_pidm != NULL 
      && m_dispidClose != DISPID_UNKNOWN
       )
    {
        hr = THR( m_pidm->Invoke( m_dispidClose,
                                  IID_NULL,
                                  LOCALE_USER_DEFAULT,
                                  DISPATCH_METHOD,
                                  &dispparamsNoArgs, 
                                  &varResult,
                                  &ei,
                                  NULL
                                  ) );
    }
    else
    {
        hr = S_OK;
    }
    if ( hr == DISP_E_EXCEPTION )
    {
        LogScriptError( ei );
    }
    else if ( hr == DISP_E_MEMBERNOTFOUND )
    {
        //
        // No-op
        //
        hr = S_OK;
    } 
    else if ( FAILED( hr ) )
    {
        LogError( hr );
    }

    VariantClear( &varResult );

    //
    // Disconnect script engine.  Note that it may not be connected
    // but DoDisconnect is safe to call either way.
    //
    DoDisconnect( );

    HRETURN( hr );
} //*** OnClose( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnOnline( 
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnOnline( 
    )
{
    TraceClsFunc( "OnOnline( ... )\n" );

    HRESULT hr;
    DWORD   dwErr;
    DWORD   cbSize;
    DWORD   dwLow;
    DWORD   dwRead;

    LPWSTR      pszCommand;
    EXCEPINFO   ei;
    LPWSTR      pszScriptFilePathTmp = NULL;

    BOOL    b;
    BOOL    bDoneConnect = FALSE;
    VARIANT varResult;

    HANDLE  hFile = INVALID_HANDLE_VALUE;

    LPWSTR pszScriptName = NULL;
    LPSTR  paszText = NULL;
    LPWSTR pszScriptText = NULL;

    VariantInit( &varResult );

    DISPPARAMS  dispparamsNoArgs = { NULL, NULL, 0, 0 };

    //
    // Figure out how big the filepath is.
    //
    dwErr = TW32( ClusterRegQueryValue( m_hkeyParams, CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH, NULL, NULL, &cbSize ) );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    } // if: failed

    //
    // Make a buffer big enough.
    //    
    cbSize += sizeof(L"");

    pszScriptFilePathTmp = reinterpret_cast<LPWSTR>( TraceAlloc( LMEM_FIXED, cbSize ) );
    if ( pszScriptFilePathTmp == NULL )
        goto OutOfMemory;

    //
    // Grab it for real this time,
    //
    dwErr = TW32( ClusterRegQueryValue( m_hkeyParams, CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH, NULL, reinterpret_cast<LPBYTE>( pszScriptFilePathTmp ), &cbSize ) );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    }
    
    //
    // If we have some old data from before then free this first.
    //
    if ( m_pszScriptFilePath != NULL )
    {
        LocalFree( m_pszScriptFilePath );
    }

    m_pszScriptFilePath = ClRtlExpandEnvironmentStrings( pszScriptFilePathTmp );
    if ( m_pszScriptFilePath == NULL ) 
    {
        hr = HRESULT_FROM_WIN32( GetLastError( ) );
        goto Error;
    }
        
    hr = DoConnect (m_pszScriptFilePath);    
    if ( FAILED( hr ) )
    {
        goto Error;
    }
    bDoneConnect = TRUE;

    //
    // Open the script file.
    //
    hFile = CreateFile( m_pszScriptFilePath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        goto Error;
    } // if: failed to open

    //
    // Figure out its size.
    //
    dwLow = GetFileSize( hFile, NULL );
    if ( dwLow == -1 )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
        goto Error;
    } // if: failed to figure out size
    else if ( dwLow == -2 )
        goto OutOfMemory;

    //
    // Make a buffer big enough to hold it.
    //
    dwLow++;    // add one for trailing NULL.
    paszText = reinterpret_cast<LPSTR>( TraceAlloc( LMEM_FIXED, dwLow ) );
    if ( paszText == NULL )
        goto OutOfMemory;

    //
    // Read the script into memory.
    //
    b = ReadFile( hFile, paszText, dwLow - 1, &dwRead, NULL );
    if ( !b )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError( ) ) );
        goto Error;
    } // if: failed

    if ( dwRead == - 1 )
        goto OutOfMemory;
    if ( dwLow - 1 != dwRead )
        goto OutOfMemory;   // TODO: figure out a better error code.

    //
    // Make sure it is terminated.
    //
    paszText[ dwRead ] = L'\0';

    //
    // Make a buffer to convert the text into UNICODE.
    //
    dwRead++;
    pszScriptText = reinterpret_cast<LPWSTR>( TraceAlloc( LMEM_FIXED, dwRead * sizeof(WCHAR) ) );
    if ( pszScriptText == NULL )
        goto OutOfMemory;

    //
    // Convert it to UNICODE.
    //
    Assert( lstrlenA( paszText ) + 1 == (signed)dwRead );
    mbstowcs( pszScriptText, paszText, dwRead );

    //
    // Load the script into the engine for pre-parsing.
    //
    hr = THR( m_pasp->ParseScriptText( pszScriptText,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       0,
                                       0,
                                       &varResult,
                                       &ei
                                       ) );
    if ( hr == DISP_E_EXCEPTION )
        goto ErrorWithExcepInfo;
    else if ( FAILED( hr ) )
        goto Error;

    VariantClear( &varResult );

    Assert( m_pidm != NULL );

    //
    // Get DISPIDs for each method we will call.
    //
    pszCommand = L"Online";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                    &pszCommand, 
                                    1, 
                                    LOCALE_USER_DEFAULT, 
                                    &m_dispidOnline 
                                    ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidOnline = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Error;
    }

    pszCommand = L"Close";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                    &pszCommand, 
                                    1, 
                                    LOCALE_USER_DEFAULT, 
                                    &m_dispidClose 
                                    ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidClose = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Error;
    }

    pszCommand = L"Offline";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                    &pszCommand, 
                                    1, 
                                    LOCALE_USER_DEFAULT, 
                                    &m_dispidOffline
                                    ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidOffline = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Error;
    }

    pszCommand = L"Terminate";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                     &pszCommand, 
                                     1, 
                                     LOCALE_USER_DEFAULT, 
                                     &m_dispidTerminate 
                                     ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidTerminate = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Error;
    }

    pszCommand = L"LooksAlive";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                     &pszCommand, 
                                     1, 
                                     LOCALE_USER_DEFAULT, 
                                     &m_dispidLooksAlive 
                                     ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidLooksAlive = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Error;
    }

    pszCommand = L"IsAlive";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                     &pszCommand, 
                                     1, 
                                     LOCALE_USER_DEFAULT, 
                                     &m_dispidIsAlive 
                                     ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidIsAlive = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    // Invoke the Online function.
    //
    if ( m_dispidOnline != DISPID_UNKNOWN )
    {
        hr = THR( m_pidm->Invoke( m_dispidOnline,
                                  IID_NULL,
                                  LOCALE_USER_DEFAULT,
                                  DISPATCH_METHOD,
                                  &dispparamsNoArgs, 
                                  &varResult,
                                  &ei,
                                  NULL
                                  ) );
        if ( hr == DISP_E_EXCEPTION )
        {
            LogScriptError( ei );
        }
        else if ( hr == DISP_E_MEMBERNOTFOUND )
        {
            //
            // No-op
            //
            hr = S_OK;
        } 
        else if ( FAILED( hr ) )
        {
            LogError( hr );
        }
    }

    //
    // Assume the resource LooksAlive...
    //
    m_fLastLooksAlive = TRUE;

    //
    // TODO:    gpease  16-DEC-1999
    //          Record and process the result of the Online call.
    //

Cleanup:
    VariantClear( &varResult );

    if ( pszScriptFilePathTmp )
    {
        TraceFree( pszScriptFilePathTmp );
    } // if: pszScriptFilePathTmp

    if ( paszText != NULL )
    {
        TraceFree( paszText );
    } // if: paszText

    if ( pszScriptText != NULL )
    {
        TraceFree( pszScriptText );
    } // if: pszScriptText;

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    } // if: hFile

    HRETURN( hr );
Error:
    LogError( hr );
    if ( bDoneConnect == TRUE )
    {
        DoDisconnect( );
    }
    goto Cleanup;
ErrorWithExcepInfo:
    LogScriptError( ei );
    goto Cleanup;
OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
} //*** OnOnline( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnOffline(
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnOffline(
    )
{
    TraceClsFunc( "OnOffline( ... )\n" );

    HRESULT hr;

    EXCEPINFO   ei;
    VARIANT     varResult;

    DISPPARAMS  dispparamsNoArgs = { NULL, NULL, 0, 0 };

    VariantInit( &varResult );

    Assert( m_pidm != NULL );

    if ( m_pidm != NULL 
      && m_dispidOffline != DISPID_UNKNOWN
       )
    {
        hr = THR( m_pidm->Invoke( m_dispidOffline,
                                  IID_NULL,
                                  LOCALE_USER_DEFAULT,
                                  DISPATCH_METHOD,
                                  &dispparamsNoArgs, 
                                  &varResult,
                                  &ei,
                                  NULL
                                  ) );
    }
    else
    {
        hr = S_OK;
    }
    if ( hr == DISP_E_EXCEPTION )
    {
        LogScriptError( ei );
    }
    else if ( hr == DISP_E_MEMBERNOTFOUND )
    {
        //
        // No-op
        //
        hr = S_OK;
    } 
    else if ( FAILED( hr ) )
    {
        LogError( hr );
    }

    VariantClear( &varResult );

    //
    // Tear down the scripting engine association as it is recreated in OnOnline.
    //
    DoDisconnect( );

    HRETURN( hr );
} //*** OnOffline( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnTerminate(
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnTerminate(
    )
{
    TraceClsFunc( "OnTerminate( ... )\n" );

    HRESULT hr;

    EXCEPINFO   ei;
    VARIANT     varResult;

    DISPPARAMS  dispparamsNoArgs = { NULL, NULL, 0, 0 };

    VariantInit( &varResult );

//    Assert( m_pidm != NULL );

    if ( m_pidm != NULL 
      && m_dispidTerminate != DISPID_UNKNOWN
       )
    {
        hr = THR( m_pidm->Invoke( m_dispidTerminate,
                                  IID_NULL,
                                  LOCALE_USER_DEFAULT,
                                  DISPATCH_METHOD,
                                  &dispparamsNoArgs, 
                                  &varResult,
                                  &ei,
                                  NULL
                                  ) );
    }
    else
    {
        hr = S_OK;
    }
    if ( hr == DISP_E_EXCEPTION )
    {
        LogScriptError( ei );
    }
    else if ( hr == DISP_E_MEMBERNOTFOUND )
    {
        //
        // No-op
        //
        hr = S_OK;
    } 
    else if ( FAILED( hr ) )
    {
        LogError( hr );
    }
    HRETURN( hr );
} //*** OnTerminate( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnLooksAlive(
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnLooksAlive(
    )
{
    TraceClsFunc( "OnLooksAlive( ... )\n" );

    HRESULT hr;

    EXCEPINFO   ei;
    VARIANT     varResult;

    DISPPARAMS  dispparamsNoArgs = { NULL, NULL, 0, 0 };

    VariantInit( &varResult );

    Assert( m_pidm != NULL );

    if ( m_pidm != NULL 
      && m_dispidLooksAlive != DISPID_UNKNOWN
       )
    {
        hr = THR( m_pidm->Invoke( m_dispidLooksAlive,
                                  IID_NULL,
                                  LOCALE_USER_DEFAULT,
                                  DISPATCH_METHOD,
                                  &dispparamsNoArgs, 
                                  &varResult,
                                  &ei,
                                  NULL
                                  ) );
    }
    else
    {
        (ClusResLogEvent)( m_hResource, 
                           LOG_ERROR, 
                           L"%1 did not implement Function LooksAlive( ). This is a required function.\n", 
                           m_pszName 
                           );
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }
    if ( hr == DISP_E_EXCEPTION )
    {
        LogScriptError( ei );
        goto Cleanup;
    }
    else if ( FAILED( hr ) )
    {
        LogError( hr );
        goto Cleanup;
    }

    if ( V_VT( &varResult ) == VT_BOOL )
    {
        if ( !V_BOOL( &varResult ) )
        {
            hr = S_FALSE;
        } // if: not alive

    } // if: correct type returned
    else
    {
        hr = THR( E_INVALIDARG );
        LogError( hr );
    } // else: failed

Cleanup:
    VariantClear( &varResult );

    //
    //  Only if the result of this function is S_OK is the resource
    //  considered alive.
    //
    if ( hr == S_OK )
    {
        m_fLastLooksAlive = TRUE;
    } // if: S_OK
    else
    {
        m_fLastLooksAlive = FALSE;
    } // else: failed

    HRETURN( hr );
} //*** OnLooksAlive( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnIsAlive(
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnIsAlive(
    )
{
    TraceClsFunc( "IsAlive( ... )\n" );

    HRESULT hr;

    EXCEPINFO   ei;
    VARIANT     varResult;

    DISPPARAMS  dispparamsNoArgs = { NULL, NULL, 0, 0 };

    VariantInit( &varResult );

    if ( m_pidm != NULL 
      && m_dispidIsAlive != DISPID_UNKNOWN
       )
    {
        hr = THR( m_pidm->Invoke( m_dispidIsAlive,
                                  IID_NULL,
                                  LOCALE_USER_DEFAULT,
                                  DISPATCH_METHOD,
                                  &dispparamsNoArgs, 
                                  &varResult,
                                  &ei,
                                  NULL
                                  ) );
    }
    else
    {
        (ClusResLogEvent)( m_hResource, 
                           LOG_ERROR, 
                           L"%1 did not implement Function IsAlive( ). This is a required function.\n", 
                           m_pszName 
                           );
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }
    if ( hr == DISP_E_EXCEPTION )
    {
        LogScriptError( ei );
        goto Cleanup;
    }
    else if ( FAILED( hr ) )
    {
        LogError( hr );
        goto Cleanup;
    }

    if ( V_VT( &varResult ) == VT_BOOL )
    {
        if ( !V_BOOL( &varResult ) )
        {
            hr = S_FALSE;
        } // if: not alive

    } // if: correct type returned
    else
    {
        hr = THR( E_INVALIDARG );
        LogError( hr );
    } // else: failed

Cleanup:
    VariantClear( &varResult );

    HRETURN( hr );
} //*** OnIsAlive( )

/////////////////////////////////////////////////////////////////////////////
//
//  DWORD 
//  WINAPI
//  CScriptResource::S_ThreadProc( 
//      LPVOID pParam 
//      )
//
/////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI
CScriptResource::S_ThreadProc( 
    LPVOID pParam 
    )
{
    MSG     msg;
    HRESULT hr;
    DWORD   dw;
    BOOL    b;

    CScriptResource * pscript = reinterpret_cast< CScriptResource * >( pParam );

    Assert( pscript != NULL );

    //
    // Initialize COM.
    //
    hr = THR( CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE ) );
    if ( FAILED( hr ) )
        goto Error;

    for( ;; ) // ever
    {
        //
        //  Indicate that we are ready to do something.
        //
        b = SetEvent( pscript->m_hEventDone );
        if ( !b )
            goto Win32Error;

        //
        //  Wait for someone to need something.
        //
        dw = WaitForSingleObject( pscript->m_hEventWait, INFINITE );
        if ( dw != WAIT_OBJECT_0 )
        {
            hr = HRESULT_FROM_WIN32( dw );
            goto Error;
        }

        //
        //  Reset the event.
        //
        b = ResetEvent( pscript->m_hEventWait );
        if ( !b )
            goto Win32Error;

        //
        //  Do what they ask.
        //
        switch ( pscript->m_msg )
        {
        case msgOPEN:
            pscript->m_hr = THR( pscript->OnOpen( ) );
            break;

        case msgCLOSE:
            pscript->m_hr = THR( pscript->OnClose( ) );
            break;

        case msgONLINE:
            pscript->m_hr = THR( pscript->OnOnline( ) );
            break;

        case msgOFFLINE:
            pscript->m_hr = THR( pscript->OnOffline( ) );
            break;

        case msgTERMINATE:
            pscript->m_hr = THR( pscript->OnTerminate( ) );
            break;

        case msgLOOKSALIVE:
            pscript->m_hr = STHR( pscript->OnLooksAlive( ) );
            break;

        case msgISALIVE:
            pscript->m_hr = STHR( pscript->OnIsAlive( ) );
            break;

        case msgDIE:
            //
            // This means the resource is being released.
            //
            goto Cleanup;
        }

    } // spin forever

Cleanup:
    CoUninitialize( );
    return hr;

Error:
    pscript->LogError( hr );
    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( GetLastError( ) );
    goto Error;
} //*** S_ThreadProc( )

//////////////////////////////////////////////////////////////////////////////
//
//  DWORD
//  CScriptResource::MakeScriptEngineAssociation( pszScriptFileName )
//
//  Description:
//      Takes the filename and splits off the extension then queries
//      the registry to obtain the association and finally queries the
//      ScriptingEngine key under that association and allocates and
//      returns a buffer containing the engine name.  This engine name
//      is suitable for input into CLSIDFromProgID.
//
//  Arguments:
//      pszScriptFileName - Pointer to null terminated script file name (full path with environment expanded).
//
//  Return Values:
//      NULL    - Failure to read engine for this key, consult GetLastError() for details.
//      Valid pointer to string buffer containing engine prog id.
//
//////////////////////////////////////////////////////////////////////////////

#define SCRIPTENGINE_KEY_STRING L"\\ScriptEngine"
LPWSTR
CScriptResource::MakeScriptEngineAssociation(
    IN    LPCWSTR     pszScriptFileName 
    )
{
    LPWSTR  pszAssociation = NULL;
    LPWSTR  pszEngineName  = NULL;
    LONG    lRegStatus     = ERROR_SUCCESS;
    HKEY    hKey           = NULL;
    WCHAR   szExtension[_MAX_EXT];
    DWORD   dwType, cbAssociationSize, cbEngineNameSize, dwNumChars;

    //
    // First split the path to get the extension.
    //
    _wsplitpath (pszScriptFileName, NULL, NULL, NULL, szExtension);
    if (szExtension[0] == L'\0') {
        SetLastError (ERROR_FILE_NOT_FOUND);
        goto Cleanup;
    }

    //
    // Pre-parse to patch up .scr association!
    //
    if (_wcsicmp (szExtension, L".scr") == 0)
    {
        LPWSTR pszSCREngine=NULL;
        pszSCREngine = (LPWSTR) TraceAlloc( GPTR, sizeof( L"VBScript" ) );
        if ( pszSCREngine == NULL )
            goto ErrorOutOfMemory;
        else
        {
            wcscpy (pszSCREngine, L"VBScript");
            return pszSCREngine;
        }
    }

    //
    // If the pre-parse didn't get it then go to the registry to do
    // the right thing.
    //
    lRegStatus = RegOpenKeyExW( HKEY_CLASSES_ROOT,              // handle to open key
                                szExtension,                    // subkey name
                                0,                              // reserved
                                KEY_READ,                       // security access desired.
                                &hKey);                         // key handle returned
    if (lRegStatus != ERROR_SUCCESS)
        goto Error;
    
    //
    // Query the value to get the size of the buffer to allocate.
    // NB cbSize contains the size including the '\0'
    //
    lRegStatus = RegQueryValueExW( hKey,                        // handle to key
                                   NULL,                        // value name
                                   0,                           // reserved
                                   &dwType,                     // type buffer
                                   NULL,                        // data buffer
                                   &cbAssociationSize);         // size of data buffer
    if ( lRegStatus != ERROR_SUCCESS )
        goto Error;
    if ( dwType != REG_SZ )
        goto ErrorBadType;

    dwNumChars = cbAssociationSize / sizeof (WCHAR);
    pszAssociation = (LPWSTR) TraceAlloc( GPTR, cbAssociationSize + sizeof (SCRIPTENGINE_KEY_STRING) );
    if ( pszAssociation == NULL )
        goto ErrorOutOfMemory;

    // Get the value for real.
    //
    lRegStatus = RegQueryValueExW( hKey,                        // handle to key
                                   NULL,                        // value name
                                   0,                           // reserved
                                   &dwType,                     // type buffer
                                   (LPBYTE) pszAssociation,     // data buffer
                                   &cbAssociationSize );        // size of data buffer
    if ( lRegStatus != ERROR_SUCCESS )
        goto Error;
    if ( dwType != REG_SZ )
        goto ErrorBadType;
    
    lRegStatus = RegCloseKey( hKey );
    if ( lRegStatus != ERROR_SUCCESS )
        goto Error;
    
    hKey = NULL;

    //
    // Take the data and make a key with \ScriptEngine on the end.  If
    // we find this then we can use the file.
    //
    swprintf( &pszAssociation[ dwNumChars - 1 ], SCRIPTENGINE_KEY_STRING );
    pszAssociation[ dwNumChars + (sizeof( SCRIPTENGINE_KEY_STRING ) / sizeof ( WCHAR ) )  - 1 ] = L'\0';
    
    lRegStatus = RegOpenKeyExW( HKEY_CLASSES_ROOT,              // handle to open key
                                pszAssociation,                 // subkey name
                                0,                              // reserved
                                KEY_READ,                       // security access
                                &hKey );                        // key handle 

    lRegStatus = RegQueryValueExW( hKey,                        // handle to key
                                   NULL,                        // value name
                                   0,                           // reserved
                                   &dwType,                     // type buffer
                                   NULL,                        // data buffer
                                   &cbEngineNameSize);          // size of data buffer
    
    if ( lRegStatus != ERROR_SUCCESS )
        goto Error;
    if ( dwType != REG_SZ )
        goto ErrorBadType;

    dwNumChars = cbEngineNameSize / sizeof (WCHAR);
    pszEngineName = (LPWSTR) TraceAlloc( GPTR, cbEngineNameSize );
    if ( NULL == pszEngineName )
    {
        goto ErrorOutOfMemory;
    }
    pszEngineName[ dwNumChars - 1 ] = '\0';
        
    //
    // Get the value for real.
    //
    lRegStatus = RegQueryValueExW( hKey,                        // handle to key
                                   NULL,                        // value name
                                   0,                           // reserved
                                   &dwType,                     // type buffer
                                   (LPBYTE) pszEngineName,      // data buffer
                                   &cbEngineNameSize);          // size of data buffer

    if ( lRegStatus != ERROR_SUCCESS )
        goto Error;
    if ( dwType != REG_SZ )
        goto ErrorBadType;
    
    lRegStatus = RegCloseKey( hKey );
    if ( lRegStatus != ERROR_SUCCESS )
        goto Error;
    
    hKey = NULL;
    goto Cleanup;

Error:
    SetLastError (lRegStatus);
    goto ErrorCleanup;

ErrorBadType:
    SetLastError (ERROR_FILE_NOT_FOUND);
    goto ErrorCleanup;

ErrorOutOfMemory:
    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
    goto ErrorCleanup;

ErrorCleanup:
    if (pszEngineName) 
    {
        TraceFree (pszEngineName);
        pszEngineName = NULL;
    }
Cleanup:
    if (pszAssociation)
        TraceFree (pszAssociation);
    if (hKey)
        (void) RegCloseKey (hKey);

    return pszEngineName;
}
#undef SCRIPTENGINE_KEY_STRING


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::DoConnect( szScriptFilePath )
//
//  Description:
//      Connects to the script engine associated with the script passed in.
//
//  Arguments:
//      pszScriptFileName - Pointer to null terminated script file name (full path with environment expanded).
//
//  Return Values:
//      S_OK - connected OK.
//      Failure status - local cleanup performed.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::DoConnect(
    IN  LPWSTR  szScriptFilePath
    )
{
    HRESULT hr = S_OK;
    DWORD cbSize;
    DWORD dwErr;
    CLSID clsidScriptEngine;

    CActiveScriptSite * psite;

    //
    // Create the scripting site.
    //
    psite = new CActiveScriptSite( m_hResource, ClusResLogEvent, m_hkeyParams, m_pszName );
    if ( psite == NULL )
        goto OutOfMemory;

    hr = THR( psite->QueryInterface( IID_IActiveScriptSite, reinterpret_cast<void**>( &m_pass ) ) );
    psite->Release( );      // release promptly
    if ( FAILED( hr ) )
        goto Error;

    //
    // Find the Active Engine.
    //
    if (szScriptFilePath == NULL)
    {
        (ClusResLogEvent)( m_hResource, 
                           LOG_INFORMATION, L"DoConnect: Default to VBScript\n");

        hr = THR( CLSIDFromProgID( L"VBScript", &clsidScriptEngine ) );
        if ( FAILED( hr ) )
            goto Error;
    }
    else
    {
        (ClusResLogEvent)( m_hResource, 
                           LOG_INFORMATION, L"DoConnect: Got path: %1\n", szScriptFilePath);

        //
        // Find the program associated with the extension.
        //
        if ( m_pszScriptEngine != NULL )
        {
            TraceFree( m_pszScriptEngine );
        }
        m_pszScriptEngine = MakeScriptEngineAssociation( szScriptFilePath );
        if ( m_pszScriptEngine == NULL) 
        {
            (ClusResLogEvent)( m_hResource, 
                               LOG_ERROR, L"Error getting engine\n");
            hr = HRESULT_FROM_WIN32( GetLastError( ) );
            goto Error;
        }

        (ClusResLogEvent)( m_hResource, 
                           LOG_ERROR, L"Got engine %1\n", m_pszScriptEngine);

        hr = THR( CLSIDFromProgID( m_pszScriptEngine, &clsidScriptEngine ) );
        if ( FAILED( hr ) ) 
        {
            (ClusResLogEvent)( m_hResource, 
                               LOG_ERROR, L"Error getting prog ID\n");
            goto Error;
        }
    }
    //
    // Create an instance of it.
    //
    TraceDo( hr = THR( CoCreateInstance( clsidScriptEngine, 
                                NULL, 
                                CLSCTX_SERVER, 
                                IID_IActiveScriptParse, 
                                reinterpret_cast<void**>( &m_pasp ) 
                                ) )
            );
    if ( FAILED( hr ) ) {
        (ClusResLogEvent)( m_hResource, LOG_ERROR, L"DoConnect: Failed to create instance of CLSID\n");
        goto Error;
    }
    m_pasp = TraceInterface( L"Active Script Engine", IActiveScriptParse, m_pasp, 1 );

    TraceDo( hr = THR( m_pasp->QueryInterface( IID_IActiveScript, (void**) &m_pas ) ) );
    if ( FAILED( hr ) )
        goto Error;
    m_pas = TraceInterface( L"Active Script Engine", IActiveScript, m_pas, 1 );

    //
    // Initialize it.
    //
    TraceDo( hr = THR( m_pasp->InitNew( ) ) );
    if ( FAILED( hr ) ) 
    {
        (ClusResLogEvent)( m_hResource, LOG_ERROR, L"DoConnect: Failed to InitNew\n");
        goto Error;
    }

#if defined(DEBUG)
    //
    // Set our site. We'll give out a new tracking interface to track this separately.
    //
    {
        IActiveScriptSite * psite;
        hr = THR( m_pass->TypeSafeQI( IActiveScriptSite, &psite ) );
        Assert( hr == S_OK );

        TraceDo( hr = THR( m_pas->SetScriptSite( psite ) ) );
        psite->Release( );      // release promptly
        if ( FAILED( hr ) )
            goto Error;
    }
#else
    TraceDo( hr = THR( m_pas->SetScriptSite( m_pass ) ) );
    if ( FAILED( hr ) )
    {
        (ClusResLogEvent)( m_hResource, LOG_ERROR, L"DoConnect: Failed to SetScriptSite\n");
        goto Error;
    }
#endif

    //
    // Add Document to the global members.
    //
    TraceDo( hr = THR( m_pas->AddNamedItem( L"Resource", SCRIPTITEM_ISVISIBLE ) ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    // Connect the script.
    //
    TraceDo( hr = THR( m_pas->SetScriptState( SCRIPTSTATE_CONNECTED ) ) );
    if ( FAILED( hr ) ) {
        (ClusResLogEvent)( m_hResource, LOG_ERROR, L"DoConnect: Failed to SetScriptState\n");
        goto Error;
    }
    //
    // Get the dispatch inteface to the script.
    //
    TraceDo( hr = THR( m_pas->GetScriptDispatch( NULL, &m_pidm ) ) );
    if ( FAILED( hr) ) {
        (ClusResLogEvent)( m_hResource, LOG_ERROR, L"DoConnect: Failed to GetScriptDispatch\n");
        goto Error;
    }
    m_pidm = TraceInterface( L"Active Script", IDispatch, m_pidm, 1 );

    hr = S_OK;

Cleanup:
    HRETURN( hr );

Error:
    LogError( hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//////////////////////////////////////////////////////////////////////////////
//
//  void
//      CScriptResource::DoDisconnect( )
//
//  Description:
//      Disconnects from any currently connected script engine.
//
//  Arguments:
//      none.
//
//  Return Values:
//      none.
//
//////////////////////////////////////////////////////////////////////////////
void
CScriptResource::DoDisconnect( )
{
    //
    // Cleanup the scripting engine.
    //
    if ( m_pszScriptFilePath != NULL )
    {
        LocalFree( m_pszScriptFilePath );
        m_pszScriptFilePath = NULL;
    } // if: m_pszScriptFilePath

    if ( m_pszScriptEngine != NULL )
    {
        TraceFree( m_pszScriptEngine );
        m_pszScriptEngine = NULL;
    } // if: m_pszScriptEngine

    if ( m_pidm != NULL )
    {
        TraceDo( m_pidm->Release( ) );
        m_pidm = NULL;
    } // if: m_pidm

    if ( m_pasp != NULL )
    {
        TraceDo( m_pasp->Release( ) );
        m_pasp = NULL;
    } // if: m_pasp

    if ( m_pas != NULL )
    {
        TraceDo( m_pas->Close( ) );
        TraceDo( m_pas->Release( ) );
        m_pas = NULL;
    } // if: m_pas

    if ( m_pass != NULL )
    {
        TraceDo( m_pass->Release( ) );
        m_pass = NULL;
    } // if: m_pass
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\iis\iisutil.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    iisutil.c

Abstract:

    IIS Resource utility routine DLL

Author:

    Pete Benoit (v-pbenoi) 12-SEP-1996

Revision History:

--*/

#include    "iisutil.h"

DWORD IISService[] = {
      INET_HTTP,
      INET_FTP,
      INET_GOPHER
      };

#define  IIS_MNGT_DLLNAME  L"infoadmn.dll"

//
// Define some globals used to get iis management routines
//
HINSTANCE iisDLL = NULL;
typedef   NET_API_STATUS (NET_API_FUNCTION *INETINFOGETPROC)(LPWSTR,DWORD,LPINET_INFO_CONFIG_INFO *);
typedef   NET_API_STATUS (NET_API_FUNCTION *INETINFOSETPROC)(LPWSTR,DWORD,LPINET_INFO_CONFIG_INFO);
typedef   NET_API_STATUS (NET_API_FUNCTION *INETINFOFLUSHPROC)(LPWSTR,DWORD);

INETINFOGETPROC   InetInfoGet = NULL;
INETINFOSETPROC   InetInfoSet = NULL;
INETINFOFLUSHPROC InetInfoFlushMemory = NULL;


DWORD
IsIISMngtDllLoaded(
        )
/*++

Routine Description:
    Checks to see if the IIS mngt dll loaded
Arguments:


Return Value:
    ERROR_SUCCESS - Successfully loaded and found
    A Win32 error code on failure.

--*/

{
    if (iisDLL != NULL) {
        return(ERROR_SUCCESS);
    }
    return(ERROR_SERVICE_NOT_ACTIVE);
}

DWORD
IISLoadMngtDll(
        )
/*++

Routine Description:
    This routine tries to load the iis management dll. Then it attempts to
    find the procedures required to manage it.

Arguments:


Return Value:
    ERROR_SUCCESS - Successfully loaded and found
    A Win32 error code on failure.

--*/

{
    DWORD status;
    //
    // Try and load the IIS Mngt dll
    //
    iisDLL = LoadLibrary( IIS_MNGT_DLLNAME );
    if (iisDLL == NULL) {
        return(GetLastError());
    }
    //
    // Try to locate the management routines
    //
    InetInfoGet = (INETINFOGETPROC)GetProcAddress(iisDLL,"InetInfoGetAdminInformation");
    if (InetInfoGet == NULL) {
        status = GetLastError();
        goto error_exit;
    }

    InetInfoSet = (INETINFOSETPROC)GetProcAddress(iisDLL,"InetInfoSetAdminInformation");
    if (InetInfoGet == NULL) {
        status = GetLastError();
        goto error_exit;
    }

    InetInfoFlushMemory = (INETINFOFLUSHPROC)GetProcAddress(iisDLL,"InetInfoFlushMemoryCache");
    if (InetInfoFlushMemory == NULL) {
        status = GetLastError();
        goto error_exit;
    }
    return(ERROR_SUCCESS);
error_exit:
    IISUnloadMngtDll();
    return(status);

} // END IsIISInstalled

VOID
IISUnloadMngtDll(
    )

/*++

Routine Description:
    This routine frees the IIS management DLL

Arguments:


Return Value:

--*/
{
    if (iisDLL != NULL) {
        FreeLibrary( iisDLL);
    }

    iisDLL = NULL;
    InetInfoGet = NULL;
    InetInfoSet = NULL;
    InetInfoFlushMemory = NULL;
}


DWORD
GetIISInfo(
        IN  DWORD                           ServiceType,
        OUT LPINET_INFO_CONFIG_INFO         *IISInfo
        )


/*++

Routine Description:

    Get IIS information. This call returns a pointer
    to an INET_INFO_CONFIG_INFO structure

Arguments:

    ServiceType - The type of service

    IISInfo - return a pointer to an INET_INFO_CONFIG_INFO structure. This
              structure contains the virtual root information


Return Value:

    NET_API_STATUS

--*/

{
     DWORD  Status;
     if (InetInfoGet == NULL) {
         return(ERROR_SERVICE_NOT_ACTIVE);
     }
     Status=InetInfoGet(NULL,IISService[ServiceType],IISInfo);
     return(Status);

} // END GetIISInfo




DWORD
SetIISInfo(
        IN DWORD                           ServiceType,
        IN LPINET_INFO_CONFIG_INFO         IISInfo
        )

/*++

Routine Description:

    Set IIS information. This call sets inet config infor using the
    INET_INFO_CONFIG_INFO structure

Arguments:

    ServiceType - The type of service

    IISInfo - pointer to an INET_INFO_CONFIG_INFO structure. This structure
              contains the virtual root information


Return Value:

    ERROR_SUCCESS
    NET ERROR Status

--*/

{
     DWORD  Status;

     if ((InetInfoSet == NULL) || (InetInfoFlushMemory == NULL)) {
         return(ERROR_SERVICE_NOT_ACTIVE);
     }
     //
     // Only set the VirtualRoots
     //
     IISInfo->FieldControl =  FC_INET_INFO_VIRTUAL_ROOTS;

     Status=InetInfoSet(NULL,IISService[ServiceType],IISInfo);

     if (Status != ERROR_SUCCESS) {
        return(Status);
     }

     //
     // If we sucessfully set the virtual root information
     // flush the memory cache
     //
     Status = InetInfoFlushMemory(NULL,IISService[ServiceType]);

     return(Status);

} // END SetIISInfo




DWORD
OffLineVirtualRoot(
        IN LPIIS_RESOURCE   ResourceEntry,
        IN PLOG_EVENT_ROUTINE   LogEvent
        )

/*++

Routine Description:

    Take offline all Virtual Roots for this resource

Arguments:

    ResourceEntry - The resource that contains a list of virtual roots

Return Value:

    ERROR_SUCCESS
    W32 error code

--*/

{

        LPINET_INFO_CONFIG_INFO         IISInfo         = NULL;
        LPINET_INFO_VIRTUAL_ROOT_LIST   tmpVRL          = NULL;
        LPINET_INFO_VIRTUAL_ROOT_LIST   iisVRL          = NULL;
        LPINET_INFO_VIRTUAL_ROOT_ENTRY  resVR           = NULL;
        DWORD                           Status          = ERROR_SUCCESS;
        DWORD                           i,c;
        BOOLEAN                         MatchFound;
        DWORD                           MatchingEntries = 0;

    //
    // Call IIS Management API to GET list of  Virtual Roots
    //
       Status = GetIISInfo(ResourceEntry->ServiceType, &IISInfo);
       if (Status != ERROR_SUCCESS) {
           goto error_exit;
       }

    //
    // For Robustness check to see if the IIS returned SUCCESS but
    // did not return a valid address
    //
       if (IISInfo == NULL) {
           (LogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_ERROR,
               L"Error [OffLineVirtualRoots] Get IIS information returned NULL\n");
               Status = ERROR_RESOURCE_NOT_FOUND;
           goto error_exit;
       }

    //
    // Save pointer to original VirtualRoot Structure
    //
       iisVRL = IISInfo->VirtualRoots;
       resVR  = ResourceEntry->VirtualRoot;

    //
    // If the caller called terminate after open BUT before online
    // the VR field of the resource could be NULL. Return so we don't accvio
    //

       if (resVR == NULL) {
           (LogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_ERROR,
               L"Error [OffLineVirtualRoots] Resource VR information is NULL\n");
            Status = ERROR_RESOURCE_NOT_FOUND;
            goto error_exit;
       }
    //
    // This is a sanity check
    //
       if ( (resVR->pszRoot == NULL) ||
            (resVR->pszAddress == NULL) ||
            (resVR->pszDirectory == NULL) ) {
           (LogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_ERROR,
               L"Error [OffLineVirtualRoots] Resource has NULL entries for root , addr or directory\n");
           Status = ERROR_RESOURCE_NOT_FOUND;
           goto error_exit;
       }
    //
    // Allocate storage to Filter out Virtual Roots managed by the Cluster
    //
       tmpVRL = LocalAlloc(LPTR,
                           ( (iisVRL->cEntries + 1) *
                           sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY) ) +
                           sizeof(INET_INFO_VIRTUAL_ROOT_LIST));
    //
    // Check to see we got a valid address
    //

       if (tmpVRL == NULL) {
           (LogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"Error [OffLineVirtualRoots] Allocation of TMP VR failed\n");
           Status = ERROR_RESOURCE_NOT_FOUND;
           goto error_exit;
       }

    //
    // This is so ugly ...
    // 1. Enumerate and compare each IIS VR KEY with the resource VR
    // 2. Add ones that don't match to the tmpVR
    // 3. Use the tmpVR to update the IIS service and mask resources entries

       tmpVRL->cEntries = 0;
       for (i=0;i<iisVRL->cEntries ;i++ ) {
           MatchFound = FALSE;


           if ( (_wcsicmp(iisVRL->aVirtRootEntry[i].pszRoot,resVR->pszRoot)           == 0) &&
                (_wcsicmp(iisVRL->aVirtRootEntry[i].pszAddress,resVR->pszAddress)     == 0)
//                (_wcsicmp(iisVRL->aVirtRootEntry[i].pszDirectory,resVR->pszDirectory) == 0)
              ){
        // if all the VR primary keys match then skip this entry
               MatchFound       = TRUE;
               MatchingEntries  +=1;
           } // END if


           // No matching entry found in the Cluster config data so this VR is ok
           if (!MatchFound) {
               tmpVRL->aVirtRootEntry[tmpVRL->cEntries++] = iisVRL->aVirtRootEntry[i];
           } // END if !MatchFound

       } // END for i=0


    IISInfo->VirtualRoots = tmpVRL;
    //
    // Call IIS Management API to SET list of Virtual Roots
    // But only call this if we have something to remove
    //
    if (MatchingEntries > 0) {
        Status = SetIISInfo(ResourceEntry->ServiceType, IISInfo);
    }

    // Destruct any temporary storage
    IISInfo->VirtualRoots   = iisVRL;

error_exit:
    if (IISInfo != NULL) MIDL_user_free((LPVOID)IISInfo);
    if (tmpVRL != NULL)  LocalFree(tmpVRL);

    return(Status);
} //OfflineVirtualRoot



DWORD
OnLineVirtualRoot(
        IN LPIIS_RESOURCE   ResourceEntry,
        IN PLOG_EVENT_ROUTINE   LogEvent
        )

/*++

Routine Description:

    Add this resources Virtual Root to the IIS

Arguments:

    ResourceEntry - The resource that contains a list of virtual roots

Return Value:

    ERROR_SUCCESS
    W32 error code

--*/
{


    LPINET_INFO_CONFIG_INFO         IISInfo     = NULL;
    LPINET_INFO_VIRTUAL_ROOT_LIST   tmpVRL      = NULL;
    LPINET_INFO_VIRTUAL_ROOT_LIST   iisVRL      = NULL;
    LPINET_INFO_VIRTUAL_ROOT_ENTRY  resVR       = NULL;
    DWORD                           Status      = ERROR_SUCCESS;
    DWORD                           i,c;
    BOOLEAN                         MatchFound;


    // Call IIS Management API to GET list of  Virtual Roots
    Status = GetIISInfo(ResourceEntry->ServiceType, &IISInfo);
    if (Status != ERROR_SUCCESS) {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error [OnLineVirtualRoots] Get IIS information call failed status =  %1!u! \n",
            Status);
         goto error_exit;
    }

    // Save pointer to original VirtualRoot Structure
    iisVRL = IISInfo->VirtualRoots;
    resVR  = ResourceEntry->VirtualRoot;

    // Add Virtual Roots managed by the resource
    if (resVR == NULL) {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error [OnLineVirtualRoots] NULL virtual root entry \n");
        Status = ERROR_RESOURCE_NOT_FOUND;
        goto error_exit;
    }

    //
    // See if the resource is already on line. In which
    // case this is a duplicate
    //
    if ( VerifyIISService( ResourceEntry,FALSE,LogEvent ) ) {
        // We found a duplicate or this resource is already online
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Warning [OnLineThread] Resource already online or is a duplicate. Check for Unique Alias property\n");
//        Status = ERROR_DUP_NAME;
          Status = ERROR_SUCCESS;
        goto error_exit;
    }

#if DBG
    (LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[OnLineVirtualRoots] about to set info Root = %1!ws! ip = %2!ws! Dir = %3!ws! Mask = %4!u! Name = %5!ws! Pass = %6!ws! \n",
        resVR->pszRoot,
        resVR->pszAddress,
        resVR->pszDirectory,
        resVR->dwMask,
        resVR->pszAccountName,
        resVR->AccountPassword);
#endif
    // Allocate temporary storage for cluster and iis vr entries
    tmpVRL = LocalAlloc(LPTR,
                        ((iisVRL->cEntries + 1) *
                        sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY) ) +
                        sizeof(INET_INFO_VIRTUAL_ROOT_LIST));
    // Make sure we didn't fail on the allocate
    if (tmpVRL == NULL){
        (LogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[OnLineVirtualRoots] LocalAlloc for temp VRL failed\n");
         Status = ERROR_RESOURCE_NOT_FOUND;
         goto error_exit;
    }


    tmpVRL->aVirtRootEntry[0] = *resVR;


    // Add any additional VR not managed by the cluster
    for (i=0;i<iisVRL->cEntries ;i++ ) {
        tmpVRL->aVirtRootEntry[i+1] = iisVRL->aVirtRootEntry[i];
    }

    tmpVRL->cEntries = iisVRL->cEntries + 1;


    IISInfo->VirtualRoots = tmpVRL;
#if DBG
    for (i=0;i < tmpVRL->cEntries ;i++ ) {
    (LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[OnLineVirtualRoots] about to set info Root = %1!ws! Ipaddr = %2!ws! Dir = %3!ws! Mask = %4!u! Name = %5!ws! Pass = %6!ws! \n",
        tmpVRL->aVirtRootEntry[i].pszRoot,
        tmpVRL->aVirtRootEntry[i].pszAddress,
        tmpVRL->aVirtRootEntry[i].pszDirectory,
        tmpVRL->aVirtRootEntry[i].dwMask,
        tmpVRL->aVirtRootEntry[i].pszAccountName,
        tmpVRL->aVirtRootEntry[i].AccountPassword);
    }
#endif
    // Call IIS Management API to SET list of Virtual Roots
    Status = SetIISInfo(ResourceEntry->ServiceType, IISInfo);
    if (Status != ERROR_SUCCESS) {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[OnLineVirtualRoots] set info status = %1!u!\n",
            Status);
     } else {

        //
        // See if root came on line sucessfully
        //
        if ( !VerifyIISService( ResourceEntry,FALSE,LogEvent ) ) {
            //
            // The root was sucessfully added to iis but the iis could
            // not access the root. Remove it here so the inet manager does
            // not contain bad roots
            //
            OffLineVirtualRoot( ResourceEntry, LogEvent);

            (LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"ERROR [OnLineThread] IIS could not bring resource online. Verify IIS root is accessable. \n");
            Status = ERROR_RESOURCE_NOT_AVAILABLE;

        } // if !VerifyIISService

    } // if status != ERROR_SUCCESS

    // Destruct any temporary storage
    IISInfo->VirtualRoots   = iisVRL;
error_exit:
    if (IISInfo != NULL) MIDL_user_free((LPVOID)IISInfo);
    if (tmpVRL != NULL)  LocalFree(tmpVRL);

    return(Status);

}  // END OnLineVirtualRoot



VOID
FreeIISResource(
    IN LPIIS_RESOURCE   ResourceEntry
    )

/*++

Routine Description:

    Free all the storage for a IIS_RESOURCE

Arguments:

    vr - virtual root to free

Return Value:

    NONE

--*/

{
    if (ResourceEntry != NULL) {

        if (ResourceEntry->ParametersKey != NULL ) {
            ClusterRegCloseKey( ResourceEntry->ParametersKey );
        }

        if (ResourceEntry->hResource != NULL ) {
            CloseClusterResource( ResourceEntry->hResource );
        }
        LocalFree( ResourceEntry->Params.ServiceName );
        LocalFree( ResourceEntry->Params.Alias );
        LocalFree( ResourceEntry->Params.Directory );

        if (ResourceEntry->VirtualRoot != NULL) {
            DestructVR(ResourceEntry->VirtualRoot);
        }
    } // ResourceEntry != NULL

} // FreeIISResource




VOID
DestructIISResource(
    IN LPIIS_RESOURCE   ResourceEntry
    )

/*++

Routine Description:

    Free all the storage for a ResourceEntry and the ResourceEntry

Arguments:

    vr - virtual root to free

Return Value:

    NONE

--*/
{
    if (ResourceEntry != NULL) {
        FreeIISResource(ResourceEntry),
        LocalFree(ResourceEntry);
    } // ResourceEntry != NULL

} // DestructIISResource




VOID
FreeVR(
      IN  LPINET_INFO_VIRTUAL_ROOT_ENTRY vr
      )

/*++

Routine Description:

    Free all the storage for a Virtual Root

Arguments:

    vr - virtual root to free

Return Value:

    NONE

--*/


{

    if (vr == NULL) {
        return;
    }
    if (vr->pszRoot != NULL) {
        LocalFree(vr->pszRoot);
    }
    if (vr->pszAddress != NULL) {
        LocalFree(vr->pszAddress);
    }
    if (vr->pszDirectory != NULL) {
        LocalFree(vr->pszDirectory);
    }
    if (vr->pszAccountName != NULL) {
        LocalFree(vr->pszAccountName);
    }

}// FreeVR


VOID
DestructVR(
        LPINET_INFO_VIRTUAL_ROOT_ENTRY vr
        )

/*++

Routine Description:

    Free all the storage for a Virtual Root and vr

Arguments:

    vr - virtual root to free

Return Value:

    NONE

--*/


{

    if (vr == NULL) {
        return;
    }
    FreeVR(vr);
    LocalFree(vr);

}// DestructVR



BOOL
VerifyIISService(
    IN LPIIS_RESOURCE       ResourceEntry,
    IN BOOL                 IsAliveFlag,
    IN PLOG_EVENT_ROUTINE   LogEvent
    )

/*++

Routine Description:

    Verify that the IIS service is running and that it has virtual roots
    contained in the resource
    Steps:
       1.  Make sure the IIS service is running by calling the mngt API
       2.  Verfify that the resources virtual roots are currently in
           the running system
       3.  Check the dwError field to make sure the VR for the resource is accessable
       4.  Sanity check to make sure the resources virtual root was found

Arguments:

    Resource - supplies the resource id

    IsAliveFlag - says this is an IsAlive call - used only for debug print

Return Value:

    TRUE - if service is running and service contains resources virtual roots

    FALSE - service is in any other state

--*/
{
    DWORD                           status;
    DWORD                           MatchingEntries = 0;
    DWORD                           VRAccessErrors  = 0;
    BOOL                            MatchFound;
    LPINET_INFO_CONFIG_INFO         IISInfo         = NULL;
    LPINET_INFO_VIRTUAL_ROOT_ENTRY  resVR           = NULL;
    LPINET_INFO_VIRTUAL_ROOT_LIST   iisVRL          = NULL;
    DWORD                           c;
    BOOL                            VerifyStatus    = TRUE;

    //
    // Get IIS virtual root information
    //
    status = GetIISInfo(ResourceEntry->ServiceType, &IISInfo);

    //
    // Check the error status to see if the service is starting
    //
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_SERVICE_NOT_ACTIVE) {
            //
            // Service is not active
            //
            (LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"IsAlive/LooksAlive ERROR Service NOT active service %1!ws!.\n",
                ResourceEntry->Params.ServiceName );
        } else {
            //
            // Some type of error
            //
            (LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"IsAlive/LooksAlive ERROR getting information for service %1!ws! status = %2!u!\n",
                ResourceEntry->Params.ServiceName,
                status);
        }
        //
        // Return false;
        //
        VerifyStatus = FALSE;
        goto error_exit;
    }

    iisVRL  = IISInfo->VirtualRoots;
    resVR   = ResourceEntry->VirtualRoot;
    //
    // Now check to see if the Virtual roots for this resource exist in the service
    //
    MatchFound = FALSE;
    for (c=0;c<iisVRL->cEntries ;c++ ) {
        if ( (_wcsicmp(resVR->pszRoot,iisVRL->aVirtRootEntry[c].pszRoot)           == 0) &&
             (_wcsicmp(resVR->pszAddress,iisVRL->aVirtRootEntry[c].pszAddress)     == 0)
///             (_wcsicmp(resVR->pszDirectory,iisVRL->aVirtRootEntry[c].pszDirectory) == 0)
           ){
        //
        // if all the VR primary keys match
        //
            MatchFound       = TRUE;
            MatchingEntries  +=1;
        //
        // See if the IIS can sucessfully access this virtual root
        //
            if (iisVRL->aVirtRootEntry[c].dwError != ERROR_SUCCESS) {
                VRAccessErrors +=1;
                (LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"IsAlive/LooksAlive virtual root %1!ws! IIS Access Error service %2!ws! error = %3!u!\n",
                    resVR->pszRoot,
                    ResourceEntry->Params.ServiceName,
                    iisVRL->aVirtRootEntry[c].dwError);

             } // END dwERROR != ERROR_SUCCESS

             break;

        } // END if

    } // END for c=0

    // No matching entry found in the Cluster config data so this VR is ok
    if (!MatchFound) {
        if (IsAliveFlag) {
            (LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"ERROR IsAlive/LooksAlive virtual root %1!ws! not found for service %2!ws!\n",
                resVR->pszRoot,
                ResourceEntry->Params.ServiceName,
                status);
        }
        VerifyStatus = FALSE;
        goto error_exit;
    } // END if !MatchFound


    //
    // Perform  sanity check
    //
    if (MatchingEntries != 1) {
        (LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ERROR IsAlive/LooksAlive more than one resource is active, service %1!ws!\n",
            ResourceEntry->Params.ServiceName);
        VerifyStatus = FALSE;
        goto error_exit;
    }


    //
    // If the resources virtual root is inaccessable then the resource is offline
    //
    if (VRAccessErrors != 0) {
        VerifyStatus = FALSE;
    }

error_exit:
    if (IISInfo != NULL) MIDL_user_free((LPVOID)IISInfo);
    return(VerifyStatus);

} // VerifyIISService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\iis\iisutil.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    iisutil.h

Abstract:

    IIS Resource utility routine DLL

Author:

    Pete Benoit (v-pbenoi) 12-SEP-1996

Revision History:

--*/

#ifndef IISUTIL_H
#define IISUTIL_H


#define     UNICODE             1

#include    "clusres.h"
#include    "wtypes.h"
#include    "inetinfo.h"

#define IISLogEvent ClusResLogEvent
#define IISSetResourceStatus ClusResSetResourceStatus

// Define the Service Identifiers
#define WWW_SERVICE     0
#define FTP_SERVICE     1
#define GOPHER_SERVICE  2
#define MAX_SERVICE     GOPHER_SERVICE + 1

//
// Define the resource Name
//
#define IIS_RESOURCE_NAME           L"IIS Virtual Root"

// Define some max values
#define MAX_LENGTH_VIRTUAL_ROOT     256         // Length of VR
#define MAX_LENGTH_ROOT_ADDR        80          // Address Length
#define MAX_VIRTUAL_ROOT            200         // Max number of VR's
#define MAX_INET_SERVER_START_DELAY 1000        // 1 Seconds
#define SERVER_START_DELAY          500         // 500ms
#define MAX_DEFAULT_WSTRING_SIZE    512         // Default string size
#define MAX_IIS_RESOURCES           20          // Total number of IIS resources
#define MAX_OPEN_RETRY              30          // 30 Retries (15 sec)
#define MAX_ONLINE_RETRY            60          // 60         (30 sec)
#define MAX_MUTEX_WAIT              10*1000     // 10 seconds
#define IP_ADDRESS_RESOURCE_NAME    L"IP Address"

// Define parameters structure
typedef struct _IIS_PARAMS {
    LPWSTR          ServiceName;
    LPWSTR          Alias;
    LPWSTR          Directory;
    DWORD           AccessMask;
//BUGBUG
// Remove AccountName Password for UNC physical directories
// for the first release
/*
    LPWSTR          AccountName;
    LPWSTR          Password;
*/
} IIS_PARAMS, *PIIS_PARAMS;

// Define the resource data structure
typedef struct _IIS_RESOURCE {
    DWORD                           Index;
    LPWSTR                          ResourceName;
    IIS_PARAMS                      Params;
//    LPWSTR                          ServiceName;
    DWORD                           ServiceType;
    RESOURCE_HANDLE                 ResourceHandle;
    HKEY                            ParametersKey;
    LPINET_INFO_VIRTUAL_ROOT_ENTRY  VirtualRoot;
    CLUS_WORKER                     OnlineThread;
    CLUS_WORKER                     OpenThread;
    CLUSTER_RESOURCE_STATE          State;
    HRESOURCE                       hResource;
} IIS_RESOURCE, *LPIIS_RESOURCE;



DWORD
OffLineVirtualRoot(
        IN LPIIS_RESOURCE   ResourceEntry,
        IN PLOG_EVENT_ROUTINE   LogEvent
        );

DWORD
OnLineVirtualRoot(
        IN LPIIS_RESOURCE   ResourceEntry,
        IN PLOG_EVENT_ROUTINE   LogEvent
        );

VOID
DestructVR(
        IN LPINET_INFO_VIRTUAL_ROOT_ENTRY vr
        );

VOID
DestructIISResource(
        IN LPIIS_RESOURCE   ResourceEntry
        );


VOID
FreeVR(
        IN LPINET_INFO_VIRTUAL_ROOT_ENTRY vr
        );

VOID
FreeIISResource(
        IN LPIIS_RESOURCE   ResourceEntry
        );



BOOL
VerifyIISService(
    IN LPIIS_RESOURCE       ResourceEntry,
    IN BOOL                 IsAliveFlag,
    IN PLOG_EVENT_ROUTINE   LogEvent
    );


DWORD
IISLoadMngtDll(
    );
DWORD
IsIISMngtDllLoaded(
   );

VOID
IISUnloadMngtDll(
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\inc\clusres.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    clusres.h

Abstract:

    Common Resource DLL Header

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "clusudef.h"
#include "clusapi.h"
#include "resapi.h"
#include "clusvmsg.h"


#define LOCAL_SERVICES  L"System\\CurrentControlSet\\Services"

#ifdef __cplusplus
extern "C" {
#endif

extern PLOG_EVENT_ROUTINE ClusResLogEvent;
extern PSET_RESOURCE_STATUS_ROUTINE ClusResSetResourceStatus;

//
// Cluster Resource Specific routines
//

DWORD
ClusResOpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    );

NTSTATUS
ClusResDoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    );


//
// Helpful macros for logging cluster service events
//
VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusResLogEventWithName1(
    IN HKEY hResourceKey,
    IN