//
    // Failed
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateNestedDirectory:  Failed to create the directory with error %d."), GetLastError()));

    return 0;

}

//*************************************************************
//
//  GetProfilesDirectory()
//
//  Purpose:    Returns the location of the "profiles" directory
//
//  Parameters: lpProfilesDir   -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              9/18/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetProfilesDirectory(LPTSTR lpProfilesDir, LPDWORD lpcchSize)
{
    return GetProfilesDirectoryEx (lpProfilesDir, lpcchSize, TRUE);
}


//*************************************************************
//
//  GetProfilesDirectoryEx()
//
//  Purpose:    Returns the location of the "profiles" directory
//
//  Parameters: lpProfilesDir   -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//              bExpand         -   Expand directory name
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/15/97    ericflo    Created
//
//*************************************************************

BOOL GetProfilesDirectoryEx(LPTSTR lpProfilesDir, LPDWORD lpcchSize, BOOL bExpand)
{
    TCHAR  szDirectory[MAX_PATH];
    TCHAR  szTemp[MAX_PATH];
    DWORD  dwLength;
    HKEY   hKey = INVALID_HANDLE_VALUE;
    LONG   lResult;
    DWORD  dwSize, dwType;
    BOOL   bRetVal = FALSE;


    //
    // Arg check
    //

    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    szDirectory[0] = TEXT('\0');
    szTemp[0] = TEXT('\0');

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH, 0, KEY_READ,
                            &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(szTemp);

        lResult = RegQueryValueEx (hKey, PROFILES_DIRECTORY, NULL, &dwType,
                                   (LPBYTE) szTemp, &dwSize);

        if (lResult == ERROR_SUCCESS) {

            if ((dwType == REG_EXPAND_SZ) || (dwType == REG_SZ)) {

                if (bExpand && (dwType == REG_EXPAND_SZ)) {
                    if((dwLength = ExpandEnvironmentStrings(szTemp, szDirectory, MAX_PATH)) == 0) {
                        goto Exit;
                    }
                    else if(dwLength > MAX_PATH) {
                        SetLastError(ERROR_BAD_PATHNAME);
                        goto Exit;
                    }
                } else {
                    lstrcpy (szDirectory, szTemp);
                }
            }
        }

        RegCloseKey (hKey);
        hKey = INVALID_HANDLE_VALUE;
    }


    if (szDirectory[0] == TEXT('\0')) {

        LoadString (g_hDllInstance, IDS_PROFILES_ROOT, szTemp, ARRAYSIZE(szTemp));

        if (bExpand) {
            if((dwLength = ExpandEnvironmentStrings(szTemp, szDirectory, MAX_PATH)) == 0) {
                goto Exit;
            }
            else if(dwLength > MAX_PATH) {
                SetLastError(ERROR_BAD_PATHNAME);
                goto Exit;
            }
        } else {
            lstrcpy (szDirectory, szTemp);
        }
    }


    dwLength = lstrlen(szDirectory) + 1;

    if (lpProfilesDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfilesDir, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

Exit:

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    return bRetVal;
}

//*************************************************************
//
//  GetDefaultUserProfileDirectory()
//
//  Purpose:    Returns the location of the Default User's profile
//
//  Parameters: lpProfileDir    -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/8/97     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetDefaultUserProfileDirectory(LPTSTR lpProfileDir, LPDWORD lpcchSize)
{
    return  GetDefaultUserProfileDirectoryEx(lpProfileDir, lpcchSize, TRUE);
}

//*************************************************************
//
//  GetDefaultUserProfileDirectoryEx()
//
//  Purpose:    Returns the location of the Default User's profile
//
//  Parameters: lpProfileDir    -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//              bExpand         -   Expand the path or not
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/8/97     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetDefaultUserProfileDirectoryEx(LPTSTR lpProfileDir,
                                             LPDWORD lpcchSize, BOOL bExpand)
{
    TCHAR  szDirectory[MAX_PATH];
    TCHAR  szProfileName[100];
    LPTSTR lpEnd;
    DWORD  dwSize, dwLength, dwType;
    BOOL   bRetVal = FALSE;
    LONG   lResult;
    HKEY   hKey;


    //
    // Arg check
    //

    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Get the profiles root
    //

    szDirectory[0] = TEXT('\0');
    dwSize = ARRAYSIZE(szDirectory);

    if (!GetProfilesDirectoryEx(szDirectory, &dwSize, bExpand)) {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectory:  Failed to get profiles root.")));
        *lpcchSize = 0;
        return FALSE;
    }


    //
    // Query for the Default User profile name
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectoryEx:  Failed to open profile list key with %d."),
                 lResult));
        SetLastError(lResult);
        return FALSE;
    }

    dwSize = sizeof(szProfileName);
    lResult = RegQueryValueEx (hKey, DEFAULT_USER_PROFILE, NULL, &dwType,
                               (LPBYTE) szProfileName, &dwSize);

    if (lResult != ERROR_SUCCESS) {
        lstrcpy (szProfileName, DEFAULT_USER);
    }

    RegCloseKey (hKey);


    //
    // Put them together
    //

    lpEnd = CheckSlash (szDirectory);
    lstrcpy (lpEnd, szProfileName);


    //
    // Save the result if possible
    dwLength = lstrlen(szDirectory) + 1;

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfileDir, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }

    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}

//*************************************************************
//
//  GetAllUsersProfileDirectory()
//
//  Purpose:    Returns the location of the All Users profile
//
//  Parameters: lpProfileDir    -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/8/97     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetAllUsersProfileDirectory(LPTSTR lpProfileDir, LPDWORD lpcchSize)
{
    return  GetAllUsersProfileDirectoryEx(lpProfileDir, lpcchSize, TRUE);
}

//*************************************************************
//
//  GetAllUsersProfileDirectoryEx()
//
//  Purpose:    Returns the location of the All Users profile
//
//  Parameters: lpProfileDir    -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//              bExpand         -   Expand the path or not
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/8/97     ericflo    Created
//
//*************************************************************

BOOL GetAllUsersProfileDirectoryEx (LPTSTR lpProfileDir,
                                    LPDWORD lpcchSize, BOOL bExpand)
{
    TCHAR  szDirectory[MAX_PATH];
    TCHAR  szProfileName[100];
    LPTSTR lpEnd;
    DWORD  dwSize, dwLength, dwType;
    BOOL   bRetVal = FALSE;
    LONG   lResult;
    HKEY   hKey;



    //
    // Arg check
    //

    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Get the profiles root
    //

    szDirectory[0] = TEXT('\0');
    dwSize = ARRAYSIZE(szDirectory);

    if (!GetProfilesDirectoryEx(szDirectory, &dwSize, bExpand)) {
        DebugMsg((DM_WARNING, TEXT("GetAllUsersProfileDirectoryEx:  Failed to get profiles root.")));
        *lpcchSize = 0;
        return FALSE;
    }


    //
    // Query for the All Users profile name
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetAllUsersProfileDirectoryEx:  Failed to open profile list key with %d."),
                 lResult));
        SetLastError(lResult);
        return FALSE;
    }

    dwSize = sizeof(szProfileName);
    lResult = RegQueryValueEx (hKey, ALL_USERS_PROFILE, NULL, &dwType,
                               (LPBYTE) szProfileName, &dwSize);

    if (lResult != ERROR_SUCCESS) {
        lstrcpy(szProfileName, ALL_USERS);
    }

    RegCloseKey (hKey);


    //
    // Put them together
    //

    lpEnd = CheckSlash (szDirectory);
    lstrcpy (lpEnd, szProfileName);


    //
    // Save the result if possible
    dwLength = lstrlen(szDirectory) + 1;

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfileDir, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}

//*************************************************************
//
//  GetUserProfileDirectory()
//
//  Purpose:    Returns the root of the user's profile directory.
//
//  Parameters: hToken          -   User's token
//              lpProfileDir    -   Output buffer
//              lpcchSize       -   Size of output buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              9/18/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetUserProfileDirectory(HANDLE hToken, LPTSTR lpProfileDir,
                                    LPDWORD lpcchSize)
{
    DWORD  dwLength = MAX_PATH * sizeof(TCHAR);
    DWORD  dwType;
    BOOL   bRetVal = FALSE;
    LPTSTR lpSidString;
    TCHAR  szBuffer[MAX_PATH];
    TCHAR  szDirectory[MAX_PATH];
    HKEY   hKey;
    LONG   lResult;


    //
    // Parameter check
    //

    if (!hToken) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }


    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Retrieve the user's sid string
    //

    lpSidString = GetSidString(hToken);

    if (!lpSidString) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, lpSidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                           &hKey);

    if (lResult != ERROR_SUCCESS) {
        DeleteSidString(lpSidString);
        SetLastError(lResult);
        return FALSE;
    }

    lResult = RegQueryValueEx(hKey,
                              PROFILE_IMAGE_VALUE_NAME,
                              NULL,
                              &dwType,
                              (LPBYTE) szBuffer,
                              &dwLength);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        DeleteSidString(lpSidString);
        SetLastError(lResult);
        return FALSE;
    }


    //
    // Clean up
    //

    RegCloseKey(hKey);
    DeleteSidString(lpSidString);



    //
    // Expand and get the length of string
    //

    ExpandEnvironmentStrings(szBuffer, szDirectory, MAX_PATH);

    dwLength = lstrlen(szDirectory) + 1;


    //
    // Save the string if appropriate
    //

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfileDir, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}


//*************************************************************
//
//  GetUserProfileDirFromSid()
//
//  Purpose:    Returns the root of the user's profile directory.
//
//  Parameters: pSid            -   User's SID
//              lpProfileDir    -   Output buffer
//              lpcchSize       -   Size of output buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              03/08/01    santanuc   Created
//
//*************************************************************

BOOL WINAPI GetUserProfileDirFromSid(PSID pSid, LPTSTR lpProfileDir,
                                     LPDWORD lpcchSize)
{
    DWORD  dwLength = MAX_PATH * sizeof(TCHAR);
    DWORD  dwType;
    BOOL   bRetVal = FALSE;
    UNICODE_STRING UnicodeString;
    TCHAR  szBuffer[MAX_PATH];
    TCHAR  szDirectory[MAX_PATH];
    HKEY   hKey;
    LONG   lResult;
    NTSTATUS NtStatus;


    //
    // Parameter check
    //

    if (!pSid) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }


    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Retrieve the user's sid string
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            pSid,
                            (BOOLEAN)TRUE  // Allocate memory
                            );
    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        SetLastError(NtStatus);
        DebugMsg((DM_WARNING, TEXT("GetUserProfileDirFromSid: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return FALSE;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, UnicodeString.Buffer);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                           &hKey);

    if (lResult != ERROR_SUCCESS) {
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(lResult);
        return FALSE;
    }

    lResult = RegQueryValueEx(hKey,
                              PROFILE_IMAGE_VALUE_NAME,
                              NULL,
                              &dwType,
                              (LPBYTE) szBuffer,
                              &dwLength);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(lResult);
        return FALSE;
    }


    //
    // Clean up
    //

    RegCloseKey(hKey);
    RtlFreeUnicodeString(&UnicodeString);



    //
    // Expand and get the length of string
    //

    ExpandEnvironmentStrings(szBuffer, szDirectory, MAX_PATH);

    dwLength = lstrlen(szDirectory) + 1;


    //
    // Save the string if appropriate
    //

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfileDir, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}


//*************************************************************
//
//  GetUserAppDataPath()
//
//  Purpose:    Returns the path for user's Appdata.
//
//  Parameters: hToken          -   User's token
//              lpFolderPath    -   Output buffer
//
//  Return:     ERROR_SUCCESS if successful
//              otherwise the error code
//
//  Comments:   If error occurs then lpFolderPath set to empty.
//              Used by Crypto guys to avoid calling SHGetFolderPath.
//
//  History:    Date        Author     Comment
//
//*************************************************************
DWORD WINAPI GetUserAppDataPath(HANDLE hToken, LPTSTR lpFolderPath)
{
    DWORD  dwSize, dwType;
    LPTSTR lpSidString = NULL;
    DWORD  dwError = ERROR_SUCCESS;
    HKEY   hKey = NULL;
    TCHAR  szBuffer[MAX_PATH];


    //
    // Parameter check
    //

    if (!hToken) {
        dwError = ERROR_INVALID_HANDLE;
        goto Exit;
    }


    if (!lpFolderPath) {
        dwError = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    else {
        *lpFolderPath = TEXT('\0');
    }


    //
    // Retrieve the user's sid string
    //

    lpSidString = GetSidString(hToken);

    if (!lpSidString) {
        dwError = ERROR_INVALID_HANDLE;
        goto Exit;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, lpSidString);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, USER_SHELL_FOLDERS);

    dwError = RegOpenKeyEx(HKEY_USERS, szBuffer, 0, KEY_READ, &hKey);
    if (dwError != ERROR_SUCCESS) {
        goto Exit;
    }

    dwSize = MAX_PATH * sizeof(TCHAR);
    dwError = RegQueryValueEx(hKey,
                              TEXT("AppData"),
                              NULL,
                              &dwType,
                              (LPBYTE) szBuffer,
                              &dwSize);

    if (ERROR_SUCCESS == dwError) {

        dwSize = MAX_PATH;
        if (!ExpandEnvironmentStringsForUser(hToken, szBuffer, lpFolderPath, dwSize)) {
            dwError = GetLastError();
        }
    }
                    

Exit:

    //
    // Clean up
    //

    if (lpSidString) {
        DeleteSidString(lpSidString);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    SetLastError(dwError);
    return dwError;
}


//*************************************************************
//
//  StringToInt()
//
//  Purpose:    Converts a string to an integer
//
//  Parameters: lpNum   -   Number to convert
//
//  Return:     The number
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

int StringToInt(LPTSTR lpNum)
{
  int i = 0;
  BOOL bNeg = FALSE;

  if (*lpNum == TEXT('-')) {
      bNeg = TRUE;
      lpNum++;
  }

  while (*lpNum >= TEXT('0') && *lpNum <= TEXT('9')) {
      i *= 10;
      i += (int)(*lpNum-TEXT('0'));
      lpNum++;
  }

  if (bNeg) {
      i *= -1;
  }

  return(i);
}

//*************************************************************
//
//  HexStringToInt()
//
//  Purpose:    Converts a hex string to an integer, stops
//              on first invalid character
//
//  Parameters: lpNum   -   Number to convert
//
//  Return:     The number
//
//  Comments:   Originally for use in "ExtractCSIDL" tested
//              exclusively with 0x0000 numbers format
//
//  History:    Date        Author     Comment
//              6/9/98      stephstm   Created
//
//*************************************************************

unsigned int HexStringToUInt(LPCTSTR lpcNum)
{
  unsigned int i = 0;

  while (1)
  {
      if(*lpcNum != TEXT('x') && *lpcNum != TEXT('X') )
      {
          if(*lpcNum >= TEXT('0') && *lpcNum <= TEXT('9'))
          {
              i *= 16;
              i += (unsigned int)(*lpcNum-TEXT('0'));
          }
          else
          {
              if(*lpcNum >= TEXT('a') && *lpcNum <= TEXT('f'))
              {
                  i *= 16;
                  i += (unsigned int)(*lpcNum-TEXT('a')) + 10;
              }
              else
              {
                  if(*lpcNum >= TEXT('A') && *lpcNum <= TEXT('F'))
                  {
                      i *= 16;
                      i += (unsigned int)(*lpcNum-TEXT('A')) + 10;
                  }
                  else
                      break;
              }
          }
      }
      lpcNum++;
  }

  return(i);
}

//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    LPTSTR lpEnd;
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }


    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        if (lResult == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } else {
            return FALSE;
        }
    }


    lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            lstrcpy (lpEnd, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    TCHAR szDelKey[2 * MAX_PATH];

    lstrcpy (szDelKey, lpSubKey);
    return RegDelnodeRecurse(hKeyRoot, szDelKey);
}


//*************************************************************
//
//  RegRenameKey()
//
//  Purpose:    Renames a registry key
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey1    -   SubKey to rename from
//              lpSubKey2   -   SubKey to rename to
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              20/9/99     ushaji     created
//Currently this just renames keys without any subkeys underneath it

//*************************************************************

LONG RegRenameKey(HKEY hKeyRoot, LPTSTR lpSrcKey, LPTSTR lpDestKey)
{
    HKEY   hSrcKey=NULL, hDestKey=NULL;
    LONG   lResult;
    DWORD  dwDisposition;
    DWORD  dwValues, dwMaxValueNameLen;
    DWORD  dwMaxValueLen, dwType;
    DWORD  dwMaxValueNameLenLocal, dwMaxValueLenLocal, i, dwSDSize;
    LPTSTR lpValueName=NULL;
    LPBYTE lpData=NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;


    lResult = RegOpenKeyEx(hKeyRoot, lpSrcKey, 0, KEY_ALL_ACCESS, &hSrcKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot open src key %s with error %d"), lpSrcKey, lResult));
        goto Exit;
    }


    RegDelnode(hKeyRoot, lpDestKey);


    lResult = RegQueryInfoKey(hSrcKey, NULL, NULL, NULL, NULL, NULL, NULL,
                              &dwValues, &dwMaxValueNameLen, &dwMaxValueLen,
                              &dwSDSize, NULL);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot query dest key %s with error %d"), lpDestKey, lResult));
        goto Exit;
    }

    pSD = LocalAlloc(LPTR, sizeof(BYTE)*dwSDSize);

    if (!pSD) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory error %d"), lpDestKey, GetLastError()));
        lResult = GetLastError();
        goto Exit;
    }


    lResult = RegGetKeySecurity(hSrcKey, DACL_SECURITY_INFORMATION, pSD, &dwSDSize);


    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot get sd with error %d"), lpDestKey, lResult));
        goto Exit;
    }


    lResult = RegCreateKeyEx(hKeyRoot, lpDestKey, 0, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hDestKey,
                             &dwDisposition);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot open dest key %s with error %d"), lpDestKey, lResult));
        goto Exit;
    }


    lResult = RegSetKeySecurity(hDestKey, DACL_SECURITY_INFORMATION, pSD);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot get sd with error %d"), lpDestKey, lResult));
        goto Exit;
    }



    lpValueName = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*(dwMaxValueNameLen+1));

    if (!lpValueName) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory for valuename")));
        lResult = GetLastError();
        goto Exit;
    }

    lpData = (LPBYTE) LocalAlloc(LPTR, sizeof(BYTE)*dwMaxValueLen);

    if (!lpData) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory for lpData")));
        lResult = GetLastError();
        goto Exit;
    }


    for (i = 0; i < dwValues; i++) {

        dwMaxValueNameLenLocal = dwMaxValueNameLen+1;
        dwMaxValueLenLocal = dwMaxValueLen;


        lResult = RegEnumValue(hSrcKey, i, lpValueName, &dwMaxValueNameLenLocal, NULL, &dwType, lpData, &dwMaxValueLenLocal);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot enum src key value %s with error %d"), lResult));
            goto Exit;
        }


        lResult = RegSetValueEx(hDestKey, lpValueName, 0, dwType, lpData, dwMaxValueLenLocal);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot set dest value %s with error %d"), lpValueName, lResult));
            goto Exit;
        }
    }


Exit:

    if (hSrcKey)
        RegCloseKey(hSrcKey);

    if (hDestKey)
        RegCloseKey(hDestKey);

    if (lpData)
        LocalFree(lpData);

    if (lpValueName)
        LocalFree(lpValueName);

    if (pSD)
        LocalFree(pSD);

    if (lResult == ERROR_SUCCESS)
        lResult = RegDeleteKey(hKeyRoot, lpSrcKey);
    else
        RegDeleteKey(hKeyRoot, lpDestKey);

    return lResult;
}



//*************************************************************
//
//  CreateSecureAdminDirectory()
//
//  Purpose:    Creates a secure directory that only the Administrator
//              and system have access to.
//
//  Parameters: lpDirectory -   Directory Name
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/20/95     ericflo    Created
//
//*************************************************************

BOOL CreateSecureAdminDirectory (LPTSTR lpDirectory, DWORD dwOtherSids)
{

    //
    // Attempt to create the directory
    //

    if (!CreateNestedDirectory(lpDirectory, NULL)) {
        return FALSE;
    }


    //
    // Set the security
    //

    if (!MakeFileSecure (lpDirectory, dwOtherSids)) {
        RemoveDirectory(lpDirectory);
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  DeleteAllValues ()
//
//  Purpose:    Deletes all values under specified key
//
//  Parameters: hKey    -   Key to delete values from
//
//  Return:
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/14/95     ericflo    Ported
//
//*************************************************************

BOOL DeleteAllValues(HKEY hKey)
{
    TCHAR ValueName[MAX_PATH+1];
    DWORD dwSize = MAX_PATH+1;
    LONG lResult;

    while (RegEnumValue(hKey, 0, ValueName, &dwSize,
            NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            lResult = RegDeleteValue(hKey, ValueName);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("DeleteAllValues:  Failed to delete value <%s> with %d."), ValueName, lResult));
                return FALSE;
            } else {
                DebugMsg((DM_VERBOSE, TEXT("DeleteAllValues:  Deleted <%s>"), ValueName));
            }


            dwSize = MAX_PATH+1;
    }
    return TRUE;
}

//*************************************************************
//
//  MakeFileSecure()
//
//  Purpose:    Sets the attributes on the file so only Administrators
//              and the OS can delete it.  Authenticated Users have read
//              permission only.
//
//  Parameters: lpFile  -   File to set security on
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/6/95     ericflo    Created
//              2/16/99     ushaji      Added everyone, pweruser
//
//*************************************************************

BOOL MakeFileSecure (LPTSTR lpFile, DWORD dwOtherSids)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidUsers = NULL, psidPowerUsers = NULL;
    PSID  psidEveryOne = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bAddPowerUsersAce=TRUE;
    BOOL bAddEveryOneAce=FALSE;
    DWORD dwAccMask;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the users sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0, 0, 0, 0, 0, 0, &psidUsers)) {

         DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize authenticated users sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin))  +
            (2 * GetLengthSid (psidUsers))  +
            sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    //
    // Get the power users sid, if required.
    // Don't fail if you don't get because it might not be available on DCs??
    //

    bAddPowerUsersAce = TRUE;
    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_POWER_USERS, 0, 0, 0, 0, 0, 0, &psidPowerUsers)) {

        DebugMsg((DM_WARNING, TEXT("AddPowerUserAce: Failed to initialize power users sid.  Error = %d"), GetLastError()));
        bAddPowerUsersAce = FALSE;
    }

    if (bAddPowerUsersAce)
        cbAcl += (2 * GetLengthSid (psidPowerUsers)) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    //
    // Get the EveryOne sid, if required.
    //

    if (dwOtherSids & OTHERSIDS_EVERYONE) {
        bAddEveryOneAce = TRUE;
        if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryOne)) {

            DebugMsg((DM_WARNING, TEXT("AddPowerUserAce: Failed to initialize power users sid.  Error = %d"), GetLastError()));
            goto Exit;
        }
    }

    if (bAddEveryOneAce)
        cbAcl += (2 * GetLengthSid (psidEveryOne)) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidUsers)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    if (bAddPowerUsersAce) {

        //
        // By default give read permissions, otherwise give modify permissions
        //

        dwAccMask = (dwOtherSids & OTHERSIDS_POWERUSERS) ? (FILE_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER)):
                                                           (GENERIC_READ | GENERIC_EXECUTE);

        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccMask, psidPowerUsers)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }
    }

    if (bAddEveryOneAce) {
        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidEveryOne)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidUsers)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    if (bAddPowerUsersAce) {
        aceIndex++;
        dwAccMask = (dwOtherSids & OTHERSIDS_POWERUSERS) ? (FILE_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER)):
                                                           (GENERIC_READ | GENERIC_EXECUTE);

        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccMask, psidPowerUsers)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }

        if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }

        lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    }

    if (bAddEveryOneAce) {
        aceIndex++;

        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidEveryOne)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }

        if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }

        lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Set the security
    //

    if (SetFileSecurity (lpFile, DACL_SECURITY_INFORMATION, &sd)) {
        bRetVal = TRUE;
    } else {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: SetFileSecurity failed.  Error = %d"), GetLastError()));
    }



Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }


    if (psidUsers) {
        FreeSid(psidUsers);
    }

    if ((bAddPowerUsersAce) && (psidPowerUsers)) {
        FreeSid(psidPowerUsers);
    }

    if ((bAddEveryOneAce) && (psidEveryOne)) {
        FreeSid(psidEveryOne);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}


//*************************************************************
//
//  GetSpecialFolderPath()
//
//  Purpose:    Gets the path to the requested special folder
//
//  Parameters: csid   - CSIDL of the special folder
//              lpPath - Path to place result in
//                       assumed to be MAX_PATH in size
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetSpecialFolderPath (INT csidl, LPTSTR lpPath)
{
    BOOL bResult = FALSE;
    PSHELL32_API pShell32Api;

    if (ERROR_SUCCESS == LoadShell32Api( &pShell32Api )) {
        //
        // Ask the shell for the folder location
        //

        bResult = pShell32Api->pfnShGetSpecialFolderPath (NULL, lpPath, csidl, TRUE);
    }

    return bResult;
}


//*************************************************************
//
//  GetFolderPath()
//
//  Purpose:    Gets the path to the requested special folder
//
//  Parameters: csidl   - CSIDL of the special folder
//              lpPath - Path to place result in
//                       assumed to be MAX_PATH in size
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************
BOOL GetFolderPath (INT csidl, HANDLE hToken, LPTSTR lpPath)
{
    BOOL bResult = FALSE;
    PSHELL32_API pShell32Api;

    if (ERROR_SUCCESS == LoadShell32Api( &pShell32Api )) {
        //
        // Ask the shell for the folder location
        //
        HRESULT hr;

        hr = pShell32Api->pfnShGetFolderPath (NULL,
                                 csidl | CSIDL_FLAG_CREATE,
                                 hToken,
                                 0,
                                 lpPath);

        bResult = SUCCEEDED ( hr );
    }

    return bResult;
}


//*************************************************************
//
//  SetFolderPath()
//
//  Purpose:    Sets the path to the requested special folder
//
//  Parameters: csidl   - CSIDL of the special folder
//              lpPath - Path
//                       assumed to be MAX_PATH in size
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************
BOOL SetFolderPath (INT csidl, HANDLE hToken, LPTSTR lpPath)
{
    BOOL bResult = FALSE;
    PSHELL32_API pShell32Api;

    if (ERROR_SUCCESS == LoadShell32Api( &pShell32Api )) {
        //
        // Set the shell folder location
        //
        HRESULT hr;

        hr = pShell32Api->pfnShSetFolderPath (
                                 csidl | CSIDL_FLAG_DONT_UNEXPAND,
                                 hToken,
                                 0,
                                 lpPath);

        bResult = SUCCEEDED ( hr );
    }

    return bResult;
}


//*************************************************************
//
//  CenterWindow()
//
//  Purpose:    Centers a window on the screen
//
//  Parameters: hwnd    -   window handle to center
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/21/96     ericflo    Ported
//
//*************************************************************

void CenterWindow (HWND hwnd)
{
    RECT    rect;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    // Get window rect
    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    // Get parent rect
    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        // Return the desktop windows size (size of main screen)
        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        HWND    hwndParent;
        RECT    rectParent;

        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }

        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    // Centre the child in the parent
    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;

    // Move the child into position
    SetWindowPos(hwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);
}

//*************************************************************
//
//  UnExpandSysRoot()
//
//  Purpose:    Unexpands the given path/filename to have %systemroot%
//              if appropriate
//
//  Parameters: lpFile   -  File to check
//              lpResult -  Result buffer (MAX_PATH chars in size)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/23/96     ericflo    Created
//
//*************************************************************

BOOL UnExpandSysRoot(LPCTSTR lpFile, LPTSTR lpResult)
{
    TCHAR szSysRoot[MAX_PATH];
    LPTSTR lpFileName;
    DWORD dwSysLen;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("UnExpandSysRoot: Entering with <%s>"),
             lpFile ? lpFile : TEXT("NULL")));


    if (!lpFile || !*lpFile) {
        DebugMsg((DM_VERBOSE, TEXT("UnExpandSysRoot: lpFile is NULL, setting lpResult to a null string")));
        *lpResult = TEXT('\0');
        return TRUE;
    }


    //
    // If the first part of lpFile is the expanded value of %SystemRoot%
    // then we want to un-expand the environment variable.
    //

    if (!ExpandEnvironmentStrings (TEXT("%SystemRoot%"), szSysRoot, MAX_PATH)) {
        DebugMsg((DM_VERBOSE, TEXT("UnExpandSysRoot: ExpandEnvironmentString failed with error %d, setting szSysRoot to %systemroot% "), GetLastError()));
        lstrcpy(lpResult, lpFile);
        return FALSE;
    }

    dwSysLen = lstrlen(szSysRoot);


    //
    // Make sure the source is long enough
    //

    if ((DWORD)lstrlen(lpFile) < dwSysLen) {
        lstrcpy (lpResult, lpFile);
        return TRUE;
    }


    if (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                       szSysRoot, dwSysLen,
                       lpFile, dwSysLen) == CSTR_EQUAL) {

        //
        // The szReturn buffer starts with %systemroot%.
        // Actually insert %systemroot% in the result buffer.
        //

        lstrcpy (lpResult, TEXT("%SystemRoot%"));
        lstrcat (lpResult, (lpFile + dwSysLen));


    } else {

        //
        // The szReturn buffer does not start with %systemroot%
        // just copy in the original string.
        //

        lstrcpy (lpResult, lpFile);
    }


    DebugMsg((DM_VERBOSE, TEXT("UnExpandSysRoot: Leaving with <%s>"), lpResult));

    return TRUE;
}

//*************************************************************
//
//  AllocAndExpandEnvironmentStrings()
//
//  Purpose:    Allocates memory for and returns pointer to buffer containing
//              the passed string expanded.
//
//  Parameters: lpszSrc -   unexpanded string
//
//  Return:     Pointer to expanded string
//              NULL if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

LPTSTR AllocAndExpandEnvironmentStrings(LPCTSTR lpszSrc)
{
    LPTSTR String, Temp;
    LONG LengthAllocated;
    LONG LengthCopied;

    //
    // Pick a random buffer length, if it's not big enough reallocate
    // it and try again until it is.
    //

    LengthAllocated = lstrlen(lpszSrc) + 60;

    String = LocalAlloc(LPTR, LengthAllocated * sizeof(TCHAR));
    if (String == NULL) {
        DebugMsg((DM_WARNING, TEXT("AllocAndExpandEnvironmentStrings: Failed to allocate %d bytes for string"), LengthAllocated * sizeof(TCHAR)));
        return(NULL);
    }

    while (TRUE) {

        LengthCopied = ExpandEnvironmentStrings( lpszSrc,
                                                 String,
                                                 LengthAllocated
                                               );
        if (LengthCopied == 0) {
            DebugMsg((DM_WARNING, TEXT("AllocAndExpandEnvironmentStrings: ExpandEnvironmentStrings failed, error = %d"), GetLastError()));
            LocalFree(String);
            String = NULL;
            break;
        }

        //
        // If the buffer was too small, make it bigger and try again
        //

        if (LengthCopied > LengthAllocated) {

            Temp = LocalReAlloc(String, LengthCopied * sizeof(TCHAR), LMEM_MOVEABLE);

            if (Temp == NULL) {
                DebugMsg((DM_WARNING, TEXT("AllocAndExpandEnvironmentStrings: Failed to reallocate %d bytes for string"), LengthAllocated * sizeof(TCHAR)));
                LocalFree(String);
                String = NULL;
                break;
            }

            LengthAllocated = LengthCopied;
            String = Temp;

            //
            // Go back and try to expand the string again
            //

        } else {

            //
            // Success!
            //

            break;
        }

    }

    return(String);
}

//*************************************************************
//
//  IntToString
//
//  Purpose:    TCHAR version of itoa
//
//  Parameters: INT    i    - integer to convert
//              LPTSTR sz   - pointer where to put the result
//
//  Return:     void
//
//*************************************************************
#define CCH_MAX_DEC 12         // Number of chars needed to hold 2^32

void IntToString( INT i, LPTSTR sz) {
    TCHAR szTemp[CCH_MAX_DEC];
    int iChr;


    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (i % 10);
        i = i / 10;
    } while (i != 0);

    do {
        iChr--;
        *sz++ = szTemp[iChr];
    } while (iChr != 0);

    *sz++ = TEXT('\0');
}

//*************************************************************
//
//  IsUserAGuest()
//
//  Purpose:    Determines if the user is a member of the guest group.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is a guest
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              7/25/95     ericflo    Created
//
//*************************************************************

BOOL IsUserAGuest(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL FoundGuests=FALSE;
    PSID pGuestSid=NULL, pDomainGuestSid=NULL, psidUser=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Guests sid.
    //

    Status = RtlAllocateAndInitializeSid(
               &authNT,
               2,
               SECURITY_BUILTIN_DOMAIN_RID,
               DOMAIN_ALIAS_RID_GUESTS,
               0, 0, 0, 0, 0, 0,
               &pGuestSid
               );

    if (Status != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("IsUserAGuest: RtlAllocateAndInitializeSid failed with error 0x%x"), Status));
        goto Exit;
    }

    if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                      NULL, SecurityImpersonation, TokenImpersonation,
                      &hImpToken)) {
        DebugMsg((DM_WARNING, TEXT("IsUserAGuest: DuplicateTokenEx failed with error %d"), GetLastError()));
        hImpToken = NULL;
        goto Exit;
    }

    if (!CheckTokenMembership(hImpToken, pGuestSid, &FoundGuests)) {
        DebugMsg((DM_WARNING, TEXT("IsUserAGuest: CheckTokenMembership failed for GuestSid with error %d"), GetLastError()));
    }

    if (!FoundGuests) {
        //
        // Get the user's sid
        //

        psidUser = GetUserSid(hToken);

        if (!psidUser) {
            DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure:  Failed to get user sid")));
            goto Exit;
        }

        //
        // Create Domain Guests sid.
        //

        Status = GetDomainSidFromDomainRid(
                                           psidUser,
                                           DOMAIN_GROUP_RID_GUESTS,
                                           &pDomainGuestSid);

        if (Status != STATUS_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("IsUserAGuest: GetDomainSidFromDomainRid failed with error 0x%x"), Status));
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, pDomainGuestSid, &FoundGuests)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAGuest: CheckTokenMembership failed for DomainGuestSid with error %d"), GetLastError()));
        }
    }

    //
    // Tidy up
    //

Exit:

    if (pGuestSid)
        RtlFreeSid(pGuestSid);

    if (pDomainGuestSid)
        RtlFreeSid(pDomainGuestSid);

   if (psidUser)
       DeleteUserSid (psidUser);

    if (hImpToken)
        CloseHandle(hImpToken);

    return(FoundGuests);
}

//*************************************************************
//
//  IsUserAnAdminMember()
//
//  Purpose:    Determines if the user is a member of the administrators group.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is a admin
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              7/25/95     ericflo    Created
//
//*************************************************************

BOOL IsUserAnAdminMember(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL FoundAdmins = FALSE;
    PSID AdminsDomainSid=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Admins domain sid.
    //


    Status = RtlAllocateAndInitializeSid(
               &authNT,
               2,
               SECURITY_BUILTIN_DOMAIN_RID,
               DOMAIN_ALIAS_RID_ADMINS,
               0, 0, 0, 0, 0, 0,
               &AdminsDomainSid
               );

    if (Status == STATUS_SUCCESS) {

        //
        // Test if user is in the Admins domain
        //

        if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                          NULL, SecurityImpersonation, TokenImpersonation,
                          &hImpToken)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnAdminMember: DuplicateTokenEx failed with error %d"), GetLastError()));
            FoundAdmins = FALSE;
            hImpToken = NULL;
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, AdminsDomainSid, &FoundAdmins)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnAdminmember: CheckTokenMembership failed for AdminsDomainSid with error %d"), GetLastError()));
            FoundAdmins = FALSE;
        }
    }

    //
    // Tidy up
    //

Exit:

    if (hImpToken)
        CloseHandle(hImpToken);

    if (AdminsDomainSid)
        RtlFreeSid(AdminsDomainSid);

    return(FoundAdmins);
}

//*************************************************************
//
//  IsUserALocalSystemMember()
//
//  Purpose:    Determines if the user is a member of the Local system group.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is a local system
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              9/22/00     santanuc   created
//
//*************************************************************

BOOL IsUserALocalSystemMember(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL FoundLocalSystem = FALSE;
    PSID LocalSystemSid=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Local system sid.
    //


    Status = RtlAllocateAndInitializeSid(
               &authNT,
               1,
               SECURITY_LOCAL_SYSTEM_RID,
               0, 0, 0, 0, 0, 0, 0,
               &LocalSystemSid
               );

    if (Status == STATUS_SUCCESS) {

        //
        // Test if user is in the Local system
        //

        if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                              NULL, SecurityImpersonation, TokenImpersonation,
                              &hImpToken)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAGuest: DuplicateTokenEx failed with error %d"), GetLastError()));
            FoundLocalSystem = FALSE;
            hImpToken = NULL;
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, LocalSystemSid, &FoundLocalSystem)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnAdminmember: CheckTokenMembership failed for LocalSystemSid with error %d"), GetLastError()));
            FoundLocalSystem = FALSE;
        }
    }

    //
    // Tidy up
    //

Exit:

    if (hImpToken)
        CloseHandle(hImpToken);

    if (LocalSystemSid)
        RtlFreeSid(LocalSystemSid);

    return(FoundLocalSystem);
}

//*************************************************************
//
//  IsUserAnInteractiveUser()
//
//  Purpose:    Determines if the user is interactively logged on.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is logged on interactively
//              FALSE if not
//  Comments:
//
//*************************************************************

BOOL IsUserAnInteractiveUser(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    BOOL bInteractive = FALSE;
    PSID pInteractiveSid=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Admins domain sid.
    //

    if (AllocateAndInitializeSid(&authNT, 1, SECURITY_INTERACTIVE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &pInteractiveSid)) {

        //
        // Test if user is interactive 
        //

        if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                          NULL, SecurityImpersonation, TokenImpersonation,
                          &hImpToken)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnInteractiveUser: DuplicateTokenEx failed with error %d"), GetLastError()));
            bInteractive = FALSE;
            hImpToken = NULL;
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, pInteractiveSid, &bInteractive)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnInteractiveUser: CheckTokenMembership failed for InteractiveSid with error %d"), GetLastError()));
            bInteractive = FALSE;
        }
    }
    else {
        DebugMsg((DM_WARNING, TEXT("IsUserAnInteractiveUser: AllocateAndInitializeSid failed for InteractiveSid with error %d"), GetLastError()));
    }

    //
    // Tidy up
    //

Exit:

    if (hImpToken)
        CloseHandle(hImpToken);

    if (pInteractiveSid)
        FreeSid(pInteractiveSid);

    return(bInteractive);
}

//*************************************************************
//
//  MakeRegKeySecure()
//
//  Purpose:    Sets the security for the key give so that
//              the admin and os having full control with the
//              user having read / execute.
//
//  Parameters: hToken          -   User's token or null for "everyone"
//              hKeyRoot        -   Key to the root of the hive
//              lpKeyName       -   Key to secure
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/7/97      ericflo    Created
//
//*************************************************************

BOOL MakeRegKeySecure(HANDLE hToken, HKEY hKeyRoot, LPTSTR lpKeyName)
{
    DWORD Error, dwDisp;
    HKEY hSubKey;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, AceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;


    //
    // Create the security descriptor that will be applied to the key
    //

    if (hToken) {

        //
        // Get the user's sid
        //

        psidUser = GetUserSid(hToken);

        if (!psidUser) {
            DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure:  Failed to get user sid")));
            return FALSE;
        }

    } else {

        //
        // Get the authenticated users sid
        //

        if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_AUTHENTICATED_USER_RID,
                                      0, 0, 0, 0, 0, 0, 0, &psidUser)) {

             DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure: Failed to initialize authenticated users sid.  Error = %d"), GetLastError()));
             return FALSE;
        }
    }


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Open the registry key
    //

    Error = RegCreateKeyEx(hKeyRoot,
                           lpKeyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                           NULL,
                           &hSubKey,
                           &dwDisp);

    if (Error == ERROR_SUCCESS) {

        Error = RegSetKeySecurity (hSubKey, DACL_SECURITY_INFORMATION, &sd);

        if (Error == ERROR_SUCCESS) {
            bRetVal = TRUE;
        } else {
            DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure: Failed to set security, error = %d"), Error));
        }

        RegCloseKey(hSubKey);

    } else {
        DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure: Failed to open registry key, error = %d"), Error));
    }


Exit:

    //
    // Free the sids and acl
    //

    if (psidUser) {
            if (hToken) {
                DeleteUserSid (psidUser);
        } else {
                FreeSid (psidUser);
        }
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }


    return(bRetVal);
}

//*************************************************************
//
//  FlushSpecialFolderCache()
//
//  Purpose:    Flushes the special folder cache in the shell
//
//  Parameters: none
//
//  Comments:   Shell32.dll caches the special folder pidls
//              but since winlogon never goes away, it is possible
//              for one user's pidls to be used for another user
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

typedef VOID (*PFNSHFLUSHSFCACHE)(VOID);

BOOL FlushSpecialFolderCache (void)
{
    HINSTANCE hInstDLL;
    PFNSHFLUSHSFCACHE pfnSHFlushSFCache;
    BOOL bResult = FALSE;


    hInstDLL = LoadLibraryA ("shell32.dll");

    if (hInstDLL) {

        pfnSHFlushSFCache = (PFNSHFLUSHSFCACHE)GetProcAddress (hInstDLL,
                                       MAKEINTRESOURCEA(526));

        if (pfnSHFlushSFCache) {
            pfnSHFlushSFCache();
            bResult = TRUE;
        }

        FreeLibrary (hInstDLL);
    }

    return bResult;
}

//*************************************************************
//
//  CheckForVerbosePolicy()
//
//  Purpose:    Checks if the user has requested verbose
//              output of policy to the eventlog
//
//  Parameters: None
//
//  Return:     TRUE if we should be verbose
//              FALSE if not
//
//*************************************************************

BOOL CheckForVerbosePolicy (void)
{
    DWORD dwSize, dwType;
    BOOL bVerbose = FALSE;
    HKEY hKey;
    LONG lResult;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, DIAGNOSTICS_KEY,
                     0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        dwSize = sizeof(bVerbose);
        if (RegQueryValueEx (hKey, DIAGNOSTICS_POLICY_VALUE, NULL,
                             &dwType, (LPBYTE) &bVerbose,
                             &dwSize) != ERROR_SUCCESS)
        {
            RegQueryValueEx (hKey, DIAGNOSTICS_GLOBAL_VALUE, NULL,
                             &dwType, (LPBYTE) &bVerbose, &dwSize);
        }

        RegCloseKey (hKey);
    }

    return bVerbose;
}


//*************************************************************
//
//  int ExtractCSIDL()
//
//  Purpose:    Extract the CSIDL from the given string which
//              should under the form ::0x0000::path1\path2\...\
//              pathn\file.ext, where 0x0000 is any valid CSIDL
//
//  Parameters: pcszPath  -     Path containing or not a CSIDL
//              ppszUsualPath - pointer to first characvter of
//                              usual path
//
//  Return:     CSIDL if successful
//              -1    if no CSIDL in path
//
//  Comments:   The ::0x0000:: must be at the beginning and not
//              preceded by any other character and not followed
//              by any either (other than the usual path)
//
//  History:    Date        Author     Comment
//              6/9/98      stephstm   Created
//
//*************************************************************
int ExtractCSIDL(LPCTSTR pcszPath, LPTSTR* ppszUsualPath)
{
    int nRV=-1;

    if (NULL != ppszUsualPath)
    {
        if (TEXT(':') == *pcszPath && TEXT(':') == *(pcszPath+1) &&
            TEXT(':') == *(pcszPath+8) && TEXT(':') == *(pcszPath+9))
        {//looks good
            //+4 to skip "::0x"
            nRV = HexStringToUInt(pcszPath+4);
            *ppszUsualPath = (LPTSTR)(pcszPath+10);
        }
        else
        {//no CSIDL in this path
            //the whole path is a usual path
            *ppszUsualPath = (LPTSTR)pcszPath;
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, TEXT("ExtractCSIDL:  ppszUsualPath ptr is NULL.")));
    }
    return nRV;
}

//*************************************************************
//
//  MyGetDomainName()
//
//  Purpose:    Gets the user's domain name
//
//  Parameters: void
//
//  Return:     lpDomain if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetDomainName (VOID)
{
    LPTSTR lpTemp, lpDomain;


    //
    // Get the username in NT4 format
    //

    lpDomain = MyGetUserName (NameSamCompatible);

    if (!lpDomain) {
        DebugMsg((DM_WARNING, TEXT("MyGetDomainName:  MyGetUserName failed for NT4 style name with %d"),
                 GetLastError()));
        return NULL;
    }


    //
    // Look for the \ between the domain and username and replace
    // it with a NULL
    //

    lpTemp = lpDomain;

    while (*lpTemp && ((*lpTemp) != TEXT('\\')))
        lpTemp++;


    if (*lpTemp != TEXT('\\')) {
        DebugMsg((DM_WARNING, TEXT("GetUserAndDomainNames:  Failed to find slash in NT4 style name:  <%s>"),
                 lpDomain));
        SetLastError(ERROR_INVALID_DATA);
        LocalFree (lpDomain);
        return NULL;
    }

    *lpTemp = TEXT('\0');


    return lpDomain;
}

//*************************************************************
//
//  MyGetUserName()
//
//  Purpose:    Gets the user name in the requested format
//
//  Parameters: NameFormat   - GetUserNameEx naming format
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetUserName (EXTENDED_NAME_FORMAT  NameFormat)
{
    DWORD dwCount = 0, dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;
    PSECUR32_API pSecur32;



    //
    // Load secur32.dll
    //

    pSecur32 = LoadSecur32();

    if (!pSecur32) {
        DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to load Secur32.")));
        return NULL;
    }


    //
    // Allocate a buffer for the user name
    //

    ulUserNameSize = 75;

    if (NameFormat == NameFullyQualifiedDN) {
        ulUserNameSize = 200;
    }


    lpUserName = LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

    if (!lpUserName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Get the username in the requested format
    //

    while (TRUE) {

        if (pSecur32->pfnGetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {

            dwError = ERROR_SUCCESS;
            goto Exit;

        } else {

            //
            // Get the error code
            //

            dwError = GetLastError();


            //
            // If the call failed due to insufficient memory, realloc
            // the buffer and try again.  Otherwise, check the pass
            // count and retry if appropriate.
            //

            if ((dwError == ERROR_INSUFFICIENT_BUFFER) ||
                (dwError == ERROR_MORE_DATA)) {

                lpTemp = LocalReAlloc (lpUserName, (ulUserNameSize * sizeof(TCHAR)),
                                       LMEM_MOVEABLE);

                if (!lpTemp) {
                    dwError = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to realloc memory with %d"),
                             dwError));
                    LocalFree (lpUserName);
                    lpUserName = NULL;
                    goto Exit;
                }

                lpUserName = lpTemp;

            } else if ((dwError == ERROR_NONE_MAPPED) || (dwError == ERROR_NETWORK_UNREACHABLE)) {
                LocalFree (lpUserName);
                lpUserName = NULL;
                goto Exit;

            } else {

                DebugMsg((DM_WARNING, TEXT("MyGetUserName:  GetUserNameEx failed with %d."),
                         dwError));

                dwCount++;

                if (dwCount > 3) {
                    LocalFree (lpUserName);
                    lpUserName = NULL;
                    goto Exit;
                }

                DebugMsg((DM_VERBOSE, TEXT("MyGetUserName:  Retrying call to GetUserNameEx in 1/2 second.")));

                Sleep(500);
            }
        }
    }

Exit:

    SetLastError(dwError);

    return lpUserName;
}


//*************************************************************
//
//  MyGetUserNameEx()
//
//  Purpose:    Gets the user name in the requested format
//
//  Parameters: NameFormat   - GetUserNameEx naming format
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetUserNameEx (EXTENDED_NAME_FORMAT  NameFormat)
{
    DWORD dwCount = 0, dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;
    PSECUR32_API pSecur32;



    //
    // Load secur32.dll
    //

    pSecur32 = LoadSecur32();

    if (!pSecur32) {
        DebugMsg((DM_WARNING, TEXT("MyGetUserNameEx:  Failed to load Secur32.")));
        return NULL;
    }


    //
    // Allocate a buffer for the user name
    //

    ulUserNameSize = 75;

    if (NameFormat == NameFullyQualifiedDN) {
        ulUserNameSize = 200;
    }


    lpUserName = LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

    if (!lpUserName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetUserNameEx:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Get the username in the requested format
    //

    if (!pSecur32->pfnGetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {

        //
        // If the call failed due to insufficient memory, realloc
        // the buffer and try again.  Otherwise, exit now.
        //

        dwError = GetLastError();

       if ((dwError != ERROR_INSUFFICIENT_BUFFER) && (dwError != ERROR_MORE_DATA)) {
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        } 


        lpTemp = LocalReAlloc (lpUserName, (ulUserNameSize * sizeof(TCHAR)),
                               LMEM_MOVEABLE);

        if (!lpTemp) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetUserNameEx:  Failed to realloc memory with %d"),
                      dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        lpUserName = lpTemp;

        if (!pSecur32->pfnGetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {
            dwError = GetLastError();
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        dwError = ERROR_SUCCESS;
    }

Exit:

    SetLastError(dwError);

    return lpUserName;
}


//*************************************************************
//
//  MyGetComputerName()
//
//  Purpose:    Gets the computer name in the requested format
//
//  Parameters: NameFormat  - GetComputerObjectName naming format
//
//  Return:     lpComputerName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetComputerName (EXTENDED_NAME_FORMAT  NameFormat)
{
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR lpComputerName = NULL, lpTemp;
    ULONG ulComputerNameSize;
    PSECUR32_API pSecur32;

    //
    // Load secur32.dll
    //

    pSecur32 = LoadSecur32();

    if (!pSecur32) {
        DebugMsg((DM_WARNING, TEXT("MyGetComputerName:  Failed to load Secur32.")));
        return NULL;
    }

    //
    // Allocate a buffer for the computer name
    //

    ulComputerNameSize = 75;

    if (NameFormat == NameFullyQualifiedDN) {
        ulComputerNameSize = 200;
    }


    lpComputerName = LocalAlloc (LPTR, ulComputerNameSize * sizeof(TCHAR));

    if (!lpComputerName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetComputerName:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Get the computer name in the requested format
    //

    if (!pSecur32->pfnGetComputerObjectName (NameFormat, lpComputerName, &ulComputerNameSize)) {

        //
        // If the call failed due to insufficient memory, realloc
        // the buffer and try again.  Otherwise, exit now.
        //

        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER) {
            LocalFree (lpComputerName);
            lpComputerName = NULL;
            goto Exit;
        }

        lpTemp = LocalReAlloc (lpComputerName, (ulComputerNameSize * sizeof(TCHAR)),
                               LMEM_MOVEABLE);

        if (!lpTemp) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetComputerName:  Failed to realloc memory with %d"),
                     dwError));
            LocalFree (lpComputerName);
            lpComputerName = NULL;
            goto Exit;
        }


        lpComputerName = lpTemp;

        if (!pSecur32->pfnGetComputerObjectName (NameFormat, lpComputerName, &ulComputerNameSize)) {
            dwError = GetLastError();
            LocalFree (lpComputerName);
            lpComputerName = NULL;
            goto Exit;
        }

        dwError = ERROR_SUCCESS;
    }


Exit:

    SetLastError(dwError);

    return lpComputerName;
}


//*************************************************************
//
//  ImpersonateUser()
//
//  Purpose:    Impersonates the specified user
//
//  Parameters: hToken - user to impersonate
//
//  Return:     hToken  if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ImpersonateUser (HANDLE hNewUser, HANDLE *hOldUser)
{

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ,
                          TRUE, hOldUser)) {
        *hOldUser = NULL;
    }

    if (!ImpersonateLoggedOnUser(hNewUser))
    {
        if ( *hOldUser )
        {
            CloseHandle( *hOldUser );
            *hOldUser = NULL;
        }
        DebugMsg((DM_VERBOSE, TEXT("ImpersonateUser: Failed to impersonate user with %d."), GetLastError()));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  RevertToUser()
//
//  Purpose:    Revert back to original user
//
//  Parameters: hUser  -  original user token
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RevertToUser (HANDLE *hUser)
{

    SetThreadToken(NULL, *hUser);

    if (*hUser) {
        CloseHandle (*hUser);
        *hUser = NULL;
    }

    return TRUE;
}


//*************************************************************
//
//  GuidToString, StringToGuid, ValidateGuid, CompareGuid()
//
//  Purpose:    Guid utility functions
//
//*************************************************************

//
// Length in chars of string form of guid {44cffeec-79d0-11d2-a89d-00c04fbbcfa2}
//

#define GUID_LENGTH 38


void GuidToString( const GUID *pGuid, TCHAR * szValue )
{
    wsprintf( szValue,
              TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
              pGuid->Data1,
              pGuid->Data2,
              pGuid->Data3,
              pGuid->Data4[0], pGuid->Data4[1],
              pGuid->Data4[2], pGuid->Data4[3],
              pGuid->Data4[4], pGuid->Data4[5],
              pGuid->Data4[6], pGuid->Data4[7] );
}


void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    WCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == L'{' )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = wcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

BOOL ValidateGuid( TCHAR *szValue )
{
    //
    // Check if szValue is of form {19e02dd6-79d2-11d2-a89d-00c04fbbcfa2}
    //

    if ( lstrlen(szValue) < GUID_LENGTH )
        return FALSE;

    if ( szValue[0] != TEXT('{')
         || szValue[9] != TEXT('-')
         || szValue[14] != TEXT('-')
         || szValue[19] != TEXT('-')
         || szValue[24] != TEXT('-')
         || szValue[37] != TEXT('}') )
    {
        return FALSE;
    }

    return TRUE;
}



INT CompareGuid( GUID * pGuid1, GUID * pGuid2 )
{
    INT i;

    if ( pGuid1->Data1 != pGuid2->Data1 )
        return ( pGuid1->Data1 < pGuid2->Data1 ? -1 : 1 );

    if ( pGuid1->Data2 != pGuid2->Data2 )
        return ( pGuid1->Data2 < pGuid2->Data2 ? -1 : 1 );

    if ( pGuid1->Data3 != pGuid2->Data3 )
        return ( pGuid1->Data3 < pGuid2->Data3 ? -1 : 1 );

    for ( i = 0; i < 8; i++ )
    {
        if ( pGuid1->Data4[i] != pGuid2->Data4[i] )
            return ( pGuid1->Data4[i] < pGuid2->Data4[i] ? -1 : 1 );
    }

    return 0;
}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName)
{
    TCHAR szDelKey[2 * MAX_PATH];
    LPTSTR lpEnd;
    DWORD dwKeys, dwValues;
    LONG lResult;
    HKEY hKey;


    //
    // Make a copy of the subkey so we can write to it.
    //

    if (lstrlen(lpSubKey) >= ARRAYSIZE(szDelKey))
    {
        DebugMsg((DM_WARNING, TEXT("RegCleanUpKey: subkey exceeds range")));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }
    lstrcpy (szDelKey, lpSubKey);


    //
    // First delete the value
    //

    lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegDeleteValue (hKey, lpValueName);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult != ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
                return FALSE;
            }
        }
    }

    //
    // Now loop through each of the parents.  If the parent is empty
    // eg: no values and no other subkeys, then remove the parent and
    // keep working up.
    //

    lpEnd = szDelKey + lstrlen(szDelKey) - 1;

    while (lpEnd >= szDelKey)
    {

        //
        // Find the parent key
        //

        while ((lpEnd > szDelKey) && (*lpEnd != TEXT('\\')))
            lpEnd--;


        //
        // Open the key
        //

        lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_READ, &hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_FILE_NOT_FOUND)
            {
                goto LoopAgain;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
                return FALSE;
            }
        }

        //
        // See if there any any values / keys
        //

        lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL,
                         &dwValues, NULL, NULL, NULL, NULL);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
            return FALSE;
        }


        //
        // Exit now if this key has values or keys
        //

        if ((dwKeys != 0) || (dwValues != 0))
        {
            return TRUE;
        }

        RegDeleteKey (hKeyRoot, szDelKey);

LoopAgain:
        //
        // If we are at the beginning of the subkey, we can leave now.
        //

        if (lpEnd == szDelKey)
        {
            return TRUE;
        }


        //
        // There is a parent key.  Remove the slash and loop again.
        //

        if (*lpEnd == TEXT('\\'))
        {
            *lpEnd = TEXT('\0');
        }
    }

    return TRUE;
}

//*************************************************************
//
//  InitializePingCritSec()
//
//  Purpose:    Initializes a CRITICAL_SECTION for pinging
//              computers
//
//  Parameters: none
//
//
//  Return:     ERROR_SUCCESS if successful
//              An error if it fails.
//
//*************************************************************

DWORD InitializePingCritSec( void )
{
    CRITICAL_SECTION *pCritSec     = NULL;
    DWORD             result       = ERROR_SUCCESS;
    BOOL              fInitialized = FALSE;
    CRITICAL_SECTION *pInitial;

    // If the critical section already exists, return.
    if (g_PingCritSec != NULL)
        return ERROR_SUCCESS;

    // Allocate memory for the critial section.
    pCritSec = (CRITICAL_SECTION *) LocalAlloc( LMEM_FIXED,
                                                sizeof(CRITICAL_SECTION) );
    if (pCritSec == NULL)
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Initialize the critical section.  Using the flag 0x80000000
    // preallocates the event so that EnterCriticalSection can only
    // throw timeout exceptions.
    __try
    {
        if (!InitializeCriticalSectionAndSpinCount( pCritSec, 0x80000000 ))
            result = GetLastError();
        else
            fInitialized = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
    }
    if (result != ERROR_SUCCESS)
        goto Exit;

    // Save the critical section.
    pInitial = (CRITICAL_SECTION *) InterlockedCompareExchangePointer(
        (void **) &g_PingCritSec, (void *) pCritSec, NULL );

    // If the InterlockedCompareExchange succeeded, don't free the
    // critical section just allocated.
    if (pInitial == NULL)
        pCritSec = NULL;

Exit:
    if (pCritSec != NULL)
    {
        if (fInitialized)
            DeleteCriticalSection( pCritSec );
        LocalFree( pCritSec );
    }
    return result;
}

//*************************************************************
//
//  ClosePingCritSec()
//
//  Purpose:    Closes the CRITICAL_SECTION for pinging
//              computers
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void ClosePingCritSec( void )
{
    if (g_PingCritSec != NULL)
    {
        DeleteCriticalSection( g_PingCritSec );
        LocalFree( g_PingCritSec );
        g_PingCritSec = NULL;
    }
}

#define PING_BUFFER_SIZE  2048

//*************************************************************
//
//  PingComputerEx()
//
//  Purpose:    Pings the specified computer to determine
//              what the data transfer rate is
//
//  Parameters: ipaddr  -  IP address of computer
//              ulSpeed -  Data transfer rate (see Notes below)
//              pdwAdapterIndex - index of the adapter that services
//              calls to the DC
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//  Notes:      For fast connections (eg: LAN), it isn't possible
//              to get accurate transfer rates since the response
//              time from the computer is less than 10ms.  In
//              this case, the function returns ERROR_SUCCESS and 
//              ulSpeed is set to maximum speed of network interface.  
//
//              This function will ping the computer 3 times with
//              no data and 3 times with 4K of data.  If the response
//              time from any of the pings is less than 10ms, the
//              function assumes this is a fast link (eg: LAN) and
//              returns with ulSpeed set to maximum speed of network 
//              interface.
//
//              If the pings respond in a time greater than 10ms,
//              the time of the second ping is subtracted from
//              the time of the first ping to determine the amount
//              of time it takes to move just the data.  This
//              is repeated for the 3 sets of pings.  Then the
//              average time is computed from the 3 sets of pings.
//              From the average time, the kbps is calculated.
//
//*************************************************************

DWORD WINAPI
PingComputerEx( ULONG ipaddr, ULONG *ulSpeed, DWORD* pdwAdapterIndex )
{
    DWORD            dwResult   = ERROR_SUCCESS;
    DWORD            i;
    DWORD            dwReplySize;
    HANDLE           icmpHandle = NULL;
    LPBYTE           lpReply    = NULL;
    PICMP_ECHO_REPLY pReplyStruct;
    ULONG            ulFirst;
    ULONG            ulSecond;
    ULONG            ulDiff;
    ULONG            ulTotal    = 0;
    ULONG            ulCount    = 0;
    PICMP_API        pIcmp;
    HRSRC            hJPEG;
    MIB_IFROW        mibIfRow;
    PIPHLPAPI_API    pIpHlpApi;
    HGLOBAL          hGlobalJPEG;

    dwResult = InitializePingCritSec();
    if (dwResult != ERROR_SUCCESS)
        return dwResult;
    EnterCriticalSection( g_PingCritSec );

    //
    // Load iphlpapi.dll
    //

    pIpHlpApi = LoadIpHlpApi();
    if ( !pIpHlpApi )
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PingComputer: iphlpapi.dll is not loaded, %d"), dwResult ));
        goto Exit;
    }

    //
    // Load the icmp api
    //

    dwResult = LoadIcmp( &pIcmp );

    if (dwResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("PingComputer:  Failed to load icmp api.")));
        goto Exit;
    }


    //
    // Load the slow link data if appropriate
    //

    if (!g_lpTestData) {

        hJPEG = FindResource (g_hDllInstance, MAKEINTRESOURCE(IDB_SLOWLINK), TEXT("JPEG"));

        if (hJPEG) {

            hGlobalJPEG = LoadResource (g_hDllInstance, hJPEG);

            if (hGlobalJPEG) {
                g_lpTestData = LockResource (hGlobalJPEG);
            }
        }
    }


    if (!g_lpTestData) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PingComputer:  Failed to load slow link data.")));
        goto Exit;
    }


    //
    // Set default speed
    //
    ZeroMemory( &mibIfRow, sizeof( mibIfRow ) );

    //
    // get the interface index corr. to the interface that services traffic to ipaddr ( DC )
    //
    dwResult = pIpHlpApi->pfnGetBestInterface( ipaddr, &mibIfRow.dwIndex );
    if ( dwResult != NO_ERROR )
    {
        DebugMsg((DM_WARNING, TEXT("PingComputer: GetBestInterface with %d"), dwResult));
    }
    else
    {
        //
        // get information about the interface. We use the dwSpeed as the default speed of the link.
        //
        dwResult = pIpHlpApi->pfnGetIfEntry( &mibIfRow );
        if ( dwResult != NO_ERROR )
        {
            DebugMsg((DM_WARNING, TEXT("PingComputer: GetIfEntry with %d"), dwResult));
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer: Adapter speed %d bps"), mibIfRow.dwSpeed));
        }
    }

    if ( pdwAdapterIndex )
    {
        *pdwAdapterIndex = mibIfRow.dwIndex;
    }
    *ulSpeed = mibIfRow.dwSpeed/1024; // In kbps

    //
    // Allocate space for the receive buffer
    //

    dwReplySize = PING_BUFFER_SIZE + sizeof(ICMP_ECHO_REPLY) + 8;
    lpReply = LocalAlloc (LPTR, dwReplySize);

    if (!lpReply) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PingComputer:  Failed to allocate memory with %d"), dwResult));
        goto Exit;
    }


    //
    // Open the Icmp handle
    //

    icmpHandle = pIcmp->pfnIcmpCreateFile();

    if (icmpHandle == INVALID_HANDLE_VALUE) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PingComputer:  Failed to open handle with %d"), dwResult));
        goto Exit;
    }


    //
    // Loop through the 3 sets of pings
    //

    for (i = 0; i < 3; i++) {

        //
        // Initialize the return value
        //

        dwResult = ERROR_SUCCESS;


        //
        // First ping with no data
        //

        if (pIcmp->pfnIcmpSendEcho (icmpHandle, ipaddr, g_lpTestData, 0, NULL, lpReply,
                                dwReplySize, 5000) == 0) {

            dwResult = GetLastError();

            if (dwResult == IP_DEST_HOST_UNREACHABLE) {
                dwResult = ERROR_BAD_NETPATH;
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Target computer 0x%x not found"), (DWORD)ipaddr));
                goto Exit;

            } else {
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  First send 0x%x failed with %d"), (DWORD)ipaddr, dwResult));
                continue;
            }
        }


        pReplyStruct = (PICMP_ECHO_REPLY) lpReply;

        if (pReplyStruct->Status != IP_SUCCESS) {

            if (pReplyStruct->Status == IP_DEST_HOST_UNREACHABLE) {

                dwResult = ERROR_BAD_NETPATH;
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Target computer not found")));
                goto Exit;

            } else {
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  First send has a reply buffer failure of %d"), pReplyStruct->Status));
                continue;
            }
        }


        ulFirst = pReplyStruct->RoundTripTime;
        DebugMsg((DM_VERBOSE, TEXT("PingComputer:  First time:  %d"), ulFirst));

        if (ulFirst < 10) {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Fast link.  Exiting.")));
            goto Exit;
        }


        //
        // Second ping with dwSize data
        //

        if (pIcmp->pfnIcmpSendEcho (icmpHandle, ipaddr, g_lpTestData, PING_BUFFER_SIZE, NULL, lpReply,
                                dwReplySize, 5000) == 0) {

            dwResult = GetLastError();

            if (dwResult == IP_DEST_HOST_UNREACHABLE) {
                dwResult = ERROR_BAD_NETPATH;
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Target computer not found")));
                goto Exit;

            } else {
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Second send failed with %d"), dwResult));
                continue;
            }
        }


        pReplyStruct = (PICMP_ECHO_REPLY) lpReply;

        if (pReplyStruct->Status != IP_SUCCESS) {

            if (pReplyStruct->Status == IP_DEST_HOST_UNREACHABLE) {

                dwResult = ERROR_BAD_NETPATH;
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Target computer not found")));
                goto Exit;

            } else {
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Second send has a reply buffer failure of %d"), pReplyStruct->Status));
                continue;
            }
        }

        ulSecond = pReplyStruct->RoundTripTime;
        DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Second time:  %d"), ulSecond));

        if (ulSecond < 10) {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Fast link.  Exiting.")));
            goto Exit;
        }


        //
        // Study the results
        //

        if (ulFirst > ulSecond) {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Second time less than first time.")));

        } else if (ulFirst == ulSecond) {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer:  First and second times match.")));

        } else {
            ulTotal += (ulSecond - ulFirst);
            ulCount++;
        }
    }


    //
    // Study the results
    //

    if (ulTotal > 0) {

        ulTotal = (ulTotal / ulCount);
        *ulSpeed = ((((PING_BUFFER_SIZE * 2) * 1000) / ulTotal) * 8) / 1024;
        DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Transfer rate:  %d Kbps  Loop count:  %d"),*ulSpeed, ulCount));
        dwResult = ERROR_SUCCESS;

    } else {
        DebugMsg((DM_VERBOSE, TEXT("PingComputer:  No data available")));
        dwResult = ERROR_UNEXP_NET_ERR;
    }


Exit:

    if (icmpHandle) {
        pIcmp->pfnIcmpCloseHandle (icmpHandle);
    }

    if (lpReply) {
        LocalFree (lpReply);
    }

    LeaveCriticalSection( g_PingCritSec );

    return dwResult;
}

DWORD WINAPI PingComputer (ULONG ipaddr, ULONG *ulSpeed)
{
    return PingComputerEx( ipaddr, ulSpeed, 0 );
}

//*************************************************************
//
//  GetDomainControllerInfo()
//
//  Purpose:    Wrapper for DsGetDcName().
//
//  Parameters:
//              pNetAPI32       - Net API entry points
//              szDomainName    - domain name
//              ulFlags         - flags, see DsGetDcName()
//              ppInfo          - see DOMAIN_CONTROLLER_INFO
//              pfSlow          - slow link?
//
//  Comments:
//
//
//  Return:     NO_ERROR if successful
//              Error code if an error occurs
//
//*************************************************************

DWORD GetDomainControllerInfo(  PNETAPI32_API pNetAPI32,
                                LPTSTR szDomainName,
                                ULONG ulFlags,
                                HKEY hKeyRoot,
                                PDOMAIN_CONTROLLER_INFO* ppInfo,
                                BOOL* pfSlow,
                                DWORD* pdwAdapterIndex )
{
    DWORD   dwResult;

    //
    //  get DC info.
    //
    dwResult = pNetAPI32->pfnDsGetDcName(   0,
                                            szDomainName,
                                            0,
                                            0,
                                            ulFlags,
                                            ppInfo);


    if ( dwResult == ERROR_SUCCESS ) {

        //
        // Check for slow link
        //
        dwResult = IsSlowLink(  hKeyRoot,
                                (*ppInfo)->DomainControllerAddress,
                                pfSlow,
                                pdwAdapterIndex );

        if ( dwResult != ERROR_SUCCESS ){

            //
            // force rediscovery to obtain a live DC
            //
            dwResult = pNetAPI32->pfnDsGetDcName(   0,
                                                    szDomainName,
                                                    0,
                                                    0,
                                                    ulFlags | DS_FORCE_REDISCOVERY,
                                                    ppInfo);
            if ( dwResult == ERROR_SUCCESS ) {

                //
                // re-evaluate link speed
                //
                dwResult = IsSlowLink(  hKeyRoot,
                                        (*ppInfo)->DomainControllerAddress,
                                        pfSlow,
                                        pdwAdapterIndex );
            }
        }
    }
    return dwResult;
}

//*************************************************************
//
//  MakeGenericSecurityDesc()
//
//  Purpose:    manufacture a security descriptor with generic
//              access
//
//  Parameters:
//
//  Return:     pointer to SECURITY_DESCRIPTOR or NULL on error
//
//  Comments:
//
//  History:    Date        Author     Comment
//              4/12/99     NishadM    Created
//
//*************************************************************

PISECURITY_DESCRIPTOR MakeGenericSecurityDesc()
{
    PISECURITY_DESCRIPTOR       psd = 0;
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    authWORLD = SECURITY_WORLD_SID_AUTHORITY;

    PACL    pAcl = 0;
    PSID    psidSystem = 0,
            psidAdmin = 0,
            psidEveryOne = 0;
    DWORD   cbMemSize;
    DWORD   cbAcl;
    DWORD   aceIndex;
    BOOL    bSuccess = FALSE;

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }

    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }

    //
    // Get the EveryOne sid
    //

    if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryOne)) {

        DebugMsg((DM_WARNING, TEXT("AddPowerUserAce: Failed to initialize power users sid.  Error = %d"), GetLastError()));
        goto Exit;
    }

    cbAcl = (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin))  +
            (2 * GetLengthSid (psidEveryOne))  +
            sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    //
    // Allocate space for the SECURITY_DESCRIPTOR + ACL
    //

    cbMemSize = sizeof( SECURITY_DESCRIPTOR ) + cbAcl;

    psd = (PISECURITY_DESCRIPTOR) GlobalAlloc(GMEM_FIXED, cbMemSize);

    if (!psd) {
        DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to alocate security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // increment psd by sizeof SECURITY_DESCRIPTOR
    //

    pAcl = (PACL) ( ( (unsigned char*)(psd) ) + sizeof(SECURITY_DESCRIPTOR) );

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // GENERIC_ALL for local system
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    //
    // GENERIC_ALL for Administrators
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    //
    // GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE for world
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE, psidEveryOne)) {
        DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!SetSecurityDescriptorDacl(psd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("MakeGenericSecurityDesc: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    bSuccess = TRUE;
Exit:
    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (psidEveryOne) {
        FreeSid(psidEveryOne);
    }

    if (!bSuccess && psd) {
        GlobalFree(psd);
        psd = 0;
    }

    return psd;
}

//***************************************************************************
//
//  GetUserGuid
//
//  Purpose:    Allocates and returns a string representing the user guid of
//                the current user.
//
//  Parameters: hToken          -   user's token
//
//  Return:     szUserString is successful
//              NULL if an error occurs
//
//  Comments:   Note, this only works for domain accounts.  Local accounts
//              do not have GUIDs.
//
//  History:    Date        Author     Comment
//              11/14/95    ushaji     created
//***************************************************************************

LPTSTR GetUserGuid(HANDLE hToken)
{
    LPTSTR szUserGuid=NULL;
    HANDLE hOldToken;
    PSID    psidSystem = NULL, psidUser=NULL;
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    BOOL    bImpersonated = FALSE;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_WARNING, TEXT("GetUserGuid: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    psidUser = GetUserSid(hToken);

    if (!psidUser) {
         DebugMsg((DM_WARNING, TEXT("GetUserGuid: Couldn't get user sid,  Error = %d"), GetLastError()));
         goto Exit;
    }

    if (EqualSid(psidUser, psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("GetUserGuid: user sid matches local system, returning NULL"), GetLastError()));
         goto Exit;
    }


    //
    // impersonate the user and the get the user guid for this user.
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetUserGuid: Failed to impersonate user with %d."), GetLastError()));
        goto Exit;
    }

    bImpersonated = TRUE;


    szUserGuid = MyGetUserNameEx(NameUniqueId);

    if (!szUserGuid) {
        if ((GetLastError() != ERROR_CANT_ACCESS_DOMAIN_INFO) &&
            (GetLastError() != ERROR_NONE_MAPPED)) {
            DebugMsg((DM_WARNING, TEXT("GetUserGuid: Failed to get user guid with %d."), GetLastError()));
        }
    }

Exit:
    if (bImpersonated)
        RevertToUser(&hOldToken);

    if (psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidSystem)
         FreeSid(psidSystem);

    return szUserGuid;
}



//***************************************************************************
//
//  GetOldSidString
//
//  Purpose:    Allocates and returns a string representing the old sid of
//                the current user by looking at the profile guid in the registry.
//
//  Parameters: hToken          -   user's token
//              lpKeyName       -   key to read
//
//  Return:     SidString is successful
//              NULL if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/14/95    ushaji     created
//***************************************************************************

LPTSTR GetOldSidString(HANDLE hToken, LPTSTR lpKeyName)
{
    TCHAR szBuffer[MAX_PATH+1], *lpEnd;
    LPTSTR szUserGuid;
    DWORD dwSize=0, dwType;
    TCHAR *lpSidString = NULL;
    HKEY  hKey = NULL;
    LONG  lResult;
    DWORD dwErr;

    //
    // get the prev last error
    //

    dwErr = GetLastError();

    szUserGuid = GetUserGuid(hToken);

    if (!szUserGuid) {
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Open the guid->sid mapping
    //

    lstrcpy(szBuffer, lpKeyName);
    lpEnd = CheckSlash (szBuffer);
    lstrcpy(lpEnd, szUserGuid);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_VERBOSE, TEXT("GetOldSidString:  Failed to open profile profile guid key with error %d"), lResult));
        goto Exit;
    }

    //
    // Query for the Sid String, (size first)
    //

    lResult = RegQueryValueEx (hKey,
                               PROFILE_SID_STRING,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("GetOldSidString:  Failed to query size of SidString with error %d"), lResult));
        goto Exit;
    }

    lpSidString = LocalAlloc(LPTR, dwSize);

    if (!lpSidString) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("GetOldSidString:  Failed to allocate memory for SidString"), lResult));
        goto Exit;
    }

    lResult = RegQueryValueEx (hKey,
                               PROFILE_SID_STRING,
                               NULL,
                               &dwType,
                               (LPBYTE)lpSidString,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("GetOldSidString:  Failed to query SidString with error %d"), lResult));
        LocalFree(lpSidString);
        lpSidString = NULL;
        goto Exit;
    }

Exit:
    if (szUserGuid)
        LocalFree(szUserGuid);

    if (hKey)
        RegCloseKey(hKey);

    SetLastError(dwErr);

    return lpSidString;
}

//***************************************************************************
//
//  SetOldSidString
//
//  Purpose:    Sets the old sid string corresp. to a user for the next domain
//              migration
//
//  Parameters: hToken          -   user's token
//              lpSidString     -   user's sid (in a string form)
//              lpKeyName       -   key to store
//
//  Return:     SidString is successful
//              NULL if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/14/95    ushaji     created
//***************************************************************************
BOOL SetOldSidString(HANDLE hToken, LPTSTR lpSidString, LPTSTR lpKeyName)
{
    TCHAR szBuffer[MAX_PATH+1], *lpEnd;
    DWORD dwSize=0, dwDisp = 0;
    HKEY  hKey = NULL;
    BOOL  bRetVal = TRUE;
    LONG lResult = 0;
    LPTSTR szUserGuid;
    DWORD dwErr;

    //
    // get the prev last error
    //

    dwErr = GetLastError();

    szUserGuid = GetUserGuid(hToken);

    if (!szUserGuid) {
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Open the guid->sid mapping
    //

    lstrcpy(szBuffer, lpKeyName);
    lpEnd = CheckSlash (szBuffer);
    lstrcpy(lpEnd, szUserGuid);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, 0, 0, KEY_READ | KEY_WRITE, NULL,
                            &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        dwErr = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("GetOldSidString:  Failed to open profile profile guid key with error %d"), lResult));
        goto Exit;
    }

    //
    // Set the Sid String
    //

    lResult = RegSetValueEx (hKey,
                             PROFILE_SID_STRING,
                             0,
                             REG_SZ,
                             (LPBYTE) lpSidString,
                             (lstrlen(lpSidString) + 1) * sizeof(TCHAR));

    if (lResult != ERROR_SUCCESS) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SetOldSidString:  Failed to set SidString with error %d"), lResult));
        goto Exit;
    }

    bRetVal = TRUE;

Exit:
    if (szUserGuid)
        LocalFree(szUserGuid);

    if (hKey)
        RegCloseKey(hKey);

    SetLastError(dwErr);

    return bRetVal;
}


//***************************************************************************
//
//  GetErrString
//
//  Purpose:    Calls FormatMessage to Get the error string corresp. to a error
//              code
//
//
//  Parameters: dwErr           -   Error Code
//              szErr           -   Buffer to return the error string (MAX_PATH)
//                                  is assumed.!!!
//
//  Return:     szErr
//
//  History:    Date        Author     Comment
//              4/28/99     ushaji     created
//***************************************************************************

LPTSTR GetErrString(DWORD dwErr, LPTSTR szErr)
{
    szErr[0] = TEXT('\0');

    FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                  NULL, dwErr,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  szErr, MAX_PATH, NULL);

    return szErr;
}


//*************************************************************
//
//  GetMachineToken()
//
//  Purpose:    Gets the machine token
//
//  Parameters: none
//
//  Note:       This must be called from the LocalSystem context
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HANDLE GetMachineToken (void)
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS InitStatus;
    SECURITY_STATUS AcceptStatus;
    HANDLE hToken = NULL;
    PSecPkgInfo PackageInfo = NULL;
    BOOLEAN AcquiredServerCred = FALSE;
    BOOLEAN AcquiredClientCred = FALSE;
    BOOLEAN AcquiredClientContext = FALSE;
    BOOLEAN AcquiredServerContext = FALSE;
    CredHandle CredentialHandle2;
    CredHandle ServerCredHandleStorage;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    PCtxtHandle pServerContextHandle = NULL;
    PCtxtHandle pClientContextHandle = NULL;
    PCredHandle ServerCredHandle = NULL;
    TimeStamp Lifetime;
    DWORD dwSize;
    TCHAR szComputerName[MAX_PATH];
    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    PSecBufferDesc pChallengeDesc = NULL;
    SecBuffer ChallengeBuffer;
    LPBYTE pvBuffer = NULL;
    LPBYTE pvBuffer2 = NULL;
    ULONG ContextAttributes;
    PSECUR32_API pSecur32;


    //
    // Load pSecur32->dll
    //

    if ( !( pSecur32 = LoadSecur32 () ) ) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  Failed to load Secur32.")));
        SecStatus = GetLastError();
        return NULL;
    }


    //
    // Get the computer name
    //

    dwSize = ARRAYSIZE(szComputerName);

    if (!GetComputerName (szComputerName, &dwSize)) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken: Failed to get the computer name with %d"), GetLastError()));
        SecStatus = GetLastError();
        goto Exit;
    }

    lstrcat (szComputerName, TEXT("$"));


    //
    // Get the kerberos security package
    //

    SecStatus = pSecur32->pfnQuerySecurityPackageInfo( L"kerberos", &PackageInfo );

    if (SecStatus != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  QuerySecurityPackageInfo failed with 0x%x"),
                 SecStatus));
        goto Exit;
    }


    //
    // Acquire a credential handle for the server side
    //

    ServerCredHandle = &ServerCredHandleStorage;

    SecStatus = pSecur32->pfnAcquireCredentialsHandle(
                    NULL,           // New principal
                    L"kerberos",    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    ServerCredHandle,
                    &Lifetime );

    if (SecStatus != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  AcquireCredentialsHandle for server failed with 0x%x"),
                 SecStatus));
        goto Exit;
    }

    AcquiredServerCred = TRUE;


    //
    // Acquire a credential handle for the client side
    //

    SecStatus = pSecur32->pfnAcquireCredentialsHandle(
                    NULL,           // New principal
                    L"kerberos",    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if (SecStatus != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  AcquireCredentialsHandle for client failed with 0x%x"),
                 SecStatus));
        goto Exit;
    }

    AcquiredClientCred = TRUE;


    //
    // Allocate buffers
    //

    pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken);

    if (!pvBuffer) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  LocalAlloc failed with %d"),
                 GetLastError()));
        SecStatus = GetLastError();
        goto Exit;
    }


    pvBuffer2 = LocalAlloc( 0, PackageInfo->cbMaxToken);

    if (!pvBuffer2) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  LocalAlloc failed with %d"),
                 GetLastError()));
        SecStatus = GetLastError();
        goto Exit;
    }


    while (TRUE) {

        //
        // Initialize the security context (client side)
        //

        NegotiateDesc.ulVersion = 0;
        NegotiateDesc.cBuffers = 1;
        NegotiateDesc.pBuffers = &NegotiateBuffer;

        NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
        NegotiateBuffer.pvBuffer = pvBuffer;

        InitStatus = pSecur32->pfnInitializeSecurityContext(
                        &CredentialHandle2,
                        pClientContextHandle,
                        szComputerName,
                        0,
                        0,                  // Reserved 1
                        SECURITY_NATIVE_DREP,
                        pChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &NegotiateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ((InitStatus != SEC_E_OK) && (InitStatus != SEC_I_CONTINUE_NEEDED)) {
            DebugMsg((DM_WARNING, TEXT("GetMachineToken:  InitializeSecurityContext failed with 0x%x"),
                     InitStatus));
            SecStatus = InitStatus;
            goto Exit;
        }

        pClientContextHandle = &ClientContextHandle;
        AcquiredClientContext = TRUE;


        //
        // Accept the server side context
        //

        NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
        ChallengeDesc.ulVersion = 0;
        ChallengeDesc.cBuffers = 1;
        ChallengeDesc.pBuffers = &ChallengeBuffer;

        ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
        ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
        ChallengeBuffer.pvBuffer = pvBuffer2;

        AcceptStatus = pSecur32->pfnAcceptSecurityContext(
                        ServerCredHandle,
                        pServerContextHandle,
                        &NegotiateDesc,
                        0,
                        SECURITY_NATIVE_DREP,
                        &ServerContextHandle,
                        &ChallengeDesc,
                        &ContextAttributes,
                        &Lifetime );


        if ((AcceptStatus != SEC_E_OK) && (AcceptStatus != SEC_I_CONTINUE_NEEDED)) {
            DebugMsg((DM_WARNING, TEXT("GetMachineToken:  AcceptSecurityContext failed with 0x%x"),
                     AcceptStatus));
            SecStatus = AcceptStatus;
            goto Exit;
        }

        AcquiredServerContext = TRUE;

        if (AcceptStatus == SEC_E_OK) {
            break;
        }

        pChallengeDesc = &ChallengeDesc;
        pServerContextHandle = &ServerContextHandle;

        DebugMsg((DM_VERBOSE, TEXT("GetMachineToken:  Looping for authentication again.")));
    }


    //
    // Get the server token
    //

    SecStatus = pSecur32->pfnQuerySecurityContextToken(&ServerContextHandle, &hToken);

    if ( SecStatus != STATUS_SUCCESS ) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  QuerySecurityContextToken failed with 0x%x"),
                 SecStatus));
        goto Exit;
    }

Exit:

    if (AcquiredClientContext) {
        pSecur32->pfnDeleteSecurityContext( &ClientContextHandle );
    }

    if (AcquiredServerContext) {
        pSecur32->pfnDeleteSecurityContext( &ServerContextHandle );
    }

    if (pvBuffer2) {
        LocalFree (pvBuffer2);
    }

    if (pvBuffer) {
        LocalFree (pvBuffer);
    }

    if (AcquiredClientCred) {
        pSecur32->pfnFreeCredentialsHandle(&CredentialHandle2);
    }

    if (AcquiredServerCred)
    {
        pSecur32->pfnFreeCredentialsHandle(ServerCredHandle);
    }

    if (PackageInfo) {
        pSecur32->pfnFreeContextBuffer(PackageInfo);
    }

    if (!hToken) {
        SetLastError(SecStatus);
    }

    return hToken;
}

//*************************************************************
//
//  IsNullGUID()
//
//  Purpose:    Determines if the passed in GUID is all zeros
//
//  Parameters: pguid   GUID to compare
//
//  Return:     TRUE if the GUID is all zeros
//              FALSE if not
//
//*************************************************************

BOOL IsNullGUID (GUID *pguid)
{

    return ( (pguid->Data1 == 0)    &&
             (pguid->Data2 == 0)    &&
             (pguid->Data3 == 0)    &&
             (pguid->Data4[0] == 0) &&
             (pguid->Data4[1] == 0) &&
             (pguid->Data4[2] == 0) &&
             (pguid->Data4[3] == 0) &&
             (pguid->Data4[4] == 0) &&
             (pguid->Data4[5] == 0) &&
             (pguid->Data4[6] == 0) &&
             (pguid->Data4[7] == 0) );
}

//*************************************************************
//
//  GetMachineRole()
//
//  Purpose:    Determines the role of the machine
//              server vs workstation vs standalone
//
//  Parameters: piRole -  Receives the simple role number
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetMachineRole (LPINT piRole)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic;
    DWORD dwResult;
    PNETAPI32_API pNetAPI32;


    //
    // Check the cached value first
    //

    if (g_iMachineRole != -1) {
        *piRole = g_iMachineRole;
        return TRUE;
    }


    //
    // Load netapi32
    //

    pNetAPI32 = LoadNetAPI32();

    if (!pNetAPI32) {
        DebugMsg((DM_WARNING, TEXT("GetMachineRole:  Failed to load netapi32 with %d."),
                 GetLastError()));
        return FALSE;
    }


    //
    // Ask for the role of this machine
    //

    dwResult = pNetAPI32->pfnDsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic,
                                                               (PBYTE *)&pBasic);


    if (dwResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetMachineRole:  DsRoleGetPrimaryDomainInformation failed with %d."),
                 dwResult));
        return FALSE;
    }


    //
    // Convert the role into a simple machine role
    //

    if ((pBasic->MachineRole == DsRole_RoleStandaloneWorkstation) ||
        (pBasic->MachineRole == DsRole_RoleStandaloneServer)) {

        *piRole = 0;   // standalone machine not in a DS domain

    } else {

        if (pBasic->Flags & DSROLE_PRIMARY_DOMAIN_GUID_PRESENT) {

            if (!IsNullGUID(&pBasic->DomainGuid)) {

                *piRole = 2;   // machine is a member of a domain with DS support

                if ((pBasic->MachineRole == DsRole_RoleBackupDomainController) ||
                    (pBasic->MachineRole == DsRole_RolePrimaryDomainController)) {
                    *piRole = 3;  // machine is a domain controller
                }
            } else {
                *piRole = 1;   // machine is a member of a NT4 domain
            }

        } else {
            *piRole = 1;   // machine is a member of a domain without DS support
        }
    }

    pNetAPI32->pfnDsRoleFreeMemory (pBasic);


    //
    // Save this value in the cache for future use
    //

    g_iMachineRole = *piRole;

    return TRUE;
}



//*************************************************************
//
//  IsUNCPath()
//
//  Purpose:    Is the given path a UNC path
//
//  Parameters: lpPath  -   Path to check
//
//  Return:     TRUE if the path is UNC
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL IsUNCPath(LPCTSTR lpPath)
{

    if ((!lpPath) || (!lpPath[0]) && (!lpPath[1]))
        return FALSE;

    if (lpPath[0] == TEXT('\\') && lpPath[1] == TEXT('\\')) {
        return(TRUE);
    }
    return(FALSE);
}


//*************************************************************
//
//  MakePathUNC()
//
//  Purpose:    Makes the given path UNC s.t. it can be accessed from a remote machine..
//              if the path contains %systemroot% expanded then it substitutes
//              \\machname\admin$ otherwise \\machname\<driveletter>$
//
//  Parameters: lpPath          -   Input Path (needs to be absolute)
//              szComputerName  -   Name of the computer on which this is the local path
//
//  Return:     Path if it was fone successfully
//              NULL if not
//
//  Comments:
//
//
//*************************************************************

LPTSTR MakePathUNC(LPTSTR pwszFile, LPTSTR szComputerName)
{
    LPTSTR szUNCPath=NULL;
    TCHAR szSysRoot[MAX_PATH];
    DWORD dwSysLen;
    LPTSTR lpEnd = NULL;


    DebugMsg((DM_VERBOSE, TEXT("MakePathUNC: Entering with <%s>"),
             pwszFile ? pwszFile : TEXT("NULL")));

    szUNCPath = LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(pwszFile)+lstrlen(szComputerName)+3+lstrlen(TEXT("admin$"))+1));

    if (!szUNCPath)
        return NULL;

    if (!pwszFile || !*pwszFile) {
        DebugMsg((DM_VERBOSE, TEXT("MakePathUNC: lpFile is NULL, setting lpResult to a null string")));
        *szUNCPath = TEXT('\0');
        return szUNCPath;
    }


    if (IsUNCPath(pwszFile)) {
        lstrcpy(szUNCPath, pwszFile);
        return szUNCPath;
    }


    lstrcpy(szUNCPath, TEXT("\\\\"));
    lstrcat(szUNCPath, szComputerName);


    //
    // If the first part of lpFile is the expanded value of %SystemRoot%
    //

    if (!ExpandEnvironmentStrings (TEXT("%SystemRoot%"), szSysRoot, MAX_PATH)) {
        DebugMsg((DM_WARNING, TEXT("MakePathUNC: ExpandEnvironmentString failed with error %d, setting szSysRoot to %systemroot% "), GetLastError()));
        LocalFree(szUNCPath);
        return NULL;
    }


    dwSysLen = lstrlen(szSysRoot);
    lpEnd = CheckSlash(szUNCPath);


    //
    // if the prefix is the same as expanded systemroot then..
    //

    if (((DWORD)lstrlen(pwszFile) > dwSysLen) &&
        (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                       szSysRoot, dwSysLen,
                       pwszFile, dwSysLen) == CSTR_EQUAL)) {

        lstrcat(szUNCPath, TEXT("admin$"));
        lstrcat(szUNCPath, pwszFile+dwSysLen);
    }
    else {

        if (pwszFile[1] != TEXT(':')) {
            DebugMsg((DM_WARNING, TEXT("MakePathUNC: Input path %s is not an absolute path"), pwszFile));
            lstrcpy(szUNCPath, pwszFile);
            return szUNCPath;
        }

        lpEnd[0] = pwszFile[0];
        lpEnd[1] = TEXT('$');
        lpEnd[2] = TEXT('\0');

        lstrcat(szUNCPath, pwszFile+2);
    }

    DebugMsg((DM_VERBOSE, TEXT("MakePathUNC: Returning a UNCPath of %s"), szUNCPath));

    return szUNCPath;
}


//*************************************************************
//
//  SupportLongFileName()
//
//  Purpose:    Prepends lpDir with \\?\UNC\ or \\?\ depending on
//              whether lpDir is a UNC path or local path. Before
//              prepending this function converts relative path or 
//              absolute path started with a slash to corresponding
//              absolute path containing drive letter.
//
//  Parameters: lpDir         -   Directory
//              lpWrkDirSize  -   Size of the returned buffer in unit
//                                of TCHAR
//
//  Return:     LPTSTR pointing to prepended dir/file
//              NULL if fail to allocate memory
//
//  Comments:   Prepending with \\?\UNC\ or \\?\ allows all file api's
//              to handle file name > MAX_PATH.
//
//  History:    Date        Author     Comment
//              8/8/00      santanuc   Created
//
//*************************************************************

LPTSTR SupportLongFileName (LPTSTR lpDir, LPDWORD lpWrkDirSize)
{
    LPTSTR lpWrkDir = NULL;

    *lpWrkDirSize = lstrlen(lpDir)+2*MAX_PATH;
    lpWrkDir = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)**lpWrkDirSize);

    if (!lpWrkDir) {
        DebugMsg((DM_WARNING, TEXT("EnableLongFileNameDeletion: Failed to Allocate memory.  Error = %d"),
                GetLastError()));
        return NULL;
    }

    if ( IsUNCPath(lpDir) ) {
        // lpDir is of the form \\computername\...
        lstrcpy(lpWrkDir, c_szUNCFilePrefix);
        lstrcat(lpWrkDir, lpDir+2);
    }

    else if ( *CharNext(lpDir) == TEXT(':') ) {
        // Local storage specified with drive name
        lstrcpy(lpWrkDir, c_szLocalFilePrefix);
        lstrcat(lpWrkDir, lpDir);
    }

    else if ( *lpDir == TEXT('\\') ) {
        DWORD dwSize;

        // Prepend lpDir with c_szLocalFilePrefix followed by current drive as DeleteFile function requires 
        // drive name to delete files from local storage with path name > MAX_PATH
        lstrcpy(lpWrkDir, c_szLocalFilePrefix);
        dwSize = GetCurrentDirectory(*lpWrkDirSize-c_dwLocalFilePrefixLen, lpWrkDir+c_dwLocalFilePrefixLen);

        if (dwSize == 0) {
            DebugMsg((DM_VERBOSE, TEXT("DelNode: GetCurrentDirectory failed with error %d"), GetLastError()));
            // proceed to delete lpDir without long file name deletion feature
            lstrcpy(lpWrkDir, lpDir);
        }
        else {

            if (dwSize > *lpWrkDirSize-c_dwLocalFilePrefixLen) {

                // Extend lpWrkDir to accomodate current directory name with drive
                LocalFree(lpWrkDir);
                *lpWrkDirSize = dwSize+c_dwLocalFilePrefixLen;
                lpWrkDir = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)**lpWrkDirSize);
                if (!lpWrkDir) {
                    DebugMsg((DM_WARNING, TEXT("Delnode: Failed to Allocate memory.  Error = %d"), GetLastError()));
                    return NULL;
                }

                lstrcpy(lpWrkDir, c_szLocalFilePrefix);
                dwSize = GetCurrentDirectory(*lpWrkDirSize-c_dwLocalFilePrefixLen, lpWrkDir+c_dwLocalFilePrefixLen);

                if (dwSize == 0 || dwSize > *lpWrkDirSize-c_dwLocalFilePrefixLen) {
                    DebugMsg((DM_VERBOSE, TEXT("DelNode: GetCurrentDirectory 2nd call failed with error %d"), GetLastError()));
                    // proceed to delete lpDir without long file name deletion feature
                    lstrcpy(lpWrkDir, lpDir);
                }

                else {
                    // Copy lpDir after c_szLocalFilePrefix and drive name
                    lstrcpy(lpWrkDir+c_dwLocalFilePrefixLen+2, lpDir);
                }        
            
            }
            else {               
                // Copy lpDir after c_szLocalFilePrefix and drive name
                lstrcpy(lpWrkDir+c_dwLocalFilePrefixLen+2, lpDir);
            }
        }
    }
    else {

        LPTSTR szFileName;
        DWORD dwSize;

        // Relative path name specified. So Prepend lpDir with c_szLocalFilePrefix followed by the current directory
        lstrcpy(lpWrkDir, c_szLocalFilePrefix);
        dwSize = GetFullPathName(lpDir, *lpWrkDirSize-c_dwLocalFilePrefixLen, lpWrkDir+c_dwLocalFilePrefixLen, &szFileName);
        if ( dwSize == 0 ) {
            DebugMsg((DM_VERBOSE, TEXT("DelNode: GetFullPathName failed with error %d"), GetLastError()));
            // proceed to delete lpDir without long file name deletion feature
            lstrcpy(lpWrkDir, lpDir);
        }
        else {

            if ( dwSize > *lpWrkDirSize-c_dwLocalFilePrefixLen ) {

                // Extend lpWrkDir to accomodate absolute path name
                LocalFree(lpWrkDir);
                *lpWrkDirSize = dwSize+2*MAX_PATH;
                lpWrkDir = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)**lpWrkDirSize);
                if (!lpWrkDir) {
                    DebugMsg((DM_WARNING, TEXT("Delnode: Failed to Allocate memory.  Error = %d"), GetLastError()));
                    return NULL;
                }

                lstrcpy(lpWrkDir, c_szLocalFilePrefix);
                dwSize = GetFullPathName(lpDir, *lpWrkDirSize-c_dwLocalFilePrefixLen, lpWrkDir+c_dwLocalFilePrefixLen, &szFileName);
                if (dwSize == 0 || dwSize > *lpWrkDirSize-c_dwLocalFilePrefixLen) {
                    DebugMsg((DM_VERBOSE, TEXT("DelNode: GetFullPathName 2nd call failed with error %d"), GetLastError()));
                    // proceed to delete lpDir without long file name deletion feature
                    lstrcpy(lpWrkDir, lpDir);
                }
            }
        }
    }

    return lpWrkDir;
}

            

//*************************************************************
//
//  SecureNestedDir_Recurse()
//
//  Purpose:    Recursive function for securing nested dirs/files
//
//  Parameters: lpDir   -   Full Directory Path. 
//              dwSize  -   Allocated size of the working buffer
//              pDirSd  -   Security descriptor to be applied with dirs
//              pFileSd -   Security descriptor to be applied with files
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//
//
//*************************************************************

BOOL SecureNestedDir_Recurse (LPTSTR lpDir, DWORD dwSize, PSECURITY_DESCRIPTOR pDirSd, PSECURITY_DESCRIPTOR pFileSd)
{
    BOOL bOwn = FALSE, bRetVal = FALSE;
    LPTSTR lpEnd = NULL, lpWrkDir = NULL;
    WIN32_FIND_DATA fd;
    HANDLE hFile;
    DWORD dwWrkDirSize;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureNestedDir_Recurse: Entering, lpDir = <%s>"), lpDir));


    //
    // Each filename or a directory has to be less than MAX_PATH in the worst case.
    // So make sure that we have at least MAX_PATH + 2 (for a slash and '\0'
    // space left in the working buffer case.
    //
    // In the normal case, when we have a path of length ~MAX_PATH it will do only 
    // 1 allocation
    //


    if ((DWORD)(lstrlen(lpDir) + MAX_PATH+2) > (dwSize)) {
        
        dwWrkDirSize = dwSize+2*MAX_PATH;
        lpWrkDir = (LPWSTR)LocalAlloc(LPTR, dwWrkDirSize*sizeof(TCHAR));
        if (!lpWrkDir) {
            DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: Couldn't allocate memory for working buffer. Error - %d"), GetLastError()));
            goto Exit;
        }

        lstrcpy(lpWrkDir, lpDir);
        bOwn = TRUE;

    }
    else {
        lpWrkDir = lpDir;
        dwWrkDirSize = dwSize;
    }


    //
    // Attach a Slash the end if required
    //

    lpEnd = CheckSlash(lpWrkDir);
    lstrcat(lpEnd, c_szStarDotStar);


    //
    // Find the first file
    //

    hFile = FindFirstFile(lpWrkDir, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ((GetLastError() == ERROR_FILE_NOT_FOUND) || (GetLastError() == ERROR_PATH_NOT_FOUND)) {
            bRetVal = TRUE;
            goto Exit;
        } else {
            DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: FindFirstFile failed.  Error = %d"),
                     GetLastError()));
            goto Exit;
        }
    }


    do {
        //
        //  Verbose output
        //

        DebugMsg((DM_VERBOSE, TEXT("SecureNestedDir_Recurse: FindFile found:  <%s>"), fd.cFileName));

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, c_szDot)) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, c_szDotDot)) {
            continue;
        }

        lstrcpyn(lpEnd, fd.cFileName, MAX_PATH);


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //

            SecureNestedDir_Recurse(lpWrkDir, dwWrkDirSize, pDirSd, pFileSd);

            //
            // ignore errors and go ahead..
            //

            lstrcpyn(lpEnd, fd.cFileName, MAX_PATH);

            if (!SetFileSecurity (lpWrkDir, DACL_SECURITY_INFORMATION, pDirSd)) {
                DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: Failed to secure directory <%s>.  Error = %d"),
                          lpWrkDir, GetLastError()));
            }

        } else {

            //
            // We found a file.  Try to secure it
            //

            if (!SetFileSecurity (lpWrkDir, DACL_SECURITY_INFORMATION, pFileSd)) {
                DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: Failed to secure file <%s>.  Error = %d"),
                          fd.cFileName, GetLastError()));
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    //
    // Close the search handle
    //

    FindClose(hFile);

    //
    // Success.
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureNestedDir_Recurse: Leaving <%s>"), lpDir));

    bRetVal = TRUE;

Exit:
    if (bOwn) 
        LocalFree(lpWrkDir);
    
    return bRetVal;
}


//*************************************************************
//
//  SecureNestedDir()
//
//  Purpose:    Secure the dir and nested dirs(files) with input
//              SECURITY_DESCRIPTOR.
//
//  Parameters: lpDir   -   Directory
//              pDirSd  -   Security descriptor to be applied with dirs.
//              pFileSd -   Security descriptor to be applied with files. 
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  History:    Date        Author     Comment
//              8/8/00      santanuc   Created
//
//*************************************************************

BOOL SecureNestedDir (LPTSTR lpDir, PSECURITY_DESCRIPTOR pDirSd, PSECURITY_DESCRIPTOR pFileSd)
{
    LPTSTR lpWrkDir = NULL;
    DWORD  dwWrkDirSize;
    BOOL   bRetVal = FALSE;

    lpWrkDir = SupportLongFileName(lpDir, &dwWrkDirSize);

    if (!lpWrkDir) {
        DebugMsg((DM_WARNING, TEXT("SecureNestedDir: Failed to Allocate memory.  Error = %d"),
                GetLastError()));
        goto Exit;
    }

    if (!SecureNestedDir_Recurse (lpWrkDir, dwWrkDirSize, pDirSd, pFileSd)) {
        DebugMsg((DM_WARNING, TEXT("SecureNestedDir: SecureNestedDir recurse failed with error %d"),
                GetLastError()));
    }
        
    if (!SetFileSecurity (lpDir, DACL_SECURITY_INFORMATION, pDirSd)) {
        DebugMsg((DM_WARNING, TEXT("SecureNestedDir: SetFileSecurity failed.  Error = %d"), GetLastError()));
        goto Exit;
    }

    bRetVal = TRUE;

    DebugMsg((DM_VERBOSE, TEXT("SecureNestedDir: Secure directory <%s> successfully."), lpDir));

Exit:
    
    if (lpWrkDir) {
        LocalFree(lpWrkDir);
    }

    return bRetVal;
}


//*************************************************************
//
//  SetEnvironmentVariableInBlock()
//
//  Purpose:    Sets the environment variable in the given block
//
//  Parameters: pEnv        -   Environment block
//              lpVariable  -   Variables
//              lpValue     -   Value
//              bOverwrite  -   Overwrite
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL SetEnvironmentVariableInBlock(PVOID *pEnv, LPTSTR lpVariable,
                                   LPTSTR lpValue, BOOL bOverwrite)
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    DWORD cb;
    LPTSTR szValue = NULL;

    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }

    RtlInitUnicodeString(&Name, lpVariable);

    cb = 1025 * sizeof(WCHAR);
    Value.Buffer = LocalAlloc(LPTR, cb);
    if (Value.Buffer) {
        Value.Length = 0;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);

        LocalFree(Value.Buffer);

        if ( NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }

    szValue = (LPTSTR)LocalAlloc(LPTR, 1024*sizeof(TCHAR));
    if (!szValue) {
        DebugMsg((DM_WARNING, TEXT("SetEnvironmentVariableInBlock: Out of memory")));
        return FALSE;
    }

    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!lstrcmpi(lpVariable, TEXT("TEMP"))) ||
            (!lstrcmpi(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, 1024)) {
                 lstrcpyn (szValue, lpValue, 1024);
             }
        } else {
            lstrcpyn (szValue, lpValue, 1024);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable(pEnv, &Name, NULL);
    }

    LocalFree(szValue);
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}

/***************************************************************************\
* ExpandUserEvironmentVariable
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
DWORD
ExpandUserEnvironmentStrings(
    PVOID pEnv,
    LPCTSTR lpSrc,
    LPTSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;

    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(nSize*sizeof(WCHAR));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( pEnv,
                                          (PUNICODE_STRING)&Source,
                                          (PUNICODE_STRING)&Destination,
                                          &Length
                                        );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length );
        }
    else {
        return( 0 );
        }
}


//*************************************************************
//
//  ConvertToShareName()
//
//  Purpose:    Convert the UNC path of a file\dir to a share
//
//  Parameters: lpShare  : Full UNC path of file\dir
//
//  Return:     None.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/21/00     santanuc   Created
//
//*************************************************************
LPTSTR ConvertToShareName(LPTSTR lpShare)
{
    BOOL bShareName = FALSE;

    lpShare += 2;   // Skip initial two slashes
    while ((!bShareName || *lpShare != TEXT('\\')) && *lpShare != TEXT('\0')) {
        if (*lpShare == TEXT('\\'))
            bShareName = TRUE;
        lpShare++;
    }

    if (*lpShare == TEXT('\\')) {
        *lpShare = TEXT('\0');
        return lpShare+1;
    }
   
    return NULL;
}


//*************************************************************
//
//  AbleToBypassCSC()
//
//  Purpose:    Try to bypass CSC using a secret api. 
//
//  Parameters: hTokenUser         -  User's token
//              lpDir              -  Roaming profile dir
//              lppCscBypassedPath -  Path name with mapped drive (OUT)
//              cpDrive            -  Mapped drive (OUT)
//
//  Return:     ERROR_SUCCESS if successful
//              Error code if an error occurs
//
//  Comments:   We will always bypass csc for roaming share. 
//              There are two reason behind this :
//                o csc mark entire server offline even if only 
//                  one share goes offline. This is a bad design 
//                  from csc perspective and they need to fix it
//                o If csc is turned on in the roaming share server
//                  then both csc and profile will try to sync files
//                  on top of one another and we will be in a inconsistent 
//                  state
//
//  History:    Date        Author     Comment
//              10/29/00    santanuc   Created
//
//*************************************************************
DWORD AbleToBypassCSC(HANDLE hTokenUser, LPCTSTR lpDir, LPTSTR *lppCscBypassedPath, TCHAR *cpDrive)
{
    NETRESOURCE     sNR;
    LPTSTR          lpShare = NULL;
    BOOL            bIsDfsConnect = FALSE, bRetValue = FALSE;
    DWORD           dwFlags = 0, dwError;
    HANDLE          hOldToken;
    WIN32_FIND_DATA fd;
    HANDLE          hResult;
    LPTSTR          lpFileName;
    BOOL            bImpersonated = FALSE;
    
    DebugMsg((DM_VERBOSE, TEXT("AbleToBypassCSC: Try to bypass CSC")));

    if (!lpDir || !IsUNCPath(lpDir) || !lppCscBypassedPath || !cpDrive) {
        return ERROR_INVALID_PARAMETER;  // Invalid argument
    }

    // Initialize
    *lppCscBypassedPath = NULL;
    memset(&sNR, 0, sizeof(NETRESOURCE));
    
    if (!ImpersonateUser(hTokenUser, &hOldToken)) {
	dwError = GetLastError();
	DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to impersonate user with %d."), dwError));
	goto Exit;
    }
    bImpersonated = TRUE;

    //
    // Construct the roaming share name
    //

    lpShare = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpDir)+1) * sizeof(TCHAR));
    if (!lpShare) {
	dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to allocate memory")));
        goto Exit;
    }

    lstrcpy(lpShare, lpDir);
    lpFileName = ConvertToShareName(lpShare);
    
    *lppCscBypassedPath = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpDir)+1) * sizeof(TCHAR));
    if (!*lppCscBypassedPath) {
	dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to allocate memory")));
        goto Exit;
    }

    // 
    // Initialize NETRESOURCE structure
    //

    sNR.dwType = RESOURCETYPE_DISK;
    sNR.lpRemoteName = lpShare;
    sNR.lpLocalName = (LPTSTR)LocalAlloc(LPTR, 3 * sizeof(TCHAR));
    if (!sNR.lpLocalName) {
	dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to allocate memory")));
        goto Exit;
    }
    sNR.lpLocalName[0] = TEXT('E');
    sNR.lpLocalName[1] = TEXT(':');
    sNR.lpLocalName[2] = TEXT('\0');

    do{
        __try {
            dwError = NPAddConnection3ForCSCAgent(NULL, &sNR, NULL, NULL, dwFlags, &bIsDfsConnect);
            DebugMsg((DM_VERBOSE, TEXT("AbleToBypassCSC: tried NPAddConnection3ForCSCAgent. Error %d"), dwError));
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Took exception in NPAddConnection3ForCSCAgent. Error %d"), dwError));
        }

        if (dwError == WN_SUCCESS || dwError == WN_CONNECTED_OTHER_PASSWORD ||
            dwError == WN_CONNECTED_OTHER_PASSWORD_DEFAULT){
            dwError = ERROR_SUCCESS;
            break;
        }
        if (sNR.lpLocalName[0]==TEXT('Z')) {
            goto Exit;
        }
        else if ((dwError == WN_BAD_LOCALNAME) || (dwError == WN_ALREADY_CONNECTED)){
            ++sNR.lpLocalName[0];
            continue;
        }
        else{
            if (GetNetworkProvider(&sNR) == ERROR_BAD_PROVIDER) {
                dwError = ERROR_BAD_PROVIDER;
            }
            goto Exit;
        }
    }while (TRUE);   

    // Succesfully bypassed CSC. Do not modify dwError in this part.
    bRetValue = TRUE;

    *cpDrive = sNR.lpLocalName[0];
    lstrcpy(*lppCscBypassedPath, sNR.lpLocalName);
    lstrcat(*lppCscBypassedPath, TEXT("\\"));
    lstrcat(*lppCscBypassedPath, lpFileName);
    DebugMsg((DM_VERBOSE, TEXT("AbleToBypassCSC: Share %s mapped to drive %c. Returned Path %s"), lpShare, sNR.lpLocalName[0], *lppCscBypassedPath));

Exit:
    
    if (lpShare) {
        LocalFree(lpShare);
    }

    if (!bRetValue && *lppCscBypassedPath) {
        LocalFree(*lppCscBypassedPath);
        *lppCscBypassedPath = NULL;
    }

    if (sNR.lpLocalName) {
        LocalFree(sNR.lpLocalName);
    }

    if (bImpersonated) {
        RevertToUser(&hOldToken);
    }

    return dwError;
}


//*************************************************************
//
//  CancelCSCBypassedConnection()
//
//  Purpose:    Release the mapped drive. 
//
//  Parameters: hTokenUser  -  User's token
//              cDrive      -  Drive letter to unmap
//
//  Return:     None
//
//  Comments:   We will always bypass csc for roaming share. 
//              There are two reason behind this :
//                o csc mark entire server offline even if only 
//                  one share goes offline. This is a bad design 
//                  from csc perspective and they need to fix it
//                o If csc is turned on in the roaming share server
//                  then both csc and profile will try to sync files
//                  on top of one another and we will be in a inconsistent 
//                  state
//
//  History:    Date        Author     Comment
//              10/29/00    santanuc   Created
//
//*************************************************************
void CancelCSCBypassedConnection(HANDLE hTokenUser, TCHAR cDrive)
{
    DWORD  dwError;
    TCHAR  szDrive[3];
    HANDLE hOldToken;

    if (!ImpersonateUser(hTokenUser, &hOldToken)) {
	dwError = GetLastError();
	DebugMsg((DM_WARNING, TEXT("CancelCSCBypassedConnection: Failed to impersonate user with %d."), dwError));
	return ;
    }

    szDrive[0] = cDrive;
    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\0');
    DebugMsg((DM_VERBOSE, TEXT("CancelCSCBypassedConnection: Cancelling connection of %s"), szDrive));

    __try {
        dwError = NPCancelConnectionForCSCAgent(szDrive, TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CancelCSCBypassedConnection: Took exception in NPCancelConnectionForCSCAgent. Error %d"), dwError));
    }

    if (dwError != WN_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CancelCSCBypassedConnection: Fail to delete connection. Error returned %d"), dwError));
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("CancelCSCBypassedConnection: Connection deleted.")));
    }

    RevertToUser(&hOldToken);

}

//*************************************************************
//
//  GetNetworkProvider()
//
//  Purpose:    Determine network provider for a share
//
//  Parameters: 
//
//  Return:     DWORD
//
//  Comments:   Returns ERROR_BAD_PROVIDER if provider is other 
//              than microsoft SMB provider otherwise return 
//              NO_ERROR.
//
//  History:    Date        Author     Comment
//              03/08/01    santanuc   Created
//
//*************************************************************
DWORD GetNetworkProvider(NETRESOURCE *psNR)
{
    PFNWNETGETRESOURCEINFORMATION  pfnWNetGetResourceInformation;
    HMODULE                        hWNetLib;
    NETRESOURCE                    dNR;
    LPBYTE                         pbBuffer = (LPBYTE)&dNR;
    DWORD                          cbBuffer = sizeof(dNR);
    DWORD                          dwError = NO_ERROR;
    LPTSTR                         lpSystem = NULL;

    if (!(hWNetLib = LoadLibrary(TEXT("mpr.dll")))) {
        DebugMsg((DM_WARNING, TEXT("GetNetworkProvider: LoadLibrary failed with %d"), GetLastError()));
        goto Exit;
    }
    pfnWNetGetResourceInformation = (PFNWNETGETRESOURCEINFORMATION)GetProcAddress(hWNetLib, "WNetGetResourceInformationW");
    if (!pfnWNetGetResourceInformation) {
        DebugMsg((DM_WARNING, TEXT("GetNetworkProvider: GetProcAddress failed with %d"), GetLastError()));
        goto Exit;
    }
        
    dwError = (*pfnWNetGetResourceInformation)(psNR, pbBuffer, &cbBuffer, &lpSystem);
    if (ERROR_MORE_DATA == dwError) {
        pbBuffer = LocalAlloc(LPTR, cbBuffer);
        if (!pbBuffer) {
	    DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to impersonate user with %d."), GetLastError()));
            goto Exit;
        }
        
        dwError = (*pfnWNetGetResourceInformation)(psNR, pbBuffer, &cbBuffer, &lpSystem);
    }

    if (NO_ERROR == dwError) {
        if (lstrcmpi(((NETRESOURCE *)pbBuffer)->lpProvider, SMB_PROVIDER) != 0) {
            dwError = ERROR_BAD_PROVIDER;
            goto Exit;
        }
    }

    dwError = NO_ERROR;

Exit:

    if (pbBuffer && (pbBuffer != (LPBYTE)&dNR)) {
        LocalFree(pbBuffer);
    }

    if (hWNetLib) {
        FreeLibrary(hWNetLib);
    }

    return dwError;
}
    
            
//*************************************************************
//
//  GetUserNameFromSid()
//
//  Purpose:    Returns the user name in domain\user format
//
//  Parameters: lpSidString - User's sid string
//
//  Return:     LPTSTR : domain\user name if succeeds
//                       lpSidString if fails
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/31/00    santanuc   Created
//
//*************************************************************
LPTSTR GetUserNameFromSid(LPTSTR lpSidString)
{
    PSID          pSidUser = NULL;
    LPTSTR        lpRetVal = lpSidString;
    TCHAR         szUserName[MAX_PATH], szDomainName[MAX_PATH];
    DWORD         dwUserSize = MAX_PATH, dwDomainSize = MAX_PATH;
    SID_NAME_USE  TypeOfAccount;

    //
    // Get the user sid
    //

    if (AllocateAndInitSidFromString(lpSidString, &pSidUser) != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameFromSid: Failed to create user sid.")));
        goto Exit;
    }

    //
    // Get the user and domain name
    //

    if (!LookupAccountSid(NULL, pSidUser, szUserName, &dwUserSize, szDomainName, &dwDomainSize, &TypeOfAccount)) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameFromSid: LookupAccountSid failed with error %d."), GetLastError()));
        goto Exit;
    }

    lpRetVal = (LPTSTR)LocalAlloc(LPTR, (lstrlen(szUserName)+lstrlen(szDomainName)+2)*sizeof(TCHAR));
    if (!lpRetVal) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameFromSid: Memory alloaction failure. error %d"), GetLastError()));
        lpRetVal = lpSidString;
        goto Exit;
    }
    
    // Construct the return string
    lstrcpy(lpRetVal, szDomainName);
    lstrcat(lpRetVal, TEXT("\\"));
    lstrcat(lpRetVal, szUserName);

Exit:
    
    if (pSidUser) {
        FreeSid(pSidUser);
    }

    return lpRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userinit\msgalias.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgalias.c

Abstract:

    This file contains routines for adding and deleting message aliases
    when a user logs on/off.

Author:

    Dan Lafferty (danl)     21-Aug-1992

Environment:

    User Mode -Win32

Revision History:

    21-Aug-1992     danl
        created

--*/
// #include <nt.h>
// #include <ntrtl.h>
// #include <nturtl.h>

#include <windows.h>


#define LPTSTR  LPWSTR
#include <lmcons.h>
#include <lmerr.h>
#include <lmmsg.h>
#include <stdlib.h>
#include <msgalias.h>



VOID
AddMsgAlias(
    LPWSTR   Username
    )

/*++

Routine Description:

    This function adds the Username to the list of message aliases.
    If unsuccessful, we don't care.

Arguments:

    Username - This is a pointer to a unicode Username.

Return Value:

    none.

--*/
{
    HANDLE          dllHandle;
    PMSG_NAME_ADD   NetMessageNameAdd = NULL;


    dllHandle = LoadLibraryW(L"netapi32.dll");
    if (dllHandle != NULL) {


        NetMessageNameAdd = (PMSG_NAME_ADD) GetProcAddress(
                                dllHandle,
                                "NetMessageNameAdd");


        if (NetMessageNameAdd != NULL) {
            NetMessageNameAdd(NULL,Username);
        }
        FreeLibrary(dllHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userinit\helpmsg.c ===
//
// html help messagebox, requires to be linked with htmlhelp.lib.
//
#include "userinit.h"

#include <Htmlhelp.h>
#pragma warning(push, 4)


LPTSTR MSGPARENT_WINDOWCLASS = TEXT("MessageHelpWndClass");

LRESULT CALLBACK MessageHelpWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static LPTSTR szHelpFile = NULL;
    switch (message)
    {
    case WM_HELP:
        HtmlHelp(hWnd, szHelpFile, HH_DISPLAY_TOPIC, 0);
        return TRUE;
        break;
    case WM_CREATE:
        szHelpFile = (LPTSTR)((LPCREATESTRUCT)lParam)->lpCreateParams;
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
}


ATOM RegisterHelpMessageClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;
    ZeroMemory(&wcex, sizeof(WNDCLASSEX));

    wcex.cbSize         = sizeof(WNDCLASSEX);
    wcex.hInstance		= hInstance;
	wcex.lpszClassName	= MSGPARENT_WINDOWCLASS;
    wcex.lpfnWndProc	= (WNDPROC)MessageHelpWndProc;

	return RegisterClassEx(&wcex);
}



int HelpMessageBox(
  HINSTANCE hInst,
  HWND hWnd,          // handle to owner window
  LPCTSTR lpText,     // text in message box
  LPCTSTR lpCaption,  // message box title
  UINT uType,         // message box style
  LPTSTR szHelpLine
)
{
    if (!(uType & MB_HELP) || !szHelpLine)
    {
        return MessageBox(hWnd, lpText, lpCaption, uType);
    }
    else
    {
        HWND hWndParent;
        int iReturn;

        //
        // create a window which will process the help message
        //
        RegisterHelpMessageClass(hInst);
        hWndParent = CreateWindow(
                MSGPARENT_WINDOWCLASS,
                NULL,
                WS_OVERLAPPEDWINDOW,
                0,
                0,
                0,
                0,
                hWnd,
                NULL,
                hInst,
                szHelpLine
                );

        iReturn = MessageBox(hWndParent, lpText, lpCaption, uType);
        DestroyWindow(hWndParent);
        return iReturn;
    }
}
#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userinit\stringid.h ===
/****************************** Module Header ******************************\
* Module Name: stringid.h
*
* Copyright (c) 1991-1993, Microsoft Corporation
*
* Defines resource ids
*
* History:
* 15-03-93 andreva      Created.
\***************************************************************************/

//
// Strings
//

#define IDS_INVALID_DISPLAY        1600
#define IDS_VMAPPLET               1601
#define IDS_DISPLAYAPPLET          1602
#define IDS_FAILING_WORKINGDIR     1603
#define IDS_FAILING_SHELLCOMMAND   1604
#define IDS_ERROR_WORKINGDIR       1605
#define IDS_ERROR_SHELLCOMMAND     1606
#define IDS_ERROR_SHELL_FAILED     1607
#define IDS_LOGON_FAILED           1608
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\wlballoon\debug.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File   : Debug.h

  Content: Global debug facilities.

  History: 03-22-2001   dsie     created

------------------------------------------------------------------------------*/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DBG
#include <shlwapi.h>
void DebugTrace(LPCSTR pszFormat, ...)
{
    va_list arglist;
    char szBuffer[512]  = "";
    char szMessage[640] = "[Wlballoon] - ";

    va_start(arglist, pszFormat);
    if (0 < wvnsprintfA(szBuffer, sizeof(szBuffer), pszFormat, arglist))
    {
        lstrcatA(szMessage, szBuffer);
        OutputDebugStringA(szMessage);
    }
    va_end(arglist);

    return;
}
#else
inline void DebugTrace(LPCSTR pszFormat, ...) {};
#endif

#ifdef WLBALLOON_PRIVATE_DEBUG
void PrivateDebugTrace(LPCSTR pszFormat, ...)
{
    va_list arglist;
    char szBuffer[512]  = "";
    char szMessage[640] = "[Wlballoon] - ";

    va_start(arglist, pszFormat);
    if (0 < wvnsprintfA(szBuffer, sizeof(szBuffer), pszFormat, arglist))
    {
        lstrcatA(szMessage, szBuffer);
        OutputDebugStringA(szMessage);
    }
    va_end(arglist);

    return;
}
#else
inline void PrivateDebugTrace(LPCSTR pszFormat, ...) {};
#endif


#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userinit\userinit.h ===
/****************************** Module Header ******************************\
* Module Name: userinit.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Main header file for userinit
*
* History:
* 21-Aug-92 Davidc       Created.
\***************************************************************************/


#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winstaw.h>
#include <wincrypt.h>
#include <autoenr.h>

//
// Memory macros
//

#define Alloc(c)        ((PVOID)LocalAlloc(LPTR, c))
#define ReAlloc(p, c)   ((PVOID)LocalReAlloc(p, c, LPTR | LMEM_MOVEABLE))
#define Free(p)         ((VOID)LocalFree(p))


//
// Define a debug print routine
//

#define UIPrint(s)  KdPrint(("USERINIT: ")); \
                    KdPrint(s);            \
                    KdPrint(("\n"));

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

//
// Define the path environment variable
//

#define PATH                   TEXT("PATH")

//
//
// GetProcAddr Prototype for winsta.dll function WinStationQueryInformationW
//

typedef BOOLEAN (*PWINSTATION_QUERY_INFORMATION) (
                    HANDLE hServer,
                    ULONG SessionId,
                    WINSTATIONINFOCLASS WinStationInformationClass,
                    PVOID  pWinStationInformation,
                    ULONG WinStationInformationLength,
                    PULONG  pReturnLength
                    );

typedef void (*PTERMSRCHECKNEWINIFILES) (void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userinit\msgalias.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgalias.h

Abstract:

    Prototypes for function that adds message aliases.

Author:

    Dan Lafferty (danl)     28-Oct-1992

Environment:

    User Mode -Win32

Revision History:

    28-Oct-1992     danl
        created

--*/

//
// GetProcAddr Prototypes
//

typedef DWORD   (*PMSG_NAME_ADD) (
                    LPWSTR servername,
                    LPWSTR msgname
                    );

//
// Function Prototypes
//


VOID
AddMsgAlias(
    LPWSTR   Username
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\acui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       acui.h
//
//  Contents:   Authenticode User Interface Provider Definitions
//
//              This is an internal provider interface used by the
//              Authenticode Policy Provider to allow user interaction
//              in determining trust.  This will allow us to replace the
//              UI (including possibly having no UI) and not affect the
//              core Authenticode policy provider.
//
//  History:    08-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ACUI_H__)
#define __ACUI_H__

#include <windows.h>
#include <wintrust.h>
#include <softpub.h>

#if defined(__cplusplus)
extern "C" {
#endif

//
// ACUI_INVOKE_INFO
//
// This structure gives enough information for the provider to invoke the
// appropriate UI. It includes the following data
//
// Window Handle for display
//
// Generic Policy Info (see gentrust.h, note it includes the cert. chain)
//
// SPC SP Opus Information (see authcode.h)
//
// Alternate display name of the subject in case the Opus does not have it
//
// Invoke Reason Code
//     hr == S_OK, the subject is trusted does the user want to override
//     hr != S_OK, the subject is not trusted does the user want to override
//
// Personal Trust database interface
//

typedef struct _ACUI_INVOKE_INFO {

    DWORD                   cbSize;
    HWND                    hDisplay;
    CRYPT_PROVIDER_DATA     *pProvData;
    PSPC_SP_OPUS_INFO       pOpusInfo;
    LPCWSTR                 pwcsAltDisplayName;
    HRESULT                 hrInvokeReason;
    IUnknown*               pPersonalTrustDB;

} ACUI_INVOKE_INFO, *PACUI_INVOKE_INFO;

//
// ACUIProviderInvokeUI
//
// This is the entry point used by authenticode to invoke the provider UI. The
// input is an ACUI_INVOKE_INFO pointer and the return code is an HRESULT which
// is interpreted as follows
//
// hr == S_OK, the subject is trusted
// hr == TRUST_E_SUBJECT_NOT_TRUSTED, the subject is NOT trusted
// Otherwise, some other error has occurred, authenticode is free to do
// what it wants.
//

typedef HRESULT (WINAPI *pfnACUIProviderInvokeUI) (
                                        PACUI_INVOKE_INFO pInvokeInfo
                                        );

HRESULT WINAPI ACUIProviderInvokeUI (PACUI_INVOKE_INFO pInvokeInfo);

//
// NOTENOTE: It is still TBD how UI providers will be registered and loaded
//           by Authenticode.  For now, it will always load a hardcoded
//           default provider and look for the ACUIProviderInvokeUI entry
//           point.
//

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\wlballoon\wlballoon.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Wlballoon.cpp

  Content: Implementation of the notification balloon class.

  History: 03-22-2001   dsie     created

------------------------------------------------------------------------------*/

#pragma warning (disable: 4100)
#pragma warning (disable: 4706)


////////////////////
//
// Include
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winwlx.h>
#include <shobjidl.h>
#include <shellapi.h>

#include "debug.h"
#include "wlballoon.rh"


////////////////////
//
// Defines
//

#define MAX_RESOURCE_STRING_SIZE                    512
#define IQUERY_CANCEL_INTERVAL                      (10 * 1000)
#define BALLOON_SHOW_TIME                           (15 * 1000)
#define BALLOON_SHOW_INTERVAL                       (2 * 60 * 1000)
#define BALLOON_RESHOW_COUNT                        (0)
#define LOGOFF_NOTIFICATION_EVENT_NAME              L"Local\\WlballoonLogoffNotificationEventName"
#define KERBEROS_NOTIFICATION_EVENT_NAME            L"WlballoonKerberosNotificationEventName"


////////////////////
//
// Classes
//

class CBalloon : IQueryContinue
{
public:
    CBalloon(HANDLE hEvent);
    ~CBalloon();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();       // S_OK -> Continue, otherwise S_FALSE

    STDMETHODIMP ShowBalloon(HWND hWnd, HINSTANCE hInstance);

private:
    LONG    m_cRef;
    HANDLE  m_hEvent;
};


class CNotify
{
public:
    CNotify();
    ~CNotify();

    DWORD RegisterNotification(LPWSTR pwszLogoffEventName, LPWSTR pwszKerberosEventName);
    DWORD UnregisterNotification();

private:
    HANDLE  m_hWait;
    HANDLE  m_hThread;
    HANDLE  m_hLogoffEvent;
    HANDLE  m_hKerberosEvent;
    WCHAR   m_wszKerberosEventName[MAX_PATH];

    static VOID CALLBACK RegisterWaitCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired);
    static DWORD WINAPI NotifyThreadProc(PVOID lpParameter);
};


////////////////////
//
// Typedefs
//
typedef struct
{
  HANDLE	    hWait;
  HANDLE	    hEvent;
  HMODULE       hModule;
  CNotify *     pNotify;
} LOGOFFDATA, * PLOGOFFDATA;


#if (0) //DSIE: Bug 407941
//+----------------------------------------------------------------------------
//
// BalloonDialog
//
//-----------------------------------------------------------------------------

INT_PTR CALLBACK BalloonDialog(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            RECT rect;

            if (GetWindowRect(hwndDlg, &rect))
            {
	            int wx = (GetSystemMetrics(SM_CXSCREEN) - (rect.right - rect.left)) / 2;
	            int wy = (GetSystemMetrics(SM_CYSCREEN) - (rect.bottom - rect.top)) / 2;
	            
                if (wx > 0 && wy > 0)
                {
                    SetWindowPos(hwndDlg, NULL, wx, wy, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
                }
            }

            return TRUE;
        }

        case WM_CLOSE:
        {
            EndDialog(hwndDlg, IDOK);
            return TRUE;
        }
        
        case WM_COMMAND:
        {
            if (IDOK == LOWORD(wParam))
            {
                EndDialog(hwndDlg, IDOK);
                return TRUE;
            }

            break;
        }
 
        default:
        {
            break;
        }
    }

    return FALSE;
}
#endif


//+----------------------------------------------------------------------------
//
// CBalloon
//
//-----------------------------------------------------------------------------

CBalloon::CBalloon(HANDLE hEvent)
{
    m_cRef   = 1;
    m_hEvent = hEvent;
}


//+----------------------------------------------------------------------------
//
// ~CBalloon
//
//-----------------------------------------------------------------------------

CBalloon::~CBalloon()
{
    ASSERT(m_hEvent);

    CloseHandle(m_hEvent);

    return;
}


//+----------------------------------------------------------------------------
//
// QueryInterface 
//
//-----------------------------------------------------------------------------

HRESULT CBalloon::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IQueryContinue))
    {
        *ppv = static_cast<IQueryContinue *>(this);
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
// AddRef
//
//-----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBalloon::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


//+----------------------------------------------------------------------------
//
// Release 
//
//-----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBalloon::Release()
{
    if (InterlockedDecrement(&m_cRef))
    {
        return m_cRef;
    }

    delete this;

    return 0;
}


//+----------------------------------------------------------------------------
//
// QueryContinue 
//
//-----------------------------------------------------------------------------

STDMETHODIMP CBalloon::QueryContinue()
{
    ASSERT(m_hEvent);

    switch (WaitForSingleObject(m_hEvent, 0))
    {
        case WAIT_OBJECT_0:
            DebugTrace("Info: Kerberos event is still signaled, continue to show notification balloon.\n");
            return S_OK;

        case WAIT_TIMEOUT:
            DebugTrace("Info: Kerberos event has been reset, dismissing notification balloon.\n");
            return S_FALSE;

        case WAIT_FAILED:

        default:
            DebugTrace("Error [%#x]: WaitForSingleObject() failed, dismissing notification balloon.\n", GetLastError());
            break;
    }
 
    return E_FAIL;
}


//+----------------------------------------------------------------------------
//
// ShowBalloon
//
//-----------------------------------------------------------------------------

STDMETHODIMP CBalloon::ShowBalloon(HWND hWnd, HINSTANCE hInstance)
{
    HRESULT             hr                                 = S_OK;
    BOOL                bCoInitialized                     = FALSE;
    HICON               hIcon                              = NULL;
    WCHAR               wszTitle[MAX_RESOURCE_STRING_SIZE] = L"";
    WCHAR               wszText[MAX_RESOURCE_STRING_SIZE]  = L"";
    IUserNotification * pIUserNotification                 = NULL;

    PrivateDebugTrace("Entering CBalloon::ShowBalloon.\n");

    ASSERT(m_hEvent);
    ASSERT(hInstance);

    if (FAILED(hr = CoInitialize(NULL)))
    {
        DebugTrace("Error [%#x]: CoInitialize() failed.\n", hr);
        goto ErrorReturn;
    }

    bCoInitialized = TRUE;

    if (FAILED(hr = CoCreateInstance(CLSID_UserNotification,
                                     NULL,
                                     CLSCTX_ALL,
                                     IID_IUserNotification,
                                     (void **) &pIUserNotification)))
    {
        DebugTrace("Error [%#x]: CoCreateInstance() failed.\n", hr);
        goto ErrorReturn;
    }

    if (FAILED(hr = pIUserNotification->SetBalloonRetry(BALLOON_SHOW_TIME, 
                                                        BALLOON_SHOW_INTERVAL, 
                                                        BALLOON_RESHOW_COUNT)))
    {
        DebugTrace("Error [%#x]: pIUserNotification->SetBalloonRetry() failed.\n", hr);
        goto ErrorReturn;
    }

    if (NULL == (hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_KERBEROS_TICKET))))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace("Error [%#x]: LoadIcon() failed for IDI_KERBEROS_TICKET.\n", hr);
        goto ErrorReturn;
    }

    if (!LoadStringW(hInstance, IDS_BALLOON_TIP, wszText, MAX_RESOURCE_STRING_SIZE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_TIP.\n", hr);
        goto ErrorReturn;
    }
    
    if (FAILED(hr = pIUserNotification->SetIconInfo(hIcon, wszText)))
    {
        DebugTrace("Error [%#x]: pIUserNotification->SetIconInfo() failed.\n", hr);
        goto ErrorReturn;
    }

    if (!LoadStringW(hInstance, IDS_BALLOON_TITLE, wszTitle, MAX_RESOURCE_STRING_SIZE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_TITLE.\n", hr);
        goto ErrorReturn;
    }
    
    if (!LoadStringW(hInstance, IDS_BALLOON_TEXT, wszText, MAX_RESOURCE_STRING_SIZE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_TEXT.\n", hr);
        goto ErrorReturn;
    }

    if (FAILED(hr = pIUserNotification->SetBalloonInfo(wszTitle, wszText, NIIF_ERROR)))
    {
        DebugTrace("Error [%#x]: pIUserNotification->SetBalloonInfo() failed.\n", hr);
        goto ErrorReturn;
    }

    if (FAILED(hr = pIUserNotification->Show(static_cast<IQueryContinue *>(this), IQUERY_CANCEL_INTERVAL)))
    {
        DebugTrace("Error [%#x]: pIUserNotification->Show() failed.\n", hr);
        goto ErrorReturn;
    }

CommonReturn:

    if (hIcon)
    {
        DestroyIcon(hIcon);
    }

    if (pIUserNotification)
    {
        pIUserNotification->Release();
    }

    if (bCoInitialized)
    {
        CoUninitialize();
    }

    PrivateDebugTrace("Leaving CBalloon::ShowBalloon().\n");

    return hr;

ErrorReturn:

    ASSERT(hr != S_OK);

    goto CommonReturn;
}


//+----------------------------------------------------------------------------
//
// Function : ShowNotificationBalloonW
//
// Synopsis : Display the notification balloon periodically until the specified
//            event is reset.
//
// Parameter: HWND      hWnd
//            HINSTANCE hInstance
//            LPWSTR    lpwszCommandLine - Event name
//            int       nCmdShow
//
// Return   : None.
//
// Remarks  : This function is intended to be called through RunDll32 from
//            Winlogon. The reason we put these in wlnotify.dll is to save
//            distributing another EXE.
//
//            Sample calling command line:
//
//            RunDll32 wlnotify.dll,ShowNotificationBalloon EventName
//
//-----------------------------------------------------------------------------

void CALLBACK ShowNotificationBalloonW(HWND      hWnd,
                                       HINSTANCE hInstance,
                                       LPWSTR    lpwszCommandLine,
                                       int       nCmdShow)
{
    HRESULT    hr             = S_OK;
    HANDLE     hLogoffEvent   = NULL;
    HANDLE     hKerberosEvent = NULL;
    HMODULE    hModule        = NULL;
    CBalloon * pBalloon       = NULL;

    PrivateDebugTrace("Entering ShowNotificationBalloonW().\n");

    if (NULL == (hModule = LoadLibraryW(L"wlnotify.dll")))
    {
        DebugTrace("Error [%#x]: LoadLibraryW() failed for wlnotify.dll.\n", GetLastError());
        goto ErrorReturn;
     }

    if (NULL == lpwszCommandLine)
    {
        DebugTrace("Error [%#x]: invalid argument, lpwszCommandLine is NULL.\n", E_INVALIDARG);
        goto ErrorReturn;
    }

    if (NULL == (hLogoffEvent = OpenEventW(SYNCHRONIZE, FALSE, LOGOFF_NOTIFICATION_EVENT_NAME)))
    {
        DebugTrace("Error [%#x]: OpenEventW() failed for event %S.\n", GetLastError(), LOGOFF_NOTIFICATION_EVENT_NAME);
        goto ErrorReturn;
    }

    if (NULL == (hKerberosEvent = OpenEventW(EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE, lpwszCommandLine)))
    {
        DebugTrace("Error [%#x]: OpenEventW() failed for event %S.\n", GetLastError(), lpwszCommandLine);
        goto ErrorReturn;
    }

    if (NULL == (pBalloon = new CBalloon(hKerberosEvent)))
    {
        DebugTrace("Error [%#x]: new CBalloon() failed.\n", E_OUTOFMEMORY);
        goto ErrorReturn;
    }

    if (WAIT_OBJECT_0 == WaitForSingleObject(hKerberosEvent, 0)) 
    {
        if (S_OK == (hr = pBalloon->ShowBalloon(NULL, hModule)))
        {
            WCHAR wszTitle[MAX_RESOURCE_STRING_SIZE] = L"";
            WCHAR wszText[MAX_RESOURCE_STRING_SIZE]  = L"";

            DebugTrace("Info: User clicked on icon.\n");

#if (0) //DSIE: Bug 407941
            DialogBoxParamW(hModule, 
                            (LPCWSTR) MAKEINTRESOURCEW(IDD_BALLOON_DIALOG), 
                            hWnd, 
                            BalloonDialog,
                            (LPARAM) hModule);
#else
            if (!LoadStringW(hModule, IDS_BALLOON_DIALOG_TITLE, wszTitle, sizeof(wszTitle) / sizeof(wszTitle[0])))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_DIALOG_TITLE.\n", hr);
                goto CommonReturn;  // hKerberosEvent will be closed in CBalloon destructor
            }

            if (!LoadStringW(hModule,
                GetSystemMetrics(SM_REMOTESESSION) ? IDS_BALLOON_DIALOG_TS_TEXT : IDS_BALLOON_DIALOG_TEXT,
                wszText, sizeof(wszText) / sizeof(wszText[0])))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_DIALOG_TEXT.\n", hr);
                goto CommonReturn;  // hKerberosEvent will be closed in CBalloon destructor
            }

            MessageBoxW(hWnd, wszText, wszTitle, MB_OK | MB_ICONERROR);
#endif
        }
        else if (S_FALSE == hr)
        {
            DebugTrace("Info: IQueryContinue cancelled the notification.\n");
        }
        else if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)
        {
            DebugTrace("Info: Balloon icon timed out.\n");
        }
        else
        {
            SetEvent(hLogoffEvent);
            DebugTrace("Error [%#x]: pBalloon->ShowBalloon() failed.\n", hr);
        }

        ResetEvent(hKerberosEvent);
    }   

CommonReturn:

    if (hLogoffEvent)
    {
        CloseHandle(hLogoffEvent);
    }

    if (pBalloon)
    {
        pBalloon->Release();
    }

    if (hModule)
    {
        FreeLibrary(hModule);
    }

    PrivateDebugTrace("Leaving ShowNotificationBalloonW().\n");

    return;

ErrorReturn:

    if (hKerberosEvent)
    {
        CloseHandle(hKerberosEvent);
    }

    goto CommonReturn;
}


//+----------------------------------------------------------------------------
//
// CNotify
//
//-----------------------------------------------------------------------------

CNotify::CNotify()
{
    m_hWait                   = NULL;
    m_hThread                 = NULL;
    m_hLogoffEvent            = NULL;
    m_hKerberosEvent          = NULL;
    m_wszKerberosEventName[0] = L'\0';
}


//+----------------------------------------------------------------------------
//
// ~CNotify
//
//-----------------------------------------------------------------------------

CNotify::~CNotify()
{
    if (m_hWait)
    {
        UnregisterWait(m_hWait);
    }

    if (m_hThread)
    {
        CloseHandle(m_hThread);
    }

    if (m_hLogoffEvent)
    {
        CloseHandle(m_hLogoffEvent);
    }

    if (m_hKerberosEvent)
    {
        CloseHandle(m_hKerberosEvent);
    }

    return;
}


//+----------------------------------------------------------------------------
//
// RegisterNotification
//
// To register and wait for the Kerberos notification event. When the event is 
// signaled, a ticket icon and balloon will appear in the systray to warn the 
// user about the problem, and suggest them to lock and then unlock the machine 
// with their new password.
//
//-----------------------------------------------------------------------------

DWORD CNotify::RegisterNotification(LPWSTR pwszLogoffEventName, LPWSTR pwszKerberosEventName)
{
    DWORD  dwRetCode  = 0;

    PrivateDebugTrace("Entering CNotify::RegisterNotification().\n");

    if (NULL == pwszLogoffEventName ||
        NULL == pwszKerberosEventName || 
        MAX_PATH < lstrlenW(pwszKerberosEventName))
    {
        dwRetCode = (DWORD) E_INVALIDARG;
        DebugTrace("Error [%#x]: invalid argument.\n", dwRetCode);
        goto ErrorReturn;
    }

    if (NULL == (m_hLogoffEvent = OpenEventW(SYNCHRONIZE, FALSE, pwszLogoffEventName)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: OpenEventW() failed for event %S.\n", dwRetCode, pwszLogoffEventName);
        goto ErrorReturn;
    }

    if (NULL == (m_hKerberosEvent = CreateEventW(NULL, TRUE, FALSE, pwszKerberosEventName)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: CreateEventW() failed for event %S.\n", dwRetCode, pwszKerberosEventName);
        goto ErrorReturn;
    }

    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        dwRetCode = ERROR_SINGLE_INSTANCE_APP;
        DebugTrace("Error [%#x]: cannot run more than one instance of this code per unique event.\n", dwRetCode);
        goto ErrorReturn;
    }

    lstrcpyW(&m_wszKerberosEventName[0], pwszKerberosEventName);

    if (!RegisterWaitForSingleObject(&m_hWait,
                                     m_hKerberosEvent,
                                     CNotify::RegisterWaitCallback,
                                     (PVOID) this,
                                     INFINITE,
                                     WT_EXECUTEONLYONCE))
    {
        dwRetCode = (DWORD) E_UNEXPECTED;
        DebugTrace("Unexpected error: RegisterWaitForSingleObject() failed.\n");
        goto ErrorReturn;
    }

CommonReturn:

    PrivateDebugTrace("Leaving CNotify::RegisterNotification().\n");

    return dwRetCode;

ErrorReturn:

    ASSERT(0 != dwRetCode);

    if (m_hWait)
    {
        UnregisterWait(m_hWait);
        m_hWait = NULL;
    }

    if (m_hLogoffEvent)
    {
        CloseHandle(m_hLogoffEvent);
        m_hLogoffEvent = NULL;
    }
  
    if (m_hKerberosEvent)
    {
        CloseHandle(m_hKerberosEvent);
        m_hKerberosEvent = NULL;
    }
  
    goto CommonReturn;
}


//+----------------------------------------------------------------------------
//
// UnregisterNotification
//
// Unregister the Kerberos notification wait event registered by 
// RegisterNotification().
//
//-----------------------------------------------------------------------------

DWORD CNotify::UnregisterNotification()
{
    DWORD dwRetCode = 0;

    PrivateDebugTrace("Entering CNotify::UnregisterNotification().\n");

    ResetEvent(m_hKerberosEvent);
 
    if (m_hThread)
    {
        WaitForSingleObject(m_hThread, INFINITE);
    }

    PrivateDebugTrace("Leaving CNotify::UnregisterNotification().\n");

    return dwRetCode;
}


//+----------------------------------------------------------------------------
//
// RegisterWaitCallback
//
//-----------------------------------------------------------------------------

VOID CALLBACK CNotify::RegisterWaitCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
{
    DWORD     dwThreadId = 0;
    CNotify * pNotify    = NULL;

    PrivateDebugTrace("Entering CNotify::RegisterWaitCallback().\n");

    (void) TimerOrWaitFired;
    
    ASSERT(lpParameter);

    pNotify = (CNotify *) lpParameter;

    if (NULL == (pNotify->m_hThread = CreateThread(NULL,
                                                   0,
                                                   (LPTHREAD_START_ROUTINE) CNotify::NotifyThreadProc,
                                                   lpParameter,
                                                   0,
                                                   &dwThreadId)))
    {
        ResetEvent(pNotify->m_hKerberosEvent);

        DebugTrace("Error [%#x]: CreateThread() for NotifyThreadProc failed.\n", GetLastError());
    }

    PrivateDebugTrace("Leaving CNotify::RegisterWaitCallback().\n");

    return;
}


//+----------------------------------------------------------------------------
//
// NotifyThreadProc
//
//-----------------------------------------------------------------------------

DWORD WINAPI CNotify::NotifyThreadProc(PVOID lpParameter)
{

    DWORD               dwRetCode                    = 0;
    WCHAR               wszDllPath[MAX_PATH]         = L"";
    WCHAR               wszCommandLine[MAX_PATH * 2] = L"RunDll32.exe ";
    CNotify           * pNotify                      = NULL;
    STARTUPINFOW        si;
    PROCESS_INFORMATION pi;

    PrivateDebugTrace("Entering CNotify::NotifyThreadProc().\n");

    ASSERT(lpParameter);

    pNotify = (CNotify *) lpParameter;

    ASSERT(pNotify->m_hWait);
    ASSERT(pNotify->m_hLogoffEvent);
    ASSERT(pNotify->m_hKerberosEvent);
    ASSERT(lstrlenW(pNotify->m_wszKerberosEventName));

    ExpandEnvironmentStringsW(L"%SystemRoot%\\system32\\wlnotify.dll", wszDllPath, MAX_PATH);
    lstrcatW(wszCommandLine, wszDllPath);
    lstrcatW(wszCommandLine, L",ShowNotificationBalloon ");
    lstrcatW(wszCommandLine, pNotify->m_wszKerberosEventName);

    ZeroMemory(&pi, sizeof(pi));
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.lpDesktop = L"WinSta0\\Default";

    if (!CreateProcessW(NULL, 
                        wszCommandLine,
                        NULL,
                        NULL,
                        FALSE,
                        0,
                        NULL,
                        NULL,
                        &si,
                        &pi))
    {
        dwRetCode = GetLastError();
        DebugTrace( "Error [%#x]: CreateProcessW() failed.\n", dwRetCode);
        goto ErrorReturn;
    }
    
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    switch (WaitForSingleObject(pNotify->m_hLogoffEvent, 0))
    {
        case WAIT_OBJECT_0:
        {
            DebugTrace("Info: Logoff event is signaled, so skip register wait for callback.\n");
            break;
        }

        case WAIT_TIMEOUT:
        {
            HANDLE hThread = pNotify->m_hThread;

            pNotify->m_hThread = NULL;
            CloseHandle(hThread);

            if (!RegisterWaitForSingleObject(&pNotify->m_hWait,
                                             pNotify->m_hKerberosEvent,
                                             CNotify::RegisterWaitCallback,
                                             lpParameter,
                                             INFINITE,
                                             WT_EXECUTEONLYONCE))
            {
                dwRetCode = (DWORD) E_UNEXPECTED;
                DebugTrace("Error [%#x]: RegisterWaitForSingleObject() failed.\n", dwRetCode);
                goto ErrorReturn;
            }

            DebugTrace("Info: Logoff event is not signaled, so continue to register wait for callback.\n");
            break;
        }

        default:
        {
            dwRetCode = GetLastError();
            DebugTrace("Error [%#x]: WaitForSingleObject() failed.\n", dwRetCode);
            goto ErrorReturn;
        }
    }

CommonReturn:

    PrivateDebugTrace("Leaving CNotify::NotifyThreadProc().\n");
   
    return dwRetCode;

ErrorReturn:

    ASSERT(0 != dwRetCode);

    goto CommonReturn;

}


//+----------------------------------------------------------------------------
//
// CreateNotificationEventName
//
//-----------------------------------------------------------------------------

LPWSTR CreateNotificationEventName(LPWSTR pwszSuffixName)
{
    DWORD  dwRetCode       = 0;
    DWORD  cb              = 0;
    TOKEN_STATISTICS stats;
    HANDLE hThreadToken    = NULL;

    LPWSTR pwszEventName   = NULL;
    WCHAR  wszPrefixName[] = L"Global\\";
    WCHAR  wszLuid[20]     = L"";
    WCHAR  wszSeparator[]  = L"_";

    PrivateDebugTrace("Entering CreateNotificationEventName().\n");

    if (NULL == pwszSuffixName)
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken))
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hThreadToken))
        {
            dwRetCode = GetLastError();
            DebugTrace("Error [%#x]: OpenProcessToken() failed.\n", dwRetCode);
            goto CLEANUP;
        }                  
    }

    if (!GetTokenInformation(hThreadToken, TokenStatistics, &stats, sizeof(stats), &cb))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: GetTokenInformation() failed.\n", dwRetCode);
        goto CLEANUP;
    }

    wsprintfW(wszLuid, L"%08x%08x", stats.AuthenticationId.HighPart, stats.AuthenticationId.LowPart);

    if (NULL == (pwszEventName = (LPWSTR) malloc((lstrlenW(wszPrefixName) + 
                                                  lstrlenW(wszLuid) + 
                                                  lstrlenW(wszSeparator) +
                                                  lstrlenW(pwszSuffixName) + 1) * sizeof(WCHAR))))
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace("Error: out of memory.\n");
        goto CLEANUP;
    }

    lstrcpyW(pwszEventName, wszPrefixName);
    lstrcatW(pwszEventName, wszLuid);
    lstrcatW(pwszEventName, wszSeparator);
    lstrcatW(pwszEventName, pwszSuffixName);

CLEANUP:

    if (NULL != hThreadToken)
    {
        CloseHandle(hThreadToken);
    }

    PrivateDebugTrace("Leaving CreateNotificationEventName().\n");

    SetLastError(dwRetCode);

    return pwszEventName;
}


//+----------------------------------------------------------------------------
//
// LogoffThreadProc
//
//-----------------------------------------------------------------------------

DWORD WINAPI LogoffThreadProc(PVOID lpParameter)
{
    HMODULE     hModule = NULL;
    PLOGOFFDATA pLogoffData;

    PrivateDebugTrace("Entering LogoffThreadProc().\n");

    ASSERT(lpParameter);

    if (pLogoffData = (PLOGOFFDATA) lpParameter)
    {
        if (pLogoffData->hWait)
        {
           UnregisterWait(pLogoffData->hWait);
        }

        if (pLogoffData->pNotify)
        {
            pLogoffData->pNotify->UnregisterNotification();

            delete pLogoffData->pNotify;
        }

        if (pLogoffData->hEvent)
        {
            CloseHandle(pLogoffData->hEvent);
        }

        if (pLogoffData->hModule) 
        {
            hModule = pLogoffData->hModule;
        }

        LocalFree(pLogoffData);
    }

    PrivateDebugTrace("Leaving LogoffThreadProc().\n");

    if (hModule)
    {
        FreeLibraryAndExitThread(hModule, 0);
    }

    return 0;
}


//+----------------------------------------------------------------------------
//
// LogoffWaitCallback
//
//-----------------------------------------------------------------------------

VOID CALLBACK LogoffWaitCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
{
    PLOGOFFDATA pLogoffData;

    PrivateDebugTrace("Entering LogoffWaitCallback().\n");

    (void) TimerOrWaitFired;

    ASSERT(lpParameter);

    if (pLogoffData = (PLOGOFFDATA) lpParameter)
    {
        DWORD  dwThreadId = 0;
        HANDLE hThread    = NULL;
        
        if (hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) LogoffThreadProc,
                                   lpParameter,
                                   0,
                                   &dwThreadId))
        {
            CloseHandle(hThread);
        }
        else
        {
            DebugTrace("Error [%#x]: CreateThread() for LogoffThreadProc failed.\n", GetLastError());
        }
    }

    PrivateDebugTrace("Leaving LogoffWaitCallback().\n");
    
    return;
}


//+----------------------------------------------------------------------------
//
// Public
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function : RegisterTicketExpiredNotificationEvent
//
// Synopsis : To register and wait for the Kerberos notification event. When the 
//            event is signaled, a ticket icon and balloon will appear in the 
//            systray to warn the user about the problem, and suggest them to 
//            lock and then unlock the machine with their new password.
//
// Parameter: PWLX_NOTIFICATION_INFO pNotificationInfo
//
// Return   : If the function succeeds, zero is returned.
// 
//            If the function fails, a non-zero error code is returned.
//
// Remarks  : This function should only be called by Winlogon LOGON 
//            notification mechanism with the Asynchronous and Impersonate
//            flags set to 1.
//
//            Also for each RegisterKerberosNotificationEvent() call, a
//            pairing call by Winlogon LOGOFF notification mechanism to 
//            UnregisterKerberosNotificationEvent() must be made at the 
//            end of each logon session.
//
//-----------------------------------------------------------------------------

DWORD WINAPI RegisterTicketExpiredNotificationEvent(PWLX_NOTIFICATION_INFO pNotificationInfo)
{
    DWORD        dwRetCode             = 0;
    LPWSTR       pwszLogoffEventName   = LOGOFF_NOTIFICATION_EVENT_NAME;
    LPWSTR       pwszKerberosEventName = NULL;
    PLOGOFFDATA  pLogoffData           = NULL;

    PrivateDebugTrace("Entering RegisterTicketExpiredNotificationEvent().\n");

    if (NULL == (pLogoffData = (PLOGOFFDATA) LocalAlloc(LPTR, sizeof(LOGOFFDATA))))
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace("Error [%#x]: out of memory.\n", dwRetCode);
        goto ErrorReturn;
     }
    ZeroMemory(pLogoffData, sizeof(LOGOFFDATA));

    if (NULL == (pLogoffData->hEvent = CreateEventW(NULL, TRUE, FALSE, pwszLogoffEventName)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: CreateEventW() failed for event %S.\n", dwRetCode, pwszLogoffEventName);
        goto ErrorReturn;
    }

    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        dwRetCode = ERROR_SINGLE_INSTANCE_APP;
        DebugTrace("Error [%#x]: cannot run more than one instance of this code per session.\n", dwRetCode);
        goto ErrorReturn;
    }

    DebugTrace("Info: Logoff event name = %S.\n", pwszLogoffEventName);

    if (NULL == (pwszKerberosEventName = CreateNotificationEventName(KERBEROS_NOTIFICATION_EVENT_NAME)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: CreateNotificationEventName() failed.\n", dwRetCode);
        goto ErrorReturn;
    }

    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        dwRetCode = ERROR_INTERNAL_ERROR;
        DebugTrace("Internal error [%#x]: Kerberos event already exists.\n", dwRetCode);
        goto ErrorReturn;
    }

    DebugTrace("Info: Kerberos event name = %S.\n", pwszKerberosEventName);

    if (NULL == (pLogoffData->hModule = LoadLibraryW(L"wlnotify.dll")))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: LoadLibraryW() failed.\n", dwRetCode);
        goto ErrorReturn;
    }

    if (NULL == (pLogoffData->pNotify = new CNotify()))
    {
        dwRetCode = (DWORD) E_OUTOFMEMORY;
        DebugTrace("Error [%#x]: new CNotify() failed.\n", dwRetCode);
        goto ErrorReturn;
    }

    if (0 != (dwRetCode = pLogoffData->pNotify->RegisterNotification(pwszLogoffEventName, 
                                                                     pwszKerberosEventName)))
    {
        goto ErrorReturn;
    }

    if (!RegisterWaitForSingleObject(&pLogoffData->hWait,
                                     pLogoffData->hEvent,
                                     LogoffWaitCallback,
                                     (PVOID) pLogoffData,
                                     INFINITE,
                                     WT_EXECUTEONLYONCE))
    {
        dwRetCode = (DWORD) E_UNEXPECTED;
        DebugTrace("Unexpected error: RegisterWaitForSingleObject() failed for LogoffWaitCallback().\n");
        goto ErrorReturn;
    }

CommonReturn:

    if (pwszKerberosEventName)
    {
        free(pwszKerberosEventName);
    }

    PrivateDebugTrace("Leaving RegisterTicketExpiredNotificationEvent().\n");
    
    return dwRetCode;;
    
ErrorReturn:

    ASSERT(0 != dwRetCode);

    if (pLogoffData)
    {
        if (pLogoffData->hWait)
        {
           UnregisterWait(pLogoffData->hWait);
        }

        if (pLogoffData->pNotify)
        {
            pLogoffData->pNotify->UnregisterNotification();
            delete pLogoffData->pNotify;
        }

        if (pLogoffData->hEvent)
        {
            CloseHandle(pLogoffData->hEvent);
        }

        if (pLogoffData->hModule) 
        {
            FreeLibrary(pLogoffData->hModule);
        }

        LocalFree(pLogoffData);
    }

    goto CommonReturn;
}


//+----------------------------------------------------------------------------
//
// Function : UnregisterTicketExpiredNotificationEvent
//
// Synopsis : To unregister the Kerberos notification wait event registered by 
//            RegisterKerberosNotificationEvent().
//
// Parameter: PWLX_NOTIFICATION_INFO pNotificationInfo
//
// Return   : If the function succeeds, zero is returned.
// 
//            If the function fails, a non-zero error code is returned.
//
// Remarks  : This function should only be called by Winlogon LOGON 
//            notification mechanism with the Asynchronous and Impersonate
//            flags set to 1.
//
//-----------------------------------------------------------------------------

DWORD WINAPI UnregisterTicketExpiredNotificationEvent(PWLX_NOTIFICATION_INFO pNotificationInfo)
{
    DWORD  dwRetCode    = 0;
    HANDLE hLogoffEvent = NULL;

    PrivateDebugTrace("Entering UnregisterTicketExpiredNotificationEvent().\n");

    if (NULL == (hLogoffEvent = OpenEventW(EVENT_MODIFY_STATE, FALSE, LOGOFF_NOTIFICATION_EVENT_NAME)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: OpenEventW() failed for event %S.\n", dwRetCode, LOGOFF_NOTIFICATION_EVENT_NAME);
        goto ErrorReturn;
    }

    if (!SetEvent(hLogoffEvent))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: SetEvent() failed for event %S.\n", dwRetCode, LOGOFF_NOTIFICATION_EVENT_NAME);
        goto ErrorReturn;
    }

CommonReturn:

    if (hLogoffEvent)
    {
        CloseHandle(hLogoffEvent);
    }

    PrivateDebugTrace("Leaving UnregisterTicketExpiredNotificationEvent().\n");

    return dwRetCode;
    
ErrorReturn:

    ASSERT(0 != dwRetCode);

    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\asn1util.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       asn1util.h
//
//  Contents:   ASN.1 utility functions.
//
//  APIs: 
//              Asn1UtilDecodeLength
//              Asn1UtilExtractContent
//              Asn1UtilIsPKCS7WithoutContentType
//              Asn1UtilAdjustEncodedLength
//              Asn1UtilExtractValues
//              Asn1UtilExtractPKCS7SignedDataContent
//              Asn1UtilExtractCertificateToBeSignedContent
//              Asn1UtilExtractCertificatePublicKeyInfo
//              Asn1UtilExtractKeyIdFromCertInfo
//
//  History:    06-Dec-96    philh   created from kevinr's wincrmsg version
//--------------------------------------------------------------------------

#ifndef __ASN1UTIL_H__
#define __ASN1UTIL_H__

#ifdef __cplusplus
extern "C" {
#endif

#define ASN1UTIL_INSUFFICIENT_DATA  -2

//+-------------------------------------------------------------------------
//  ASN.1 Tag Defines
//--------------------------------------------------------------------------
#define ASN1UTIL_TAG_NULL                   0x00
#define ASN1UTIL_TAG_BOOLEAN                0x01
#define ASN1UTIL_TAG_INTEGER                0x02
#define ASN1UTIL_TAG_BITSTRING              0x03
#define ASN1UTIL_TAG_OCTETSTRING            0x04
#define ASN1UTIL_TAG_OID                    0x06
#define ASN1UTIL_TAG_UTC_TIME               0x17
#define ASN1UTIL_TAG_GENERALIZED_TIME       0x18
#define ASN1UTIL_TAG_CONSTRUCTED            0x20
#define ASN1UTIL_TAG_SEQ                    0x30
#define ASN1UTIL_TAG_SET                    0x31
#define ASN1UTIL_TAG_CONTEXT_0              0x80
#define ASN1UTIL_TAG_CONTEXT_1              0x81

#define ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0  \
                        (ASN1UTIL_TAG_CONSTRUCTED | ASN1UTIL_TAG_CONTEXT_0)
#define ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_1  \
                        (ASN1UTIL_TAG_CONSTRUCTED | ASN1UTIL_TAG_CONTEXT_1)

//+-------------------------------------------------------------------------
//  ASN.1 Length Defines for indefinite length encooding
//--------------------------------------------------------------------------
#define ASN1UTIL_LENGTH_INDEFINITE          0x80
#define ASN1UTIL_LENGTH_NULL                0x00

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbDER      - number of bytes remaining in the DER encoding
//
//  Returns:
//          success - the number of bytes in the length field, >=0
//          failure - <0
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilDecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbDER);

//+-------------------------------------------------------------------------
//  Point to the content octets in a DER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, >=0
//          failure - <0
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractContent(
    IN const BYTE *pbDER,
    IN DWORD cbDER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent);

//+-------------------------------------------------------------------------
//  Returns TRUE if we believe this is a Bob special that has ommitted the
//  PKCS #7 ContentType.
//
//  For PKCS #7: an Object Identifier tag (0x06) immediately follows the
//  identifier and length octets. For a Bob special: an integer tag (0x02)
//  follows the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilIsPKCS7WithoutContentType(
    IN const BYTE *pbDER,
    IN DWORD cbDER);

//+-------------------------------------------------------------------------
//  Decode the Asn1 length bytes to possibly downward adjust the length.
//
//  The returned length is always <= cbDER.
//--------------------------------------------------------------------------
DWORD
WINAPI
Asn1UtilAdjustEncodedLength(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    );



typedef struct _ASN1UTIL_EXTRACT_VALUE_PARA {
    // See below for list of operations and optional return blobs.
    DWORD           dwFlags;

    // The following 0 terminated array of tags is optional. If ommited, the
    // value may contain any tag. Note, for OPTIONAL_STEP_OVER, not optional.
    const BYTE      *rgbTag;
} ASN1UTIL_EXTRACT_VALUE_PARA, *PASN1UTIL_EXTRACT_VALUE_PARA;

// The lower 8 bits of dwFlags is set to one of the following operations
#define ASN1UTIL_MASK_VALUE_OP                  0xFF
#define ASN1UTIL_STEP_INTO_VALUE_OP             1
#define ASN1UTIL_STEP_OVER_VALUE_OP             2
#define ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP    3

#define ASN1UTIL_RETURN_VALUE_BLOB_FLAG         0x80000000
#define ASN1UTIL_RETURN_CONTENT_BLOB_FLAG       0x40000000


//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (ASN1UTIL_STEP_INTO_VALUE_OP)
//  or steps over the value's tag, length and content octets 
//  (ASN1UTIL_STEP_OVER_VALUE_OP or ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  For tag matching, only supports single byte tags.  STEP_OVER values
//  must be definite-length encoded.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all values successfully extracted. For
//                        STEP_INTO, only the tag and length octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        LastError is updated with the error.
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. For OPTIONAL_STEP_OVER, if tag isn't
//  found, pbData and cbData are set to 0.  If a STEP_INTO value is
//  indefinite-length encoded, cbData is set to CMSG_INDEFINITE_LENGTH.
//  If ASN1UTIL_DEFINITE_LENGTH_FLAG is set, then, all returned lengths
//  are definite-length, ie, CMSG_INDEFINITE_LENGTH is never returned.
//
//  If ASN1UTIL_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If ASN1UTIL_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OUT DWORD *pcValue,
    IN const ASN1UTIL_EXTRACT_VALUE_PARA *rgValuePara,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    );

#define ASN1UTIL_DEFINITE_LENGTH_FLAG           0x1


//+-------------------------------------------------------------------------
//  Skips past PKCS7 ASN.1 encoded values to get to the SignedData content.
//
//  Checks that the outer ContentType has the SignedData OID and optionally
//  checks the inner SignedData content's ContentType.
//
//  Returns:
//      success - the number of bytes skipped, >=0
//      failure - <0
//
//  If the SignedData content is indefinite-length encoded,
//  *pcbContent is set to CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractPKCS7SignedDataContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OPTIONAL const CRYPT_DER_BLOB *pEncodedInnerOID,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );

//+-------------------------------------------------------------------------
//  Verifies this is a certificate ASN.1 encoded signed content.
//  Returns the pointer to and length of the ToBeSigned content.
//
//  Returns an error if the ToBeSigned content isn't definite length
//  encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificateToBeSignedContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );

//+-------------------------------------------------------------------------
//  Returns the pointer to and length of the SubjectPublicKeyInfo value in
//  a signed and encoded X.509 certificate.
//
//  Returns an error if the value isn't definite length encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificatePublicKeyInfo(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbPublicKeyInfo,
    OUT const BYTE **ppbPublicKeyInfo
    );


//+-------------------------------------------------------------------------
//  If the Issuer and SerialNumber in the CERT_INFO contains a special
//  KeyID RDN attribute returns TRUE with pKeyId's cbData and pbData updated
//  with the RDN attribute's OCTET_STRING value. Otherwise, returns FALSE.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractKeyIdFromCertInfo(
    IN PCERT_INFO pCertInfo,
    OUT PCRYPT_HASH_BLOB pKeyId
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userinit\userinit.c ===
/****************************** Module Header ******************************\
* Module Name: userinit.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Userinit main module
*
* Userinit is an app executed by winlogon at user logon.
* It executes in the security context of the user and on the user desktop.
* Its purpose is to complete any user initialization that may take an
* indeterminate time. e.g. code that interacts with the user.
* This process may be terminated at any time if a shutdown is initiated
* or if the user logs off by some other means.
*
* History:
* 20-Aug-92 Davidc       Created.
\***************************************************************************/

#include "userinit.h"
#include "winuserp.h"
#include <mpr.h>
#include <winnetp.h>
#include <winspool.h>
#include <winsprlp.h>
#include "msgalias.h"
#include "stringid.h"
#include "strings.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <shellapi.h>
#include <regapi.h>
#include <dsgetdc.h>
#include <lm.h>
#include "helpmsg.h"        // for HelpMessageBox

/****************************************************************************
IsTSAppCompatOn()
Purpose:
    Checks if TS application compatibility is enabled.
    returns TRUE if enabled, FALSE - if not enabled or on case of error.
Comments:
    This function goes to the registry only once.
    All other times it just returnes the value.
****************************************************************************/
BOOL IsTSAppCompatOn();

//
// Define this to enable verbose output for this module
//

// #define DEBUG_USERINIT

#ifdef DEBUG_USERINIT
#define VerbosePrint(s) UIPrint(s)
#else
#define VerbosePrint(s)
#endif

//
// Define this to enable timing of userinit
//

//#define LOGGING

#ifdef LOGGING

void _WriteLog(LPCTSTR LogString);

#define WriteLog(s) _WriteLog(s)
#else
#define WriteLog(s)
#endif

//
// Define the environment variable names used to pass the logon
// server and script name from winlogon
//

#define LOGON_SERVER_VARIABLE       TEXT("UserInitLogonServer")
#define LOGON_SCRIPT_VARIABLE       TEXT("UserInitLogonScript")
#define MPR_LOGON_SCRIPT_VARIABLE   TEXT("UserInitMprLogonScript")
#define GPO_SCRIPT_TYPE_VARIABLE    TEXT("UserInitGPOScriptType")
#define OPTIMIZED_LOGON_VARIABLE    TEXT("UserInitOptimizedLogon")
#define EVENT_SOURCE_NAME           TEXT("UserInit")
#define USERDOMAIN_VARIABLE         TEXT("USERDOMAIN")
#define UNC_LOGON_SERVER_VARIABLE   TEXT("LOGONSERVER")
#define AUTOENROLL_VARIABLE         TEXT("UserInitAutoEnroll")
#define AUTOENROLL_NONEXCLUSIVE     TEXT("1")
#define AUTOENROLL_EXCLUSIVE        TEXT("2")
#define AUTOENROLLMODE_VARIABLE     TEXT("UserInitAutoEnrollMode")
#define AUTOENROLL_STARTUP          TEXT("1")
#define AUTOENROLL_WAKEUP           TEXT("2")
#define SCRIPT_ZONE_CHECK_VARIABLE  TEXT("SEE_MASK_NOZONECHECKS")
#define SCRIPT_ZONE_CHECK_DISABLE   TEXT("1")

//
// Define path separator
//

#define PATH_SEPARATOR          TEXT("\\")

//
// Define filename extension separator
//

#define EXTENSION_SEPARATOR_CHAR TEXT('.')

//
// Define server name prefix
//

#define SERVER_PREFIX           TEXT("\\\\")

//
// Define Logon script paths.
//

#define SERVER_SCRIPT_PATH      TEXT("\\NETLOGON")
#define LOCAL_SCRIPT_PATH       TEXT("\\repl\\import\\scripts")


#define WINLOGON_KEY            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define WINLOGON_POLICY_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System")
#define GPO_SCRIPTS_KEY         TEXT("Software\\Policies\\Microsoft\\Windows\\System\\Scripts")
#define SYNC_LOGON_SCRIPT       TEXT("RunLogonScriptSync")
#define SYNC_STARTUP_SCRIPT     TEXT("RunStartupScriptSync")
#define GRPCONV_REG_VALUE_NAME  TEXT("RunGrpConv")

//
// We cache user preference to run logon scripts synchronously
// in the machine hive so it can be checked to determine if we
// can do cached logon without having to load the user's hive.
//

#define PROFILE_LIST_PATH               L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"


TCHAR g_szGrpConvExe[] = TEXT("grpconv.exe -p");

//
// Define extensions that should be added to scripts without extensions
// when we go search for them. Basically this list includes those extensions
// that CreateProcess handles when they are present in the executable file
// name but must be provided by the caller (us)
// We search for a script file with these extensions in this order and
// execute the first one we find.
//
static LPTSTR ScriptExtensions[] = { TEXT(".bat"), TEXT(".cmd") };

//
// Name of registry key and value to check for temp page file.
//
TCHAR szMemMan[] =
     TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

TCHAR szNoPageFile[] = TEXT("TempPageFile");


//
// Handle to a thread that may be created to deal with autoenrollment goo.  
// If this is non-null, we will wait on this thread to complete before
// terminating the process.
//
HANDLE AutoEnrollThread ;

//
// Timeout in miliseconds to wait for AddMessageAlias to complete
//

#define TIMEOUT_VALUE  (5L * 60L * 1000L)
#define MAX_STRING_BYTES 512

BOOL SetupHotKeyForKeyboardLayout ();

LPTSTR
AllocAndGetEnvironmentVariable(
    LPTSTR lpName
    );

BOOL
RunScriptHidden(HKEY hKeyRoot, LPTSTR lpValue, BOOL bDefault);

BOOL
RunLogonScriptSync(VOID);

BOOL
RunStartupScriptSync(VOID);

BOOL
UpdateUserEnvironment(VOID);

LPWSTR 
GetSidString(HANDLE UserToken);

VOID
DeleteSidString(LPWSTR SidString);

VOID
UpdateUserSyncLogonScriptsCache(BOOL bSync);

VOID
NewLogonNotify(VOID);

BOOL
RunGPOScripts(
    LPTSTR  lpGPOScriptType
    );

void
PathUnquoteSpaces(LPTSTR lpsz);

BOOL
PrependToPath(
    IN LPTSTR lpLogonPath,
    OUT LPTSTR *lpOldPath
    );

typedef BOOL  (*PFNSHELLEXECUTEEX)(LPSHELLEXECUTEINFO lpExecInfo);
PFNSHELLEXECUTEEX g_pfnShellExecuteEx=NULL;

// If a path is contained in quotes then remove them.
void PathUnquoteSpaces(LPTSTR lpsz)
{
    int cch;

    cch = lstrlen(lpsz);

    // Are the first and last chars quotes?
    if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
    {
        // Yep, remove them.
        lpsz[cch-1] = 0;
        MoveMemory(lpsz, lpsz+1, (cch-1) * sizeof(TCHAR));
    }
}

// Following function determines if the machine is a Pro or Personal machine 
BOOL IsPerOrProTerminalServer()
{
    OSVERSIONINFOEX osVersion = {0};

    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    return(GetVersionEx((OSVERSIONINFO*)&osVersion) &&
           (osVersion.wProductType == VER_NT_WORKSTATION) &&
           (osVersion.wSuiteMask & VER_SUITE_SINGLEUSERTS));
}

//
// The 3 functions below are duplicated in gptext as well
// for running GPO scripts
//

/***************************************************************************\
* AllocAndGetEnvironmentVariable
*
* Version of GetEnvironmentVariable that allocates the return buffer.
*
* Returns pointer to environment variable or NULL on failure
*
* The returned buffer should be free using Free()
*
* History:
* 09-Dec-92     Davidc  Created
*
\***************************************************************************/
LPTSTR
AllocAndGetEnvironmentVariable(
    LPTSTR lpName
    )
{
    LPTSTR Buffer;
    DWORD LengthRequired;
    DWORD LengthUsed;
    DWORD BytesRequired;

    //
    // Go search for the variable and find its length
    //

    LengthRequired = GetEnvironmentVariable(lpName, NULL, 0);

    if (LengthRequired == 0) {
        VerbosePrint(("Environment variable <%S> not found, error = %d", lpName, GetLastError()));
        return(NULL);
    }

    //
    // Allocate a buffer to hold the variable
    //

    BytesRequired = LengthRequired * sizeof(TCHAR);

    Buffer = (LPTSTR) Alloc(BytesRequired);
    if (Buffer == NULL) {
        VerbosePrint(("Failed to allocate %d bytes for environment variable", BytesRequired));
        return(NULL);
    }

    //
    // Go get the variable and pass a buffer this time
    //

    LengthUsed = GetEnvironmentVariable(lpName, Buffer, LengthRequired);

    if (LengthUsed == 0) {
        VerbosePrint(("Environment variable <%S> not found (should have found it), error = %d", lpName, GetLastError()));
        Free(Buffer);
        return(NULL);
    }

    if (LengthUsed != LengthRequired - 1) {
        VerbosePrint(("Unexpected result from GetEnvironmentVariable. Length passed = %d, length used = %d (expected %d)", LengthRequired, LengthUsed, LengthRequired - 1));
        Free(Buffer);
        return(NULL);
    }

    return(Buffer);
}

//
// Directory separator in environment strings
//

#define DIRECTORY_SEPARATOR     TEXT(";")

BOOL
PrependToPath(
    IN LPTSTR lpLogonPath,
    OUT LPTSTR *lpOldPath
    )
{
    DWORD BytesRequired;
    LPTSTR lpNewPath;

    //
    // Prepend the address of the logon script to the path, so it can
    // reference other files.
    //

    *lpOldPath = AllocAndGetEnvironmentVariable( PATH );

    if (*lpOldPath == NULL) {
        return(FALSE);
    }

    BytesRequired = ( lstrlen(lpLogonPath) +
                      lstrlen(*lpOldPath)   +
                      2                           // one for terminator, one for ';'
                    ) * sizeof(TCHAR);

    lpNewPath = (LPTSTR)Alloc(BytesRequired);
    if (lpNewPath == NULL) {
        VerbosePrint(("PrependToPath: Failed to allocate %d bytes for modified path variable", BytesRequired));
        return(FALSE);
    }

    lstrcpy(lpNewPath, lpLogonPath);
    lstrcat(lpNewPath, DIRECTORY_SEPARATOR);
    lstrcat(lpNewPath, *lpOldPath);

//    Free( *lpOldPath );

    ASSERT(((lstrlen(lpNewPath) + 1) * sizeof(TCHAR)) == BytesRequired);

    SetEnvironmentVariable(PATH, lpNewPath);

    Free(lpNewPath);

    return(TRUE);
}

//
// Volatile Environment
//

#define VOLATILE_ENVIRONMENT        TEXT("Volatile Environment")

FILETIME g_LastWrite = {0,0};

typedef BOOL (WINAPI *PFNREGENERATEUSERENVIRONMENT) (
              PVOID pPrevEnv, BOOL bSetCurrentEnv);


//
// This function checks if a volatile environment section
// exists in the registry, and if so does the environment
// need to be updated.
//

BOOL UpdateUserEnvironment (void)
{
    PVOID pEnv;
    HKEY hKey;
    DWORD dwDisp, dwType, dwSize;
    BOOL bRebuildEnv = FALSE;
    TCHAR szClass[MAX_PATH];
    DWORD cchClass, dwSubKeys, dwMaxSubKey, dwMaxClass,dwValues;
    DWORD dwMaxValueName, dwMaxValueData, dwSecurityDescriptor;
    FILETIME LastWrite;


    //
    // Attempt to open the Volatile Environment key
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      VOLATILE_ENVIRONMENT,
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS) {


        //
        // Query the key information for the LastWrite time.
        // This way we can update the environment only when
        // we really need to.
        //

        cchClass = MAX_PATH;

        if (RegQueryInfoKey(hKey,
                            szClass,
                            &cchClass,
                            NULL,
                            &dwSubKeys,
                            &dwMaxSubKey,
                            &dwMaxClass,
                            &dwValues,
                            &dwMaxValueName,
                            &dwMaxValueData,
                            &dwSecurityDescriptor,
                            &LastWrite) == ERROR_SUCCESS) {

            //
            // If we haven't checked this key before,
            // then just store the values for next time.
            //

            if (g_LastWrite.dwLowDateTime == 0) {

                g_LastWrite.dwLowDateTime = LastWrite.dwLowDateTime;
                g_LastWrite.dwHighDateTime = LastWrite.dwHighDateTime;

                bRebuildEnv = TRUE;

            } else {

                //
                // Compare the last write times.
                //

                if (CompareFileTime (&LastWrite, &g_LastWrite) == 1) {

                    g_LastWrite.dwLowDateTime = LastWrite.dwLowDateTime;
                    g_LastWrite.dwHighDateTime = LastWrite.dwHighDateTime;

                    bRebuildEnv = TRUE;
                }
            }
        }


        RegCloseKey (hKey);
    }


    //
    // Check if we need to rebuild the environment
    //

    if (bRebuildEnv) {
        HINSTANCE hInst;
        PFNREGENERATEUSERENVIRONMENT pRegUserEnv;

        hInst = LoadLibrary (TEXT("shell32.dll"));

        if (hInst) {
            pRegUserEnv = (PFNREGENERATEUSERENVIRONMENT) GetProcAddress(hInst, "RegenerateUserEnvironment");

            if (pRegUserEnv) {
                (*pRegUserEnv) (&pEnv, TRUE);
            }

            FreeLibrary (hInst);
        }
    }


    return TRUE;
}
    
// returns a pointer to the arguments in a cmd type path or pointer to
// NULL if no args exist
//
// foo.exe bar.txt    -> bar.txt
// foo.exe            -> ""
//
// Spaces in filenames must be quoted.
// "A long name.txt" bar.txt -> bar.txt

LPTSTR GetArgs(LPCTSTR pszPath)
{
    BOOL fInQuotes = FALSE;

    if (!pszPath)
            return NULL;

    while (*pszPath)
    {
        if (*pszPath == TEXT('"'))
            fInQuotes = !fInQuotes;
        else if (!fInQuotes && *pszPath == TEXT(' '))
            return (LPTSTR)pszPath;
        pszPath = CharNext(pszPath);
    }

    return (LPTSTR)pszPath;
}

/***************************************************************************\
* ExecApplication
*
* Execs an application
*
* Returns TRUE on success, FALSE on failure.
*
* 21-Aug-92 Davidc   Created.
\***************************************************************************/

BOOL
ExecApplication(
    LPTSTR pch,
    BOOL bFileNameOnly,
    BOOL bSyncApp,
    BOOL bShellExec,
    USHORT ShowState
    )
{
    BOOL Result;
    WCHAR Localpch[ MAX_PATH+1 ];
    BOOL  IsProcessExplorer = FALSE;

    if ( (_wcsicmp( pch, L"explorer" ) == 0) ||
         (_wcsicmp( pch, L"explorer.exe" ) == 0 ) )
    {
        //
        // Explorer.exe might not be in the right spot on the path.  Let's wire
        // it to the right spot.
        //

        IsProcessExplorer = TRUE ;
        if ( ExpandEnvironmentStrings( L"%SystemRoot%\\Explorer.EXE", Localpch, MAX_PATH ) )
        {
            pch = Localpch ;
        }
        WriteLog( TEXT("Changed explorer.exe to") );
        WriteLog( pch );
    }
    else
    {
        if ( ExpandEnvironmentStrings( pch, Localpch, MAX_PATH ) )
        {
            pch = Localpch;
        }
    }

    //
    // Applications can be launched via ShellExecuteEx or CreateProcess
    //

    if (bShellExec)
    {
        SHELLEXECUTEINFO ExecInfo;
        LPTSTR lpArgs = NULL;
        LPTSTR lpTemp;
        HINSTANCE hShell32;

        if (!g_pfnShellExecuteEx) {
            
            Result = FALSE;

            hShell32 = LoadLibrary(TEXT("shell32.dll"));
            // this handle is not closed..

            if (hShell32) {
#ifdef UNICODE
                g_pfnShellExecuteEx = (PFNSHELLEXECUTEEX)GetProcAddress(hShell32, "ShellExecuteExW");
#else
                g_pfnShellExecuteEx = (PFNSHELLEXECUTEEX)GetProcAddress(hShell32, "ShellExecuteExA");
#endif

                if (g_pfnShellExecuteEx) {
                    Result = TRUE;
                }
            }
        }
        else {
            Result = TRUE;
        }

        if (Result) {
            lpTemp = LocalAlloc (LPTR, (lstrlen(pch) + 1) * sizeof(TCHAR));

            if (!lpTemp) {
                return FALSE;
            }

            lstrcpy (lpTemp, pch);

            if (!bFileNameOnly) {
                lpArgs = GetArgs (lpTemp);

                if (lpArgs) {
                    if (*lpArgs) {
                        *lpArgs = TEXT('\0');
                        lpArgs++;
                    } else {
                        lpArgs = NULL;
                    }
                }
            }

            PathUnquoteSpaces(lpTemp);

            ZeroMemory(&ExecInfo, sizeof(ExecInfo));
            ExecInfo.cbSize = sizeof(ExecInfo);
            ExecInfo.fMask = SEE_MASK_DOENVSUBST | SEE_MASK_FLAG_NO_UI |
                             SEE_MASK_NOCLOSEPROCESS;
            ExecInfo.lpFile = lpTemp;
            ExecInfo.lpParameters = lpArgs;
            ExecInfo.nShow = ShowState;
            ExecInfo.lpVerb = TEXT("open");



            Result = g_pfnShellExecuteEx (&ExecInfo);

            if (Result) {

                //
                // If we are running this app synchronously, wait
                // for it to terminate.
                //

                if (bSyncApp) {
                    WaitForSingleObject(ExecInfo.hProcess, INFINITE);
                }

                //
                // Close our handles to the process and thread
                //

                CloseHandle(ExecInfo.hProcess);

            }

            LocalFree (lpTemp);
        }
    }
    else
    {
        STARTUPINFO si;
        PROCESS_INFORMATION ProcessInformation;


        //
        // Initialize process startup info
        //
        si.cb = sizeof(STARTUPINFO);
        si.lpReserved = pch; // This tells progman it's the shell!
        si.lpTitle = pch;
        si.lpDesktop = NULL; // Not used
        si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = ShowState;
        si.lpReserved2 = NULL;
        si.cbReserved2 = 0;


        //
        // Start the app
        //
        Result = CreateProcess(
                          bFileNameOnly ? pch : NULL,   // Image name
                          bFileNameOnly ? NULL : pch,   // Command line
                          NULL,  // Default process protection
                          NULL,  // Default thread protection
                          FALSE, // Don't inherit handles
                          NORMAL_PRIORITY_CLASS,
                          NULL,  // Inherit environment
                          NULL,  // Inherit current directory
                          &si,
                          &ProcessInformation
                          );

        if (!Result) {
            VerbosePrint(("Failed to execute <%S>, error = %d", pch, GetLastError()));
            // TS : For non console sessions, a app restriting process like AppSec or SAFER might not allow explorer.exe for remote session
            // In this case we cannot leave a Blue screen hanging around - so we should log-off in this case
            // Also we want this only for Server or Advanced Server where this scenario is relevant
            if ( IsPerOrProTerminalServer() == FALSE) {
                if ((NtCurrentPeb()->SessionId != 0) && (IsProcessExplorer == TRUE)) {
                    TCHAR Title[MAX_STRING_BYTES];
                    TCHAR Message[MAX_STRING_BYTES];

                    #if DBG
                    DbgPrint("Userinit : TS : Failed to launch explorer.exe for a Remote Session. Doing ExitWindowsEx to logoff. \n");
                    #endif

                    // Display a MessageBox saying why we log off
                    LoadString( NULL, IDS_LOGON_FAILED, Title, MAX_STRING_BYTES );
                    LoadString(NULL, IDS_ERROR_SHELL_FAILED, Message, MAX_STRING_BYTES );
                    MessageBox(NULL, Message, Title, MB_OK);
                    ExitWindowsEx(EWX_LOGOFF, 0);
                }
            } 
        } else {

            //
            // If we are running this app synchronously, wait
            // for it to terminate.
            //

            if (bSyncApp) {
                WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
            }

            //
            // Close our handles to the process and thread
            //

            CloseHandle(ProcessInformation.hProcess);
            CloseHandle(ProcessInformation.hThread);

        }
    }

    return(Result);
}

/***************************************************************************\
* ExecProcesses
*
* Read the registry for a list of system processes and start them up.
*
* Returns number of processes successfully started.
*
* 3-Mar-97 Eric Flo      Rewrote
\***************************************************************************/

DWORD
ExecProcesses(
    LPTSTR pszKeyName,
    LPTSTR pszDefault,
    BOOL bMachine,
    BOOL bSync,                         // Should we wait until the process finish?
    BOOL bMinimize                      // Should we use the SW_SHOWMINNOACTIVE flag
    )
{
    LPTSTR pchData, pchCmdLine, pchT;
    DWORD cbCopied;
    DWORD dwExecuted = 0 ;
    HKEY hKey;
    DWORD dwType, dwSize = (MAX_PATH * sizeof(TCHAR));
    USHORT showstate = (UINT) (bMinimize ? SW_SHOWMINNOACTIVE : SW_SHOWNORMAL);

    //
    // Alloc a buffer to work with
    //

    pchData = LocalAlloc (LPTR, dwSize);

    if (!pchData) {
        return 0;
    }


    //
    // Set the default value
    //

    if (pszDefault) {
        lstrcpy (pchData, pszDefault);
    }


    //
    // Check for the requested value in the registry.
    //

    if (RegOpenKeyEx ((bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER),
                            WINLOGON_KEY,
                            0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        RegQueryValueEx (hKey, pszKeyName, NULL, &dwType, (LPBYTE) pchData, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for policy override if this is a user action
    //

    if (!bMachine)
    {
        if (RegOpenKeyEx (HKEY_CURRENT_USER, WINLOGON_POLICY_KEY,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            RegQueryValueEx (hKey, pszKeyName, NULL, &dwType, (LPBYTE) pchData, &dwSize);

            RegCloseKey (hKey);
        }
    }


    //
    // If the command line(s) is still null, exit now.
    //

    if (*pchData == TEXT('\0')) {
        LocalFree(pchData);
        return 0;
    }


    //
    // Walk through the command line(s) executing the app(s)
    //

    pchCmdLine = pchT = pchData;

    while (*pchT) {

        while (*pchT && *pchT != TEXT(',')) {
            pchT++;
        }

        if (*pchT == ',') {
            *pchT = TEXT('\0');
            pchT++;
        }

        //
        // Skip any leading spaces.
        //

        while (*pchCmdLine == TEXT(' ')) {
            pchCmdLine++;
        }


        //
        // We have something... exec this application.
        //

        if (ExecApplication(pchCmdLine, FALSE, bSync, FALSE, showstate)) {
            dwExecuted++;
        }

        pchCmdLine = pchT;
    }

    LocalFree(pchData);

    return dwExecuted ;
}


/***************************************************************************\
* SearchAndAllocPath
*
* Version of SearchPath that allocates the return string.
*
* Returns pointer to full path of file or NULL if not found.
*
* The returned buffer should be free using Free()
*
* History:
* 09-Dec-92     Davidc  Created
*
\***************************************************************************/
LPTSTR
SearchAndAllocPath(
    LPTSTR lpPath,
    LPTSTR lpFileName,
    LPTSTR lpExtension,
    LPTSTR *lpFilePart
    )
{
    LPTSTR Buffer;
    DWORD LengthRequired;
    DWORD LengthUsed;
    DWORD BytesRequired;

    //
    // Allocate a buffer to hold the full filename
    //

    LengthRequired = MAX_PATH;
    BytesRequired = (LengthRequired * sizeof(TCHAR));

    Buffer = Alloc(BytesRequired);
    if (Buffer == NULL) {
        UIPrint(("SearchAndAllocPath: Failed to allocate %d bytes for file name", BytesRequired));
        return(NULL);
    }

    //
    // Go search for the file
    //

    LengthUsed = SearchPath(
                           lpPath,
                           lpFileName,
                           lpExtension,
                           LengthRequired,
                           Buffer,
                           lpFilePart);

    if (LengthUsed == 0) {
        VerbosePrint(("SearchAndAllocPath: Path <%S>, file <%S>, extension <%S> not found, error = %d", lpPath, lpFileName, lpExtension, GetLastError()));
        Free(Buffer);
        return(NULL);
    }

    if (LengthUsed > LengthRequired - 1) {
        UIPrint(("SearchAndAllocPath: Unexpected result from SearchPath. Length passed = %d, length used = %d (expected %d)", LengthRequired, LengthUsed, LengthRequired - 1));
        Free(Buffer);
        return(NULL);
    }

    return(Buffer);
}

BOOL
DisableScriptZoneSecurityCheck()
{
    BOOL bSucceeded;

    //
    // To make the shell skip the zone security check for launching scripts, we use
    // a special environment variable honored by the shell for this purpose and
    // set it to a specific value
    //
    bSucceeded = SetEnvironmentVariable(SCRIPT_ZONE_CHECK_VARIABLE, SCRIPT_ZONE_CHECK_DISABLE);

    return bSucceeded;
}

BOOL
EnableScriptZoneSecurityCheck()
{
    BOOL bSucceeded;

    //
    // Clear the environment variable that disables the security check 
    //
    bSucceeded = SetEnvironmentVariable(SCRIPT_ZONE_CHECK_VARIABLE, NULL);

    if ( ! bSucceeded )
    {
        //
        // If we failed to clear it, it may be that this is because the
        // environment variable wasn't set in the first place, in which
        // case we can ignore the error since we are in the desired state
        //
        LONG Status = GetLastError();

        if ( ERROR_ENVVAR_NOT_FOUND == Status )
        {
            bSucceeded = TRUE;
        }
    }

    return bSucceeded;
}

/***************************************************************************\
* ExecScript
*
* Attempts to run the command script or exe lpScript in the directory lpPath.
* If path is not specified then the default windows search path is used.
*
* This routine is basically a wrapper for CreateProcess. CreateProcess always
* assumes a .exe extension for files without extensions. It will run .cmd
* and .bat files but it keys off the .cmd and .bat extension. So we must go
* search for the file first and add the extension before calling CreateProcess.
*
* Returns TRUE if the script began executing successfully.
* Returns FALSE if we can't find the script in the path specified
* or something fails.
*
* History:
* 09-Dec-92     Davidc  Created
*
\***************************************************************************/
BOOL
ExecScript(
    LPTSTR lpPath OPTIONAL,
    LPTSTR lpScript,
    BOOL bSyncApp,
    BOOL bShellExec
    )
{
    BOOL Result;
    DWORD i;
    USHORT uFlags;
    LPTSTR lpFullName;
    DWORD BytesRequired;


    //
    // First try and execute the raw script file name
    //

    if (lpPath != NULL) {

        BytesRequired = (lstrlen(lpPath) +
                         lstrlen(PATH_SEPARATOR) +
                         lstrlen(lpScript) +
                         1)
                         * sizeof(TCHAR);

        lpFullName  = Alloc(BytesRequired);
        if (lpFullName == NULL) {
            UIPrint(("ExecScript failed to allocate %d bytes for full script name", BytesRequired));
            return(FALSE);
        }

        lstrcpy(lpFullName, lpPath);
        lstrcat(lpFullName, PATH_SEPARATOR);
        lstrcat(lpFullName, lpScript);

        ASSERT(((lstrlen(lpFullName) + 1) * sizeof(TCHAR)) == BytesRequired);

    } else {
        lpFullName = lpScript;
    }


    uFlags = SW_SHOWNORMAL;

    if (!bSyncApp) {
        uFlags |= SW_SHOWMINNOACTIVE;
    }

    if (RunScriptHidden(HKEY_CURRENT_USER, TEXT("HideLegacyLogonScripts"), FALSE)) {
        uFlags = SW_HIDE;
    }

    //
    // Let CreateProcess have a hack at the raw script path and name.
    //

    Result = ExecApplication(lpFullName, FALSE, bSyncApp, bShellExec, uFlags);


    //
    // Free up the full name buffer
    //

    if (lpFullName != lpScript) {
        Free(lpFullName);
    }



    if (!Result) {

        //
        // Create process couldn't find it so add each script extension in
        // turn and try and execute the full script name.
        //
        // Only bother with this procedure if the script name doesn't
        // already contain an extension
        //
        BOOL ExtensionPresent = FALSE;
        LPTSTR p = lpScript;

        while (*p) {
            if (*p == EXTENSION_SEPARATOR_CHAR) {
                ExtensionPresent = TRUE;
                break;
            }
            p = CharNext(p);
        }

        if (ExtensionPresent) {
            VerbosePrint(("ExecScript: Skipping search path because script name contains extension"));
        } else {

            for (i = 0; i < sizeof(ScriptExtensions)/sizeof(ScriptExtensions[0]); i++) {

                lpFullName = SearchAndAllocPath(
                                    lpPath,
                                    lpScript,
                                    ScriptExtensions[i],
                                    NULL);

                if (lpFullName != NULL) {

                    //
                    // We found the file, go execute it
                    //

                    Result = ExecApplication(lpFullName, FALSE, bSyncApp, bShellExec, uFlags);

                    //
                    // Free the full path buffer
                    //

                    Free(lpFullName);

                    return(Result);
                }
            }
        }
    }


    return(Result);
}

BOOL RunScriptHidden(HKEY hKeyRoot, LPTSTR lpValue, BOOL bDefault)
{
    BOOL bResult;
    HKEY hKey;
    DWORD dwType, dwSize;


    //
    // Set the default
    //

    bResult = bDefault;


    //
    // Check for a preference
    //

    if (RegOpenKeyEx (hKeyRoot, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bResult);
        RegQueryValueEx (hKey, lpValue, NULL, &dwType,
                         (LPBYTE) &bResult, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a policy
    //

    if (RegOpenKeyEx (hKeyRoot, WINLOGON_POLICY_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bResult);
        RegQueryValueEx (hKey, lpValue, NULL, &dwType,
                         (LPBYTE) &bResult, &dwSize);

        RegCloseKey (hKey);
    }


    return bResult;
}

/***************************************************************************\
* RunLogonScript
*
* Starts the logon script
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 21-Aug-92     Davidc  Created
*
\***************************************************************************/
BOOL
RunLogonScript(
    LPTSTR lpLogonServer OPTIONAL,
    LPTSTR lpLogonScript,
    BOOL bSyncApp,
    BOOL bShellExec
    )
{
    LPTSTR lpLogonPath;
    LPTSTR lpOldPath;
    DWORD BytesRequired;
    BOOL Result;
    WIN32_FILE_ATTRIBUTE_DATA fad;


    if (!lpLogonScript) {
        return TRUE;
    }

    //
    // if the logon server exists, look for the logon scripts on
    // \\<LogonServer>\NETLOGON\<ScriptName>
    //

    if ((lpLogonServer != NULL) && (lpLogonServer[0] != 0)) {

        BytesRequired = ( lstrlen(SERVER_PREFIX) +
                          lstrlen(lpLogonServer) +
                          lstrlen(SERVER_SCRIPT_PATH) +
                          1
                        ) * sizeof(TCHAR);

        lpLogonPath = (LPTSTR)Alloc(BytesRequired);
        if (lpLogonPath == NULL) {
            UIPrint(("RunLogonScript: Failed to allocate %d bytes for remote logon script path", BytesRequired));
            return(FALSE);
        }

        lstrcpy(lpLogonPath, SERVER_PREFIX);
        lstrcat(lpLogonPath, lpLogonServer);
        lstrcat(lpLogonPath, SERVER_SCRIPT_PATH);

        if (GetFileAttributesEx (lpLogonPath, GetFileExInfoStandard, &fad)) {

            Result = PrependToPath( lpLogonPath, &lpOldPath );

            if (Result) {
                VerbosePrint(("Successfully prepended <%S> to path", lpLogonPath));
            } else {
                VerbosePrint(("Cannot prepend <%S> path.",lpLogonPath));
            }

            //
            // Try and execute the app/script specified by lpLogonScript
            // in the directory specified by lpLogonPath
            //
            Result = ExecScript(lpLogonPath, lpLogonScript, bSyncApp, bShellExec);

            if (Result) {
                VerbosePrint(("Successfully executed logon script <%S> in directory <%S>", lpLogonScript, lpLogonPath));
            } else {
                VerbosePrint(("Cannot start logon script <%S> on LogonServer <%S>. Trying local path.", lpLogonScript, lpLogonServer));
            }

            //
            // Put the path back the way it was
            //

            SetEnvironmentVariable(PATH, lpOldPath);

            Free(lpOldPath);

        } else {
            Result = FALSE;
        }

        //
        // Free up the buffer
        //

        Free(lpLogonPath);

        //
        // If the script started successfully we're done, otherwise
        // drop through and try to find the script locally
        //

        if (Result) {

            if (bSyncApp) {
                //
                // Check that the volatile environment hasn't changed.
                //

                UpdateUserEnvironment();
            }

            return(TRUE);
        }
    }




    //
    // Try to find the scripts on <system dir>\repl\import\scripts\<scriptname>
    //

    BytesRequired = GetSystemDirectory(NULL, 0) * sizeof(TCHAR);
    if (BytesRequired == 0) {
        UIPrint(("RunLogonScript: GetSystemDirectory failed, error = %d", GetLastError()));
        return(FALSE);
    }

    BytesRequired += ( lstrlen(LOCAL_SCRIPT_PATH)
                       // BytesRequired already includes space for terminator
                     ) * sizeof(TCHAR);

    lpLogonPath = (LPTSTR)Alloc(BytesRequired);
    if (lpLogonPath == NULL) {
        UIPrint(("RunLogonScript failed to allocate %d bytes for logon script path", BytesRequired));
        return(FALSE);
    }

    Result = FALSE;
    if (GetSystemDirectory(lpLogonPath, BytesRequired)) {

        lstrcat(lpLogonPath, LOCAL_SCRIPT_PATH);

        ASSERT(((lstrlen(lpLogonPath) + 1) * sizeof(TCHAR)) == BytesRequired);

        Result = PrependToPath( lpLogonPath, &lpOldPath );

        if (Result) {
            VerbosePrint(("Successfully prepended <%S> to path", lpLogonPath));
        } else {
            VerbosePrint(("Cannot prepend <%S> path.",lpLogonPath));
        }

        //
        // Try and execute the app/script specified by lpLogonScript
        // in the directory specified by lpLogonPath
        //

        Result = ExecScript(lpLogonPath, lpLogonScript, bSyncApp, bShellExec);

        if (Result) {
            VerbosePrint(("Successfully executed logon script <%S> in directory <%S>", lpLogonScript, lpLogonPath));
        } else {
            VerbosePrint(("Cannot start logon script <%S> on local path <%S>.", lpLogonScript, lpLogonPath));
        }

        //
        // Put the path back the way it was
        //

        SetEnvironmentVariable(PATH, lpOldPath);

        Free(lpOldPath);

    } else {
        UIPrint(("RunLogonScript: GetSystemDirectory failed, error = %d", GetLastError()));
    }

    //
    // Free up the buffer
    //

    Free(lpLogonPath);


    //
    // Check that the volatile environment hasn't changed.
    //

    if (Result && bSyncApp) {
        UpdateUserEnvironment();
    }

    return(Result);
}

#define SCR_STARTUP     L"Startup"
#define SCR_SHUTDOWN    L"Shutdown"
#define SCR_LOGON       L"Logon"
#define SCR_LOGOFF      L"Logoff"

DWORD
ScrExecGPOListFromReg(  LPWSTR szType,
                        BOOL bMachine,
                        BOOL bSync,
                        BOOL bHidden,
                        BOOL bRunMin,
                        HANDLE  hEventLog );

BOOL
RunGPOScripts(
    LPTSTR lpGPOScriptType
    )
{
    HKEY hKeyScripts;
    HKEY hKeyRoot;
    BOOL bSync = TRUE;
    BOOL bRunMin = TRUE;
    BOOL bHide;
    HANDLE hEventLog = NULL;
    BOOL  bMachine;
    BOOL  bResult;
    DWORD   dwError;

    //
    // Ensure that the shell's checks for ie zones are disabled
    // since this script is trusted by an administrator to execute
    //
    bResult = DisableScriptZoneSecurityCheck();

    if ( ! bResult )
    {
        goto RunGPOScripts_exit;
    }

    //
    // Register with Event Log
    //
    hEventLog = RegisterEventSource( 0, EVENT_SOURCE_NAME );

    //
    // Preliminary work to see if the scripts should be
    // run sync or async and to decide what the appropriate
    // root key is
    //

    if (!lstrcmpi (lpGPOScriptType, SCR_LOGON ))
    {
        hKeyRoot = HKEY_CURRENT_USER;
        bHide = RunScriptHidden(hKeyRoot, TEXT("HideLogonScripts"), TRUE);
        bSync = RunLogonScriptSync();
        bMachine = FALSE;
        if (bSync && !bHide)
        {
            bRunMin = FALSE;
        }
    }
    else if (!lstrcmpi (lpGPOScriptType, SCR_LOGOFF ))
    {
        hKeyRoot = HKEY_CURRENT_USER;
        bHide = RunScriptHidden(hKeyRoot, TEXT("HideLogoffScripts"), TRUE);
        bMachine = FALSE;
        if (!bHide)
        {
            bRunMin = FALSE;
        }
    }
    else if (!lstrcmpi (lpGPOScriptType, SCR_STARTUP ))
    {
        hKeyRoot = HKEY_LOCAL_MACHINE;
        bHide = RunScriptHidden(hKeyRoot, TEXT("HideStartupScripts"), TRUE);
        bSync = RunStartupScriptSync();
        bMachine = TRUE;
        if (bSync && !bHide)
        {
            bRunMin = FALSE;
        }
    }
    else if (!lstrcmpi (lpGPOScriptType, SCR_SHUTDOWN ))
    {
        hKeyRoot = HKEY_LOCAL_MACHINE;
        bHide = RunScriptHidden(hKeyRoot, TEXT("HideShutdownScripts"), TRUE);
        bMachine = TRUE;
        if (!bHide)
        {
            bRunMin = FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    dwError = ScrExecGPOListFromReg(lpGPOScriptType,
                                    bMachine,
                                    bSync,
                                    bHide,
                                    bRunMin,
                                    hEventLog );

    bResult = ( dwError == ERROR_SUCCESS );

RunGPOScripts_exit:

    if (hEventLog)
    {
        DeregisterEventSource(hEventLog);
    }
    
    return bResult;
}


/***************************************************************************\
* RunMprLogonScripts
*
* Starts the network provider logon scripts
* The passed string is a multi-sz - we exec each script in turn.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 21-Aug-92     Davidc  Created
*
\***************************************************************************/
BOOL
RunMprLogonScripts(
    LPTSTR lpLogonScripts,
    BOOL bSyncApp
    )
{
    BOOL Result;

    if (lpLogonScripts != NULL) {

        DWORD Length;

        do {
            Length = lstrlen(lpLogonScripts);
            if (Length != 0) {

                Result = ExecScript(NULL, lpLogonScripts, bSyncApp, FALSE);

                if (Result) {
                    VerbosePrint(("Successfully executed mpr logon script <%S>", lpLogonScripts));

                    if (bSyncApp) {
                        //
                        // Check that the volatile environment hasn't changed.
                        //

                        UpdateUserEnvironment();
                    }
                } else {
                    VerbosePrint(("Cannot start mpr logon script <%S>", lpLogonScripts));
                }
            }

            lpLogonScripts += (Length + 1);

        } while (Length != 0);

    }

    return(TRUE);
}

/***************************************************************************\
* AllocAndGetEnvironmentMultiSz
*
* Gets an environment variable's value that's assumed to be an
* encoded multi-sz and decodes it into an allocated return buffer.
* Variable should have been written with SetEnvironmentMultiSz() (winlogon)
*
* Returns pointer to environment variable or NULL on failure
*
* The returned buffer should be free using Free()
*
* History:
* 01-15-93      Davidc  Created
*
\***************************************************************************/

#define TERMINATOR_REPLACEMENT  TEXT(',')

LPTSTR
AllocAndGetEnvironmentMultiSz(
    LPTSTR lpName
    )
{
    LPTSTR Buffer;
    LPTSTR p, q;

    Buffer = AllocAndGetEnvironmentVariable(lpName);
    if (Buffer == NULL) {
        return(NULL);
    }

    //
    // Now decode the string - we can do this in place since the string
    // will always get smaller
    //

    p = Buffer;
    q = Buffer;

    while (*p) {

        if (*p == TERMINATOR_REPLACEMENT) {

            p ++;
            if (*p != TERMINATOR_REPLACEMENT) {
                p --;
                *p = 0;
            }
        }

        if (p != q) {
            *q = *p;
        }

        p ++;
        q ++;
    }

    ASSERT(q <= p);

    //
    // Copy terminator
    //

    if (q != p) {
        *q = 0;
    }

    return(Buffer);
}



/***************************************************************************\
* CheckVideoSelection
*
* History:
* 15-Mar-93 Andreva          Created.
\***************************************************************************/

VOID
CheckVideoSelection(
    HINSTANCE hInstance
)

{
    //
    // First check if we are in a detection mode.
    // If we are, spawn the applet and let the user pick the mode.
    //
    // Otherwise, check to see if the display was initialized properly.
    // We may want to move this to a more appropriate place at a later date.
    //
    // Andreva
    //

    NTSTATUS Status;
    HANDLE HkRegistry;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    TCHAR achDispMode[512];
    TCHAR achDisp[512];
    TCHAR achExec[MAX_PATH];

    DWORD Mesg = 0;
    LPTSTR psz = NULL;
    DWORD cb, dwType;
    DWORD data;

    if ( NtCurrentPeb()->SessionId != 0 ) {
        // Only do this for Console
        return;

    }

    //
    // Check for a new driver installation
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet"
                         L"\\Control\\GraphicsDrivers\\DetectDisplay");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&HkRegistry,
                       GENERIC_READ | GENERIC_WRITE | DELETE,
                       &ObjectAttributes);


    if (!NT_SUCCESS(Status)) {

        //
        // Check for a new driver installation
        //

        RtlInitUnicodeString(&UnicodeString,
                             L"\\Registry\\Machine\\System\\CurrentControlSet"
                             L"\\Control\\GraphicsDrivers\\NewDisplay");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenKey(&HkRegistry,
                           GENERIC_READ | GENERIC_WRITE | DELETE,
                           &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {

            //
            // Check for an invalid driver (like a 3.51 driver) or a badly
            // configured driver.
            //

            RtlInitUnicodeString(&UnicodeString,
                                 L"\\Registry\\Machine\\System\\CurrentControlSet"
                                 L"\\Control\\GraphicsDrivers\\InvalidDisplay");

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Status = NtOpenKey(&HkRegistry,
                               GENERIC_READ | GENERIC_WRITE | DELETE,
                               &ObjectAttributes);

        }
    }

    //
    // If any of the the error keys were opened successfully, then close the
    // key and spawn the applet (we only delete the invalid display key, not
    // the DetectDisplay key !)
    //

    if (NT_SUCCESS(Status)) {

        NtClose(HkRegistry);

        LoadString(hInstance,
                   IDS_DISPLAYAPPLET,
                   achExec, sizeof(achExec) / sizeof( TCHAR ));

        ExecApplication(achExec, FALSE, TRUE, FALSE, SW_SHOWNORMAL);

    }
}


/***************************************************************************\
* InitializeMisc
*
* History:
* 14-Jul-95 EricFlo          Created.
\***************************************************************************/

void InitializeMisc (HINSTANCE hInstance)
{
    HKEY hkeyMM;
    DWORD dwTempFile, cbTempFile, dwType;
    TCHAR achExec[MAX_PATH];

    //
    // check the page file. If there is not one, then spawn the vm applet
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMemMan, 0, KEY_READ,
            &hkeyMM) == ERROR_SUCCESS) {

        cbTempFile = sizeof(dwTempFile);
        if (RegQueryValueEx (hkeyMM, szNoPageFile, NULL, &dwType,
                (LPBYTE) &dwTempFile, &cbTempFile) != ERROR_SUCCESS ||
                dwType != REG_DWORD || cbTempFile != sizeof(dwTempFile)) {
            dwTempFile = 0;
        }

        RegCloseKey(hkeyMM);
    } else
        dwTempFile = 0;

    if (dwTempFile == 1) {
        LoadString(hInstance, IDS_VMAPPLET, achExec, sizeof(achExec) / sizeof( TCHAR ));
        ExecProcesses(TEXT("vmapplet"), achExec, TRUE, FALSE, TRUE);
    }


    //
    // Tell the user if he has an invalid video selection.
    //

    CheckVideoSelection(hInstance);


    //
    // Notify other system components that a new
    // user has logged into the workstation.
    //
    NewLogonNotify();

}


#ifdef LOGGING

#define DATEFORMAT  TEXT("%d-%d %.2d:%.2d:%.2d:%.3d ")

/***************************************************************************\
* _WriteLog
*
* History:
* 22-Mar-93 Robertre          Created.
\***************************************************************************/

void
_WriteLog(
    LPCTSTR LogString
    )
{
    TCHAR Buffer[MAX_PATH];
    SYSTEMTIME st;
    TCHAR FormatString[MAX_PATH];


    lstrcpy( FormatString, DATEFORMAT );
    lstrcat( FormatString, LogString );
    lstrcat( FormatString, TEXT("\r\n") );

    GetLocalTime( &st );

    //
    // Construct the message
    //

    wsprintf( Buffer,
              FormatString,
              st.wMonth,
              st.wDay,
              st.wHour,
              st.wMinute,
              st.wSecond,
              st.wMilliseconds
              );

    OutputDebugString (Buffer);
}

#endif


DWORD
WINAPI
AddToMessageAlias(
    PVOID params
    )
/***************************************************************************\
* AddToMessageAlias
*
* History:
* 10-Apr-93 Robertre       Created.
\***************************************************************************/
{
    HANDLE hShellReadyEvent;

    WCHAR UserName[MAX_PATH + 1];
    DWORD UserNameLength = sizeof(UserName) / sizeof(*UserName);
    DWORD dwCount;

    BOOL  standardShellWasStarted = *(BOOL *)params;

    //
    // Add the user's msg alias.
    //

    WriteLog(TEXT("Userinit: Adding MsgAlias"));

    if (GetUserNameW(UserName, &UserNameLength)) {
        AddMsgAlias(UserName);
    } else {
        UIPrint(("GetUserName failed, error = %d",GetLastError()));
    }

    WriteLog( TEXT("Userinit: Finished adding MsgAlias"));

    if (standardShellWasStarted )
    {
        dwCount = 0;
        while (TRUE) {
    
            hShellReadyEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,L"ShellReadyEvent");
    
            if (hShellReadyEvent == NULL)
            {
                if (GetLastError() == ERROR_FILE_NOT_FOUND) {
    
                    if (dwCount < 5) {
                         Sleep (3000);
                         dwCount++;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
            else
            {
                WaitForSingleObject(hShellReadyEvent, INFINITE);
                Sleep(20000);
                CloseHandle(hShellReadyEvent);
                break;
            }
        }
    }

    SpoolerInit();


    return( NO_ERROR );
}

BOOL
StartTheShell(
    void
    )
/***************************************************************************\
* StartTheShell
*
* Starts the shell, either explorer, the shell value specified in
* the registry for winlogon, or the alternate shell that is specified
* by the safeboot procedure.
*
* retrun
*   TRUE if the standard shell was executed
*   FALSE if a non-standard shell was executed.
*
* 14-Jan-98 WesW     Created.
\***************************************************************************/
{
    HKEY    hKey;
    DWORD   dwSize, dwType;
    WCHAR   ShellCmdLine[MAX_PATH];
    DWORD   UseAlternateShell = 0;


    //
    // get the safeboot mode
    //

    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("system\\currentcontrolset\\control\\safeboot\\option"),
            0,
            KEY_READ,
            &hKey
            ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        RegQueryValueEx (
            hKey,
            TEXT("UseAlternateShell"),
            NULL,
            &dwType,
            (LPBYTE) &UseAlternateShell,
            &dwSize
            );

        RegCloseKey( hKey );

        if (UseAlternateShell) {

            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("system\\currentcontrolset\\control\\safeboot"),
                    0,
                    KEY_READ,
                    &hKey
                    ) == ERROR_SUCCESS)
            {
                dwSize = sizeof(ShellCmdLine);
                if (RegQueryValueEx (
                    hKey,
                    TEXT("AlternateShell"),
                    NULL,
                    &dwType,
                    (LPBYTE) ShellCmdLine,
                    &dwSize
                    ) != ERROR_SUCCESS || ShellCmdLine[0] == 0)
                {
                    UseAlternateShell = 0;
                }
                RegCloseKey( hKey );
            } else {
                UseAlternateShell = 0;
            }
        }

    }

    //
    // Before we start the shell, we must re-enable the shell's script 
    // zone security checks -- if we can't do this, it is not safe
    // to start the shell since it may allow the user to run
    // unsafe code without notification.
    //
    if ( ! EnableScriptZoneSecurityCheck() )
    {
        //
        // We have to exit, and return TRUE which means that we failed to start
        // the standard shell.  We do this even if an alternate shell was desired since
        // whenever the alternate shell fails to launch for some other reason, 
        // we try to launch explorer.exe and would return TRUE in that case.
        //
        return TRUE;
    }

    if (IsTSAppCompatOn()) {
        if ( !ExecProcesses(TEXT("AppSetup"), NULL, FALSE, TRUE, TRUE ) ) {
            ExecProcesses(TEXT("AppSetup"), NULL, TRUE, TRUE, TRUE);
        }
    }

    if (UseAlternateShell) {
        if (ExecApplication(ShellCmdLine, FALSE, FALSE, FALSE, SW_MAXIMIZE)) {
            return FALSE; // an alt-shell was executed
        }
    } else if (NtCurrentPeb()->SessionId != 0) {

        //
        //  Terminal Server: For remote sessions query the Terminal Server service
        //  to see if this session has specified a initial program other than
        //  explorer.exe.
        //

        BOOLEAN bExecOk = TRUE;
        BOOLEAN IsWorkingDirWrong = FALSE;
        UINT ErrorStringId;
        LPTSTR  psz = NULL;
        LPTSTR  pszerr;
        ULONG Length;
        BOOLEAN Result;
        HANDLE  dllHandle;



        //
        // Load winsta.dll
        //
        dllHandle = LoadLibraryW(L"winsta.dll");

        if (dllHandle) {

            WINSTATIONCONFIG *pConfigData = LocalAlloc(LPTR, sizeof(WINSTATIONCONFIG));
            
            if (pConfigData) {

                PWINSTATION_QUERY_INFORMATION pfnWinstationQueryInformation;

                pfnWinstationQueryInformation = (PWINSTATION_QUERY_INFORMATION) GetProcAddress(
                                                                        dllHandle,
                                                                        "WinStationQueryInformationW"
                                                                        );
                if (pfnWinstationQueryInformation) {




                    Result = pfnWinstationQueryInformation( SERVERNAME_CURRENT,
                                                             LOGONID_CURRENT,
                                                             WinStationConfiguration,
                                                             pConfigData,
                                                             sizeof(WINSTATIONCONFIG),
                                                             &Length );

                    if (Result && pConfigData->User.InitialProgram[0] ) {

                        //BUGID - 342176

                        if( !ExpandEnvironmentStrings( pConfigData->User.InitialProgram, ShellCmdLine,  MAX_PATH ) )
                        {
                            wcscpy( ShellCmdLine, pConfigData->User.InitialProgram );
                        }



                        //
                        // If a working directory is specified,
                        // then attempt to change the current directory to it.
                        //

                        if ( pConfigData->User.WorkDirectory[0] ) {

                            WCHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];

                            if ( !ExpandEnvironmentStrings( pConfigData->User.WorkDirectory, WorkDirectory, DIRECTORY_LENGTH + 1 ) ) {
                                wcscpy( WorkDirectory, pConfigData->User.WorkDirectory );
                            }

                            bExecOk = (BYTE) SetCurrentDirectory( WorkDirectory );
                        }

                        pszerr = pConfigData->User.WorkDirectory;

                        if ( !bExecOk ) {

                            DbgPrint( "USERINIT: Failed to set working directory %ws for SessionId %u\n",
                                        pConfigData->User.WorkDirectory, NtCurrentPeb()->SessionId );

                            IsWorkingDirWrong = TRUE;
                            goto badexec;

                        }

                        bExecOk = (BYTE)ExecApplication( ShellCmdLine, FALSE, FALSE,
                                    FALSE,(USHORT)(pConfigData->User.fMaximize ? SW_SHOWMAXIMIZED : SW_SHOW) );
                        pszerr = ShellCmdLine;

                    badexec:

                        if ( !bExecOk ) {
                            DWORD   rc;
                            BOOL    bGotString;
                            #define PSZ_MAX 256
                            WCHAR   pszTemplate[PSZ_MAX];
                            LPTSTR  errbuf = NULL;

                            rc = GetLastError();
                            FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                           FORMAT_MESSAGE_MAX_WIDTH_MASK,
                                           NULL,
                                           rc,
                                           0,
                                           (LPTSTR) (&psz),
                                           1,
                                           NULL);

                            if (psz) {
                                if (IsWorkingDirWrong == TRUE)
                                {
                                    ErrorStringId = IDS_FAILING_WORKINGDIR;
                                }
                                else
                                {
                                    ErrorStringId = IDS_FAILING_SHELLCOMMAND;
                                }
                                bGotString = LoadString(NULL,ErrorStringId,pszTemplate,PSZ_MAX);
                                if (bGotString) {
                                    errbuf = LocalAlloc(LPTR,  512 * sizeof(TCHAR));
                                    if (errbuf) {
                                        wsprintf( errbuf, pszTemplate, psz, pszerr );
                                    }

                                }
                                LocalFree(psz);
                            }
                            else {
                                if (IsWorkingDirWrong == TRUE)
                                {
                                    ErrorStringId = IDS_ERROR_WORKINGDIR;
                                }
                                else
                                {
                                    ErrorStringId = IDS_ERROR_SHELLCOMMAND;
                                }
                                bGotString = LoadString(NULL,ErrorStringId,pszTemplate,PSZ_MAX);
                                if (bGotString) {
                                    errbuf = LocalAlloc(LPTR, 512 * sizeof(WCHAR));
                                    if (errbuf) {
                                        wsprintf( errbuf, pszTemplate, rc, pszerr );
                                    }
                                }
                            }

                            if (bGotString && errbuf) {

                                HelpMessageBox(NULL, NULL, errbuf, NULL, MB_OK | MB_ICONSTOP | MB_HELP, TEXT("MS-ITS:rdesktop.chm::/rdesktop_troubleshoot.htm"));
                                LocalFree(errbuf);
                            }



                        }

                        LocalFree(pConfigData);
                        FreeLibrary(dllHandle);

                        // an alt shell/program was executed
                        return FALSE ;
                    }
                
                }

                LocalFree(pConfigData);

            } // if pConfigData

            FreeLibrary(dllHandle);
        }
    }


    if (!ExecProcesses(TEXT("shell"), NULL, FALSE, FALSE, FALSE)) {
        ExecProcesses(TEXT("shell"), TEXT("explorer"), TRUE, FALSE, FALSE);
    }

    return TRUE; // standard shell/explorer was executed
}

VOID
DoAutoEnrollment(
    LPTSTR Param
    )
{
    if (0==wcscmp(Param, AUTOENROLL_STARTUP)) {
        AutoEnrollThread = CertAutoEnrollment( GetDesktopWindow(), CERT_AUTO_ENROLLMENT_START_UP );
    } else {
        AutoEnrollThread = CertAutoEnrollment( GetDesktopWindow(), CERT_AUTO_ENROLLMENT_WAKE_UP );
    }
}


/***************************************************************************\
* WinMain
*
* History:
* 20-Aug-92 Davidc       Created.
\***************************************************************************/
typedef BOOL (WINAPI * PFNIMMDISABLEIME)( DWORD );

int
WINAPI
WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow
    )
{
    LPTSTR lpLogonServer;
    LPTSTR lpOriginalUNCLogonServer;
    LPTSTR lpLogonScript;
    LPTSTR lpMprLogonScripts;
    LPTSTR lpGPOScriptType;
    LPTSTR lpAutoEnroll;
    LPTSTR lpAutoEnrollMode;
    DWORD ThreadId;
    DWORD WaitResult;
    HANDLE ThreadHandle;
    BOOL bRunLogonScriptsSync;
    BOOL bRunGrpConv = FALSE;
    HKEY hKey;
    DWORD dwType, dwSize, dwTemp;
    TCHAR szCmdLine[50];
    BOOL standardShellWasStarted;
    HANDLE  hImm = 0;
    PFNIMMDISABLEIME pfnImmDisableIME = 0;
    BOOL OptimizedLogon;
    LPTSTR OptimizedLogonStatus;

    WriteLog(TEXT("Userinit: Starting"));
    if ( GetSystemMetrics( SM_IMMENABLED ) )
    {
        hImm = LoadLibrary( L"imm32.dll");
        if ( hImm )
        {
            pfnImmDisableIME = (PFNIMMDISABLEIME) GetProcAddress(   hImm,
                                                                    "ImmDisableIME" );
            if ( pfnImmDisableIME )
            {
                pfnImmDisableIME( -1 );
            }
        }
    }

    //
    // Determine if we did an optimized logon. By default assume we did not.
    //

    OptimizedLogon = FALSE;

    OptimizedLogonStatus = AllocAndGetEnvironmentVariable(OPTIMIZED_LOGON_VARIABLE);
    if (OptimizedLogonStatus) {
        if (lstrcmp(OptimizedLogonStatus, TEXT("1")) == 0) {
            OptimizedLogon = TRUE;
        }
        Free(OptimizedLogonStatus);
    }
    SetEnvironmentVariable(OPTIMIZED_LOGON_VARIABLE, NULL);
    
    //
    // Check if userinit is being started to just run GPO scripts
    //

    lpGPOScriptType = AllocAndGetEnvironmentVariable(GPO_SCRIPT_TYPE_VARIABLE);

    //
    // Check if userinit.exe is being run just for auto enrollment
    //

    lpAutoEnroll = AllocAndGetEnvironmentVariable( AUTOENROLL_VARIABLE );
    lpAutoEnrollMode = AllocAndGetEnvironmentVariable( AUTOENROLLMODE_VARIABLE );

    SetEnvironmentVariable(AUTOENROLL_VARIABLE, NULL);

    if (lpGPOScriptType) {

        //
        // Userinit was started to execute GPO scripts only
        //
        // Clean up the environment block
        //

        SetEnvironmentVariable(GPO_SCRIPT_TYPE_VARIABLE, NULL);


        //
        // Execute the scripts and clean up
        //

        RunGPOScripts (lpGPOScriptType);

        Free(lpGPOScriptType);


        //
        // We're finished.  Exit now.
        //

        if ( lpAutoEnroll == NULL )
        {
            goto Exit ;
        }
    }

    if ( lpAutoEnroll )
    {
        if ( ( wcscmp( lpAutoEnroll, AUTOENROLL_NONEXCLUSIVE ) == 0 ) ||
             ( wcscmp( lpAutoEnroll, AUTOENROLL_EXCLUSIVE ) == 0 ) )
        {
            DoAutoEnrollment(  lpAutoEnrollMode );

            if ( wcscmp( lpAutoEnroll, AUTOENROLL_EXCLUSIVE ) == 0 )
            {
                goto Exit;
            }

        }
    }
    //
    // Check if grpconv.exe needs to be run
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bRunGrpConv);
        RegQueryValueEx (hKey, GRPCONV_REG_VALUE_NAME, NULL, &dwType,
                         (LPBYTE) &bRunGrpConv, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Run grpconv.exe if requested
    //

    if (bRunGrpConv) {
        WriteLog(TEXT("Userinit: Running grpconv.exe"));
        ExecApplication(g_szGrpConvExe, FALSE, TRUE, FALSE, SW_SHOWNORMAL);
    }


    //
    // Get the logon script environment variables
    //

    lpLogonServer = AllocAndGetEnvironmentVariable(LOGON_SERVER_VARIABLE);
    lpLogonScript = AllocAndGetEnvironmentVariable(LOGON_SCRIPT_VARIABLE);
    lpMprLogonScripts = AllocAndGetEnvironmentMultiSz(MPR_LOGON_SCRIPT_VARIABLE);


    //
    // Delete the logon script environment variables
    //

    SetEnvironmentVariable(LOGON_SERVER_VARIABLE, NULL);
    SetEnvironmentVariable(LOGON_SCRIPT_VARIABLE, NULL);
    SetEnvironmentVariable(MPR_LOGON_SCRIPT_VARIABLE, NULL);

    //
    // See if logon scripts are to be run sync or async
    //

    bRunLogonScriptsSync = RunLogonScriptSync();

    SetupHotKeyForKeyboardLayout();
    
    //
    // For application server see if we hve any .ini file/registry sync'ing to do
    //We should do it before we start running logon scripts!
    //
    //First Check if Application compatibility is on
    //
    if (IsTSAppCompatOn())
    {
        HANDLE  dllHandle;
        
        if (lpMprLogonScripts) {
            //Force to run logon script sync when a provider logon script exists when the system
            //is a terminal server. This is because of the global flag on the registry 
            // doesn't work when two interactive users logon at the same time.
            bRunLogonScriptsSync = TRUE;
        } 

        //
        // Load tsappcmp.dll
        //
        dllHandle = LoadLibrary (TEXT("tsappcmp.dll"));

        if (dllHandle) {

            PTERMSRCHECKNEWINIFILES pfnTermsrvCheckNewIniFiles;

            pfnTermsrvCheckNewIniFiles = (PTERMSRCHECKNEWINIFILES) GetProcAddress(
                                                            dllHandle,
                                                            "TermsrvCheckNewIniFiles"
                                                            );
            if (pfnTermsrvCheckNewIniFiles) {

                pfnTermsrvCheckNewIniFiles();
            }
        
            FreeLibrary(dllHandle);
        }
    }

    //
    // If logon scripts can be run async then start the shell first.
    //

    if (bRunLogonScriptsSync) {

        //
        // Disable the shell's ie zone checking for the processes we 
        // are starting along with all their child processes
        //
        (void) DisableScriptZoneSecurityCheck();

        RunLogonScript(lpLogonServer, lpLogonScript, bRunLogonScriptsSync, TRUE);
        RunMprLogonScripts(lpMprLogonScripts, bRunLogonScriptsSync);
        standardShellWasStarted = StartTheShell();

    } else {

        WriteLog(TEXT("Userinit: Starting the shell"));
        standardShellWasStarted = StartTheShell();

        (void) DisableScriptZoneSecurityCheck();

        RunLogonScript(lpLogonServer, lpLogonScript, bRunLogonScriptsSync, TRUE);
        RunMprLogonScripts(lpMprLogonScripts, bRunLogonScriptsSync);
    }

    UpdateUserSyncLogonScriptsCache(bRunLogonScriptsSync);

    //
    // Free up the buffers
    //

    Free(lpLogonServer);
    Free(lpLogonScript);
    Free(lpMprLogonScripts);


    //
    // Lower our priority so the shell can start faster
    //

    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_LOWEST);

    //
    // Load remote fonts
    //


    LoadRemoteFonts();

    //
    // Initialize misc stuff
    //

    InitializeMisc (hInstance);


    ThreadHandle = CreateThread(
                       NULL,
                       0,
                       AddToMessageAlias,
                       &standardShellWasStarted,
                       0,
                       &ThreadId
                       );

    WaitResult = WaitForSingleObject( ThreadHandle, TIMEOUT_VALUE );

    if ( WaitResult == WAIT_TIMEOUT )
    {
        //
        // This may never come back, so kill it.
        //

        UIPrint(("UserInit: AddToMessageAlias timeout, terminating thread\n"));
    }

    CloseHandle( ThreadHandle );


    //
    // If appropriate, start proquota.exe
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                  0, KEY_READ, &hKey) == ERROR_SUCCESS) {


        dwTemp = 0;
        dwSize = sizeof(dwTemp);

        RegQueryValueEx (hKey, TEXT("EnableProfileQuota"), NULL, &dwType,
                         (LPBYTE) &dwTemp, &dwSize);

        if (dwTemp) {
            lstrcpy (szCmdLine, TEXT("proquota.exe"));
            ExecApplication(szCmdLine, FALSE, FALSE, FALSE, SW_SHOWNORMAL);
        }

        RegCloseKey (hKey);
    }


Exit:

    if ( AutoEnrollThread )
    {
        WaitResult = WaitForSingleObject( AutoEnrollThread, INFINITE );

        CloseHandle( AutoEnrollThread );

        AutoEnrollThread = NULL ;
        
    }
    Free(lpAutoEnroll);
    Free(lpAutoEnrollMode);

    if ( hImm )
    {
        FreeLibrary( hImm );
    }
    
    return(0);
}


//
// Determines if logon scripts should be executed sync or async
//

BOOL RunLogonScriptSync()
{
    BOOL bSync = FALSE;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Check for a user preference
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_LOGON_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a machine preference
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_LOGON_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);


        RegCloseKey (hKey);
    }


    //
    // Check for a user policy
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, WINLOGON_POLICY_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_LOGON_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a machine policy
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_LOGON_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);


        RegCloseKey (hKey);
    }

    return bSync;
}

//
// Determines if startup scripts should be executed sync or async
//

BOOL RunStartupScriptSync()
{
    BOOL bSync = TRUE;
    HKEY hKey;
    DWORD dwType, dwSize;


    //
    // Check for a machine preference
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_STARTUP_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);


        RegCloseKey (hKey);
    }


    //
    // Check for a machine policy
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_STARTUP_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);


        RegCloseKey (hKey);
    }

    return bSync;
}

//
// Notify various components that a new user
// has logged into the workstation.
//

VOID
NewLogonNotify(
   VOID
   )
{
    FARPROC           lpProc;
    HMODULE           hLib;
    HANDLE            hEvent;


    //
    // Load the client-side user-mode PnP manager DLL
    //

    hLib = LoadLibrary(TEXT("setupapi.dll"));

    if (hLib) {

        lpProc = GetProcAddress(hLib, "CMP_Report_LogOn");

        if (lpProc) {

            //
            // Ping the user-mode pnp manager -
            // pass the private id as a parameter
            //

            (lpProc)(0x07020420, GetCurrentProcessId());
        }

        FreeLibrary(hLib);
    }


    //
    // Notify DPAPI that a new user has just logged in. DPAPI will take
    // this opportunity to re-synchronize its master keys if necessary.
    //

    {
        BYTE BufferIn[8] = {0};
        DATA_BLOB DataIn;
        DATA_BLOB DataOut;

        DataIn.pbData = BufferIn;
        DataIn.cbData = sizeof(BufferIn);

        CryptProtectData(&DataIn,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         CRYPTPROTECT_CRED_SYNC,
                         &DataOut);
    }


    //
    // Only do this for Console session
    //

    if ( NtCurrentPeb()->SessionId != 0 ) {
         return;
    }


    //
    // Notify RAS Autodial service that a new
    // user has logged in.
    //

    hEvent = OpenEvent(SYNCHRONIZE|EVENT_MODIFY_STATE, FALSE, L"RasAutodialNewLogonUser");

    if (hEvent) {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
}

BOOL SetupHotKeyForKeyboardLayout ()
{
    if (!GetSystemMetrics(SM_REMOTESESSION)) {

        //
        // we dont care about local sessions.
        //
        return TRUE;
    }

    if (GetUserDefaultLangID() != LOWORD(GetKeyboardLayout(0))) {

        //
        // we are in a remote session, and we have different keyboard layouts for client and this users settings.
        // the user should be allowed to switch the keyboard layout even if there is only 1 kbd layout available in his settings.
        // since the current kbd layout is different that the one in his profile.
        //

        WCHAR szCtfmon[] = L"ctfmon.exe";
        WCHAR szCtfmonCmd[] = L"ctfmon.exe /n";
        HKEY hRunOnce;
        DWORD dw;

        //
        // Lets put this in RunOnce.
        //
        if (RegCreateKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Runonce",
               0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
               NULL, &hRunOnce, &dw) == ERROR_SUCCESS) {

            WCHAR *szHotKeyReg = L"Keyboard Layout\\Toggle";
            HKEY  hHotKey;
            WCHAR szHotKeylAltShft[] = L"1";
            WCHAR szNoHotKey[] = L"3";

            RegSetValueEx(hRunOnce, szCtfmon, 0, REG_SZ, (PBYTE)szCtfmonCmd, sizeof(szCtfmonCmd));
            RegCloseKey(hRunOnce);

            if (RegCreateKeyEx(HKEY_CURRENT_USER, szHotKeyReg, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                   NULL, &hHotKey, &dw) == ERROR_SUCCESS) {

                DWORD dwType;
                WCHAR szHotKey[3];
                DWORD dwLen = sizeof(szHotKey);
                BOOL bResetHotkey = FALSE;

                if (RegQueryValueEx(hHotKey, L"Hotkey", NULL, &dwType,
                                    (PBYTE)szHotKey, &dwLen) != ERROR_SUCCESS) {

                    bResetHotkey = TRUE;
                }

                if (bResetHotkey || !wcscmp(szHotKey, szNoHotKey))
                {

                    //
                    // setup the registry for Hotkey.
                    //
                    if (RegSetValueEx(hHotKey, L"Hotkey", 0, REG_SZ,
                           (const BYTE *)szHotKeylAltShft, sizeof(szHotKeylAltShft)) == ERROR_SUCCESS) {

                         //
                         // now make call to read this registry and set the hotkey appropriately.
                         //
                         SystemParametersInfo( SPI_SETLANGTOGGLE, 0, NULL, 0);
                    }
                }

                RegCloseKey(hHotKey);
            }
        }
    }

    return TRUE;
}

/****************************************************************************
IsTSAppCompatOn()
Purpose:
    Checks if TS application compatibility is enabled.
    returns TRUE if enabled, FALSE - if not enabled or on case of error.
Comments:
    This function goes to the registry only once.
    All other times it just returnes the value.
****************************************************************************/
BOOL 
IsTSAppCompatOn()
{
    
    static BOOL bAppCompatOn = FALSE;
    static BOOL bFirst = TRUE;

    if(bFirst)
    {
        HKEY hKey;
        if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                          KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS ) 
        {
            DWORD dwValue = 0;
            DWORD dwType;
            DWORD dwSize = sizeof(dwValue);
        
            if( RegQueryValueEx(hKey, REG_TERMSRV_APPCOMPAT,
                NULL, &dwType, (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS )
            {
                bAppCompatOn = (dwValue != 0);   
            }

            RegCloseKey(hKey);
        }

        bFirst = FALSE;
    }

    return bAppCompatOn;
}

/****************************************************************************
UpdateUserSyncLogonScriptsCache()
Purpose:
    Update user's sync-logon-scripts setting cache in profile list.   
****************************************************************************/
VOID
UpdateUserSyncLogonScriptsCache(BOOL bSync)
{
    HANDLE UserToken;
    HKEY UserKey;
    PWCHAR UserSidString;
    PWCHAR KeyPath;
    ULONG Length;

    //
    // Update user's sync-logon-scripts setting cache in profile list.
    //

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &UserToken)) {

        UserSidString = GetSidString(UserToken);

        if (UserSidString) {

            Length = 0;
            Length += wcslen(PROFILE_LIST_PATH);
            Length += wcslen(L"\\");
            Length += wcslen(UserSidString);

            KeyPath = Alloc((Length + 1) * sizeof(WCHAR));

            if (KeyPath) {

                wcscpy(KeyPath, PROFILE_LIST_PATH);
                wcscat(KeyPath, L"\\");
                wcscat(KeyPath, UserSidString);

                if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, KeyPath, 0,
                      KEY_SET_VALUE, &UserKey) == ERROR_SUCCESS) {

                    RegSetValueEx(UserKey, SYNC_LOGON_SCRIPT, 0, REG_DWORD, 
                                  (BYTE *) &bSync, sizeof(bSync));
                
                    RegCloseKey(UserKey);
                }

                Free(KeyPath);
            }

            DeleteSidString(UserSidString);
        }

        CloseHandle(UserToken);
    }
 
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\catutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catutil.h
//
//  Contents:   definitions for catalog file utility functions
//
//  History:    01-may-2000 reidk created
//
//--------------------------------------------------------------------------


#ifndef __CATUTIL_H
#define __CATUTIL_H

#ifdef __cplusplus
extern "C"
{
#endif


BOOL
CatUtil_CreateCTLContextFromFileName(
    LPCWSTR         pwszFileName,
    HANDLE          *phMappedFile,
    BYTE            **ppbMappedFile,
    PCCTL_CONTEXT   *ppCTLContext,
    BOOL            fCreateSorted);


#ifdef __cplusplus
}
#endif


#endif // __CATUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\certperf.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       certperf.h
//
//  Contents:   Certificate Performance Counter Functions
//
//  APIs: 
//              CertPerfIncrementChainCount
//              CertPerfIncrementChainElementCount
//              CertPerfIncrementChainEngineCurrentCount
//              CertPerfDecrementChainEngineCurrentCount
//              CertPerfIncrementChainEngineTotalCount
//              CertPerfIncrementChainEngineResyncCount
//              CertPerfIncrementChainCertCacheCount
//              CertPerfDecrementChainCertCacheCount
//              CertPerfIncrementChainCtlCacheCount
//              CertPerfDecrementChainCtlCacheCount
//              CertPerfIncrementChainEndCertInCacheCount
//              CertPerfIncrementChainCacheEndCertCount
//              CertPerfIncrementChainRevocationCount
//              CertPerfIncrementChainRevokedCount
//              CertPerfIncrementChainRevocationOfflineCount
//              CertPerfIncrementChainNoRevocationCheckCount
//              CertPerfIncrementChainVerifyCertSignatureCount
//              CertPerfIncrementChainCompareIssuerPublicKeyCount
//              CertPerfIncrementChainVerifyCtlSignatureCount
//              CertPerfIncrementChainBeenVerifiedCtlSignatureCount
//              CertPerfIncrementChainUrlIssuerCount
//              CertPerfIncrementChainCacheOnlyUrlIssuerCount
//              CertPerfIncrementChainRequestedEngineResyncCount
//              CertPerfIncrementChangeNotifyCount
//              CertPerfIncrementChangeNotifyLmGpCount
//              CertPerfIncrementChangeNotifyCuGpCount
//              CertPerfIncrementChangeNotifyCuMyCount
//              CertPerfIncrementChangeNotifyRegCount
//              CertPerfIncrementStoreCurrentCount
//              CertPerfDecrementStoreCurrentCount
//              CertPerfIncrementStoreTotalCount
//              CertPerfIncrementStoreRegCurrentCount
//              CertPerfDecrementStoreRegCurrentCount
//              CertPerfIncrementStoreRegTotalCount
//              CertPerfIncrementRegElementReadCount
//              CertPerfIncrementRegElementWriteCount
//              CertPerfIncrementRegElementDeleteCount
//              CertPerfIncrementCertElementCurrentCount
//              CertPerfDecrementCertElementCurrentCount
//              CertPerfIncrementCertElementTotalCount
//              CertPerfIncrementCrlElementCurrentCount
//              CertPerfDecrementCrlElementCurrentCount
//              CertPerfIncrementCrlElementTotalCount
//              CertPerfIncrementCtlElementCurrentCount
//              CertPerfDecrementCtlElementCurrentCount
//              CertPerfIncrementCtlElementTotalCount
//
//  History:    04-May-99    philh   created
//--------------------------------------------------------------------------

#ifndef __CERTPERF_H__
#define __CERTPERF_H__

#ifdef __cplusplus
extern "C" {

#include <pshpack8.h>

typedef struct _CERT_PERF_PROCESS_COUNTERS {
    LONG            lChainCnt;
    LONG            lChainElementCnt;
    LONG            lChainEngineCurrentCnt;
    LONG            lChainEngineTotalCnt;
    LONG            lChainEngineResyncCnt;
    LONG            lChainCertCacheCnt;
    LONG            lChainCtlCacheCnt;
    LONG            lChainEndCertInCacheCnt;
    LONG            lChainCacheEndCertCnt;
    LONG            lChainRevocationCnt;
    LONG            lChainRevokedCnt;
    LONG            lChainRevocationOfflineCnt;
    LONG            lChainNoRevocationCheckCnt;
    LONG            lChainVerifyCertSignatureCnt;
    LONG            lChainCompareIssuerPublicKeyCnt;
    LONG            lChainVerifyCtlSignatureCnt;
    LONG            lChainBeenVerifiedCtlSignatureCnt;
    LONG            lChainUrlIssuerCnt;
    LONG            lChainCacheOnlyUrlIssuerCnt;
    LONG            lChainRequestedEngineResyncCnt;
    LONG            lChangeNotifyCnt;
    LONG            lChangeNotifyLmGpCnt;
    LONG            lChangeNotifyCuGpCnt;
    LONG            lChangeNotifyCuMyCnt;
    LONG            lChangeNotifyRegCnt;
    LONG            lStoreCurrentCnt;
    LONG            lStoreTotalCnt;
    LONG            lStoreRegCurrentCnt;
    LONG            lStoreRegTotalCnt;
    LONG            lRegElementReadCnt;
    LONG            lRegElementWriteCnt;
    LONG            lRegElementDeleteCnt;
    LONG            lCertElementCurrentCnt;
    LONG            lCertElementTotalCnt;
    LONG            lCrlElementCurrentCnt;
    LONG            lCrlElementTotalCnt;
    LONG            lCtlElementCurrentCnt;
    LONG            lCtlElementTotalCnt;

    //--###  Add New Counters  ###--
} CERT_PERF_PROCESS_COUNTERS, *PCERT_PERF_PROCESS_COUNTERS;

extern PCERT_PERF_PROCESS_COUNTERS pCertPerfProcessCounters;
#include <poppack.h>

__inline
void
CertPerfIncrementChainCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCnt);
}

__inline
void
CertPerfIncrementChainElementCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainElementCnt);
}

__inline
void
CertPerfIncrementChainEngineCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainEngineCurrentCnt);
}

__inline
void
CertPerfDecrementChainEngineCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lChainEngineCurrentCnt);
}

__inline
void
CertPerfIncrementChainEngineTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainEngineTotalCnt);
}

__inline
void
CertPerfIncrementChainEngineResyncCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainEngineResyncCnt);
}


__inline
void
CertPerfIncrementChainCertCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCertCacheCnt);
}

__inline
void
CertPerfDecrementChainCertCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lChainCertCacheCnt);
}


__inline
void
CertPerfIncrementChainCtlCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCtlCacheCnt);
}

__inline
void
CertPerfDecrementChainCtlCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lChainCtlCacheCnt);
}


__inline
void
CertPerfIncrementChainEndCertInCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainEndCertInCacheCnt);
}

__inline
void
CertPerfIncrementChainCacheEndCertCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCacheEndCertCnt);
}


__inline
void
CertPerfIncrementChainRevocationCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainRevocationCnt);
}

__inline
void
CertPerfIncrementChainRevokedCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainRevokedCnt);
}

__inline
void
CertPerfIncrementChainRevocationOfflineCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainRevocationOfflineCnt);
}

__inline
void
CertPerfIncrementChainNoRevocationCheckCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainNoRevocationCheckCnt);
}

__inline
void
CertPerfIncrementChainVerifyCertSignatureCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainVerifyCertSignatureCnt);
}

__inline
void
CertPerfIncrementChainCompareIssuerPublicKeyCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCompareIssuerPublicKeyCnt);
}

__inline
void
CertPerfIncrementChainVerifyCtlSignatureCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainVerifyCtlSignatureCnt);
}

__inline
void
CertPerfIncrementChainBeenVerifiedCtlSignatureCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainBeenVerifiedCtlSignatureCnt);
}

__inline
void
CertPerfIncrementChainUrlIssuerCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainUrlIssuerCnt);
}

__inline
void
CertPerfIncrementChainCacheOnlyUrlIssuerCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCacheOnlyUrlIssuerCnt);
}

__inline
void
CertPerfIncrementChainRequestedEngineResyncCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainRequestedEngineResyncCnt);
}

__inline
void
CertPerfIncrementChangeNotifyCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyCnt);
}

__inline
void
CertPerfIncrementChangeNotifyLmGpCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyLmGpCnt);
}

__inline
void
CertPerfIncrementChangeNotifyCuGpCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyCuGpCnt);
}

__inline
void
CertPerfIncrementChangeNotifyCuMyCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyCuMyCnt);
}

__inline
void
CertPerfIncrementChangeNotifyRegCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyRegCnt);
}

__inline
void
CertPerfIncrementStoreCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lStoreCurrentCnt);
}
__inline
void
CertPerfDecrementStoreCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lStoreCurrentCnt);
}

__inline
void
CertPerfIncrementStoreTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lStoreTotalCnt);
}

__inline
void
CertPerfIncrementStoreRegCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lStoreRegCurrentCnt);
}

__inline
void
CertPerfDecrementStoreRegCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lStoreRegCurrentCnt);
}

__inline
void
CertPerfIncrementStoreRegTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lStoreRegTotalCnt);
}

__inline
void
CertPerfIncrementRegElementReadCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lRegElementReadCnt);
}

__inline
void
CertPerfIncrementRegElementWriteCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lRegElementWriteCnt);
}

__inline
void
CertPerfIncrementRegElementDeleteCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lRegElementDeleteCnt);
}

__inline
void
CertPerfIncrementCertElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCertElementCurrentCnt);
}
__inline
void
CertPerfDecrementCertElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lCertElementCurrentCnt);
}

__inline
void
CertPerfIncrementCertElementTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCertElementTotalCnt);
}

__inline
void
CertPerfIncrementCrlElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCrlElementCurrentCnt);
}
__inline
void
CertPerfDecrementCrlElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lCrlElementCurrentCnt);
}

__inline
void
CertPerfIncrementCrlElementTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCrlElementTotalCnt);
}

__inline
void
CertPerfIncrementCtlElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCtlElementCurrentCnt);
}
__inline
void
CertPerfDecrementCtlElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lCtlElementCurrentCnt);
}

__inline
void
CertPerfIncrementCtlElementTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCtlElementTotalCnt);
}

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\crtem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crtem.h
//
//  Contents:   'C' Run Time Emulation Definitions
//
//  History:	03-Jun-96   philh   created
//--------------------------------------------------------------------------

#ifndef __CRTEM_H__
#define __CRTEM_H__


///////////////////////////////////////////////////////////////////////
//
// Definitions that help reduce our dependence on the C runtimes
//
#define wcslen(sz)      lstrlenW(sz)            // yes it IS implemented by Win95

#define strlen(sz)      lstrlenA(sz)
#define strcpy(s1,s2)   lstrcpyA(s1,s2)
#define strcmp(s1,s2)   lstrcmpA(s1,s2)
#define strcat(s1,s2)   lstrcatA(s1,s2)



///////////////////////////////////////////////////////////////////////
//
// C runtime excluders that we only use in non-debug builds
//

////////////////////////////////////////////
//
// enable intrinsics that we can
//
#if !DBG

    #ifdef __cplusplus
        #ifndef _M_PPC
            #pragma intrinsic(memcpy)
            #pragma intrinsic(memcmp)
            #pragma intrinsic(memset)
        #endif
    #endif

////////////////////////////////////////////
//
// memory management
//
#define malloc(cb)          ((void*)LocalAlloc(LPTR, cb))
#define free(pv)            (LocalFree((HLOCAL)pv))
#define realloc(pv, cb)     ((void*)LocalReAlloc((HLOCAL)pv, cb, LMEM_MOVEABLE))

#endif  // !DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\codesign.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       codesign.h
//
//--------------------------------------------------------------------------

#ifndef _CODESIGN_H
#define _CODESIGN_H

// OBSOLETE :- moved to authcode.h
//--------------------------------
//--------------------------------

//////////////////////////////////////////////////////
// Policy

#define STATE_TRUSTTEST        0x00000020
#define STATE_TESTCANBEVALID   0x00000080 
#define STATE_IGNOREEXPIRATION 0x00000100   // Use expiration date
#define STATE_IGNOREREVOKATION 0x00000200   // Do revocation check
#define STATE_OFFLINEOK_IND    0x00000400   // off-line is ok for individual certs
#define STATE_OFFLINEOK_COM    0x00000800   // off-line is ok for commercial certs
#define STATE_OFFLINEOKNBU_IND 0x00001000   // off-line is ok for individual certs, no bad ui
#define STATE_OFFLINEOKNBU_COM 0x00002000   // off-line is ok for commercial certs, no bad ui
#define STATE_TIMESTAMP_IND    0x00004000   // Use timestamp for individual certs
#define STATE_TIMESTAMP_COM    0x00008000   // Use timestamp for commerical certs
#define STATE_VERIFY_V1_OFF    0x00010000   // turn verify of v1 certs off

#define REGPATH_WINTRUST_USER   "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust"
#define REGPATH_SPUB            "\\Trust Providers\\Software Publishing"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\cnvcrypt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       cnvcrypt.h
//
//  Contents:   Temporary Hack for converting the (SDR) version of
//              CryptoAPI 2.0
//----------------------------------------------------------------------------

#ifndef __CNVCRYPT_H__
#define __CNVCRYPT_H__


#if(_WIN32_WINNT >= 0x0400)

#ifdef __cplusplus
extern "C" {
#endif

// In general all digest, Digest, DIGEST changed to: hash, Hash, HASH.

// A Hack to get the old error codes to work
#define CRMSG_E_GENERAL                 CRYPT_E_MSG_ERROR
#define CERT_BAD_PARAMETER              E_INVALIDARG
#define CERT_BAD_LENGTH                 CRYPT_E_BAD_LEN
#define CERT_BAD_ENCODE                 CRYPT_E_BAD_ENCODE
#define CERT_OUT_OF_MEMORY              E_OUTOFMEMORY
#define CERT_MUST_COPY_ENCODED          E_INVALIDARG
#define CERT_OSS_ERROR                  CRYPT_E_OSS_ERROR
#define CERT_STORE_BAD_PARAMETER        E_INVALIDARG
#define CERT_STORE_BAD_LEN              CRYPT_E_BAD_LEN
#define CERT_STORE_BAD_FLAGS            E_INVALIDARG
#define CERT_STORE_BAD_FILE             CRYPT_E_FILE_ERROR
#define CERT_STORE_NO_SUCH_PROPERTY     CRYPT_E_NOT_FOUND
#define CERT_STORE_ALREADY_IN_STORE     CRYPT_E_EXISTS
#define CERT_STORE_NOT_IMPLEMENTED      E_NOTIMPL
#define CERT_STORE_NOT_FOUND            CRYPT_E_NOT_FOUND
#define CERT_STORE_NO_CRYPT_PROV        CRYPT_E_NO_PROVIDER
#define CERT_STORE_SELF_SIGNED          CRYPT_E_SELF_SIGNED
#define CERT_STORE_DELETED_PREV         CRYPT_E_DELETED_PREV
#define CERT_HELPER_NO_MATCH            CRYPT_E_NO_MATCH
#define SCA_BAD_LEN_PARAMETER           CRYPT_E_BAD_LEN
#define SCA_BAD_PARAMETER               E_INVALIDARG
#define SCA_UNEXPECTED_MSG_TYPE         CRYPT_E_UNEXPECTED_MSG_TYPE
#define SCA_NO_CERT_KEY_PROV            CRYPT_E_NO_KEY_PROPERTY
#define SCA_NO_XCHG_CERT                CRYPT_E_NO_DECRYPT_CERT
#define SCA_BAD_MSG                     CRYPT_E_BAD_MSG


// A Hack to get the old APIs to work
#define CertStoreOpen                       CertOpenStore				
// Added dwFlags parameter to CertCloseStore
#define CertStoreClose                      CertCloseStore				
#define CertStoreClean                      CertCleanStore				
#define CertStoreSave                       CertSaveStore
#define CertStoreDuplicate                  CertDuplicateStore
#define CertStoreAddCert                    CertAddEncodedCertificateToStore
#define CertStoreAddCertContext             CertAddCertificateContextToStore
#define CertStoreAddCrl                     CertAddEncodedCRLToStore
#define CertStoreAddCrlContext              CertAddCRLContextToStore
#define CertStoreDeleteCert                 CertDeleteCertificateFromStore
#define CertStoreDeleteCrl                  CertDeleteCRLFromStore
#define CertStoreEnumCert                   CertEnumCertificatesInStore		
#define CertStoreFindCert                   CertFindCertificateInStore		
#define CertStoreGetSubjectCert             CertGetSubjectCertificateFromStore	
#define CertStoreGetCrl                     CertGetCRLFromStore			
#define CertStoreGetIssuerCert              CertGetIssuerCertificateFromStore	
#define CertStoreCreateCert                 CertCreateCertificateContext		
#define CertStoreDuplicateCert              CertDuplicateCertificateContext		
#define CertStoreSetCertProperty            CertSetCertificateContextProperty	
#define CertStoreGetCertProperty            CertGetCertificateContextProperty	
#define CertStoreFreeCert                   CertFreeCertificateContext		
#define CertStoreCreateCrl                  CertCreateCRLContext			
#define CertStoreDuplicateCrl               CertDuplicateCRLContext			
#define CertStoreFreeCrl                    CertFreeCRLContext			
#define CertStoreSetCrlProperty             CertSetCRLContextProperty		
#define CertStoreGetCrlProperty             CertGetCRLContextProperty

#define WinGetSystemCertificateStoreA       CertOpenSystemStoreA			
#define WinGetSystemCertificateStoreW       CertOpenSystemStoreW			
#define WinInsertCertificateA               CertAddEncodedCertificateToSystemStoreA
#define WinInsertCertificateW               CertAddEncodedCertificateToSystemStoreW

#define CertHelperCompareCert               CertCompareCertificate
#define CertHelperCompareCertName           CertCompareCertificateName
#define CertHelperCompareCertNameAttr       CertIsRDNAttrsInCertificateName

// Note parameters changed from PCRYPT_BIT_BLOB to PCERT_PUBLIC_KEY_INFO
#define CertHelperComparePublicKey          CertComparePublicKeyInfo
#define CertComparePublicKeys               CertComparePublicKeyInfo

// Note CertCompareCertificateName takes a PCERT_NAME_BLOB, not a PCERT_INFO
#define CertHelperIsIssuerOfSubjectCert     CertCompareCertificateName
#define CertHelperIsIssuerOfCrl             CertCompareCertificateName

// Note: PublicKey changed from a PCRYPT_BIT_BLOB to a PCERT_PUBLIC_KEY_INFO.
#define CertHelperKeyVerifySignature        CryptVerifyCertificateSignature

#if 0
BOOL
WINAPI
CertHelperVerifySignature(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN PCERT_INFO pIssuerInfo
    );
#else
#define CertHelperVerifySignature(hCryptProv, dwCertEncodingType, \
        pbEncoded, cbEncoded, pIssuerInfo) \
    CryptVerifyCertificateSignature(hCryptProv, dwCertEncodingType, \
        pbEncoded, cbEncoded, &pIssuerInfo->SubjectPublicKeyInfo)
#endif

#define CertHelperDigestToBeSigned          CryptHashToBeSigned
// Added dwFlags to CrytptDigestCertificate and CryptHashPublicKeyInfo
#define CertHelperComputeDigest             CryptHashCertificate
#define CertHelperDigestPublicKeyInfo       CryptHashPublicKeyInfo

// Note added HashAlgid and dwHashFlags parameters.
// Switched the order of the dwKeySpec and dwCertEncodingType parameters.
#define CertHelperSignToBeSigned            CryptSignCertificate
#define CryptSignCertificateContext         CryptSignCertificate

#define CertHelperVerifyCertTimeValidity    CertVerifyTimeValidity
#define CertHelperVerifyCrlTimeValidity     CertVerifyCRLTimeValidity
#define CertHelperVerifyValidityNesting     CertVerifyValidityNesting
#define CertHelperVerifyCertRevocation      CertVerifyRevocation
#define CryptVerifyRevocation               CertVerifyRevocation
#define CertHelperAlgIdToObjId              CertAlgIdToOID
#define CertHelperObjIdToAlgId              CertOIDToAlgId
#define CertHelperFindExtension             CertFindExtension
#define CertHelperFindAttribute             CertFindAttribute
#define CertHelperFindRDNAttr               CertFindRDNAttr
#define CertHelperGetIntendedKeyUsage       CertGetIntendedKeyUsage

// Added deCertEncodingType parameter, returns PCERT_PUBLIC_KEY_INFO instead
// of PBYTE
#define CertHelperGetPublicKey              CryptExportPublicKeyInfo
#define CertGetPublicKey                    CryptExportPublicKeyInfo

#if 0
BOOL
WINAPI
CertHelperCreatePublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    DWORD dwKeySpec,            // AT_SIGNATURE | AT_KEYEXCHANGE
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    );
#else
#define CertHelperCreatePublicKeyInfo(hCryptProv, dwKeySpec, \
        pInfo, pcbInfo) \
    CryptExportPublicKeyInfo(hCryptProv, dwKeySpec, X509_ASN_ENCODING, \
        pInfo, pcbInfo)
#endif

#define CertHelperNameValueToStr            CertRDNValueToStrA
#define CertHelperNameValueToWStr           CertRDNValueToStrW

// For all the SCA_*_PARA: dwVersion has been changed to cbSize.
// cbSize must be set to the sizeof(CRYPT_*_PARA) or else LastError
// will be updated with E_INVALIDARG.

typedef PFN_CRYPT_GET_SIGNER_CERTIFICATE PFN_SCA_VERIFY_SIGNER_POLICY;

typedef CRYPT_SIGN_MESSAGE_PARA SCA_SIGN_PARA;
typedef PCRYPT_SIGN_MESSAGE_PARA PSCA_SIGN_PARA;

// Combined into single dwMsgAndCertEncodingType
typedef CRYPT_VERIFY_MESSAGE_PARA SCA_VERIFY_PARA;
typedef PCRYPT_VERIFY_MESSAGE_PARA PSCA_VERIFY_PARA;

// Added EncryptionAlgid, dwEncryptionFlags
typedef CRYPT_ENCRYPT_MESSAGE_PARA SCA_ENCRYPT_PARA;
typedef PCRYPT_ENCRYPT_MESSAGE_PARA PSCA_ENCRYPT_PARA;

// Combined into single dwMsgAndCertEncodingType
typedef CRYPT_DECRYPT_MESSAGE_PARA SCA_DECRYPT_PARA;
typedef PCRYPT_DECRYPT_MESSAGE_PARA PSCA_DECRYPT_PARA;

// Added HashAlgid, dwHashFlags
typedef CRYPT_HASH_MESSAGE_PARA SCA_DIGEST_PARA;
typedef PCRYPT_HASH_MESSAGE_PARA PSCA_DIGEST_PARA;

// Added dwKeySpec, HashAlgid, dwHashFlags. Combined into single
// dwMsgAndCertEncodingType.
typedef CRYPT_KEY_SIGN_MESSAGE_PARA SCA_NO_CERT_SIGN_PARA;
typedef PCRYPT_KEY_SIGN_MESSAGE_PARA PSCA_NO_CERT_SIGN_PARA;

typedef CRYPT_KEY_VERIFY_MESSAGE_PARA SCA_NO_CERT_VERIFY_PARA;
typedef PCRYPT_KEY_VERIFY_MESSAGE_PARA PSCA_NO_CERT_VERIFY_PARA;

#define SCAEncrypt                          CryptEncryptMessage			
#define SCADecrypt                          CryptDecryptMessage			
#define SCASign                             CryptSignMessage			
#define SCAVerifySignature                  CryptVerifyMessageSignature		
#define SCASignAndEncrypt                   CryptSignAndEncryptMessage		
#define SCADecryptAndVerifySignature        CryptDecryptAndVerifyMessageSignature	
#define SCADigest                           CryptHashMessage			
#define SCAVerifyDigest                     CryptVerifyMessageHash		
#define SCANoCertSign                       CryptSignMessageWithKey			
#define SCANoCertVerifySignature            CryptVerifyMessageSignatureWithKey	
#define SCAVerifyDetachedDigest             CryptVerifyDetachedMessageHash
#define SCAVerifyDetachedSignature          CryptVerifyDetachedMessageSignature	
#define SETSCASignAndExEncrypt              CryptSignAndExEncryptMessage		
#define SETSCAExDecryptAndVerifySignature   CryptExDecryptAndVerifyMessageSignature		
#define SETSCAExEncrypt                     CryptExEncryptMessage			
#define SETSCAExDecrypt                     CryptExDecryptMessage			


// A Hack to get the old encode/decode APIs to work

// Renamed the structure used for X509_CERT. Futhermore, the content of the
// CERT_ENCODING structure has changed.
typedef CERT_SIGNED_CONTENT_INFO CERT_ENCODING;
typedef PCERT_SIGNED_CONTENT_INFO PCERT_ENCODING;

//  Content types
#define CERT_CONTENT            1
#define CRL_CONTENT             2
#define CERT_REQUEST_CONTENT    3


#if 0
BOOL
WINAPI
CertEncodeToBeSigned(
            IN DWORD dwEncodingType,
            IN DWORD dwContentType,
            IN void *pvInfo,
            OUT BYTE *pbEncodedToBeSigned,
            IN OUT DWORD *pcbEncodedToBeSigned
            );
#else
#define CertEncodeToBeSigned(dwEncodingType, dwContentType, pvInfo, \
        pbEncodedToBeSigned, pcbEncodedToBeSigned) \
    CryptEncodeObject(dwEncodingType, \
        (dwContentType == CERT_CONTENT) ? X509_CERT_TO_BE_SIGNED : \
        ((dwContentType == CRL_CONTENT) ? X509_CERT_CRL_TO_BE_SIGNED : \
            X509_CERT_REQUEST_TO_BE_SIGNED), \
        pvInfo, pbEncodedToBeSigned, pcbEncodedToBeSigned)
#endif

#if 0
BOOL
WINAPI
CertEncode(
            IN DWORD dwEncodingType,
            IN const BYTE *pbEncodedToBeSigned,
            IN DWORD cbEncodedToBeSigned,
            IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
            IN const BYTE *pbSignature,
            IN DWORD cbSignature,
            IN OPTIONAL void *pAdditionalInfo,
            OUT BYTE *pbEncoded,
            IN OUT DWORD *pcbEncoded
            );
#else
// You'll need to create and initialize a CERT_SIGNED_CONTENT_INFO data
// structure initialized with the above information
// You'll need to manually modify your code
#define CertEncode(dwEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, \
        pSignatureAlgorithm, pbSignature, cbSignature, pAdditionalInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_CERT, &CertSignedContentInfo, \
        pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
CertDecodeToBeSigned(
            IN DWORD dwEncodingType,
            IN DWORD dwContentType,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT void *pvInfo,
            IN OUT DWORD *pcbInfo
            );
#else
#define CertDecodeToBeSigned(dwEncodingType, dwContentType, \
        pbEncoded, cbEncoded, pvInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, \
        (dwContentType == CERT_CONTENT) ? X509_CERT_TO_BE_SIGNED : \
        ((dwContentType == CRL_CONTENT) ? X509_CERT_CRL_TO_BE_SIGNED : \
            X509_CERT_REQUEST_TO_BE_SIGNED), \
        pbEncoded, cbEncoded, 0, pvInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
CertDecode(
            IN DWORD dwEncodingType,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT OPTIONAL PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
            IN OUT OPTIONAL DWORD *pcbSignatureAlgorithm,
            IN OUT OPTIONAL BYTE **ppbSignature,
            IN OUT OPTIONAL DWORD *pcbSignature,
            IN OUT BYTE **ppbEncodedToBeSigned,
            IN OUT DWORD *pcbEncodedToBeSigned,
            IN OUT OPTIONAL void *pAdditionalInfo,
            IN OUT OPTIONAL DWORD *pcbAdditionalInfo
            );
#else
// Returns a CERT_SIGNED_CONTENT_INFO data
// structure containing the above information
// You'll need to manually modify your code
#define CertDecode(dwEncodingType, pbEncoded, cbEncoded, \
        pSignatureAlgorithm, pcbSignatureAlgorithm, \
        ppbSignature, pcbSignature, \
        ppbEncodedToBeSigned, pcbEncodedToBeSigned, \
        pAdditionalInfo, pcbAdditionalInfo) \
    CryptDecodeObject(dwEncodingType, X509_CERT, pbEncoded, cbEncoded, 0, \
        pCertSignedContentInfo, &cbCertSignedContentInfo)
#endif

#if 0
BOOL
WINAPI
CertEncodeName(
            IN DWORD dwEncodingType,
            IN PCERT_NAME_INFO pInfo,
            OUT BYTE *pbEncoded,
            IN OUT DWORD *pcbEncoded
            );
#else
#define CertEncodeName(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_NAME, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
CertDecodeName(
            IN DWORD dwEncodingType,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT PCERT_NAME_INFO pInfo,
            IN OUT DWORD *pcbInfo
            );
#else
#define CertDecodeName(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_NAME, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
CertEncodeNameValue(
            IN DWORD dwEncodingType,
            IN PCERT_NAME_VALUE pInfo,
            OUT BYTE *pbEncoded,
            IN OUT DWORD *pcbEncoded
            );
#else
#define CertEncodeNameValue(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_NAME_VALUE, \
        pInfo, pbEncoded, pcbEncoded)
#endif


#if 0
BOOL
WINAPI
CertDecodeNameValue(
            IN DWORD dwEncodingType,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT PCERT_NAME_VALUE pInfo,
            IN OUT DWORD *pcbInfo
            );
#else
#define CertDecodeNameValue(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_NAME_VALUE, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
CertEncodeExtensions(
        IN DWORD dwEncodingType,
        IN PCERT_EXTENSIONS pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define CertEncodeExtensions(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_EXTENSIONS, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
CertDecodeExtensions(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_EXTENSIONS pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define CertDecodeExtensions(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_EXTENSIONS, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
PublicKeyInfoEncode(
        IN DWORD dwEncodingType,
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define PublicKeyInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_PUBLIC_KEY_INFO, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
PublicKeyInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_PUBLIC_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define PublicKeyInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_PUBLIC_KEY_INFO, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
AuthorityKeyIdEncode(
        IN DWORD dwEncodingType,
        IN PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define AuthorityKeyIdEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_AUTHORITY_KEY_ID, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
AuthorityKeyIdDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define AuthorityKeyIdDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_AUTHORITY_KEY_ID, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
KeyAttributesEncode(
        IN DWORD dwEncodingType,
        IN PCERT_KEY_ATTRIBUTES_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define KeyAttributesEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_KEY_ATTRIBUTES, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
KeyAttributesDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_KEY_ATTRIBUTES_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define KeyAttributesDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_KEY_ATTRIBUTES, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
KeyUsageRestrictionEncode(
        IN DWORD dwEncodingType,
        IN PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define KeyUsageRestrictionEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_KEY_USAGE_RESTRICTION, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
KeyUsageRestrictionDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define KeyUsageRestrictionDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_KEY_USAGE_RESTRICTION, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
AltNameEncode(
        IN DWORD dwEncodingType,
        IN PCERT_ALT_NAME_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define AltNameEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_ALTERNATE_NAME, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
AltNameDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_ALT_NAME_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define AltNameDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_ALTERNATE_NAME, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
BasicConstraintsEncode(
        IN DWORD dwEncodingType,
        IN PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define BasicConstraintsEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_BASIC_CONSTRAINTS, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
BasicConstraintsDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define BasicConstraintsDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_BASIC_CONSTRAINTS, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SETAccountAliasEncode(
        IN DWORD dwEncodingType,
        IN BOOL *pbInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define SETAccountAliasEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_SET_ACCOUNT_ALIAS, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
SETAccountAliasDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT BOOL *pbInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SETAccountAliasDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_SET_ACCOUNT_ALIAS, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SETHashedRootKeyEncode(
        IN DWORD dwEncodingType,
        IN BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define SETHashedRootKeyEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_SET_HASHED_ROOT_KEY, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
SETHashedRootKeyDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        IN OUT DWORD *pcbInfo
        );
#else
#define SETHashedRootKeyDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_SET_HASHED_ROOT_KEY, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SETCertificateTypeEncode(
        IN DWORD dwEncodingType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define SETCertificateTypeEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_SET_CERTIFICATE_TYPE, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
SETCertificateTypeDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SETCertificateTypeDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_SET_CERTIFICATE_TYPE, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SETMerchantDataEncode(
        IN DWORD dwEncodingType,
        IN PSET_MERCHANT_DATA_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define SETMerchantDataEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_SET_MERCHANT_DATA, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
SETMerchantDataDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSET_MERCHANT_DATA_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SETMerchantDataDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_SET_MERCHANT_DATA, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


// A Hack to get the old SPC encode/decode APIs to work

#if 0
BOOL
WINAPI
SpcSpAgencyInfoEncode(
        IN DWORD dwEncodingType,
        IN PSPC_SP_AGENCY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
SpcSpAgencyInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_SP_AGENCY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcSpAgencyInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_SP_AGENCY_INFO_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcSpAgencyInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_SP_AGENCY_INFO_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SpcMinimalCriteriaInfoEncode(
        IN DWORD dwEncodingType,
        IN BOOL *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
SpcMinimalCriteriaInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT BOOL *pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcMinimalCriteriaInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_MINIMAL_CRITERIA_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcMinimalCriteriaInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_MINIMAL_CRITERIA_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SpcFinancialCriteriaInfoEncode(
        IN DWORD dwEncodingType,
        IN PSPC_FINANCIAL_CRITERIA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcFinancialCriteriaInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_FINANCIAL_CRITERIA pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcFinancialCriteriaInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_FINANCIAL_CRITERIA_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcFinancialCriteriaInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_FINANCIAL_CRITERIA_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SpcIndirectDataContentEncode(
        IN DWORD dwEncodingType,
        IN PSPC_INDIRECT_DATA_CONTENT pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcIndirectDataContentDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_INDIRECT_DATA_CONTENT pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcIndirectDataContentEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_INDIRECT_DATA_CONTENT_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcIndirectDataContentDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_INDIRECT_DATA_CONTENT_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
SpcPeImageDataEncode(
        IN DWORD dwEncodingType,
        IN PSPC_PE_IMAGE_DATA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcPeImageDataDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_PE_IMAGE_DATA pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcPeImageDataEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_PE_IMAGE_DATA_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcPeImageDataDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_PE_IMAGE_DATA_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SpcLinkEncode(
        IN DWORD dwEncodingType,
        IN PSPC_LINK pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcLinkDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_LINK pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcLinkEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_LINK_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcLinkDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_LINK_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
SpcStatementTypeEncode(
        IN DWORD dwEncodingType,
        IN PSPC_STATEMENT_TYPE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcStatementTypeDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_STATEMENT_TYPE pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcStatementTypeEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_STATEMENT_TYPE_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcStatementTypeDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_STATEMENT_TYPE_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
SpcSpOpusInfoEncode(
        IN DWORD dwEncodingType,
        IN PSPC_SP_OPUS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcSpOpusInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_SP_OPUS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcSpOpusInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_SP_OPUS_INFO_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcSpOpusInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_SP_OPUS_INFO_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif /* _WIN32_WINNT >= 0x0400 */

#endif // __CNVCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\certprot.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certprot.h
//
//  Contents:   Certificate Protection APIs
//
//  APIs:       I_CertProtectFunction
//              I_CertCltProtectFunction
//              I_CertSrvProtectFunction
//
//  History:    27-Nov-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CERTPROT_H__
#define __CERTPROT_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Calls the services process to do a protected certificate function,
//  such as, add or delete a protected root certificate.
//
//  CryptMemFree must be called to free the returned *ppbOut.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    );

#define CERT_PROT_INIT_ROOTS_FUNC_ID            1
#define CERT_PROT_PURGE_LM_ROOTS_FUNC_ID        2
#define CERT_PROT_ADD_ROOT_FUNC_ID              3
#define CERT_PROT_DELETE_ROOT_FUNC_ID           4
#define CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID  5
#define CERT_PROT_ROOT_LIST_FUNC_ID             6
#define CERT_PROT_ADD_ROOT_IN_CTL_FUNC_ID       7
#define CERT_PROT_LOG_EVENT_FUNC_ID             8


//+-------------------------------------------------------------------------
//  CERT_PROT_INIT_ROOTS_FUNC_ID
//
//  Initialize the protected list of CurrentUser roots. Note, no UI.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_PURGE_LM_ROOTS_FUNC_ID
//  
//  Purge all CurrentUser roots from the protected list that also exist
//  in the LocalMachine SystemRegistry "Root" store. Also removes duplicated
//  certificates from the CurrentUser SystemRegistry "Root" store.
//
//  Note, no UI. Purging can be disabled by setting the
//  CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG in the registry's ProtectedRootFlags
//  value.
//
//  No IN/OUT parameters.
//
//  Even if purging is disabled, the protected list of roots is still
//  initialized.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ADD_ROOT_FUNC_ID
//  
//  Add the specified certificate to the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the add.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized certificate context to be added. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_ROOT_FUNC_ID
//  
//  Delete the specified certificate from the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the delete.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  certificate's SHA1 hash property. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID
//  
//  Delete all CurrentUser roots from the protected list that don't also
//  exist in the CurrentUser SystemRegistry "Root" store. The user is
//  prompted before doing the delete.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ROOT_LIST_FUNC_ID
//  
//  Add or remove the signed list of certificates to/from the CurrentUser
//  SystemRegistry "Root" store and the protected list of roots. The user
//  isn't prompted before doing the add or remove.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized CTL containing the signed list of roots to be added or
//  removed. No other IN/OUT parameters.
//
//  CURRENTLY NOT SUPPORTED!!!
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ADD_ROOT_IN_CTL_FUNC_ID
//  
//  Add the certificate in the Auto Update CTL to the HKLM AuthRoot store.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized X.509 certificate immediately followed by the 
//  serialized CTL. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_LOG_EVENT_FUNC_ID
//  
//  Logs a crypt32 event.
//
//  pbIn and cbIn must be updated to point to the following
//  CERT_PROT_EVENT_LOG_PARA data structure. It contains the parameters
//  passed to advapi32!ReportEventW.
//
//  wNumString NULL terminated unicode strings immediately follow. Followed by
//  dwDataSize binary data bytes.
//
//  wCategory, wNumStrings and dwDataSize are optional.
//--------------------------------------------------------------------------
typedef struct _CERT_PROT_EVENT_LOG_PARA {
    WORD            wType;
    WORD            wCategory;      // OPTIONAL, may be 0
    DWORD           dwEventID;
    WORD            wNumStrings;    // OPTIONAL, may be 0
    WORD            wPad1;
    DWORD           dwDataSize;     // OPTIONAL, may be 0
} CERT_PROT_EVENT_LOG_PARA, *PCERT_PROT_EVENT_LOG_PARA;

//+-------------------------------------------------------------------------
//  Called from the client process to do the RPC to the server process.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCltProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    );



typedef void __RPC_FAR * (__RPC_USER *PFN_CERT_PROT_MIDL_USER_ALLOC)(
    IN size_t cb
    );
typedef void (__RPC_USER *PFN_CERT_PROT_MIDL_USER_FREE)(
    IN void __RPC_FAR *pv
    );

//+-------------------------------------------------------------------------
//  Called from the services process to process a protected certificate 
//  function.
//
//  Returns the error status, ie, not returned in LastError.
//--------------------------------------------------------------------------
DWORD
WINAPI
I_CertSrvProtectFunction(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

typedef DWORD (WINAPI *PFN_CERT_SRV_PROTECT_FUNCTION)(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\crypt32l.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crypt32l.h
//
//  Contents:   Crypt32 static library
//              API Prototypes and Definitions
//
//  APIs:       Crypt32DllMain
//
//  NB: This header is for temporary use only, with the static library
//      form of crypt32 (crypt32l).  It should not be used after IE4 ships,
//      since then the correct action will be to use the dll form of crypt32.
//
//--------------------------------------------------------------------------

#ifndef _CRYPT32L_H_
#define _CRYPT32L_H_


//+-------------------------------------------------------------------------
//
//  Function:  Crypt32DllMain
//
//  Synopsis:  Initialize the Crypt32 static library code
//
//  Returns:   FALSE iff failed
//
//  Notes:
//      If crypt32l.lib is linked with an exe, call
//          Crypt32DllMain( NULL, DLL_PROCESS_ATTACH, NULL)
//      at the start of main() and
//          Crypt32DllMain( NULL, DLL_PROCESS_DETACH, NULL)
//      at the end of main().
//
//      If linking with a dll, call Crypt32DllMain from the dll's init
//      routine, passing it the same args as were passed to the init routine.
//
//--------------------------------------------------------------------------
BOOL
WINAPI
Crypt32DllMain(
    HMODULE hInstDLL,
    DWORD   fdwReason,
    LPVOID  lpvReserved
    );


#endif //_CRYPT32L_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\cryptnet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptnet.h
//
//  Contents:   Internal CryptNet API prototypes
//
//  History:    22-Oct-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CRYPTNET_H__)
#define __CRYPTNET_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// I_CryptNetGetUserDsStoreUrl.  Gets the URL to be used for open an
// LDAP store provider over a portion of the DS associated with the
// current user.  The URL can be freed using CryptMemFree
//

BOOL WINAPI
I_CryptNetGetUserDsStoreUrl (
          IN LPWSTR pwszUserAttribute,
          OUT LPWSTR* ppwszUrl
          );

//
// Returns TRUE if we are connected to the internet
//
BOOL
WINAPI
I_CryptNetIsConnected ();

typedef BOOL (WINAPI *PFN_I_CRYPTNET_IS_CONNECTED) ();

//
// Cracks the Url and returns the host name component.
//
BOOL
WINAPI
I_CryptNetGetHostNameFromUrl (
        IN LPWSTR pwszUrl,
        IN DWORD cchHostName,
        OUT LPWSTR pwszHostName
        );

typedef BOOL (WINAPI *PFN_I_CRYPTNET_GET_HOST_NAME_FROM_URL) (
        IN LPWSTR pwszUrl,
        IN DWORD cchHostName,
        OUT LPWSTR pwszHostName
        );

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\crypthlp.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crypthlp.h
//
//  Contents:   Misc internal crypt/certificate helper APIs
//
//  APIs:       I_CryptGetDefaultCryptProv
//              I_CryptGetDefaultCryptProvForEncrypt
//              I_CryptGetFileVersion
//              I_CertSyncStoreEx
//              I_CertSyncStore
//              I_CertUpdateStore
//              I_RecursiveCreateDirectory
//              I_RecursiveDeleteDirectory
//              I_CryptReadTrustedPublisherDWORDValueFromRegistry
//              I_CryptZeroFileTime
//              I_CryptIsZeroFileTime
//              I_CryptIncrementFileTimeBySeconds
//              I_CryptDecrementFileTimeBySeconds
//              I_CryptSubtractFileTimes
//              I_CryptIncrementFileTimeByMilliseconds
//              I_CryptDecrementFileTimeByMilliseconds
//              I_CryptRemainingMilliseconds
//
//  History:    01-Jun-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTHLP_H__
#define __CRYPTHLP_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Cross Cert Distribution Retrieval Times
//

// 8 hours
#define XCERT_DEFAULT_SYNC_DELTA_TIME   (60 * 60 * 8)
// 1 hour
#define XCERT_MIN_SYNC_DELTA_TIME       (60 * 60)

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm supported
//  by the provider type. The provider is acquired with only
//  CRYPT_VERIFYCONTEXT.
//
//  Setting aiPubKey to 0, gets the default provider for RSA_FULL.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  HCRYPTPROVs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProv(
    IN ALG_ID aiPubKey
    );

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm, encrypt
//  key algorithm and encrypt key length supported by the provider type.
//
//  dwBitLen = 0, assumes the aiEncrypt's default bit length. For example,
//  CALG_RC2 has a default bit length of 40.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProvForEncrypt(
    IN ALG_ID aiPubKey,
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    );

//+-------------------------------------------------------------------------
//  crypt32.dll release version numbers
//--------------------------------------------------------------------------
#define IE4_CRYPT32_DLL_VER_MS          ((    5 << 16) | 101 )
#define IE4_CRYPT32_DLL_VER_LS          (( 1670 << 16) |   1 )

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptGetFileVersion(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    );

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore
    );

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//
//  Setting ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG in dwInFlags
//  inhibits the syncing of properties.
//
//  ICERT_SYNC_STORE_CHANGED_OUT_FLAG is returned and set in *pdwOutFlags
//  if any contexts were added or deleted from the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStoreEx(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore,
    IN DWORD dwInFlags,
    OUT OPTIONAL DWORD *pdwOutFlags,
    IN OUT OPTIONAL void *pvReserved
    );

#define ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG      0x00000001
#define ICERT_SYNC_STORE_CHANGED_OUT_FLAG                   0x00010000

//+-------------------------------------------------------------------------
//  Update the original store with contexts from the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertUpdateStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore,
    IN DWORD dwReserved,
    IN OUT void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Recursively creates a full directory path
//--------------------------------------------------------------------------
BOOL 
I_RecursiveCreateDirectory(
    IN LPCWSTR pwszDir,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

//+-------------------------------------------------------------------------
//  Recursively deletes a whole directory
//--------------------------------------------------------------------------
BOOL 
I_RecursiveDeleteDirectory(
    IN LPCWSTR pwszDelete
    );

//+-------------------------------------------------------------------------
//  Recursively copies a whole directory
//--------------------------------------------------------------------------
BOOL 
I_RecursiveCopyDirectory(
    IN LPCWSTR pwszDirFrom,
    IN LPCWSTR pwszDirTo
    );



//+-------------------------------------------------------------------------
//  First checks if the registry value exists in GPO Policies section. If
//  not, checks the LocalMachine section.
//--------------------------------------------------------------------------
BOOL
I_CryptReadTrustedPublisherDWORDValueFromRegistry(
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValue
    );

//+-------------------------------------------------------------------------
//  Zero's the filetime
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptZeroFileTime(
    OUT LPFILETIME pft
    )
{
    pft->dwLowDateTime = 0;
    pft->dwHighDateTime = 0;
}

//+-------------------------------------------------------------------------
//  Check for a filetime of 0. Normally, this indicates the filetime
//  wasn't specified.
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
I_CryptIsZeroFileTime(
    IN LPFILETIME pft
    )
{
    if (0 == pft->dwLowDateTime && 0 == pft->dwHighDateTime)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Increment the filetime by the specified number of seconds.
//
//  Filetime is in units of 100 nanoseconds.  Each second has
//  10**7 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptIncrementFileTimeBySeconds(
    IN LPFILETIME pftSrc,
    IN DWORD dwSeconds,
    OUT LPFILETIME pftDst
    )
{
	*(((DWORDLONG UNALIGNED *) pftDst)) =
	    *(((DWORDLONG UNALIGNED *) pftSrc)) +
        (((DWORDLONG) dwSeconds) * 10000000i64);
}

//+-------------------------------------------------------------------------
//  Decrement the filetime by the specified number of seconds.
//
//  Filetime is in units of 100 nanoseconds.  Each second has
//  10**7 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptDecrementFileTimeBySeconds(
    IN LPFILETIME pftSrc,
    IN DWORD dwSeconds,
    OUT LPFILETIME pftDst
    )
{
	*(((DWORDLONG UNALIGNED *) pftDst)) =
	    *(((DWORDLONG UNALIGNED *) pftSrc)) -
        (((DWORDLONG) dwSeconds) * 10000000i64);
}

//+-------------------------------------------------------------------------
//  Subtract two filetimes and return the number of seconds.
//
//  The second filetime is subtracted from the first. If the first filetime
//  is before the second, then, 0 seconds is returned.
//  
//  Filetime is in units of 100 nanoseconds.  Each second has
//  10**7 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
DWORD
WINAPI
I_CryptSubtractFileTimes(
    IN LPFILETIME pftFirst,
    IN LPFILETIME pftSecond
    )
{
    DWORDLONG qwDiff;

    if (0 >= CompareFileTime(pftFirst, pftSecond))
        return 0;


    qwDiff = *(((DWORDLONG UNALIGNED *) pftFirst)) -
        *(((DWORDLONG UNALIGNED *) pftSecond));

    return (DWORD) (qwDiff / 10000000i64);
}


//+-------------------------------------------------------------------------
//  Increment the filetime by the specified number of milliseconds.
//
//  Filetime is in units of 100 nanoseconds.  Each millisecond has
//  10**4 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptIncrementFileTimeByMilliseconds(
    IN LPFILETIME pftSrc,
    IN DWORD dwMilliseconds,
    OUT LPFILETIME pftDst
    )
{
	*(((DWORDLONG UNALIGNED *) pftDst)) =
	    *(((DWORDLONG UNALIGNED *) pftSrc)) +
        (((DWORDLONG) dwMilliseconds) * 10000i64);
}

//+-------------------------------------------------------------------------
//  Decrement the filetime by the specified number of milliseconds.
//
//  Filetime is in units of 100 nanoseconds.  Each millisecond has
//  10**4 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptDecrementFileTimeByMilliseconds(
    IN LPFILETIME pftSrc,
    IN DWORD dwMilliseconds,
    OUT LPFILETIME pftDst
    )
{
	*(((DWORDLONG UNALIGNED *) pftDst)) =
	    *(((DWORDLONG UNALIGNED *) pftSrc)) -
        (((DWORDLONG) dwMilliseconds) * 10000i64);
}


//+-------------------------------------------------------------------------
//  Return the number of milliseconds remaining before the specified end
//  filetime.
//
//  The current filetime is subtracted from the end filetime. If the current
//  filetime is after or the same as the end filetime, then, 0 milliseconds
//  is returned.
//  
//  Filetime is in units of 100 nanoseconds.  Each millisecond has
//  10**4 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
DWORD
WINAPI
I_CryptRemainingMilliseconds(
    IN LPFILETIME pftEnd
    )
{
    FILETIME ftCurrent;
    DWORDLONG qwDiff;

    GetSystemTimeAsFileTime(&ftCurrent);

    if (0 >= CompareFileTime(pftEnd, &ftCurrent))
        return 0;


    qwDiff = *(((DWORDLONG UNALIGNED *) pftEnd)) -
        *(((DWORDLONG UNALIGNED *) &ftCurrent));

    return (DWORD) (qwDiff / 10000i64);
}


#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptUninstallOssGlobal
//              I_CryptGetOssGlobal
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "msasn1.h"
#include "ossglobl.h"
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed OssGlobal table
typedef DWORD HCRYPTOSSGLOBAL;

// Pointer to OssGlobal. Returned by I_CryptGetOssGlobal()
typedef  OssGlobal  *POssGlobal;

// Handle to an installed Asn1 module
typedef DWORD HCRYPTASN1MODULE;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an OssGlobal entry. Iterate
//  through the threads and frees their allocated copy of OssGlobal.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    return (HCRYPTASN1MODULE) I_CryptInstallOssGlobal(
        pvCtlTbl, dwFlags, pvReserved);
}
#else

HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return I_CryptUninstallOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1encoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1decoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifndef _XELIBCA_SRC_
#ifdef __cplusplus
    extern "C" 
    {
#endif
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


#ifdef _XELIBCA_SRC_

// Copied from CA\include\cs.h:

#define DBG_SS_INFO	 0x00000004	// or in with any of the below
#define DBG_SS_CERTLIB	 0x40000000
#define DBG_SS_CERTLIBI		(DBG_SS_CERTLIB | DBG_SS_INFO)
#define DBG_SS_TRACE		DBG_SS_CERTLIBI
#define DBG_SS_APP		DBG_SS_CERTLIB

#else // _XELIBCA_SRC_

//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000
#define DBG_SS_CATDBSVC                     0x00800000

#define DBG_SS_APP                          0x10000000

#define DBG_SS_TRACE			    DBG_SS_CRYPT32

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                DBG_SS_CATDBSVC,    "CATDBSV",  \
                                NULL, NULL                      \
                            }
#endif // _XELIBCA_SRC_

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG

    extern int WINAPIV DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);

#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_TRACE, argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_TRACE, name)
#define SET_ERROR(name, err)            SET_ERROR_EX(DBG_SS_TRACE, name, err)
#define SET_ERROR_VAR(name, err)        SET_ERROR_VAR_EX(DBG_SS_TRACE, name, err)
#define SET_HRESULT(name, err)          SET_HRESULT_EX(DBG_SS_TRACE, name, err)
#define SET_HRESULT_VAR(name, err)      SET_HRESULT_VAR_EX(DBG_SS_TRACE, name, err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_TRACE, name)


#ifndef _XELIBCA_SRC_
#ifdef __cplusplus
    }       // balance of extern "C"
#endif
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\cryptver.h ===
/*+-------------------------------------------------------------------------
 *
 *  Microsoft Windows
 *
 *  Copyright (C) Microsoft Corporation, 1996 - 1999
 *
 *  File:       cryptver.h
 *
 *  Contents:   Microsoft Internet Security versioning
 *
 *  History:    14-Aug-1997 pberkman   created
 *
 *--------------------------------------------------------------------------*/

#include <ntverp.h>

#define VER_FILEDESCRIPTION_STR_TRUST   "Microsoft Trust "

#undef VER_PRODUCTMINOR

#ifdef _ISPUCAB
/* x86fre IE BUILD */
#   define VER_PRODUCTMINOR         101
#else
/* REAL NT BUILD */
#   define VER_PRODUCTMINOR         131
#endif

#undef VER_PRODUCTVERSION_STRING
#define VER_PRODUCTVERSION_STRING   "5"

#undef VER_PRODUCTVERSION
#define VER_PRODUCTVERSION          5,VER_PRODUCTMINOR,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#undef VER_BPAD
#if 	(VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif	(VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif	(VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#if 	(VER_PRODUCTMINOR < 10)
#define VERM_BPAD "00"
#elif	(VER_PRODUCTMINOR < 100)
#define VERM_BPAD "0"
#else
#define VERM_BPAD
#endif


#define VER_PRODUCTVERSION_STR2x(w,x,y) VER_PRODUCTVERSION_STRING "." VERM_BPAD #w "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1x(w,x,y) VER_PRODUCTVERSION_STR2x(w, x, y)

#undef VER_PRODUCTVERSION_STR
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1x(VER_PRODUCTMINOR, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\dpapiprv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dpapiprv.h
//
//--------------------------------------------------------------------------

//
// private header for secure storage
//

#ifndef __DPAPIPRV_H__
#define __DPAPIPRV_H__

#define SECURITY_WIN32
#include <security.h>
#include <spseal.h>
#include <sspi.h>
#include <secpkg.h>

// use TEXT() so that cred_nt.c can use Unicode RPC

#define DPAPI_LOCAL_ENDPOINT        L"protected_storage"
#define DPAPI_LOCAL_PROT_SEQ        L"ncalrpc"

#define DPAPI_BACKUP_ENDPOINT        L"\\PIPE\\protected_storage"
#define DPAPI_BACKUP_PROT_SEQ        L"ncacn_np"

#define DPAPI_LEGACY_BACKUP_ENDPOINT  L"\\PIPE\\ntsvcs"
#define DPAPI_LEGACY_BACKUP_PROT_SEQ  L"ncacn_np"



//
// CryptProtect #defines

#define REG_CRYPTPROTECT_LOC        L"SOFTWARE\\Microsoft\\Cryptography\\Protect"

#define REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC            L"Providers"
#define REG_CRYPTPROTECT_PREFERREDPROVIDER_VALUELOC     L"Preferred"
#define REG_CRYPTPROTECT_PROVIDERPATH_VALUELOC          L"Image Path"
#define REG_CRYPTPROTECT_PROVIDERNAME_VALUELOC          L"Name"
#define REG_CRYPTPROTECT_ALLOW_CACHEPW                  L"AllowCachePW"

/* df9d8cd0-1501-11d1-8c7a-00c04fc297eb */
#define CRYPTPROTECT_DEFAULT_PROVIDER_GUIDSZ L"df9d8cd0-1501-11d1-8c7a-00c04fc297eb"
#define CRYPTPROTECT_DEFAULT_PROVIDER   { 0xdf9d8cd0, 0x1501, 0x11d1, {0x8c, 0x7a, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb} }

#define CRYPTPROTECT_DEFAULT_PROVIDER_FRIENDLYNAME  L"System Protection Provider"
#define CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG              L"Encr Alg"
#define CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG               L"MAC Alg"
#define CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG_KEYSIZE      L"Encr Alg Key Size"
#define CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG_KEYSIZE       L"MAC Alg Key Size"
#define CRYPTPROTECT_DEFAULT_PROVIDER_CRYPT_PROV_TYPE       L"Default CSP Type"





//
// This flag is used for the French version, indicating no encryption.
#define CRYPTPROTECT_NO_ENCRYPTION  0x10000000

#define CRYPTPROTECT_IN_PROCESS     0x20000000


#ifdef __cplusplus
extern "C" {
#endif

//
// Exports for lsasrv.dll 
//
DWORD
NTAPI
DPAPIInitialize(
    LSA_SECPKG_FUNCTION_TABLE *pSecpkgTable);

DWORD
NTAPI 
DPAPIShutdown( );


#ifdef __cplusplus
}
#endif

#endif // __DPAPIPRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\cryptreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cryptreg.h
//
//  Contents:   Microsoft Internet Security Registry Keys
//
//  History:    04-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef CRYPTREG_H
#define CRYPTREG_H

//
//  MAXs
//
#define REG_MAX_FUNC_NAME           64
#define REG_MAX_KEY_NAME            128
#define REG_MAX_GUID_TEXT           39      // 38 + NULL

//
//  HKEY_LOCAL_MACHINE
//

#define REG_MACHINE_SETTINGS_KEY    L"Software\\Microsoft\\Cryptography\\Machine Settings"

#define REG_INIT_PROVIDER_KEY       L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Initialization"
#define REG_OBJTRUST_PROVIDER_KEY   L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Message"
#define REG_SIGTRUST_PROVIDER_KEY   L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Signature"
#define REG_CERTTRUST_PROVIDER_KEY  L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Certificate"
#define REG_CERTPOL_PROVIDER_KEY    L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\CertCheck"
#define REG_FINALPOL_PROVIDER_KEY   L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\FinalPolicy"
#define REG_TESTPOL_PROVIDER_KEY    L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\DiagnosticPolicy"
#define REG_CLEANUP_PROVIDER_KEY    L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Cleanup"
#define REG_TRUST_USAGE_KEY         L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Usages"

//  3-Dec-1997 pberkman: removed
//#define REG_SIP_PROVIDER_KEY        L"Software\\Microsoft\\Cryptography\\Providers\\Subject"
//#define REG_SIP_HINTS_KEY           L"Software\\Microsoft\\Cryptography\\Providers\\Subject\\Hints"
//#define REG_SIP_HINTS_MAGIC_KEY     L"Software\\Microsoft\\Cryptography\\Providers\\Subject\\Hints\\MagicNumber"

#define REG_REVOKE_PROVIDER_KEY     L"Software\\Microsoft\\Cryptography\\Providers\\Revocation"
#define REG_SP_REVOKE_PROVIDER_KEY  L"Software\\Microsoft\\Cryptography\\Providers\\Revocation\\SoftwarePublishing"


#define REG_DLL_NAME                L"$DLL"
#define REG_FUNC_NAME               L"$Function"

#define REG_FUNC_NAME_SIP_GET       L"$GetFunction"
#define REG_FUNC_NAME_SIP_PUT       L"$PutFunction"
#define REG_FUNC_NAME_SIP_CREATE    L"$CreateFunction"
#define REG_FUNC_NAME_SIP_VERIFY    L"$VerifyFunction"
#define REG_FUNC_NAME_SIP_REMOVE    L"$RemoveFunction"
#define REG_FUNC_NAME_SIP_HINT_IS   L"$IsFunction"
#define REG_FUNC_NAME_SIP_HINT_IS2  L"$IsFunctionByName"

#define REG_DEF_FOR_USAGE           L"DefaultId"
#define REG_DEF_CALLBACK_ALLOC      "CallbackAllocFunction"
#define REG_DEF_CALLBACK_FREE       "CallbackFreeFunction"

//
//  HKEY_CURRENT_USER
//

#define REG_PKITRUST_USERDATA       L"Software\\Microsoft\\Cryptography\\UserData"
#define REG_PKITRUST_TSTAMP_URL     L"TimestampURL"
#define REG_PKITRUST_MY_URL         L"MyInfoURL"
#define REG_PKITRUST_LASTDESC       L"LastContentDesc"

//////////////////////////////////////////////////////////////////////////////
//
// Wintrust Policy Flags registry location
//----------------------------------------------------------------------------
//  The following is where the DWORD can be found in the HKEY_CURRENT_USER 
//  registry.  See wintrust.h for further information.
//
#define REGPATH_WINTRUST_POLICY_FLAGS   L"Software\\Microsoft\\Windows\\CurrentVersion\\" \
                                        L"WinTrust\\Trust Providers\\Software Publishing"
#define REGNAME_WINTRUST_POLICY_FLAGS   L"State"


#endif // CRYPTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\ihgttran.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ihgttran.h
//
//--------------------------------------------------------------------------

typedef ULONG_PTR  HUTTRAN;

typedef DWORD (__stdcall * PFNOpen) (HUTTRAN * phTran, const TCHAR * tszBinding, DWORD fOpen);
typedef DWORD (__stdcall * PFNSend) (HUTTRAN hTran, DWORD dwEncoding, DWORD cbSendBuff, const BYTE * pbSendBuff);
typedef DWORD (__stdcall * PFNFree) (HUTTRAN hTran, BYTE * pb);
typedef DWORD (__stdcall * PFNReceive) (HUTTRAN hTran, DWORD * pdwEncoding, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff);
typedef DWORD (__stdcall * PFNClose) (HUTTRAN hTran);

typedef struct _IGTS {
	HINSTANCE	hLib;
	HUTTRAN		hTran;
	PFNOpen		PfnOpen;
	PFNSend		PfnSend;
	PFNFree		PfnFree;
	PFNReceive	PfnReceive;
	PFNClose	PfnClose;
} IGTS;


#ifdef __cplusplus

extern "C" DWORD __stdcall GTInitSrv(TCHAR * tszLibrary);
extern "C" DWORD __stdcall GTUnInitSrv(void);

#else


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\frmtcom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       frmtcom.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////
//
//	   The common format file for both WIN32API and 
//	   activeX FormatCert control
//
//
//	   Created: Xiaohs
//				March-12-97
//
//
//////////////////////////////////////////////////////////////////
#ifndef __COMMON_FORMAT_H__
#define __COMMON_FORMAT_H__

#ifdef __cplusplus
extern "C" {
#endif


//constants for dwFormatStrType
//The default behavior of CryptFormatObject is to return single line
//display.  If there is no formatting routine installed for registered
//for the OID, the hex dump will be returned.  User can set the flag
//CRYPT_FORMAT_STR_NO_HEX to disable the hex dump.  If user prefers
//a multiple link display, set the flag  CRYPT_FORMAT_STR_MULTI_LINE

#define         CRYPT_FORMAT_STR_MULTI_LINE         0x0001

#define         CRYPT_FORMAT_STR_NO_HEX             0x0010

//--------------------------------------------------------------------
// Following are possible values for dwFormatType for formatting X509_NAME
// or X509_UNICODE_NAME
//--------------------------------------------------------------------
//Just get the simple string
#define	CRYPT_FORMAT_SIMPLE			0x0001

//Put an attribute name infront of the attribute
//such as "O=Microsoft,DN=xiaohs"
#define	CRYPT_FORMAT_X509			0x0002

//Put an OID infront of the simple string, such as 
//"2.5.4.22=Microsoft,2.5.4.3=xiaohs"
#define CRYPT_FORMAT_OID			0x0004


//Put a ";" between each RDN.  The default is "," 
#define	CRYPT_FORMAT_RDN_SEMICOLON	0x0100

//Put a "\n" between each RDN.   
#define	CRYPT_FORMAT_RDN_CRLF		0x0200


//Unquote the DN value, which is quoated by default va the following 
//rules: if the DN contains leading or trailing 
//white space or one of the following characters: ",", "+", "=", 
//""", "\n",  "<", ">", "#" or ";". The quoting character is ". 
//If the DN Value contains a " it is double quoted ("").
#define	CRYPT_FORMAT_RDN_UNQUOTE	0x0400

//reverse the order of the RDNs before converting to the string
#define CRYPT_FORMAT_RDN_REVERSE	0x0800


///-------------------------------------------------------------------------
// Following are possible values for dwFormatType for formatting a DN.:
//
//  The following three values are defined in the section above:
//  CRYPT_FORMAT_SIMPLE:    Just a simple string
//                          such as  "Microsoft+xiaohs+NT"
//  CRYPT_FORMAT_X509       Put an attribute name infront of the attribute
//                          such as "O=Microsoft+xiaohs+NT"
//                         
//  CRYPT_FORMAT_OID        Put an OID infront of the simple string, 
//                          such as "2.5.4.22=Microsoft+xiaohs+NT"
//
//  Additional values are defined as following:
//----------------------------------------------------------------------------
//Put a "," between each value.  Default is "+" 
#define CRYPT_FORMAT_COMMA			0x1000

//Put a ";" between each value 
#define CRYPT_FORMAT_SEMICOLON		CRYPT_FORMAT_RDN_SEMICOLON

//Put a "\n" between each value 
#define CRYPT_FORMAT_CRLF			CRYPT_FORMAT_RDN_CRLF


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif	//__COMMON_FORMAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\gttran.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       gttran.h
//
//  Contents:   Generic Transport APIs
//
//  APIs:
//              GTOpen
//              GTSend
//              GTFree
//              GTReceive
//              GTClose
//              GTRecSend
//              GTInitSrv
//              GTUnInitSrv
//
//  Created KeithV
//--------------------------------------------------------------------------

#ifndef _HGTTRAN_H_
#define _HGTTRAN_H_

#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Encoding types
//
//  Because the Composit type for ASN is 0x30, we will define this to
//  be the encoding type for it.
//--------------------------------------------------------------------------

#define ASCII_ENCODING  0x0
#define TLV_ENCODING    0x1
#define IDL_ENCODING    0x2
#define OCTET_ENCODING  0x3
#define ASN_ENCODING    0x30

//+-------------------------------------------------------------------------
//  Functions will allow you to read, write or both
//  To do both, OR (|) them together.
//--------------------------------------------------------------------------

#define GTREAD    0x00000001
#define GTWRITE   0x00000002

typedef ULONG_PTR  HGT;

//+-------------------------------------------------------------------------
//  Any receiving (listening) DLL must export these functions
//--------------------------------------------------------------------------
typedef DWORD (__stdcall * PFNGTRecSend) (DWORD dwEncoding, DWORD cb, const BYTE * pbIn, DWORD * pcbOut, BYTE ** ppbOut);
typedef DWORD (__stdcall * PFNGTFree) (BYTE * pb);

//+-------------------------------------------------------------------------
//  Functions used by and application that wants to send a message
//  Just like File IO
//--------------------------------------------------------------------------
DWORD __stdcall GTOpen(HGT * phTran, const TCHAR * szLibrary, const TCHAR * tszBinding, DWORD fOpen);
DWORD __stdcall GTSend(HGT hTran, DWORD dwEncoding, DWORD cbSendBuff, const BYTE * pbSendBuff);
DWORD __stdcall GTFree(HGT hTran, BYTE * pb);
DWORD __stdcall GTReceive(HGT hTran, DWORD * pdwEncoding, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff);
DWORD __stdcall GTClose(HGT hTran);

//+-------------------------------------------------------------------------
//  Listening functions for a listening application.
//  The GTFree prototype is also used as specified above
//--------------------------------------------------------------------------
DWORD __stdcall GTRecSend(DWORD dwEncoding, DWORD cb, const BYTE * pbIn, DWORD * pcbOut, BYTE ** ppbOut);

//+-------------------------------------------------------------------------
//  Additonal private listening functions for a listening application.
//  Not generally implemented.
//--------------------------------------------------------------------------
DWORD __stdcall GTRecSendNoEncrypt(DWORD dwEncoding, DWORD cb, const BYTE * pbIn, DWORD * pcbOut, BYTE ** ppbOut);


//+-------------------------------------------------------------------------
//  Used to init a receiving DLL, particularly useful for HTTP BGI, CGI application
//--------------------------------------------------------------------------
DWORD __stdcall GTInitSrv(TCHAR * tszLibrary);
DWORD __stdcall GTUnInitSrv(void);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\dsysdbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dsysdbg.h
//
//  Contents:   Merged all the debug code together
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DSYSDBG_H__
#define __DSYSDBG_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

typedef struct _DEBUG_KEY {
    DWORD   Mask;
    PCHAR   Tag;
} DEBUG_KEY, * PDEBUG_KEY;

#define DSYSDBG_OPEN_ONLY       0x00000001
#define DSYSDBG_DEMAND_OPEN     0x00000002
#define DSYSDBG_BREAK_ON_ERROR  0x00000004

#define DSYSDBG_ASSERT_CONTINUE 0
#define DSYSDBG_ASSERT_BREAK    1
#define DSYSDBG_ASSERT_SUSPEND  2
#define DSYSDBG_ASSERT_KILL     3
#define DSYSDBG_ASSERT_PROMPT   4
#define DSYSDBG_ASSERT_DEBUGGER 5

//
// Global Flags exposed to callers:
//

#define DEBUG_HEAP_CHECK    0x00000040      // Check Heap on every debug out
#define DEBUG_MULTI_THREAD  0x00000080      // Use critical section in header
#define DEBUG_BREAK_ON_ERROR 0x00000400     // Break on an error out

VOID    _DsysAssertEx(PVOID FailedAssertion, PVOID FileName, ULONG LineNumber,
                        PCHAR Message, ULONG ContinueCode);
VOID    _DebugOut(PVOID pControl, ULONG Mask, CHAR * Format, va_list ArgList);
VOID    _InitDebug(DWORD Flags, DWORD * InfoLevel, PVOID * Control, char * ModuleName, PDEBUG_KEY pKey);
VOID    _UnloadDebug( PVOID pControl );
VOID    _DbgSetOption(PVOID pControl, DWORD Flag, BOOL On, BOOL Global);
VOID    _DbgSetLoggingOption(PVOID pControl, BOOL On);
VOID    DbgpDumpException(PVOID p);

//  Hack to allow retail builds to include debug support
//  define RETAIL_LOG_SUPPORT in your sources to do it!
#ifdef RETAIL_LOG_SUPPORT
#define DEBUG_SUPPORT
#else
#if DBG
#define DEBUG_SUPPORT
#endif
#endif


#ifdef DEBUG_SUPPORT
//
// Use this in your header file.  It declares the variables that we need
//

#define DECLARE_DEBUG2(comp)                                \
extern PVOID    comp##ControlBlock;                         \
extern DWORD    comp##InfoLevel;                            \
void   comp##DebugPrint(ULONG Mask, CHAR * Format, ... );   \

//
// Use this when you control when you are initialized, for example a DLL or
// EXE.  This defines the wrapper functions that will call into dsysdbg.lib
//

#define DEFINE_DEBUG2(comp)                                 \
PVOID   comp##ControlBlock = NULL ;                         \
DWORD   comp##InfoLevel;                                    \
PVOID   comp##__DebugKeys;                                  \
void comp##DebugPrint(                                      \
    ULONG Mask,                                             \
    CHAR * Format,                                          \
    ... )                                                   \
{                                                           \
    va_list ArgList;                                        \
    va_start(ArgList, Format);                              \
    _DebugOut( comp##ControlBlock, Mask, Format, ArgList);  \
}                                                           \
void                                                        \
comp##InitDebugEx(DWORD Flags, PDEBUG_KEY pKey)             \
{                                                           \
    comp##__DebugKeys = pKey;                               \
    _InitDebug(Flags, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##InitDebug(PDEBUG_KEY  pKey)                           \
{                                                           \
    _InitDebug(0, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##SetOption(DWORD Option, BOOL On, BOOL Global)         \
{                                                           \
    _DbgSetOption( comp##ControlBlock, Option, On, Global); \
}                                                           \
void                                                        \
comp##SetLoggingOption(BOOL On)                             \
{                                                           \
   _DbgSetLoggingOption(comp##ControlBlock, On);            \
}                                                           \
void                                                        \
comp##UnloadDebug(void)                                     \
{                                                           \
    _UnloadDebug( comp##ControlBlock );                     \
    comp##ControlBlock = NULL ;                             \
}


//
// Use this when you don't control when you are initialized, e.g. a static
// library like the gluon code.
//
#define DEFINE_DEBUG_DEFER(comp,keys)                       \
PVOID       comp##ControlBlock = INVALID_HANDLE_VALUE;      \
DWORD       comp##InfoLevel;                    \
PDEBUG_KEY  comp##__DebugKeys = keys;                       \
void comp##DebugPrint(                                      \
    ULONG Mask,                                             \
    CHAR * Format,                                          \
    ... )                                                   \
{                                                           \
    va_list ArgList;                                        \
    va_start(ArgList, Format);                              \
    if (comp##ControlBlock == INVALID_HANDLE_VALUE)         \
    {                                                       \
        _InitDebug(DSYSDBG_DEMAND_OPEN, & comp##InfoLevel, & comp##ControlBlock, #comp, comp##__DebugKeys); \
    }                                                       \
    _DebugOut( comp##ControlBlock, Mask, Format, ArgList);  \
}                                                           \
void                                                        \
comp##InitDebugEx(DWORD Flags, PDEBUG_KEY pKey)             \
{                                                           \
    comp##__DebugKeys = pKey;                               \
    _InitDebug(Flags, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##InitDebug(PDEBUG_KEY  pKey)                           \
{                                                           \
    _InitDebug(DSYSDBG_DEMAND_OPEN, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##UnloadDebug(void)                                     \
{                                                           \
    _UnloadDebug( comp##ControlBlock );                     \
}


#else   // NOT DEBUG_SUPPORT

//
// Empty defines for the retail case:
//
#define DECLARE_DEBUG2(comp)

#define DEFINE_DEBUG2(comp)

#define DEFINE_DEBUG_DEFER(x, y)


#endif // DEBUG_SUPPORT 



#if DBG
//
// Moved assertions to new section, so no asserts occur in retail builds
// with DEBUG_SUPPORT. 
//
// Assertions:  Most should use DsysAssert or DsysAssertMsg.  These forward on
// the call to dsysdbg.lib, with the continue code set to drop into the
// debugger.  The more sophisticated can call DsysAssertEx, which allows you
// to specify one of the assert codes from above:
//

#define DsysAssertEx(exp, ContinueCode) \
            if (!(exp)) \
                _DsysAssertEx( #exp, __FILE__, __LINE__, NULL, ContinueCode);

#define DsysAssertMsgEx(exp, Message, ContinueCode) \
            if (!(exp)) \
                _DsysAssertEx( #exp, __FILE__, __LINE__, Message, ContinueCode);

#define DsysAssertMsg(exp, Message) DsysAssertMsgEx(exp, Message, DSYSDBG_ASSERT_DEBUGGER)


#define DsysAssert(exp) DsysAssertMsgEx(exp, NULL, DSYSDBG_ASSERT_DEBUGGER)

#define DsysException(p)    DbgpDumpException(p)

#define SZ_DEFAULT_PROFILE_STRING   "Error"         

#else // retail builds cannot contain asserts...


#define DsysAssertEx(x,y)
#define DsysAssertMsgEx(x, y, z)
#define DsysAssert(x)
#define DsysAssertMsg(x, y)

#define DsysException(p)

#define SZ_DEFAULT_PROFILE_STRING   ""

#endif // dbg


#ifndef DEB_ERROR
#define DEB_ERROR   0x00000001
#endif

#ifndef DEB_WARN
#define DEB_WARN    0x00000002
#endif

#ifndef DEB_TRACE
#define DEB_TRACE   0x00000004
#endif

#define DSYSDBG_FORCE   0x80000000
#define DSYSDBG_CLEAN   0x40000000


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSYSDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\enroll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       enroll.h
//
//--------------------------------------------------------------------------

typedef void * HSES;

BOOL WINAPI Enroll(
    WCHAR *     wszContainer,
    WCHAR *     wszProvider,
    HSES *      phSes,
    BYTE **     ppbCertReq,
    DWORD *     pcbCertReq);

BOOL WINAPI Accept(
    HSES    SessionId,
    BYTE *  pbBuff,
    DWORD   cbBuff);

BOOL WINAPI TermSession(
    HSES  SessionId);


BOOL WINAPI SetHInstance(
    HINSTANCE   hinst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\errlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       errlog.h
//
//  Contents:   generic error logging
//
//  History:    19-Jun-00   reidk   created
//
//--------------------------------------------------------------------------

#ifndef ERRLOG_H
#define ERRLOG_H

#define ERRLOG_CLIENT_ID_CATDBSCV   1
#define ERRLOG_CLIENT_ID_CATADMIN   2
#define ERRLOG_CLIENT_ID_CATDBCLI   3
#define ERRLOG_CLIENT_ID_WAITSVC    4
#define ERRLOG_CLIENT_ID_TIMESTAMP  5


#define ERRLOG_LOGERROR_LASTERROR(x,y) ErrLog_LogError(x, y, __LINE__, 0, FALSE);   
#define ERRLOG_LOGERROR_PARAM(x,y,z)   ErrLog_LogError(x, y, __LINE__, z, FALSE);
#define ERRLOG_LOGERROR_WARNING(x,y,z) ErrLog_LogError(x, y, __LINE__, z, TRUE);

void
ErrLog_LogError(
    LPWSTR  pwszLogFileName,    // NULL - means log to the catalog DB logfile
    DWORD   dwClient,
    DWORD   dwLine,
    DWORD   dwErr,              // 0 - means use GetLastError()
    BOOL    fWarning,
    BOOL    fLogToFileOnly);

void
ErrLog_LogString(
    LPWSTR  pwszLogFileName,    // NULL - means log to the catalog DB logfile
    LPWSTR  pwszMessageString,
    LPWSTR  pwszExtraString,
    BOOL    fLogToFileOnly);

BOOL
TimeStampFile_Touch(
    LPWSTR  pwszDir);

BOOL
TimeStampFile_InSync(
    LPWSTR  pwszDir1,
    LPWSTR  pwszDir2,
    BOOL    *pfInSync);


#endif // ERRLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\format.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:      format.h
//
//  Contents:   The header for format.cpp
//
//  History:    21-February-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef __FORMAT_H__
#define __FORMAT_H__


#ifdef __cplusplus
extern "C" {
#endif


//---------------------------------------------------------
//the following defines should go to the headers in 
// crypt0 2.0
//-----------------------------------------------------------

//the dll routine for formatting the attributes
//in the certificate
BOOL	WINAPI	CryptDllFormatAttr(  
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pBuffer,
				DWORD		*pcBuffer);

//The routine to format the complet DN.
BOOL	WINAPI	CryptDllFormatName(  
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pbBuffer,
				DWORD		*pcbBuffer);

BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatBasicConstraints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatCRLReasonCode(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatEnhancedKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatAltName(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatAuthorityKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatAuthorityKeyID2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatNextUpdateLocation(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatSubjectKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatFinancialCriteria(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatSMIMECapabilities(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatAuthortiyInfoAccess(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL                                   
WINAPI                                 
FormatKeyAttributes(                   
	DWORD		dwCertEncodingType,    
	DWORD		dwFormatType,          
	DWORD		dwFormatStrType,       
	void		*pFormatStruct,        
	LPCSTR		lpszStructType,        
	const BYTE *pbEncoded,             
	DWORD		cbEncoded,             
	void	   *pbFormat,              
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatKeyRestriction(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);
             
BOOL
WINAPI
FormatCRLDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatCertPolicies(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatSPAgencyInfo(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);





#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif // __FORMAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\keyback.h ===
/*++

Copyright (C) 1996, 1997  Microsoft Corporation

Module Name:

    keyback.h

Abstract:

    This module defines the Key Backup interface and associated data structures.

Author:

    Scott Field (sfield)    16-Aug-97

--*/

#ifndef __KEYBACK_H__
#define __KEYBACK_H__

//
// Back up a key
//
#define BACKUPKEY_BACKUP_GUID           { 0x7f752b10, 0x178e, 0x11d1, { 0xab, 0x8f, 0x00, 0x80, 0x5f, 0x14, 0xdb, 0x40 } }

//
// Restore a key, wraping it in the pbBK format,
// for downlevel compatability
//
#define BACKUPKEY_RESTORE_GUID_W2K      { 0x7fe94d50, 0x178e, 0x11d1, { 0xab, 0x8f, 0x00, 0x80, 0x5f, 0x14, 0xdb, 0x40 } }

#define BACKUPKEY_RESTORE_GUID          { 0x47270c64, 0x2fc7, 0x499b,  {0xac, 0x5b, 0x0e, 0x37, 0xcd, 0xce, 0x89, 0x9a} }
// Retrieve the public backup certificate
#define BACKUPKEY_RETRIEVE_BACKUP_KEY_GUID  { 0x018ff48a, 0xeaba, 0x40c6, { 0x8f, 0x6d, 0x72, 0x37, 0x02, 0x40, 0xe9, 0x67 } }


#define BACKUPKEY_RECOVERY_BLOB_VERSION_W2K 1   // 

 
#define BACKUPKEY_RECOVERY_BLOB_VERSION 2      // version of recovery blob containing
                                               // MK and LK directly.


//
// Header for the backupkey blob version
// Folowed by the master key and payload key encrypted
// by the key indicated by guidKey.  The encrypted data is
// represented in a PKCS#1v2 formmated (CRYPT_OAEP) blob
// That data is followed by the encrypted payload
//

typedef struct {
    DWORD dwVersion;              // version of structure (BACKUPKEY_RECOVERY_BLOB_VERSION)
    DWORD cbEncryptedMasterKey;   // quantity of encrypted master key data following structure
    DWORD cbEncryptedPayload;     // quantity of encrypted payload
    GUID guidKey;                 // guid identifying backup key used
} BACKUPKEY_RECOVERY_BLOB, 
 *PBACKUPKEY_RECOVERY_BLOB, 
 *LPBACKUPKEY_RECOVERY_BLOB;

typedef struct {
    DWORD   cbMasterKey;
    DWORD   cbPayloadKey;
} BACKUPKEY_KEY_BLOB,
  *PBACKUPKEY_KEY_BLOB,
  *LPBACKUPKEY_KEY_BLOB;


//
// Header for the inner blob of the master key recovery blob
// Following the header is LocalKey, then the SID, and finally
// a SHA_1 MAC of the contained data 

typedef struct {
    DWORD dwPayloadVersion;
    DWORD cbLocalKey;
} BACKUPKEY_INNER_BLOB, 
 *PBACKUPKEY_INNER_BLOB, 
 *LPBACKUPKEY_INNER_BLOB;

#define BACKUPKEY_PAYLOAD_VERSION   1


#define MASTERKEY_BLOB_RAW_VERSION  0

#define MASTERKEY_BLOB_VERSION_W2K  1

#define MASTERKEY_BLOB_VERSION      2

#define MASTERKEY_BLOB_LOCALKEY_BACKUP  3

#define MASTERKEY_R2_LEN_W2K            (16)
#define MASTERKEY_R3_LEN_W2K            (16)

typedef struct {
    DWORD dwVersion;            // version of structure (MASTERKEY_BLOB_VERSION_W2K)
    BYTE R2[MASTERKEY_R2_LEN_W2K];  // random data used during HMAC to derive symetric key
} MASTERKEY_BLOB_W2K, *PMASTERKEY_BLOB_W2K, *LPMASTERKEY_BLOB_W2K;


typedef struct {
    BYTE R3[MASTERKEY_R3_LEN_W2K];  // random data used to derive MAC key
    BYTE MAC[A_SHA_DIGEST_LEN]; // HMAC(R3, pbMasterKey)
} MASTERKEY_INNER_BLOB_W2K, *PMASTERKEY_INNER_BLOB_W2K, *LPMASTERKEY_INNER_BLOB_W2K;



DWORD
WINAPI
BackupKey(
    IN      LPCWSTR szComputerName,
    IN      const GUID *pguidActionAgent,
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut,
    IN      DWORD dwParam
    );


#endif  // __KEYBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\lenroll.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows                                                  
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       lenroll.h
//
//  Contents:   The header for LocalEnroll API.  It is used 
//              by keyservice for remote certificate enrollment.
//
//----------------------------------------------------------------------------

#ifndef __LENROLL_H__
#define __LENROLL_H__

#ifdef __cplusplus
extern "C" {
#endif
//-----------------------------------------------------------------------
//  
// LocalEnroll
//
//
//  The routine that calls xEnroll and CA to request a certificate
//  This routine also provide confirmation dialogue
//------------------------------------------------------------------------
//-----------------------------------------------------------------------
//  CERT_ENROLL_INFO
//
//------------------------------------------------------------------------
typedef struct _CERT_ENROLL_INFO
{
    DWORD           dwSize;             //Required: Set to the sizeof(CERT_REQUEST_INFO_W)
    LPCWSTR         pwszUsageOID;       //Required: A list of comma seperated key usage oid of the certificate
    LPCWSTR         pwszCertDNName;     //Required: The certificate CN name
    DWORD           dwPostOption;       //Required: A bit wise OR of the following value:
                                        //          REQUEST_POST_ON_DS
                                        //          REQUEST_POST_ON_CSP
    LPCWSTR         pwszFriendlyName;   //Optional: The friendly name of the certificate
    LPCWSTR         pwszDescription;    //Optional: The description of the certificate
    DWORD           dwExtensions;       //Optional: The count of PCERT_EXTENSIONS array for the certificate request
    PCERT_EXTENSIONS    *prgExtensions; //Optional: the PCERT_EXTENSIONS array
}CERT_ENROLL_INFO, *PCERT_ENROLL_INFO;


///-----------------------------------------------------------------------
//  CERT_REQUEST_PVK_NEW
//
//------------------------------------------------------------------------
typedef struct _CERT_REQUEST_PVK_NEW
{
    DWORD           dwSize;             //Required: Set to the sizeof(CERT_REQUEST_PVK_EXISTING)
    DWORD           dwProvType;         //Optional: The provider type. If this field
                                        //          is 0, pwszProvider is ignored
    LPCWSTR         pwszProvider;       //Optional: The name of the provider.  
                                        //          NULL means the default
    DWORD           dwProviderFlags;    //Optional: The flag passed to CryptAcquireContext
    LPCWSTR         pwszKeyContainer;   //Optional: The private key container.  If this value is NULL,
                                        //          a new key container will be generated.  Its name is guaranteed
                                        //          to be unique.
    DWORD           dwKeySpec;          //Optional: The key specification of the private key
    DWORD           dwGenKeyFlags;      //Optional: The flags for CryptGenKey
    DWORD           dwEnrollmentFlags;  //Optional: The enrollment cert type flags for this cert request. 
    DWORD           dwSubjectNameFlags; //Optional: The subject name cert type flags for this cert request. 
    DWORD           dwPrivateKeyFlags;  //Optional: The private key cert type flags for this cert request. 
    DWORD           dwGeneralFlags;     //Optional: The general cert type flags for this cert request. 

}CERT_REQUEST_PVK_NEW, *PCERT_REQUEST_PVK_NEW;


HRESULT  WINAPI LocalEnroll(   DWORD                 dwFlags,         //IN Required
                      LPCWSTR               pRequestString,  //IN Optional
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
                      PCERT_CONTEXT        *ppCertContext   //OUT Optional: The enrolled certificate
                    ); 

HRESULT WINAPI LocalEnrollNoDS(  DWORD                 dwFlags,         //IN Required
		      LPCWSTR               pRequestString,  // Reserved:  must be NULL. 
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
		      HANDLE                *pResult         //OUT Optional: The enrolled certificate
				 );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // _LENROLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\keysvcc.h ===
//depot/Lab03_N/DS/security/inc/keysvcc.h#8 - edit change 8790 (text)
//depot/Lab03_N/DS/security/inc/keysvcc.h#5 - edit change 6380 (text)
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       keysvcc.h
//
//--------------------------------------------------------------------------


#ifndef __keysvcc_h__
#define __keysvcc_h__

#ifdef __cplusplus
extern "C"{
#endif 


#define KEYSVC_DEFAULT_ENDPOINT            TEXT("\\pipe\\keysvc")
#define KEYSVC_DEFAULT_PROT_SEQ            TEXT("ncacn_np")

#define KEYSVC_LOCAL_ENDPOINT              TEXT("keysvc")
#define KEYSVC_LOCAL_PROT_SEQ              TEXT("ncalrpc")

#define KEYSVC_LEGACY_ENDPOINT             TEXT("\\pipe\\ntsvcs")
#define KEYSVC_LEGACY_PROT_SEQ             TEXT("ncacn_np")


typedef void *KEYSVCC_HANDLE;

/****************************************
 * Client API for Key Service
 ****************************************/

ULONG KeyOpenKeyService( 
    /* [in] */ LPSTR pszMachineName,
    /* [in] */ KEYSVC_TYPE ulOwnerType,
    /* [in] */ LPWSTR pwszOwnerName,
    /* [in] */ void *pAuthentication,
    /* [out][in] */ void *pReserved,
    /* [out] */ KEYSVCC_HANDLE *phKeySvcCli);

ULONG KeyEnumerateProviders( 
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [out][in] */ ULONG *pcProviderCount,
    /* [size_is][size_is][out][in] */ PKEYSVC_PROVIDER_INFO *ppProviders);

ULONG KeyEnumerateProviderTypes( 
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [out][in] */ ULONG *pcProviderCount,
    /* [size_is][size_is][out][in] */ PKEYSVC_PROVIDER_INFO *ppProviders);

ULONG KeyEnumerateProvContainers(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ KEYSVC_PROVIDER_INFO Provider,
    /* [in, out] */ void *pReserved,
    /* [in, out] */ ULONG *pcContainerCount,
    /* [in, out][size_is(,*pcContainerCount)] */
               PKEYSVC_UNICODE_STRING *ppContainers);

ULONG KeyCloseKeyService( 
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved);

ULONG KeyGetDefaultProvider( 
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ ULONG ulProvType,
    /* [in] */ ULONG ulFlags,
    /* [out][in] */ void *pReserved,
    /* [out] */ ULONG *pulDefType,
    /* [out] */ PKEYSVC_PROVIDER_INFO *ppProvider);

ULONG KeySetDefaultProvider( 
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ ULONG ulFlags,
    /* [out][in] */ void *pReserved,
    /* [in] */ KEYSVC_PROVIDER_INFO Provider);

ULONG KeyEnroll(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli, 
     /* [in] */ LPSTR pszMachineName,                   //IN Required: name of the remote machine
    /* [in] */ BOOL fKeyService,                        //IN Required: Whether the function is called remotely
    /* [in] */ DWORD dwPurpose,                         //IN Required: Indicates type of request - enroll/renew
    /* [in] */ LPWSTR pwszAcctName,                     //IN Optional: Account name the service runs under
    /* [in] */ void *pAuthentication,                   //RESERVED must be NULL
    /* [in] */ BOOL fEnroll,                            //IN Required: Whether it is enrollment or renew
    /* [in] */ LPWSTR pwszCALocation,                   //IN Required: The ca machine name
    /* [in] */ LPWSTR pwszCAName,                       //IN Required: The ca name
    /* [in] */ BOOL fNewKey,                            //IN Required: Set the TRUE if new private key is needed
    /* [in] */ PCERT_REQUEST_PVK_NEW pKeyNew,           //IN Required: The private key information
    /* [in] */ CERT_BLOB *pCert,                        //IN Optional: The old certificate if renewing
    /* [in] */ PCERT_REQUEST_PVK_NEW pRenewKey,         //IN Optional: The new private key information
    /* [in] */ LPWSTR pwszHashAlg,                      //IN Optional: The hash algorithm
    /* [in] */ LPWSTR pwszDesStore,                     //IN Optional: The destination store
    /* [in] */ DWORD dwStoreFlags,                      //IN Optional: Flags for cert store.
    /* [in] */ PCERT_ENROLL_INFO pRequestInfo,          //IN Required: The information about the cert request
    /* [in] */ LPWSTR pwszAttributes,                   //IN Optional: Attribute string for request
    /* [in] */ DWORD dwFlags,                           //RESERVED must be 0
    /* [in] */ BYTE *pReserved,                         //RESERVED must be NULL
    /* [out] */ CERT_BLOB *pPKCS7Blob,                  //OUT Optional: The PKCS7 from the CA
    /* [out] */ CERT_BLOB *pHashBlob,                   //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
    /* [out] */ DWORD *pdwStatus);                      //OUT Optional: The status of the enrollment/renewal

ULONG KeyEnroll_V2(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli, 
    /* [in] */ LPSTR pszMachineName,                    //IN Required: name of the remote machine
    /* [in] */ BOOL fKeyService,                        //IN Required: Whether the function is called remotely
    /* [in] */ DWORD dwPurpose,                         //IN Required: Indicates type of request - enroll/renew
    /* [in] */ DWORD dwFlags,                           //IN Required: Flags for enrollment
    /* [in] */ LPWSTR pwszAcctName,                     //IN Optional: Account name the service runs under
    /* [in] */ void *pAuthentication,                   //RESERVED must be NULL
    /* [in] */ BOOL fEnroll,                            //IN Required: Whether it is enrollment or renew
    /* [in] */ LPWSTR pwszCALocation,                   //IN Required: The ca machine names to attempt to enroll with
    /* [in] */ LPWSTR pwszCAName,                       //IN Required: The ca names to attempt to enroll with
    /* [in] */ BOOL fNewKey,                            //IN Required: Set the TRUE if new private key is needed
    /* [in] */ PCERT_REQUEST_PVK_NEW pKeyNew,           //IN Required: The private key information
    /* [in] */ CERT_BLOB *pCert,                        //IN Optional: The old certificate if renewing
    /* [in] */ PCERT_REQUEST_PVK_NEW pRenewKey,         //IN Optional: The new private key information
    /* [in] */ LPWSTR pwszHashAlg,                      //IN Optional: The hash algorithm
    /* [in] */ LPWSTR pwszDesStore,                     //IN Optional: The destination store
    /* [in] */ DWORD dwStoreFlags,                      //IN Optional: Flags for cert store.
    /* [in] */ PCERT_ENROLL_INFO pRequestInfo,          //IN Required: The information about the cert request
    /* [in] */ LPWSTR pwszAttributes,                   //IN Optional: Attribute string for request
    /* [in] */ DWORD dwReservedFlags,                   //RESERVED must be 0
    /* [in] */ BYTE *pReserved,                         //RESERVED must be NULL
    /* [in][out] */ HANDLE *phRequest,                      //IN OUT Optional: A handle to a created request
    /* [out] */ CERT_BLOB *pPKCS7Blob,                  //OUT Optional: The PKCS7 from the CA
    /* [out] */ CERT_BLOB *pHashBlob,                   //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
    /* [out] */ DWORD *pdwStatus);                      //OUT Optional: The status of the enrollment/renewal

ULONG KeyExportCert(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ LPWSTR pwszPassword,
    /* [in] */ LPWSTR pwszCertStore,
    /* [in] */ ULONG cHashCount,
    /* [size_is][in] */ KEYSVC_CERT_HASH *pHashes,
    /* [in] */ ULONG ulFlags,
    /* [in, out] */ void *pReserved,
    /* [out] */ PKEYSVC_BLOB *ppPFXBlob);

ULONG KeyImportCert(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ LPWSTR pwszPassword,
    /* [in] */ LPWSTR pwszCertStore,
    /* [in] */ PKEYSVC_BLOB pPFXBlob,
    /* [in] */ ULONG ulFlags,
    /* [in, out] */ void *pReserved);


ULONG KeyEnumerateAvailableCertTypes(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [out][in] */ ULONG *pcCertTypeCount,
    /* [in, out][size_is(,*pcCertTypeCount)] */
               PKEYSVC_UNICODE_STRING *ppCertTypes);

ULONG KeyEnumerateCAs(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [in] */      ULONG  ulFlags,
    /* [out][in] */ ULONG *pcCACount,
    /* [in, out][size_is(,*pcCACount)] */
               PKEYSVC_UNICODE_STRING *ppCAs);

ULONG KeyQueryRequestStatus
(/* [in] */        KEYSVCC_HANDLE                        hKeySvcCli, 
 /* [in] */        HANDLE                                hRequest, 
 /* [out, ref] */  CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO  *pQueryInfo); 

ULONG RKeyOpenKeyService
( /* [in] */       LPSTR            pszMachineName,
  /* [in] */       KEYSVC_TYPE      OwnerType,
  /* [in] */       LPWSTR           pwszOwnerName,
  /* [in] */       void            *pAuthentication,
  /* [out][in] */  void            *pReserved,
  /* [out] */      KEYSVCC_HANDLE  *phKeySvcCli);

ULONG RKeyCloseKeyService
(/* [in] */ KEYSVCC_HANDLE hKeySvcCli,
 /* [out][in] */ void *pReserved);

ULONG RKeyPFXInstall
(/* [in] */ KEYSVCC_HANDLE          hKeySvcCli,
 /* [in] */ PKEYSVC_BLOB            pPFX,
 /* [in] */ PKEYSVC_UNICODE_STRING  pPassword,
 /* [in] */ ULONG                   ulFlags);



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\lsasecpk.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1995
//
// File:        lsasecpk.h
//
// Contents:    common stuff for all sec packages
//
//
// History:     06-Mar-99   ChandanS   Created
//
//------------------------------------------------------------------------

// We need this to be a day less than maxtime so when callers
// of sspi convert to utc, they won't get time in the past.

#define MAXTIMEQUADPART (LONGLONG)0x7FFFFF36D5969FFF
#define MAXTIMEHIGHPART 0x7FFFFF36
#define MAXTIMELOWPART  0xD5969FFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\lrucache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lrucache.h
//
//  Contents:   LRU Cache API
//
//  History:    16-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LRUCACHE_H__)
#define __LRUCACHE_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// These API allow creation and manipulation of an LRU based cache area.  The
// identifier used for the cache area is a stream of bytes of which some set
// of bytes are used for the hash index.  In order to get optimal caching
// the identifiers used should be unique and the bytes sufficiently random.
//

typedef HANDLE HLRUCACHE;
typedef HANDLE HLRUENTRY;

//
// Configuration flags
//

#define LRU_CACHE_NO_SERIALIZE            0x00000001
#define LRU_CACHE_NO_COPY_IDENTIFIER      0x00000002

//
// Entry removal and cache freeing flags
//

#define LRU_SUPPRESS_REMOVAL_NOTIFICATION 0x00000004

//
// Entry touching flags
//

#define LRU_SUPPRESS_CLOCK_UPDATE         0x00000008

typedef VOID (WINAPI *LRU_DATA_FREE_FN) (LPVOID pvData);
typedef DWORD (WINAPI *LRU_HASH_IDENTIFIER_FN) (PCRYPT_DATA_BLOB pIdentifier);
typedef VOID (WINAPI *LRU_ON_REMOVAL_NOTIFY_FN) (LPVOID pvData, LPVOID pvRemovalContext);

//
// Configuration NOTE: If MaxEntries is zero then no LRU is applied to the
//                     cache entries, i.e. the cache is not bounded.
//

typedef struct _LRU_CACHE_CONFIG {

    DWORD                    dwFlags;
    LRU_DATA_FREE_FN         pfnFree;
    LRU_HASH_IDENTIFIER_FN   pfnHash;
    LRU_ON_REMOVAL_NOTIFY_FN pfnOnRemoval;
    DWORD                    cBuckets;
    DWORD                    MaxEntries;

} LRU_CACHE_CONFIG, *PLRU_CACHE_CONFIG;

BOOL
WINAPI
I_CryptCreateLruCache (
       IN PLRU_CACHE_CONFIG pConfig,
       OUT HLRUCACHE* phCache
       );

VOID
WINAPI
I_CryptFlushLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

VOID
WINAPI
I_CryptFreeLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

BOOL
WINAPI
I_CryptCreateLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       IN LPVOID pvData,
       OUT HLRUENTRY* phEntry
       );

PCRYPT_DATA_BLOB
WINAPI
I_CryptGetLruEntryIdentifier (
       IN HLRUENTRY hEntry
       );

LPVOID
WINAPI
I_CryptGetLruEntryData (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptAddRefLruEntry (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptReleaseLruEntry (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptInsertLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL LPVOID pvLruRemovalContext
       );

VOID
WINAPI
I_CryptRemoveLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

VOID
WINAPI
I_CryptTouchLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL DWORD dwFlags
       );

// NOTE: The following find does NOT touch the cache entry

HLRUENTRY
WINAPI
I_CryptFindLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier
       );

// NOTE: The following find touches the cache entry

LPVOID
WINAPI
I_CryptFindLruEntryData (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       OUT HLRUENTRY* phEntry
       );

//
// If you cache contains multiple entries with the same identifier, then
// this function can be used to enumerate them after finding the first with
// I_CryptFindLruEntry
//
// NOTE: hPrevEntry is released
//
// NOTE: This does NOT touch the cache entries
//
// NOTE: The only way to safely use this function is if the serialization
//       is done outside of the cache handle and you use the
//       LRU_CACHE_NO_SERIALIZE flag.  If not, then you will get undefined
//       results if hPrevEntry is removed or inserted (after removal) in
//       between calls
//

HLRUENTRY
WINAPI
I_CryptEnumMatchingLruEntries (
       IN HLRUENTRY hPrevEntry
       );

//
// Temporary disabling of LRU behavior.  When it is re-enabled then entries
// are purged until the watermark is again met
//

VOID
WINAPI
I_CryptEnableLruOfEntries (
       IN HLRUCACHE hCache,
       IN OPTIONAL LPVOID pvLruRemovalContext
       );

VOID
WINAPI
I_CryptDisableLruOfEntries (
       IN HLRUCACHE hCache
       );

//
// Walk all entries function
//

typedef BOOL (WINAPI *PFN_WALK_ENTRIES) (
                          IN LPVOID pvParameter,
                          IN HLRUENTRY hEntry
                          );

VOID
WINAPI
I_CryptWalkAllLruCacheEntries (
       IN HLRUCACHE hCache,
       IN PFN_WALK_ENTRIES pfnWalk,
       IN LPVOID pvParameter
       );

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\mailto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mailto.h
//
//--------------------------------------------------------------------------

// mailto.h

// Required symbols
#define MAX_LENGTH 256
#define MEGA_LENGTH 65535
#define WIN95_REG_KEY "Software\\Microsoft\\Windows Messaging Subsystem\\Profiles"
#define WINNT_REG_KEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles"

// Options
#define		MAIL_QUIET		0x00000001	// Quiet - no output
#define		MAIL_VERBOSE	0x00000002	// Verbose - status sent to standard out

// Signature
ULONG MailTo(char *szRecip,			// NULL delimited recipient list (one or more)
			char *szCC,				// NULL delimited CC list (zero or more)
			char *szBCC,			// NULL delimited BCC list (zero or more)
			char *szSubject,		// subject (may be empty string)
			char *szMessage,		// message text (may be empty string)
			char *szFileName,		// NULL delimited file attachment names (zero or more)
			unsigned int dwOptions);// Options

// szRecip		-	Recipient list
//						This should be a null terminated list of recipient names.
//						Each name should be separated with a null character and
//						the string should be terminated with two null characters.
//						This is consistent with the common open file dialog.

// szCC			-	Carbon copy recipient list
//						This should also be a null terminated list of recipient names.
//						Obviously this is the list of names to be cc'd on the mail.

// szBCC		-	Blind carbon copy recipient list
//						This should also be a null terminated list of recipient names.
//						The names on this list will also get the mail but the regular
//						recipients and carbon copy recipients will not know.

// szSubject	-	Subject text of message
//						This should be a null terminated string that will go in the
//						subject field.

// szMessage	-	Body text of message
//						This should be a null terminated string that will be the
//						body text of the message.

// szFileName	-	List of file attachments
//						This should be a null terminated list of file names to attach.
//						The files will go on the first line before the body text.

// dwOptions	-	See Options above

// Note: You are limited to thirty total recipients and thirty total files.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\lsaitf.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        lsaitf.h
//
// Contents:    Prototypes for auth packages to call into LSA & SAM
//
//
// History:     21-February-1997        Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __LSAITF_H__
#define __LSAITF_H__

#include <samrpc.h>
#include <lsarpc.h>
#include <samisrv.h>
#include <lsaisrv.h>

NTSTATUS
I_SamrSetInformationUser(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    IN                PSAMPR_USER_INFO_BUFFER Buffer
    );

NTSTATUS
I_SamrGetGroupsForUser(
    IN                SAMPR_HANDLE            UserHandle,
    OUT               PSAMPR_GET_GROUPS_BUFFER *Groups
    );

NTSTATUS
I_SamrCloseHandle(
    IN OUT            SAMPR_HANDLE    *       SamHandle
    );

NTSTATUS
I_SamrQueryInformationUser(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    OUT               PSAMPR_USER_INFO_BUFFER *Buffer
    );

NTSTATUS
I_SamrOpenUser(
    IN                SAMPR_HANDLE            DomainHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                ULONG                   UserId,
    OUT               SAMPR_HANDLE    *       UserHandle
    );

NTSTATUS
I_SamrLookupNamesInDomain(
    IN                SAMPR_HANDLE            DomainHandle,
    IN                ULONG                   Count,
    //
    // The following count must match SAM_MAXIMUM_LOOKUP_COUNT,
    // defined in ntsam.h
    //
    IN                RPC_UNICODE_STRING      Names[],
    OUT               PSAMPR_ULONG_ARRAY      RelativeIds,
    OUT               PSAMPR_ULONG_ARRAY      Use
    );

NTSTATUS
I_SamrLookupIdsInDomain(
    IN                SAMPR_HANDLE DomainHandle,
    IN                ULONG Count,
    IN                PULONG RelativeIds,
    OUT               PSAMPR_RETURNED_USTRING_ARRAY Names,
    OUT               PSAMPR_ULONG_ARRAY Use
    );


NTSTATUS
I_SamrOpenDomain(
    IN                SAMPR_HANDLE            ServerHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                PRPC_SID                DomainId,
    OUT               SAMPR_HANDLE    *       DomainHandle
    );
    
NTSTATUS
I_SamrQueryInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    );


NTSTATUS
I_SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
I_SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

NTSTATUS
I_SamIGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

NTSTATUS
I_SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

VOID
I_SamIFree_SAMPR_GET_GROUPS_BUFFER (
    PSAMPR_GET_GROUPS_BUFFER Source
    );

VOID
I_SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    );

VOID
I_SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    );

VOID
I_SamIFree_SAMPR_RETURNED_USTRING_ARRAY (
    PSAMPR_RETURNED_USTRING_ARRAY Source
    );

VOID I_SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    );


VOID
I_SamIIncrementPerformanceCounter(
    IN SAM_PERF_COUNTER_TYPE CounterType
    );

VOID
I_SamIFreeVoid(
    IN PVOID ptr
    );

NTSTATUS
I_SamIUpdateLogonStatistics(
    IN  SAMPR_HANDLE DomainHandle,
    IN  PSAM_LOGON_STATISTICS LogonStats
    );

NTSTATUS
I_SamIUPNFromUserHandle(
    IN SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    );

NTSTATUS
I_LsaIOpenPolicyTrusted(
    OUT PLSAPR_HANDLE PolicyHandle
    );

NTSTATUS
I_LsarClose(
    IN OUT LSAPR_HANDLE *ObjectHandle
    );

NTSTATUS
I_LsaIQueryInformationPolicyTrusted(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    );

VOID
I_LsaIFree_LSAPR_POLICY_INFORMATION (
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );

NTSTATUS
I_LsarQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *PolicyInformation
    );

NTSTATUS
I_LsarCreateSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    );

NTSTATUS
I_LsarOpenSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    );

NTSTATUS
I_LsarSetSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedOldValue
    );

NTSTATUS
I_LsarQuerySecret(
    IN LSAPR_HANDLE SecretHandle,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    IN OUT OPTIONAL PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    IN OUT OPTIONAL PLARGE_INTEGER OldValueSetTime
    );

NTSTATUS
I_LsarDelete(
    IN OUT LSAPR_HANDLE ObjectHandle
    );

VOID
I_LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    );

NTSTATUS NTAPI
I_LsaIRegisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

NTSTATUS NTAPI
I_LsaIUnregisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

NTSTATUS
I_LsaIAuditAccountLogon(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             Status          OPTIONAL
    );

NTSTATUS
I_LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    );

NTSTATUS
I_LsaISetLogonGuidInLogonSession(
    IN  PLUID  pLogonId,
    IN  LPGUID pLogonGuid
    );

VOID
I_LsaIAuditKerberosLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid
    );

NTSTATUS
I_LsaIAuditLogonUsingExplicitCreds(
    IN USHORT          AuditEventType,
    IN PSID            pUser1Sid,
    IN PUNICODE_STRING pUser1Name,
    IN PUNICODE_STRING pUser1Domain,
    IN PLUID           pUser1LogonId,
    IN LPGUID          pUser1LogonGuid,
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid
    );


NTSTATUS
I_LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
I_LsaIAddNameToLogonSession(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  PUNICODE_STRING Name
    );


#endif //  __LSAITF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\offsgn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       offsng32.h
//
//  Contents:   Microsoft Internet Security Office Helper
//
//  History:    14-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef OFFSNG32_H
#define OFFSNG32_H

#ifdef __cplusplus
extern "C" 
{
#endif

//////////////////////////////////////////////////////////////////////////////
//
// OFFICESIGN_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a Structured Storage file using the Microsoft Office
//  Authenticode add-on Policy Provider,
//  
//          {5555C2CD-17FB-11d1-85C4-00C04FC295EE}
//
#define     OFFICESIGN_ACTION_VERIFY                                    \
                { 0x5555c2cd,                                           \
                  0x17fb,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xc4, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     OFFICE_POLICY_PROVIDER_DLL_NAME             L"OFFSGN32.DLL"
#define     OFFICE_INITPROV_FUNCTION                    L"OfficeInitializePolicy"
#define     OFFICE_CLEANUPPOLICY_FUNCTION               L"OfficeCleanupPolicy"

//////////////////////////////////////////////////////////////////////////////
//
// CryptOfficeSign
//----------------------------------------------------------------------------
//  Digitally signs the file.  The user will be prompted for signing 
//  certificate.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_INVALID_PARAMETER:        bad argument passed in  (the user will NOT be shown UI)
//
extern BOOL WINAPI CryptOfficeSignW(HWND hWndCaller, WCHAR *pwszFile);
extern BOOL WINAPI CryptOfficeSignA(HWND hWndCaller, char *pszFile);

//////////////////////////////////////////////////////////////////////////////
//
// CryptOfficeVerify
//----------------------------------------------------------------------------
//  Digitally verifies the file.  The user will be presented UI if 
//  applicable.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_INVALID_PARAMETER:        bad argument passed in (the user will NOT be shown UI).
//
extern BOOL WINAPI CryptOfficeVerifyW(HWND hWndCaller, WCHAR *pwszFile);
extern BOOL WINAPI CryptOfficeVerifyA(HWND hWndCaller, char *pszFile);

#ifdef UNICODE

#   define CryptOfficeSign      CryptOfficeSignW
#   define CryptOfficeVerify    CryptOfficeVerifyW

#else

#   define CryptOfficeSign      CryptOfficeSignA
#   define CryptOfficeVerify    CryptOfficeVerifyA

#endif // UNICODE


#ifdef __cplusplus
}
#endif

#endif // OFFSNG32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\ossconv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ossconv.h
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  APIs:       OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//
//--------------------------------------------------------------------------

#ifndef __OSSCONV_H__
#define __OSSCONV_H__

#include "asn1hdr.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    );

#define OSS_UTC_TIME_CHOICE             1
#define OSS_GENERALIZED_TIME_CHOICE     2

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\passrecp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passrecp.h

Abstract:

    This module contains private data definitions for the password recovery system

Author:

    Pete Skelly (petesk)    09-May-00

--*/

#ifndef __PASSRECP_H__
#define __PASSRECP_H__

#ifdef __cplusplus
extern "C" {
#endif

#define RECOVERY_BLOB_MAGIC *((DWORD *)"MSRB")
#define RECOVERY_BLOB_VERSION 1

#define RECOVERY_SUPPLEMENTAL_CREDENTIAL_VERSION 1

typedef struct _RECOVERY_SUPPLEMENTAL_CREDENTIAL
{
    DWORD dwVersion;
    DWORD cbRecoveryCertHashSize;
    DWORD cbRecoveryCertSignatureSize;
    DWORD cbEncryptedPassword;
} RECOVERY_SUPPLEMENTAL_CREDENTIAL, *PRECOVERY_SUPPLEMENTAL_CREDENTIAL;


DWORD 
RecoveryRetrieveSupplementalCredential(
    PSID pUserSid,
    PRECOVERY_SUPPLEMENTAL_CREDENTIAL *ppSupplementalCred, 
    DWORD *pcbSupplementalCred);

DWORD 
RecoverySetSupplementalCredential(
    PSID pUserSid,
    PRECOVERY_SUPPLEMENTAL_CREDENTIAL pSupplementalCred, 
    DWORD cbSupplementalCred);

DWORD
PRImportRecoveryKey(
            IN PUNICODE_STRING pUserName,
            IN PUNICODE_STRING pCurrentPassword,
            IN BYTE* pbRecoveryPublic,
            IN DWORD cbRecoveryPublic);

DWORD 
PRGetUserSid(
    IN  PBYTE pbRecoveryPrivate,
    IN  DWORD cbRecoveryPrivate,
    OUT PSID *ppSid);

DWORD
DPAPICreateNestedDirectories(
    IN      LPWSTR szFullPath,
    IN      LPWSTR szCreationStartPoint);

#ifdef __cplusplus
}
#endif


#endif // __RECOVERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\ossutil.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ossutil.h
//
//  Contents:   OSS ASN.1 compiler utility functions.
//
//  APIs: 
//              OssUtilAlloc
//              OssUtilFree
//              OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilFreeHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilSetBitStringWithoutTrailingZeroes
//              OssUtilGetBitString
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilEncodeInfoEx
//              OssUtilDecodeAndAllocInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __OSSUTIL_H__
#define __OSSUTIL_H__

#include <wincrypt.h>
#include <pkialloc.h>

#include "asn1hdr.h"
#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  OssUtil allocation and free functions
//--------------------------------------------------------------------------
#define OssUtilAlloc    PkiNonzeroAlloc
#define OssUtilFree     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BYTE reversal::
//   - this only needs to be done for little endian processors
//
//  OssUtilFreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        );

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

#define OssUtilFreeHugeUINT     OssUtilFreeHugeInteger

void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        );

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        );

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        );

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        );

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_OSS_UTIL_DECODE_EX_CALLBACK)(
    IN void *pvOssInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pfx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       pfx.h
//
//  Contents:   PFX (PKCS #12) function defintions and types
//
//----------------------------------------------------------------------------
#ifndef PFX_H
#define PFX_H

// All of the pfx definitions have been moved to the following
#include <wincrypt.h>

#endif // PFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs:
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN size_t cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN size_t cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN size_t cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pkicrit.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkicrit.h
//
//  Contents:   PKI CriticalSection Functions
//
//  APIs:       Pki_InitializeCriticalSection
//
//  History:    23-Aug-99    philh   created
//--------------------------------------------------------------------------

#ifndef __PKICRIT_H__
#define __PKICRIT_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following calls InitializeCriticalSection within a try/except.
//  If an exception is raised, returns FALSE with LastError set to
//  the exception error. Otherwise, TRUE is returned.
//--------------------------------------------------------------------------
BOOL
WINAPI
Pki_InitializeCriticalSection(
    OUT LPCRITICAL_SECTION lpCriticalSection
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pkiasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkiasn1.h
//
//  Contents:   PKI ASN.1 support functions.
//
//  APIs:       PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1FreeEncoded
//              PkiAsn1Encode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//              PkiAsn1FreeDecoded
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//              PkiAsn1EncodedOidToDotVal
//              PkiAsn1FreeDotVal
//              PkiAsn1DotValToEncodedOid
//              PkiAsn1FreeEncodedOid
//
//              PkiAsn1Alloc
//              PkiAsn1Free
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1FreeHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1SetBitStringWithoutTrailingZeroes
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1FreeInfo
//              PkiAsn1EncodeInfoEx
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIASN1_H__
#define __PKIASN1_H__

#include <msber.h>
#include <msasn1.h>
#include <winerror.h>
#include <pkialloc.h>

#ifdef OSS_CRYPT_ASN1
#include "asn1hdr.h"
#include "asn1code.h"
#include "ossglobl.h"
#include "pkioss.h"
#include "ossutil.h"
#include "ossconv.h"
#endif  // OSS_CRYPT_ASN1


#ifdef __cplusplus
extern "C" {
#endif



#ifndef OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 > Asn1Err)
        return CRYPT_E_ASN1_ERROR + (-Asn1Err -1000);
    else
        return CRYPT_E_ASN1_ERROR + 0x100 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ASN1_FreeEncoded(pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rule functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    );

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    );

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    LPSTR pszDotVal = NULL;
    if (ASN1BEREoid2DotVal(pDec, pEncodedOid, &pszDotVal))
        return pszDotVal;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ASN1Free(pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    return ASN1BERDotVal2Eoid(pEnc, pszDotVal, pEncodedOid);
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ASN1_FreeEncoded(pEnc, pEncodedOid->value);
}

//+-------------------------------------------------------------------------
//  PkiAsn1 allocation and free functions
//--------------------------------------------------------------------------
#define PkiAsn1Alloc    PkiNonzeroAlloc
#define PkiAsn1Free     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  PkiAsn1FreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        );

void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        );

#define PkiAsn1FreeHugeUINT     PkiAsn1FreeHugeInteger

void
WINAPI
PkiAsn1GetHugeUINT(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        );

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        );

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        );

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    );

#define PKI_ASN1_UTC_TIME_CHOICE            1
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    2

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    );

#else 

//+=========================================================================
// The following map to the OSS ASN1 routines
//==========================================================================

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 <= Asn1Err && 1000 > Asn1Err)
        return CRYPT_E_OSS_ERROR + Asn1Err;
    else if (0 > Asn1Err)
        return CRYPT_E_ASN1_ERROR + (-Asn1Err -1000);
    else
        return CRYPT_E_ASN1_ERROR + 0x100 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT OPTIONAL DWORD *pcbEncoded = NULL
    )
{
    return (ASN1error_e) PkiOssEncode(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ossFreeBuf((OssGlobal *) pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssEncode2(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        pbEncoded,
        cbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode2(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ossFreePDU((OssGlobal *) pDec, (int) id, pvAsn1Info);
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ossEncodingRules ossRules;
    if (ASN1_BER_RULE_BER == eRule)
        ossRules = OSS_BER;
    else
        ossRules = OSS_DER;

    return (ASN1error_e) ossSetEncodingRules((OssGlobal *) pEnc, ossRules);
}

__inline
ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ossEncodingRules ossRules;
    ossRules = ossGetEncodingRules((OssGlobal *) pEnc);
    if (OSS_BER == ossRules)
        return ASN1_BER_RULE_BER;
    else
        return ASN1_BER_RULE_DER;
}

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID OssEncodedOid;
    OssBuf dotOid;
    memset(&dotOid, 0, sizeof(dotOid));

    OssEncodedOid.length = pEncodedOid->length;
    OssEncodedOid.value = pEncodedOid->value;
    if (0 == ossEncodedOidToDotVal((OssGlobal *) pDec, &OssEncodedOid,
            &dotOid))
        return (LPSTR) dotOid.value;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ossFreeBuf((OssGlobal *) pDec, pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID eoid;
    memset(&eoid, 0, sizeof(eoid));
    if (0 == ossDotValToEncodedOid((OssGlobal *) pEnc, pszDotVal, &eoid)) {
        pEncodedOid->length = eoid.length;
        pEncodedOid->value = eoid.value;
        return 1;
    } else {
        pEncodedOid->length = 0;
        pEncodedOid->value = NULL;
        return 0;
    }
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ossFreeBuf((OssGlobal *) pEnc, pEncodedOid->value);
}

#define PkiAsn1Alloc OssUtilAlloc
#define PkiAsn1Free OssUtilFree
#define PkiAsn1ReverseBytes OssUtilReverseBytes
#define PkiAsn1AllocAndReverseBytes OssUtilAllocAndReverseBytes
#define PkiAsn1GetOctetString OssUtilGetOctetString
#define PkiAsn1SetHugeInteger OssUtilSetHugeInteger
#define PkiAsn1FreeHugeInteger OssUtilFreeHugeInteger
#define PkiAsn1GetHugeInteger OssUtilGetHugeInteger
#define PkiAsn1SetHugeUINT OssUtilSetHugeUINT
#define PkiAsn1FreeHugeUINT OssUtilFreeHugeInteger
#define PkiAsn1GetHugeUINT OssUtilGetHugeUINT
#define PkiAsn1SetBitString OssUtilSetBitString
#define PkiAsn1GetBitString OssUtilGetBitString
#define PkiAsn1SetBitStringWithoutTrailingZeroes OssUtilSetBitStringWithoutTrailingZeroes
#define PkiAsn1GetIA5String OssUtilGetIA5String
#define PkiAsn1SetUnicodeConvertedToIA5String OssUtilSetUnicodeConvertedToIA5String
#define PkiAsn1FreeUnicodeConvertedToIA5String OssUtilFreeUnicodeConvertedToIA5String
#define PkiAsn1GetIA5StringConvertedToUnicode OssUtilGetIA5StringConvertedToUnicode
#define PkiAsn1GetBMPString OssUtilGetBMPString
#define PkiAsn1SetAny OssUtilSetAny
#define PkiAsn1GetAny OssUtilGetAny

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfo(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    return OssUtilDecodeAndAllocInfo(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        ppvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    OssUtilFreeInfo(
        (OssGlobal *) pDec,
        (int) id,
        pvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilAllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilDecodeAndAllocInfoEx(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

#define PkiAsn1ToObjectIdentifier OssConvToObjectIdentifier
#define PkiAsn1FromObjectIdentifier OssConvFromObjectIdentifier
#define PkiAsn1ToUTCTime OssConvToUTCTime
#define PkiAsn1FromUTCTime OssConvFromUTCTime
#define PkiAsn1ToGeneralizedTime OssConvToGeneralizedTime
#define PkiAsn1FromGeneralizedTime OssConvFromGeneralizedTime


__inline
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pGeneralTime,
    OUT UTCTime *pUtcTime
    )
{
    return OssConvToChoiceOfTime(
        pFileTime,
        pwChoice,
        pGeneralTime
        );
}

#define PKI_ASN1_UTC_TIME_CHOICE            OSS_UTC_TIME_CHOICE
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    OSS_GENERALIZED_TIME_CHOICE

__inline
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pGeneralTime,
    IN UTCTime *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    return OssConvFromChoiceOfTime(
        wChoice,
        pGeneralTime,
        pFileTime
        );
}

#endif  // OSS_CRYPT_ASN1

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pstdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pstdef.h
//
//--------------------------------------------------------------------------

#ifndef _PSTDEF_H_
#define _PSTDEF_H_

/*
    Typedefs, values 
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020
#define PST_PC_NOT_AVAILABLE    0x00000040 


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area 
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/* 
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation 
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001

//
// RSABase rqmt: determine if item has ui attached
//
#define     PST_PF_NEVER_SHOW           0x00000002

/* 
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite 
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004

//
// on ReadItem call
// return value on success without UI on item is PST_E_OK
// return value on success with UI on item is PST_E_ITEM_EXISTS
// return value on failure is a different error code
//
#define     PST_PROMPT_QUERY            0x00000008

//
// on ReadItem, DeleteItem, for data migration purposes:
// Avoid displaying UI on ReadItem unless a custom password is required (highsecurity).
// Avoid displaying UI on DeleteItem, period.
//
#define     PST_NO_UI_MIGRATION         0x00000010



/* 
    Security masks, rule modifiers 
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002
#define     PST_CREATE_TYPE         0x0004
#define     PST_CREATE_SUBTYPE      0x0008
#define     PST_DELETE_TYPE         0x0010
#define     PST_DELETE_SUBTYPE      0x0020
#define     PST_USE                 0x0040

#define     PST_GENERIC_READ        PST_READ
#define     PST_GENERIC_WRITE       (PST_WRITE | PST_CREATE_TYPE | PST_CREATE_SUBTYPE)
#define     PST_GENERIC_EXECUTE     PST_USE
#define     PST_ALL_ACCESS          0x01FF


// PST_ACCESSCLAUSETYPE 

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb 
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
#define PST_E_MEMORY_IMAGE_MISMATCH     _HRESULT_TYPEDEF_(0x800C000CL)
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK

#endif // _PSTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pkistr.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkistr.h
//
//  Contents:   PKI String Functions
//
//  APIs:       Pki_wcsicmp
//              Pki_wcsnicmp
//              Pki_stricmp
//              Pki_strnicmp
//
//  History:    21-May-99    philh   created
//--------------------------------------------------------------------------

#ifndef __PKISTR_H__
#define __PKISTR_H__

#include <string.h>


#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  CompareString is called with the following locale:
//      MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
//--------------------------------------------------------------------------
int __cdecl Pki_wcsicmp(const wchar_t *pwsz1, const wchar_t *pwsz2);
int __cdecl Pki_wcsnicmp(const wchar_t *pwsz1, const wchar_t *pwsz2,
                    size_t cch);
int __cdecl Pki_stricmp(const char *psz1, const char *psz2);
int __cdecl Pki_strnicmp(const char *psz1, const char *psz2,
                    size_t cch);

#define _wcsicmp(s1,s2)         Pki_wcsicmp(s1,s2)
#define _wcsnicmp(s1,s2,cch)    Pki_wcsnicmp(s1,s2,cch)
#define _stricmp(s1,s2)         Pki_stricmp(s1,s2)
#define _strnicmp(s1,s2,cch)    Pki_strnicmp(s1,s2,cch)

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pkioss.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkioss.h
//
//  Contents:   PKI OSS support functions.
//
//              PkiOssEncode
//              PkiOssEncode2
//              PkiOssDecode
//              PkiOssDecode2
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIOSS_H__
#define __PKIOSS_H__

#include "asn1hdr.h"
#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  OSS Encode function. The encoded output is allocated and must be freed
//  by calling ossFreeBuf
//--------------------------------------------------------------------------
int
WINAPI
PkiOssEncode(
    IN OssGlobal *Pog,
    IN void *pvOssInfo,
    IN int id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );


//+-------------------------------------------------------------------------
//  OSS Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
int
WINAPI
PkiOssEncode2(
    IN OssGlobal *Pog,
    IN void *pvOssInfo,
    IN int id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  OSS Decode function. The allocated, decoded structure, **pvOssInfo, must
//  be freed by calling ossFreePDU().
//--------------------------------------------------------------------------
int
WINAPI
PkiOssDecode(
    IN OssGlobal *Pog,
    OUT void **ppvOssInfo,
    IN int id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  OSS Decode function. The allocated, decoded structure, **pvOssInfo, must
//  be freed by calling ossFreePDU().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
int
WINAPI
PkiOssDecode2(
    IN OssGlobal *Pog,
    OUT void **ppvOssInfo,
    IN int id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\protrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       protrust.h
//
//  Contents:   Protected Trust Provider
//              API Prototypes and Definitions
//
// Implements a generic trust provider that allows verification of certifciates
// and uses a call back to check the policy. The policy is called for each signature 
// in the subject and for each signer within the signature
// 
// Documentation is at the bottom of the file.
//
//--------------------------------------------------------------------------

#ifndef _PROTRUST_H_
#define _PROTRUST_H_

#include "signcde.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  PROTRUST optional certificate verification checks (elements to check)
//--------------------------------------------------------------------------
// PROTRUST_CERT_SIGNATURE_FLAG - verify certificate signature
// PROTRUST_CERT_TIME_VALIDITY_FLAG - verify certificate time 
// PROTRUST_CERT_REVOCATION_VALIDITY_FLAG - verify revocation of certificates
// 
// PROTRUST_TIMESTAMP_SIGNATURE_FLAG - verify timestamp certificate
// PROTRUST_TRUST_TEST_ROOT - verify up to the test root

#define PROTRUST_CERT_SIGNATURE_FLAG           CERT_STORE_SIGNATURE_FLAG
#define PROTRUST_CERT_TIME_VALIDITY_FLAG       CERT_STORE_TIME_VALIDITY_FLAG
#define PROTRUST_CERT_REVOCATION_VALIDITY_FLAG CERT_STORE_REVOCATION_FLAG
#define PROTRUST_TIMESTAMP_SIGNATURE_FLAG      0x00040000
#define PROTRUST_TRUST_TEST_ROOT               0x00080000

//+-------------------------------------------------------------------------
//  PROTRUST signature verification (elements that failed; See dwStatusFlags below)
//--------------------------------------------------------------------------
//  PROTRUST_TIME_FLAG  - Time of the signer certificate is not valid
//  PROTRUST_DIGEST_FLAG - digest of signature did not verify
//  PROTRUST_ROOT_FLAG - unable to find a trusted root 
//     (NOTE. check pRoot to see if a root was found)
//  These flags are supplied only to a policy call back. They are not returned
//  to the caller of WinVerifyTrust.

#define PROTRUST_TIME_FLAG              0x20000000   // Time of a certificate in chain is not valid
#define PROTRUST_DIGEST_FLAG            0x40000000   // 
#define PROTRUST_ROOT_FLAG              0x80000000


//+-------------------------------------------------------------------------
#define REGSTR_PATH_PROTRUST REGSTR_PATH_SERVICES "\\WinTrust\\TrustProviders\\Protected Trust"
#define WIN_PROTECTED_ACTION  \
{ 0xa692ba40, 0x6da8, 0x11d0, { 0xa7, 0x0, 0x0, 0xa0, 0xc9, 0x3, 0xb8, 0x3d } }

// Policy Information supplied to the call back, Use only what is required to 
// determine if the signature is to be trusted.
typedef struct _PROTECTED_POLICY_INFO {
    HCRYPTPROV         hCryptProv;     // The provider used in verfication
    DWORD              dwEncodingType; // Encoding type of certificate
    DWORD              dwSignCount;    // Signature, may be more then one signature 
    DWORD              dwSigner;       // Which signer in signature, may be more then one signer
    DWORD              dwVerifyFlags;  // Search flags used to find certificates in chain 
    PCCERT_CONTEXT     pCertContext;   // Signing Certificate found
    PCCERT_CONTEXT     pRoot;          // Root Certificate found
    PCCERT_CONTEXTLIST pCertChain;     // Chain used to verify certificate
    FILETIME           sTime;          // Valid date for certificates (ie time stamp)
    CRYPT_DIGEST_BLOB  sDigest;        // Digest (unsigned hash) from signature
    PCRYPT_ATTRIBUTES  pAuthenticatedAttributes;   // List of authenticated attributes
    PCRYPT_ATTRIBUTES  pUnauthenticatedAttributes; // List of unauthenticated attributes
    PBYTE              pbSignature;    // Encoded Signature
    DWORD              cbSignature;    // Size of Encoded Signature
    DWORD              dwStatusFlags;  // Status flags defined in PROTECTED trust model
} PROTECTED_POLICY_INFO, *PPROTECTED_POLICY_INFO;

// PROTECTED Trust Policy is defined as:
typedef HRESULT (WINAPI *_PROTECTED_TRUST_POLICY)(IN HANDLE                  hClientToken,
                                                  IN PPROTECTED_POLICY_INFO  pInfo);

// Policy List is defined as:
typedef struct _PROTECTED_TRUST_INFO {
    DWORD                   cbSize;             // sizeof(_PROTECTED_TRUST_POLICY_LIST)
    DWORD                   dwVerifyFlags;    // Should contain at least PROTRUST_CERT_SIGNATURE_FLAG
    DWORD                   dwCertEncodingType; // Optional, defaults to X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
    HCRYPTPROV              hCryptProv;         // Optional, pass in provider for doing verification
    HCERTSTORE              hTrustedStore;      // Optional, list of trusted roots
    HCERTSTORE              hCertificateStore;  // Optional, additional certs to use in verification
    _PROTECTED_TRUST_POLICY pfnPolicy;          // Optional, application defined user policy
} PROTECTED_TRUST_INFO, *PPROTECTED_TRUST_INFO;

typedef struct _PROTECTED_TRUST_ACTDATA_CALLER_CONTEXT {
    HANDLE                hClientToken;
    GUID *                SubjectType;
    WIN_TRUST_SUBJECT     Subject;
    PROTECTED_TRUST_INFO  sTrustInfo; 
} PROTECTED_TRUST_ACTDATA_CALLER_CONTEXT, *LPPROTECTED_TRUST_ACTDATA_CALLER_CONTEXT;

// The policy provider must use the following return codes
// Returns S_OK: - valid signature, returns from the trust provider
//         S_FALSE: - continue on to the next signature or signer
//         ERROR: - aborts trust provider and exists with this error code.
//


//---------------------------------------------------------------------------
/*
  Generic Trust Provider

  Usage: The generic trust provider is designed to provide a flexible manner for
  implementing a policy where the developer can let the provider do as much or 
  as little of the decision making as required. Verifying is composed of two stages,
  the first is to determine if the signature matches the item that was signed. The
  second stage is to determine if the certificate used to do the signing was valid. 
  This second stage is dependent on the policy of the calling application, criteria
  like, root certificates, specific signature certicates, certificate extensions can
  all be used to determine if the signature is valid. 

  There are three ways of using the generic trust provider (GTB) to do the verification, 
  1) let the GTB verify the digest and verify the certificate.
  2) let the GTB verify the digest and verify the certificate supplying the GTB root 
  certificates that can be trusted.
  3) supply a policy call back that the GTB calls providing the signature, certificates
  and its status for the digest and the certifcate to the policy call back.

  METHOD 1) Let the trust provider do the verfication
  
  Fill in a PROTECTED_TRUST_INFO structure. The only fields that must be filled in are
  cbSize and dwVerifyFlags. dwVerifyFlags specify how to determine if the signing certificate
  and all the issuer certificates are valid (validity flags can be combined).

            cbSize = sizeof(PROTECTED_TRUST_INFO);

            dwVerifyFlags = zero or more of PROTRUST_CERT_SIGNATURE_FLAG 
                                            PROTRUST_CERT_TIME_VALIDITY_FLAG
                                            PROTRUST_TIMESTAMP_SIGNATURE_FLAG
                                            PROTRUST_TRUST_TEST_ROOT.
            (where:
                PROTRUST_CERT_SIGNATURE_FLAG - verify certificates on signatures 
                                               (ie find the issuer certificate and 
                                               verify the signature of the certificate).
                PROTRUST_CERT_TIME_VALIDITY_FLAG - verify that the certificate is 
                                                   valid at the current time.
                PROTRUST_TIMESTAMP_SIGNATURE_FLAG - verify that the certificate was 
                                                    valid at the time a time-stamp was 
                                                    placed on the signature. If there
                                                    is no time stamp then use the current time.
                PROTRUST_TRUST_TEST_ROOT - Verifying the certifcate chain to the test 
                                           root is valid.)

  WinVerifyTrust will return:
        S_OK - signature verified
        TRUST_E_NOSIGNATURE  - no signature found
        NTE_BAD_SIGNATURE    - signature did not verify to digest
        CERT_E_UNTRUSTEDROOT - verifyied to an untrusted root
        CERT_E_CHAINING      - a certificate could not be verified (issuer not found)
        CERT_E_EXPIRED       - a valid certificate chain could not be found 
                               (ceritifcate or issuer expired)

  METHOD 2) Let the trust provider verify to a list of certificates.

  Add a store to the PROTECTED_TRUST_INFO structure in addition to the entries 
  specified in method 1.
    
            hTrustedStore = a store that contains all roots that are to be trusted.
                            (This store can be opened using CertOpenSystemStore etc.)
            
            cbSize = sizeof(PROTECTED_TRUST_INFO);
            
            dwVerifyFlags = zero or more of PROTRUST_CERT_SIGNATURE_FLAG 
                                            PROTRUST_CERT_TIME_VALIDITY_FLAG
                                            PROTRUST_TIMESTAMP_SIGNATURE_FLAG
                                            PROTRUST_TRUST_TEST_ROOT.
              (where:
                PROTRUST_CERT_SIGNATURE_FLAG - verify certificates on signatures 
                                               (ie find the issuer certificate and 
                                               verify the signature of the certificate).
                PROTRUST_CERT_TIME_VALIDITY_FLAG - verify that the certificate is 
                                                   valid at the current time.
                PROTRUST_TIMESTAMP_SIGNATURE_FLAG - verify that the certificate was 
                                                    valid at the time a time-stamp was 
                                                    placed on the signature. If there
                                                    is no time stamp then use the current time.
                PROTRUST_TRUST_TEST_ROOT - Verifying the certifcate chain to the test 
                                           root is valid.)

  WinVerifyTrust will return:
        S_OK - signature verified
        TRUST_E_NOSIGNATURE  - no signature found
        NTE_BAD_SIGNATURE    - signature did not verify to digest
        CERT_E_UNTRUSTEDROOT - verifyied to an untrusted root
        CERT_E_CHAINING      - a certificate could not be verified (issuer not found)
        CERT_E_EXPIRED       - a valid certificate chain could not be found 
                               (ceritifcate or issuer expired)

            
  METHOD 3) Pass in a policy call back that is called prior to returning from
  WinVerifyTrust. The call back is called for every signature found and for
  each signer in a signature. When then call back returns S_OK then the WinVerifyTrust
  returns. If S_FALSE is returned from the call back then the next signer or signature
  is tried. If and error is found then WinVerifyTrust returns this error immediately.

  The call back must by of type _PROTECTED_TRUST_POLICY. This function takes a HANDLE 
  and a PPROTECTED_POLICY_INFO. The handle points to client data that is passed into
  WinVerifyTrust, it can contain data, returned elements, status flags etc. The  
  PPROTECTED_POLICY_INFO points to a structure that contains all the information the
  general trust provider found in the signature. The policy call back can use some or 
  all of this data in determining if the signature is valid.
  
  In addition to method 1 and method 2 a call back procedure is added to the 
  PROTECTED_TRUST_INFO structure.

            pfnPolicy = MyPolicy;   
              (where: 
                MyPolicy is a function defined by the caller.)

            hTrustedStore = a store that contains all roots that are to be trusted.
                            (This store can be opened using CertOpenSystemStore etc.)
            
            cbSize = sizeof(PROTECTED_TRUST_INFO);
            
            dwVerifyFlags = zero or more of PROTRUST_CERT_SIGNATURE_FLAG 
                                            PROTRUST_CERT_TIME_VALIDITY_FLAG
                                            PROTRUST_TIMESTAMP_SIGNATURE_FLAG
                                            PROTRUST_TRUST_TEST_ROOT.
              (where:
                PROTRUST_CERT_SIGNATURE_FLAG - verify certificates on signatures 
                                               (ie find the issuer certificate and 
                                               verify the signature of the certificate).
                PROTRUST_CERT_TIME_VALIDITY_FLAG - verify that the certificate is 
                                                   valid at the current time.
                PROTRUST_TIMESTAMP_SIGNATURE_FLAG - verify that the certificate was 
                                                    valid at the time a time-stamp was 
                                                    placed on the signature. If there
                                                    is no time stamp then use the current time.
                PROTRUST_TRUST_TEST_ROOT - Verifying the certifcate chain to the test 
                                           root is valid.)
  WinVerifyTrust will return:
        The return code from the policy module.

        Example: of policy callback.
         
    //
    // Protest3 - tool for manually calling WinVerifyTrust
    //
            
    #include <stdio.h>
    #include <windows.h>
    #include "wincrypt.h"
    #include "signcde.h" 
    #include "protrust.h"
    
    
    // Potential Subject ids
    GUID guidProtectedTrust    = WIN_PROTECTED_ACTION;
    GUID guidSubjectPeImage    = WIN_TRUST_SUBJTYPE_PE_IMAGE;
    GUID guidSubjectJavaClass  = WIN_TRUST_SUBJTYPE_JAVA_CLASS;
    GUID guidSubjectCabinet    = WIN_TRUST_SUBJTYPE_CABINET;
            
    
            // Which action and subject will be used
    GUID*   pguidActionID = &guidProtectedTrust;
    GUID*   pguidSubject  = &guidSubjectPeImage;
    
            // Structures used to call WinVerifyTrust
    PROTECTED_TRUST_ACTDATA_CALLER_CONTEXT  sSetup;
    WIN_TRUST_SUBJECT_FILE                  sSubjectFile;
    
            // Set up my own error codes
    #define MY_CODE_NO_ROOT          0x00010000
    #define MY_CODE_BAD_DIGEST       0x00100000
    #define MY_CODE_BAD_TIME         0x00200000
    
    // Define my structure for use in the Policy call back.
    typedef struct _CLIENT_DATA {
        DWORD  dwStatusFlags; // Verification Status
        BOOL   dwRealRoot;    // Did it verify to the real microsoft root
        BOOL   dwTestRoot;    // Did it verify to the test root
    } CLIENT_DATA, *PCLIENT_DATA;
    
    HRESULT WINAPI MyPolicy(IN HANDLE hClientToken,
                            IN PPROTECTED_POLICY_INFO pInfo)
    {
        HRESULT hr = S_OK;
        PCLIENT_DATA pClient = (PCLIENT_DATA) hClientToken;
        
        if(pInfo->dwStatusFlags & PROTRUST_DIGEST_FLAG) {
            // Bad digest
            pClient->dwStatusFlags |= MY_CODE_BAD_DIGEST;
            return S_FALSE; // Try next one
        }
    
        // Check to see if the signing certificate had a valid time
        if(pInfo->dwStatusFlags & PROTRUST_TIME_FLAG) {
            // time expired on certificate or issuer
            pClient->dwStatusFlags |= MY_CODE_BAD_TIME;
            return S_FALSE; // Try next one
        }
    
        // Check to see we got a root cert. If not then we did
        // not verify up to a root.
        if(!pInfo->pRoot) {
            pClient->dwStatusFlags |= MY_CODE_NO_ROOT;
            hr = CERT_E_ISSUERCHAINING;
        }
        else {
    
            // Test the Cert to see which one it is
            hr = SpcIsRootCert(pInfo->pRoot);
            if(hr == S_FALSE) { // The certificate is the test root cert
                pClient->dwRealRoot = FALSE;
                pClient->dwTestRoot = TRUE;
            }
            else if(hr == S_OK) {
                pClient->dwRealRoot = TRUE;
                pClient->dwTestRoot = FALSE;
            }
        }
        return hr;
    }
    
    
    // Information defined by me for use in my policy
    WCHAR   rgwSubjectPath[_MAX_PATH];
    BOOL    fCheckTimeStamp = FALSE;
    BOOL    fCheckCurrentTime = FALSE;
    BOOL    fTestRootOk = FALSE;
    
    void Usage ()
    {
        printf ( "Usage:   CHKTRUST [-options] file-name\n" );
        printf ( "Options:\n" );
        printf ( "  -I       : subject type is PE executable image file (default)\n" );
        printf ( "  -J       : subject type is Java class\n" );
        printf ( "  -C       : subject type is Cabinet file\n" );
        printf ( "  -S       : check for a time stamp\n");
        printf ( "  -T       : test root is valid\n");
        printf ( "  -U       : use current time to see if certificates are valid\n");
                    
        exit ( 0 );
    }
           
           
    VOID
    WINAPI
    ParseSwitch (CHAR chSwitch,
                 int *pArgc,
                 char **pArgv[])
    {
           
        switch (toupper (chSwitch)) {
        case '?':
            Usage();
            break;
        case 'I':
            pguidSubject = &guidSubjectPeImage;
            break;
        case 'J':
            pguidSubject = &guidSubjectJavaClass;
            break;
        case 'C':
            pguidSubject = &guidSubjectCabinet;
            break;
        case 'S':
            fCheckTimeStamp  = TRUE;
            break;
        case 'T':
            fTestRootOk  = TRUE;
            break;
        case 'U':
            fCheckCurrentTime  = TRUE;
            break;
        default:
            Usage ();
            break;
        }
    }
    
    void _cdecl main ( int argc, char** argv )
    {
        HCERTSTORE hRoots = NULL;
        WCHAR wpath[_MAX_PATH];
        char chChar, *pchChar;
    
        if ( argc <= 1 ) Usage ();
    
        while (--argc) {
            pchChar = *++argv;
            if (*pchChar == '/' || *pchChar == '-') {
                while (chChar = *++pchChar) {
                    ParseSwitch (chChar, &argc, &argv);
                }
            }
            else {
                MultiByteToWideChar ( CP_ACP, 0, pchChar, -1, wpath, _MAX_PATH );
                sSubjectFile.hFile = INVALID_HANDLE_VALUE;
                sSubjectFile.lpPath = &(wpath[0]);
                sSetup.SubjectType = pguidSubject;
                sSetup.Subject = &sSubjectFile;
            }
        }
        
        // Make sure we have a file
        if ( sSubjectFile.lpPath == NULL ) 
            Usage();
        
        // Setup up client data for policy (application decides what this is)
        CLIENT_DATA sClientData; 
        //   Zero out structure
        ZeroMemory(&sClientData, sizeof(CLIENT_DATA));
            
        //   Set the Client structure to return status codes
        sSetup.hClientToken = (HANDLE) &sClientData;
    
        //==================
        // Setup the Protrust structure
            
        // Setup the Protected Trust info (Most fields are optional)
        //   Zero out structure
        ZeroMemory(&sSetup.sTrustInfo, sizeof(PROTECTED_TRUST_INFO));
            
            //   Set size of structure for extensibility
        sSetup.sTrustInfo.cbSize = sizeof(PROTECTED_TRUST_INFO); // 
            
        //   Check the possible flags for verifying certificates
        sSetup.sTrustInfo.dwVerifyFlags = PROTRUST_CERT_SIGNATURE_FLAG;
        if(fTestRootOk)
            sSetup.sTrustInfo.dwVerifyFlags |= PROTRUST_TRUST_TEST_ROOT;
        if(fCheckTimeStamp) 
            sSetup.sTrustInfo.dwVerifyFlags |= PROTRUST_TIMESTAMP_SIGNATURE_FLAG;
        if(fCheckCurrentTime)
            sSetup.sTrustInfo.dwVerifyFlags |= PROTRUST_CERT_TIME_VALIDITY_FLAG;
            
            
            //   Set the policy (defined above)
        sSetup.sTrustInfo.pfnPolicy = MyPolicy;
        
        //   The rest of sSetup.sTrustInfo is the default values
       
            //==================
            // Check the file
    
        DWORD r = WinVerifyTrust ( NULL, pguidActionID, &sSetup );
        if(sClientData.dwStatusFlags & MY_CODE_NO_ROOT)
            printf ("Did not find a root certificate\n");
        if(sClientData.dwStatusFlags & MY_CODE_BAD_DIGEST)
            printf ("There was no valid signature\n");
        if(sClientData.dwStatusFlags & MY_CODE_BAD_TIME)
            
            printf ("The certificate had an invalid time\n");
    
        switch(r) {
        case TRUST_E_NOSIGNATURE:
            printf ("No signature found\n");
            break;
        default:
            printf ("Result: %0x\n", r );
        }
    
        if(hRoots)
            CertCloseStore(hRoots, 0);
        exit ( r == 0 ? 0 : 1 );
    }
    
    */ 
//---------------------------------------------------------------------------
#ifdef __cplusplus
}
#endif

#endif //_PROTRUST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pvkhlpr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkhlpr.h
//
//  Contents:   Private Key Helper API Prototypes and Definitions
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  APIs:       PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContext
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//              PrivateKeyLoadA
//              PrivateKeySaveA
//              PrivateKeyLoadFromMemoryA
//              PrivateKeySaveToMemoryA
//              PrivateKeyAcquireContextA
//              PrivateKeyAcquireContextFromMemoryA
//              PrivateKeyReleaseContextA
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __PVKHLPR_H__
#define __PVKHLPR_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PRIVATEKEYBLOB
#define PRIVATEKEYBLOB  0x7
#endif


    //+-------------------------------------------------------------------------
    //  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  from the file into the cryptographic provider.
    //
    //  If the private key was password encrypted, then, the user is first
    //  presented with a dialog box to enter the password.
    //
    //  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
    //  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
    //  a mismatch. *pdwKeySpec is updated with the key type.
    //
    //  dwFlags is passed through to CryptImportKey.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyLoad(IN HCRYPTPROV hCryptProv,
                       IN HANDLE hFile,
                       IN HWND hwndOwner,
                       IN LPCWSTR pwszKeyName,     // name used in dialog
                       IN DWORD dwFlags,
                       IN OUT OPTIONAL DWORD *pdwKeySpec);

    BOOL WINAPI
        PvkPrivateKeyLoadA(IN HCRYPTPROV hCryptProv,
                        IN HANDLE hFile,
                        IN HWND hwndOwner,
                        IN LPCTSTR pwszKeyName,     // name used in dialog
                        IN DWORD dwFlags,
                        IN OUT OPTIONAL DWORD *pdwKeySpec);

    //+-------------------------------------------------------------------------
    //  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  to the specified file.
    //
    //  The user is presented with a dialog box to enter an optional password to
    //  encrypt the private key.
    //
    //  dwFlags is passed through to CryptExportKey.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeySave(IN HCRYPTPROV hCryptProv,
                       IN HANDLE hFile,
                       IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                       IN HWND hwndOwner,
                       IN LPCWSTR pwszKeyName,     // name used in dialog
                       IN DWORD dwFlags);

    BOOL WINAPI
        PvkPrivateKeySaveA(IN HCRYPTPROV hCryptProv,
                        IN HANDLE hFile,
                        IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                        IN HWND hwndOwner,
                        IN LPCTSTR pwszKeyName,     // name used in dialog
                        IN DWORD dwFlags);
    //+-------------------------------------------------------------------------
    //  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  from memory into the cryptographic provider.
    //
    //  Except for the key being loaded from memory, identical to PrivateKeyLoad.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyLoadFromMemory(IN HCRYPTPROV hCryptProv,
                                 IN BYTE *pbData,
                                 IN DWORD cbData,
                                 IN HWND hwndOwner,
                                 IN LPCWSTR pwszKeyName,     // name used in dialog
                                 IN DWORD dwFlags,
                                 IN OUT OPTIONAL DWORD *pdwKeySpec);

    BOOL WINAPI
        PvkPrivateKeyLoadFromMemoryA(IN HCRYPTPROV hCryptProv,
                                  IN BYTE *pbData,
                                  IN DWORD cbData,
                                  IN HWND hwndOwner,
                                  IN LPCTSTR pwszKeyName,     // name used in dialog
                                  IN DWORD dwFlags,
                                  IN OUT OPTIONAL DWORD *pdwKeySpec);
    
    //+-------------------------------------------------------------------------
    //  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  to memory.
    //
    //  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
    //  return an error (also, the user isn't prompted for a password).
    //
    //  Except for the key being saved to memory, identical to PrivateKeySave.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeySaveToMemory(IN HCRYPTPROV hCryptProv,
                               IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                               IN HWND hwndOwner,
                               IN LPCWSTR pwszKeyName,     // name used in dialog
                               IN DWORD dwFlags,
                               OUT BYTE *pbData,
                               IN OUT DWORD *pcbData);

    BOOL WINAPI
        PvkPrivateKeySaveToMemoryA(IN HCRYPTPROV hCryptProv,
                                IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                                IN HWND hwndOwner,
                                IN LPCTSTR pwszKeyName,     // name used in dialog
                                IN DWORD dwFlags,
                                OUT BYTE *pbData,
                                IN OUT DWORD *pcbData);

    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from the specified file.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoad is called to load the private key into the temporary
    //  container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContext(IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN HANDLE hFile,
                                 IN HWND hwndOwner,
                                 IN LPCWSTR pwszKeyName,     // name used in dialog
                                 IN OUT OPTIONAL DWORD *pdwKeySpec,
                                 OUT HCRYPTPROV *phCryptProv,
                                 OUT LPWSTR *ppwszTmpContainer
                                 );

    BOOL WINAPI
        PvkPrivateKeyAcquireContextA(IN LPCTSTR pwszProvName,
                                  IN DWORD dwProvType,
                                  IN HANDLE hFile,
                                  IN HWND hwndOwner,
                                  IN LPCTSTR pwszKeyName,     // name used in dialog
                                  IN OUT OPTIONAL DWORD *pdwKeySpec,
                                  OUT HCRYPTPROV *phCryptProv,
                                  OUT LPTSTR *ppwszTmpContainer);
    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from memory.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoadFromMemory is called to load the private key into the
    //  temporary container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemory(IN LPCWSTR pwszProvName,
                                           IN DWORD dwProvType,
                                           IN BYTE *pbData,
                                           IN DWORD cbData,
                                           IN HWND hwndOwner,
                                           IN LPCWSTR pwszKeyName,     // name used in dialog
                                           IN OUT OPTIONAL DWORD *pdwKeySpec,
                                           OUT HCRYPTPROV *phCryptProv,
                                           OUT LPWSTR *ppwszTmpContainer);

    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemoryA(IN LPCTSTR pwszProvName,
                                            IN DWORD dwProvType,
                                            IN BYTE *pbData,
                                            IN DWORD cbData,
                                            IN HWND hwndOwner,
                                            IN LPCTSTR pwszKeyName,     // name used in dialog
                                            IN OUT OPTIONAL DWORD *pdwKeySpec,
                                            OUT HCRYPTPROV *phCryptProv,
                                            OUT LPTSTR *ppwszTmpContainer);

    //+-------------------------------------------------------------------------
    //  Releases the cryptographic provider and deletes the temporary container
    //  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyReleaseContext(IN HCRYPTPROV hCryptProv,
                                 IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN LPWSTR pwszTmpContainer);

    BOOL WINAPI
        PvkPrivateKeyReleaseContextA(IN HCRYPTPROV hCryptProv,
                                  IN LPCTSTR pwszProvName,
                                  IN DWORD dwProvType,
                                  IN LPTSTR pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Acquiring hprovs, Trys the file first and then the KeyContainer. Use
//  PvkFreeCryptProv to release HCRYPTPROV and resources.
//--------------------------------------------------------------------------
    HCRYPTPROV WINAPI 
        PvkGetCryptProvA(IN HWND hwnd,
                         IN LPCSTR pszCaption,
                         IN LPCSTR pszCapiProvider,
                         IN DWORD  dwProviderType,
                         IN LPCSTR pszPrivKey,
                         OUT LPSTR *ppszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvA(IN HCRYPTPROV hProv,
                          IN LPCSTR  pszCapiProvider,
                          IN DWORD   dwProviderType,
                          IN LPSTR   pszTmpContainer);

    HCRYPTPROV WINAPI 
        PvkGetCryptProvU(IN HWND hwnd,
                         IN LPCWSTR pwszCaption,
                         IN LPCWSTR pwszCapiProvider,
                         IN DWORD   dwProviderType,
                         IN LPCWSTR pwszPrivKey,
                         OUT LPWSTR *ppwszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvU(IN HCRYPTPROV hProv,
                          IN LPCWSTR  pwszCapiProvider,
                          IN DWORD    dwProviderType,
                          IN LPWSTR   pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Private Key helper  error codes
//--------------------------------------------------------------------------
#define PVK_HELPER_BAD_PARAMETER        0x80097001
#define PVK_HELPER_BAD_PVK_FILE         0x80097002
#define PVK_HELPER_WRONG_KEY_TYPE       0x80097003
#define PVK_HELPER_PASSWORD_CANCEL      0x80097004

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\redir.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       redir.h
//
//--------------------------------------------------------------------------

#ifndef _REDIR_H_
#define _REDIR_H_

/* 

  Dev Notes:
  To define a redirected provider, call FDefineProvTypeFuncPointers(...).
  Any hProv, hKey, or hHash created using that dwProvType after will 
  be redirected. Any provider not in the list of redirected providers
  will fall through to CAPI. ReDir's handles are fully compatible with 
  direct calls to CAPI.
  
  You are not required to undefine a provider you define -- ReDir will 
  clean up the table during PROCESS_DETACH. However, if you 
  wish to clean up a dwProvType you previously defined, call 
  FUndefineProvTypeFuncPointers(...). 



  WARNING: 
  Reference counting is not applied to the defined providers. That
  is, if you remove a provider definition and then attempt to use 
  an {hKey, hProv, hHash} that was used with that provider, ReDir will
  not have a valid function table.
  


  MultiThreading:
  Critical sections are applied to all functions where necessary, and
  this library should be fully multithread-safe.



  CryptSetProvider availability:
  CryptSetProvider{A,W} is not available to non-CAPI providers. The 
  functions return FALSE if not pointing to AdvAPI's CAPI.



  Wide char APIs:
  Win95 doesn't support Wide APIs, and real ADVAPI doesn't export them.
  Thus, the easiest thing to do was to not try an load them, in any case.
  This means ReDir doesn't support the Wide APIs, even on NT. Could change
  to use an OS check before loading...?

*/

// to allow us to see both W and A versions of APIs, don't
// force us away from either just yet...
#ifndef _ADVAPI32_
#define WINADVAPI DECLSPEC_IMPORT
#endif
			 
// wincrypt func prototypes; other func prototypes at EOF
#include "wincrypt.h"


// Some CryptoAPI typedefs
typedef WINADVAPI BOOL WINAPI CRYPTACQUIRECONTEXTW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
typedef WINADVAPI BOOL WINAPI CRYPTACQUIRECONTEXTA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
#ifdef UNICODE
#define CRYPTACQUIRECONTEXT  CRYPTACQUIRECONTEXTW
#else
#define CRYPTACQUIRECONTEXT  CRYPTACQUIRECONTEXTA
#endif // !UNICODE

typedef WINADVAPI BOOL WINAPI CRYPTRELEASECONTEXT(
    HCRYPTPROV hProv,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGENKEY(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef WINADVAPI BOOL WINAPI CRYPTDERIVEKEY(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef WINADVAPI BOOL WINAPI CRYPTDESTROYKEY(
    HCRYPTKEY hKey);

typedef WINADVAPI BOOL WINAPI CRYPTSETKEYPARAM(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGETKEYPARAM(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTSETHASHPARAM(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGETHASHPARAM(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTSETPROVPARAM(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGETPROVPARAM(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGENRANDOM(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

typedef WINADVAPI BOOL WINAPI CRYPTGETUSERKEY(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

typedef WINADVAPI BOOL WINAPI CRYPTEXPORTKEY(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef WINADVAPI BOOL WINAPI CRYPTIMPORTKEY(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef WINADVAPI BOOL WINAPI CRYPTENCRYPT(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

typedef WINADVAPI BOOL WINAPI CRYPTDECRYPT(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef WINADVAPI BOOL WINAPI CRYPTCREATEHASH(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

typedef WINADVAPI BOOL WINAPI CRYPTHASHDATA(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTHASHSESSIONKEY(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTDESTROYHASH(
    HCRYPTHASH hHash);

typedef WINADVAPI BOOL WINAPI CRYPTSIGNHASHA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);
typedef WINADVAPI BOOL WINAPI CRYPTSIGNHASHW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);
#ifdef UNICODE
#define CRYPTSIGNHASH  CRYPTSIGNHASHW
#else
#define CRYPTSIGNHASH  CRYPTSIGNHASHA
#endif // !UNICODE

typedef WINADVAPI BOOL WINAPI CRYPTVERIFYSIGNATUREA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);
typedef WINADVAPI BOOL WINAPI CRYPTVERIFYSIGNATUREW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);
#ifdef UNICODE
#define CRYPTVERIFYSIGNATURE  CRYPTVERIFYSIGNATUREW
#else
#define CRYPTVERIFYSIGNATURE  CRYPTVERIFYSIGNATUREA
#endif // !UNICODE

typedef WINADVAPI BOOL WINAPI CRYPTSETPROVIDERA(
    LPCSTR pszProvName,
    DWORD dwProvType);
typedef WINADVAPI BOOL WINAPI CRYPTSETPROVIDERW(
    LPCWSTR pszProvName,
    DWORD dwProvType);
#ifdef UNICODE
#define CRYPTSETPROVIDER  CRYPTSETPROVIDERW
#else
#define CRYPTSETPROVIDER  CRYPTSETPROVIDERA
#endif // !UNICODE



// a structure with a bunch of 

typedef	struct FuncList
{
	CRYPTACQUIRECONTEXTA	*pfnAcquireContextA;
	CRYPTACQUIRECONTEXTW	*pfnAcquireContextW;
	CRYPTRELEASECONTEXT		*pfnReleaseContext;
	CRYPTGENKEY				*pfnGenKey;
	CRYPTDERIVEKEY			*pfnDeriveKey;
	CRYPTDESTROYKEY			*pfnDestroyKey;
	CRYPTSETKEYPARAM		*pfnSetKeyParam;
	CRYPTGETKEYPARAM		*pfnGetKeyParam;
	CRYPTSETHASHPARAM		*pfnSetHashParam;
	CRYPTGETHASHPARAM		*pfnGetHashParam;
	CRYPTSETPROVPARAM		*pfnSetProvParam;
	CRYPTGETPROVPARAM		*pfnGetProvParam;
	CRYPTGENRANDOM			*pfnGenRandom;
	CRYPTGETUSERKEY			*pfnGetUserKey;
	CRYPTEXPORTKEY			*pfnExportKey;
	CRYPTIMPORTKEY			*pfnImportKey;
	CRYPTENCRYPT			*pfnEncrypt;
	CRYPTDECRYPT			*pfnDecrypt;
	CRYPTCREATEHASH			*pfnCreateHash;
	CRYPTHASHDATA			*pfnHashData;
	CRYPTHASHSESSIONKEY		*pfnHashSessionKey;
	CRYPTDESTROYHASH		*pfnDestroyHash;
	CRYPTSIGNHASHA			*pfnSignHashA;
	CRYPTSIGNHASHW			*pfnSignHashW;
	CRYPTVERIFYSIGNATUREA	*pfnVerifySignatureA;
	CRYPTVERIFYSIGNATUREW	*pfnVerifySignatureW;
	CRYPTSETPROVIDERA		*pfnSetProviderA;
	CRYPTSETPROVIDERW		*pfnSetProviderW;

} FUNCLIST, *PFUNCLIST;


// other func prototypes
BOOL WINAPI	FDefineProvTypeFuncPointers(DWORD dwProvType, PFUNCLIST psFuncList);
BOOL WINAPI	FUndefineProvTypeFuncPointers(DWORD dwProvType);


#endif // _REDIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\pstprv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pstprv.h
//
//--------------------------------------------------------------------------

//
// private header for secure storage
//

#ifndef __PSTPRV_H__
#define __PSTPRV_H__

#define PROTSTOR_VERSION            1
#define MAXPROTSEQ                  20     // increase avail bind handles to 20

#define PSTORE_LOCAL_ENDPOINT        L"protected_storage"
#define PSTORE_LOCAL_PROT_SEQ        L"ncalrpc"

#define PST_EVENT_INIT              "PS_SERVICE_STARTED"
//
// For Windows NT5, terminal server requires the "Global\" prefix in order
// for the named-event to be shared across all sessions.
//
#define PST_EVENT_INIT_NT5          "Global\\PS_SERVICE_STARTED"
#define PST_EVENT_STOP              "PS_SERVICE_STOP"
#define PST_EVENT_DEFER_QUERY       "PS_SERVICE_QUERY"

//
// file name of our network provider
//

#define FILENAME_NETWORK_PROVIDER   L"pstorenp.dll"
#define FILENAME_NETWORK_PROVIDERA  "pstorenp.dll"
#define FILENAME_CLIENT_INTERFACE   L"pstorec.dll"
#define FILENAME_CLIENT_INTERFACEA  "pstorec.dll"
#define FILENAME_SERVER_INTERFACE   "pstores.exe"   // unicode later
#define FILENAME_SERVER_INTERFACEW  L"pstores.exe"
#define FILENAME_BASE_PROVIDER      "psbase.dll"    // unicode later
#define FILENAME_BASE_PROVIDERW     L"psbase.dll"
#define FILENAME_PSTORE_EXPLORER    "pstoreex.dll"
#define FILENAME_RESOURCE_MODULEW   L"pstorerc.dll"
#define NETWORK_PROVIDER_FILENAME   FILENAME_NETWORK_PROVIDER


//
// CLSID string in ANSI for PStore Explorer installation.
//

#define GUID_EXPLORER_SZ            "{5fe50e0e-8dcb-11d0-8c43-00c04fc2c621}"

#define PST_AUTHENTICODE_ACTION_ID  { 0xb750e756, 0xee6d, 0x11d0, {0xaa, 0x18, 0x00, 0x00, 0xf8, 0x75, 0x3a, 0x58} }
#define PST_AUTHENTICODE_INIT_POLICY    L"AuthInitPolicy"
#define PST_AUTHENTICODE_FINAL_POLICY   L"AuthFinalPolicy"

#define PASSWORD_LOGON_NT           1
//
// WinNT doesn't have logoff notification.  Scavenger will call LSA to see if
// session deleted.
//
#define PASSWORD_LOGON_LEGACY_95    3   // old case-sensitive passwords on Win95, don't use!
#define PASSWORD_LOGOFF_95          4
#define PASSWORD_LOGON_95           5

#define MODULE_RAISE_COUNT          4   // Ref count on process raise count



#define REG_PSTTREE_LOC             L"SOFTWARE\\Microsoft\\Protected Storage System Provider"



//
// private callbacks exposed for server which are specific to base provider.
//

#define SS_SERVERPARAM_CALLBACKS    0x6997  // server get param value

typedef
BOOL FGETWINDOWSPASSWORD(
        PST_PROVIDER_HANDLE     *hPSTProv,
        BYTE                    rgbPasswordDerivedBytes[],
        DWORD                   cbPasswordDerivedBytes);

FGETWINDOWSPASSWORD FGetWindowsPassword;

typedef
HRESULT PRIVATE_AUTHENTICODEINITPOLICY(
    IN      LPVOID lpV
    );

PRIVATE_AUTHENTICODEINITPOLICY PrivateAuthenticodeInitPolicy;

typedef
HRESULT PRIVATE_AUTHENTICODEFINALPOLICY(
    IN      LPVOID lpV
    );

PRIVATE_AUTHENTICODEFINALPOLICY PrivateAuthenticodeFinalPolicy;

typedef struct {
    DWORD                               cbSize; // sizeof(PRIVATE_CALLBACKS)

    FGETWINDOWSPASSWORD*                pfnFGetWindowsPassword;

    PRIVATE_AUTHENTICODEINITPOLICY*     pfnAuthenticodeInitPolicy;
    PRIVATE_AUTHENTICODEFINALPOLICY*    pfnAuthenticodeFinalPolicy;

} PRIVATE_CALLBACKS, *PPRIVATE_CALLBACKS, *LPPRIVATE_CALLBACKS;


typedef struct {
    PST_PROVIDER_HANDLE hPSTProv;   // copy of client provided handle
    handle_t hBinding;              // client binding handle

    HANDLE hThread;                 // client thread handle
    HANDLE hProcess;                // client process handle (not to be closed)
    DWORD dwProcessId;              // client process ID
    LPVOID lpContext;               // Win95 HACKHACK context

} CALL_STATE, *PCALL_STATE, *LPCALL_STATE;


//
// hack work-around to Win95 imagehlp bug.
//

typedef struct {
    DWORD StartEip;
    DWORD StartEbp;
    DWORD StartEsp;
} HACK_WIN95_CONTEXT, *PHACK_WIN95_CONTEXT, *LPHACK_WIN95_CONTEXT;


//
// installed provider item data buffer
//

typedef struct {
    DWORD cbSize;                   // sizeof(PST_PROVIDER)
    BYTE FileHash[20];              // SHA-1 hash of file szFileName
    WCHAR szFileName[ANYSIZE_ARRAY];// Unicode (in-place) file name
} PST_PROVIDER, *PPST_PROVIDER, *LPPST_PROVIDER;


#endif // __PSTPRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\safelock.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    safelock.h

Abstract:

    "safe lock" collection of routines

    This code is a debug-only replacement for APIs dealing with
    critical sections and resources.  It is essentially a thin
    wrapper around those routines that ensures proper ordering
    of locks and helps catch potential deadlock situations.

    The code will generate debug spew (and optionally assert)
    when locks are acquired outside of the given order.

    Utilizing this code will have zero impact on the FRE builds
    and negligible impact on DBG builds (as it is lock- and
    contention-free)

    Here is how you use it:

    o  #include <safelock.h>

    o  determine the lock order for your routine and add an enum
       such as:

       typedef enum {

           LockTypeA,
           LockTypeB,
           LockTypeC

       } MY_ENUM;

       The code will ensure that, for instance, LockTypeA
       is not acquired with LockTypeC held, unless that thread
       already holds LockTypeA.

    o  Once per process initialization, call the SafeLockInit()
       routine.  This routine should only be called in checked
       builds.

    o  replace every declaration of RTL_CRITICAL_SECTION
       with SAFE_CRITICAL_SECTION

    o  replace every declaration of RTL_RESOURCE
       with SAFE_RESOURCE

    o  replace every call to RtlEnterCriticalSection with
       SafeEnterCriticalSection (similary for RtlLeaveCriticalSection
       and other Rtl* calls involving RTL_CRITICAL_SECTION)

    o  replace every call to RtlAcquireResource with
       SafeAcquireResource (similarly for RtlReleaseResource and
       other Rtl* calls involving RTL_RESOURCE)

    o  RtlInitializeCriticalSection and RtlInitializeResource
       are replaced with SafeEnterCriticalSection and
       SafeInitializeResource and take one additional parameter -
       the enum value associated with the critical section:

       e.g. replace

       RtlInitializeCriticalSection( &critsecA );

       with

       SafeInitializeCriticalSection( &critsecA, LockTypeA );

--*/

#ifndef __SAFELOCK_H
#define __SAFELOCK_H

#include <nturtl.h>

#ifdef DBG

NTSTATUS
SafeLockInit();

typedef struct _SAFE_CRITICAL_SECTION {

    RTL_CRITICAL_SECTION CriticalSection;
    DWORD Enum;

} SAFE_CRITICAL_SECTION, *PSAFE_CRITICAL_SECTION;

NTSTATUS
SafeEnterCriticalSection(
    PSAFE_CRITICAL_SECTION SafeCriticalSection
    );

NTSTATUS
SafeLeaveCriticalSection(
    PSAFE_CRITICAL_SECTION SafeCriticalSection
    );

BOOLEAN
SafeTryEnterCriticalSection(
    PSAFE_CRITICAL_SECTION SafeCriticalSection
    );

NTSTATUS
SafeInitializeCriticalSection(
    PSAFE_CRITICAL_SECTION SafeCriticalSection,
    DWORD Enum
    );

NTSTATUS
SafeInitializeCriticalSectionAndSpinCount(
    PSAFE_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount,
    DWORD Enum
    );

ULONG
SafeSetCriticalSectionSpinCount(
    PSAFE_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    );

NTSTATUS
SafeDeleteCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    );

#define SafeCritsecLockCount( _critsec )            ((_critsec)->CriticalSection.LockCount )

typedef struct _SAFE_RESOURCE {

    RTL_RESOURCE Resource;
    DWORD Enum;

} SAFE_RESOURCE, *PSAFE_RESOURCE;

VOID
SafeInitializeResource(
    PSAFE_RESOURCE Resource,
    DWORD Enum
    );

BOOLEAN
SafeAcquireResourceShared(
    PSAFE_RESOURCE Resource,
    BOOLEAN Wait
    );

BOOLEAN
SafeAcquireResourceExclusive(
    PSAFE_RESOURCE Resource,
    BOOLEAN Wait
    );

VOID
SafeReleaseResource(
    PSAFE_RESOURCE Resource
    );

VOID
SafeConvertSharedToExclusive(
    PSAFE_RESOURCE Resource
    );

VOID
SafeConvertExclusiveToShared(
    PSAFE_RESOURCE Resource
    );

VOID
NTAPI
SafeDeleteResource (
    PSAFE_RESOURCE Resource
    );

#define SafeEnterResourceCritsec( _resrc )          RtlEnterCriticalSection( &(_resrc)->Resource.CriticalSection )
#define SafeLeaveResourceCritsec( _resrc )          RtlLeaveCriticalSection( &(_resrc)->Resource.CriticalSection )
#define SafeNumberOfActive( _resrc )                ((_resrc)->Resource.NumberOfActive )
#define SafeNumberOfWaitingShared( _resrc )         ((_resrc)->Resource.NumberOfWaitingShared )
#define SafeNumberOfWaitingExclusive( _resrc )      ((_resrc)->Resource.NumberOfWaitingExclusive )

#else

#define SAFE_CRITICAL_SECTION RTL_CRITICAL_SECTION
#define PSAFE_CRITICAL_SECTION PRTL_CRITICAL_SECTION

#define SafeEnterCriticalSection                    RtlEnterCriticalSection
#define SafeLeaveCriticalSection                    RtlLeaveCriticalSection
#define SafeTryEnterCriticalSection                 RtlTryEnterCriticalSection
#define SafeInitializeCriticalSection( _cs, _enum ) RtlInitializeCriticalSection( _cs )
#define SafeInitializeCriticalSectionAndSpinCount( _cs, _count, _enum )   RtlInitializeCriticalSectionAndSpinCount( _cs, _count )
#define SafeSetCriticalSectionSpinCount             RtlSetCriticalSectionSpinCount
#define SafeDeleteCriticalSection                   RtlDeleteCriticalSection

#define SafeCritsecLockCount( _critsec )            ((_critsec)->LockCount )

#define SAFE_RESOURCE         RTL_RESOURCE
#define PSAFE_RESOURCE        PRTL_RESOURCE

#define SafeInitializeResource( _res, _enum )       RtlInitializeResource( _res )
#define SafeAcquireResourceShared                   RtlAcquireResourceShared
#define SafeAcquireResourceExclusive                RtlAcquireResourceExclusive
#define SafeReleaseResource                         RtlReleaseResource
#define SafeConvertSharedToExclusive                RtlConvertSharedToExclusive
#define SafeConvertExclusiveToShared                RtlConvertExclusiveToShared
#define SafeDeleteResource                          RtlDeleteResource

#define SafeEnterResourceCritsec( _resrc )          RtlEnterCriticalSection( &(_resrc)->CriticalSection )
#define SafeLeaveResourceCritsec( _resrc )          RtlLeaveCriticalSection( &(_resrc)->CriticalSection )
#define SafeNumberOfActive( _resrc )                ((_resrc)->NumberOfActive )
#define SafeNumberOfWaitingShared( _resrc )         ((_resrc)->NumberOfWaitingShared )
#define SafeNumberOfWaitingExclusive( _resrc )      ((_resrc)->NumberOfWaitingExclusive )

#endif

#endif // __SAFELOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\scuisupp.h ===
#if !defined(__SCUISUPP_INCLUDED__)
#define __SCUISUPP_INCLUDED__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <wincrypt.h>

// use these strings for RegisterWindowMessage
#define SCARDUI_READER_ARRIVAL		"SCardUIReaderArrival"
#define SCARDUI_READER_REMOVAL		"SCardUIReaderRemoval"
#define SCARDUI_SMART_CARD_INSERTION	"SCardUISmartCardInsertion"
#define SCARDUI_SMART_CARD_REMOVAL	"SCardUISmartCardRemoval"
#define SCARDUI_SMART_CARD_STATUS	"SCardUISmartCardStatus"
#define SCARDUI_SMART_CARD_CERT_AVAIL   "SCardUISmartCardCertAvail"

typedef LPVOID HSCARDUI;

typedef struct _CERT_ENUM
{
	// status of the reader / card 	  
	// typical values:
	// SCARD_S_SUCCESS
	// SCARD_E_UNKNOWN_CARD - unregistered / unknown card
	// SCARD_W_UNRESPONSIVE_CARD - card upside down
	// NTE_KEYSET_NOT_DEF - known card with no certificate
	// SCARD_W_REMOVED_CARD - card removed shortly after insertion
	DWORD				dwStatus;

	// name of the reader that contains the card
	LPTSTR				pszReaderName;

	// name of the card (NULL if card is unknown)
	LPTSTR				pszCardName;

	// certificate context 
	// (NULL if card is unknown or can't be read)
	PCERT_CONTEXT		pCertContext;

} CERT_ENUM, *PCERT_ENUM;


// initialize smart card ui
HSCARDUI 
WINAPI
SCardUIInit(
    HWND hWindow			// handle of parent window
    );

// clean up 
DWORD 
WINAPI
SCardUIExit(
	HSCARDUI hSCardUI		// handle that was returned by SCardUIInit
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\scrdcert.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scrdcert.h
//
//  Contents:   Smart Card Certificate Helper API
//
//  History:    21-Nov-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SCRDCERT_H__)
#define __SCRDCERT_H__

#if defined(__cplusplus)
extern "C" {
#endif 

//
// Register and Unregister a smart card certificate store.  These stores
// appear as physical stores under the Smart Card Logical Store in the 
// Current User location.  When registering a card store, the caller must
// provide the following information:
//
// Card Friendly Name
// Provider Name ( NULL means use the Microsoft Base Smart Card Provider )
// Container Name ( NULL means use the Card Friendly Name )
//
// If a card store of the given name already exists the registration will
// return an error (ERROR_ALREADY_EXISTS) unless the 
// SMART_CARD_STORE_REPLACE_EXISTING flag is used
//

#define SMART_CARD_STORE_REPLACE_EXISTING 0x00000001
         
BOOL WINAPI
I_CryptRegisterSmartCardStore (
       IN LPCWSTR pwszCardName,
       IN OPTIONAL LPCWSTR pwszProvider,
       IN OPTIONAL DWORD dwProviderType,
       IN OPTIONAL LPCWSTR pwszContainer,
       IN DWORD dwFlags
       );

BOOL WINAPI
I_CryptUnregisterSmartCardStore (
       IN LPCWSTR pwszCardName
       );  

//
// Find a smart card certificate in a store
//
// For a certificate to be considered a smart card certificate.  It must have
// the CERT_SMART_CARD_DATA_PROP_ID.  The SMART_CARD_CERT_FIND_DATA can be used
// to place additional filtering on the returned smart card certificates. 
// Optionally, the CERT_SMART_CARD_DATA_PROP_ID value can be returned as well.
// The value can be freed using LocalFree or if the *ppSmartCardData is non NULL 
// will be freed for the caller
//

typedef struct _SMART_CARD_CERT_FIND_DATA {

    DWORD  cbSize;                        
    LPWSTR pwszProvider;
    DWORD  dwProviderType;
    LPWSTR pwszContainer;
    DWORD  dwKeySpec;
    
} SMART_CARD_CERT_FIND_DATA, *PSMART_CARD_CERT_FIND_DATA;

PCCERT_CONTEXT WINAPI
I_CryptFindSmartCardCertInStore (
       IN HCERTSTORE hStore,
       IN PCCERT_CONTEXT pPrevCert,
       IN OPTIONAL PSMART_CARD_CERT_FIND_DATA pFindData,
       IN OUT OPTIONAL PCRYPT_DATA_BLOB* ppSmartCardData
       );
       
//
// Add a smart card certificate to a store and add the specified properties
// to it.
//

BOOL WINAPI
I_CryptAddSmartCardCertToStore (
       IN HCERTSTORE hStore,
       IN PCRYPT_DATA_BLOB pEncodedCert,
       IN OPTIONAL LPWSTR pwszCertFriendlyName,
       IN PCRYPT_DATA_BLOB pSmartCardData,
       IN PCRYPT_KEY_PROV_INFO pKeyProvInfo
       );      
       
//
// Definitions
//

#define MS_BASE_PROVIDER         L"Microsoft Base Cryptographic Provider"
#define MAX_PROVIDER_TYPE_STRLEN 13
#define SMART_CARD_SYSTEM_STORE  L"SmartCard"
                          
#if defined(__cplusplus)
}
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\setcert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       setcert.h
//
//  Contents:   SET X509 Certificate Extension Definitions
//              
//
//  History:    22-Nov-96   philh   created
//--------------------------------------------------------------------------

#ifndef __SETCERT_H__
#define __SETCERT_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Predefined X509 SET certificate extension data structures that can be
//  encoded / decoded.
//--------------------------------------------------------------------------
#define X509_SET_ACCOUNT_ALIAS              ((LPCSTR) 1000)
#define X509_SET_HASHED_ROOT_KEY            ((LPCSTR) 1001)
#define X509_SET_CERTIFICATE_TYPE           ((LPCSTR) 1002)
#define X509_SET_MERCHANT_DATA              ((LPCSTR) 1003)

//+-------------------------------------------------------------------------
//  SET Private Extension Object Identifiers
//--------------------------------------------------------------------------
#define szOID_SET_ACCOUNT_ALIAS         "2.99999.1"
#define szOID_SET_HASHED_ROOT_KEY       "2.99999.2"
#define szOID_SET_CERTIFICATE_TYPE      "2.99999.3"
#define szOID_SET_MERCHANT_DATA         "2.99999.4"

#define SET_ACCOUNT_ALIAS_OBJID         szOID_SET_ACCOUNT_ALIAS
#define SET_HASHED_ROOT_KEY_OBJID       szOID_SET_HASHED_ROOT_KEY
#define SET_CERTIFICATE_TYPE_OBJID      szOID_SET_CERTIFICATE_TYPE
#define SET_MERCHANT_DATA_OBJID         szOID_SET_MERCHANT_DATA

//+-------------------------------------------------------------------------
//  szOID_SET_ACCOUNT_ALIAS private extension
//
//  pvStructInfo points to BOOL.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_SET_HASHED_ROOT_KEY private extension
//
//  pvStructInfo points to: BYTE rgbInfo[SET_HASHED_ROOT_LEN].
//--------------------------------------------------------------------------
#define SET_HASHED_ROOT_LEN 20


//+-------------------------------------------------------------------------
//  szOID_SET_CERTIFICATE_TYPE private extension
//
//  pvStructInfo points to CRYPT_BIT_BLOB.
//--------------------------------------------------------------------------
// BYTE 0
#define SET_CERT_CARD_FLAG          0x80
#define SET_CERT_MER_FLAG           0x40
#define SET_CERT_PGWY_FLAG          0x20
#define SET_CERT_CCA_FLAG           0x10
#define SET_CERT_MCA_FLAG           0x08
#define SET_CERT_PCA_FLAG           0x04
#define SET_CERT_GCA_FLAG           0x02
#define SET_CERT_BCA_FLAG           0x01
// BYTE 1
#define SET_CERT_RCA_FLAG           0x80
#define SET_CERT_ACQ_FLAG           0x40

//+-------------------------------------------------------------------------
//  szOID_SET_MERCHANT_DATA private extension
//
//  pvStructInfo points to following SET_MERCHANT_DATA_INFO
//--------------------------------------------------------------------------
typedef struct _SET_MERCHANT_DATA_INFO {
    LPSTR       pszMerID;
    LPSTR       pszMerAcquirerBIN;
    LPSTR       pszMerTermID;
    LPSTR       pszMerName;
    LPSTR       pszMerCity;
    LPSTR       pszMerStateProvince;
    LPSTR       pszMerPostalCode;
    LPSTR       pszMerCountry;
    LPSTR       pszMerPhone;
    BOOL        fMerPhoneRelease;
    BOOL        fMerAuthFlag;
} SET_MERCHANT_DATA_INFO, *PSET_MERCHANT_DATA_INFO;

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\secwarn.h ===
// W4 is too cumbersome. For that matter, even 4701 is painful,
// But, it's still very helpful in catching uninitialized vars.

// Add any other diagnostics here
#include <warning.h>
#pragma warning(error:4701)

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\sclogon2.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ScLogon2

Abstract:

    This header defines APIs for use by GINA and LSA during logon via a
    smart card, these API's merely redirect the calls from the LSA procoess
    back to the corresponing Winlogon process to make the needed CSP calls

Author:

    reidk

Environment:

    Win32

Revision History:

Notes:

--*/

#ifndef __SCLOGON2_H__
#define __SCLOGON2_H__


#define SCLOGONRPC_DEFAULT_ENDPOINT             TEXT("\\pipe\\sclogonpipe")
#define SCLOGONRPC_DEFAULT_PROT_SEQ             TEXT("ncacn_np")

#define SCLOGONRPC_LOCAL_ENDPOINT               TEXT("sclogonrpc")
#define SCLOGONRPC_LOCAL_PROT_SEQ               TEXT("ncalrpc")

#define SZ_ENDPOINT_NAME_FORMAT                 TEXT("%s-%lx")

#ifdef __cplusplus
extern "C" {
#endif


NTSTATUS WINAPI
__ScHelperInitializeContext(
    IN OUT PBYTE                    pbLogonInfo,
    IN ULONG                        cbLogonInfo
    );

VOID WINAPI
__ScHelperRelease(
    IN PBYTE                        ppbLogonInfo
    );

NTSTATUS WINAPI
__ScHelperGetProvParam(
    IN PUNICODE_STRING              pucPIN,
    IN PBYTE                        pbLogonInfo,
    DWORD                           dwParam,
    BYTE                            *pbData,
    DWORD                           *pdwDataLen,
    DWORD                           dwFlags
    );

NTSTATUS WINAPI
__ScHelperGetCertFromLogonInfo(
    IN PBYTE                        pbLogonInfo,
    IN PUNICODE_STRING              pucPIN,
    OUT PCCERT_CONTEXT              *CertificateContext
    );

NTSTATUS WINAPI
__ScHelperGenRandBits(
    IN PBYTE                        pbLogonInfo,
    IN ScHelper_RandomCredBits      *psc_rcb
);


NTSTATUS WINAPI
__ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING              pucPIN,
    IN PCCERT_CONTEXT               CertificateContext,
    IN PBYTE                        pbLogonInfo,
    IN PBYTE                        SignedEncryptedData,
    IN ULONG                        SignedEncryptedDataSize,
    OUT OPTIONAL PBYTE              CleartextData,
    OUT PULONG                      CleartextDataSize
    );

NTSTATUS WINAPI
__ScHelperEncryptCredentials(
    IN PUNICODE_STRING              pucPIN,
    IN PCCERT_CONTEXT               CertificateContext,
    IN ScHelper_RandomCredBits      *psch_rcb,
    IN PBYTE                        pbLogonInfo,
    IN PBYTE                        CleartextData,
    IN ULONG                        CleartextDataSize,
    OUT OPTIONAL PBYTE              EncryptedData,
    OUT PULONG                      EncryptedDataSize
    );

NTSTATUS WINAPI
__ScHelperSignMessage(
    IN PUNICODE_STRING              pucPIN,
    IN PBYTE                        pbLogonInfo,
    IN OPTIONAL HCRYPTPROV          Provider,
    IN ULONG                        Algorithm,
    IN PBYTE                        Buffer,
    IN ULONG                        BufferLength,
    OUT PBYTE                       Signature,
    OUT PULONG                      SignatureLength
    );

NTSTATUS WINAPI
__ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING     pucPIN,
    IN OPTIONAL PBYTE               pbLogonInfo,
    IN OPTIONAL HCRYPTPROV          Provider,
    IN PCCERT_CONTEXT               Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER  Algorithm,
    IN OPTIONAL DWORD               dwSignMessageFlags,
    IN PBYTE                        Buffer,
    IN ULONG                        BufferLength,
    OUT OPTIONAL PBYTE              SignedBuffer,
    OUT OPTIONAL PULONG             SignedBufferLength
    );

NTSTATUS WINAPI
__ScHelperVerifyMessage(
    IN OPTIONAL PBYTE               pbLogonInfo,
    IN PCCERT_CONTEXT               CertificateContext,
    IN ULONG                        Algorithm,
    IN PBYTE                        Buffer,
    IN ULONG                        BufferLength,
    IN PBYTE                        Signature,
    IN ULONG                        SignatureLength
    );

NTSTATUS WINAPI
__ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE               pbLogonInfo,
    IN OPTIONAL HCRYPTPROV          Provider,
    IN PBYTE                        Buffer,
    IN ULONG                        BufferLength,
    OUT OPTIONAL PBYTE              DecodedBuffer,
    OUT OPTIONAL PULONG             DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT     *CertificateContext
    );

NTSTATUS WINAPI
__ScHelperDecryptMessage(
    IN PUNICODE_STRING              pucPIN,
    IN OPTIONAL PBYTE               pbLogonInfo,
    IN OPTIONAL HCRYPTPROV          Provider,
    IN PCCERT_CONTEXT               CertificateContext,
    IN PBYTE                        CipherText,         // Supplies formatted CipherText
    IN ULONG                        CipherLength,       // Supplies the length of the CiperText
    OUT PBYTE                       ClearText,          // Receives decrypted message
    IN OUT PULONG                   pClearLength        // Supplies length of buffer, receives actual length
    );


/////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif

#endif // __SCLOGON2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\secauth.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       secauth.h
//
//--------------------------------------------------------------------------

//Security dialog box help

#define SECAUTH_HELPFILENAME                "SECAUTH.HLP"

//Topics were copied from iexplore.rtf (IE help)
#define IDH_SECAUTH_ENTER_SSL               52168 //Entering a secure site
#define IDH_SECAUTH_ENTER_SSL_W_INVALIDCERT 52169 //Entering a secure site with an invalid certificate
#define IDH_SECAUTH_FILE_DOWN               52170 //File Download
#define IDH_SECAUTH_SEND_N_REC_COOKIES      52171 //Sending and Receiving Information About Your Browsing
#define IDH_SECAUTH_SIGNED                  52172 //Signed ActiveX/Java Download
#define IDH_SECAUTH_SIGNED_N_INVALID        52173 //Signed and Invalid ActiveX/Java Download
#define IDH_SECAUTH_UNSIGNED                52174 //Unsigned ActiveX/Java Download
#define IDH_SECAUTH_MIXED_DOWNLOAD_FROM_SSL 52175 //Insecure content download from a secure Web site
#define IDH_SECAUTH_ENTER_NON_SECURE_SITE   52226 //Entering non-secure Web site without a cert, from a secure web site
#define IDH_SECAUTH_SIGNED_N_INVALID_WEB    52227 //Entering Web site with invalid cert, from a secure web site

#define IDH_TRUSTCOMMERCIAL                 1
#define IDH_TRUSTLIST                       4
#define IDH_TRUSTREMOVE                     5

#define IDH_DIGSIGNATURE                    11
#define IDH_DIGCERTIFICATE                  12
#define IDH_CONTENTDESC                     13
#define IDH_MYURL                           14
#define IDH_TIMESTAMPURL                    15

#define IDH_CERTVIEW_GENERAL_SUBJECT_EDIT           101
#define IDH_CERTVIEW_GENERAL_ISSUER_EDIT            102
#define IDH_CERTVIEW_GENERAL_INSTALLCERT_BUTTON     103
#define IDH_CERTVIEW_GENERAL_EDITPROPERTIES_BUTTON  104
#define IDH_CERTVIEW_GENERAL_DISCLAIMER_BUTTON      105
#define IDH_CERTVIEW_GENERAL_ACCEPT_BUTTON          106
#define IDH_CERTVIEW_GENERAL_DECLINE_BUTTON         107
#define IDH_CERTVIEW_GENERAL_GOODFOR_EDIT           108
#define IDH_CERTVIEW_GENERAL_VALID_EDIT             110
#define IDH_CERTVIEW_GENERAL_PRIVATE_KEY_INFO       111

#define IDH_CERTVIEW_DETAILS_SHOW_COMBO             115
#define IDH_CERTVIEW_DETAILS_SAVECERT_BUTTON        116
#define IDH_CERTVIEW_DETAILS_ITEM_LIST              117
#define IDH_CERTVIEW_DETAILS_ITEM_EDIT              118

#define IDH_CERTVIEW_HIERARCHY_TRUST_TREE           120
#define IDH_CERTVIEW_HIERARCHY_SHOW_DETAILS_BUTTON  121
#define IDH_CERTVIEW_HIERARCHY_ERROR_EDIT           122

#define IDH_CTLVIEW_GENERAL_ITEM_LIST               125
#define IDH_CTLVIEW_GENERAL_ITEM_EDIT               126
#define IDH_CTLVIEW_GENERAL_VIEWSIGNATURE_BUTTON    127

#define IDH_CTLVIEW_TRUSTLIST_CERTIFICATE_LIST      130
#define IDH_CTLVIEW_TRUSTLIST_CERTVALUE_LIST        131
#define IDH_CTLVIEW_TRUSTLIST_VALUE_DETAIL_EDIT     132
#define IDH_CTLVIEW_TRUSTLIST_VIEWCERT_BUTTON       133

#define IDH_CRLVIEW_GENERAL_ITEM_LIST               135
#define IDH_CRLVIEW_GENERAL_ITEM_EDIT               136

#define IDH_CRLVIEW_REVOCATIONLIST_REVOCATION_LIST  140
#define IDH_CRLVIEW_REVOCATIONLIST_LIST_ENTRY       141
#define IDH_CRLVIEW_REVOCATIONLIST_LIST_ENTRY_DETAIL 142

#define IDH_CERTPROPERTIES_CERTIFICATENAME          145
#define IDH_CERTPROPERTIES_DESCRIPTION              146
#define IDH_CERTPROPERTIES_USAGE_LIST               147
#define IDH_CERTPROPERTIES_ADDPURPOSE_BUTTON        148
#define IDH_CERTPROPERTIES_ENABLE_ALL_RADIO         260
#define IDH_CERTPROPERTIES_DISABLE_ALL_RADIO        261
#define IDH_CERTPROPERTIES_ENABLE_CUSTOM_RADIO      262


#define IDH_SIGNERINFO_GENERAL_SIGNERNAME           150
#define IDH_SIGNERINFO_GENERAL_SIGNEREMAIL          151
#define IDH_SIGNERINFO_GENERAL_SIGNETIME            152
#define IDH_SIGNERINFO_GENERAL_VIEW_CERTIFICATE     153
#define IDH_SIGNERINFO_GENERAL_COUNTERSIG_LIST      154
#define IDH_SIGNERINFO_GENERAL_COUNTERSIG_DETAILS   155

#define IDH_SIGNERINFO_ADVANCED_DETAIL_LIST         160
#define IDH_SIGNERINFO_ADVANCED_DETAIL_EDIT         161

#define IDH_SELECTSTORE_STORE_TREE                  167
#define IDH_SELECTSTORE_SHOWPHYSICAL_CHECK          168

#define IDH_SELECTCERTIFICATE_VIEWCERT_BUTTON       172
#define IDH_SELECTCERTIFICATE_CERTIFICATE_LIST      173

#define IDH_CATALOGVIEW_GENERAL_ITEM_LIST           175
#define IDH_CATALOGVIEW_GENERAL_ITEM_EDIT           176
#define IDH_CATALOGVIEW_GENERAL_VIEWSIGNATURE_BUTTON 177

#define IDH_CATALOG_ENTRY_LIST                      180
#define IDH_CATALOG_ENTRY_DETAILS                   181
#define IDH_CATALOG_ENTRY_DETAIL_DISPLAY            182

// DSIE: followings are for Cross Certificate dialog page.
#define IDH_CHECKFORNEWCERTS_CHECK                  190
#define IDH_NUMBEROFUNITS_EDIT                      191
#define IDH_UNITS_COMBO                             192
#define IDH_USE_DEFAULT_BUTTON                      193
#define IDH_ADDURL_BUTTON                           194
#define IDH_NEWURL_EDIT                             195
#define IDH_URL_LIST                                196
#define IDH_REMOVEURL_BUTTON                        197

//the following is the help for CertMgr window.
//reserve # from 200-250                                                    
#define IDH_CERTMGR_LIST                            220
#define IDH_CERTMGR_PURPOSE_COMBO                   221
#define IDH_CERTMGR_IMPORT                          223
#define IDH_CERTMGR_EXPORT                          224
#define IDH_CERTMGR_VIEW                            225
#define IDH_CERTMGR_REMOVE                          226
#define IDH_CERTMGR_ADVANCE                         227

#define IDH_CERTMGR_ADV_LIST                        240
#define IDH_CERTMGR_EXPORT_COMBO                    241
#define IDH_CERTMGR_EXPORT_CHECK                    242
#define IDH_SELCA_LIST                              247

#define IDH_CERTMGR_FIELD_PURPOSE                   252

#define IDH_DIGSIG_PROPSHEET_LIST                   270
#define IDH_DIGSIG_PROPSHEET_DETAIL                 271
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\signcde.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       signcde.h
//
//--------------------------------------------------------------------------

#ifndef _SIGNCDE_H
#define _SIGNCDE_H

// OBSOLETE :- Split up, moved to mssip32.h, mscat.h, gentrust.h and authcode.h
//---------------------------------------------------------------------
//---------------------------------------------------------------------


// SignCode.h : main header file for the SIGNCODE application
//

#include "wincrypt.h"

#include  "wintrust.h"
#include  "signutil.h"

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////
// OID's used for SPC
//   

//+-------------------------------------------------------------------------
// Structures types for CryptEncodeObject() and CryptDecodeObject()
//  ( see spc.h for addtional structures and information )
//+-------------------------------------------------------------------------
//  SPC_CERT_EXTENSIONS_OBJID
//
//  Since the type of this attribute value is CERT_EXTENSIONS, uses the
//  CERT_EXTENSIONS data structure defined in wincrypt.h. It can be encoded/decoded
//  using the the predefined lpszStructType of X509_EXTENSIONS.
//+-------------------------------------------------------------------------
//  SPC_MINIMAL_CRITERIA_STRUCT
//
//  pvStructInfo points to BOOL
//+-------------------------------------------------------------------------
#define SPC_COMMON_NAME_OBJID               szOID_COMMON_NAME
#define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#define SPC_RAW_FILE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.18"
#define SPC_STRUCTURED_STORAGE_DATA_OBJID   "1.3.6.1.4.1.311.2.1.19"
#define SPC_JAVA_CLASS_DATA_OBJID           "1.3.6.1.4.1.311.2.1.20"
#define SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.21"
#define SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.22"
#define SPC_CAB_DATA_OBJID                  "1.3.6.1.4.1.311.2.1.25"
#define SPC_GLUE_RDN_OBJID                  "1.3.6.1.4.1.311.2.1.25" // Duplicate number??
// Structure passed in and out is CryptoGraphicTimeStamp


//+-------------------------------------------------------------------------
//  SPC X.509 v3 Certificate Extension Object Identifiers
//
//  SPC certificates can also contain the following extensions
//  defined in wincrypt.h:
//      szOID_KEY_USAGE_RESTRICTION     "2.5.29.4"
//      szOID_BASIC_CONSTRAINTS         "2.5.29.10"
//      szOID_AUTHORITY_KEY_IDENTIFIER  "2.5.29.1"
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  SPC_COMMON_NAME_OBJID
//
//  Since the type of the common name extension is a CERT_NAME_VALUE
//  uses the CERT_NAME_VALUE data structure defined in wincrypt.h.
//  It can be encoded/decoded using the the predefined lpszStructType of
//  X509_NAME_VALUE.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  SPC Indirect Data Content Data Attribute Values:
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  List of SPC Indirect Data Content Data Attribute Values are:
//      SPC_PE_IMAGE_DATA_OBJID
//      SPC_RAW_FILE_DATA_OBJID
//      SPC_JAVA_CLASS_DATA_OBJID
//      SPC_STRUCTURED_STORAGE_DATA_OBJID
//      SPC_CAB_DATA_OBJID
//  
//  These are the values can be currently added to SPC_INDIRECT_DATA_CONTENT
//  Data field.
//
//  SPC_LINK value types.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\sgnerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sgnerror.h
//
//--------------------------------------------------------------------------

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: SPC_BAD_PARAMETER
//
// MessageText:
//
//  Bad parameter for spc utility
//
#define SPC_BAD_PARAMETER                0x80096001L

//
// MessageId: SPC_BAD_LENGTH
//
// MessageText:
//
//  Bad length for data
//
#define SPC_BAD_LENGTH                   0x80096002L

//
// MessageId: SPC_BAD_CONTENT_DATA_ATTR
//
// MessageText:
//
//  SPC Message contained corrupted content
//
#define SPC_BAD_CONTENT_DATA_ATTR        0x80096003L

//
// MessageId: SPC_BAD_INDIRECT_CONTENT_TYPE
//
// MessageText:
//
//  SPC Message did not contain indirect data type
//
#define SPC_BAD_INDIRECT_CONTENT_TYPE    0x80096004L

//
// MessageId: SPC_UNEXPECTED_MSG_TYPE
//
// MessageText:
//
//  Message contains an unexpected content type
//
#define SPC_UNEXPECTED_MSG_TYPE          0x80096005L

//
// MessageId: SPC_NOT_JAVA_CLASS_FILE
//
// MessageText:
//
//  File is not a java class file
//
#define SPC_NOT_JAVA_CLASS_FILE          0x80096006L

//
// MessageId: SPC_BAD_JAVA_CLASS_FILE
//
// MessageText:
//
//  File is a corrupted java class file
//
#define SPC_BAD_JAVA_CLASS_FILE          0x80096007L

//
// MessageId: SPC_BAD_STRUCTURED_STORAGE
//
// MessageText:
//
//  Structured file is corrupted
//
#define SPC_BAD_STRUCTURED_STORAGE       0x80096008L

//
// MessageId: SPC_BAD_CAB_FILE
//
// MessageText:
//
//  File is a corrupted CAB file
//
#define SPC_BAD_CAB_FILE                 0x80096009L

//
// MessageId: SPC_NO_SIGNED_DATA_IN_FILE
//
// MessageText:
//
//  No signed message was found in file
//
#define SPC_NO_SIGNED_DATA_IN_FILE       0x8009600AL

//
// MessageId: SPC_REVOCATION_OFFLINE
//
// MessageText:
//
//  Could not connect to online revocation server.
//
#define SPC_REVOCATION_OFFLINE           0x8009600BL

//
// MessageId: SPC_REVOCATION_ERROR
//
// MessageText:
//
//  An error occured while accessing online revocation server.
//
#define SPC_REVOCATION_ERROR             0x8009600CL

//
// MessageId: SPC_CERT_REVOKED
//
// MessageText:
//
//  Signing certificate or issuing certifcate has been revoked.
//
#define SPC_CERT_REVOKED                 0x8009600DL

//
// MessageId: SPC_NO_SIGNATURE
//
// MessageText:
//
//  AUTHENTICODE signature not found.
//
#define SPC_NO_SIGNATURE                 0x8009600EL

//
// MessageId: SPC_BAD_SIGNATURE
//
// MessageText:
//
//  The signature does not match the content of the signed message.
//
#define SPC_BAD_SIGNATURE                0x8009600FL

//
// MessageId: SPC_BAD_FILE_DIGEST
//
// MessageText:
//
//  Software does not match contents of signature.
//
#define SPC_BAD_FILE_DIGEST              0x80096010L

//
// MessageId: SPC_NO_VALID_SIGNER
//
// MessageText:
//
//  Signature does not contain a valid signing certifcate.
//
#define SPC_NO_VALID_SIGNER              0x80096011L

//
// MessageId: SPC_CERT_EXPIRED
//
// MessageText:
//
//  A certificate (signing or issuer) has expired.
//
#define SPC_CERT_EXPIRED                 0x80096012L

//
// MessageId: SPC_NO_SIGNER_ROOT
//
// MessageText:
//
//  The signing certificate did not have a valid root certificate.
//
#define SPC_NO_SIGNER_ROOT               0x80096013L

//
// MessageId: SPC_NO_STATEMENT_TYPE
//
// MessageText:
//
//  Signing certificate does not contain AUTHENTICODE extensions.
//
#define SPC_NO_STATEMENT_TYPE            0x80096014L

//
// MessageId: SPC_NO_COMMERCIAL_TYPE
//
// MessageText:
//
//  No commercial or individual setting in signing certificate.
//
#define SPC_NO_COMMERCIAL_TYPE           0x80096015L

//
// MessageId: SPC_INVALID_CERT_NESTING
//
// MessageText:
//
//  Signing certificate's starting or ending time is outside one of its issuers starting or ending time.
//
#define SPC_INVALID_CERT_NESTING         0x80096016L

//
// MessageId: SPC_INVALID_ISSUER
//
// MessageText:
//
//  Wrong issuing Certificate used to verify a certificate.
//
#define SPC_INVALID_ISSUER               0x80096017L

//
// MessageId: SPC_INVALID_PURPOSE
//
// MessageText:
//
//  A purpose specified in a certificate (signing or issuer) makes it invalid for AUTHENTICODE.
//
#define SPC_INVALID_PURPOSE              0x80096018L

//
// MessageId: SPC_INVALID_BASIC_CONSTRAINTS
//
// MessageText:
//
//  A basic contraint of a certificate in the signature failed for AUTHENTICODE.
//
#define SPC_INVALID_BASIC_CONSTRAINTS    0x80096019L

//
// MessageId: SPC_UNSUPPORTED_BASIC_CONSTRAINTS
//
// MessageText:
//
//  Unsupported basic contraint found in a certificate used by the signature.
//
#define SPC_UNSUPPORTED_BASIC_CONSTRAINTS 0x8009601AL

//
// MessageId: SPC_NO_OPUS_INFO
//
// MessageText:
//
//  No opus information provided for the signing certificate.
//
#define SPC_NO_OPUS_INFO                 0x8009601BL

//
// MessageId: SPC_INVALID_CERT_TIME
//
// MessageText:
//
//  The date for the signing certificate is not valid.
//
#define SPC_INVALID_CERT_TIME            0x8009601CL

//
// MessageId: SPC_UNTRUSTED_TIMESTAMP_ROOT
//
// MessageText:
//
//  The test root is not trusted as the time stamp root.
//
#define SPC_UNTRUSTED_TIMESTAMP_ROOT     0x8009601DL

//
// MessageId: SPC_INVALID_FINANCIAL
//
// MessageText:
//
//  Certificate does not contain AUTHENTICODE financial extension.
//
#define SPC_INVALID_FINANCIAL            0x8009601EL

//
// MessageId: SPC_NO_AUTHORITY_KEYID
//
// MessageText:
//
//  No authority key id extension in certificate.
//
#define SPC_NO_AUTHORITY_KEYID           0x8009601FL

//
// MessageId: SPC_INVALID_EXTENSION
//
// MessageText:
//
//  The extension in a certificate means the certificate can not be used for AUTHENTICODE.
//
#define SPC_INVALID_EXTENSION            0x80096020L

//
// MessageId: SPC_CERT_SIGNATURE
//
// MessageText:
//
//  Certificate signature could not be verified using issuers certificate.
//
#define SPC_CERT_SIGNATURE               0x80096021L

//
// MessageId: SPC_CHAINING
//
// MessageText:
//
//  Unable to create certificate chain from the signing certificate to a root.
//
#define SPC_CHAINING                     0x80096022L

//
// MessageId: SPC_UNTRUSTED
//
// MessageText:
//
//  Signature is not trusted by AUTHENTICODE.
//
#define SPC_UNTRUSTED                    0x80096023L

//
// MessageId: SPC_SAFETY_LEVEL_UNTRUSTED
//
// MessageText:
//
//  Signature is not trusted by AUTHENTICODE at this safety level.
//
#define SPC_SAFETY_LEVEL_UNTRUSTED       0x80096024L

//
// MessageId: SPC_UNTRUSTED_ROOT
//
// MessageText:
//
//  The test root is has not been enabled as a trusted root.
//
#define SPC_UNTRUSTED_ROOT               0x80096025L

//
// MessageId: SPC_UNKNOWN_SIGNER_ROOT
//
// MessageText:
//
//  Verified chain to an unknown root certificate.
//
#define SPC_UNKNOWN_SIGNER_ROOT          0x80096026L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\signdll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       signdll.h
//
//--------------------------------------------------------------------------

#ifndef _SIGNDLL2_H
#define _SIGNDLL2_H

// SignCode.h : main header file for the SIGNCODE application
//

#include "spc.h"

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI 
    SignCode(IN  HWND    hwnd,
             IN  LPCWSTR pwszFilename,       // file to sign
             IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
             IN  DWORD   dwProviderType,
             IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
             IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
             IN  LPCWSTR pwszOpusName,       // the name of the program to appear in
             // the UI
             IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more
             // info...
             IN  BOOL    fIncludeCerts,
             IN  BOOL    fCommercial,
             IN  BOOL    fIndividual,
             IN  ALG_ID  algidHash,
             IN  PBYTE   pbTimeStamp,      // Optional
             IN  DWORD   cbTimeStamp );    // Optional

HRESULT WINAPI 
    TimeStampCode32(IN  HWND    hwnd,
                    IN  LPCWSTR pwszFilename,       // file to sign
                    IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
                    IN  DWORD   dwProviderType,
                    IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
                    IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
                    IN  LPCWSTR pwszOpusName,       // the name of the program to appear in the UI
                    IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more info...
                    IN  BOOL    fIncludeCerts,
                    IN  BOOL    fCommercial,
                    IN  BOOL    fIndividual,
                    IN  ALG_ID  algidHash,
                    OUT PBYTE pbTimeRequest,
                    IN OUT DWORD* cbTimeRequest);

HRESULT WINAPI 
    TimeStampCode(IN  HWND    hwnd,
                  IN  LPCWSTR pwszFilename,       // file to sign
                  IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
                  IN  DWORD   dwProviderType,
                  IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
                  IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
                  IN  LPCWSTR pwszOpusName,       // the name of the program to appear in the UI
                  IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more info...
                  IN  BOOL    fIncludeCerts,
                  IN  BOOL    fCommercial,
                  IN  BOOL    fIndividual,
                  IN  ALG_ID  algidHash,
                  IN  PCRYPT_DATA_BLOB sTimeRequest);   // Returns result in sTimeRequest 
// By default this will use CoTaskMemAlloc. Use CryptSetMemoryAlloc() to specify a different
// memory model.

//-------------------------------------------------------------------------
// Puts up a signing dialog
HRESULT WINAPI 
     SignWizard(HWND hwnd); 

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\spc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       spc.h
//
//  Contents:   Software Publishing Certificate (SPC) Prototypes and Definitions
//              
//              Defines a set of Win32 APIs specific to software publishing
//              for encoding and decoding X.509 v3 certificate extensions and
//              PKCS #7 signed message content and authenticated attributes.
//              Defines a PKCS #10 attribute containing X509 v3 extensions.
//
//              Defines a set of Win32 APIs for signing and verifying files
//              used in software publishing. The APIs have file processing
//              callbacks to accommodate any type of file. Direct support is
//              provided for: Portable Executable (PE) image, Java class,
//              structured storage and raw files.
//
//  APIs:
//              SpcGetSignedDataIndirect
//              SpcWriteSpcFile
//              SpcReadSpcFile
//              SpcWriteSpcToMemory
//              SpcReadSpcFromMemory
//              SpcSignPeImageFile
//              SpcVerifyPeImageFile
//              SpcSignJavaClassFile
//              SpcVerifyJavaClassFile
//              SpcSignStructuredStorageFile
//              SpcVerifyStructuredStorageFile
//              SpcSignRawFile
//              SpcVerifyRawFile
//              SpcSignCabFile
//              SpcVerifyCabFile
//              SpcSignFile
//              SpcVerifyFile
//
//  History:    15-Apr-96   philh   created
//--------------------------------------------------------------------------

#ifndef __SPC_H__
#define __SPC_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  SPC_SP_AGENCY_INFO_OBJID
//
//  All the fields in the Image and Info structures are optional. When
//  omitted, a pointer is NULL or a blob's cbData is 0.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  SPC_MINIMAL_CRITERIA_OBJID
//
//  Type of BOOL. Its set to TRUE if publisher meets minimal criteria.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  SPC_FINANCIAL_CRITERIA_OBJID
//--------------------------------------------------------------------------

//+=========================================================================
//
// SPC PKCS #7 Signed Message Content
//
//-=========================================================================

//+-------------------------------------------------------------------------
//  SPC PKCS #7 IndirectData ContentType Object Identifier
//--------------------------------------------------------------------------

//+=========================================================================
//
//  SPC Sign and Verify File APIs and Type Definitions
//
//  Following file types are directly supported:
//      Portable Executable (PE) Image
//      Java Class
//      Structured Storage
//      Raw (signed data is stored outside of the file)
//
//-=========================================================================


//+-------------------------------------------------------------------------
//  Callback to get and verify the software publisher's certificate.
//
//  Passed the CertId of the signer (its Issuer and SerialNumber), a
//  handle to a cert store containing certs and CRLs copied from
//  the signed message, the indirect data content attribute extracted from
//  the signed data's indirect content,
//  flag indicating if computed digest of the file matched the digest in the
//  signed data's indirect content and the signer's authenticated attributes.
//
//  If the file's signed data doesn't contain any content or signers, then,
//  called with pSignerId, pIndirectDataContentAttr and rgAuthnAttr == NULL.
//
//  For a valid signer certificate, returns SPC_VERIFY_SUCCESS and a pointer
//  to a read only CERT_CONTEXT. The returned CERT_CONTEXT is either obtained
//  from a cert store or was created via CertStoreCreateCert. For either case,
//  its freed via CertStoreFreeCert.
//
//  If this is the wrong signer or if a certificate wasn't found for the
//  signer, returns either
//  SPC_VERIFY_CONTINUE to continue on to the next signer or SPC_VERIFY_FAILED
//  to terminate the verification process.
//
//  The NULL implementation tries to get the Signer certificate from the
//  signed data's cert store. It doesn't verify the certificate.
//--------------------------------------------------------------------------
typedef int (WINAPI *PFN_SPC_VERIFY_SIGNER_POLICY)(
            IN void *pvVerifyArg,
            IN DWORD dwCertEncodingType,
            IN OPTIONAL PCERT_INFO pSignerId,   // Only the Issuer and
                                                // SerialNumber fields have
                                                // been updated
            IN HCERTSTORE hMsgCertStore,
            IN OPTIONAL PCRYPT_ATTRIBUTE_TYPE_VALUE pIndirectDataContentAttr,
            IN BOOL fDigestResult,
            IN DWORD cAuthnAttr,
            IN OPTIONAL PCRYPT_ATTRIBUTE rgAuthnAttr,
            IN DWORD cUnauthAttr,
            IN OPTIONAL PCRYPT_ATTRIBUTE rgUnauthAttr,
            IN DWORD cDigest,
            IN OPTIONAL PBYTE rgDigest,
            OUT PCCERT_CONTEXT *ppSignerCert
            );

#define SPC_VERIFY_SUCCESS      0
#define SPC_VERIFY_FAILED       -1
#define SPC_VERIFY_CONTINUE     1

//+-------------------------------------------------------------------------
//  The SPC_SIGN_PARA are used for signing files used in software publishing.
//  
//  Either the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID must
//  be set for pSigningCert. Either one specifies the private
//  signature key to use.
//
//  If any certificates and/or CRLs are to be included in the file's signed
//  data, then, the MsgCert and MsgCrl fields need to be updated. If the
//  rgpSigningCerts are to be included, then, they must also be in the
//  rgpMsgCert array.
//
//  If any authenticated attributes are to be included, then, the AuthnAttr
//  fields must be updated.
//--------------------------------------------------------------------------
typedef struct _SPC_SIGN_PARA {
    DWORD                         dwVersion;
    DWORD                         dwMsgAndCertEncodingType;
    PCCERT_CONTEXT                pSigningCert;
    CRYPT_ALGORITHM_IDENTIFIER    DigestAlgorithm;
    DWORD                         cMsgCert;
    PCCERT_CONTEXT                *rgpMsgCert;
    DWORD                         cMsgCrl;
    PCCRL_CONTEXT                 *rgpMsgCrl;
    DWORD                         cAuthnAttr;
    PCRYPT_ATTRIBUTE              rgAuthnAttr;
    DWORD                         cUnauthnAttr;
    PCRYPT_ATTRIBUTE              rgUnauthnAttr;
} SPC_SIGN_PARA, *PSPC_SIGN_PARA;

//+-------------------------------------------------------------------------
//  The SCA_VERIFY_PARA are used to verify files signed for software
//  publishing.
//
//  hCryptProv is used to do digesting and signature verification.
//
//  hMsgCertStore is the store to copy certificates and CRLs from the message
//  to. If hMsgCertStore is NULL, then, a temporary store is created before
//  calling the VerifySignerPolicy callback.
//
//  The dwMsgAndCertEncodingType specifies the encoding type of the certificates
//  and/or CRLs in the message.
//
//  pfnVerifySignerPolicy is called to verify the message signer's certificate.
//--------------------------------------------------------------------------
typedef struct _SPC_VERIFY_PARA {
    DWORD                           dwVersion;
    DWORD                           dwMsgAndCertEncodingType;
    HCRYPTPROV                      hCryptProv;
    HCERTSTORE                      hMsgCertStore;          // OPTIONAL
    PFN_SPC_VERIFY_SIGNER_POLICY    pfnVerifySignerPolicy;
    void                            *pvVerifyArg;
} SPC_VERIFY_PARA, *PSPC_VERIFY_PARA;


//+-------------------------------------------------------------------------
//  Sign / Verify Flags
//--------------------------------------------------------------------------
#define SPC_LENGTH_ONLY_FLAG                0x00000001
#define SPC_DISABLE_DIGEST_FILE_FLAG        0x00000002
#define SPC_DISABLE_VERIFY_SIGNATURE_FLAG   0x00000004
#define SPC_ADD_SIGNER_FLAG                 0x00000100
#define SPC_GET_SIGNATURE                   0x00000200

//+-------------------------------------------------------------------------
//  Put any certs/crl's into the store, and verify the SignedData's signature
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifySignedData(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN PBYTE pbSignedData,
    IN DWORD cbSignedData
    );

//+-------------------------------------------------------------------------
//  Table of functions called to support the signing and verifying of files
//  used in software publishing. The functions read the portions of the
//  file to be digested, store the signed data or retrieve the signed data.
//
//  pfnOpenSignFile is called with the pvSignFileArg passed to either
//  SpcSignFile() or SpcVerifyFile(). It returns a handle to be passed to the
//  other functions. pfnCloseSignFile is called to close the hSignFile.
//
//  pfnDigestSignFile reads the portions of the file to be digested and
//  calls pfnDigestData to do the actual digesting.
//
//  pfnSetSignedData stores the PKCS #7 Signed Data in the appropriate place
//  in the file. pfnGetSignedData retrieves the PKCS #7 Signed Data from the
//  file. pfnGetSignedData returns a pointer to its copy of the signed
//  data. Its not freed until pfnCloseSignFile is called.
//--------------------------------------------------------------------------

typedef void *HSPCDIGESTDATA;
typedef BOOL (WINAPI *PFN_SPC_DIGEST_DATA)(
            IN HSPCDIGESTDATA hDigestData,
            IN const BYTE *pbData,
            IN DWORD cbData
            );

typedef void *HSPCSIGNFILE;

typedef HSPCSIGNFILE (WINAPI *PFN_SPC_OPEN_SIGN_FILE)(
            IN void *pvSignFileArg
            );
typedef BOOL (WINAPI *PFN_SPC_CLOSE_SIGN_FILE)(
            IN HSPCSIGNFILE hSignFile
            );
typedef BOOL (WINAPI *PFN_SPC_DIGEST_SIGN_FILE)(
            IN HSPCSIGNFILE hSignFile,
            IN DWORD dwMsgAndCertEncodingType,
            IN PCRYPT_ATTRIBUTE_TYPE_VALUE pIndirectDataContentAttr,
            IN PFN_SPC_DIGEST_DATA pfnDigestData,
            IN HSPCDIGESTDATA hDigestData
            );
typedef BOOL (WINAPI *PFN_SPC_GET_SIGNED_DATA)(
            IN HSPCSIGNFILE hSignFile,
            OUT const BYTE **ppbSignedData,
            OUT DWORD *pcbSignedData
            );
typedef BOOL (WINAPI *PFN_SPC_SET_SIGNED_DATA)(
            IN HSPCSIGNFILE hSignFile,
            IN const BYTE *pbSignedData,
            IN DWORD cbSignedData
            );

typedef struct _SPC_SIGN_FILE_FUNC_TABLE {
    PFN_SPC_OPEN_SIGN_FILE      pfnOpenSignFile;
    PFN_SPC_CLOSE_SIGN_FILE     pfnCloseSignFile;
    PFN_SPC_DIGEST_SIGN_FILE    pfnDigestSignFile;
    PFN_SPC_GET_SIGNED_DATA     pfnGetSignedData;
    PFN_SPC_SET_SIGNED_DATA     pfnSetSignedData;
} SPC_SIGN_FILE_FUNC_TABLE, *PSPC_SIGN_FILE_FUNC_TABLE;
typedef const SPC_SIGN_FILE_FUNC_TABLE *PCSPC_SIGN_FILE_FUNC_TABLE;


//+-------------------------------------------------------------------------
//  Sign any type of file used for software publishing.
//
//  The IndirectDataContentAttr indicates the type of file being digested
//  and signed. It may have an optional value, such as, a link to the file.
//  Its stored with the file's digest algorithm and digest in the
//  indirect data content of the signed data.
//
//  The SPC_DISABLE_DIGEST_FLAG inhibits the digesting of the file.
//  The SPC_LENGTH_ONLY_FLAG implicitly sets the SPC_DISABLE_DIGEST_FLAG_FLAG 
//  and only calculates a length for the signed data.
//--------------------------------------------------------------------------
BOOL
WINAPI
    SpcSignFile(IN PSPC_SIGN_PARA pSignPara,
                IN PCSPC_SIGN_FILE_FUNC_TABLE pSignFileFuncTable,
                IN void *pvSignFileArg,
                IN PCRYPT_ATTRIBUTE_TYPE_VALUE pIndirectDataContentAttr,
                IN DWORD dwFlags,
                OUT PBYTE* pbEncoding,
                OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify any type of file signed for software publishing.
//
//  pVerifyPara's pfnVerifySignerPolicy is called to verify the signer's
//  certificate.
//
//  For a verified signer and file, *ppSignerCert is updated
//  with the CertContext of the signer. It must be freed by calling
//  CertStoreFreeCert. Otherwise, *ppSignerCert is set to NULL.
//  For *pbcbDecoded == 0 on input, *ppSignerCert is always set to
//  NULL.
//
//  ppSignerCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext of the signer.
//
//  If specified, the attribute type of the indirect data content in the
//  file's signed data is compared with pszDataAttrObjId.
//
//  The SPC_DISABLE_DIGEST_FLAG inhibits the digesting of the file.
//  The SPC_DISABLE_VERIFY_SIGNATURE_FLAG inhibits the verification of the
//  the signed data in the file. The SPC_LENGTH_ONLY_FLAG isn't allowed and
//  returns an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN PCSPC_SIGN_FILE_FUNC_TABLE pSignFileFuncTable,
    IN void *pvSignFileArg,
    IN OPTIONAL LPSTR pszDataAttrObjId,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  SPC error codes
//--------------------------------------------------------------------------
#include "sgnerror.h"

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\spcmem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       spcmem.h
//
//--------------------------------------------------------------------------

#ifndef _SPCMEM_H
#define _SPCMEM_H

#if defined(__cplusplus) && defined(TRYTHROW)
class PkiError {
public:

    PkiError(HRESULT err = E_UNEXPECTED)
    { pkiError = err; }

    HRESULT  pkiError;

};
#else
typedef struct _PkiError {
    HRESULT pkiError;
} PkiError;
#endif

#if defined(DBG) && defined(__cplusplus) && defined(TRYTHROW)
#define PKITRY       try
#define PKITHROW(x)  throw PkiError(x); //   
#define PKICATCH(x)  catch (PkiError x) 
#define PKIEND       //
#else
#define PKITRY       HRESULT _tpkiError; 
#define PKITHROW(x)  {_tpkiError = x; goto PKIERROR;} //
#define PKICATCH(x)  goto PKICONT; PKIERROR: { PkiError x; x.pkiError = _tpkiError; 
#define PKIEND       } PKICONT: //                                        
#endif


#ifdef __cplusplus
extern "C" {
#endif

// Internal memory manager for calls.
typedef LPVOID (WINAPI *AllocMem)(ULONG);
typedef VOID   (WINAPI *FreeMem)(LPVOID);

typedef struct _SpcAlloc {
    AllocMem Alloc;
    FreeMem  Free;
} SpcAlloc, *PSpcAlloc;

HRESULT WINAPI SpcInitializeStdAsn();  // Initialize to ASN and standard C allocators

#ifdef __cplusplus
}   /* extern "C" */
#endif 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\signer.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       signer.h
//
//  Contents:   Digital Signing APIs
//
//  History:    June-25-1997	Xiaohs    Created
//----------------------------------------------------------------------------

#ifndef SIGNER_H
#define SIGNER_H



#ifdef __cplusplus
extern "C" {
#endif	 

//-------------------------------------------------------------------------
//
//	Struct to define the file to sign and/or timestamp
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_FILE_INFO
{
	DWORD		cbSize;					//Required: should be set to sizeof(SIGNER_FILE_INFO)
	LPCWSTR		pwszFileName;			//Required: name of the file.  
    HANDLE      hFile;                  //Optional: open handle to pwszFileName. If hFile is set
										//			to values other than NULL or INVALID_HANDLE_VALUE,
										//			this handle is used for access the file	instead of pwszFileName
}SIGNER_FILE_INFO, *PSIGNER_FILE_INFO;


//-------------------------------------------------------------------------
//
//	Struct to define the BLOB to sign and/or timestamp
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_BLOB_INFO
{
	DWORD				cbSize;				//Required: should be set to sizeof(SIGNER_BLOB_INFO)
	GUID                *pGuidSubject;      //Required: Idenfity the sip functions to load
    DWORD               cbBlob;				//Required: the size of BLOB, in bytes
    BYTE                *pbBlob;			//Required: the pointer to the BLOB
    LPCWSTR             pwszDisplayName;    //Optional: the display name of the BLOB
}SIGNER_BLOB_INFO, *PSIGNER_BLOB_INFO;
			
//-------------------------------------------------------------------------
//
//	Struct to define the subject to sign and/or timestamp
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_SUBJECT_INFO
{
	DWORD					cbSize;				//Required: should be set to sizeof(SIGNER_SUBJECTINFO)
	DWORD					*pdwIndex;			//Required: 0 based index of the signature
                                                //          Currently, only 0 is supported
	DWORD					dwSubjectChoice;	//Required:	indicate whether to the subject is a file
												//			or a memory BLOB.  Can be either SIGNER_SUBJECT_FILE
												//			or SIGNER_SUBJECT_BLOB
	union
	{
		SIGNER_FILE_INFO	*pSignerFileInfo;	//Required if dwSubjectChoice==SIGNER_SUBJECT_FILE
		SIGNER_BLOB_INFO	*pSignerBlobInfo;	//Required if dwSubhectChoice==SIGNER_SUBJECT_BLOB
	};

}SIGNER_SUBJECT_INFO, *PSIGNER_SUBJECT_INFO;

#define	SIGNER_SUBJECT_FILE		0x01
#define	SIGNER_SUBJECT_BLOB		0x02

//-------------------------------------------------------------------------
//
//	Struct to define attributes of the signature for authenticode
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_ATTR_AUTHCODE
{
	DWORD				cbSize;			//Required: should be set to sizeof(SIGNER_ATTR_AUTHCODE)
	BOOL				fCommercial;	//Required:	whether to sign the document as a commercial publisher
	BOOL				fIndividual;	//Required: whether to sign the document as an individual publisher
										//			if both fCommercial and fIndividual are FALSE,
										//			the document will be signed with certificate's highest capabitlity
	LPCWSTR				pwszName;		//Optional: the display name of the file upon download time
	LPCWSTR				pwszInfo;		//Optional: the display information(URL) of the file upon download time
}SIGNER_ATTR_AUTHCODE, *PSIGNER_ATTR_AUTHCODE;


//-------------------------------------------------------------------------
//
//	Struct to define the signature information
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_SIGNATURE_INFO
{
	DWORD					cbSize;				//Required: should be set to sizeof(SIGNER_SIGNATURE_INFO)
	ALG_ID					algidHash;			//Required: the hashing algorithm for signature
	DWORD					dwAttrChoice;		//Required: indicate the predefined attributes of the signature
												//			can be either SIGNER_NO_ATTR or SIGNER_AUTHCODE_ATTR
	union
	{
		SIGNER_ATTR_AUTHCODE *pAttrAuthcode;	//Optional: should be set if dwAttrChoide==SIGNER_AUTHCODE_ATTR 
												//			pre-defined attributes added to the signature
												//			Those attributes are related to authenticode
	};

	PCRYPT_ATTRIBUTES		psAuthenticated;	//Optional: user supplied authenticated attributes added to the signature
	PCRYPT_ATTRIBUTES		psUnauthenticated;	//Optional:	user supplied unauthenticated attributes added to the signature
}SIGNER_SIGNATURE_INFO, *PSIGNER_SIGNATURE_INFO;

//dwAttrChoice should be one of the following:
#define  SIGNER_NO_ATTR			0x00
#define  SIGNER_AUTHCODE_ATTR	0x01

//-------------------------------------------------------------------------
//
//	Struct to define the cryptographic secutiry provider(CSP) and
//  private key information
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_PROVIDER_INFO
{
	DWORD					cbSize;				//Required: should be set of sizeof(SIGNER_PROVIDER_INFO)
	LPCWSTR					pwszProviderName;	//Required: the name of the CSP	provider.  NULL means default provider
	DWORD					dwProviderType;		//Required: the provider type.  
	DWORD					dwKeySpec;			//Required: the specification of the key.  This value can be set to 0,
												//        	which means using the same key specification as in the 
												//			private key file or keyContainer.  If there are more than
												//			one key specification in the keyContainer, we will try
												//			AT_SIGNATURE, if it fails, try AT_KEYEXCHANGE.
	DWORD					dwPvkChoice;		//Required: indicate the private key information
												//			either PVK_TYPE_FILE_NAME or PVK_TYPE_KEYCONTAINER
	union
	{
		LPWSTR				pwszPvkFileName;	//Required if dwPvkChoice==PVK_TYPE_FILE_NAME
		LPWSTR				pwszKeyContainer;	//Required if dwPvkChoice==PVK_TYPE_KEYCONTAINER
	};
	
}SIGNER_PROVIDER_INFO, *PSIGNER_PROVIDER_INFO;


//dwPvkChoice in SIGNER_PKV_INFO should be one of the following:
#define	PVK_TYPE_FILE_NAME				0x01
#define	PVK_TYPE_KEYCONTAINER			0x02

//-------------------------------------------------------------------------
//
//	Struct to define the SPC file and certificate chain used to sign the document
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_SPC_CHAIN_INFO
{
	DWORD					cbSize;					//Required: should be set to sizeof(SIGNER_SPC_CHAIN_INFO)
	LPCWSTR					pwszSpcFile;	        //Required: the name of the CSP file to use 
	DWORD					dwCertPolicy;			//Required:	the policy of adding certificates to the signature:
													//			it can be set with one of the following the following flag:
													//			SIGNER_CERT_POLICY_CHAIN:           add only the certs in the cert chain
													//			SIGNER_CERT_POLICY_CHAIN_NO_ROOT:   add only the certs in the cert chain, excluding the root certificate
                                                    //
                                                    //          The following flag can be Ored with any of the above flags:
													//			SIGNER_CERT_POLICY_STORE: add all the certs in hCertStore 
													//			
                                                    //          When we search for the certificate chain, we search
													//			MY, CA, ROOT, SPC store, and also hCertStore if it is set.
	HCERTSTORE				hCertStore;				//Optional: additional certificate store.
}SIGNER_SPC_CHAIN_INFO, *PSIGNER_SPC_CHAIN_INFO;

//-------------------------------------------------------------------------
//
//	Struct to define the certificate store used to sign the document
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_CERT_STORE_INFO
{
	DWORD					cbSize;					//Required: should be set to sizeof(SIGNER_CERT_STORE_INFO)
	PCCERT_CONTEXT			pSigningCert;			//Required: the signing certificate context
	DWORD					dwCertPolicy;			//Required:	the policy of adding certificates to the signature:
													//			it can be set with one of the following the following flag:
													//			SIGNER_CERT_POLICY_CHAIN:           add only the certs in the cert chain
													//			SIGNER_CERT_POLICY_CHAIN_NO_ROOT:   add only the certs in the cert chain, excluding the root certificate
                                                    //
                                                    //          The following flag can be Ored with any of the above flags:
													//			SIGNER_CERT_POLICY_STORE: add all the certs in hCertStore 
													//			
	HCERTSTORE				hCertStore;				//Optional: additional certificate store.
}SIGNER_CERT_STORE_INFO, *PSIGNER_CERT_STORE_INFO;

//dwCertPolicy in SIGNER_CERT_STORE_INFO should be ORed with the following flags:
#define	SIGNER_CERT_POLICY_STORE			0x01
#define	SIGNER_CERT_POLICY_CHAIN			0x02
#define	SIGNER_CERT_POLICY_SPC				0x04
#define SIGNER_CERT_POLICY_CHAIN_NO_ROOT    0x08

//-------------------------------------------------------------------------
//
//	Struct to define the certificate used to sign the docuemnt.  The
//	certificate can be in a SPC file, or in a cert store.
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_CERT
{
	DWORD						cbSize;			 //Required: should be set to sizeof(SIGNER_CERT)
	DWORD						dwCertChoice;	 //Required: Can be set to one of the following:
                                                 //         SIGNER_CERT_SPC_FILE 
                                                 //         SIGNER_CERT_STORE 
                                                 //         SIGNER_CERT_SPC_CHAIN
	union
	{
		LPCWSTR					pwszSpcFile;	 //Required if dwCertChoice==SIGNER_CERT_SPC_FILE.
												 //			the name of the spc file to use
		SIGNER_CERT_STORE_INFO	*pCertStoreInfo; //Required if dwCertChoice==SIGNER_CERT_STORE
												 //          the certificate store to use
        SIGNER_SPC_CHAIN_INFO   *pSpcChainInfo;  //Required if dwCertChoice==SIGNER_CERT_SPC_CHAIN
                                                 //         the name of the spc file and the cert chain
	};
	HWND						hwnd;			 //Optional: The optional window handler for promting user for 
												 //			 password of the private key information.  NULL means
												 //			 default window
}SIGNER_CERT, *PSIGNER_CERT;

//dwCertChoice in SIGNER_CERT_INFO should be one of the following
#define	SIGNER_CERT_SPC_FILE	0x01
#define	SIGNER_CERT_STORE		0x02
#define SIGNER_CERT_SPC_CHAIN   0x03

//-------------------------------------------------------------------------
//
//	The signed blob
//
//-------------------------------------------------------------------------
typedef struct  _SIGNER_CONTEXT
{
    DWORD                       cbSize;         
    DWORD                       cbBlob;
    BYTE                        *pbBlob;
}SIGNER_CONTEXT, *PSIGNER_CONTEXT;

//+-----------------------------------------------------------------------
//  
//  SignerSign:
//		Sign and/or timestamp a file.
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
SignerSign(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be signed and/or timestamped 
IN	SIGNER_CERT				*pSignerCert,		//Required: The signing certificate to use
IN	SIGNER_SIGNATURE_INFO	*pSignatureInfo,	//Required: The signature information during signing process
IN	SIGNER_PROVIDER_INFO	*pProviderInfo,		//Optional:	The crypto security provider to use.
												//			This parameter has to be set unless
												//			certStoreInfo is set in *pSignerCert
												//			and the signing certificate has provider
												//			information associated with it
IN  LPCWSTR					pwszHttpTimeStamp,	//Optional: Timestamp server http address.  If this parameter
												//			is set, the file will be timestamped.
IN  PCRYPT_ATTRIBUTES		psRequest,			//Optional: Attributes added to Time stamp request. Ignored
												//			unless pwszHttpTimeStamp is set   
IN	LPVOID					pSipData			//Optional: The additional data passed to sip funcitons
);									

//+-----------------------------------------------------------------------
//  
//  SignerSignEx:
//		Sign and/or timestamp a file.  This function is the same as SignerSign with
//      exception of the out put parameter ppSignerContext
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
SignerSignEx(
IN  DWORD                   dwFlags,            //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be signed and/or timestamped 
IN	SIGNER_CERT				*pSignerCert,		//Required: The signing certificate to use
IN	SIGNER_SIGNATURE_INFO	*pSignatureInfo,	//Required: The signature information during signing process
IN	SIGNER_PROVIDER_INFO	*pProviderInfo,		//Optional:	The crypto security provider to use.
												//			This parameter has to be set unless
												//			certStoreInfo is set in *pSignerCert
												//			and the signing certificate has provider
												//			information associated with it
IN  LPCWSTR					pwszHttpTimeStamp,	//Optional: Timestamp server http address.  If this parameter
												//			is set, the file will be timestamped.
IN  PCRYPT_ATTRIBUTES		psRequest,			//Optional: Attributes added to Time stamp request. Ignored
												//			unless pwszHttpTimeStamp is set   
IN	LPVOID					pSipData,			//Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT          **ppSignerContext   //Optional: The signed BLOB.  User has to free
                                                //          the context via SignerFreeSignerContext
);									

//+-----------------------------------------------------------------------
//  
//  SignerFreeSignerContext:
//     
//------------------------------------------------------------------------
HRESULT WINAPI
SignerFreeSignerContext(
IN  SIGNER_CONTEXT          *pSignerContext     //Required: The signerContext to free
);


//+-----------------------------------------------------------------------
//  
//  SignerTimeStamp:
//		Timestamp a file.  
//     
//------------------------------------------------------------------------
HRESULT WINAPI 
SignerTimeStamp(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be timestamped 
IN  LPCWSTR					pwszHttpTimeStamp,	// Required: timestamp server HTTP address
IN  PCRYPT_ATTRIBUTES		psRequest,			// Optional, attributes added to the timestamp 
IN	LPVOID					pSipData			// Optional: The additional data passed to sip funcitons
);					

//+-----------------------------------------------------------------------
//  
//  SignerTimeStampEx:
//		Timestamp a file.  This function is the same as SignerTimeStamp with
//      exception of the out put parameter ppSignerContext
//     
//------------------------------------------------------------------------
HRESULT WINAPI 
SignerTimeStampEx(
IN  DWORD                   dwFlags,            //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be timestamped 
IN  LPCWSTR					pwszHttpTimeStamp,	// Required: timestamp server HTTP address
IN  PCRYPT_ATTRIBUTES		psRequest,			// Optional, attributes added to the timestamp 
IN	LPVOID					pSipData,			// Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT          **ppSignerContext   // Optional: The signed BLOB.  User has to free
                                                //          the context via SignerFreeSignerContext
);					


//+-----------------------------------------------------------------------
//  
//  SignerCreateTimeStampRequest:
//		Create a timestamp request for a file.
//
//		If pbTimestampRequest==NULL, *pcbTimeStampRequest is the size of 
//		the timestampRequest, in bytes.  
//     
//------------------------------------------------------------------------
HRESULT WINAPI 
SignerCreateTimeStampRequest(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject based on which to create a timestamp request 
IN  PCRYPT_ATTRIBUTES		psRequest,			// Optional: attributes added to Time stamp request 
IN	LPVOID					pSipData,			// Optional: The additional data passed to sip funcitons
OUT PBYTE					pbTimeStampRequest,	// Required: buffer to receive the timestamp request BLOB
IN OUT DWORD*				pcbTimeStampRequest	// Required: the number of bytes of the timestamp request BLOB
);


//+-----------------------------------------------------------------------
//  
//   SignerAddTimeStampResponse:
//		Add the timestamp response from the timestamp server to a signed file. 
//     
//------------------------------------------------------------------------

HRESULT WINAPI
SignerAddTimeStampResponse(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,			//Required: The subject to which the timestamp request should be added 
IN	PBYTE					pbTimeStampResponse,	//Required: the timestamp response BLOB
IN	DWORD					cbTimeStampResponse,	//Required: the size of the tiemstamp response BLOB
IN	LPVOID					pSipData				//Optional: The additional data passed to sip funcitons
);


//+-----------------------------------------------------------------------
//  
//   SignerAddTimeStampResponseEx:
//		Add the timestamp response from the timestamp server to a signed file. 
//      This function is the same as SignerTimeStamp with
//      exception of the out put parameter ppSignerContext
//------------------------------------------------------------------------

HRESULT WINAPI
SignerAddTimeStampResponseEx(
IN  DWORD                   dwFlags,                //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,			//Required: The subject to which the timestamp request should be added 
IN	PBYTE					pbTimeStampResponse,	//Required: the timestamp response BLOB
IN	DWORD					cbTimeStampResponse,	//Required: the size of the tiemstamp response BLOB
IN	LPVOID					pSipData,				//Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT          **ppSignerContext       // Optional: The signed BLOB.  User has to free
                                                    //          the context via SignerFreeSignerContext
);


#ifdef __cplusplus
}
#endif

#endif  // SIGNER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\signutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       signutil.h
//
//--------------------------------------------------------------------------

#ifndef _SIGNUTIL_H
#define _SIGNUTIL_H

// OBSOLETE :- Was used for signcde.dll that is no longer required
//---------------------------------------------------------------------
//---------------------------------------------------------------------

// SignCode.h : main header file for the SIGNCODE application
//

#include "wincrypt.h"
#include "ossglobl.h"
#include "sgnerror.h"
#include "spcmem.h"
#include "pvkhlpr.h"
#include "spc.h"

#include "wintrust.h"
#include "sipbase.h"
#include "mssip.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//+-------------------------------------------------------------------------
//  SPC_TIME_STAMP_REQUEST_STRUCT (placed in PKCS#7 Content for a time request)
//  pvStructInfo points to SPC_TIMESTAMP_REQ 
//
typedef struct _SPC_ContentInfo {
    LPCSTR            pszContentType;
    PBYTE             pbContentValue;
    DWORD             cbContentValue;
} SPC_CONTENT_INFO, *PSPC_CONTENT_INFO;


typedef struct _SPC_TimeStampRequest {
    LPCSTR             pszTimeStampAlg;
    DWORD             cAuthAttr;
    PCRYPT_ATTRIBUTE  rgAuthAttr;
    SPC_CONTENT_INFO  sContent;
} SPC_TIMESTAMP_REQ, *PSPC_TIMESTAMP_REQ;
//
//+-------------------------------------------------------------------------


//+------------------------------------------------------------------------------
// Certificate List structures. Ordered list of Certificate contexts
//
typedef struct CERT_CONTEXTLIST {
    PCCERT_CONTEXT* psList;   // List
    DWORD           dwCount;  // Number of entries in list
    DWORD           dwList;   // Max size of list
} CERT_CONTEXTLIST, *PCERT_CONTEXTLIST;
    
typedef const CERT_CONTEXTLIST *PCCERT_CONTEXTLIST;
    
//+------------------------------------------------------------------------------
// Crl List structures. Ordered list of Certificate contexts
//
typedef struct CRL_CONTEXTLIST {
    PCCRL_CONTEXT*  psList;   // List
    DWORD           dwCount;  // Number of entries in list
    DWORD           dwList;   // Max size of list
} CRL_CONTEXTLIST, *PCRL_CONTEXTLIST;
    
typedef const CRL_CONTEXTLIST *PCCRL_CONTEXTLIST;
    

//+------------------------------------------------------------------------------
// Capi Provider information structure (see SpcGetCapiProviders)
//
typedef struct CAPIPROV
    {
    TCHAR       szProviderName[MAX_PATH];
    TCHAR       szProviderDisplayName[MAX_PATH];
    DWORD       dwProviderType;
    } CAPIPROV;

//+-------------------------------------------------------------------------
//+-------------------------------------------------------------------------
// Spc utility functions


//+-------------------------------------------------------------------------
//  Converts error (see GetLastError())  to an HRESULT
//--------------------------------------------------------------------------
HRESULT SpcError();

//+-------------------------------------------------------------------------
//  SPC PKCS #7 Indirect Data Content
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcGetSignedDataIndirect(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwMsgAndCertEncodingType,
    IN PBYTE pbSignedData,
    IN DWORD cbSignedData,
    OUT PSPC_INDIRECT_DATA_CONTENT pInfo,
    IN OUT DWORD *pcbInfo);

//+=========================================================================
//
// SPC PKCS #7 Signed Message Authenticated Attributes
//
//-=========================================================================

//+-------------------------------------------------------------------------
//  Create a SignedData message consisting of the certificates and
//  CRLs copied from the specified cert store and write to the specified file.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcWriteSpcFile(
    IN HANDLE hFile,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags);

//+-------------------------------------------------------------------------
//  Read a SignedData message consisting of certificates and
//  CRLs from the specified file and copy to the specified cert store.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcReadSpcFile(
    IN HANDLE hFile,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags);

//+-------------------------------------------------------------------------
//  Create a SignedData message consisting of the certificates and
//  CRLs copied from the specified cert store and write to memory
//
//  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
//  return an error.
//
//  Except for the SPC being saved to memory, identical to SpcWriteSpcFile.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcWriteSpcToMemory(
    IN HANDLE hFile,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData);

//+-------------------------------------------------------------------------
//  Read a SignedData message consisting of certificates and
//  CRLs from memory and copy to the specified cert store.
//
//  Except for the SPC being loaded from memory, identical to SpcReadSpcFile.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcReadSpcFromMemory(
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags);

//+-------------------------------------------------------------------------
//  By default (according to the world of BOB) the SignedData doesn't have
//  the normal PKCS #7 ContentType at the beginning. Set the following
//  flag in the SpcSign* and SpcWriteSpcFile functions to include the
//  PKCS #7 ContentType.
//
//  The SpcVerify* functions take SignedData with or without the PKCS #7
//  ContentType.
//--------------------------------------------------------------------------
#define SPC_PKCS_7_FLAG                     0x00010000

//+-------------------------------------------------------------------------
//  Sign Portable Executable (PE) image file where the signed data is stored
//  in the file.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_PE_IMAGE_DATA_OBJID and its optional value is set to the
//  PeImageData parameter.
//
//  The SPC_LENGTH_ONLY_FLAG or SPC_DISABLE_DIGEST_FILE_FLAG isn't allowed
//  and return an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignPeImageFile(IN PSPC_SIGN_PARA pSignPara,
                   IN HANDLE hFile,
                   IN OPTIONAL PSPC_PE_IMAGE_DATA pPeImageData,
                   IN DWORD dwFlags,
                   OUT PBYTE* pbEncoding,
                   OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify Portable Executable (PE) image file where the signed data is
//  extracted from the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyPeImageFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN HANDLE hFile,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert);

//+-------------------------------------------------------------------------
//  Sign Java class file where the signed data is stored in the file.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_JAVA_CLASS_DATA_OBJID and its optional value is set to the
//  Link parameter.
//
//  The SPC_LENGTH_ONLY_FLAG or SPC_DISABLE_DIGEST_FILE_FLAG isn't allowed
//  and return an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignJavaClassFile(IN PSPC_SIGN_PARA pSignPara,
                     IN HANDLE hFile,
                     IN OPTIONAL PSPC_LINK pLink,
                     IN DWORD dwFlags,
                     OUT PBYTE* pbEncoding,
                     OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify Java class file where the signed data is extracted from the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyJavaClassFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN HANDLE hFile,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert);

//+-------------------------------------------------------------------------
//  Sign Structured Storage file where the signed data is stored in the file.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_STRUCTURED_STORAGE_DATA_OBJID and its optional value is set to the
//  Link parameter.
//
//  The SPC_LENGTH_ONLY_FLAG or SPC_DISABLE_DIGEST_FILE_FLAG isn't allowed
//  and return an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignStructuredStorageFile(IN PSPC_SIGN_PARA pSignPara,
                             IN IStorage *pStg,
                             IN OPTIONAL PSPC_LINK pLink,
                             IN DWORD dwFlags,
                             OUT PBYTE* pbEncoding,
                             OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify Structured Storage file where the signed data is extracted
//  from the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyStructuredStorageFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN IStorage *pStg,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  Sign Raw file. The signed data is stored OUTSIDE of the file.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_RAW_FILE_DATA_OBJID and its optional value is set to the
//  Link parameter.
//
//  If pbSignedData == NULL or *pcbSignedData == 0, then, the
//  SPC_LENGTH_ONLY_FLAG and SPC_DISABLE_DIGEST_FILE_FLAG are implicitly set.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignRawFile(IN PSPC_SIGN_PARA pSignPara,
               IN HANDLE hFile,
               IN OPTIONAL PSPC_LINK pLink,
               IN DWORD dwFlags,
               OUT PBYTE *pbSignedData,
               IN OUT DWORD *pcbSignedData);

//+-------------------------------------------------------------------------
//  Verify Raw file. The signed data is stored OUTSIDE of the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyRawFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN HANDLE hFile,
    IN const BYTE *pbSignedData,
    IN DWORD cbSignedData,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  Sign Diamond Cabinet (.cab) file where the signed data is stored in the
//  the file's cabinet header reserved data space.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_CAB_DATA_OBJID and its optional value is set to the
//  Link parameter.
//
//  The SPC_LENGTH_ONLY_FLAG or SPC_DISABLE_DIGEST_FILE_FLAG isn't allowed
//  and return an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignCabFile(IN PSPC_SIGN_PARA pSignPara,
               IN HANDLE hFile,
               IN OPTIONAL PSPC_LINK pLink,
               IN DWORD dwFlags,
               OUT PBYTE* pbEncoding,
               OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify cabinet file where the signed data is extracted from the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyCabFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN HANDLE hFile,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert);

//+=========================================================================
//
//  SPC Sign and Verify File APIs and Type Definitions
//
//  Supports any file type via a table of functions for accessing the file.
//  The above file types have been implemented on top of these
//  sign and verify file APIs.
//
//-=========================================================================




//+-------------------------------------------------------------------------
// A convient way of setting up the SPC dll and loading the oid encode and decode
// routines.  Not a required call!
//
// Returns: 
//    E_OUTOFMEMORY - unable to set up dll
//    S_OK

HRESULT WINAPI 
SpcInitialize(DWORD dwEncodingType, // Defaults to X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
              SpcAlloc*);           // Defaults to no memory allocator

HRESULT WINAPI 
SpcInitializeStd(DWORD dwEncodingType); // Defaults to X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
                                        // Sets memory to LocalAlloc and LocalFree.

////////////////////////////////////
// Helper functions

/////////////////////////////////////////////////////////////////////////////
// Time Stamping structures
typedef struct _SPC_SignerInfo {
    DWORD                         dwVersion;
    CRYPT_INTEGER_BLOB            sSerialNumber;
    CERT_NAME_BLOB                sIssuer;
    PCRYPT_ALGORITHM_IDENTIFIER   psDigestEncryptionAlgorithm;
    PCRYPT_ALGORITHM_IDENTIFIER   psDigestAlgorithm;
    DWORD                         cAuthAttr;
    PCRYPT_ATTRIBUTE              rgAuthAttr;
    DWORD                         cUnauthAttr;
    PCRYPT_ATTRIBUTE              rgUnauthAttr;
    PBYTE                         pbEncryptedDigest;
    DWORD                         cbEncryptedDigest;
} SPC_SIGNER_INFO, *PSPC_SIGNER_INFO;

//+------------------------------------------------------------------------------
// Checks if the certificate is self signed. 
// Returns: S_FALSE                - certificate is not self signed
//          NTE_BAD_SIGNATURE      - self signed certificate but signature is invalid
//          S_OK                   - certificate is self signed and signature is valid
//          CRYPT_E_NO_PRVOIDER    - no provider supplied
//
HRESULT WINAPI
SpcSelfSignedCert(IN HCRYPTPROV hCryptProv,
                  IN PCCERT_CONTEXT pSubject);

//+-----------------------------------------------------------------------------------
//  Checks if the certificate is the Microsoft real root or one of the test roots used
//  in IE30
//  Returns: S_OK                   - For the Microsoft root
//           S_FALSE                - For the Microsoft test root
//           CRYPT_E_NOT_FOUND       - When it is not a root certificate
//
HRESULT WINAPI
SpcIsRootCert(PCCERT_CONTEXT pSubject);

//+---------------------------------------------------------------------------
//  Checks if the certificate a glue certificate
//  in IE30
//  Returns: S_OK                   - Is a glue certificate
//           S_FALSE                - Not a certificate
//           CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcIsGlueCert(IN PCCERT_CONTEXT pCert);

//+--------------------------------------------------------------------
// Gets the list of providers, pass in the address to a CAPIPROV
// structer and a long.
//  ppsList - Vector of CAPIPROV (free pointer using the SpcAllocator)
//  pdwEntries - number of entries in the vector.
//----------------------------------------------------------------------

HRESULT WINAPI 
SpcGetCapiProviders(CAPIPROV** ppsList, 
                    DWORD* pdwEntries);


//+-------------------------------------------------------------------
// Checks the certifcate chain based on trusted roots then on glue certs
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using trusted roots
//      CERT_E_EXPIRED - An issuing certificate was found but it was not currently valid
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcCheckTrustStore(IN HCRYPTPROV hCryptProv,
                   IN DWORD dwVerifyFlags,
                   IN OPTIONAL FILETIME*  pTimeStamp,
                   IN HCERTSTORE hCertStore,
                   IN PCCERT_CONTEXT pChild,
                   IN OPTIONAL PCCERT_CONTEXTLIST,
                   OUT PCCERT_CONTEXT* pRoot);

//+---------------------------------------------------------------------------
// Checks the certifcate by finding a glue certificate and walking that chain
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using store
//      CERT_E_EXPIRED - An issuing certificate was found but it was not currently valid
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcCheckGlueChain(IN HCRYPTPROV hCryptProv,
                  IN DWORD dwVerifyFlags,
                  IN OPTIONAL FILETIME*  pTimeStamp,
                  IN HCERTSTORE hCertStore,
                  IN OPTIONAL PCCERT_CONTEXTLIST pIssuers,
                  IN PCCERT_CONTEXT pChild);

//+-------------------------------------------------------------------
// Checks the certifcate chain based on trusted roots then on glue certs
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using trusted roots
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcCheckCertChain(IN HCRYPTPROV hCryptProv,
                  IN DWORD dwVerifyFlags,
                  IN OPTIONAL FILETIME* pTimeStamp,
                  IN HCERTSTORE hTrustedRoots,
                  IN HCERTSTORE hCertStore,
                  IN PCCERT_CONTEXT pChild,
                  IN OPTIONAL PCCERT_CONTEXTLIST hChainStore,
                  OUT PCCERT_CONTEXT* pRoot); 


//+--------------------------------------------------------------------------
// Sign a file, optional supply a timestamp. 
//
// Returns:
//
// NOTE: By default this will use CoTaskMemAlloc. Use CryptSetMemoryAlloc() to 
// specify a different memory model.
// NOTE: Time Stamp must be an encoded pkcs7 message.

HRESULT WINAPI 
SpcSignCode(IN  HWND    hwnd,
         IN  LPCWSTR pwszFilename,       // file to sign
         IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
         IN  DWORD   dwProviderType,     // Uses default if 0
         IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
         IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
         IN  LPCWSTR pwszOpusName,       // the name of the program to appear in
         IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more
         IN  BOOL    fIncludeCerts,      // add the certificates to the signature
         IN  BOOL    fCommercial,        // commerical signing
         IN  BOOL    fIndividual,        // individual signing
         IN  ALG_ID  algidHash,          // Algorithm id used to create digest
         IN  PBYTE   pbTimeStamp,        // Optional
         IN  DWORD   cbTimeStamp );      // Optional
    
//+--------------------------------------------------------------------------
// Create a time stamp request. It does not actually sign the file.
//
// Returns:
//
// NOTE: By default this will use CoTaskMemAlloc. Use CryptSetMemoryAlloc() to 
// specify a different memory model.

HRESULT WINAPI 
SpcTimeStampCode(IN  HWND    hwnd,
              IN  LPCWSTR pwszFilename,       // file to sign
              IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
              IN  DWORD   dwProviderType,
              IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
              IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
              IN  LPCWSTR pwszOpusName,       // the name of the program to appear in the UI
              IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more info...
              IN  BOOL    fIncludeCerts,
              IN  BOOL    fCommercial,
              IN  BOOL    fIndividual,
              IN  ALG_ID  algidHash,
              OUT  PCRYPT_DATA_BLOB sTimeRequest);   // Returns result in sTimeRequest 

//+-------------------------------------------------------------------------
//  Crack a PKCS7 message and builds an encoded response. Store should
//  contain all the required certificates to crack the incoming message
//  and build the out going message.
//  Input:
//      pbEncodedMsg - encoded time stamp request.
//      cbEncodedMsg - length of time stamp request.
//
//  Parameter Returns:
//      pbResponse - allocated response message containing the time stamp
//      cbResponse - length of response
//  Returns:
//      S_OK - everything worked
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
//      CRYPT_E_NO_MATCH - could not locate certificate in store
     
HRESULT WINAPI
SpcCreateTimeStampResponse(IN DWORD dwCertEncodingType,
                           IN HCRYPTPROV hSignProv,
                           IN HCERTSTORE hCertStore,
                           IN DWORD dwAlgId,
                           IN OPTIONAL FILETIME* pFileTime,
                           IN PBYTE pbEncodedMsg,
                           IN DWORD cbEncodedMsg,
                           OUT PBYTE* pbResponse,
                           OUT DWORD* cbResponse);


//+-------------------------------------------------------------------------
//  Creates PKCS7 message using the information supplied
//  Parameter Returns:
//      pbPkcs7 - allocated pkcs7 message containing the time stamp
//      cbPkcs7 - length of pkcs7
//  Returns:
//      S_OK - everything worked
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
     
HRESULT WINAPI
SpcCreatePkcs7(IN DWORD dwCertEncodingType,
              IN HCRYPTPROV hCryptProv,    // if Null it will get provider from signing certificate
              IN DWORD dwKeySpec,          // if 0 it will get signing key type from signing certificate
              IN PCCERT_CONTEXT pSigningCert,
              IN CRYPT_ALGORITHM_IDENTIFIER dwDigestAlgorithm,
              IN OPTIONAL PCCERT_CONTEXTLIST pCertList,
              IN OPTIONAL PCRL_CONTEXTLIST pCrlList,
              IN OPTIONAL PCRYPT_ATTRIBUTE rgAuthAttr,  
              IN OPTIONAL DWORD cAuthAttr,
              IN OPTIONAL PCRYPT_ATTRIBUTE rgUnauthAttr,
              IN OPTIONAL DWORD cUnauthAttr,
              IN LPCSTR pszContentType,
              IN PBYTE pbSignerData,
              IN DWORD cbSignerData,
              OUT PBYTE* pbPkcs7,
              OUT DWORD* pcbPkcs7);

//+--------------------------------------------------------------------------
// Retrieve the signature from an encoded PKCS7 message. 
// 
// Returns:
//
// Note: Returns the signature of the first signer.
    
HRESULT WINAPI
SpcGetSignature(IN PBYTE pbMessage,               // Pkcs7 Message
                IN DWORD cbMessage,               // length of Message
                OUT PCRYPT_DATA_BLOB);            // Signature returned.
    
//+--------------------------------------------------------------------------
// Returns the content value from within a timestamp request. 
// 
// Returns:
//     S_OK - Success
//
// Note:  By default this will use CoTaskMemAlloc. Use CryptSetMemoryAlloc() to specify 
//        a different allocation routine
    
HRESULT WINAPI
SpcGetTimeStampContent(IN PBYTE pbEncoding,               // Pkcs7 Message
                    IN DWORD cbEncoding,               // length of Message
                    OUT PCRYPT_DATA_BLOB pSig);        // Time Stamped Data 

//+--------------------------------------------------------------------------
// Returns: the type of file
// 
// Note: See defines for the type returned
DWORD WINAPI
SpcGetFileType(LPCWSTR pszFile);

#define SIGN_FILE_IMAGE 1
#define SIGN_FILE_JAVACLASS 2
#define SIGN_FILE_RAW 4
#define SIGN_FILE_CAB 8



//+---------------------------------------------------------------
//+---------------------------------------------------------------
// SignCode Internal OID's and structurs
// Global values
#define EMAIL_OID                  "1.2.840.113549.1.9.1"
// Not implemented
#define CONTENT_TYPE_OID           "1.2.840.113549.1.9.3"
// Uses a LPSTR
#define MESSAGE_DIGEST_OID         "1.2.840.113549.1.9.4"
// Not implemented
#define SIGNING_TIME_OID           "1.2.840.113549.1.9.5"
// Structure passed in and out is FILETIME
#define COUNTER_SIGNATURE_OID      "1.2.840.113549.1.9.6"
// Not implemented
#define DIRECTORY_STRING_OID       "2.5.4.4"
// Not implemented (see Printable and Wide versions below)


// OID functions
#define OID_BASE                           101
#define TIMESTAMP_REQUEST_SPCID            101
// Uses TimeStampRequest structure
#define WIDE_DIRECTORY_STRING_SPCID        102
// Structure is LPWSTR
#define PRINTABLE_DIRECTORY_STRING_SPCID   103
// Structure is LPSTR
#define IA5_STRING_SPCID                   104
// Structure is LPSTR
#define OCTET_STRING_SPCID                 105
// Structure is CRYPT_DATA_BLOB
#define CONTENT_INFO_SPCID                 106
// Structure is SPC_CONTENT_INFO
#define SIGNING_TIME_SPCID                 107
// Structure is a SPC_SIGNER_INFO
#define SIGNER_INFO_SPCID                  108
// Structure is a SPC_SIGNER_INFO
#define ATTRIBUTES_SPCID                   109
// Structure is a CMSG_ATTR 
#define OBJECTID_SPCID                     110
// Structure is a LPTSTR
#define CONTENT_TYPE_SPCID                 111
// Structure is a LPTSTR
#define ATTRIBUTE_TYPE_SPCID               112
// Structure is a CRYPT_ATTRIBUTE     

HRESULT WINAPI
SpcEncodeOid(IN  DWORD        dwAlgorithm,
             IN  const void  *pStructure,
             OUT PBYTE*       ppsEncoding,
             IN  OUT DWORD*   pdwEncoding);

HRESULT WINAPI
SpcDecodeOid(IN  DWORD       dwAlgorithm,
             IN  const PBYTE psEncoding,
             IN  DWORD       dwEncoding,
             IN  DWORD       dwFlags,
             OUT LPVOID*     ppStructure,
             IN OUT DWORD*   pdwStructure);


//+-------------------------------------------------------------------
// Pushes a certificate on the list, ONLY use SpcDeleteCertChain to free 
// up certificate list.
// Returns:
//      S_OK

HRESULT WINAPI 
SpcPushCertChain(IN PCCERT_CONTEXT pCert,
                 IN PCCERT_CONTEXTLIST pIssuer);


//+-------------------------------------------------------------------
// Frees up a list of cert contexts
// Returns:
//      S_OK

HRESULT WINAPI
SpcDeleteCertChain(IN PCCERT_CONTEXTLIST sIssuer);


//+--------------------------------------------------------------------------
// Creates a list of glue certs that apply to the pSubject. If the crypt memory
// allocator is set it will return a list that must be freed. (Returned memory
// is a vector so free just the returned pointer) If there is no allocator then 
// use the two pass win32 style. (NOTE: PCCERT_CONTEXTLIST must be supplied) 
//
// Parameter Returns:
//      pGlue - List of cert contexts that must be released. 
// 
// Returns:
//      S_OK                          - Created list
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
//      E_OUTOFMEMORY                 - Memory allocation error occured

HRESULT WINAPI
SpcFindGlueCerts(IN PCCERT_CONTEXT pSubject,
                 IN HCERTSTORE     hCertStore,
                 IN OUT PCCERT_CONTEXTLIST pGlue);


//+-------------------------------------------------------------------
// Locate the issuers in the trusted list. (NOTE: PCCERT_CONTEXTLIST must be supplied) 
// Parameter Returns:
//      pIssuerChain   - List of cert contexts that must be released.
//
// Returns:
//      S_OK           - Created list
//      E_OUTOFMEMORY  - Memory allocation error occured

                                              
HRESULT WINAPI
SpcLocateIssuers(IN DWORD dwVerifyFlags,
                 IN HCERTSTORE hCertStore,
                 IN PCCERT_CONTEXT item,
                 IN OUT PCCERT_CONTEXTLIST pIssuerChain);



//+-------------------------------------------------------------------------
//  Find the the cert from the hprov
//  Parameter Returns:
//      pReturnCert - context of the cert found (must pass in cert context);
//  Returns:
//      S_OK - everything worked
//      E_OUTOFMEMORY - memory failure
//      E_INVALIDARG - no pReturnCert supplied
//      CRYPT_E_NO_MATCH - could not locate certificate in store
//
     
HRESULT WINAPI
SpcGetCertFromKey(IN DWORD dwCertEncodingType,
                  IN HCERTSTORE hStore,
                  IN HCRYPTPROV hProv,
                  IN OUT PCCERT_CONTEXT* pReturnCert);


/*
//+-------------------------------------------------------------------------
//  Locates a certificate in the store that matches the public key
//  dictated by the HCRYPTPROV
//-=========================================================================
PCCERT_CONTEXT WINAPI
SpcFindCert(IN HCERTSTORE hStore,
            IN HCRYPTPROV hProv);
            */
//+-------------------------------------------------------------------
// Retrieves the a cert context from the store based on the issuer
// and serial number.
// Returns:
//      Cert context   - on success
//      NULL           - if no certificate existed or on Error
//    
/*
PCCERT_CONTEXT WINAPI
SpcFindCertWithIssuer(IN DWORD dwCertEncodingType,
                   IN HCERTSTORE hCertStore,
                   IN CERT_NAME_BLOB* psIssuer,
                   IN CRYPT_INTEGER_BLOB* psSerial);
                   */

//+-------------------------------------------------------------------------
//  Given a signing cert, a store with the certs chain, hashing algorithm,
//  and a time request structure it will return an encoded time stamp request 
//  message.
//  Parameter Returns:
//      pbEncoding - time stamp response (PKCS7 message)
//      cbEncoding - length of encoding
//  Returns:
//      S_OK - everything worked
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
     
HRESULT WINAPI
SpcBuildTimeStampResponse(IN HCRYPTPROV hCryptProv,
                          IN HCERTSTORE hCertStore,
                          IN PCCERT_CONTEXT pSigningCert,
                          IN ALG_ID  algidHash,
                          IN OPTIONAL FILETIME* pFileTime,
                          IN PSPC_TIMESTAMP_REQ psRequest,
                          OUT PBYTE* pbEncoding,
                          OUT DWORD* cbEncoding);


//+-------------------------------------------------------------------------
//  Encodes the current time
//  Parameter Returns:
//      pbEncodedTime - encoded time (current UTC time)
//      cbEncodedTime - length of encoding
//  Returns:
//      S_OK - everything worked
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
     
HRESULT WINAPI
SpcEncodeCurrentTime(OUT PBYTE* pbEncodedTime,
                     OUT DWORD* cbEncodedTime);



//+-------------------------------------------------------------------------
//  Crack a PKCS7 message returns the content and content type. Data is verified
//  
//  Parameter Returns:
//      pSignerCert - Context that was used to sign the certificate
//      ppbContent - the content of the message
//      pcbContent - the length
//      pOid       - the oid of the content (content type)
//  Returns:
//      S_OK - everything worked
//
//      CERT_E_NOT_FOUND - Cannot load certificate from encoded pkcs7 message
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
HRESULT WINAPI
SpcLoadData(IN HCRYPTPROV hCryptProv,
            IN PBYTE pbEncoding,
            IN DWORD cbEncoding,
            IN DWORD lSignerIndex, 
            OUT PCCERT_CONTEXT& pSignerCert,
            OUT PBYTE& pbContent,
            OUT DWORD& cbContent,
            OUT LPSTR& pOid);

//+-------------------------------------------------------------------------
//  Crack a PKCS7 message which contains a time request
//  Parameter Returns:
//      ppCertContext - returns contexts if pointer provided (optional)
//      ppbRequest - allocates a Time request structure (delete just the pointer)
//  Returns:
//      S_OK - everything worked
//
//      CERT_E_NOT_FOUND - Cannot load certificate from encoded pkcs7 message
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
HRESULT WINAPI
SpcLoadTimeStamp(IN HCRYPTPROV hCryptProv,
                 IN PBYTE pbEncoding,
                 IN DWORD cbEncoding,
                 OUT PCCERT_CONTEXT* ppCertContext, // Optional
                 OUT PSPC_TIMESTAMP_REQ* ppbRequest);


//+-------------------------------------------------------------------
// Verifies the certifcate chain based on glue certs
// Return Parameters:
//      pRoot          - Context to the root certificate of the chain
//                       (must be freed)
//      pIssuers       - Stores the chain in pIssuers if it is present
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified 
//      CERT_E_EXPIRED - An issuing certificate was found but it was not currently valid
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
    
HRESULT WINAPI
SpcVerifyCertChain(IN HCRYPTPROV hCryptProv,
                   IN DWORD dwVerifyFlags,
                   IN FILETIME*  pTimeStamp,
                   IN HCERTSTORE hCertStore,
                   IN PCCERT_CONTEXT pChild,
                   IN OUT OPTIONAL PCCERT_CONTEXTLIST pIssuers,
                   OUT PCCERT_CONTEXT* pRoot);

//+-------------------------------------------------------------------
// Checks the certifcate chain for a glue certificate
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using 
//      CERT_E_EXPIRED - An issuing certificate was found but it was not currently valid
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcVerifyGlueChain(IN DWORD dwVerifyFlags,
                   IN HCRYPTPROV hCryptProv,
                   IN OPTIONAL FILETIME*  pTimeStamp,
                   IN HCERTSTORE hCertStore,
                   IN OPTIONAL PCCERT_CONTEXTLIST pIssuers,
                   IN PCCERT_CONTEXT pChild);

//-------------------------------------------------------------------
// Retrieves the a cert context from the store based on the issuer
// and serial number. psIssuer and psSerial can be obtained from
// the SPC_CONTENT_INFO.
//
// Returns:
//      Cert context   - on success
//      NULL           - if no certificate existed or on Error (use SpcError() to retirieve HRESULT)
//    

PCCERT_CONTEXT WINAPI
SpcGetCertFromStore(IN DWORD dwCertEncodingType,
                    IN HCERTSTORE hCertStore,
                    IN CERT_NAME_BLOB* psIssuer,
                    IN CRYPT_INTEGER_BLOB* psSerial);

//+---------------------------------------------------------------------------
// Verifies the signer at the specified time. The psSignerInfo can be
// obtained be decoding and encoded signature using SIGNER_INFO_SPCID.
// Verify flags can be CERT_STORE_SIGNATURE_FLAG and/or CERT_STORE_REVOCATION_FLAG.
// If pTimeStamp is present the certificate must have been valid at that time
// Returns:
//      S_OK           - Time stamp was found and verified
//      S_FALSE        - Time stamp was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using tursted roots or certificate store 
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcVerifySignerInfo(IN DWORD dwCertEncodingType,
                    IN HCRYPTPROV hCryptProv,
                    IN DWORD dwVerifyFlags,
                    IN HCERTSTORE hTrustedRoots,
                    IN HCERTSTORE hCertStore,
                    IN PSPC_SIGNER_INFO psSignerInfo,
                    IN LPFILETIME pTimeStamp,
                    IN PSPC_CONTENT_INFO psData);

//+-------------------------------------------------------------------------------
// Verifies the encoded signature if there is a time stamp present. If there is no
// time stamp the CERT_E_NO_MATCH is returned. If there is a time stamp then the 
// certificate and ceritifcate chain is  verfified at that time.
//
// Verify flags can be CERT_STORE_SIGNATURE_FLAG and/or CERT_STORE_REVOCATION_FLAG.
//
// Parameter Returns:
//      psTime   - Filled in time, time is set to zero on error.
//
// Returns:
//      S_OK           - Time stamp was found and verified
//      S_FALSE        - Time stamp was found and verified to a test root
//      CERT_E_NO_MATCH - Unable to find time stamp in signer info
//      CERT_E_CHAINING - Could not be verified using trusted roots or certicate store
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcVerifyEncodedSigner(IN DWORD dwCertEncodingType,
                       IN HCRYPTPROV hCryptProv,
                       IN DWORD dwVerifyFlags,
                       IN HCERTSTORE hTrustedRoots,
                       IN HCERTSTORE hCertStore,
                       IN PBYTE psEncodedSigner,
                       IN DWORD dwEncodedSigner,
                       IN PSPC_CONTENT_INFO psData,
                       OUT FILETIME* pReturnTime);

//+-------------------------------------------------------------------
// Finds a counter signature attribute (OID: COUNTER_SIGNATURE_OID == 
// "1.2.840.113549.1.9.6"). The counter signature is then verified.
// (see CryptVerifySignerInfo)
// Parameter Returns:
//      psTime   - Filled in time, time is set to zero on error.
//
// Returns:
//      S_OK              - Time stamp was found and verified
//      S_FALSE           - Time stamp was found and verified to a test root
//      CRYPT_E_NO_MATCH  - Time stamp attribute could not be found
//
//      CERT_E_CHAINING   - Could not be verified using trusted roots or certicate store
//      E_OUTOFMEMORY     - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
    
    
HRESULT WINAPI
SpcVerifyTimeStampAttribute(IN DWORD dwCertEncodingType,
                            IN HCRYPTPROV hCryptProv,
                            IN DWORD dwVerifyFlags,
                            IN HCERTSTORE hTrustedRoots,
                            IN HCERTSTORE hCertStore,
                            IN PCRYPT_ATTRIBUTE psAttributes,
                            IN DWORD dwAttributes,
                            IN PSPC_CONTENT_INFO psData,
                            OUT FILETIME* pReturnTime);
    
//+-------------------------------------------------------------------------
// Cracks the SignerInfo out of the PKCS7 message and returns the encoded representation.
// Parameter Returns:
//  pbSignerData    - Encoded signer info from the message.
//  cbSignerData    - Length of the message
// Returns:
//  TRUE - Succeeded.
//  FALSE - Failed.
//

HRESULT WINAPI
SpcGetEncodedSigner(IN  DWORD dwMsgAndCertEncodingType,
                      IN  HCERTSTORE hMsgCertStore,
                      IN  PCCERT_CONTEXT  pSignerCert,
                      IN  PBYTE pbEncoding, 
                      IN  DWORD cbEncoding,
                      OUT PBYTE* pbSignerData,
                      OUT DWORD* cbSignerData);

//+-------------------------------------------------------------------------
//  Gets (and will set) the CERT_KEY_PROV_INFO_PROP_ID property for a cert
//  context.
//+--------------------------------------------------------------------------
HRESULT WINAPI
SpcGetCertKeyProv(IN PCCERT_CONTEXT pCert,
                    OUT HCRYPTPROV *phCryptProv,
                    OUT DWORD *pdwKeySpec,
                    OUT BOOL *pfDidCryptAcquire);

//+-------------------------------------------------------------------------
//  Returns TRUE if message is not wrapped in a 
//  ContentInfo.
//+--------------------------------------------------------------------------
BOOL WINAPI 
SpcNoContentWrap(IN const BYTE *pbDER,
                 IN DWORD cbDER);


//+-------------------------------------------------------------------------
// Retrieves the specified parameter from the Signature. The parameter is 
// allocated using the SPC allocation.
// 
// Parameter Returns:
//      pbData:  Allocated data
//      cbData:  size of data allocated
// Returns: 
//      S_OK            - Created parameter
//      E_OUTOFMEMORY   - Memory Allocation error
// 
//--------------------------------------------------------------------------

HRESULT SpcGetParam(IN HCRYPTMSG hMsg,
                    IN DWORD dwParamType,
                    IN DWORD dwIndex,
                    OUT PBYTE& pbData,
                    OUT DWORD& cbData);

//+-------------------------------------------------------------------------
// Retrieves the Signer Id from the Signature. The parameter is 
// allocated using the SPC allocation.
// 
// Returns: 
//      S_OK            - Created Signer id
//      E_OUTOFMEMORY   - Memory Allocation error
// 
//--------------------------------------------------------------------------

HRESULT SpcGetCertIdFromMsg(IN HCRYPTMSG hMsg,
                            IN DWORD dwIndex,
                            OUT PCERT_INFO& pSignerId);

//+-------------------------------------------------------------------------
//+-------------------------------------------------------------------------
//+-------------------------------------------------------------------------
//  Certificate and CRL encoding types 
//+--------------------------------------------------------------------------
#define CERT_OSS_ERROR          0x80093000


typedef HRESULT (*SpcEncodeFunction)(const SpcAlloc* pManager,
                                     const void*     pStructure,
                                     PBYTE&          psEncoding,
                                     DWORD&          dwEncoding);

typedef HRESULT (*SpcDecodeFunction)(const SpcAlloc* pManager,
                                     const PBYTE pEncoding,
                                     DWORD       dwEncoding,
                                     DWORD       dwFlags,
                                     LPVOID&     pStructure,
                                     DWORD&      dwStructure);

typedef struct _SPC_OidFuncEntry {
    SpcEncodeFunction pfEncode;
    SpcDecodeFunction pfDecode;
} SPC_OidFuncEntry;


// 
// Decode routines
// #define CRYPT_DECODE_NOCOPY_FLAG            0x1

HRESULT WINAPI 
SpcEncodeOid32(IN  DWORD        dwAlgorithm,
               IN  const void  *pStructure,
               OUT PBYTE        ppsEncoding,
               IN  OUT DWORD*   pdwEncoding);
// Win32 version of above function

HRESULT WINAPI
SpcDecodeOid32(IN  DWORD         dwAlgorithm,
               IN  const PBYTE   psEncoding,
               IN  DWORD         dwEncoding,
               IN  DWORD         dwFlags,
               OUT LPVOID        ppStructure,
               IN OUT DWORD*     pdwStructure);
// Win32 version of above function

//+-------------------------------------------------------------------
// Asn routines, Uses specified memory allocator or Win32 dual call
// if no allocator set.

typedef  OssGlobal  *POssGlobal;  

HRESULT WINAPI 
SpcASNEncode(IN const SpcAlloc* pManager,
             IN POssGlobal   pOssGlobal,
             IN DWORD        pdu, 
             IN const void*  sOssStructure,
             OUT PBYTE&      psEncoding,
             OUT DWORD&      dwEncoding);

HRESULT WINAPI
SpcASNDecode(IN POssGlobal     pOssGlobal,
             IN  DWORD         pdu, 
             IN  const PBYTE   psEncoding,
             IN  DWORD         dwEncoding,
             IN  DWORD         dwFlags,
             OUT LPVOID&       psStructure);

//+-------------------------------------------------------------------
// Memory Functions

HRESULT WINAPI
SpcSetMemoryAlloc(SpcAlloc& pAlloc);

const SpcAlloc* WINAPI
SpcGetMemoryAlloc();

BOOL WINAPI
SpcGetMemorySet();

BOOL WINAPI
SpcSetMemoryAllocState(BOOL state);

HRESULT WINAPI
SpcSetEncodingType(DWORD type);

HRESULT WINAPI
SpcGetEncodingType(DWORD* type);

//+-------------------------------------------------------------------
// Time Stamp functions

HRESULT WINAPI
SpcCompareTimeStamps(IN   PBYTE   psTime1,
                     IN   DWORD   dwTime1,
                     IN   PBYTE   psTime2,
                     IN   DWORD   dwTime2);

HRESULT WINAPI
SpcCreateTimeStampHash(IN HCRYPTPROV  hCryptProv,
                         IN DWORD dwAlgoCAPI,
                         IN PBYTE pbData,
                         IN DWORD cbData,
                         OUT HCRYPTHASH& hHash);

HRESULT WINAPI
SpcGetTimeStampHash(IN HCRYPTPROV  hCryptProv,
                      IN DWORD dwAlgoCAPI,
                      IN PBYTE pbData,
                      IN DWORD cbData,
                      OUT PBYTE& pbHashValue,
                      IN OUT DWORD& cbHashValue);

HRESULT WINAPI
SpcTimeStampHashContent(IN HCRYPTPROV  hCryptProv,
                          IN SPC_CONTENT_INFO& sContent,
                          IN SPC_SIGNER_INFO& sTimeStamp,
                          OUT PBYTE& pbHashValue,
                          IN OUT DWORD& cbHashValue);

HRESULT WINAPI
SpcVerifyTimeStampSignature(IN HCRYPTPROV    hCryptProv,
                         IN CERT_INFO&    sCertInfo,
                         IN SPC_SIGNER_INFO&  sTimeStamp);

HRESULT WINAPI
SpcVerifyTimeStampDigest(IN HCRYPTPROV  hCryptProv,
                      IN SPC_CONTENT_INFO& sContent,
                      IN SPC_SIGNER_INFO& sTimeStamp);

HRESULT WINAPI
SpcVerifyTimeStamp(IN HCRYPTPROV  hCryptProv,
                IN CERT_INFO&  sCertInfo,
                IN SPC_CONTENT_INFO& sContent,
                IN SPC_SIGNER_INFO& sTimeStamp);

HRESULT SpcError();


//+-------------------------------------------------------------------
// String functions

HRESULT WINAPI
SpcCopyPrintableString(const SpcAlloc* pManager, 
                    LPCSTR sz,
                    LPSTR& str,
                    DWORD& lgth);

BOOL WINAPI
SpcIsPrintableStringW(LPCWSTR wsz);

BOOL WINAPI
SpcIsPrintableString(LPCSTR sz);

HRESULT WINAPI
SpcWideToPrintableString(const SpcAlloc* psManager,
                      LPCWSTR wsz,
                      LPSTR& pString,
                      DWORD& dwString);

HRESULT WINAPI
SpcPrintableToWideString(const SpcAlloc* psManager,
                      LPCSTR sz,
                      LPWSTR& psString,
                      DWORD&  dwString);


HRESULT WINAPI
SpcBMPToWideString(const SpcAlloc* psManager,
                WORD*  pbStr, 
                DWORD   cbStr,
                LPWSTR& psString,
                DWORD&  dwString);

HRESULT WINAPI
SpcBMPToPrintableString(const SpcAlloc* psManager,
                     WORD*  pbStr, 
                     DWORD   cbStr,
                     LPSTR&  psString,
                     DWORD&  dwString);

HRESULT WINAPI
SpcUniversalToWideString(const SpcAlloc* psManager,
                      DWORD*  pbStr, 
                      USHORT  cbStr,
                      LPWSTR& psString,
                      DWORD&  dwString);

HRESULT WINAPI
SpcWideToUniversalString(const SpcAlloc* psManager,
                      LPWSTR  pSource, 
                      DWORD*  pString,
                      DWORD&  dwString);
HRESULT WINAPI
SpcPrintableToUniversalString(const SpcAlloc* psManager,
                           LPSTR  pSource, 
                           DWORD*  pString,
                           DWORD&  dwString);

HRESULT WINAPI 
SpcUniversalToPrintableString(const SpcAlloc* psManager,
                           DWORD*  pbStr, 
                           USHORT  cbStr,
                           LPSTR&  psString,
                           DWORD&  dwString);

//+-------------------------------------------------------------------
// Asn functions

HRESULT WINAPI 
SpcASNEncodeTimeStamp(IN const SpcAlloc* pManager,
                      IN const void* pStructure,
                      OUT PBYTE&     psEncoding,
                      IN OUT DWORD&  dwEncoding);

HRESULT WINAPI 
SpcASNDecodeTimeStamp(IN const SpcAlloc* pManager,
                      IN  const PBYTE psEncoding,
                      IN  DWORD       dwEncoding,
                      IN  DWORD       dwFlags,
                      OUT LPVOID&     psStructure,
                      IN OUT DWORD&   dwStructure);

HRESULT WINAPI
SpcASNEncodeObjectId(IN const SpcAlloc* pManager,
                     IN const void*   pStructure,
                     OUT PBYTE&       psEncoding,
                     IN OUT DWORD&    dwEncoding);

HRESULT 
SpcASNDecodeObjectId(IN const SpcAlloc* pManager,
                     IN  const PBYTE psEncoding,
                     IN  DWORD       dwEncoding,
                     IN  DWORD       dwFlags,
                     OUT LPVOID&     psStructure,
                     IN OUT DWORD&   dwStructure);

HRESULT WINAPI
SpcASNEncodeDirectoryString(IN const SpcAlloc* pManager,
                            const void* psData,
                            PBYTE&      pEncoding,
                            DWORD&      dwEncoding);

HRESULT WINAPI 
SpcASNDecodeDirectoryString(IN const SpcAlloc* pManager,
                            IN const PBYTE psEncoding, 
                            IN DWORD       dwEncoding, 
                            IN DWORD       dwFlags,
                            OUT LPVOID&    psString,
                            IN OUT DWORD&  dwString);

HRESULT WINAPI
SpcASNEncodeDirectoryStringW(IN const SpcAlloc* pManager,
                             const void* psData,
                             PBYTE&      pEncoding,
                             DWORD&      dwEncoding);

HRESULT WINAPI 
SpcASNDecodeDirectoryStringW(IN const SpcAlloc* pManager,
                             IN const PBYTE psEncoding, 
                             IN DWORD       dwEncoding, 
                             IN DWORD       dwFlags,
                             OUT LPVOID&    psString,
                             IN OUT DWORD&  dwString);

HRESULT WINAPI 
SpcASNEncodeOctetString(IN const SpcAlloc* pManager,
                        IN  const void* pStructure,
                        OUT PBYTE&      psEncoding,
                        IN OUT DWORD&   dwEncoding);


HRESULT WINAPI 
SpcASNDecodeOctetString(IN const SpcAlloc* pManager,
                        IN  const PBYTE psEncoding,
                        IN  DWORD       dwEncoding,
                        IN  DWORD       dwFlags,
                        OUT LPVOID&     psStructure,
                        IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeAttributes(IN const SpcAlloc* pManager,
                       IN  const void* pStructure,
                       OUT PBYTE&      psEncoding,
                       IN OUT DWORD&   dwEncoding);

HRESULT WINAPI 
SpcASNDecodeAttributes(IN const SpcAlloc* pManager,
                       IN  const PBYTE psEncoding,
                       IN  DWORD       dwEncoding,
                       IN  DWORD       dwFlags,
                       OUT LPVOID&     psStructure,
                       IN OUT DWORD&   dwStructure);
HRESULT WINAPI 
SpcASNEncodeIA5String(IN const SpcAlloc* pManager,
                      IN const void*   pStructure,
                      OUT PBYTE&  psEncoding,
                      IN OUT DWORD&  dwEncoding);

HRESULT WINAPI 
SpcASNDecodeIA5String(IN const SpcAlloc* pManager,
                      IN  const PBYTE psEncoding,
                      IN  DWORD       dwEncoding,
                      IN  DWORD       dwFlags,
                      OUT LPVOID&     psStructure,
                      IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeTimeRequest(IN const SpcAlloc* pManager,
                        IN  const void* pStructure,
                        OUT PBYTE& psEncoding,
                        IN OUT DWORD& dwEncoding);

HRESULT WINAPI 
SpcASNDecodeTimeRequest(IN const SpcAlloc* pManager,
                        IN  const PBYTE psEncoding,
                        IN  DWORD       dwEncoding,
                        IN  DWORD       dwFlags,
                        OUT LPVOID&     psStructure,
                        IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeSignerInfo(IN const SpcAlloc* pManager,
                       IN  const void* pStructure,
                       OUT PBYTE&      psEncoding,
                       IN OUT DWORD&   dwEncoding);

HRESULT WINAPI 
SpcASNDecodeSignerInfo(IN const SpcAlloc* pManager,
                       IN  const PBYTE psEncoding,
                       IN  DWORD       dwEncoding,
                       IN  DWORD       dwFlags,
                       OUT LPVOID&     psStructure,
                       IN OUT DWORD&   dwStructure);
HRESULT WINAPI 
SpcASNEncodeContentInfo(IN const SpcAlloc* pManager,
                        IN  const void* pStructure,
                        OUT PBYTE&      psEncoding,
                        IN OUT DWORD&   dwEncoding);

HRESULT WINAPI 
SpcASNDecodeContentInfo(IN const SpcAlloc* pManager,
                        IN  const PBYTE psEncoding,
                        IN  DWORD       dwEncoding,
                        IN  DWORD       dwFlags,
                        OUT LPVOID&     psStructure,
                        IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeContentType(IN const SpcAlloc* pManager,
                        IN  const void* pStructure,
                        OUT PBYTE& psEncoding,
                        IN OUT DWORD& dwEncoding);

HRESULT WINAPI 
SpcASNDecodeContentType(IN const SpcAlloc* pManager,
                        IN  const PBYTE psEncoding,
                        IN  DWORD       dwEncoding,
                        IN  DWORD       dwFlags,
                        OUT LPVOID&     psStructure,
                        IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeAttribute(IN const SpcAlloc* pManager,
                      IN  const void* pStructure,
                      OUT PBYTE& psEncoding,
                      IN OUT DWORD& dwEncoding);

HRESULT WINAPI 
SpcASNDecodeAttribute(IN const SpcAlloc* pManager,
                      IN  const PBYTE psEncoding,
                      IN  DWORD       dwEncoding,
                      IN  DWORD       dwFlags,
                      OUT LPVOID&     psStructure,
                      IN OUT DWORD&   dwStructure);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\sipprov.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipprov.h
//
//--------------------------------------------------------------------------

//
// sipprov.h
//
// Miscellaneous definitions to be shared between
// the pieces of our NT trust provider and its SIPs
//

//
// internal definitions that help us process things
//
typedef enum
    {
    SUBJTYPE_NONE            = 0,
    SUBJTYPE_FILE            = 1,
    SUBJTYPE_FILEANDDISPLAY  = 2
    } SUBJTYPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\trustcom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       trustcom.h
//
//  Contents:   Microsoft Internet Security COM interface
//
//  History:    14-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef TRUSTCOM_H
#define TRUSTCOM_H

#ifdef __cplusplus
extern "C" 
{
#endif

//////////////////////////////////////////////////////////////////////////////
//
// TrustSign
//----------------------------------------------------------------------------
//  Digitally signs the file.  The user will be prompted for signing 
//  certificate.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_INVALID_PARAMETER:        bad argument passed in  (the user will NOT be shown UI)
//
extern BOOL WINAPI TrustSign(HWND hWndCaller, WCHAR *pwszFile);

//////////////////////////////////////////////////////////////////////////////
//
// TrustVerify
//----------------------------------------------------------------------------
//  Digitally verifies the file.  The user will be presented UI if 
//  applicable.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_INVALID_PARAMETER:        bad argument passed in (the user will NOT be shown UI).
//
extern BOOL WINAPI TrustVerify(HWND hWndCaller, WCHAR *pwszFile);

#ifdef __cplusplus
}
#endif

#endif // TRUSTCOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\trustglu.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       trustglu.h
//
//--------------------------------------------------------------------------

//
// trustglue.h
//
// This is TEMPORARY housing for this data, permanent housing will
// be winbase.h
//

//////////////////////////////////////////////////////////////////
//
// Subject form for CAB files that uses WIN_TRUST_SUBJECT_FILE
//
//////////////////////////////////////////////////////////////////

#define WIN_TRUST_SUBJTYPE_CABINET                               \
            { 0xd17c5374,                                        \
              0xa392,                                            \
              0x11cf,                                            \
              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
            }

//////////////////////////////////////////////////////////////////
//
// Extended subject forms that use the newer, improved subject
// form WIN_TWIN_TRUST_SUBJECT_FILE_AND_DISPLAY
//
//////////////////////////////////////////////////////////////////

#define WIN_TRUST_SUBJTYPE_RAW_FILEEX                            \
            { 0x6f458110,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_PE_IMAGEEX                            \
            { 0x6f458111,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_JAVA_CLASSEX                          \
            { 0x6f458113,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_CABINETEX                             \
            { 0x6f458114,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }


//////////////////////////////////////////////////////////////////
//
// Subject forms
//
//////////////////////////////////////////////////////////////////

//
// from winbase.h
//
// typedef struct _WIN_TRUST_SUBJECT_FILE {
//
//    HANDLE  hFile;
//    LPCWSTR lpPath;
//
// } WIN_TRUST_SUBJECT_FILE, *LPWIN_TRUST_SUBJECT_FILE;
//

typedef struct _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY {

    HANDLE  hFile;              // handle to the open file if you got it
    LPCWSTR lpPath;             // the path to open if you don't
    LPCWSTR lpDisplayName;      // (optional) display name to show to user 
                                //      in place of path

} WIN_TRUST_SUBJECT_FILE_AND_DISPLAY, *LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\unicode5.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       unicode5.h
//
//--------------------------------------------------------------------------

//
// include this file instead of unicode.h, or after unicode.h
// for NT5 only compatibility.
//

#ifndef __UNICODE5_H__
#define __UNICODE5_H__

#define FIsWinNT() (TRUE)
#define FIsWinNT5() (TRUE)


#define RegQueryValueExU        RegQueryValueExW
#define RegCreateKeyExU         RegCreateKeyExW
#define RegDeleteKeyU           RegDeleteKeyW
#define RegEnumKeyExU           RegEnumKeyExW
#define RegEnumValueU           RegEnumValueW
#define RegSetValueExU          RegSetValueExW
#define RegQueryInfoKeyU        RegQueryInfoKeyW
#define RegDeleteValueU         RegDeleteValueW
#define RegOpenKeyExU           RegOpenKeyExW
#define RegConnectRegistryU     RegConnectRegistryW
#define ExpandEnvironmentStringsU ExpandEnvironmentStringsW

#define CreateFileU             CreateFileW
#define DeleteFileU             DeleteFileW
#define CopyFileU               CopyFileW
#define MoveFileExU             MoveFileExW
#define GetTempFileNameU        GetTempFileNameW
#define GetFileAttributesU      GetFileAttributesW
#define SetFileAttributesU      SetFileAttributesW
#define GetCurrentDirectoryU    GetCurrentDirectoryW
#define CreateDirectoryU        CreateDirectoryW
#define GetWindowsDirectoryU    GetWindowsDirectoryW
#define LoadLibraryU            LoadLibraryW
#define LoadLibraryExU          LoadLibraryExW

#define CryptSignHashU          CryptSignHashW
#define CryptVerifySignatureU   CryptVerifySignatureW
#define CryptSetProviderU       CryptSetProviderW

#define UuidToStringU           UuidToStringW

#define GetUserNameU            GetUserNameW
#define GetComputerNameU        GetComputerNameW
#define GetModuleFileNameU      GetModuleFileNameW
#define GetModuleHandleU        GetModuleHandleW

#define LoadStringU             LoadStringW
#define InsertMenuU             InsertMenuW
#define FormatMessageU          FormatMessageW
#define PropertySheetU          PropertySheetW
#define CreatePropertySheetPageU    CreatePropertySheetPageW
#define DragQueryFileU          DragQueryFileW
#define SetWindowTextU          SetWindowTextW
#define GetWindowTextU          GetWindowTextW
#define DialogBoxParamU         DialogBoxParamW
#define DialogBoxU              DialogBoxW
#define GetDlgItemTextU         GetDlgItemTextW
#define SetDlgItemTextU         SetDlgItemTextW
#define MessageBoxU             MessageBoxW
#define LCMapStringU            LCMapStringW
#define GetDateFormatU          GetDateFormatW
#define GetTimeFormatU          GetTimeFormatW
#define WinHelpU                WinHelpW
#define SendMessageU            SendMessageW
#define SendDlgItemMessageU     SendDlgItemMessageW
#define IsBadStringPtrU         IsBadStringPtrW
#define OutputDebugStringU      OutputDebugStringW
#define GetCommandLineU         GetCommandLineW
#define DrawTextU               DrawTextW
#define GetSaveFileNameU        GetSaveFileNameW
#define GetOpenFileNameU        GetOpenFileNameW
#define CreateFileMappingU      CreateFileMappingW

#define CreateEventU            CreateEventW
#define RegisterEventSourceU    RegisterEventSourceW
#define OpenEventU              OpenEventW
#define CreateMutexU            CreateMutexW
#define OpenMutexU              OpenMutexW

#define CreateFontIndirectU     CreateFontIndirectW

#endif  // __UNICODE5_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\unicode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       unicode.h
//
//--------------------------------------------------------------------------

#ifndef __ECM_UNICODE_H__
#define __ECM_UNICODE_H__

// necessary defns -- remove?
#include <rpc.h>
#include <rpcdce.h>
#include <wincrypt.h>

#include "commctrl.h"
#include "commdlg.h"
#include "prsht.h"
#include "shellapi.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI FIsWinNT(void);
BOOL WINAPI FIsWinNT5(VOID);
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW, char ** pszMB, int *pcbConverted);
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB);
void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB);

LPWSTR WINAPI MkWStr(char * szMB);
void WINAPI FreeWStr(LPWSTR wsz);


BOOL WINAPI wstr2guid(const WCHAR *pwszIn, GUID *pgOut);
BOOL WINAPI guid2wstr(const GUID *pgIn, WCHAR *pwszOut);

// The following is also needed for non-x86 due to the fact that the
// A/W versions of the ListView_ functions do not exist.
// (these are implemented in ispu\common\unicode\commctrl.cpp)
HTREEITEM WINAPI TreeView_InsertItemU(
    HWND hwndTV,
    LPTVINSERTSTRUCTW lpis
    );	

int WINAPI ListView_InsertItemU(
    HWND hwnd,
    const LPLVITEMW pitem
    );

void WINAPI ListView_SetItemTextU(
    HWND hwnd,
    int i,
    int iSubItem,
    LPCWSTR pszText
    );

int WINAPI ListView_InsertColumnU(
    HWND hwnd,
    int i,
    const LPLVCOLUMNW plvC);

BOOL WINAPI ListView_GetItemU(
    HWND hwnd,
    LPLVITEMW pitem
    );


LONG WINAPI RegOpenHKCUKeyExA(
    HKEY hKey,  // handle of open key
    LPCSTR lpSubKey,    // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
    );

//
//  the following api's handle the problem with impersinating another user
//  and having the HKEY_CURRENT_USER opened to an incorrect user's SID.
//
LONG WINAPI RegCreateHKCUKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegCreateHKCUKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegOpenHKCUKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG
WINAPI
RegOpenHKCU(
    HKEY *phKeyCurrentUser
    );

LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    );

// Normally, HKEY_USERS\CurrentSid is opened as the HKCU. However, if
// HKEY_USERS\CurrentSid doesn't exist, then, HKEY_USERS\.Default is
// opened.  Set the following flag to only open
// HKEY_USERS\.Default if the current user is the LocalSystem SID.
#define REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG     0x1

// Normally, HKEY_USERS\CurrentSid is opened as the HKCU. However, if
// HKEY_USERS\CurrentSid doesn't exist, then, HKEY_USERS\.Default is
// opened.  Set the following flag to always disable the opening of
// HKEY_USERS\.Default. If HKEY_USERS\CurrentSid doesn't exist, RegOpenHKCUEx
// returns ERROR_FILE_NOT_FOUND.
#define REG_HKCU_DISABLE_DEFAULT_FLAG               0x2

LONG
WINAPI
RegCloseHKCU(
    HKEY hKeyCurrentUser
    );

BOOL
WINAPI
GetUserTextualSidHKCU(
    IN      LPWSTR  wszTextualSid,
    IN  OUT LPDWORD pcchTextualSid
    );


#ifdef _M_IX86


// Reg.cpp
LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegDeleteKeyU(
    HKEY hKey,
    LPCWSTR lpSubKey
   );

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   );

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG WINAPI RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    );

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG WINAPI RegConnectRegistryU (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );

// File.cpp
HANDLE WINAPI CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

BOOL
WINAPI
DeleteFileU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
CopyFileU(
          LPCWSTR lpwExistingFileName,
          LPCWSTR lpwNewFileName,
          BOOL bFailIfExists
          );

BOOL
WINAPI
MoveFileExU(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags);

DWORD
WINAPI
GetFileAttributesU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
SetFileAttributesU(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

DWORD
WINAPI
GetCurrentDirectoryU(
    DWORD nBufferLength,
    LPWSTR lpBuffer);

BOOL
WINAPI
CreateDirectoryU(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
WINAPI
RemoveDirectoryU(
    LPCWSTR lpPathName
    );

UINT
WINAPI
GetWindowsDirectoryU(
    LPWSTR lpBuffer,
    UINT uSize
    );

UINT
WINAPI
GetTempFileNameU(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    OUT LPWSTR lpTempFileName
    );

HINSTANCE WINAPI LoadLibraryU(
    LPCWSTR lpLibFileName
    );

HINSTANCE WINAPI LoadLibraryExU(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

DWORD
WINAPI
ExpandEnvironmentStringsU(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );

HANDLE
WINAPI
FindFirstFileU(
    IN LPCWSTR pwszDir,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    );

BOOL
WINAPI
FindNextFileU(
    IN HANDLE hFindFile,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    );

HANDLE
WINAPI
FindFirstChangeNotificationU(
    LPCWSTR pwszPath,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );


// capi.cpp

BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );

BOOL WINAPI CryptEnumProvidersU(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR pwszProvName,
    DWORD *pcbProvName
    );

BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags
    );

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType
    );

// Ole.cpp
RPC_STATUS RPC_ENTRY UuidToStringU(
    UUID *  Uuid,
    WCHAR * *  StringUuid
   );

// nt.cpp
BOOL WINAPI GetUserNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
   );

BOOL WINAPI GetComputerNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

DWORD WINAPI GetModuleFileNameU(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
   );

HMODULE WINAPI GetModuleHandleU(
    LPCWSTR lpModuleName    // address of module name to return handle for
   );

// user.cpp
int WINAPI LoadStringU(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax
   );

BOOL
WINAPI
InsertMenuU(
    HMENU       hMenu,
    UINT        uPosition,
    UINT        uFlags,
    UINT_PTR    uIDNewItem,
    LPCWSTR     lpNewItem
    );


DWORD WINAPI FormatMessageU(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
   );

int
WINAPI
CompareStringU(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR  lpString1,
    int      cchCount1,
    LPCWSTR  lpString2,
    int      cchCount2);

INT_PTR WINAPI PropertySheetU(
    LPPROPSHEETHEADERW  lppsph);

HPROPSHEETPAGE WINAPI CreatePropertySheetPageU(LPCPROPSHEETPAGEW    pPage);

UINT WINAPI     DragQueryFileU(
    HDROP   hDrop,
    UINT    iFile,
    LPWSTR  lpwszFile,
    UINT    cch);


BOOL WINAPI SetWindowTextU(
    HWND hWnd,
    LPCWSTR lpString
   );

int WINAPI GetWindowTextU(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount
   );

int WINAPI DialogBoxParamU(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam
    );

int WINAPI DialogBoxU(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc
    );

UINT WINAPI GetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int nMaxCount
   );

BOOL WINAPI SetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString
    );

int WINAPI MessageBoxU(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    );

int WINAPI LCMapStringU(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest
    );

int WINAPI GetDateFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate
    );

int WINAPI GetTimeFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime
    );

BOOL WINAPI WinHelpU(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );

LRESULT WINAPI SendMessageU(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LONG WINAPI
SendDlgItemMessageU(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LPWSTR
WINAPI
GetCommandLineU(void);

BOOL
WINAPI
IsBadStringPtrU(IN LPWSTR lpsz, UINT ucchMax);

void
WINAPI
OutputDebugStringU(IN LPWSTR lpwsz);

int
WINAPI
DrawTextU(
    HDC     hDC,
    LPCWSTR lpString,
    int     nCount,
    LPRECT  lpRect,
    UINT    uFormat
);

//
// NOTE the following fields in LPOPENFILENAMEW are NOT supported:
//      nFileOffset
//      nFileExtension
//      lpTemplateName
//
BOOL
WINAPI
GetSaveFileNameU(
    LPOPENFILENAMEW pOpenFileName
);

//
// NOTE the following fields in LPOPENFILENAMEW are NOT supported:
//      nFileOffset
//      nFileExtension
//      lpTemplateName
//
BOOL
WINAPI
GetOpenFileNameU(
    LPOPENFILENAMEW pOpenFileName
);

// event.cpp
HANDLE
WINAPI
CreateEventU(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName);

HANDLE
WINAPI
RegisterEventSourceU(
                    LPCWSTR lpUNCServerName,
                    LPCWSTR lpSourceName);

HANDLE
WINAPI
OpenEventU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HANDLE
WINAPI
CreateMutexU(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName);

HANDLE
WINAPI
OpenMutexU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HFONT
WINAPI
CreateFontIndirectU(CONST LOGFONTW *lplf);

#else

#define RegQueryValueExU        RegQueryValueExW
#define RegCreateKeyExU         RegCreateKeyExW
#define RegDeleteKeyU           RegDeleteKeyW
#define RegEnumKeyExU           RegEnumKeyExW
#define RegEnumValueU           RegEnumValueW
#define RegSetValueExU          RegSetValueExW
#define RegQueryInfoKeyU        RegQueryInfoKeyW
#define RegDeleteValueU         RegDeleteValueW
#define RegOpenKeyExU           RegOpenKeyExW
#define RegConnectRegistryU     RegConnectRegistryW
#define ExpandEnvironmentStringsU ExpandEnvironmentStringsW

#define CreateFileU             CreateFileW
#define DeleteFileU             DeleteFileW
#define CopyFileU               CopyFileW
#define MoveFileExU             MoveFileExW
#define GetTempFileNameU        GetTempFileNameW
#define GetFileAttributesU      GetFileAttributesW
#define SetFileAttributesU      SetFileAttributesW
#define GetCurrentDirectoryU    GetCurrentDirectoryW
#define CreateDirectoryU        CreateDirectoryW
#define RemoveDirectoryU        RemoveDirectoryW
#define GetWindowsDirectoryU    GetWindowsDirectoryW
#define LoadLibraryU            LoadLibraryW
#define LoadLibraryExU          LoadLibraryExW

#define FindFirstFileU          FindFirstFileW
#define FindNextFileU           FindNextFileW
#define FindFirstChangeNotificationU    FindFirstChangeNotificationW

#define CryptAcquireContextU    CryptAcquireContextW
#define CryptEnumProvidersU     CryptEnumProvidersW
#define CryptSignHashU          CryptSignHashW
#define CryptVerifySignatureU   CryptVerifySignatureW
#define CryptSetProviderU       CryptSetProviderW

#define UuidToStringU           UuidToStringW

#define GetUserNameU            GetUserNameW
#define GetComputerNameU        GetComputerNameW
#define GetModuleFileNameU      GetModuleFileNameW
#define GetModuleHandleU        GetModuleHandleW

#define LoadStringU             LoadStringW
#define InsertMenuU             InsertMenuW
#define FormatMessageU          FormatMessageW
#define	CompareStringU			CompareStringW
#define PropertySheetU          PropertySheetW
#define CreatePropertySheetPageU    CreatePropertySheetPageW
#define DragQueryFileU          DragQueryFileW
#define SetWindowTextU          SetWindowTextW
#define GetWindowTextU          GetWindowTextW
#define DialogBoxParamU         DialogBoxParamW
#define DialogBoxU              DialogBoxW
#define GetDlgItemTextU         GetDlgItemTextW
#define SetDlgItemTextU         SetDlgItemTextW
#define MessageBoxU     MessageBoxW
#define LCMapStringU            LCMapStringW
#define GetDateFormatU          GetDateFormatW
#define GetTimeFormatU          GetTimeFormatW
#define WinHelpU                WinHelpW
#define SendMessageU            SendMessageW
#define SendDlgItemMessageU     SendDlgItemMessageW
#define IsBadStringPtrU         IsBadStringPtrW
#define OutputDebugStringU      OutputDebugStringW
#define GetCommandLineU         GetCommandLineW
#define DrawTextU               DrawTextW
#define GetSaveFileNameU        GetSaveFileNameW
#define GetOpenFileNameU        GetOpenFileNameW

#define CreateEventU            CreateEventW
#define RegisterEventSourceU    RegisterEventSourceW
#define OpenEventU              OpenEventW
#define CreateMutexU            CreateMutexW
#define OpenMutexU              OpenMutexW

#define CreateFontIndirectU     CreateFontIndirectW

#endif // _M_IX86

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\vercert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       vercert.h
//
//--------------------------------------------------------------------------

#ifndef _VERCERT_

#define _VERCERT_

#define	CRYPT_SAVE_CERTS_IN_CA_STORE			0x01
#define	CRYPT_SAVE_PERSONAL_CERT_IN_MY_STORE		0x02
#define	CRYPT_SAVE_SELFSIGN_CERT_IN_ROOT_STORE		0x04
#define	CRYPT_NO_PROP_ENHANCED_KEY_USAGE		0x08
#define	CRYPT_NO_EXT_ENHANCED_KEY_USAGE			0x10
#define	CRYPT_NO_REVOCATION_CHECKS			0x20
#define	CRYPT_NO_ROOT_REVOCATION_CHECKS			0x40

extern "C" BOOL WINAPI CryptVerifyCertificate(
	PCCERT_CONTEXT pCert,
   	LPCSTR szEKU,
	DWORD flags);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\voidlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       voidlist.h
//
//  Contents:   definitions for list functions
//
//  History:    01-Jan-2000 reidk created
//
//--------------------------------------------------------------------------


#ifndef __VOIDLIST_H
#define __VOIDLIST_H

#ifdef __cplusplus
extern "C"
{
#endif


typedef struct LIST_NODE_
{
    void *pNext;
    void *pElement;

} LIST_NODE, *PLIST_NODE;


typedef struct LIST_
{
    LIST_NODE   *pHead;
    LIST_NODE   *pTail;
    DWORD       dwNumNodes;

} LIST, *PLIST;


void
LIST_Initialize(LIST *pList);

PLIST_NODE
LIST_AddHead(LIST *pList, void *pElement);

PLIST_NODE
LIST_AddTail(LIST *pList, void *pElement);

BOOL
LIST_RemoveElement(LIST *pList, void *pElement);

BOOL
LIST_RemoveAll(LIST *pList);

PLIST_NODE
LIST_GetFirst(LIST *pList);

PLIST_NODE
LIST_GetNext(PLIST_NODE pNode);

void *
LIST_GetElement(PLIST_NODE pNode);


#ifdef __cplusplus
}
#endif


#endif // __VOIDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\uihlpr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       uihlpr.h
//
//--------------------------------------------------------------------------

#ifndef _UIHLPR_H
#define _UIHLPR_H

//
// uihlpr.h : CryptUI helper functions.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

//+-------------------------------------------------------------------------
//  Check to see if a specified URL is http scheme.
//--------------------------------------------------------------------------
BOOL
WINAPI
IsHttpUrlA(
    IN LPCTSTR  pszUrlString
);

BOOL
WINAPI
IsHttpUrlW(
    IN LPCWSTR  pwszUrlString
);

//+-------------------------------------------------------------------------
// Check to see if a specified string is OK to be formatted as link based on
// severity of error code, and internet scheme of the string.
//--------------------------------------------------------------------------
BOOL
WINAPI
IsOKToFormatAsLinkA(
    IN LPSTR    pszUrlString,
    IN DWORD    dwErrorCode
);

BOOL
WINAPI
IsOKToFormatAsLinkW(
    IN LPWSTR   pwszUrlString,
    IN DWORD    dwErrorCode
);

//+-------------------------------------------------------------------------
// Return the display name for a cert. Caller must free the string by
// free().
//--------------------------------------------------------------------------
LPWSTR
WINAPI
GetDisplayNameString(
    IN  PCCERT_CONTEXT   pCertContext,
	IN  DWORD            dwFlags
);

#ifdef __cplusplus
}
#endif

#endif // _UIHLPR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\utf8.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       utf8.h
//
//  Contents:   WideChar (UNICODE) to/from UTF8 APIs
//
//  APIs:       WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

#ifndef __UTF8_H__
#define __UTF8_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    );

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\whctl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       whctl.h
//
//  Contents:   Windows Hardware Compatibility Trust Provider
//              API Prototypes and Definitions
//
//--------------------------------------------------------------------------

#ifndef _WHCTL_H_
#define _WHCTL_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WHCTL_SOURCE_
#define WHCTLAPI __stdcall
#else
#define WHCTLAPI DECLSPEC_IMPORT __stdcall
#endif


#define WHCTL_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.28"

/* WindowsCompatibleHardware = 8aa7fc60-101b-11d0-ad9a-00a0c90833eb */
#define WIN_HCTL_ACTION_WINDOWS_COMPATIBLE                  \
        { 0x8aa7fc60,                                       \
          0x101b,                                           \
          0x11d0,                                           \
          {0xad, 0x9a, 0x00, 0xa0, 0xc9, 0x08, 0x33, 0xeb}  \
        }


#define REGSTR_PATH_WHCTL REGSTR_PATH_SERVICES "\\WinTrust\\TrustProviders\\Windows Compatible Hardware"


#ifdef __cplusplus
}
#endif

#endif //_WHCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\waitsvc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       waitsvc.h
//
//--------------------------------------------------------------------------

#ifndef __WAITSVC_H__
#define __WAITSVC_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// routine called by code that calls into the Cryptography service (ProtectedStorage)
// code that makes RPC calls into the service should call this function before
// making the RPC bind call.
//

BOOL
WaitForCryptService(
    IN      LPWSTR  pwszService,
    IN      BOOL    *pfDone,
    IN      BOOL    fLogErrors = FALSE);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __WAITSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\winchain.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       winchain.h
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    15-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__WINCHAIN_H__)
#define __WINCHAIN_H__

#include <wincrypt.h>

#if defined(__cplusplus)
extern "C" {
#endif

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\wintrold.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       wintrold.h
//
//--------------------------------------------------------------------------

#ifndef WINTROLD_H
#define WINTROLD_H


/************************************************************************
*                                                                       *
*   wintrust.h -- This module defines the 32-Bit WinTrust definitions   *
*                 needed to build Trust Providers and / Subject         *
*                 Interface Packages.                                   *
*                                                                       *
*   Copyright (c) 1990-1996, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _WINTRUST_
#define _WINTRUST_ 

#ifdef __cplusplus
extern "C" {
#endif



/***********************************************************************
*                                                                      *
* This section contains definitions related to:                        *
*                                                                      *
*                           WinTrust in general                        *
*                                                                      *
************************************************************************/


//
// WinTrust Revisioning
//
#define WIN_TRUST_MAJOR_REVISION_MASK       0xFFFF0000
#define WIN_TRUST_MINOR_REVISION_MASK       0x0000FFFF
#define WIN_TRUST_REVISION_1_0              0x00010000




/***********************************************************************
*                                                                      *
* This section contains definitions related to:                        *
*                                                                      *
*                           Subject Interface Packages                 *
*                                                                      *
************************************************************************/

//
// Allows passing of subject and type material.
//

typedef struct _WIN_TRUST_SIP_SUBJECT {
    GUID *                  SubjectType;
    WIN_TRUST_SUBJECT       Subject;
} WIN_TRUST_SIP_SUBJECT, *LPWIN_TRUST_SIP_SUBJECT;

//
// Templates of services that must be EXPORTED by SIPs
// FOR USE by Trust Providers (calling through WinTrust).
//

typedef BOOL
( *LPWINTRUST_SUBJECT_CHECK_CONTENT_INFO)(
    IN     LPWIN_TRUST_SIP_SUBJECT          lpSubject,          // pointer to subject info
    IN     LPWIN_CERTIFICATE                lpSignedData       // PKCS #7 Signed Data
    );

typedef BOOL
( *LPWINTRUST_SUBJECT_ENUM_CERTIFICATES)(
    IN     LPWIN_TRUST_SIP_SUBJECT          lpSubject,          // pointer to subject info
    IN     DWORD                            dwTypeFilter,       // 0 or WIN_CERT_TYPE_xxx
    OUT    LPDWORD                          lpCertificateCount,
    IN OUT LPDWORD                          lpIndices,          // Rcvs WIN_CERT_TYPE_
    IN     DWORD                            dwIndexCount
    );

typedef BOOL
( *LPWINTRUST_SUBJECT_GET_CERTIFICATE)(
    IN     LPWIN_TRUST_SIP_SUBJECT          lpSubject,
    IN     DWORD                            dwCertificateIndex,
    OUT    LPWIN_CERTIFICATE                lpCertificate,
    IN OUT LPDWORD                          lpRequiredLength
    );

typedef BOOL
( *LPWINTRUST_SUBJECT_GET_CERT_HEADER)(
    IN     LPWIN_TRUST_SIP_SUBJECT          lpSubject,
    IN     DWORD                            dwCertificateIndex,
    OUT    LPWIN_CERTIFICATE                lpCertificateHeader
    );

typedef BOOL
(*LPWINTRUST_SUBJECT_GET_NAME)(
    IN     LPWIN_TRUST_SIP_SUBJECT      lpSubject, 
    IN     LPWIN_CERTIFICATE            lpSignedData,
    IN OUT LPWSTR                       lpBuffer,
    IN OUT LPDWORD                      lpRequiredLength
    );
    
typedef DWORD
(*LPWINTRUST_PROVIDER_PING) (
    IN      LPWSTR              lpProviderName,
    IN      DWORD               dwClientParameter,
    OUT     LPDWORD             lpdwServerReturnValue
    );


typedef struct _WINTRUST_SIP_DISPATCH_TABLE
{
    LPWINTRUST_SUBJECT_CHECK_CONTENT_INFO   CheckSubjectContentInfo;
    LPWINTRUST_SUBJECT_ENUM_CERTIFICATES    EnumSubjectCertificates;
    LPWINTRUST_SUBJECT_GET_CERTIFICATE      GetSubjectCertificate;
    LPWINTRUST_SUBJECT_GET_CERT_HEADER      GetSubjectCertHeader;
    LPWINTRUST_SUBJECT_GET_NAME             GetSubjectName;

} WINTRUST_SIP_DISPATCH_TABLE, *LPWINTRUST_SIP_DISPATCH_TABLE;



//
// Structure describing an individual SIP.
//
// This structure is passed back to WinTrust from a Subject Interface Package
// initialization call.
//
typedef struct _WINTRUST_SIP_INFO {
    DWORD                               dwRevision;
    LPWINTRUST_SIP_DISPATCH_TABLE       lpServices;
    DWORD                               dwSubjectTypeCount;
    GUID *                              lpSubjectTypeArray;
} WINTRUST_SIP_INFO, *LPWINTRUST_SIP_INFO;



//
// SIP Intialization routine.
// SIP DLLs are required to have a routine named:
//
//                          WinTrustSipInitialize.
//
// This initialization routine must have the following
// definition:
//

typedef BOOL
(*LPWINTRUST_SUBJECT_PACKAGE_INITIALIZE)(
    IN     DWORD                            dwWinTrustRevision,
    OUT    LPWINTRUST_SIP_INFO              *lpSipInfo
    );




/***********************************************************************
*                                                                      *
* This section contains definitions related to:                        *
*                                                                      *
*                           Trust Providers                            *
*                                                                      *
************************************************************************/


//
// This should be with the other SPUB GUIDs in winbase.h
//
// PublishedSoftwareNoBad {C6B2E8D0-E005-11cf-A134-00C04FD7BF43}
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI              \
            { 0xc6b2e8d0,                                       \
              0xe005,                                           \
              0x11cf,                                           \
              { 0xa1, 0x34, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x43 } \
             }


//
// Dispatch table of WinTrust services available to Trust Providers
//
// Client side...

typedef struct _WINTRUST_CLIENT_TP_DISPATCH_TABLE
{
    LPWINTRUST_PROVIDER_PING                ServerPing;
    LPWINTRUST_SUBJECT_CHECK_CONTENT_INFO   CheckSubjectContentInfo;
    LPWINTRUST_SUBJECT_ENUM_CERTIFICATES    EnumSubjectCertificates;
    LPWINTRUST_SUBJECT_GET_CERTIFICATE      GetSubjectCertificate;
    LPWINTRUST_SUBJECT_GET_CERT_HEADER      GetSubjectCertHeader;
    LPWINTRUST_SUBJECT_GET_NAME             GetSubjectName;
    
} WINTRUST_CLIENT_TP_DISPATCH_TABLE, *LPWINTRUST_CLIENT_TP_DISPATCH_TABLE;


// Server side...

typedef struct _WINTRUST_SERVER_TP_DISPATCH_TABLE
{
    LPWINTRUST_SUBJECT_CHECK_CONTENT_INFO   CheckSubjectContentInfo;
    LPWINTRUST_SUBJECT_ENUM_CERTIFICATES    EnumSubectCertificates;
    LPWINTRUST_SUBJECT_GET_CERTIFICATE      GetSubjectCertificate;
    LPWINTRUST_SUBJECT_GET_CERT_HEADER      GetSubjectCertHeader;
    LPWINTRUST_SUBJECT_GET_NAME             GetSubjectName;
    
} WINTRUST_SERVER_TP_DISPATCH_TABLE, *LPWINTRUST_SERVER_TP_DISPATCH_TABLE;


//
// The following structures are passed by WinTrust to a
// Trust Provider being initialized.
//
// Client side...

typedef struct _WINTRUST_CLIENT_TP_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_CLIENT_TP_DISPATCH_TABLE     lpServices;
} WINTRUST_CLIENT_TP_INFO,  *LPWINTRUST_CLIENT_TP_INFO;

// Server side
typedef struct _WINTRUST_SERVER_TP_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_SERVER_TP_DISPATCH_TABLE     lpServices;
} WINTRUST_SERVER_TP_INFO,  *LPWINTRUST_SERVER_TP_INFO;


//
// Templates of Trust Provider services available to WinTrust
//
typedef LONG
(*LPWINTRUST_PROVIDER_VERIFY_TRUST) (
    IN     HWND                             hwnd,
    IN     GUID *                           ActionID,
    IN     LPVOID                           ActionData
    );

typedef VOID
(*LPWINTRUST_PROVIDER_SUBMIT_CERTIFICATE) (
    IN     LPWIN_CERTIFICATE                lpCertificate
    );

typedef VOID
(*LPWINTRUST_PROVIDER_CLIENT_UNLOAD) (
    IN     LPVOID                           lpTrustProviderInfo
    );

typedef VOID
(*LPWINTRUST_PROVIDER_SERVER_UNLOAD) (
    IN     LPVOID                           lpTrustProviderInfo
    );

//
// Dispatch table of Trust provider services available for use by WinTrust
//
//  Client side...

typedef struct _WINTRUST_PROVIDER_CLIENT_SERVICES
{
    LPWINTRUST_PROVIDER_CLIENT_UNLOAD       Unload;
    LPWINTRUST_PROVIDER_VERIFY_TRUST        VerifyTrust;
    LPWINTRUST_PROVIDER_SUBMIT_CERTIFICATE  SubmitCertificate;
    
} WINTRUST_PROVIDER_CLIENT_SERVICES, *LPWINTRUST_PROVIDER_CLIENT_SERVICES;


typedef struct _WINTRUST_PROVIDER_SERVER_SERVICES
{
    LPWINTRUST_PROVIDER_SERVER_UNLOAD       Unload;
    LPWINTRUST_PROVIDER_PING                Ping;
    
} WINTRUST_PROVIDER_SERVER_SERVICES, *LPWINTRUST_PROVIDER_SERVER_SERVICES;


//
// This structure is passed back from the client-side Trust Provider
// following initialization of that Trust Provider.
//
typedef struct _WINTRUST_PROVIDER_CLIENT_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_PROVIDER_CLIENT_SERVICES     lpServices;
    DWORD                                   dwActionIdCount;
    GUID *                                  lpActionIdArray;
} WINTRUST_PROVIDER_CLIENT_INFO, *LPWINTRUST_PROVIDER_CLIENT_INFO;

//
// This structure is passed back from the server-side trust provider following
// initialization of that trust provider.
//
typedef struct _WINTRUST_PROVIDER_SERVER_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_PROVIDER_SERVER_SERVICES     lpServices;
} WINTRUST_PROVIDER_SERVER_INFO, *LPWINTRUST_PROVIDER_SERVER_INFO;





//
// Trust Provider Initialization Routines
// Each Trust Provider DLL must have a client and server side initialization
// routine.  The routines must be named:
//
//              WinTrustProviderClientInitialize()
//      and
//              WinTrustProviderServerInitialize()
//
// and must be defined to match the following templates...
//
typedef BOOL
(*LPWINTRUST_PROVIDER_CLIENT_INITIALIZE)(
    IN     DWORD                                dwWinTrustRevision,
    IN     LPWINTRUST_CLIENT_TP_INFO            lpWinTrustInfo,
    IN     LPWSTR                               lpProviderName,
    OUT    LPWINTRUST_PROVIDER_CLIENT_INFO      *lpTrustProviderInfo
    );

typedef BOOL
(*LPWINTRUST_PROVIDER_SERVER_INITIALIZE) (
    IN     DWORD                            dwWinTrustRevision,
    IN     LPWINTRUST_SERVER_TP_INFO        lpWinTrustInfo,
    IN     LPWSTR                           lpProviderName,
    OUT    LPWINTRUST_PROVIDER_SERVER_INFO  *lpTrustProviderInfo
    );


#ifdef __cplusplus
}
#endif
                   
#endif // _WINTRUST_




#endif // WINTROLD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\wvtver1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtver1.h
//
//  Contents:   Microsoft Internet Security WinVerifyTrust v1 support
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WVTVER1_H
#define WVTVER1_H

#define V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI           \
            { 0xc6b2e8d0,                                       \
              0xe005,                                           \
              0x11cf,                                           \
              { 0xa1, 0x34, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x43 } \
             }

#define V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE                    \
            { 0x64b9d180,                                        \
              0x8da2,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

extern BOOL             WintrustIsVersion1ActionID(GUID *pgActionID);
extern WINTRUST_DATA    *ConvertDataFromVersion1(HWND hWnd,
                                                 GUID *pgActionID,
                                                 WINTRUST_DATA *pWTDNew, 
                                                 WINTRUST_FILE_INFO *pWTFINew,
                                                 LPVOID pWTDOld);


#endif // WVTVER1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\accdbg.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:        accdbg.h
//
//  Contents:    debug internal includes for
//
//  History:     8-94        Created         DaveMont
//
//--------------------------------------------------------------------
#ifndef __ACCDEBUGHXX__
#define __ACCDEBUGHXX__

#include <dsysdbg.h>

#if DBG == 1

    #ifdef ASSERT
        #undef ASSERT
    #endif

    #define ASSERT DsysAssert

    DECLARE_DEBUG2(ac)

    #define DEB_TRACE_API           0x08
    #define DEB_TRACE_ACC           0x10
    #define DEB_TRACE_CACHE         0x20
    #define DEB_TRACE_PROP          0x40
    #define DEB_TRACE_SD            0x80
    #define DEB_TRACE_SID           0x100
    #define DEB_TRACE_LOOKUP        0x200
    #define DEB_TRACE_MEM           0x400
    #define DEB_TRACE_HANDLE        0x800

    #define acDebugOut(args) acDebugPrint args

    VOID
    DebugInitialize();

    VOID
    DebugDumpSid(PSTR   pszTag,
                 PSID   pSid);

    VOID
    DebugDumpSD(PSTR                    pszTag,
                PSECURITY_DESCRIPTOR    pSD);

    VOID
    DebugDumpAcl(PSTR   pszTag,
                 PACL   pAcl);

    #define DebugDumpGuid(tag, pguid)                                       \
    pguid == NULL ? acDebugOut((DEB_TRACE_SD, "%s: (NULL)\n", tag))     :   \
    acDebugOut((DEB_TRACE_SD,                                               \
    "%s: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",                \
    tag,pguid->Data1,pguid->Data2,pguid->Data3,pguid->Data4[0],             \
    pguid->Data4[1],pguid->Data4[2],pguid->Data4[3],pguid->Data4[4],        \
    pguid->Data4[5],pguid->Data4[6],pguid->Data4[7]))

    PVOID   DebugAlloc(ULONG cSize);
    VOID    DebugFree(PVOID  pv);


#else

    #define acDebugOut(args)

    #define DebugInitialize()

    #define DebugDumpSid(tag,sid)

    #define DebugDumpSD(tag, sd)

    #define DebugDumpAcl(tag, acl)

    #define DebugDumpGuid(tag, guid)

#endif // DBG


#ifdef PERFORMANCE
    #define START_PERFORMANCE ULONG starttime = GetCurrentTime();
    #define MEASURE_PERFORMANCE(args)              \
    (args)                                         \
        { Log(starttime - GetCurrentTime(),"args") }

#else
    #define START_PERFORMANCE
    #define MEASURE_PERFORMANCE(args) (args)
#endif

extern HANDLE WmiGuidHandle;

#endif // __ACCDEBUGHXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\global.h ===
#ifndef __GLOBAL_H__
#define __GLOBAL_H__

typedef PVOID MARTA_CONTEXT, *PMARTA_CONTEXT;
#define NULL_MARTA_CONTEXT ((MARTA_CONTEXT) 0)

typedef struct _MARTA_OBJECT_PROPERTIES {
    DWORD cbSize;
    DWORD dwFlags;
} MARTA_OBJECT_PROPERTIES, *PMARTA_OBJECT_PROPERTIES;

#define MARTA_OBJECT_IS_CONTAINER   0x1

typedef struct _MARTA_OBJECT_TYPE_PROPERTIES {
    DWORD           cbSize;
    DWORD           dwFlags;
    GENERIC_MAPPING GenMap;
} MARTA_OBJECT_TYPE_PROPERTIES, *PMARTA_OBJECT_TYPE_PROPERTIES;

#define MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG   0x1
#define MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG   0x2

#define CONDITIONAL_EXIT(a, b) if (ERROR_SUCCESS != (a)) { goto b; }
#define CONDITIONAL_RETURN(a)  if (ERROR_SUCCESS != (a)) { return (a); }
#define CONDITIONAL_ACE_SIZE_ERROR(a)                                         \
            if ((a) > 0xFFFF) { return ERROR_BAD_INHERITANCE_ACL; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\file.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefFileContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseFileContext(
    IN MARTA_CONTEXT Context
    );

////////////////////////////////////////////////////////////////////////
// Does not free up the current context.                              //
////////////////////////////////////////////////////////////////////////

DWORD
MartaFindFirstFile(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pChildContext
    );

////////////////////////////////////////////////////////////////////////
// Frees up the current context.                                      //
////////////////////////////////////////////////////////////////////////

DWORD
MartaFindNextFile(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pSiblingContext
    );

////////////////////////////////////////////////////////////////////////
// Does not free up the current context.                              //
////////////////////////////////////////////////////////////////////////

DWORD
MartaGetFileParentContext(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pParentContext
    );

DWORD
MartaGetFileProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetFileTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetFileRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenFileNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenFileHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetFileRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

// The following function is exported for testing

DWORD
MartaConvertFileContextToNtName(
    IN MARTA_CONTEXT        Context,
    OUT LPWSTR              *ppwszNtObject
    );

ACCESS_MASK
MartaGetFileDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    );

DWORD
MartaReopenFileContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    );

DWORD
MartaReopenFileOrigContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    );

DWORD
MartaGetFileNameFromContext(
    IN MARTA_CONTEXT Context,
    OUT LPWSTR *pObjectName
    );

DWORD
MartaGetFileParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\guidtables.h ===
#ifndef __GUIDTABLES_H__
#define  __GUIDTABLES_H__

typedef DWORD (*FN_CONVERT_NAME_TO_GUID) (
                    IN  LPCWSTR   pObjectName,
                    OUT GUID    * pGuid
                    );

FN_CONVERT_NAME_TO_GUID MartaConvertNameToGuid [] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaConvertDsObjectNameToGuid,
    &MartaConvertDsObjectNameToGuid,
    NULL,
    NULL
};

typedef DWORD (*FN_CONVERT_GUID_TO_NAME) (
                    IN  GUID     Guid,
                    OUT LPWSTR * ppObjectName
                    );

FN_CONVERT_GUID_TO_NAME MartaConvertGuidToName [] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaConvertGuidToDsName,
    &MartaConvertGuidToDsName,
    NULL,
    NULL
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\inc\xelib.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       xelib.h
//
//  Contents:   defines and prototypes for functions moved from ca
//
//----------------------------------------------------------------------------
#ifndef _XELIB_H_
#define _XELIB_H_

#include <certca.h>
#define SECURITY_WIN32
#include <security.h>	// for EXTENDED_NAME_FORMAT

//defines
#define CCLOCKSKEWMINUTESDEFAULT	      10
#define CBMAX_CRYPT_HASH_LEN                  20

#define DWORDROUND(cb)	(((cb) + (sizeof(DWORD) - 1)) & ~(sizeof(DWORD) - 1))
#define POINTERROUND(cb) (((cb) + (sizeof(VOID *) - 1)) & ~(sizeof(VOID *) - 1))

// Constants chosen to avoid DWORD overflow:
#define CVT_WEEKS	(7 * CVT_DAYS)
#define CVT_DAYS	(24 * CVT_HOURS)
#define CVT_HOURS	(60 * CVT_MINUTES)
#define CVT_MINUTES	(60 * CVT_SECONDS)
#define CVT_SECONDS	(1)
#define CVT_BASE	(1000 * 1000 * 10)


// _XENROLL_SRC_ allows cs.h to define its own macros
#if defined(_XENROLL_SRC_) || defined(_XELIBCA_SRC_) || defined(__CERTLIB_H__)

// Size of a fixed array:
#define ARRAYSIZE(a)		(sizeof(a)/sizeof((a)[0]))

#ifndef CSASSERT
#if DBG
# include <assert.h>
# define CSASSERT(exp)	assert(exp)
# define DBGPRINTF(pszMessage, hr) \
            DbgPrintf(DBG_SS_APP,  \
                "%s(%u): %s:error = 0x%x\n", \
                __FILE__, \
                __LINE__, \
                pszMessage, \
                hr)
#else
# define CSASSERT(exp)
# define DBGPRINTF(pszMessage, hr)
#endif //DBG

#define _JumpIfError(hr, label, pszMessage) \
    { \
        if (S_OK != (hr)) \
        { \
            DBGPRINTF(pszMessage, hr); \
            goto label; \
        } \
    }

#define _JumpError(hr, label, pszMessage) \
    { \
        DBGPRINTF(pszMessage, hr); \
        goto label; \
    }

#define _PrintError(hr, pszMessage) \
    { \
        DBGPRINTF(pszMessage, hr); \
    }

#define _PrintIfError(hr, pszMessage) \
    { \
        if (S_OK != (hr)) \
        { \
            DBGPRINTF(pszMessage, hr); \
        } \
    }
#endif //CSASSERT

#if !defined(_XENROLL_SRC_)
# if DBG

#define LocalFree		myLocalFree
#define SysFreeString		mySysFreeString
#define LocalReAlloc            myLocalReAlloc
#define LocalAlloc		myLocalAlloc
#define CoTaskMemAlloc		myCoTaskMemAlloc
#define SysAllocStringByteLen	mySysAllocStringByteLen
#define CoTaskMemFree		myCoTaskMemFree
#define FormatMessageW		myFormatMessageW
#define CoTaskMemRealloc        myCoTaskMemRealloc
#define StringFromCLSID		myStringFromCLSID
#define StringFromIID		myStringFromIID
#define SysAllocString		mySysAllocString
#define SysReAllocString        mySysReAllocString
#define SysAllocStringLen	mySysAllocStringLen
#define SysReAllocStringLen     mySysReAllocStringLen
#define PropVariantClear	myPropVariantClear
#define VariantClear		myVariantClear
#define VariantChangeType	myVariantChangeType
#define VariantChangeTypeEx	myVariantChangeTypeEx

void *myNew(IN size_t size);
void myDelete(IN void *pv);

__inline void *__cdecl operator new(
    IN size_t size)
{
    return(myNew(size));
}

__inline void __cdecl operator delete(
    IN void *pv)
{
    return(myDelete(pv));
}


DWORD
myFormatMessageW(
    IN DWORD dwFlags,
    IN LPCVOID lpSource,
    IN DWORD dwMessageId,
    IN DWORD dwLanguageId,
    OUT LPWSTR lpBuffer,
    IN DWORD nSize,
    IN va_list *Arguments);

HLOCAL
myLocalAlloc(
    IN UINT uFlags,
    IN UINT uBytes);

HLOCAL
myLocalReAlloc(
    IN HLOCAL hMem,
    IN UINT uBytes,
    IN UINT uFlags);

HLOCAL
myLocalFree(
    IN HLOCAL hMem);

VOID *
myCoTaskMemAlloc(
    IN ULONG cb);

VOID *
myCoTaskMemRealloc(
    IN VOID *pv,
    IN ULONG cb);

VOID
myCoTaskMemFree(
    IN VOID *pv);

HRESULT
myStringFromCLSID(
    IN REFCLSID rclsid,
    OUT LPOLESTR FAR* lplpsz);

HRESULT
myStringFromIID(
    IN REFIID rclsid,
    OUT LPOLESTR FAR* lplpsz);

BSTR
mySysAllocString(
    IN const OLECHAR *pwszIn);

INT
mySysReAllocString(
    IN OUT BSTR *pstr,
    IN const OLECHAR *pwszIn);

BSTR
mySysAllocStringLen(
    IN const OLECHAR *pwcIn,
    IN UINT cwc);

INT
mySysReAllocStringLen(
    IN OUT BSTR *pstr,
    IN const OLECHAR *pwcIn,
    IN UINT cwc);

VOID
mySysFreeString(
    IN BSTR str);


HRESULT
myPropVariantClear(
    IN PROPVARIANT *pvar);

HRESULT
myVariantClear(
    IN VARIANTARG *pvar);

HRESULT
myVariantChangeType(
    OUT VARIANTARG *pvarDest,
    IN VARIANTARG *pvarSrc,
    IN unsigned short wFlags,
    IN VARTYPE vt);

HRESULT
myVariantChangeTypeEx(
    OUT VARIANTARG *pvarDest,
    IN VARIANTARG *pvarSrc,
    IN LCID lcid,
    IN unsigned short wFlags,
    IN VARTYPE vt);

BSTR
mySysAllocStringByteLen(
    LPCSTR pszIn,
    UINT cb);

VOID
mydbgDumpHex(
    IN DWORD dwSubSysId,
    IN DWORD Flags,
    IN BYTE const *pb,
    IN ULONG cb);

#define CSM_LOCALALLOC		0
#define CSM_COTASKALLOC		1
#define CSM_SYSALLOC		2
#define CSM_MALLOC		3
#define CSM_NEW			4
#define CSM_MAX			5
#define CSM_MASK		0xff
#define CSM_MIDLUSERALLOC	CSM_COTASKALLOC
#define CSM_VARIANT		100
#define CSM_GLOBALDESTRUCTOR	0x200

VOID
myRegisterMemDump(VOID);

VOID
myRegisterMemAlloc(
    IN VOID const *pv,
    IN LONG cb,
    IN DWORD Flags);

VOID
myRegisterMemFree(
    IN VOID const *pv,
    IN DWORD Flags);

# else //DBG

#define myRegisterMemDump()
#define myRegisterMemAlloc(pv, cb, Flags)
#define myRegisterMemFree(pv, Flags)

# endif //DBG
#endif //!defined(_XENROLL_SRC_)


// SUNDOWN-Safe pointer subtraction

#ifndef SAFE_SUBTRACT_POINTERS
#define SAFE_SUBTRACT_POINTERS(__x__, __y__) ( DW_PtrDiffc(__x__, sizeof(*(__x__)), __y__, sizeof(*(__y__))) )

__inline DWORD
DW_PtrDiffc(
    IN void const *pb1,
    IN DWORD dwPtrEltSize1,
    IN void const *pb2,
    IN DWORD dwPtrEltSize2)
{
    // pb1 should be greater
    CSASSERT((ULONG_PTR)pb1 >= (ULONG_PTR)pb2);

    // both should have same elt size
    CSASSERT(dwPtrEltSize1 == dwPtrEltSize2);

    // assert that the result doesn't overflow 32-bits
    CSASSERT((DWORD)((ULONG_PTR)pb1 - (ULONG_PTR)pb2) == (ULONG_PTR)((ULONG_PTR)pb1 - (ULONG_PTR)pb2));

    // return number of objects between these pointers
    return (DWORD) ( ((ULONG_PTR)pb1 - (ULONG_PTR)pb2) / dwPtrEltSize1 );
}
#endif SAFE_SUBTRACT_POINTERS

#endif //defined(_XENROLL_SRC_) || defined(__CERTLIB_H__)

//xenroll implemented apis but called in xelib but not ca
PCCRYPT_OID_INFO
WINAPI
xeCryptFindOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    );

//types

enum CERTLIB_ALLOCATOR {
    CERTLIB_NO_ALLOCATOR = 0,
    CERTLIB_USE_COTASKMEMALLOC = 1,
    CERTLIB_USE_LOCALALLOC = 2,
    CERTLIB_USE_NEW = 3,
};

//prototypes

VOID *
myAlloc(IN size_t cbBytes, IN CERTLIB_ALLOCATOR allocType);

VOID
myFree(IN VOID *pv, IN CERTLIB_ALLOCATOR allocType);

HRESULT
myHError(IN HRESULT hr);

HRESULT
myHLastError(VOID);

BOOL
myEncodeObject(
    DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN VOID const *pvStructInfo,
    IN DWORD dwFlags,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myDecodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvStructInfo,
    OUT DWORD *pcbStructInfo);

BOOL WINAPI
myCryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,            // AT_SIGNATURE | AT_KEYEXCHANGE
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_PUBLIC_KEY_INFO **ppPubKey,
    OUT DWORD *pcbPubKey);

HRESULT
myEncodeSignedContent(
    IN HCRYPTPROV hProv,
    IN DWORD dwCertEncodingType,
    IN char const *pszObjIdSignatureAlgorithm,
    IN BYTE *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned);

VOID
myMakeExprDateTime(
    IN OUT FILETIME *pft,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod);

HRESULT
myCryptMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvData,
    OUT DWORD *pcbData);

HRESULT
MultiByteIntegerToBstr(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    OUT BSTR *pstrOut);

HRESULT
MultiByteIntegerToWszBuf(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT WCHAR *pwszOut);

typedef struct _CRYPT_REQUEST_CLIENT_INFO
{
    DWORD  dwClientId;
    WCHAR *pwszUser;
    WCHAR *pwszMachine;
    WCHAR *pwszProcess;
} CRYPT_REQUEST_CLIENT_INFO;

HRESULT
myEncodeUTF8String(
    IN WCHAR const *pwszIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myDecodeUTF8String(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR **ppwszOut);

HRESULT
myEncodeRequestClientAttribute(
    IN CRYPT_REQUEST_CLIENT_INFO const *pcrci,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myDecodeRequestClientAttribute(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CRYPT_REQUEST_CLIENT_INFO **ppcrci);

HRESULT
myEncodeRequestClientAttributeFromClientId(
    IN DWORD dwClientId,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myGetUserNameEx(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszUserName);

HRESULT
myGetMachineDnsName(
    OUT WCHAR **ppwszDnsName);

HRESULT
myGetProcessName(
    OUT WCHAR **ppwszProcessName);

#define wszCNXCHGSUFFIX		L"-Xchg"
#define cchCOMMONNAMEMAX_XELIB	64

HRESULT
myAddNameSuffix(
    IN WCHAR const *pwszValue,
    IN WCHAR const *pwszSuffix,
    IN DWORD cwcNameMax,
    OUT WCHAR **ppwszOut);

HRESULT
BuildCMCAttributes(
    IN DWORD cAttribute,
    IN CRYPT_ATTRIBUTE const *rgAttribute,
    IN DWORD dwCMCDataReference,
    IN DWORD dwBodyPartIdOfRequest,
    IN DWORD dwBodyPartId,
    OUT CMC_TAGGED_ATTRIBUTE *pTaggedAttribute,
    OUT CRYPT_ATTR_BLOB *pBlob);

HRESULT
BuildCMCRequest(
    IN DWORD dwClientId,
    IN BOOL fNestedCMCRequest,
    IN BYTE const *pbReq,
    IN DWORD cbReq,
    OPTIONAL IN CERT_EXTENSION const *rgExt,
    IN DWORD cExt,
    OPTIONAL IN CRYPT_ATTRIBUTES const *rgAttributes,
    IN DWORD cAttributes,
    OPTIONAL IN CRYPT_ATTRIBUTE const *rgAttributeUnauth,
    IN DWORD cAttributeUnauth,
    OPTIONAL IN BYTE const *pbKeyIdRequest,
    IN DWORD cbKeyIdRequest,
    OPTIONAL IN HCRYPTPROV hProvRequest,
    IN DWORD dwKeySpecRequest,
    OPTIONAL IN LPCSTR pszOIDSignHashRequest,
    OPTIONAL IN CERT_CONTEXT const *pCertSigner,
    OPTIONAL IN HCRYPTPROV hProvSigner,
    IN DWORD dwKeySpecSigner,
    OPTIONAL IN LPCSTR pszObjIdHashSigner,
    OUT BYTE **ppbReqCMC,
    OUT DWORD *pcbReqCMC);

typedef struct _XCMCRESPONSE
{
    CMC_STATUS_INFO  StatusInfo;
    WCHAR           *pwszBodyPart;	// Body Part Id string: "1.3.3.1"
    BYTE	    *pbCertHash;
    DWORD            cbCertHash;
    BYTE	    *pbEncryptedKeyHash;
    DWORD            cbEncryptedKeyHash;
} XCMCRESPONSE;

HRESULT
ParseCMCResponse(
    IN BYTE *pbResponse,
    IN DWORD cbResponse,
    OPTIONAL OUT HCERTSTORE *phStoreResponse,
    OUT XCMCRESPONSE **prgResponse,
    OUT DWORD *pcResponse);

VOID
FreeCMCResponse(
    IN XCMCRESPONSE *rgResponse,
    IN DWORD cResponse);

HRESULT
myDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut);

HRESULT
myDecodePKCS7(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT BYTE **ppbContents,
    OPTIONAL OUT DWORD *pcbContents,
    OPTIONAL OUT DWORD *pdwMsgType,
    OPTIONAL OUT char **ppszInnerContentObjId,
    OPTIONAL OUT DWORD *pcSigner,
    OPTIONAL OUT DWORD *pcRecipient,
    OPTIONAL OUT HCERTSTORE *phStore,
    OPTIONAL OUT HCRYPTMSG *phMsg);

HRESULT
myGetPublicKeyHash(
    OPTIONAL IN CERT_INFO const *pCertInfo,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData);

HRESULT
myCreateSubjectKeyIdentifierExtension(
    IN CERT_PUBLIC_KEY_INFO const *pPubKey,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

HRESULT
myCalculateKeyArchivalHash(
    IN const BYTE     *pbEncryptedKey,
    IN DWORD           cbEncryptedKey,
    OUT BYTE         **ppbHash,
    OUT DWORD         *pcbHash);

HRESULT
myInternetCanonicalizeUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut);

HRESULT
myInternetUncanonicalizeURL(
    IN WCHAR const *pwszURLIn,
    OUT WCHAR **ppwszURLOut);

BOOL
myConvertWszToUTF8(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc);

BOOL
myConvertWszToSz(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc);

BOOL
myConvertUTF8ToWsz(
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch);

BOOL
myConvertSzToWsz(
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch);

#endif //_XELIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\ds.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefDsObjectContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseDsObjectContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaConvertDsObjectNameToGuid(
    IN  LPCWSTR   pObjectName,
    OUT GUID    * pGuid
    );

DWORD
MartaConvertGuidToDsName(
    IN  GUID     Guid,
    OUT LPWSTR * ppObjectName
    );

DWORD
MartaGetDsObjectProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetDsObjectTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetDsObjectRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenDsObjectNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetDsObjectRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

DWORD
MartaGetDsParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\lmsh.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefLMShareContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseLMShareContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetLMShareProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetLMShareTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetLMShareRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenLMShareNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetLMShareRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\printer.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefPrinterContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaClosePrinterContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetPrinterProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetPrinterTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetPrinterRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenPrinterNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenPrinterHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetPrinterRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\registry.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefRegistryKeyContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseRegistryKeyContext(
    IN MARTA_CONTEXT Context
    );

////////////////////////////////////////////////////////////////////////
// Does not free up the current context.                              //
////////////////////////////////////////////////////////////////////////

DWORD
MartaFindFirstRegistryKey(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pChildContext
    );

////////////////////////////////////////////////////////////////////////
// Frees up the current context.                                      //
////////////////////////////////////////////////////////////////////////

DWORD
MartaFindNextRegistryKey(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pSiblingContext
    );

////////////////////////////////////////////////////////////////////////
// Does not free up the current context.                              //
////////////////////////////////////////////////////////////////////////

DWORD
MartaGetRegistryKeyParentContext(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pParentContext
    );

DWORD
MartaGetRegistryKeyProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetRegistryKeyTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetRegistryKeyRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenRegistryKeyNamedObject(
    IN  LPCWSTR              pObjectName,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    );

DWORD
MartaOpenRegistryKeyHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetRegistryKeyRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

// The following two functions are exported for testing

DWORD
MartaConvertRegistryKeyContextToName(
    IN MARTA_CONTEXT        Context,
    OUT LPWSTR              *ppwszObject
    );

// The returned Handle isn't duplicated. It has the same lifetime as
// the Context
DWORD
MartaConvertRegistryKeyContextToHandle(
    IN MARTA_CONTEXT        Context,
    OUT HANDLE              *pHandle
    );

ACCESS_MASK
MartaGetRegistryKeyDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    );

ACCESS_MASK
MartaGetRegistryKey32DesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    );

ACCESS_MASK
MartaGetDefaultDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    );

DWORD
MartaReopenRegistryKeyContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    );

DWORD
MartaReopenRegistryKeyOrigContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    );

DWORD
MartaGetRegistryKeyNameFromContext(
    IN MARTA_CONTEXT Context,
    OUT LPWSTR *pObjectName
    );

DWORD
MartaGetRegistryKeyParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\service.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefServiceContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseServiceContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetServiceProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetServiceTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetServiceRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenServiceNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenServiceHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetServiceRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\kernel.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefKernelContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseKernelContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetKernelProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetKernelTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetKernelRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenKernelNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenKernelHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetKernelRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\tables.h ===
#ifndef __TABLES_H__
#define  __TABLES_H__

typedef DWORD (*FN_ADD_REF_CONTEXT) (
                    IN MARTA_CONTEXT Context
                    );

FN_ADD_REF_CONTEXT MartaAddRefContext [] = {
    NULL,
    &MartaAddRefFileContext,
    &MartaAddRefServiceContext,
    &MartaAddRefPrinterContext,
    &MartaAddRefRegistryKeyContext,
    &MartaAddRefLMShareContext,
    &MartaAddRefKernelContext,
    &MartaAddRefWindowContext,
    &MartaAddRefDsObjectContext,
    &MartaAddRefDsObjectContext,
    NULL,
    &MartaAddRefWMIGuidContext,
    &MartaAddRefRegistryKeyContext
};

typedef DWORD (*FN_CLOSE_CONTEXT) (
                    IN MARTA_CONTEXT Context
                    );

FN_CLOSE_CONTEXT MartaCloseContext [] = {
    NULL,
    &MartaCloseFileContext,
    &MartaCloseServiceContext,
    &MartaClosePrinterContext,
    &MartaCloseRegistryKeyContext,
    &MartaCloseLMShareContext,
    &MartaCloseKernelContext,
    &MartaCloseWindowContext,
    &MartaCloseDsObjectContext,
    &MartaCloseDsObjectContext,
    NULL,
    &MartaCloseWMIGuidContext,
    &MartaCloseRegistryKeyContext
};

typedef DWORD (*FN_FIND_FIRST) (
                    IN  MARTA_CONTEXT  Context,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pChildContext
                    );

FN_FIND_FIRST MartaFindFirst [] = {
    NULL,
    &MartaFindFirstFile,
    NULL,
    NULL,
    &MartaFindFirstRegistryKey,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaFindFirstRegistryKey
};

typedef DWORD (*FN_FIND_NEXT) (
                    IN  MARTA_CONTEXT  Context,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pSiblingContext
                    );

FN_FIND_NEXT MartaFindNext [] = {
    NULL,
    &MartaFindNextFile,
    NULL,
    NULL,
    &MartaFindNextRegistryKey,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaFindNextRegistryKey
};

typedef DWORD (*FN_GET_PARENT_CONTEXT) (
                    IN  MARTA_CONTEXT  Context,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pParentContext
                    );

FN_GET_PARENT_CONTEXT MartaGetParentContext [] = {
    NULL,
    &MartaGetFileParentContext,
    NULL,
    NULL,
    &MartaGetRegistryKeyParentContext,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaGetRegistryKeyParentContext
};

typedef DWORD (*FN_GET_TYPE_PROPERTIES) (
                    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
                    );

FN_GET_TYPE_PROPERTIES MartaGetTypeProperties [] = {
    NULL,
    &MartaGetFileTypeProperties,
    &MartaGetServiceTypeProperties,
    &MartaGetPrinterTypeProperties,
    &MartaGetRegistryKeyTypeProperties,
    &MartaGetLMShareTypeProperties,
    &MartaGetKernelTypeProperties,
    &MartaGetWindowTypeProperties,
    &MartaGetDsObjectTypeProperties,
    &MartaGetDsObjectTypeProperties,
    NULL,
    &MartaGetWMIGuidTypeProperties,
    &MartaGetRegistryKeyTypeProperties
};

typedef DWORD (*FN_GET_PROPERTIES) (
                    IN     MARTA_CONTEXT            Context,
                    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
                    );

FN_GET_PROPERTIES MartaGetProperties [] = {
    NULL,
    &MartaGetFileProperties,
    &MartaGetServiceProperties,
    &MartaGetPrinterProperties,
    &MartaGetRegistryKeyProperties,
    &MartaGetLMShareProperties,
    &MartaGetKernelProperties,
    &MartaGetWindowProperties,
    &MartaGetDsObjectProperties,
    &MartaGetDsObjectProperties,
    NULL,
    &MartaGetWMIGuidProperties,
    &MartaGetRegistryKeyProperties
};

typedef DWORD (*FN_GET_RIGHTS) (
                    IN  MARTA_CONTEXT        Context,
                    IN  SECURITY_INFORMATION SecurityInfo,
                    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
                    );

FN_GET_RIGHTS MartaGetRights [] = {
    NULL,
    &MartaGetFileRights,
    &MartaGetServiceRights,
    &MartaGetPrinterRights,
    &MartaGetRegistryKeyRights,
    &MartaGetLMShareRights,
    &MartaGetKernelRights,
    &MartaGetWindowRights,
    &MartaGetDsObjectRights,
    &MartaGetDsObjectRights,
    NULL,
    &MartaGetWMIGuidRights,
    &MartaGetRegistryKeyRights
};

typedef DWORD (*FN_OPEN_HANDLE_OBJECT) (
                    IN  HANDLE         Handle,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pContext
                    );

FN_OPEN_HANDLE_OBJECT MartaOpenHandleObject [] = {
    NULL,
    &MartaOpenFileHandleObject,
    &MartaOpenServiceHandleObject,
    &MartaOpenPrinterHandleObject,
    &MartaOpenRegistryKeyHandleObject,
    NULL,
    &MartaOpenKernelHandleObject,
    &MartaOpenWindowHandleObject,
    NULL,
    NULL,
    NULL,
    &MartaOpenWMIGuidHandleObject,
    &MartaOpenRegistryKeyHandleObject
};

typedef DWORD (*FN_OPEN_NAMED_OBJECT) (
                    IN  LPCWSTR        pObjectName,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pContext
                    );

FN_OPEN_NAMED_OBJECT MartaOpenNamedObject [] = {
    NULL,
    &MartaOpenFileNamedObject,
    &MartaOpenServiceNamedObject,
    &MartaOpenPrinterNamedObject,
    &MartaOpenRegistryKeyNamedObject,
    &MartaOpenLMShareNamedObject,
    &MartaOpenKernelNamedObject,
    &MartaOpenWindowNamedObject,
    &MartaOpenDsObjectNamedObject,
    &MartaOpenDsObjectNamedObject,
    NULL,
    &MartaOpenWMIGuidNamedObject,
    &MartaOpenRegistryKeyNamedObject
};

typedef DWORD (*FN_SET_RIGHTS) (
                    IN MARTA_CONTEXT        Context,
                    IN SECURITY_INFORMATION SecurityInfo,
                    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                    );

FN_SET_RIGHTS MartaSetRights [] = {
    NULL,
    &MartaSetFileRights,
    &MartaSetServiceRights,
    &MartaSetPrinterRights,
    &MartaSetRegistryKeyRights,
    &MartaSetLMShareRights,
    &MartaSetKernelRights,
    &MartaSetWindowRights,
    &MartaSetDsObjectRights,
    &MartaSetDsObjectRights,
    NULL,
    &MartaSetWMIGuidRights,
    &MartaSetRegistryKeyRights
};

typedef DWORD (*FN_GET_DESIRED_ACCESS) (
                    IN SECURITY_OPEN_TYPE   OpenType,
                    IN BOOL                 Attribs,
                    IN SECURITY_INFORMATION SecurityInfo
                    );

FN_GET_DESIRED_ACCESS MartaGetDesiredAccess [] = {
    NULL,
    &MartaGetFileDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetRegistryKeyDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    NULL,
    &MartaGetDefaultDesiredAccess,
    &MartaGetRegistryKey32DesiredAccess
};

typedef DWORD (*FN_REOPEN_CONTEXT) (
                    IN OUT MARTA_CONTEXT Context,
                    IN     ACCESS_MASK   AccessMask
                    );

FN_REOPEN_CONTEXT MartaReopenContext [] = {
    NULL,
    &MartaReopenFileContext,
    NULL,
    NULL,
    &MartaReopenRegistryKeyContext,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaReopenRegistryKeyContext
};

typedef DWORD (*FN_REOPEN_ORIG_CONTEXT) (
                    IN OUT MARTA_CONTEXT Context,
                    IN     ACCESS_MASK   AccessMask
                    );

FN_REOPEN_CONTEXT MartaReopenOrigContext [] = {
    NULL,
    &MartaReopenFileOrigContext,
    NULL,
    NULL,
    &MartaReopenRegistryKeyOrigContext,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaReopenRegistryKeyOrigContext
};

typedef DWORD (*FN_GET_PARENT_NAME) (
                    IN LPWSTR ObjectName,
                    OUT LPWSTR *pParentName
                    );

FN_GET_PARENT_NAME MartaGetParentName [] = {
    NULL,
    &MartaGetFileParentName,
    NULL,
    NULL,
    &MartaGetRegistryKeyParentName,
    NULL,
    NULL,
    NULL,
    &MartaGetDsParentName,
    &MartaGetDsParentName,
    NULL,
    NULL,
    &MartaGetRegistryKeyParentName
};

typedef DWORD (*FN_GET_NAME_FROM_CONTEXT) (
                    IN MARTA_CONTEXT Context,
                    OUT LPWSTR *pObjectName
                    );

FN_GET_NAME_FROM_CONTEXT MartaGetNameFromContext [] = {
    NULL,
    &MartaGetFileNameFromContext,
    NULL,
    NULL,
    &MartaGetRegistryKeyNameFromContext,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaGetRegistryKeyNameFromContext
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\strings.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:        strings.h
//
//  Contents:    Definitions to use for loading string resources
//
//  History:     20-Aug-96      MacM        Created
//
//--------------------------------------------------------------------

#define ACCPROV_MARTA_DACL_PROTECTED 1000
#define ACCPROV_MARTA_SACL_PROTECTED 1001
#define ACCPROV_MARTA_BOTH_PROTECTED 1002
#define ACCPROV_ACCOUNT_OPS          1003
#define ACCPROV_PRINTER_OPS          1004
#define ACCPROV_SYSTEM_OPS           1005
#define ACCPROV_POWER_USERS          1006
#define ACCPROV_NTAUTHORITY          1007
#define ACCPROV_BUILTIN              1008


//
// The counts of entries needs to be manually kept in synch with the
// rights defined in accctrl.h.
//

//
// This is the length of the longest string in the resource table.  This must
// be manually kept in synch
//
#define ACCPROV_LONGEST_STRING  28

//
// Base and count of standard access permissions
//
#define ACCPROV_STD_ACCESS      1100
#define ACCPROV_NUM_STD            7

//
// Base and count of ds access permissions
//
#define ACCPROV_DS_ACCESS       1200
#define ACCPROV_NUM_DS             9

//
// Base and count of file access permissions
//
#define ACCPROV_FILE_ACCESS     1300
#define ACCPROV_NUM_FILE           9

//
// Base and count of direcotry access permissions
//
#define ACCPROV_DIR_ACCESS      1400
#define ACCPROV_NUM_DIR            5

//
// Base and count of kernel access permissions
//
#define ACCPROV_KERNEL_ACCESS   1500
#define ACCPROV_NUM_KERNEL        16

//
// Base and count of printer access permissions
//
#define ACCPROV_PRINT_ACCESS    1600
#define ACCPROV_NUM_PRINT         5

//
// Base and count of service access permissions
//
#define ACCPROV_SERVICE_ACCESS  1700
#define ACCPROV_NUM_SERVICE        9

//
// Base and count of registry access permissions
//
#define ACCPROV_REGISTRY_ACCESS 1800
#define ACCPROV_NUM_REGISTRY       6

//
// Base and count of window station access permissions
//
#define ACCPROV_WIN_ACCESS      1900
#define ACCPROV_NUM_WIN            9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\lucache.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       lucache.h
//
//  Contents:   Name/Sid and Name/Property mapping and cache
//              functions and declarations
//
//  History:    2-Feb-97    MacM        Created
//
//--------------------------------------------------------------------
#ifndef __LUCACHE_H__
#define __LUCACHE_H__

#include <winldap.h>
#include <accctrl.h>

typedef struct _ACTRL_NAME_CACHE
{
    PWSTR           pwszName;
    PSID            pSid;
    SID_NAME_USE    SidUse;
    struct _ACTRL_NAME_CACHE *pNextName;
    struct _ACTRL_NAME_CACHE *pNextSid;
} ACTRL_NAME_CACHE, *PACTRL_NAME_CACHE;

#define ACTRL_NAME_TABLE_SIZE   15

//
// Comment this out to use the LSA routines directly for every lookup
//
#define USE_NAME_CACHE

#define ACTRL_OBJ_ID_TABLE_SIZE 100


#ifndef PGUID
    typedef GUID *PGUID;
#endif

typedef struct _ACTRL_OBJ_ID_CACHE
{
    PWSTR           pwszName;
    GUID            Guid;
    struct _ACTRL_OBJ_ID_CACHE *pNextName;
    struct _ACTRL_OBJ_ID_CACHE *pNextGuid;
} ACTRL_OBJ_ID_CACHE, *PACTRL_OBJ_ID_CACHE;

//
// This supports the control rights cache.
typedef struct _ACTRL_RIGHTS_CACHE
{
    GUID            ObjectClassGuid;
    ULONG           cRights;
    PWSTR          *RightsList;
    struct _ACTRL_RIGHTS_CACHE *pNext;
}
ACTRL_RIGHTS_CACHE, *PACTRL_RIGHTS_CACHE;

//
// Information on the last access to the DS
//
typedef struct _ACTRL_ID_SCHEMA_INFO
{
    LDAP    LDAP;
    BOOL    fLDAP;
    PWSTR   pwszPath;
    DWORD   LastReadTime;
} ACTRL_ID_SCHEMA_INFO, *PACTRL_ID_SCHEMA_INFO;


//
// Keep the name and sid caches in synch.
// Nodes are only inserted into the name cache, and are merely referenced
// by the sid cache.
extern PACTRL_NAME_CACHE    grgNameCache[ACTRL_NAME_TABLE_SIZE];
extern PACTRL_NAME_CACHE    grgSidCache[ACTRL_NAME_TABLE_SIZE];

extern PACTRL_OBJ_ID_CACHE  grgIdNameCache[ACTRL_OBJ_ID_TABLE_SIZE];
extern PACTRL_OBJ_ID_CACHE  grgIdGuidCache[ACTRL_OBJ_ID_TABLE_SIZE];

extern PACTRL_RIGHTS_CACHE  grgRightsNameCache[ACTRL_OBJ_ID_TABLE_SIZE];

INT
ActrlHashName(PWSTR pwszName);

INT
ActrlHashSid(PSID   pSid);

DWORD
AccctrlInitializeSidNameCache(VOID);

VOID
AccctrlFreeSidNameCache(VOID);

DWORD
AccctrlLookupName(IN  PWSTR          pwszServer,
                  IN  PSID           pSid,
                  IN  BOOL           fAllocateReturn,
                  OUT PWSTR         *ppwszName,
                  OUT PSID_NAME_USE  pSidNameUse);

DWORD
AccctrlLookupSid(IN  PWSTR          pwszServer,
                 IN  PWSTR          pwszName,
                 IN  BOOL           fAllocateReturn,
                 OUT PSID          *ppSid,
                 OUT PSID_NAME_USE  pSidNameUse);

INT
ActrlHashIdName(PWSTR   pwszName);

INT
ActrlHashGuid(PGUID pGuid);

DWORD
AccctrlInitializeIdNameCache(VOID);

VOID
AccctrlFreeIdNameCache(VOID);

DWORD
AccctrlLookupIdName(IN  PLDAP       pLDAP,
                    IN  PWSTR       pwszDsPath,
                    IN  PGUID       pGuid,
                    IN  BOOL        fAllocateReturn,
                    IN  BOOL        fFailUnknownGuid,
                    OUT PWSTR      *ppwszIdName);

DWORD
AccctrlLookupGuid(IN   PLDAP       pLDAP,
                  IN   PWSTR       pwszDsPath,
                  IN   PWSTR       pwszName,
                  IN   BOOL        fAllocateReturn,
                  OUT  PGUID      *ppGuid);

//
// Control rights lookup
//
DWORD
AccctrlInitializeRightsCache(VOID);

VOID
AccctrlFreeRightsCache(VOID);

DWORD
AccctrlLookupRightsByName(IN  PLDAP      pLDAP,
                          IN  PWSTR      pwszDsPath,
                          IN  PWSTR      pwszName,
                          OUT PULONG     pCount,
                          OUT PACTRL_CONTROL_INFOW *ControlInfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\window.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefWindowContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseWindowContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetWindowProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetWindowTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetWindowRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenWindowNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenWindowHandleObject(
    IN  HANDLE               Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT       pContext
    );

DWORD
MartaSetWindowRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newinc\wmiguid.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefWMIGuidContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseWMIGuidContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetWMIGuidProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetWMIGuidTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetWMIGuidRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenWMIGuidNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenWMIGuidHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetWMIGuidRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\aclutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:    aclutil.cxx
//
//  Contents:    utility function(s) for ACL api
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <stdio.h>
    #include <permit.h>
    #include <dsgetdc.h>
    #include <lmapibuf.h>
    #include <wmistr.h>
    #include <ntprov.hxx>
    #include <strings.h>
}

DLLFuncsTable    DLLFuncs;

typedef struct _NAME_RID_INFO {

    PWSTR pwszName;
    ULONG Rid;

} NAME_RID_INFO, *PNAME_RID_INFO;

BOOL NameSidLookupInfoLoaded = FALSE;
NAME_RID_INFO NameSidLookup[] = {
    { NULL, DOMAIN_ALIAS_RID_ACCOUNT_OPS },
    { NULL, DOMAIN_ALIAS_RID_PRINT_OPS },
    { NULL, DOMAIN_ALIAS_RID_SYSTEM_OPS },
    { NULL, DOMAIN_ALIAS_RID_POWER_USERS }
    };


//
// Private functions
//

DWORD AccpLoadLocalizedNameTranslations()
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG Value = 0,i;
    WCHAR wszStringBuffer[ 256];

    RtlAcquireResourceExclusive(&gLocalSidCacheLock, TRUE);

    if ( !NameSidLookupInfoLoaded ) {

        for (i = 0; i < sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO ); i++ )
        {

            switch ( NameSidLookup[ i ].Rid )
            {
            case DOMAIN_ALIAS_RID_ACCOUNT_OPS:
                Value = ACCPROV_ACCOUNT_OPS;
                break;

            case DOMAIN_ALIAS_RID_PRINT_OPS:
                Value = ACCPROV_PRINTER_OPS;
                break;

            case DOMAIN_ALIAS_RID_SYSTEM_OPS:
                Value = ACCPROV_SYSTEM_OPS;
                break;

            case DOMAIN_ALIAS_RID_POWER_USERS:
                Value = ACCPROV_POWER_USERS;
                break;
            }

            if (LoadString(ghDll,
                           Value,
                           wszStringBuffer,
                           sizeof( wszStringBuffer ) / sizeof( WCHAR )) != 0)
            {

                ACC_ALLOC_AND_COPY_STRINGW(wszStringBuffer,
                                           NameSidLookup[ i ].pwszName,
                                           dwErr );
            }
            else
            {
                dwErr = GetLastError();
            }

            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }

        if(dwErr != ERROR_SUCCESS)
        {
            for(i = 0; i< sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO ); i++ )
            {
                LocalFree( NameSidLookup[ i ].pwszName );
                NameSidLookup[ i ].pwszName = NULL;
            }
        }
        else
        {
            NameSidLookupInfoLoaded = TRUE;
        }

    }
    RtlReleaseResource( &gLocalSidCacheLock );

    return( dwErr );
}


DWORD AccpDoSidLookup(IN  PWSTR         pwszServer,
                      IN  PWSTR         pwszName,
                      OUT PSID         *ppSid,
                      OUT SID_NAME_USE *pSidType)
{
#define BASE_DOMAIN_NAME_SIZE 64
#define BASE_SID_SIZE 64

    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   cusid = BASE_SID_SIZE;
    DWORD   crd = BASE_DOMAIN_NAME_SIZE;
    SID_NAME_USE esidtype = SidTypeUnknown;
    WCHAR    domainbuf[BASE_DOMAIN_NAME_SIZE];
    LPWSTR  domain = (LPWSTR)domainbuf;

    domainbuf[0] = L'\0';
    if (LoadString(ghDll,
                   ACCPROV_NTAUTHORITY,
                   domainbuf,
                   sizeof( domainbuf ) / sizeof( WCHAR )) != 0)
    {

        if(_wcsicmp(pwszServer, domainbuf) == 0)
        {

            pwszServer = NULL;
        }
    } else if(_wcsicmp(pwszServer, L"NT AUTHORITY") == 0)
    {

        pwszServer = NULL;
    }

    *ppSid = (PSID)AccAlloc(cusid);

    if(*ppSid == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        if(!LookupAccountName(pwszServer,
                              pwszName,
                              *ppSid,
                              &cusid,
                              domain,
                              &crd,
                              &esidtype))
        {
            dwErr = GetLastError();

            if(dwErr == ERROR_INSUFFICIENT_BUFFER)
            {
                dwErr = ERROR_SUCCESS;

                //
                // if the rooom for the sid was not big enough,
                // grow it.
                //
                if(cusid > BASE_SID_SIZE)
                {
                    AccFree(*ppSid);
                    *ppSid = (PSID)AccAlloc(cusid);
                    if (*ppSid == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {

                    if(crd > BASE_DOMAIN_NAME_SIZE)
                    {
                        domain = (LPWSTR)AccAlloc(crd * sizeof(WCHAR));
                        if (NULL == domain)
                        {
                            AccFree(*ppSid);
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        if(!LookupAccountName(pwszServer,
                                              pwszName,
                                              *ppSid,
                                              &cusid,
                                              domain,
                                              &crd,
                                              &esidtype))
                        {
                            dwErr = GetLastError();
                            AccFree(*ppSid);

                        }
                        if(domain != (LPWSTR)domainbuf)
                        {
                            AccFree(domain);
                        }
                    }
                }
            }
            else if(dwErr != ERROR_SUCCESS)
            {
                AccFree(*ppSid);
                *ppSid = NULL;
            }
        }
        else if(dwErr != ERROR_SUCCESS)
        {
            AccFree(*ppSid);
            *ppSid = NULL;
        }
    }

    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function :  AccLookupAccountSid
//
//  Synopsis :  returns the SID for the specified trustee
//
//  Arguments: [IN  pwszServer]         --  Name of the server to remote the
//                                          call to
//             [IN  pName]              --  the name to lookup the SID for
//             [OUT ppwszName]          --  Where the name is returned
//             [OUT pSidType]           --  Where the SID type is returned
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed.
//              ERROR_INVALID_PARAMETER --  The trustee form was bad
//
//----------------------------------------------------------------------------
DWORD AccLookupAccountSid(IN  PWSTR         pwszServer,
                          IN  PTRUSTEE      pName,
                          OUT PSID         *ppsid,
                          OUT SID_NAME_USE *pSidType)
{

#define BASE_DOMAIN_NAME_SIZE 64
#define BASE_SID_SIZE 64

    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   cusid = BASE_SID_SIZE;
    DWORD   crd = BASE_DOMAIN_NAME_SIZE;
    SID_NAME_USE esidtype = SidTypeUnknown;
    WCHAR    domainbuf[BASE_DOMAIN_NAME_SIZE];
    LPWSTR  domain = (LPWSTR)domainbuf;
    PWSTR   pwszSep;
    PWSTR   pwszTempName;

    if(pName->TrusteeForm == TRUSTEE_IS_SID)
    {
        //
        // Trustee is of form TRUSTEE_IS_SID
        //
        *ppsid = (PSID) AccAlloc( GetLengthSid((PSID)pName->ptstrName) );
        if (*ppsid != NULL)
        {
            if (!CopySid( GetLengthSid((PSID)pName->ptstrName),
                          *ppsid,
                          (PSID)pName->ptstrName))
            {
                dwErr = GetLastError();
                AccFree(*ppsid);
                *ppsid = NULL;
            }
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else if(pName->TrusteeForm == TRUSTEE_IS_NAME)
    {
        //
        // Trustee is of form TRUSTEE_IS_NAME.
        //

        //
        // Check for CURRENT_USER (in which case we get the name from
        // the token)
        //
        if(_wcsicmp(pName->ptstrName, L"CURRENT_USER") == 0)
        {

            HANDLE token_handle;

            dwErr = GetCurrentToken( &token_handle );

            //
            // if we have a token, get the user SID from it
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccGetSidFromToken(pwszServer,
                                           token_handle,
                                           TokenUser,
                                           ppsid);
                CloseHandle(token_handle);
            }
        }
        else
        {
            //
            // if not current user, we have to do a name lookup
            // first allocate a default sid (so the name lookup is not
            // always performed twice.)
            //
            *ppsid = (PSID)AccAlloc(cusid);

            if(*ppsid != NULL)
            {
                if(!LookupAccountName(pwszServer,
                                      pName->ptstrName,
                                      *ppsid,
                                      &cusid,
                                      domain,
                                      &crd,
                                      &esidtype))
                {
                    dwErr = GetLastError();
                    if(dwErr == ERROR_INSUFFICIENT_BUFFER)
                    {
                        dwErr = ERROR_SUCCESS;

                        //
                        // if the rooom for the sid was not big enough,
                        // grow it.
                        //
                        if(cusid > BASE_SID_SIZE)
                        {
                            AccFree(*ppsid);
                            *ppsid = (PSID)AccAlloc(cusid);
                            if (*ppsid == NULL)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {

                            if(crd > BASE_DOMAIN_NAME_SIZE)
                            {
                                domain = (LPWSTR)AccAlloc(crd * sizeof(WCHAR));
                                if (NULL == domain)
                                {
                                    AccFree(*ppsid);
                                    *ppsid = NULL;
                                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            }

                            if(dwErr == ERROR_SUCCESS)
                            {
                                if(!LookupAccountName(pwszServer,
                                                      pName->ptstrName,
                                                      *ppsid,
                                                      &cusid,
                                                      domain,
                                                      &crd,
                                                      &esidtype))
                                {
                                    dwErr = GetLastError();
                                    AccFree(*ppsid);
                                    *ppsid = NULL;
                                }

                                if(crd > BASE_DOMAIN_NAME_SIZE)
                                {
                                    AccFree(domain);
                                }
                            }
                        }
                    }
                    else
                    {
                        //
                        // See if is a translation of a known name
                        //

                        dwErr = AccpLoadLocalizedNameTranslations();

                        *ppsid = NULL;

                        if(dwErr == ERROR_SUCCESS)
                        {

                            //
                            // Check our well known sids
                            //
                            static SID_IDENTIFIER_AUTHORITY UaspBuiltinAuthority =
                                                                        SECURITY_NT_AUTHORITY;
                            DWORD BuiltSid[sizeof(SID)/sizeof(DWORD) + 2 ];
                            PSID pSid = (PSID)BuiltSid;
                            RtlInitializeSid( pSid,
                                              &UaspBuiltinAuthority,
                                              1 );

                            *(RtlSubAuthoritySid(pSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;

                            for( ULONG i = 0;
                                 i < sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO );
                                 i++ )
                            {
                                if ( _wcsicmp( pName->ptstrName, NameSidLookup[ i ].pwszName ) == 0)
                                {
                                    *(RtlSubAuthoritySid(pSid, 1)) = NameSidLookup[ i ].Rid;
                                    break;
                                }
                            }

                            if ( i == sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO ) )
                            {

                                pSid = NULL;
                            }
                            else
                            {
                                dwErr = ERROR_SUCCESS;
                                ACC_ALLOC_AND_COPY_SID(pSid,
                                                       *ppsid,
                                                       dwErr);
                            }

                            }
                        //
                        // See if we have a server name specified in the user name
                        // when we didn't have one provided.
                        //
                        if(pwszServer == NULL)
                        {

                            ACC_ALLOC_AND_COPY_STRINGW(pName->ptstrName,
                                                       pwszTempName,
                                                       dwErr );

                            if(dwErr == ERROR_SUCCESS)
                            {

                                pwszSep = wcschr(pwszTempName, L'\\');

                                if(pwszSep != NULL)
                                {
                                    *pwszSep = L'\0';

                                    dwErr = AccpDoSidLookup(pwszTempName,
                                                            pwszSep + 1,
                                                            ppsid,
                                                            pSidType);

                                    if(dwErr != ERROR_SUCCESS)
                                    {
                                        //
                                        // Ok, may that was a domain name instead of a
                                        // server name
                                        //
                                        PDOMAIN_CONTROLLER_INFOW pDCI = NULL;
                                        dwErr = DsGetDcNameW(NULL,
                                                             pwszTempName,
                                                             NULL,
                                                             NULL,
                                                             0,
                                                             &pDCI);
                                        if(dwErr == ERROR_SUCCESS)
                                        {
                                            dwErr = AccpDoSidLookup(
                                                        pDCI[0].DomainControllerAddress,
                                                        pwszSep + 1,
                                                        ppsid,
                                                        pSidType );

                                            NetApiBufferFree(pDCI);
                                        }

                                    }

                                }

                                LocalFree(pwszTempName);
                            }
                        }

                        //
                        // If for any reason we haven't converted it, go ahead and
                        // dump it as a string.
                        //
                        if(*ppsid == NULL)
                        {
                            dwErr = ConvertStringToSid(pName->ptstrName,
                                                       ppsid);
                        }
                    }
                }
            }
            else
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else
    {
        //
        // Trustee is not of known form
        //
        dwErr = ERROR_INVALID_PARAMETER;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        *pSidType = esidtype;
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function :  AccGetSidFromToken
//
//  Synopsis :  Gets the SID from the given token handle
//
//  Arguments:  IN  pwszServer      --      Name of server to remote the
//                                          call to
//              IN  [hToken]        --      Token handle
//              IN  [TIC]           --      Token information class
//              OUT [ppSidFromToken]--      Where the SID is returned
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD AccGetSidFromToken(IN  PWSTR                    pwszServer,
                         IN  HANDLE                   hToken,
                         IN  TOKEN_INFORMATION_CLASS  TIC,
                         IN  PSID                    *ppSidFromToken)
{
    DWORD   dwErr = ERROR_SUCCESS;

    ULONG   cSize;
    BYTE    bBuf[64];

    PTOKEN_USER pTknUsr = (TOKEN_USER *)bBuf;

    if(GetTokenInformation(hToken,
                           TIC,
                           pTknUsr,
                           sizeof(bBuf),
                           &cSize) == FALSE)
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            dwErr = ERROR_SUCCESS;

            pTknUsr = (PTOKEN_USER)AccAlloc(cSize);
            if(pTknUsr == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                //
                // Now, call it again...
                //
                if(GetTokenInformation(hToken,
                                       TIC,
                                       pTknUsr,
                                       sizeof(bBuf),
                                       &cSize) == FALSE)
                {
                    dwErr = GetLastError();

                    //
                    // deallocate our buffer here, since noone else
                    // will
                    //
                    AccFree(pTknUsr);
                }
            }
        }
    }

    //
    // One way or another, we got the token info, so we'll grab the
    // sid
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // allocate room for the returned sid
        //
        ULONG cSidSize = RtlLengthSid(pTknUsr->User.Sid);
        *ppSidFromToken = (PSID)AccAlloc(cSidSize);
        if(*ppSidFromToken == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // and copy the new sid
            //
            NTSTATUS Status = RtlCopySid(cSidSize,
                                         *ppSidFromToken,
                                         pTknUsr->User.Sid);
            if(!NT_SUCCESS(Status))
            {
                dwErr = RtlNtStatusToDosError(Status);
                AccFree(*ppSidFromToken);
                *ppSidFromToken = NULL;
            }
        }

        //
        // See if we had to allocate
        //
        if(pTknUsr != (PTOKEN_USER)bBuf)
        {
            AccFree(pTknUsr);
        }

    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function :  AccLookupAccountTrustee
//
//  Synopsis :  returns the TRUSTEE for the specified sid
//
//  Arguments:  [IN  pwszServer]    --      The server to remote the call to
//              OUT [pTrustee]      --      the returned trustee
//              IN [pSid]           --      the SID
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD AccLookupAccountTrustee(IN  PWSTR     pwszServer,
                              IN  PSID      pSid,
                              OUT PTRUSTEE *ppTrustee)
{
    #define BASE_TRUSTEE_NAME_SIZE 256

    acDebugOut((DEB_TRACE_ACC, "in  AccLookupAccountTrustee \n"));

    PWSTR           pwszName;
    PWSTR           pwszDomain;
    SID_NAME_USE    SidType;

    DWORD dwErr = AccLookupAccountName(pwszServer,
                                       pSid,
                                       &pwszName,
                                       &pwszDomain,
                                       &SidType);
    if(dwErr == ERROR_SUCCESS)
    {
        PTRUSTEE pTrustee;
        LPWSTR   pName;

        pTrustee = (PTRUSTEE) AccAlloc(sizeof(TRUSTEE) + SIZE_PWSTR(pwszName));
        if(pTrustee != NULL)
        {
            pName = (LPWSTR) ((PBYTE)pTrustee + sizeof(TRUSTEE));
            CopyMemory(pName,
                       pwszName,
                       SIZE_PWSTR(pwszName));

            pTrustee->pMultipleTrustee = NULL;
            pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            pTrustee->TrusteeForm = TRUSTEE_IS_NAME;
            pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
            pTrustee->ptstrName = pName;
            *ppTrustee = pTrustee;

            if(SidType == SidTypeUnknown)
            {
                pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
            }
            else
            {
                pTrustee->TrusteeType = (TRUSTEE_TYPE)(SidType);
            }
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }

        AccFree(pwszName);
        AccFree(pwszDomain);
    }


    acDebugOut((DEB_TRACE_ACC, "out  AccLookupAccountTrustee:%lu\n", dwErr));

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function :  AccLookupAccountName
//
//  Synopsis :  Returns the name for the given SID
//
//  Arguments: [IN  pwszServer]         --  The name of the server to remote
//                                          the call to.
//             [IN  pSid]               --  the SID to lookup the name for
//             [OUT ppwszName]          --  Where the name is returned
//             [OUT pSidType]           --  Where the SID type is returned
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed.
//
//----------------------------------------------------------------------------
DWORD   AccLookupAccountName(IN  PWSTR          pwszServer,
                             IN   PSID          pSid,
                             OUT  LPWSTR       *ppwszName,
                             OUT  LPWSTR       *ppwszDomain,
                             OUT  SID_NAME_USE *pSidType)
{
    #define BASE_TRUSTEE_NAME_SIZE 256
    acDebugOut((DEB_TRACE_ACC,"in  AccLookupAccountName\n"));

    DWORD           dwErr = ERROR_SUCCESS;
    SID_NAME_USE    esidtype = SidTypeUnknown;
    LPWSTR          pwszDomain = NULL;
    LPWSTR          pwszName = NULL;
    ULONG           cName = 0;
    ULONG           cDomain = 0;

    DebugDumpSid("AccLookupAccountName", pSid);

    if(LookupAccountSid(pwszServer,
                        pSid,
                        NULL,
                        &cName,
                        NULL,
                        &cDomain,
                        &esidtype) == FALSE)
    {
        pwszName = NULL;
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            dwErr = ERROR_SUCCESS;

            //
            // Allocate for the name and the domain
            //
            pwszName = (PWSTR)AccAlloc(cName * sizeof(WCHAR));
            if(pwszName != NULL)
            {
                pwszDomain = (PWSTR)AccAlloc(cDomain * sizeof(WCHAR));
                if(pwszDomain == NULL)
                {
                    AccFree(pwszName);
                    pwszName = NULL;
                }
            }

            if(pwszName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }

            if(dwErr == ERROR_SUCCESS)
            {
                if(LookupAccountSid(pwszServer,
                                    pSid,
                                    pwszName,
                                    &cName,
                                    pwszDomain,
                                    &cDomain,
                                    &esidtype) == FALSE)
                {
                    dwErr = GetLastError();
                    AccFree(pwszName);
                    pwszName = NULL;
                    AccFree(pwszDomain);
                    pwszDomain = NULL;
                }
            }
        }
        else // if(dwErr == ERROR_NONE_MAPPED)
        {
            dwErr = AccpLoadLocalizedNameTranslations();

            if(dwErr == ERROR_SUCCESS)
            {

                //
                // Check our well known sids
                //
                static SID_IDENTIFIER_AUTHORITY UaspBuiltinAuthority =
                                                                SECURITY_NT_AUTHORITY;
                DWORD BuiltSid[sizeof(SID)/sizeof(DWORD) + 2 ];
                PSID pKnownSid = (PSID)BuiltSid;
                RtlInitializeSid( pKnownSid,
                                  &UaspBuiltinAuthority,
                                  1 );

                *(RtlSubAuthoritySid(pKnownSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;

                for( ULONG i = 0;i < sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO ); i++)
                {
                    *(RtlSubAuthoritySid(pKnownSid, 1)) = NameSidLookup[ i ].Rid;
                    if ( RtlEqualSid( pKnownSid, pSid ) == TRUE )
                    {
                        ACC_ALLOC_AND_COPY_STRINGW(NameSidLookup[ i ].pwszName,
                                                   pwszName,
                                                   dwErr);
                        break;
                    }
                }
            }

            //
            // If it isn't someone we recognize, convert it to a string..
            //
            if(dwErr == ERROR_SUCCESS && pwszName == NULL)
            {
                //
                // Ok, return the sid as a name
                //
                UCHAR   String[256];
                UNICODE_STRING  SidStr;
                SidStr.Buffer = (PWSTR)String;
                SidStr.Length = SidStr.MaximumLength = 256;

                NTSTATUS Status = RtlConvertSidToUnicodeString(&SidStr,
                                                               pSid,
                                                               FALSE);
                if(NT_SUCCESS(Status))
                {
                    ACC_ALLOC_AND_COPY_STRINGW(SidStr.Buffer,
                                               pwszName,
                                               dwErr);
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(Status);
                }
            }
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
#if 1
        //
        // Convert to RDN
        //
        *ppwszName = pwszName;
        *ppwszDomain = pwszDomain;
        *pSidType  = esidtype;

        ULONG   cLen = wcslen(pwszName);
        if(pwszDomain != NULL && *pwszDomain != L'\0')
        {
            cLen += wcslen(pwszDomain) + 1;
        }

        if(cLen != wcslen(pwszName))
        {
            cLen++;
            PWSTR   pwszFullName = (PWSTR)AccAlloc(cLen * sizeof(WCHAR));
            if(pwszFullName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                 swprintf(pwszFullName,
                          L"%ws\\%ws",
                          pwszDomain,
                          pwszName);
                AccFree(pwszName);
                pwszName = NULL;
                *ppwszName = pwszFullName;
            }
        }
        AccFree(pwszDomain);
        pwszDomain = NULL;
        *ppwszDomain = NULL;

#else
        dwErr = Nt4NameToNt5Name(pwszName,
                                 pwszDomain,
                                 ppwszName);

        if(dwErr == ERROR_SUCCESS)
        {
            AccFree(pwszName);
            *ppwszDomain = pwszDomain;
            *pSidType  = esidtype;
        }
#endif
    }

    if(dwErr != ERROR_SUCCESS)
    {
        AccFree(pwszDomain);
        AccFree(pwszName);
    }

    acDebugOut((DEB_TRACE_ACC,"Out AccLookupAccountName: %lu\n", dwErr));

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function : GetDesiredAccess
//
//  Synopsis : Gets the access required to open object to be able to set or
//             get the specified security info.
//
//  Arguments: IN [SecurityOpenType]  - Flag indicating if the object is to be
//                                      opened to read or write the DACL
//
//----------------------------------------------------------------------------
ACCESS_MASK GetDesiredAccess(IN SECURITY_OPEN_TYPE   OpenType,
                             IN SECURITY_INFORMATION SecurityInfo)
{
    acDebugOut((DEB_TRACE_ACC, "in GetDesiredAccess \n"));

    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    acDebugOut((DEB_TRACE_ACC, "out GetDesiredAccess: %lu\n", DesiredAccess));

    return (DesiredAccess);
}




//+---------------------------------------------------------------------------
//
//  Function : GetSecurityDescriptorParts
//
//  Synopsis : extracts the specified components of a security descriptor
//             It is the responsibility of the invoker to free (using AccFree)
//             any acquired security components.
//
//  Arguments: IN [pSecurityDescriptor]   - the input security descriptor
//             IN [SecurityInfo]   - flag indicating what security info to return
//             OUT [psidOwner]   - the (optional) returned owner sid
//             OUT [psidGroup]   - the (optional) returned group sid
//             OUT [pDacl]   - the (optional) returned DACL
//             OUT [pSacl]   - the (optional) returned SACL
//
//  Returns:
//
//----------------------------------------------------------------------------
DWORD GetSecurityDescriptorParts( IN PISECURITY_DESCRIPTOR pSecurityDescriptor,
                                  IN SECURITY_INFORMATION SecurityInfo,
                                  OUT PSID *psidOwner,
                                  OUT PSID *psidGroup,
                                  OUT PACL *pDacl,
                                  OUT PACL *pSacl,
                                  OUT PSECURITY_DESCRIPTOR *pOutSecurityDescriptor)
{
    acDebugOut((DEB_TRACE_ACC, "in GetSecurityDescriptorParts\n"));
    NTSTATUS Status;
    DWORD    dwErr = ERROR_SUCCESS;

    //
    // if no security descriptor found, don't return one!
    //
    if(psidOwner)
    {
        *psidOwner = NULL;
    }

    if(psidGroup)
    {
        *psidGroup = NULL;
    }

    if(pDacl)
    {
        *pDacl = NULL;
    }

    if(pSacl)
    {
        *pSacl = NULL;
    }

    *pOutSecurityDescriptor = NULL;

    if(pSecurityDescriptor)
    {
        PSID                    owner = NULL, group = NULL;
        PACL                    dacl = NULL, sacl = NULL;
        ULONG                   cSize = sizeof(SECURITY_DESCRIPTOR);
        BOOLEAN                 bDummy, bParmPresent = FALSE;
        PISECURITY_DESCRIPTOR   pOutSD;

        //
        // if the security descriptor is self relative, get absolute
        // pointers to the components
        //
        Status = RtlGetOwnerSecurityDescriptor(pSecurityDescriptor,
                                               &owner,
                                               &bDummy);
        if(NT_SUCCESS(Status))
        {
            Status = RtlGetGroupSecurityDescriptor(pSecurityDescriptor,
                                                   &group,
                                                   &bDummy);
        }

        if(NT_SUCCESS(Status))
        {
            Status = RtlGetDaclSecurityDescriptor(pSecurityDescriptor,
                                                  &bParmPresent,
                                                  &dacl,
                                                  &bDummy);
            if(NT_SUCCESS(Status) && !bParmPresent)
            {
                dacl = NULL;
            }
        }

        if(NT_SUCCESS(Status))
        {
            Status = RtlGetSaclSecurityDescriptor(pSecurityDescriptor,
                                                  &bParmPresent,
                                                  &sacl,
                                                  &bDummy);
            if(NT_SUCCESS(Status) && !bParmPresent)
            {
                sacl = NULL;
            }
        }

        if(NT_SUCCESS(Status))
        {
            //
            // Build the new security descriptor
            //
            cSize = RtlLengthSecurityDescriptor( pSecurityDescriptor ) +
                          sizeof(SECURITY_DESCRIPTOR) - sizeof(SECURITY_DESCRIPTOR_RELATIVE);


            pOutSD = (PISECURITY_DESCRIPTOR)AccAlloc(cSize);
            if(pOutSD == NULL)
            {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            RtlCreateSecurityDescriptor(pOutSD, SECURITY_DESCRIPTOR_REVISION);

            void *bufptr = Add2Ptr(pOutSD, sizeof(SECURITY_DESCRIPTOR));

            if(SecurityInfo & OWNER_SECURITY_INFORMATION)
            {
                if(NULL != owner)
                {
                    //
                    // no error checking as these should not fail!!
                    //
                    RtlCopySid(RtlLengthSid(owner), (PSID)bufptr, owner);
                    RtlSetOwnerSecurityDescriptor(pOutSD,
                                                  (PSID)bufptr, FALSE);
                    bufptr = Add2Ptr(bufptr,RtlLengthSid(owner));
                    if(psidOwner)
                    {
                        *psidOwner = pOutSD->Owner;
                    }
                }
                else
                {
                    AccFree(pOutSD);
                    return(ERROR_NO_SECURITY_ON_OBJECT);
                }
            }

            if(SecurityInfo & GROUP_SECURITY_INFORMATION)
            {
                if(NULL != group)
                {
                    //
                    // no error checking as these should not fail!!
                    //
                    RtlCopySid(RtlLengthSid(group), (PSID)bufptr, group);
                    RtlSetGroupSecurityDescriptor(pOutSD,
                                                  (PSID)bufptr, FALSE);
                    bufptr = Add2Ptr(bufptr,RtlLengthSid(group));
                    if(psidGroup)
                    {
                        *psidGroup = pOutSD->Group;
                    }
                }
                else
                {
                    AccFree(pOutSD);
                    return(ERROR_NO_SECURITY_ON_OBJECT);
                }
            }

            //
            // The DACL and SACL may or may not be on the object.
            //
            if(SecurityInfo & DACL_SECURITY_INFORMATION)
            {
                if(NULL != dacl)
                {
                    RtlCopyMemory(bufptr, dacl, dacl->AclSize);
                    RtlSetDaclSecurityDescriptor(pOutSD,
                           TRUE,
                           (ACL *)bufptr,
                           FALSE);
                    if(pDacl)
                    {
                        *pDacl = pOutSD->Dacl;
                    }
                }
            }

            if(SecurityInfo & SACL_SECURITY_INFORMATION)
            {
                if(NULL != sacl)
                {
                    RtlCopyMemory(bufptr, sacl, sacl->AclSize);
                    RtlSetSaclSecurityDescriptor(pOutSD,
                                                 TRUE,
                                                 (PACL)bufptr,
                                                 FALSE);
                    if(pSacl)
                    {
                        *pSacl = pOutSD->Sacl;
                    }
                }
            }

            *pOutSecurityDescriptor = pOutSD;
        }

        if(!NT_SUCCESS(Status))
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }
    acDebugOut((DEB_TRACE_ACC, "Out GetSecurityDescriptorParts(%d)\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function : ParseName
//
//  Synopsis : parses a UNC name for the machine name
//
//  Arguments: [IN OUT pObjectName] --      the name of the object
//             [OUT pMachineName]   --      the machine the object is on
//             [OUT pRemainingName] --      the remaining name after the
//                                          machine name
//
//  Returns:    ERROR_SUCCESS       --      The call succeeded
//
//----------------------------------------------------------------------------
DWORD ParseName(IN OUT  LPWSTR  pObjectName,
                OUT     LPWSTR *pMachineName,
                OUT     LPWSTR *pRemainingName)
{
    acDebugOut((DEB_TRACE_ACC, "in/out  ParseName \n"));

    if(pObjectName == wcsstr(pObjectName, L"\\\\"))
    {
        *pMachineName = pObjectName + 2;
        *pRemainingName =  wcschr(*pMachineName, L'\\');
        if (*pRemainingName != NULL)
        {
            **pRemainingName = L'\0';
            *pRemainingName += 1;
        }
    }
    else
    {
        *pMachineName = NULL;
        *pRemainingName = pObjectName;
    }

    return(ERROR_SUCCESS);
}




//+---------------------------------------------------------------------------
//
//  Function:   DoTrusteesMatch
//
//  Synopsis:   Determines if 2 trustess reference the same thing (ie:
//              (are they equal)
//
//  Arguments:  [IN  pwszServer]        --  Server to lookup information on
//              [IN  pTrustee1]         --  First trustee
//              [IN  pTrustee2]         --  Second trustee
//              [OUT pfMatch]           --  Where the match results are
//                                          returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DoTrusteesMatch(IN  PWSTR       pwszServer,
                IN  PTRUSTEE    pTrustee1,
                IN  PTRUSTEE    pTrustee2,
                IN  PBOOL       pfMatch)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Assume failure...
    //
    *pfMatch = FALSE;

    //
    // Make sure they are the same type...
    //
    if(pTrustee1->MultipleTrusteeOperation ==
                                        pTrustee2->MultipleTrusteeOperation)
    {
        //
        // Ok, first compare the base trustee information...
        //
        if(pTrustee1->TrusteeForm == pTrustee2->TrusteeForm)
        {
            //
            // Now, the trustee form...  If they match, it's easy... Otherwise,
            // we'll have to do some lookups...
            //
            if(pTrustee1->TrusteeForm == pTrustee2->TrusteeForm)
            {
                if(pTrustee1->TrusteeForm == TRUSTEE_IS_NAME)
                {
                    if(_wcsicmp(pTrustee1->ptstrName,
                                pTrustee2->ptstrName) == 0)
                    {
                        *pfMatch = TRUE;
                    }
                }
                else
                {
                    *pfMatch = RtlEqualSid((PSID)(pTrustee1->ptstrName),
                                          (PSID)(pTrustee2->ptstrName));
                }
            }
        }
        else
        {
            //
            // We'll look it up...
            //
            PSID        pKnownSid;
            PTRUSTEE    pLookupTrustee;
            if(pTrustee1->TrusteeForm == TRUSTEE_IS_NAME)
            {
                pLookupTrustee = pTrustee1;
                pKnownSid = (PSID)pTrustee2->ptstrName;
            }
            else
            {
                pLookupTrustee = pTrustee2;
                pKnownSid = (PSID)pTrustee1->ptstrName;
            }

            PSID            pNewSid;
            SID_NAME_USE    SidType;
            dwErr = AccctrlLookupSid(pwszServer,
                                     pLookupTrustee->ptstrName,
                                     TRUE,
                                     &pNewSid,
                                     &SidType);
            if(dwErr == ERROR_SUCCESS)
            {
                *pfMatch = RtlEqualSid(pKnownSid,
                                       pNewSid);
                AccFree(pNewSid);
            }
        }

        //
        // Now, if that worked, look for the multiple trustee case
        //
        if(dwErr == ERROR_SUCCESS && *pfMatch == TRUE &&
                pTrustee1->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
        {
            dwErr = DoTrusteesMatch(pwszServer,
                                    pTrustee1->pMultipleTrustee,
                                    pTrustee2->pMultipleTrustee,
                                    pfMatch);
        }
    }
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccessMaskForAccessEntry
//
//  Synopsis:   Converts a Provider Independent access entry to an NT
//              access mask format.
//
//  Arguments:  [IN     pAE]            --  The access entry that gets
//                                          converted
//
//  Returns:    Converted acess mask
//
//  Notes:
//
//----------------------------------------------------------------------------
ACCESS_MASK
AccessMaskForAccessEntry(IN PACTRL_ACCESS_ENTRY  pAE,
                         IN  SE_OBJECT_TYPE      ObjType)
{
    ACCESS_MASK RetMask = 0;

    //
    // We have some standard rights, so we'll add those in
    //
    if((pAE->Access & (ACTRL_STD_RIGHTS_ALL)) != 0)
    {
        RetMask = (pAE->Access & ACTRL_STD_RIGHTS_ALL) >> 11;
    }

    if((pAE->Access & (ACTRL_SYSTEM_ACCESS)) != 0)
    {
        RetMask |= ACCESS_SYSTEM_SECURITY;
    }

    //
    // Then, we or in the rest of the access bits, plus the provider specific
    // bits.
    //
    RetMask |= (pAE->Access & ~(ACTRL_STD_RIGHTS_ALL | ACTRL_SYSTEM_ACCESS));
    RetMask |= pAE->ProvSpecificAccess;

    //
    // Handle any special case stuff here
    //
    switch (ObjType)
    {
    case SE_FILE_OBJECT:
    case SE_SERVICE:
    case SE_PRINTER:
    case SE_REGISTRY_KEY:
    case SE_LMSHARE:
    case SE_KERNEL_OBJECT:
    case SE_WINDOW_OBJECT:
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
    default:
        break;
    }

    return(RetMask);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccConvertAccessMaskToActrlAccess
//
//  Synopsis:   Converts an NT access mask to the appropriate Provider
//              Independent format.
//
//  Arguments:  [IN     Access]         --  Access mask to convert
//              [IN     ObjType]        --  Type of the object
//              [IN     KernelObjectType]   If this is a kernel object, the type of the
//                                          object
//              [IN     pAE]            --  The access entry that gets
//                                          modified
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
AccConvertAccessMaskToActrlAccess(IN  ACCESS_MASK           Access,
                                  IN  SE_OBJECT_TYPE        ObjType,
                                  IN  MARTA_KERNEL_TYPE     KernelObjectType,
                                  IN  PACTRL_ACCESS_ENTRY   pAE)
{

    //
    // Ok, first thing we'll have to do is look for and remove any generic
    // rights.
    //
    GENERIC_MAPPING GenMap = {0, 0, 0, 0};
    switch(ObjType)
    {
    case SE_FILE_OBJECT:
    case SE_LMSHARE:
        GenMap.GenericRead    = FILE_GENERIC_READ;
        GenMap.GenericWrite   = FILE_GENERIC_WRITE;
        GenMap.GenericExecute = FILE_GENERIC_EXECUTE;
        GenMap.GenericAll     = FILE_ALL_ACCESS;
        break;

    case SE_SERVICE:
        GenMap.GenericRead    =  STANDARD_RIGHTS_READ               |
                                    SERVICE_QUERY_CONFIG            |
                                    SERVICE_QUERY_STATUS            |
                                    SERVICE_ENUMERATE_DEPENDENTS    |
                                    SERVICE_INTERROGATE;

        GenMap.GenericWrite   = STANDARD_RIGHTS_WRITE               |
                                    SERVICE_CHANGE_CONFIG;

        GenMap.GenericExecute = STANDARD_RIGHTS_EXECUTE             |
                                    SERVICE_START                   |
                                    SERVICE_STOP                    |
                                    SERVICE_PAUSE_CONTINUE          |
                                    SERVICE_USER_DEFINED_CONTROL;

        GenMap.GenericAll     = SERVICE_ALL_ACCESS;
        break;

    case SE_PRINTER:
        GenMap.GenericRead    = PRINTER_READ;
        GenMap.GenericWrite   = PRINTER_WRITE;
        GenMap.GenericExecute = PRINTER_EXECUTE;
        GenMap.GenericAll     = PRINTER_ALL_ACCESS;
        break;

    case SE_REGISTRY_KEY:
        GenMap.GenericRead    = KEY_READ;
        GenMap.GenericWrite   = KEY_WRITE;
        GenMap.GenericExecute = KEY_EXECUTE;
        GenMap.GenericAll     = KEY_ALL_ACCESS;
        break;

    case SE_KERNEL_OBJECT:
        switch ( KernelObjectType )
        {
//        case MARTA_WMI_GUID:
//            GenMap.GenericRead    = WMIGUID_QUERY;
//            GenMap.GenericWrite   = WMIGUID_SET;
//            GenMap.GenericExecute = WMIGUID_EXECUTE;
//            GenMap.GenericAll     = WMIGUID_QUERY | WMIGUID_SET | WMIGUID_EXECUTE;
//            break;

        case MARTA_EVENT:
        case MARTA_EVENT_PAIR:
        case MARTA_MUTANT:
        case MARTA_PROCESS:
        case MARTA_SECTION:
        case MARTA_SEMAPHORE:
        case MARTA_SYMBOLIC_LINK:
        case MARTA_THREAD:
        case MARTA_TIMER:
        case MARTA_JOB:
        default:
            GenMap.GenericRead    = STANDARD_RIGHTS_READ     | 0x1;
            GenMap.GenericWrite   = STANDARD_RIGHTS_WRITE    | 0x2;
            GenMap.GenericExecute = STANDARD_RIGHTS_EXECUTE  | 0x4;
            GenMap.GenericAll     = STANDARD_RIGHTS_REQUIRED | 0xFFFF;
            break;

        }
        break;

    case SE_WINDOW_OBJECT:
        GenMap.GenericRead    = STANDARD_RIGHTS_READ     | 0x1;
        GenMap.GenericWrite   = STANDARD_RIGHTS_WRITE    | 0x2;
        GenMap.GenericExecute = STANDARD_RIGHTS_EXECUTE  | 0x4;
        GenMap.GenericAll     = STANDARD_RIGHTS_REQUIRED | 0x1FF;
        break;

    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
        GenMap.GenericRead    = GENERIC_READ_MAPPING;
        GenMap.GenericWrite   = GENERIC_WRITE_MAPPING;
        GenMap.GenericExecute = GENERIC_EXECUTE_MAPPING;
        GenMap.GenericAll     = GENERIC_ALL_MAPPING;
        break;
    }

    MapGenericMask(&Access,
                   &GenMap);

    //
    // Look for the known entries first
    //
    if((Access & STANDARD_RIGHTS_ALL) != 0)
    {
        pAE->Access = (Access & STANDARD_RIGHTS_ALL) << 11;
    }

    if((Access & ACCESS_SYSTEM_SECURITY) != 0)
    {
        pAE->Access |= ACTRL_SYSTEM_ACCESS;
    }

    //
    // Add in the remaining rights
    //
    pAE->Access |= (Access & ~(STANDARD_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY ));

}




//+---------------------------------------------------------------------------
//
//  Function:  LoadDLLFuncTable
//
//  Synopsis:
//
//  Arguments:
//+---------------------------------------------------------------------------
DWORD
LoadDLLFuncTable()
{
    DWORD dwErr;

    if( !(DLLFuncs.dwFlags & LOADED_ALL_FUNCS))
    {
        HINSTANCE NetApiHandle = NULL;
        HINSTANCE SamLibHandle = NULL;
        HINSTANCE WinspoolHandle = NULL;

        //
        // Load the functions needed from netapi32.dll
        //
        NetApiHandle = LoadLibraryA( "NetApi32" );
        if(NetApiHandle == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PNetApiBufferFree = (PNET_API_BUFFER_FREE)
            GetProcAddress( NetApiHandle, "NetApiBufferFree");
        if(DLLFuncs.PNetApiBufferFree == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PNetShareGetInfo = (PNET_SHARE_GET_INFO)
            GetProcAddress( NetApiHandle, "NetShareGetInfo");
        if(DLLFuncs.PNetShareGetInfo == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PNetShareSetInfo = (PNET_SHARE_SET_INFO)
            GetProcAddress( NetApiHandle, "NetShareSetInfo");
        if(DLLFuncs.PNetShareSetInfo == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PNetDfsGetInfo = (PNET_DFS_GET_INFO)
            GetProcAddress( NetApiHandle, "NetDfsGetInfo");
        if(DLLFuncs.PNetDfsGetInfo == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PI_NetGetDCList = (PINET_GET_DC_LIST)
            GetProcAddress( NetApiHandle, "I_NetGetDCList");
        if(DLLFuncs.PI_NetGetDCList == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        //
        // Load the functions needed from samlib.dll
        //
        SamLibHandle = LoadLibraryA( "Samlib" );
        if(SamLibHandle == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamCloseHandle = (PSAM_CLOSE_HANDLE)
            GetProcAddress( SamLibHandle, "SamCloseHandle");
        if(DLLFuncs.PSamCloseHandle == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamOpenDomain = (PSAM_OPEN_DOMAIN)
            GetProcAddress( SamLibHandle, "SamOpenDomain");
        if(DLLFuncs.PSamOpenDomain == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamConnect = (PSAM_CONNECT)
            GetProcAddress( SamLibHandle, "SamConnect");
        if(DLLFuncs.PSamConnect == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamGetMembersInGroup = (PSAM_GET_MEMBERS_IN_GROUP)
            GetProcAddress( SamLibHandle, "SamGetMembersInGroup");
        if(DLLFuncs.PSamGetMembersInGroup == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamOpenGroup = (PSAM_OPEN_GROUP)
            GetProcAddress( SamLibHandle, "SamOpenGroup");
        if(DLLFuncs.PSamOpenGroup == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamGetMembersInAlias = (PSAM_GET_MEMBERS_IN_ALIAS)
            GetProcAddress( SamLibHandle, "SamGetMembersInAlias");
        if(DLLFuncs.PSamGetMembersInAlias == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamOpenAlias = (PSAM_OPEN_ALIAS)
            GetProcAddress( SamLibHandle, "SamOpenAlias");
        if(DLLFuncs.PSamOpenAlias == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        //
        // Load functions from winspool.drv
        //

        WinspoolHandle = LoadLibraryA( "winspool.drv" );
        if(WinspoolHandle == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.POpenPrinter = (POPEN_PRINTER)
            GetProcAddress( WinspoolHandle, "OpenPrinterW");
        if(DLLFuncs.POpenPrinter == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PClosePrinter = (PCLOSE_PRINTER)
            GetProcAddress( WinspoolHandle, "ClosePrinter");
        if(DLLFuncs.PClosePrinter == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSetPrinter = (PSET_PRINTER)
            GetProcAddress( WinspoolHandle, "SetPrinterW");
        if(DLLFuncs.PSetPrinter == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PGetPrinter = (PGET_PRINTER)
            GetProcAddress( WinspoolHandle, "GetPrinterW");
        if(DLLFuncs.PGetPrinter == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }


        DLLFuncs.dwFlags |= LOADED_ALL_FUNCS;
    }

    return (NO_ERROR);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccSetEntriesInAList
//
//  Synopsis:   Helper function.  Adds the given access entries to an optional
//              existing list, and returns the resultant list
//
//  Arguments:  [IN  cEntries]      --  Number of items to add
//              [IN  pAccessEntryList]  List to add
//              [IN  AccessMode]    --  How to do the add (MERGE or SET)
//              [IN  lpProperty]    --  Property to do the add for
//              [IN  fDoOldStyleMerge]  If TRUE, does an NT4 ACLAPI style
//                                      merge (Existing explicit entries are
//                                      removed).  Otherwise, and new style
//                                      merge is done.
//              [IN  pOldList]      --  Optional.  If present, the new items
//                                      are merged with this list [assuming a
//                                      merge operation].
//              [OUT ppNewList]     --  Where the new list is returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
AccSetEntriesInAList(IN  ULONG                 cEntries,
                     IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                     IN  ACCESS_MODE           AccessMode,
                     IN  SECURITY_INFORMATION  SeInfo,
                     IN  LPCWSTR              lpProperty,
                     IN  BOOL                  fDoOldStyleMerge,
                     IN  PACTRL_AUDITW         pOldList,
                     OUT PACTRL_AUDITW        *ppNewList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, a little parameter validation...
    //
    if(pAccessEntryList == NULL || ppNewList == NULL ||
       (SeInfo != SACL_SECURITY_INFORMATION &&
                                         SeInfo != DACL_SECURITY_INFORMATION))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CAccessList AccList;
        dwErr = AccList.SetObjectType(SE_UNKNOWN_OBJECT_TYPE);

        if(dwErr == ERROR_SUCCESS)
        {
            if(pOldList != NULL && AccessMode != SET_ACCESS)
            {
                dwErr = AccList.AddAccessLists(SeInfo,
                                               pOldList,
                                               FALSE);
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // We need to build a ACTRL_ALIST
            //
            ACTRL_ACCESSW           AList;
            ACTRL_PROPERTY_ENTRY    APE;
            ACTRL_ACCESS_ENTRY_LIST AAEL;

            AAEL.cEntries    = cEntries;
            AAEL.pAccessList = pAccessEntryList;

            APE.lpProperty       = (PWSTR)lpProperty;
            APE.pAccessEntryList = &(AAEL);
            APE.fListFlags       = 0;

            AList.cEntries            = 1;
            AList.pPropertyAccessList = &APE;

            //
            // Now, we'll just do another add...
            //
            if(AccessMode == REVOKE_ACCESS)
            {
                dwErr = AccList.RevokeTrusteeAccess(SeInfo,
                                                    &AList,
                                                    (PWSTR)lpProperty);
            }
            else
            {
                dwErr = AccList.AddAccessLists(SeInfo,
                                               &AList,
                                               AccessMode == GRANT_ACCESS ?
                                                                    TRUE  :
                                                                    FALSE,
                                               fDoOldStyleMerge);

            }
        }

        //
        // If all of that worked, we'll simply marshal it up, and return it
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccList.MarshalAccessLists(
                                        SeInfo,
                                        FLAG_ON(SeInfo,
                                                DACL_SECURITY_INFORMATION) ?
                                                                ppNewList  :
                                                                NULL,
                                        FLAG_ON(SeInfo,
                                                SACL_SECURITY_INFORMATION) ?
                                                                ppNewList  :
                                                                NULL);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccConvertAccessToSecurityDescriptor
//
//  Synopsis:   Helper function.  Converts a set of access lists and owner/
//              group into a security descriptor.  Only items that are present
//              are added.
//
//  Arguments:  [IN  pAccessList]   --  OPTIONAL.  Access list to convert
//              [IN  pAuditList]    --  OPTIONAL.  Audit list to add
//              [IN  lpOwner]       --  OPTIONAL.  Owner to add
//              [IN  lpGroup]       --  OPTIONAL.  Group to add
//              [OUT ppSecDescriptor]   Where the created security descriptor
//                                      is returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned security descriptor must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccConvertAccessToSecurityDescriptor(IN  PACTRL_ACCESSW        pAccessList,
                                     IN  PACTRL_AUDITW         pAuditList,
                                     IN  LPCWSTR               lpOwner,
                                     IN  LPCWSTR               lpGroup,
                                     OUT PSECURITY_DESCRIPTOR *ppSecDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, verify the parameters.  At least one has to be present
    //
    if(pAccessList == NULL && pAuditList == NULL && lpOwner == NULL &&
                                                              lpGroup == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Initialize our access lists
        //
        CAccessList AccList;

        TRUSTEE_W   Group;
        TRUSTEE_W   Owner;

        dwErr = AccList.SetObjectType(SE_UNKNOWN_OBJECT_TYPE);

        if(dwErr == ERROR_SUCCESS && lpGroup != NULL)
        {
            memset(&Group, 0, sizeof(TRUSTEE_W));
            Group.TrusteeForm = TRUSTEE_IS_NAME;
            Group.ptstrName = (PWSTR)lpGroup;
            dwErr = AccList.AddOwnerGroup(GROUP_SECURITY_INFORMATION,
                                          NULL,
                                          &Group);

        }

        if(dwErr == ERROR_SUCCESS && lpOwner)
        {
            memset(&Owner, 0, sizeof(TRUSTEE_W));
            Owner.TrusteeForm = TRUSTEE_IS_NAME;
            Owner.ptstrName = (PWSTR)lpOwner;
            dwErr = AccList.AddOwnerGroup(OWNER_SECURITY_INFORMATION,
                                          &Owner,
                                          NULL);
        }

        if(dwErr == ERROR_SUCCESS && pAccessList != NULL)
        {
            dwErr = AccList.AddAccessLists(DACL_SECURITY_INFORMATION,
                                           pAccessList,
                                           FALSE);
        }

        if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
        {
            dwErr = AccList.AddAccessLists(SACL_SECURITY_INFORMATION,
                                           pAuditList,
                                           FALSE);
        }

        //
        // Now, build the Security Descriptor
        //
        if(dwErr == ERROR_SUCCESS)
        {
            SECURITY_INFORMATION    SeInfo;
            dwErr = AccList.BuildSDForAccessList(ppSecDescriptor,
                                                 &SeInfo,
                                                 ACCLIST_SD_ABSOK   |
                                                           ACCLIST_SD_NOFREE);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccConvertSDToAccess
//
//  Synopsis:   Helper function.  "Cracks" a security descriptor into the
//              associated access lists and owner/group.  Only the OUT
//              parameters that are supplied will be cracked
//
//  Arguments:  [IN  ObjectType]    --  What type of object the security
//                                      descriptor came from
//              [IN  pSecDescriptor]--  Security descriptor to crack
//              [OUT ppAccessList]  --  OPTIONAL.  Where the access list is
//                                      returned.
//              [OUT ppAuditList]   --  OPTIONAL.  Where the audit list is
//                                      returned
//              [OUT lppOwner]      --  OPTIONAL.  Where the owner is returned
//              [OUT lppGroup]      --  OPTIONAL.  Where the group is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned items must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccConvertSDToAccess(IN  SE_OBJECT_TYPE       ObjectType,
                     IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                     OUT PACTRL_ACCESSW      *ppAccessList,
                     OUT PACTRL_AUDITW       *ppAuditList,
                     OUT LPWSTR              *lppOwner,
                     OUT LPWSTR              *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Make sure we have valid parameters
    //
    if(pSecDescriptor == NULL || ObjectType == SE_UNKNOWN_OBJECT_TYPE)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Make sure we have something to do
        //
        SECURITY_INFORMATION    SeInfo = 0;

        if(ppAccessList != NULL)
        {
            SeInfo |= DACL_SECURITY_INFORMATION;
        }

        if(ppAuditList != NULL)
        {
            SeInfo |= SACL_SECURITY_INFORMATION;
        }

        if(lppOwner != NULL)
        {
            SeInfo |= OWNER_SECURITY_INFORMATION;
        }

        if(lppGroup != NULL)
        {
            SeInfo |= GROUP_SECURITY_INFORMATION;
        }

        if(SeInfo != 0)
        {
            CAccessList AccList;

            dwErr = AccList.SetObjectType(ObjectType);

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccList.AddSD(pSecDescriptor,
                                      SeInfo,
                                      NULL);

                //
                // Now, build our individual lists from it...
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AccList.MarshalAccessLists(SeInfo,
                                                       ppAccessList,
                                                       ppAuditList);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // Save off the strings
                        //
                        if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                        {
                            PTRUSTEE_W  pOwner;

                            dwErr = AccList.GetSDSidAsTrustee(
                                            OWNER_SECURITY_INFORMATION,
                                            &pOwner);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                ACC_ALLOC_AND_COPY_STRINGW(
                                                        pOwner->ptstrName,
                                                       *lppOwner,
                                                        dwErr);
                                AccFree(pOwner);
                            }
                        }

                        if(FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                        {
                            PTRUSTEE_W  pGroup;

                            dwErr = AccList.GetSDSidAsTrustee(
                                            GROUP_SECURITY_INFORMATION,
                                            &pGroup);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                ACC_ALLOC_AND_COPY_STRINGW(
                                                    pGroup->ptstrName,
                                                    *lppGroup,
                                                    dwErr);
                                AccFree(pGroup);
                            }

                            if(dwErr != ERROR_SUCCESS &&
                               FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                            {
                                AccFree(*lppOwner);
                            }
                        }

                        if(dwErr != ERROR_SUCCESS)
                        {
                            if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                            {
                                AccFree(ppAccessList);
                            }

                            if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                            {
                                AccFree(ppAuditList);
                            }
                        }
                    }
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccGetAccessForTrustee
//
//  Synopsis:   Helper function.  Determines the access/audits for the
//              given trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to check access for
//              [IN  pAcl]          --  Acl to get information from
//              [IN  SeInfo]        --  Whether to handle this as an access or
//                                      audit list
//              [IN  pwszProperty]  --  Property on the acl to use
//              [OUT pAllowed]      --  Where the allowed/success mask is
//                                      returned
//              [OUT pDenied]       --  Where the denied/failure mask is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned items must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccGetAccessForTrustee(IN PTRUSTEE                  pTrustee,
                       IN PACL                      pAcl,
                       IN SECURITY_INFORMATION      SeInfo,
                       IN PWSTR                     pwszProperty,
                       IN PACCESS_RIGHTS            pAllowed,
                       IN PACCESS_RIGHTS            pDenied)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, initialize our access list
    //
    CAccessList AccList;

    PACL    pDAcl = NULL, pSAcl = NULL;

    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        pDAcl = pAcl;
    }
    else
    {
        pSAcl = pAcl;
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccList.AddAcl(pDAcl,
                               pSAcl,
                               NULL,
                               NULL,
                               SeInfo,
                               NULL,
                               TRUE);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, get the rights..
        //
        if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
        {
            dwErr = AccList.GetExplicitAccess(pTrustee,
                                              pwszProperty,
                                              pDenied,
                                              pAllowed);
        }
        else
        {
            dwErr = AccList.GetExplicitAudits(pTrustee,
                                              pwszProperty,
                                              pDenied,
                                              pAllowed);
        }
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   AccConvertAclToAccess
//
//  Synopsis:   Helper function. Converts an ACL into access lists
//
//  Arguments:  [IN  ObjectType]    --  Type of object the acl came from
//              [IN  pAcl]          --  Acl to convert
//              [OUT ppAccessList]  --  Where to return the access list
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned items must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccConvertAclToAccess(IN  SE_OBJECT_TYPE       ObjectType,
                      IN  PACL                 pAcl,
                      OUT PACTRL_ACCESSW      *ppAccessList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Make sure we have valid parameters
    //
    if(pAcl == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CAccessList AccList;

        dwErr = AccList.SetObjectType(ObjectType);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccList.AddAcl(pAcl,
                                   NULL,
                                   NULL,
                                   NULL,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   TRUE);

            //
            // Now, build our individual lists from it...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccList.MarshalAccessLists(DACL_SECURITY_INFORMATION,
                                                   ppAccessList,
                                                   NULL);
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccConvertAccessToSD
//
//  Synopsis:   Helper function.  Converts a set of access lists and owner/
//              group into a security descriptor.
//
//  Arguments:  [IN  ObjectType]    --  Type of object to add
//              [IN  SeInfo]        --  Items being set in the SD
//              [IN  pAccessList]   --  OPTIONAL.  Access list to convert
//              [IN  pAuditList]    --  OPTIONAL.  Audit list to add
//              [IN  lpOwner]       --  OPTIONAL.  Owner to add
//              [IN  lpGroup]       --  OPTIONAL.  Group to add
//              [IN  fOpts]         --  Options to use when building the SD
//              [OUT ppSecDescriptor]   Where the created security descriptor
//                                      is returned.
//              [OUT pcSDSize]      --  Where the size of the security descriptor
//                                      is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned security descriptor must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccConvertAccessToSD(IN  SE_OBJECT_TYPE         ObjectType,
                     IN  SECURITY_INFORMATION   SeInfo,
                     IN  PACTRL_ACCESSW         pAccessList,
                     IN  PACTRL_AUDITW          pAuditList,
                     IN  LPWSTR                 lpOwner,
                     IN  LPWSTR                 lpGroup,
                     IN  ULONG                  fOpts,
                     OUT PSECURITY_DESCRIPTOR  *ppSD,
                     OUT PULONG                 pcSDSize)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, verify the parameters.
    //
    if(ObjectType > SE_PROVIDER_DEFINED_OBJECT || ppSD == NULL || pcSDSize == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) &&
                                                        pAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) &&
                                                        pAuditList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Initialize our access lists
        //
        CAccessList AccList;

        TRUSTEE_W   Group;
        TRUSTEE_W   Owner;

        dwErr = AccList.SetObjectType(ObjectType);

        if(dwErr == ERROR_SUCCESS && lpGroup != NULL)
        {
            memset(&Group, 0, sizeof(TRUSTEE_W));
            Group.TrusteeForm = TRUSTEE_IS_NAME;
            Group.ptstrName = (PWSTR)lpGroup;
            dwErr = AccList.AddOwnerGroup(GROUP_SECURITY_INFORMATION,
                                          NULL,
                                          &Group);

        }

        if(dwErr == ERROR_SUCCESS && lpOwner)
        {
            memset(&Owner, 0, sizeof(TRUSTEE_W));
            Owner.TrusteeForm = TRUSTEE_IS_NAME;
            Owner.ptstrName = (PWSTR)lpOwner;
            dwErr = AccList.AddOwnerGroup(OWNER_SECURITY_INFORMATION,
                                          &Owner,
                                          NULL);
        }

        if(dwErr == ERROR_SUCCESS && pAccessList != NULL)
        {
            dwErr = AccList.AddAccessLists(DACL_SECURITY_INFORMATION,
                                           pAccessList,
                                           FALSE);
        }

        if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
        {
            dwErr = AccList.AddAccessLists(SACL_SECURITY_INFORMATION,
                                           pAuditList,
                                           FALSE);
        }

        //
        // Now, build the Security Descriptor
        //
        if(dwErr == ERROR_SUCCESS)
        {
            SECURITY_INFORMATION    LocalSeInfo;
            dwErr = AccList.BuildSDForAccessList(ppSD,
                                                 &LocalSeInfo,
                                                 ACCLIST_SD_NOFREE      |
                                                 FLAG_ON(fOpts,
                                                         ACCCONVERT_SELF_RELATIVE) ? 0 :
                                                                            ACCLIST_SD_ABSOK
                                                 );

            if(dwErr == ERROR_SUCCESS)
            {
                *pcSDSize = AccList.QuerySDSize();
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccGetExplicitEntries
//
//  Synopsis:   Helper function. Gets the list of explicit entries for
//              the given trustee from the acl.
//
//  Arguments:  [IN  pTrustee]      --  Trustee to get the list for
//              [IN  ObjectType]    --  Type of object the acl came from
//              [IN  pAcl]          --  Acl to examine
//              [IN  pwszProperty]  --  Which acl property to examine
//              [OUT pcEntries]     --  Where the count of entries is returned
//              [OUT ppAEList]      --  Where the list of explicit entries
//                                      is returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned list must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccGetExplicitEntries(IN  PTRUSTEE              pTrustee,
                      IN  SE_OBJECT_TYPE        ObjectType,
                      IN  PACL                  pAcl,
                      IN  PWSTR                 pwszProperty,
                      OUT PULONG                pcEntries,
                      OUT PACTRL_ACCESS_ENTRYW *ppAEList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Make sure we have valid parameters
    //
    if(pAcl == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CAccessList AccList;

        dwErr = AccList.SetObjectType(ObjectType);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccList.AddAcl(pAcl,
                                   NULL,
                                   NULL,
                                   NULL,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   TRUE);

            //
            // Now, build our individual lists from it...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccList.GetExplicitEntries(pTrustee,
                                                   pwszProperty,
                                                   DACL_SECURITY_INFORMATION,
                                                   pcEntries,
                                                   ppAEList);
            }
        }
    }

    return(dwErr);
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertStringToSid
//
//  Synopsis:   Converts a string representation of a SID back into a SID.
//              This is the converse of RtlConvertSidToUnicode.  If a non-
//              SID string is given, an error is returned.
//
//  Arguments:  [IN  pwszString]    --  String to convert
//              [OUT ppSid]         --  Where the convertd sid is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NONE_MAPPED   --  The given string does not represent
//                                      a SID
//
//  Notes:      The returned sid must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertStringToSid(IN  PWSTR    pwszString,
                   OUT PSID    *ppSid)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(wcslen(pwszString) < 2 ||
                           (*pwszString != L'S' && *(pwszString + 1) != L'-'))
    {
        return(ERROR_NONE_MAPPED);
    }

    acDebugOut((DEB_TRACE_SID, "Converting %ws to sid\n", pwszString));

    UCHAR                       Revision;
    UCHAR                       cSubs;
    SID_IDENTIFIER_AUTHORITY    IDAuth;
    PULONG                      pSubAuth = NULL;
    PWSTR                       pwszEnd;

    PWSTR   pwszCurr = pwszString + 2;

    Revision = (UCHAR)wcstol(pwszCurr, &pwszEnd, 10);

    pwszCurr = pwszEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    PWSTR   pwszNext = wcschr(pwszCurr, L'-');

    if(pwszNext - pwszCurr == 6)
    {
        for(ULONG iIndex = 0; iIndex < 6; iIndex++)
        {
            IDAuth.Value[iIndex] = (UCHAR)pwszNext[iIndex];
        }

        pwszCurr +=6;
    }
    else
    {
         IDAuth.Value[0] = IDAuth.Value[1] = 0;
         ULONG Auto = wcstoul(pwszCurr, &pwszEnd, 10);
         IDAuth.Value[5] = (UCHAR)Auto & 0xF;
         IDAuth.Value[4] = (UCHAR)((Auto >> 8) & 0xFF);
         IDAuth.Value[3] = (UCHAR)((Auto >> 16) & 0xFF);
         IDAuth.Value[2] = (UCHAR)((Auto >> 24) & 0xFF);
         pwszCurr = pwszEnd;
    }

    pwszCurr++;

    //
    // Now, count the number of sub auths
    //
    cSubs = 0;
    pwszNext = pwszCurr;

    if(pwszCurr != NULL)
    {
        cSubs++;
    }

    while(TRUE)
    {
        pwszNext = wcschr(pwszNext,'-');
        if(pwszNext == NULL || *(pwszNext + 1) == L'\0')
        {
            break;
        }
        pwszNext++;
        cSubs++;
    }

    if(cSubs != 0)
    {
        pSubAuth = (PULONG)AccAlloc(cSubs * sizeof(ULONG));
        if(pSubAuth == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            for(ULONG iIndex = 0; iIndex < cSubs; iIndex++)
            {
                pSubAuth[iIndex] = wcstoul(pwszCurr, &pwszEnd, 10);
                pwszCurr = pwszEnd + 1;
            }
        }
    }
    else
    {
        dwErr = ERROR_NONE_MAPPED;
    }

    //
    // Now, create the SID
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppSid = (PSID)AccAlloc(sizeof(SID) + cSubs * sizeof(ULONG));
        if(*ppSid == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            PISID pSid = (PISID)*ppSid;
            pSid->Revision = Revision;
            pSid->SubAuthorityCount = cSubs;
            memcpy(&(pSid->IdentifierAuthority),
                   &IDAuth,
                   sizeof(SID_IDENTIFIER_AUTHORITY));
            memcpy(pSid->SubAuthority,
                   pSubAuth,
                   cSubs * sizeof(ULONG));

#if DBG
            UNICODE_STRING SidString;
            NTSTATUS Status = RtlConvertSidToUnicodeString(&SidString,
                                                           pSid,
                                                           TRUE);
            if(!NT_SUCCESS(Status))
            {
                acDebugOut((DEB_TRACE_SID, "Can't convert sid to string: 0x%lx\n",
                            Status));
            }
            else
            {
                acDebugOut((DEB_TRACE_SID, "Converted sid: %wZ\n", &SidString));
                RtlFreeUnicodeString(&SidString);
            }

            if(FLAG_ON(acInfoLevel, DEB_TRACE_SID))
            {
                DebugBreak();
            }
#endif
        }
    }

    AccFree(pSubAuth);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetCurrentToken
//
//  Synopsis:   Gets the token from the current thread, if possible, or the
//              process.
//
//  Arguments:  [IN  pHandle]       --  Where the token is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD GetCurrentToken( OUT HANDLE *pHandle )
{
    DWORD dwErr = ERROR_SUCCESS;

    //
    // see if a thread token exists
    //
    if(!OpenThreadToken(GetCurrentThread(),
                        TOKEN_QUERY,
                        TRUE,
                        pHandle))
    {
        dwErr = GetLastError();

        //
        // if not, use the process token
        //
        if(dwErr == ERROR_NO_TOKEN)
        {
            dwErr = ERROR_SUCCESS;
            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_QUERY,
                                  pHandle))
            {
                dwErr = GetLastError();
            }
        }
    }

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\acclist.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:        acclist.cxx
//
//  Contents:    Class implementation of the CAccessList class
//
//  Classes:     CAccessList
//
//  History:     28-Jul-96      MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <alsup.hxx>

#include <seopaque.h>
#include <sertlp.h>

//+---------------------------------------------------------------------------
//
//  Member:     CAcccessList::CAccessList, public
//
//  Synopsis:   Constructor for the class
//
//  Arguments:  None
//
//  Returns:    Void
//
//----------------------------------------------------------------------------
CAccessList::CAccessList()      :
        _AccList(DelAcclistNode),
        _TrusteeList (DelTrusteeNode),
        _pGroup (NULL),
        _pOwner (NULL),
        _fSDValid (FALSE),
        _fFreeSD (FALSE),
        _pSD (NULL),
        _cSDSize (0),
        _fDAclFlags (0),
        _fSAclFlags (0),
        _ObjType (SE_UNKNOWN_OBJECT_TYPE),
        _pLDAP (NULL),
        _pwszDsPathReference (NULL),
        _pwszLookupServer (NULL)
{
    acDebugOut((DEB_TRACE_ACC, "In - out CAccessList::CAccessList\n"));
}





//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::~CAccessList, public
//
//  Synopsis:   Destructor for the class
//
//  Arguments:  None
//
//  Returns:    Void
//
//----------------------------------------------------------------------------
CAccessList::~CAccessList()
{
    acDebugOut((DEB_TRACE_ACC, "In - out CAccessList::~CAccessList\n"));

    AccFree(_pGroup);
    AccFree(_pOwner);

    if(_fFreeSD == TRUE)
    {
        AccFree(_pSD);
    }

    AccFree(_pwszLookupServer);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddSD, public
//
//  Synopsis:   Adds a new security descriptor to the list.  It converts the
//              acls into an access list
//
//  Arguments:  [IN pSD]        --      The information about the security
//                                      descriptor
//              [IN SeInfo]     --      SecurityInfo
//              [IN pwszProperty]       Property name
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddSD(IN   PSECURITY_DESCRIPTOR    pSD,
                         IN   SECURITY_INFORMATION    SeInfo,
                         IN   PWSTR                   pwszProperty,
                         IN   BOOL                    fAddAll)
{
    acDebugOut((DEB_TRACE_ACC, "In CAccessList::AddSD\n"));

    DWORD   dwErr = ERROR_SUCCESS;


    PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pSD;

    dwErr = AddAcl(RtlpDaclAddrSecurityDescriptor(pISD),
                   RtlpSaclAddrSecurityDescriptor(pISD),
                   RtlpOwnerAddrSecurityDescriptor(pISD),
                   RtlpGroupAddrSecurityDescriptor(pISD),
                   SeInfo,
                   pwszProperty,
                   fAddAll,
                   pISD->Control);

    acDebugOut((DEB_TRACE_ACC, "Out CAccessList::AddSD: 0x%lx\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddAcl, public
//
//  Synopsis:   Adds a new acl to the list.  It converts the acls into an
//              access list
//
//  Arguments:  [IN pDAcl]      --      The DAcl to add
//              [IN pSAcl]      --      The SAcl to add
//              [IN SeInfo]     --      SecurityInfo
//              [IN pwszProperty]       Property name
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddAcl(IN  PACL                 pDAcl,
                          IN  PACL                 pSAcl,
                          IN  PSID                 pOwner,
                          IN  PSID                 pGroup,
                          IN  SECURITY_INFORMATION SeInfo,
                          IN  PWSTR                pwszProperty,
                          IN  BOOL                 fAddAll,
                          IN  ULONG                fControl)
{
    acDebugOut((DEB_TRACE_ACC, "In CAccessList::AddAcl: 0x%lx\n", pDAcl));

    DWORD   dwErr = ERROR_SUCCESS;

    _fSDValid = FALSE;

    //
    // If no parameters are given, just return success
    //
    if(SeInfo == 0)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Ok, save off the group and owner if they exist
    //
    if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
    {
        if(pOwner == NULL || RtlValidSid((PSID)pOwner) == FALSE)
        {
            dwErr = ERROR_INVALID_OWNER;
        }
        else
        {
            ACC_ALLOC_AND_COPY_SID(pOwner, _pOwner, dwErr);
        }
    }

    if(FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
    {
        if(pGroup == NULL || RtlValidSid((PSID)pGroup) == FALSE)
        {
            dwErr = ERROR_INVALID_PRIMARY_GROUP;
        }
        else
        {
            ACC_ALLOC_AND_COPY_SID(pGroup, _pGroup, dwErr);
        }
    }

    //
    // Otherwise, we'll start processing them...
    //
    if(dwErr == ERROR_SUCCESS &&
       FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        dwErr = ConvertAclToAccess(DACL_SECURITY_INFORMATION,
                                   pDAcl,
                                   pwszProperty,
                                   fAddAll,
                                   (BOOL)FLAG_ON(fControl, SE_DACL_PROTECTED));
    }

    if(dwErr == ERROR_SUCCESS &&
       FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
    {
        dwErr = ConvertAclToAccess(SACL_SECURITY_INFORMATION,
                                   pSAcl,
                                   pwszProperty,
                                   fAddAll,
                                   (BOOL)FLAG_ON(fControl, SE_SACL_PROTECTED));
    }

    acDebugOut((DEB_TRACE_ACC, "Out CAccessList::AddAcl: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::RemoveTrusteeFromAccess, public
//
//  Synopsis:   This method goes through and removes any explicit entries from
//              an access list for the given trustee.
//
//  Arguments:  [IN  SeInfo]        --      Type of access list to operate on
//              [IN  pTrustee]      --      Trustee to remove
//              [IN  pwszProperty]  --      If present, this is the property to
//                                          revoke the access on
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::RemoveTrusteeFromAccess(IN  SECURITY_INFORMATION  SeInfo,
                                           IN  PTRUSTEE              pTrustee,
                                           IN  PWSTR                 pwszProperty OPTIONAL)
{
    acDebugOut((DEB_TRACE_ACC,"In CAccessList::RemoveTrusteeFromAccess\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL PropertiesMatch = FALSE;
    GUID Guid;
    PWSTR pwszNewPropertyName, pwszSourceName;

    //
    // Now, we'll simply process all of the lists, and remove any of the
    // specified entries
    //

    _fSDValid = FALSE;

    //
    // Enumerate through the list
    //
    _AccList.Reset();
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.NextData();

    while(pAccNode != NULL && dwErr == ERROR_SUCCESS)
    {
        PropertiesMatch = DoPropertiesMatch(pAccNode->pwszProperty, pwszProperty);

        if(PropertiesMatch == FALSE && pwszProperty != NULL && pAccNode->pwszProperty != NULL)
        {
            //
            // See if we should convert one to/from a guid and then
            // compare it again
            //
            dwErr = UuidFromString(pwszProperty, &Guid);
            if(dwErr == ERROR_SUCCESS)
            {
                pwszSourceName = pAccNode->pwszProperty;
            }
            else
            {
                dwErr = UuidFromString(pAccNode->pwszProperty, &Guid);
                if(dwErr == ERROR_SUCCESS)
                {
                    pwszSourceName = pwszProperty;
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccctrlLookupIdName(_pLDAP,
                                            _pwszDsPathReference,
                                            &Guid,
                                            FALSE,
                                            FALSE,
                                            &pwszNewPropertyName);

                if(dwErr == ERROR_SUCCESS)
                {
                    PropertiesMatch = DoPropertiesMatch(pwszSourceName,
                                                        pwszNewPropertyName);
                }

            }
        }

        if(PropertiesMatch)
        {
            //
            // Get the list we need
            //
            PACTRL_ACCESS_ENTRY_LIST pList = SeInfo == DACL_SECURITY_INFORMATION ?
                                                        pAccNode->pAccessList :
                                                        pAccNode->pAuditList;
            if(pList != NULL)
            {
                //
                // Now, process it...
                //
                ULONG   cRemoved = 0;
                for(ULONG iIndex = 0;
                    iIndex < pList->cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    BOOL    fMatch = FALSE;
                    dwErr = DoTrusteesMatch(_pwszLookupServer,
                                            pTrustee,
                                            &(pList->pAccessList[iIndex].Trustee),
                                            &fMatch);
                    if(dwErr == ERROR_SUCCESS && fMatch == TRUE)
                    {
                        cRemoved++;

                        //
                        // Indicate that this node is to be removed by setting the
                        // access flags to 0xFFFFFFFF
                        //
                        pList->pAccessList[iIndex].Access = 0xFFFFFFFF;
                    }
                }

                //
                // Now, see if we need to do anything...
                //
                if(dwErr == ERROR_SUCCESS && cRemoved != 0)
                {
                    PACTRL_ACCESS_ENTRY_LIST pNew;
                    dwErr = ShrinkList(pList,
                                       cRemoved,
                                       &pNew);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // Finally, replace what is there with our new one
                        //
                        if(SeInfo == DACL_SECURITY_INFORMATION)
                        {
                            CHECK_HEAP
                            AccFree(pAccNode->pAccessList);
                            pAccNode->pAccessList = pNew;
                            if(pNew == NULL)
                            {
                                pAccNode->SeInfo &= ~DACL_SECURITY_INFORMATION;
                            }
                        }
                        else
                        {
                            AccFree(pAccNode->pAuditList);
                            pAccNode->pAuditList = pNew;
                            if(pNew == NULL)
                            {
                                pAccNode->SeInfo &= ~SACL_SECURITY_INFORMATION;
                            }
                        }
                    }

                }
            }

        }
        pAccNode = (PACCLIST_NODE)_AccList.NextData();
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::RemoveTrusteeFromAccess: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::ConvertAclToAccess, private
//
//  Synopsis:   Converts the given dacl/sacl to an ACCLIST_NODE format
//
//  Arguments:  [IN SeInfo]             --      What type of ACL this is
//              [IN pAcl]               --      The Acl to convert
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//              ERROR_INVALID_ACL       --      ACL came in as downlevel
//
//----------------------------------------------------------------------------
DWORD CAccessList::ConvertAclToAccess(IN  SECURITY_INFORMATION SeInfo,
                                      IN  PACL                 pAcl,
                                      IN  PWSTR                pwszProperty,
                                      IN  BOOL                 fAddAll,
                                      IN  BOOL                 fProtected)
{
    acDebugOut((DEB_TRACE_ACC, "In CAccessList::ConvertAclToAccess\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    CSList  AceList((FreeFunc)AccFree);
    ACL     EmptyAcl;
//    CSList  AceList((FreeFunc)DebugFree);

    //
    // Check for the case where we're setting a NULL acl.  If it's a NULL SACL, turn
    // it into an empty one.
    //
    if(pAcl == NULL && FLAG_ON(SeInfo,SACL_SECURITY_INFORMATION))
    {
        EmptyAcl.AclRevision = ACL_REVISION;
        EmptyAcl.Sbz1 = 0;
        EmptyAcl.AclSize = sizeof( ACL );
        EmptyAcl.AceCount = 0;
        EmptyAcl.Sbz2 = 0;

        pAcl = &EmptyAcl;
    }

    if(pAcl == NULL)
    {
        //
        // Ok, find the node for this property
        //
        PACCLIST_NODE   pAccNode;

        dwErr = GetNodeForProperty(_AccList,
                                   pwszProperty,
                                   &pAccNode);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // We'll fill in the information now
            //
            pAccNode->SeInfo |= SeInfo;
            if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
            {
                pAccNode->pAccessList = NULL;
                if(fProtected)
                {
                    pAccNode->fState |= ACCLIST_DACL_PROTECTED;
                }
            }
            else
            {
                pAccNode->pAuditList = NULL;
                if(fProtected)
                {
                    pAccNode->fState |= ACCLIST_SACL_PROTECTED;
                }
            }
        }
    }
    else
    {
        //
        // Ok, we've got a valid acl list, so we'll process it...
        //

        //
        // Basically, we'll save off our flags...
        //
        SeInfo == DACL_SECURITY_INFORMATION ?
                                    _fDAclFlags = pAcl->Sbz1  :
                                    _fSAclFlags = pAcl->Sbz1;

        ULONG rgInheritFlags[] = {0,
                                  INHERITED_PARENT,
                                  INHERITED_GRANDPARENT};
        //
        // We need to keep track of the changes in denied/allowed pairs,
        // so that we can determine between the inherited and parent
        // inherited aces are, so that we can mark our new entries
        //
        ULONG   iIFIndex = 0;
        ULONG   PrevIn = 0;
        BOOL    fPrevAllowed = FALSE;


        //
        // Ok, now we'll simply process each of the entries in the list
        //
        PACE_HEADER pAceHeader = (PACE_HEADER)FirstAce(pAcl);
        for(ULONG iAce = 0;
            iAce < pAcl->AceCount && dwErr == ERROR_SUCCESS;
            iAce++, pAceHeader = (PACE_HEADER)NextAce(pAceHeader))
        {
            BOOL    fThisAllowed = FALSE;
            BOOL    fIsExtendedAce = FALSE;
            GUID    PropID;
            GUID   *pPropID = NULL;

            //
            // Ok, now lets try to figure out what type of ACE this is, so we can
            // do the neccessary mapping into the provider rights
            //
            switch(pAceHeader->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                fThisAllowed = TRUE;
                break;

            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                fThisAllowed = TRUE;
                fIsExtendedAce = TRUE;
                break;

            //
            // Currently unsupported
            //
            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                dwErr = ERROR_INVALID_ACL;
                break;

            case ACCESS_DENIED_ACE_TYPE:
                break;

            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                fIsExtendedAce = TRUE;
                break;

            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                fIsExtendedAce = TRUE;
                fThisAllowed = TRUE;
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
                fThisAllowed = TRUE;
                break;

            default:
                dwErr = ERROR_INVALID_ACL;
                break;

            }

            LPGUID  pProp = NULL;

            if(dwErr == ERROR_SUCCESS)
            {
                if(fIsExtendedAce == TRUE)
                {
                    PACCESS_ALLOWED_OBJECT_ACE pExAce =
                                       (PACCESS_ALLOWED_OBJECT_ACE)pAceHeader;
                    if(FLAG_ON(pExAce->Flags,ACE_OBJECT_TYPE_PRESENT))
                    {
                        pProp = RtlObjectAceObjectType(pAceHeader);
                    }
                }

                //
                // Pull what we can from the ace header
                //
                if((fThisAllowed == FALSE && fPrevAllowed == TRUE) ||
                    (FLAG_ON(pAceHeader->AceFlags,INHERITED_ACE) &&
                                                                PrevIn == 0))
                {
                    iIFIndex++;
                    ASSERT(iIFIndex < sizeof(rgInheritFlags) / sizeof(ULONG));
                    if(iIFIndex >= sizeof(rgInheritFlags) / sizeof(ULONG))
                    {
                        dwErr = ERROR_INVALID_ACL;
                    }

                    PrevIn = pAceHeader->AceFlags;
                }
                else
                {
                    PrevIn = pAceHeader->AceFlags;
                }

                dwErr = InsertAtoANode(AceList,
                                       pProp,
                                       pAceHeader,
                                       rgInheritFlags[iIFIndex]);
            }
        }
    }

    //
    // Ok, now we'll turn it into PACTRL_ACCESS structure, and call our
    // add access routine
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_ACCESS Access;

        Access.cEntries = 0;

        PACTRL_PROPERTY_ENTRY pAPE = (PACTRL_PROPERTY_ENTRY)
                AccAlloc(max( AceList.QueryCount(), 1 ) * sizeof(ACTRL_PROPERTY_ENTRY));
        if(pAPE == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            Access.cEntries = AceList.QueryCount();
            Access.pPropertyAccessList = pAPE;

            //
            // Now, start filling them in...
            //
            AceList.Reset();
            for(ULONG i = 0; i < Access.cEntries; i++)
            {
                if(fProtected)
                {
                    pAPE[i].fListFlags = ACTRL_ACCESS_PROTECTED;
                }


                PACCLIST_ATOACCESS pAToA = (PACCLIST_ATOACCESS)AceList.NextData();
                if(pAToA->pGuid != NULL)
                {
                    dwErr = AccctrlLookupIdName(_pLDAP,
                                                _pwszDsPathReference,
                                                pAToA->pGuid,
                                                TRUE,
                                                FALSE,  // avoid object GUIDs
                                                (PWSTR *)&pAPE[i].lpProperty);

                }

                if(dwErr == ERROR_SUCCESS)
                {
                    pAPE[i].pAccessEntryList = (PACTRL_ACCESS_ENTRY_LIST)
                                    AccAlloc(sizeof(ACTRL_ACCESS_ENTRY_LIST));
                    if(pAPE[i].pAccessEntryList == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    pAPE[i].pAccessEntryList->cEntries =
                                                  pAToA->AceList.QueryCount();

                    pAPE[i].pAccessEntryList->pAccessList =
                        (PACTRL_ACCESS_ENTRY)AccAlloc(
                                        pAPE[i].pAccessEntryList->cEntries *
                                                  sizeof(ACTRL_ACCESS_ENTRY));
                    if(pAPE[i].pAccessEntryList->pAccessList == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        PACTRL_ACCESS_ENTRY pAEL =
                                        pAPE[i].pAccessEntryList->pAccessList;
                        pAToA->AceList.Reset();
                        for(ULONG j = 0;
                            j < pAPE[i].pAccessEntryList->cEntries &&
                                                       dwErr == ERROR_SUCCESS;
                            j++)
                        {

                            PACCLIST_ATOANODE pNode = (PACCLIST_ATOANODE)
                                                    pAToA->AceList.NextData();

                            dwErr = AceToAccessEntry(pNode->pAce,
                                                     pNode->fInherit,
                                                     _ObjType,
                                                     _KernelObjectType,
                                                     &(pAEL[j]));
                        }
                    }
                }
            }

            //
            // Handle the empty case...
            //
            if ( Access.cEntries == 0 && pAcl != NULL ) {

                Access.cEntries = 1;
                pAPE->pAccessEntryList = (PACTRL_ACCESS_ENTRY_LIST)
                                AccAlloc(sizeof(ACTRL_ACCESS_ENTRY_LIST));
                if(pAPE->pAccessEntryList == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    pAPE->pAccessEntryList->cEntries = 0;
                    pAPE->pAccessEntryList->pAccessList = NULL;
                    if(fProtected)
                    {
                        pAPE->fListFlags = ACTRL_ACCESS_PROTECTED;
                    }
                }
            }

            //
            // If all of that worked, add it...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AddAccessLists(SeInfo,
                                       &Access,
                                       TRUE);
            }

            //
            // Regardless of success or failure, delete all memory
            //
            for(i = 0; i < Access.cEntries; i++)
            {
                AccFree((PWSTR *)Access.pPropertyAccessList[i].lpProperty);
                if(Access.pPropertyAccessList[i].pAccessEntryList != NULL)
                {
                    for(ULONG j = 0;
                        j < Access.pPropertyAccessList[i].
                                            pAccessEntryList->cEntries;
                        j++)
                    {
                        if(Access.pPropertyAccessList[i].pAccessEntryList->pAccessList != NULL )
                        {
                            AccFree(Access.pPropertyAccessList[i].
                                             pAccessEntryList->pAccessList[j].lpInheritProperty);
                        }
                    }

                    AccFree(Access.pPropertyAccessList[i].
                                           pAccessEntryList->pAccessList);
                    AccFree(Access.pPropertyAccessList[i].pAccessEntryList);
                }
            }

            AccFree(Access.pPropertyAccessList);
        }
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::ConvertAclToAccess: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::MarshalAccessList, private
//
//  Synopsis:   Marshals the information specified by SeInfo into a single
//              buffer
//
//  Arguments:  [IN  SeInfo]            --      Type of info to marshal
//              [OUT ppAList]           --      Where the information is
//                                              returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERRROR_NOT_ENOUGH_MEMORY--      A memory allocation failed
//
//  Notes:      Memory is allocated as a block via a AccAlloc call and
//              should be freed with a AccFree call
//
//              SeInfo can only contain a SINGLE information value
//
//----------------------------------------------------------------------------
DWORD CAccessList::MarshalAccessList(IN  SECURITY_INFORMATION  SeInfo,
                                     OUT PACTRL_ACCESSW       *ppAList)
{
    acDebugOut((DEB_TRACE_ACC,"In qCAccessList::MarshalAccessList\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    PACCLIST_CNODE  pCNode = NULL;
    ULONG           cItems = 0;

    ASSERT( SeInfo == DACL_SECURITY_INFORMATION || SeInfo == SACL_SECURITY_INFORMATION );

    //
    // First, compress the list...
    //
    dwErr = CompressList(SeInfo,
                         &pCNode,
                         &cItems);
    //
    // Then, we need to get the size of the memory block we need to allocate
    //
    DWORD   cSize = 0;
    DWORD   cAEs = 0;
    PBYTE   pbEndOBuff = NULL;
    ULONG   cUsed = 0;
    ULONG   i = 0;

    CSList  TrusteesToMarshal(NULL);
    CSList  InheritPropsToMarshal((FreeFunc)LocalFree);
//    CSList  InheritPropsToMarshal((FreeFunc)DebugFree);


    for(i = 0; i < cItems && dwErr == ERROR_SUCCESS; i++)
    {
        //
        // Get the list we need
        //
        ULONG cEnts = pCNode[i].cExp + pCNode[i].cL1Inherit +
                                                         pCNode[i].cL2Inherit;

        if(pCNode[i].pList != NULL)
        {

            cUsed++;
            cSize += sizeof(ACTRL_ACCESS_ENTRY) * cEnts;

            if ((SeInfo == DACL_SECURITY_INFORMATION ?
                    pCNode[ i ].pONode->pAccessList->pAccessList : pCNode[ i ].pONode->pAuditList->pAccessList) == NULL )
            {
                pCNode[i].Empty = TRUE;
            }

            //
            // Finally, go through and figure out what trustees we'll need to
            // marshal
            //
            for(ULONG iIndex = 0;
                iIndex < cEnts && dwErr == ERROR_SUCCESS && pCNode[i].Empty == FALSE;
                iIndex++)
            {
                dwErr = TrusteesToMarshal.InsertIfUnique(
                                          &(pCNode[i].pList[iIndex].Trustee),
                                          CompTrustees);
                if(dwErr == ERROR_SUCCESS &&
                   pCNode[i].pList[iIndex].Trustee.MultipleTrusteeOperation ==
                                                       TRUSTEE_IS_IMPERSONATE)
                {
                    dwErr = TrusteesToMarshal.InsertIfUnique(
                             pCNode[i].pList[iIndex].Trustee.pMultipleTrustee,
                             CompTrustees);

                }

                //
                // Now, see if we have any inheritable properties to add
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    if(pCNode[i].pList[iIndex].lpInheritProperty != NULL &&
                        InheritPropsToMarshal.Find(
                            (PVOID)pCNode[i].pList[iIndex].lpInheritProperty,
                            CompInheritProps) == NULL)
                    {
                        PIPROP_IN_BUFF pPIB =
                             (PIPROP_IN_BUFF)AccAlloc(sizeof(IPROP_IN_BUFF));
                        if(pPIB == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            pPIB->pwszIProp = (LPWSTR)
                                    pCNode[i].pList[iIndex].lpInheritProperty;
                            dwErr = InheritPropsToMarshal.Insert((PVOID)pPIB);
                            if(dwErr != ERROR_SUCCESS)
                            {
                                AccFree(pPIB);
                            }
                            else
                            {
                                cSize +=
                                 SIZE_PWSTR(pCNode[i].pList[iIndex].
                                                           lpInheritProperty);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            cUsed++;
        }

        //
        // Also, add in the property size
        //
        cSize += SIZE_PWSTR(pCNode[i].pONode->pwszProperty);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        TrusteesToMarshal.Reset();
        PTRUSTEE    pTrustee = (PTRUSTEE)TrusteesToMarshal.NextData();
        while(pTrustee != NULL)
        {
            if(pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
            {
                cSize += SIZE_PWSTR(pTrustee->ptstrName);
            }
            else
            {
                PTRUSTEE_NODE   pTN = NULL;
                dwErr = GetTrusteeNode(pTrustee,
                                       TRUSTEE_OPT_NOTHING,
                                       &pTN);
                cSize += SIZE_PWSTR(pTN->pwszTrusteeName);
            }

            if(pTrustee->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
            {
                cSize += sizeof(TRUSTEE);
            }

            pTrustee = (PTRUSTEE)TrusteesToMarshal.NextData();
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, all that we have is the size of the entries and the strings.
        // We now need to add the size of our structures...
        //
        cSize += sizeof(PACTRL_ACCESSW)                                  +
                 (cUsed * sizeof(ACTRL_PROPERTY_ENTRY)) +
                 (cUsed * sizeof(ACTRL_ACCESS_ENTRY))  +
                 sizeof(ACTRL_ACCESS_ENTRY_LIST);

        acDebugOut((DEB_TRACE_ACC, "Total size needed: %lu\n", cSize));

        //
        // Now, we'll allocate it, and start filling it in
        //
        *ppAList = (PACTRL_ACCESSW)AccAlloc(cSize);
        if(*ppAList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Now, we'll have to through first and add the property and
            // names to the end of the block.  We need to do this before
            // adding the individual entries, so that as we go through and
            // add each access entry, we can point the trustee to the
            // proper place
            //
            pbEndOBuff = (PBYTE)*ppAList + cSize;

            //
            // First, process all of the property names
            //
            for(i = 0; i < cItems; i++)
            {
                //
                // If we don't have a property name, set it to NULL
                //
                if(pCNode[i].pONode->pwszProperty == NULL)
                {
                    pCNode[i].pONode->pwszPropInBuff = NULL;
                }
                else
                {
                    ULONG cLen = SIZE_PWSTR(pCNode[i].pONode->pwszProperty);
                    pbEndOBuff -= cLen;

                    memcpy(pbEndOBuff,
                           pCNode[i].pONode->pwszProperty,
                           cLen);
                    pCNode[i].pONode->pwszPropInBuff = (PWSTR)pbEndOBuff;

                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                TrusteesToMarshal.Reset();
                PTRUSTEE    pTrustee = (PTRUSTEE)TrusteesToMarshal.NextData();
                while(pTrustee != NULL)
                {
                    PTRUSTEE_NODE   pTN = NULL;
                    dwErr = GetTrusteeNode(pTrustee,
                                           TRUSTEE_OPT_NOTHING,
                                           &pTN);
                    ULONG cLen = SIZE_PWSTR(pTN->pwszTrusteeName);
                    pbEndOBuff -= cLen;

                    memcpy(pbEndOBuff,
                           pTN->pwszTrusteeName,
                           cLen);
                    pTN->pwszTrusteeInBuff = (PWSTR)pbEndOBuff;

                    pTrustee = (PTRUSTEE)TrusteesToMarshal.NextData();
                }
            }


            if(dwErr == ERROR_SUCCESS)
            {
                InheritPropsToMarshal.Reset();
                PIPROP_IN_BUFF pPIB =
                                (PIPROP_IN_BUFF)InheritPropsToMarshal.NextData();
                while(pPIB != NULL)
                {
                    ULONG cLen = SIZE_PWSTR(pPIB->pwszIProp);
                    pbEndOBuff -= cLen;

                    memcpy(pbEndOBuff,
                           pPIB->pwszIProp,
                           cLen);
                    pPIB->pwszIPropInBuff = (PWSTR)pbEndOBuff;

                    pPIB = (PIPROP_IN_BUFF)InheritPropsToMarshal.NextData();
                }
            }

            //
            // Ok, now we'll start processing everything else... This
            // begins by setting our count
            //

            (*ppAList)->cEntries = cUsed;

            PBYTE pCurrBuff = (PBYTE)*ppAList + sizeof(ACTRL_PROPERTY_ENTRY);;

            if((*ppAList)->cEntries != 0)
            {
                (*ppAList)->pPropertyAccessList =
                                              (PACTRL_PROPERTY_ENTRYW)pCurrBuff;

                pCurrBuff += (*ppAList)->cEntries * sizeof(ACTRL_PROPERTY_ENTRY);
            }
            else
            {
                (*ppAList)->pPropertyAccessList = NULL;
            }

            //
            // Go through and set our property entry list correctly
            //
            ULONG   iProp = 0;    // Property list index
            for(i = 0; i < cItems && cUsed != 0; i++)
            {
                BOOL    fNullAcl = FALSE;

                if(FLAG_ON(SeInfo,DACL_SECURITY_INFORMATION))
                {
                    if(FLAG_ON(pCNode[i].pONode->fState, ACCLIST_DACL_PROTECTED) ||
                       FLAG_ON(_fDAclFlags, ACCLIST_DACL_PROTECTED) )
                    {
                        (*ppAList)->pPropertyAccessList[iProp].fListFlags =
                                                                        ACTRL_ACCESS_PROTECTED;
                    }

                }

                if(FLAG_ON(SeInfo,SACL_SECURITY_INFORMATION))
                {
                    if(FLAG_ON(pCNode[i].pONode->fState, ACCLIST_SACL_PROTECTED) ||
                       FLAG_ON(_fSAclFlags, ACCLIST_SACL_PROTECTED) )
                    {
                        (*ppAList)->pPropertyAccessList[iProp].fListFlags =
                                                                        ACTRL_ACCESS_PROTECTED;
                    }

                }

                if(pCNode[i].pList == NULL)
                {
                    fNullAcl = TRUE;
                }

                //
                // Set our prop pointer
                //
                (*ppAList)->pPropertyAccessList[iProp].lpProperty =
                                                 pCNode[i].pONode->pwszPropInBuff;

                if(fNullAcl == TRUE)
                {
                    (*ppAList)->pPropertyAccessList[iProp].pAccessEntryList = NULL;
                }
                else
                {
                    (*ppAList)->pPropertyAccessList[iProp].pAccessEntryList =
                                             (PACTRL_ACCESS_ENTRY_LIST)pCurrBuff;

                    if(pCNode[i].pList != NULL)
                    {
                        pCurrBuff +=
                             (sizeof(ACTRL_ACCESS_ENTRY_LIST));
                    }
                }


                iProp++;
            }

            //
            // Ok, now we'll actually go through and build the individual
            // lists
            //
            iProp = 0;
            if((*ppAList)->pPropertyAccessList != NULL)
            {
                pCurrBuff =
                   (PBYTE)(*ppAList)->pPropertyAccessList[iProp].pAccessEntryList;
                pCurrBuff +=
                        (cUsed * sizeof(ACTRL_ACCESS_ENTRY_LIST));
            }
            for(i = 0; i < cItems && dwErr == ERROR_SUCCESS; i++)
            {
                //
                // Get the list we need
                //
                if(pCNode[i].pList != NULL &&
                   (*ppAList)->pPropertyAccessList[iProp].pAccessEntryList != NULL)
                {
                    PACTRL_ACCESS_ENTRY_LIST pAEL =
                          (*ppAList)->pPropertyAccessList[iProp].pAccessEntryList;

                    pAEL->cEntries = pCNode[i].cExp + pCNode[i].cL1Inherit +
                                                             pCNode[i].cL2Inherit;

                    if( !pCNode[i].Empty )
                    {
                        pAEL->pAccessList = (PACTRL_ACCESS_ENTRY)pCurrBuff;
                        pCurrBuff += (sizeof(ACTRL_ACCESS_ENTRY) * pAEL->cEntries);

                    }
                    else
                    {
                        pAEL->pAccessList = NULL;
                        pAEL->cEntries = 0;
                    }

                    //
                    // Copy the node and adjust our trustee
                    //
                    for(ULONG iIndex = 0; iIndex < pAEL->cEntries && !pCNode[i].Empty; iIndex++)
                    {
                        //
                        // Make sure we strip any of our internal flags info
                        //

                        pAEL->pAccessList[iIndex].fAccessFlags       =
                                        pCNode[i].pList[iIndex].fAccessFlags &
                                                        ~ACCLIST_VALID_TYPE_FLAGS;
                        pAEL->pAccessList[iIndex].Access             =
                                        pCNode[i].pList[iIndex].Access;
                        pAEL->pAccessList[iIndex].ProvSpecificAccess =
                                        pCNode[i].pList[iIndex].ProvSpecificAccess;
                        pAEL->pAccessList[iIndex].Inheritance        =
                                        pCNode[i].pList[iIndex].Inheritance;
                        if(pCNode[i].pList[iIndex].lpInheritProperty != NULL)
                        {
                            PIPROP_IN_BUFF pPIB =
                                (PIPROP_IN_BUFF)InheritPropsToMarshal.Find(
                                    (PVOID)pCNode[i].pList[iIndex].
                                                                lpInheritProperty,
                                                                CompInheritProps);
                            ASSERT(pPIB != NULL);
                            pAEL->pAccessList[iIndex].lpInheritProperty =
                                                        pPIB->pwszIPropInBuff;
                        }

                        //
                        // Now, we only have to adjust our trustee
                        //
                        PTRUSTEE pTrustee = &(pCNode[i].pList[iIndex].Trustee);
                        PTRUSTEE_NODE   pTN = NULL;
                        dwErr = GetTrusteeNode(pTrustee,
                                               TRUSTEE_OPT_NOTHING,
                                               &pTN);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // We'll add the trustee now...
                            //
                            pAEL->pAccessList[iIndex].Trustee.pMultipleTrustee =
                                                        NULL;
                            pAEL->pAccessList[iIndex].Trustee.MultipleTrusteeOperation =
                                                        NO_MULTIPLE_TRUSTEE;
                            pAEL->pAccessList[iIndex].Trustee.TrusteeForm =
                                                        TRUSTEE_IS_NAME;
                            pAEL->pAccessList[iIndex].Trustee.TrusteeType =
                                                        pTN->Trustee.TrusteeType;
                            pAEL->pAccessList[iIndex].Trustee.ptstrName   =
                                                        pTN->pwszTrusteeInBuff;

                            if(pTN->pImpersonate != NULL)
                            {
                                //
                                // Ok, 2 things to do: adjust our current trustee
                                // state and add the new one
                                //
                                pAEL->pAccessList[iIndex].Trustee.
                                                    MultipleTrusteeOperation =
                                                           TRUSTEE_IS_IMPERSONATE;
                                pTrustee = pAEL->pAccessList[iIndex].Trustee.
                                                                 pMultipleTrustee;
                                pbEndOBuff -= sizeof(TRUSTEE);
                                pTrustee = (PTRUSTEE)pbEndOBuff;
                                pTrustee->MultipleTrusteeOperation =
                                                              NO_MULTIPLE_TRUSTEE;
                                pTrustee->TrusteeForm = TRUSTEE_IS_NAME;
                                pTrustee->TrusteeType = TRUSTEE_IS_USER;
                                pTrustee->ptstrName =
                                             pTN->pImpersonate->pwszTrusteeInBuff;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }

                    iProp++;

                }
            }

            //
            // Free our memory if something failed
            //
            if(dwErr != ERROR_SUCCESS)
            {
                AccFree(*ppAList);
                *ppAList = NULL;
            }
        }
    }

    FreeCompressedList(pCNode,
                       cItems);

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::MarshalAccessList: %lu\n", dwErr));
    return(dwErr);
}







//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::MarshalAccessLists, public
//
//  Synopsis:   Returns the requested lists in single buffer form.  Each
//              access or audit list is returned seperately.
//
//  Arguments:  [IN  SeInfo]            --      Type of info requested
//              [OUT ppAccess]          --      Where the ACCESS list is
//                                              returned if requested
//              [OUT ppAudit]           --      Where the AUDIT list is
//                                              returned if requested
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::MarshalAccessLists(IN  SECURITY_INFORMATION  SeInfo,
                                      OUT PACTRL_ACCESS        *ppAccess,
                                      OUT PACTRL_AUDIT         *ppAudit)
{
    acDebugOut((DEB_TRACE_ACC,"In CAccessList::MarshalAccessLists\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    if(FLAG_ON(SeInfo,DACL_SECURITY_INFORMATION))
    {
        dwErr = MarshalAccessList(DACL_SECURITY_INFORMATION,
                                  ppAccess);
    }

    if(dwErr == ERROR_SUCCESS &&
       FLAG_ON(SeInfo,SACL_SECURITY_INFORMATION))
    {
        dwErr = MarshalAccessList(SACL_SECURITY_INFORMATION,
                                  ppAudit);

        //
        // If it failed and we allocated our Access list, make sure to free it
        //
        if(dwErr != ERROR_SUCCESS &&
           FLAG_ON(SeInfo,DACL_SECURITY_INFORMATION))
        {
            AccFree(*ppAccess);
        }
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::MarshalAccessLists: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetTrusteeNode, private
//
//  Synopsis:   Returns a pointer to a TRUSTEE_NODE for the given
//              trustee.  The flags indicate what information about the
//              trustee needs to be present in the node.  If the trustee
//              does not already exist in the list, it will be added
//
//  Arguments:  [IN  pTrustee]      --      Trustee to find
//              [IN  fNodeOptions]  --      Information that needs to be
//                                          present in the node
//              [OUT ppTrusteeNode] --      Where the node pointer is returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetTrusteeNode(IN  PTRUSTEE         pTrustee,
                                  IN  ULONG            fNodeOptions,
                                  OUT PTRUSTEE_NODE   *ppTrusteeNode)
{

    acDebugOut((DEB_TRACE_ACC,"In CAccessList::GetTrusteeNode\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // If we're doing an insert, we'll always want to create the name
    //
    if(FLAG_ON(fNodeOptions, TRUSTEE_OPT_INSERT_ONLY))
    {
        fNodeOptions |= TRUSTEE_OPT_NAME;
    }

    //
    // First, see if it exists in our list...
    //
    PTRUSTEE_NODE pTrusteeNode =
                    (PTRUSTEE_NODE)_TrusteeList.Find((PVOID)pTrustee,
                                                     CompTrusteeToTrusteeNode);
    if(pTrusteeNode == NULL)
    {
        //
        // Ok, we'll have to create one...
        //
        pTrusteeNode = (PTRUSTEE_NODE)AccAlloc(sizeof(TRUSTEE_NODE));
        if(pTrusteeNode == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memcpy(&(pTrusteeNode->Trustee),
                   pTrustee,
                   sizeof(TRUSTEE));
            pTrusteeNode->SidType = SidTypeUnknown;


            //
            // Copy off whatever information we need
            //
            if(dwErr == ERROR_SUCCESS)
            {
                if(pTrustee->TrusteeForm == TRUSTEE_IS_SID)
                {
                    if(RtlValidSid((PSID)pTrustee->ptstrName))
                    {
                        DWORD cSidSize =
                                    RtlLengthSid((PSID)pTrustee->ptstrName);
                        pTrusteeNode->pSid = (PSID)AccAlloc(cSidSize);
                        if(pTrusteeNode->pSid == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            memcpy(pTrusteeNode->pSid,
                                  (PSID)pTrustee->ptstrName,
                                  cSidSize);
                            pTrusteeNode->Trustee.ptstrName =
                                                   (PWSTR)pTrusteeNode->pSid;
                            pTrusteeNode->fFlags |= TRUSTEE_DELETE_SID;
                        }
                    }
                    else
                    {
                        dwErr = ERROR_INVALID_SID;
                    }
                }
                else
                {
                    pTrusteeNode->pwszTrusteeName =
                            (PWSTR)AccAlloc(SIZE_PWSTR(pTrustee->ptstrName));
                    if(pTrusteeNode->pwszTrusteeName == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        wcscpy(pTrusteeNode->pwszTrusteeName,
                               pTrustee->ptstrName);
                        pTrusteeNode->Trustee.ptstrName =
                                                pTrusteeNode->pwszTrusteeName;
                        pTrusteeNode->fFlags |= TRUSTEE_DELETE_NAME;
                    }
                }
            }


            //
            // See if we need to insert an impersonate node as well
            //
            if(dwErr == ERROR_SUCCESS)
            {
                if(pTrustee->MultipleTrusteeOperation ==
                                                      TRUSTEE_IS_IMPERSONATE)
                {
                    if(pTrustee->pMultipleTrustee == NULL)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                    else
                    {
                        PTRUSTEE_NODE pImpersonate;
                        dwErr = GetTrusteeNode(pTrustee->pMultipleTrustee,
                                               fNodeOptions,
                                               &pImpersonate);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            pTrusteeNode->pImpersonate = pImpersonate;
                        }
                    }
                }
            }

            //
            // Finally, insert it in the list
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = _TrusteeList.Insert((PVOID)pTrusteeNode);
            }

            //
            // If something went wrong, cleanup
            //
            if(dwErr != ERROR_SUCCESS)
            {
                DelTrusteeNode(pTrusteeNode);
            }
        }
    }

    //
    // Increment our use count if we were inserting
    //
    if(dwErr == ERROR_SUCCESS &&
       FLAG_ON(fNodeOptions, TRUSTEE_OPT_INSERT_ONLY))
    {
        pTrusteeNode->cUseCount++;
    }

    //
    // Now, if that worked, we'll need to make sure we have all the info
    // we need...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, if we don't have our sid type, we'll go ahead and determine it
        //
        if(pTrusteeNode->SidType == SidTypeUnknown)
        {
            //
            // We'll do this by turning on the appropriate flag
            //
            if(pTrusteeNode->Trustee.TrusteeForm == TRUSTEE_IS_SID)
            {
                fNodeOptions |= TRUSTEE_OPT_NAME;
            }
            else
            {
                fNodeOptions |= TRUSTEE_OPT_SID;
            }
        }

        dwErr = LookupTrusteeNodeInformation(_pwszLookupServer,
                                             pTrusteeNode,
                                             fNodeOptions);

        //
        // Finally, if that worked, and we have a compound trustee, do the
        // child
        //
        if(dwErr == ERROR_SUCCESS && pTrusteeNode->pImpersonate != NULL)
        {
            dwErr = GetTrusteeNode(&(pTrusteeNode->pImpersonate->Trustee),
                                   fNodeOptions,
                                   &(pTrusteeNode->pImpersonate));
        }
    }

    //
    // If it all worked, return the new information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ASSERT(pTrusteeNode->Trustee.ptstrName == pTrusteeNode->pSid ||
               pTrusteeNode->Trustee.ptstrName == pTrusteeNode->pwszTrusteeName);

        if(ppTrusteeNode != NULL)
        {
            *ppTrusteeNode = pTrusteeNode;
        }
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GetTrusteeNode: %lu\n", dwErr));

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddAccessLists, private
//
//  Synopsis:
//
//  Arguments:  [IN  pTrustee]      --      Trustee to find
//              [IN  fNodeOptions]  --      Information that needs to be
//                                          present in the node
//              [OUT ppTrusteeNode] --      Where the node pointer is returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddAccessLists(IN  SECURITY_INFORMATION  SeInfo,
                                  IN  PACTRL_ACCESSW        pAdd,
                                  IN  BOOL                  fMerge,
                                  IN  BOOL                  fOldStyleMerge)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,
                "In  CAccessList::AddAccessLists (%ws)\n",
                fMerge == TRUE ? L"Merge" : L"NoMerge"));

    //
    // If NULL parameters are given, just return success
    //
    if(SeInfo == 0)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Handle the empty list case
    //
    ACTRL_ACCESSW   NullAccess;
    ACTRL_PROPERTY_ENTRY EmptyPropList;
    ACTRL_ACCESS_ENTRY_LIST EmptyAccessList;
    if(pAdd == NULL)
    {
        //
        // We don't allow NULL sacls, only empty ones
        //
        if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
        {
            NullAccess.cEntries = 1;
            NullAccess.pPropertyAccessList = &EmptyPropList;
            memset(&EmptyPropList,0,sizeof(EmptyPropList));
            EmptyPropList.pAccessEntryList = &EmptyAccessList;
            memset(&EmptyAccessList,0,sizeof(EmptyAccessList));
        }
        else
        {
            NullAccess.cEntries = 0;
            NullAccess.pPropertyAccessList = NULL;
        }
        pAdd = &NullAccess;
    }


    if(pAdd->cEntries != 0 && pAdd->pPropertyAccessList == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }
    else
    {
        _fSDValid = FALSE;
    }

    //
    // If we're doing an old style merge, make sure we remove all of the
    // existing entries for these trustees
    //
    if(fOldStyleMerge == TRUE)
    {
        dwErr = RevokeTrusteeAccess(SeInfo,
                                    pAdd,
                                    NULL);
    }

    //
    // If we're doing a set, we'll have to go through and remove any entries
    // that would be replaced before we go through and add the new entries
    // This is because our input list can have multiple lists that deal
    // with the same property, so a set applied then has disasterous results
    //
    ULONG iIndex = 0;
    while(fMerge == FALSE && iIndex < pAdd->cEntries)
    {
        PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)
                                 (pAdd->cEntries == 0 ?
                                                NULL   :
                                                pAdd->pPropertyAccessList
                                                         [iIndex].lpProperty),
                                 CompProps);
        if(pAccNode != NULL)
        {
            if(SeInfo == DACL_SECURITY_INFORMATION)
            {
                FreeAEList(pAccNode->pAccessList);
                pAccNode->pAccessList = NULL;
                pAccNode->fState &= ~ACCLIST_DACL_PROTECTED;

            }
            else
            {
                FreeAEList(pAccNode->pAuditList);
                pAccNode->fState &= ~ACCLIST_SACL_PROTECTED;
                pAccNode->pAuditList = NULL;
            }
        }
        iIndex++;
    }


    //
    // We have to do this in a while loop, so we handle the empty access list
    // properly without having to duplicate a bunch o' code
    //
    iIndex = 0;
    while(dwErr == ERROR_SUCCESS)
    {
        //
        // Ok, first, we need to find the matching property...
        //
        PACCLIST_NODE   pAccNode;
        dwErr = GetNodeForProperty(_AccList,
                                   (PWSTR)(pAdd->cEntries == 0 ?
                                                    NULL   :
                                                    pAdd->pPropertyAccessList
                                                         [iIndex].lpProperty),
                                   &pAccNode);
        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Otherwise, we'll figure out what we're doing...
        //
        PACTRL_ACCESS_ENTRY_LIST pList =
                                    SeInfo == DACL_SECURITY_INFORMATION ?
                                                   pAccNode->pAccessList  :
                                                   pAccNode->pAuditList;

        pAccNode->SeInfo |= SeInfo;

        if(pAdd->cEntries && FLAG_ON(pAdd->pPropertyAccessList[iIndex].fListFlags, ACTRL_ACCESS_PROTECTED))
        {
            SeInfo == DACL_SECURITY_INFORMATION ?
                    _fDAclFlags |= ACCLIST_DACL_PROTECTED :
                    _fSAclFlags |= ACCLIST_SACL_PROTECTED;
        }

        //
        // Ok, we can quit now if we have an empty list
        //
        if( pAdd->cEntries == 0 ||
            pAdd->pPropertyAccessList[iIndex].pAccessEntryList == NULL )
        {
            break;
        }

        //
        // Validate that the list is correct
        //
        if(pAdd->cEntries &&
           pAdd->pPropertyAccessList[iIndex].pAccessEntryList->cEntries != 0 &&
           pAdd->pPropertyAccessList[iIndex].pAccessEntryList->pAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Save our flags
        //
        SeInfo == DACL_SECURITY_INFORMATION ?
                _fDAclFlags |= pAdd->pPropertyAccessList[iIndex].fListFlags :
                _fSAclFlags |= pAdd->pPropertyAccessList[iIndex].fListFlags;

        //
        // Now, we'll have to generate a new list
        //
        ULONG cSize = 0;

        if(pAdd->pPropertyAccessList[iIndex].pAccessEntryList != NULL)
        {
            cSize += pAdd->pPropertyAccessList[iIndex].pAccessEntryList->cEntries;
        }

        if(pList != NULL)
        {
            cSize += pList->cEntries;
        }

        PACTRL_ACCESS_ENTRY_LIST pNew = (PACTRL_ACCESS_ENTRY_LIST)AccAlloc(
                                        sizeof(ACTRL_ACCESS_ENTRY_LIST) +
                                        (cSize * sizeof(ACTRL_ACCESS_ENTRY)));
        if(pNew == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Otherwise, we'll add all the new denieds, followed by the old
        // denieds, then the new accesses, followed by the old accesses
        //
        ULONG iNewIndex = 0;

        ULONG cNewCopy = 0;
        ULONG cOldCopy = 0;

        pNew->pAccessList = (PACTRL_ACCESS_ENTRY)((PBYTE)pNew +
                                             sizeof(ACTRL_ACCESS_ENTRY_LIST));

        if ( pAdd->pPropertyAccessList[iIndex].pAccessEntryList->pAccessList == NULL ) {

            pNew->cEntries = 0;
            pNew->pAccessList = NULL;
            SeInfo == DACL_SECURITY_INFORMATION ?
                                pAccNode->pAccessList = pNew :
                                pAccNode->pAuditList  = pNew;
            break;
        }
        //
        // Count the new denieds
        //
        for(ULONG iCnt = 0;
            pAdd->pPropertyAccessList[iIndex].pAccessEntryList != NULL &&
            iCnt < pAdd->pPropertyAccessList[iIndex].pAccessEntryList->cEntries;
            iCnt++)
        {
            if(FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                               pAccessList[iCnt].fAccessFlags,
                       ACTRL_ACCESS_DENIED))
            {
                cNewCopy++;
            }
            else
            {
                break;
            }
        }

        //
        // Now, the old denieds
        //
        if(pList != NULL)
        {
            for(iCnt = 0;
                iCnt < pList->cEntries;
                iCnt++)
            {
                if(FLAG_ON(pList->pAccessList[iCnt].fAccessFlags,
                           ACTRL_ACCESS_DENIED))
                {
                    cOldCopy++;
                }
                else
                {
                    break;
                }
            }
        }

        //
        // Excellent.. Now, a series of copies
        //
        if(cNewCopy != 0)
        {
            for(iCnt = 0; iCnt < cNewCopy && dwErr == ERROR_SUCCESS; iCnt++)
            {
                if(SeInfo == DACL_SECURITY_INFORMATION)
                {
                    if(!(FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                            pAccessList[iCnt].fAccessFlags,ACTRL_ACCESS_DENIED) ||
                         FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                            pAccessList[iCnt].fAccessFlags,ACTRL_ACCESS_ALLOWED)))
                    {
                        dwErr = ERROR_INVALID_ACL;
                        break;
                    }
                }
                else
                {
                    if(!(FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                            pAccessList[iCnt].fAccessFlags,ACTRL_AUDIT_SUCCESS) ||
                         FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                             pAccessList[iCnt].fAccessFlags,ACTRL_AUDIT_FAILURE)))
                    {
                        dwErr = ERROR_INVALID_ACL;
                        break;
                    }

                }
                dwErr = CopyAccessEntry(&(pNew->pAccessList[iNewIndex]),
                                        &(pAdd->pPropertyAccessList[iIndex].
                                         pAccessEntryList->pAccessList[iCnt]));
                iNewIndex++;
            }
            pNew->cEntries += cNewCopy;
        }

        if(cOldCopy != 0)
        {
            memcpy(&(pNew->pAccessList[iNewIndex]),
                   pList->pAccessList,
                   cOldCopy * sizeof(ACTRL_ACCESS_ENTRY));
            iNewIndex += cOldCopy;
            pNew->cEntries += cOldCopy;

        }

        //
        // Then, copy the alloweds...
        //
        for(iCnt = cNewCopy;
            dwErr == ERROR_SUCCESS &&
            pAdd->pPropertyAccessList[iIndex].pAccessEntryList != NULL &&
            iCnt < pAdd->pPropertyAccessList[iIndex].pAccessEntryList->cEntries;
            iCnt++)
        {
            ULONG fAccessFlag = pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                               pAccessList[iCnt].fAccessFlags;

            if(fAccessFlag != ACTRL_ACCESS_ALLOWED &&
               fAccessFlag != ACTRL_ACCESS_DENIED  &&
               (fAccessFlag & ~(ACTRL_AUDIT_SUCCESS | ACTRL_AUDIT_FAILURE)))
            {
                dwErr = ERROR_INVALID_FLAGS;
                break;
            }

            if(SeInfo == DACL_SECURITY_INFORMATION)
            {
                if(!(FLAG_ON(fAccessFlag,ACTRL_ACCESS_DENIED) ||
                     FLAG_ON(fAccessFlag,ACTRL_ACCESS_ALLOWED)))
                {
                    dwErr = ERROR_INVALID_ACL;
                    break;
                }
            }
            else
            {
                if(!(FLAG_ON(fAccessFlag,ACTRL_AUDIT_SUCCESS) ||
                     FLAG_ON(fAccessFlag,ACTRL_AUDIT_FAILURE)))
                {
                    dwErr = ERROR_INVALID_ACL;
                    break;
                }

            }

            if(fAccessFlag == ACTRL_ACCESS_DENIED)
            {
                dwErr = ERROR_INVALID_ACL;
                break;
            }

            dwErr = CopyAccessEntry(&(pNew->pAccessList[iNewIndex]),
                                    &(pAdd->pPropertyAccessList[iIndex].
                             pAccessEntryList->pAccessList[iCnt]));
            iNewIndex++;
            pNew->cEntries++;
        }


        if(dwErr == ERROR_SUCCESS &&
                             pList != NULL && pList->cEntries - cOldCopy > 0)
        {
            memcpy(&(pNew->pAccessList[iNewIndex]),
                   &pList->pAccessList[cOldCopy],
                   (pList->cEntries - cOldCopy) * sizeof(ACTRL_ACCESS_ENTRY));
            iNewIndex += cOldCopy;
            pNew->cEntries += (pList->cEntries - cOldCopy);

        }

        //
        // Now, if we got this far, we'll set it back in our list
        //
        if(dwErr == ERROR_SUCCESS)
        {
            SeInfo == DACL_SECURITY_INFORMATION ?
                                pAccNode->pAccessList = pNew :
                                pAccNode->pAuditList  = pNew;
            if(FLAG_ON(pAdd->pPropertyAccessList[iIndex].fListFlags, ACTRL_ACCESS_PROTECTED))
            {
                pAccNode->fState |= (SeInfo == DACL_SECURITY_INFORMATION ?
                                                        ACCLIST_DACL_PROTECTED :
                                                        ACCLIST_SACL_PROTECTED);
            }
        }
        else
        {
            AccFree(pNew);
        }

        iIndex++;

        if(iIndex >= pAdd->cEntries)
        {
            break;
        }
    }



    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::AddAccessLists: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetExplicitAccess, public
//
//  Synopsis:   Determines the explicit access for a given trustee.  This
//              includes group membership lookup
//
//  Arguments:  [IN  pTrustee]      --      Trustee to check the access for
//              [IN  pwszProperty]  --      Property to get access for
//              [OUT pDeniedMask]   --      Where the denied mask is returned
//              [OUT pAllowedMask]  --      Where the allowed mask is returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetExplicitAccess(IN  PTRUSTEE   pTrustee,
                                     IN  PWSTR      pwszProperty,
                                     OUT PULONG     pDeniedMask,
                                     OUT PULONG     pAllowedMask)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GetExplicitAccess\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL PropertiesMatch = FALSE;
    GUID Guid;
    PWSTR pwszNewPropertyName, pwszSourceName;

    //
    // Ok, first, get the specified access list for our property
    //
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)pwszProperty,
                                                           CompProps);
    if(pAccNode == NULL)
    {
        //
        // If that failed, lets see if we can translate it from a guid to a string
        //

        //
        // See if we should convert one to/from a guid and then
        // compare it again
        //
        dwErr = UuidFromString(pwszProperty, &Guid);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccctrlLookupIdName(_pLDAP,
                                        _pwszDsPathReference,
                                        &Guid,
                                        FALSE,
                                        FALSE,
                                        &pwszNewPropertyName);

            if(dwErr == ERROR_SUCCESS)
            {
                pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)pwszNewPropertyName,
                                                        CompProps);
            }

        }


        //
        // Whoops... No such property...
        //
        if(pAccNode == NULL)
        {
            dwErr = ERROR_UNKNOWN_PROPERTY;
        }
    }

    if(pAccNode != NULL)
    {
        PACTRL_ACCESS_ENTRY_LIST pList = pAccNode->pAccessList;

        if(pList == NULL)
        {
            *pDeniedMask = 0;
            *pAllowedMask = 0xFFFFFFFF;
        }
        else if(pList->cEntries == 0)
        {
            *pDeniedMask = 0xFFFFFFFF;
            *pAllowedMask = 0;
        }
        else
        {

            //
            // Now, we'll process each one of the entries, and build our masks
            //
            *pDeniedMask = 0;
            *pAllowedMask = 0;

            //
            // Add our trustee, so we get our information
            //
            PTRUSTEE_NODE   pTNode;
            dwErr = GetTrusteeNode(pTrustee,
                                   TRUSTEE_OPT_SID,
                                   &pTNode);

            if(dwErr == ERROR_SUCCESS)
            {
                CMemberCheck    MemberCheck(pTNode);
                dwErr = MemberCheck.Init();

                //
                // Now, we'll just go
                //
                for(ULONG iIndex = 0;
                    iIndex < pList->cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    if(!(pList->pAccessList[iIndex].Inheritance & INHERIT_ONLY_ACE))
                    {
                        PTRUSTEE_NODE   pATNode;
                        dwErr = GetTrusteeNode(&(pList->pAccessList[iIndex].Trustee),
                                               TRUSTEE_OPT_SID,
                                               &pATNode);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            BOOL    fAddMask;
                            dwErr = MemberCheck.IsMemberOf(pATNode,
                                                           &fAddMask);
                            if(dwErr == ERROR_SUCCESS && fAddMask == TRUE)
                            {
                                //
                                // Great, then we'll simply or in the bits
                                //
                                if(pList->pAccessList[iIndex].fAccessFlags ==
                                                             ACTRL_ACCESS_ALLOWED)
                                {
                                    *pAllowedMask |= pList->pAccessList[iIndex].Access;
                                }
                                else
                                {
                                    *pDeniedMask |= pList->pAccessList[iIndex].Access;
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::GetExplicitAccess: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetExplicitAudits, public
//
//  Synopsis:   Determines the explicit audits for a given trustee.  This
//              includes group membership lookup
//
//  Arguments:  [IN  pTrustee]      --      Trustee to check the access for
//              [IN  pwszProperty]  --      Property to get access for
//              [OUT pSuccessMask]  --      Where the successful audit mask
//                                          is returned
//              [OUT pFailureMask]  --      Where the failed audit mask is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetExplicitAudits(IN  PTRUSTEE   pTrustee,
                                     IN  PWSTR      pwszProperty,
                                     OUT PULONG     pSuccessMask,
                                     OUT PULONG     pFailureMask)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GetExplicitAudits\n"));
    DWORD   dwErr = ERROR_SUCCESS;


    //
    // Ok, first, get the specified access list for our property
    //
    //
    // Ok, first, get the specified access list for our property
    //
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)pwszProperty,
                                                           CompProps);
    if(pAccNode == NULL)
    {
        //
        // Whoops... No such property...
        //

        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PACTRL_ACCESS_ENTRY_LIST pList = pAccNode->pAuditList;

        if(pList == NULL)
        {
            *pSuccessMask = 0;
            *pFailureMask = 0;
        }
        else if(pList->cEntries == 0)
        {
            *pSuccessMask = 0;
            *pFailureMask = 0;
        }
        else
        {
            //
            // Now, we'll process each one of the entries, and build our masks
            //
            *pSuccessMask = 0;
            *pFailureMask = 0;

            //
            // Add our trustee, so we get our information
            //
            PTRUSTEE_NODE   pTNode;
            dwErr = GetTrusteeNode(pTrustee,
                                   TRUSTEE_OPT_SID,
                                   &pTNode);

            if(dwErr == ERROR_SUCCESS)
            {
                CMemberCheck    MemberCheck(pTNode);
                dwErr = MemberCheck.Init();

                //
                // Now, we'll just go
                //
                for(ULONG iIndex = 0;
                    iIndex < pList->cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    PTRUSTEE_NODE   pATNode;
                    dwErr = GetTrusteeNode(&(pList->pAccessList[iIndex].Trustee),
                                           TRUSTEE_OPT_SID,
                                           &pATNode);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        BOOL    fAddMask;
                        dwErr = MemberCheck.IsMemberOf(pATNode,
                                                       &fAddMask);
                        if(dwErr == ERROR_SUCCESS && fAddMask == TRUE)
                        {
                            //
                            // Great, then we'll simply or in the bits
                            //
                            if(pList->pAccessList[iIndex].fAccessFlags ==
                                                          ACTRL_AUDIT_SUCCESS)
                            {
                                *pSuccessMask |= AccessMaskForAccessEntry(
                                                            &(pList->pAccessList[iIndex]),
                                                            _ObjType);
                            }

                            if(pList->pAccessList[iIndex].fAccessFlags ==
                                                          ACTRL_AUDIT_FAILURE)
                            {
                                *pFailureMask |= AccessMaskForAccessEntry(
                                                        &(pList->pAccessList[iIndex]),
                                                        _ObjType);
                            }
                        }
                    }
                }
            }
        }
    }


    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::GetExplicitAudits: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CopyAccessEntry, private
//
//  Synopsis:   Copies one access entry to another
//
//  Arguments:  [IN  pNewEntry]     --      Entry to be copied to
//              [IN  pOldEntry]     --      Entry to copy from
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:      pNewEntry must already exist
//
//----------------------------------------------------------------------------
DWORD CAccessList::CopyAccessEntry(IN PACTRL_ACCESS_ENTRY  pNewEntry,
                                   IN PACTRL_ACCESS_ENTRY  pOldEntry)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::CopyAccessEntry\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, copy the members
    //
    memcpy(pNewEntry,
           pOldEntry,
           sizeof(ACTRL_ACCESS_ENTRY));

    //
    // We'll have to NULL out the inherit property on the given entry,
    // since we only share it, and we don't want to prematurely delete it
    //
    pOldEntry->lpInheritProperty = NULL;

    //
    // Then, adjust the trustee
    //
    PTRUSTEE_NODE   pTNode;
    dwErr = GetTrusteeNode(&(pOldEntry->Trustee),
                           TRUSTEE_OPT_NOTHING,
                           &pTNode);
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszNewTrustee;
        if(pOldEntry->Trustee.TrusteeForm == TRUSTEE_IS_SID)
        {
            acDebugOut((DEB_TRACE_ACC,
                       "Transfered %p\n",
                       pTNode->pSid));
            pwszNewTrustee = (PWSTR)pTNode->pSid;
        }
        else
        {
            pwszNewTrustee = pTNode->pwszTrusteeName;
            acDebugOut((DEB_TRACE_ACC,
                        "Transfered %ws\n",
                        pwszNewTrustee));
        }

        pNewEntry->Trustee.ptstrName = pwszNewTrustee;
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::CopyAccessEntry: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GrowInheritedAces, private
//
//  Synopsis:   Expands inherited aces of a DS Object.  This will actually
//              add the appropriate access entries
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_INVALID_DATA  --      The root access list was not
//                                          loaded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GrowInheritedAces()
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GrowInheritedAces\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    if(_ObjType != SE_DS_OBJECT || _ObjType != SE_DS_OBJECT_ALL)
    {
        acDebugOut((DEB_TRACE_ACC,
                    "Out CAccessList::GrowInheritedAces: %lu\n",
                    dwErr));
        return(dwErr);
    }

    //
    // Ok, find the node whose property is NULL
    //
    PACCLIST_NODE pNode = (PACCLIST_NODE)_AccList.Find(NULL,
                                                       CompProps);
    if(pNode == NULL)
    {
        //
        // If we haven't loaded the root, so we're screwed
        //

        dwErr = ERROR_INVALID_DATA;
    }


    if(dwErr == ERROR_SUCCESS && _AccList.QueryCount() > 1)
    {
        PACTRL_ACCESS_ENTRYW    *ppAccInherit = NULL;
        PACTRL_ACCESS_ENTRYW    *ppAudInherit = NULL;
        ULONG                   cAud = 0;
        ULONG                   cAcc = 0;

        PACTRL_ACCESS_ENTRY_LIST pILists[2];
        PACTRL_ACCESS_ENTRY    **ppInheritList[2];
        PULONG                   pulCounts[2];

        pILists[0]       = pNode->pAccessList;
        ppInheritList[0] = &ppAccInherit;
        pulCounts[0]     = &cAcc;

        pILists[1]       = pNode->pAuditList;
        ppInheritList[1] = &ppAudInherit;
        pulCounts[1]     = &cAud;

        //
        // Now, build the lists
        //
        for(ULONG iIndex = 0;
            iIndex < 2 && dwErr == ERROR_SUCCESS;
            iIndex++)
        {
            //
            // Skip empty lists
            //
            if(pILists[iIndex] == NULL)
            {
                continue;
            }

            for(ULONG iItems = 0; iItems < pILists[iIndex]->cEntries; iItems++)
            {
                if(FLAG_ON(pILists[iIndex]->pAccessList[iItems].Inheritance,
                           VALID_INHERIT_FLAGS))
                {
                    (*pulCounts[iIndex])++;
                }
            }

            //
            // Now, we'll do an allocation, and repeat the operation, doing
            // the assignment
            //
            *ppInheritList[iIndex] = (PACTRL_ACCESS_ENTRY *)
                AccAlloc(sizeof(PACTRL_ACCESS_ENTRY) * *pulCounts[iIndex]);

            if(*ppInheritList[iIndex] == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            ULONG iInherit = 0;
            for(iItems = 0; iItems < pILists[iIndex]->cEntries; iItems++)
            {
                if(FLAG_ON(pILists[iIndex]->pAccessList[iItems].Inheritance,
                           VALID_INHERIT_FLAGS))
                {
                    (*ppInheritList)[iIndex][iInherit] =
                                    &(pILists[iIndex]->pAccessList[iItems]);
                }
            }
        }

        _AccList.Reset();
        PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.NextData();

        //
        // We'll do this for both the access and audit lists
        //

        while(pAccNode != NULL && dwErr == ERROR_SUCCESS)
        {
            if(pAccNode->pwszProperty == NULL)
            {
                PACTRL_ACCESS_ENTRY_LIST *ppLists[2];

                ppLists[0] = &(pAccNode->pAccessList);
                ppLists[1] = &(pAccNode->pAuditList);

                for(ULONG iList = 0;
                    iList < 2 && dwErr == ERROR_SUCCESS;
                    iList++)
                {
                    //
                    // Skip empty lists
                    //
                    if(ppLists[iList] == NULL ||
                       (*ppInheritList)[iList] == NULL)
                    {
                        continue;
                    }

                    //
                    // We'll build an AList and then do a merge
                    //
                    ACTRL_ACCESS_ENTRY_LIST     AEL;
                    AEL.cEntries    = *pulCounts[iList];
                    AEL.pAccessList = **ppInheritList[iList];

                    ACTRL_PROPERTY_ENTRY        PEntry;
                    PEntry.lpProperty       = pAccNode->pwszProperty;
                    PEntry.pAccessEntryList = &AEL;

                    ACTRL_ACCESSW               AList;
                    AList.cEntries            = 1;
                    AList.pPropertyAccessList = &PEntry;

                    dwErr = AddAccessLists(iList == 0  ?
                                                  DACL_SECURITY_INFORMATION :
                                                  SACL_SECURITY_INFORMATION,
                                           &AList,
                                           TRUE);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        break;
                    }
                }
            }
            pAccNode = (PACCLIST_NODE)_AccList.NextData();
        }

        //
        // Finally, free our memory
        //
        for(iIndex = 0; iIndex < 2; iIndex++)
        {
            AccFree(*ppInheritList[iIndex]);;
        }

    }




    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GrowInheritedAces: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CollapseInheritedAces, private
//
//  Synopsis:   The inverse of the above function.  Goes through the lists
//              and collapses the inherited access entries for a DS object
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::CollapseInheritedAces()
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::CollapseInheritedAces\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    if(_ObjType != SE_DS_OBJECT && _ObjType != SE_DS_OBJECT_ALL)
    {
        acDebugOut((DEB_TRACE_ACC,
                    "Out CAccessList::CollapseInheritedAces: %lu\n",
                    dwErr));
        return(dwErr);
    }

    //
    // Now, we'll process all the items EXCEPT the root.  (We only collapse
    // on properties)
    //
    _AccList.Reset();
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.NextData();

    //
    // We'll do this for both the access and audit lists
    //

    while(pAccNode != NULL && dwErr == ERROR_SUCCESS)
    {
        if(pAccNode->pwszProperty == NULL)
        {
            PACTRL_ACCESS_ENTRY_LIST *ppLists[2];
            ULONG                    cLists = 0;

            if(pAccNode->pAccessList != NULL)
            {
                ppLists[cLists++] = &(pAccNode->pAccessList);
            }

            if(pAccNode->pAuditList != NULL)
            {
                ppLists[cLists++] = &(pAccNode->pAuditList);
            }

            for(ULONG iList = 0;
                iList < cLists && dwErr == ERROR_SUCCESS;
                iList++)
            {
                ULONG   cRemoved = 0;
                for(ULONG iIndex = 0;
                    iIndex < (*ppLists)[iList]->cEntries;
                    iIndex++)
                {
                    if(FLAG_ON((*ppLists)[iList]->pAccessList[iIndex].
                                                                  Inheritance,
                               INHERITED_ACE))
                    {
                        (*ppLists)[iList]->pAccessList[iIndex].Access =
                                                                  0xFFFFFFFF;
                        cRemoved++;
                    }
                }

                if(dwErr == ERROR_SUCCESS && cRemoved != 0)
                {
                    PACTRL_ACCESS_ENTRY_LIST pNew;
                    dwErr = ShrinkList((*ppLists)[iList],
                                       cRemoved,
                                       &pNew);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        AccFree((*ppLists)[iList]);
                        (*ppLists)[iList] = pNew;
                    }
                }
            }
        }
        pAccNode = (PACCLIST_NODE)_AccList.NextData();
    }


    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::CollapseInheritedAces: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::ShrinkList, private
//
//  Synopsis:   Shrinks the given list.  This goes through and removes any
//              nodes that have been marked as "deleted", as indicated by the
//              access mask.
//
//  Arguments:  [IN  pOldList]      --      List to shrink
//              [IN  cRemoved]      --      Number of items to be removed
//              [OUT ppNewList]     --      Where the "shrunk" list is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::ShrinkList(IN  PACTRL_ACCESS_ENTRY_LIST     pOldList,
                              IN  ULONG                        cRemoved,
                              IN  PACTRL_ACCESS_ENTRY_LIST    *ppNewList)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::ShrinkList\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, we'll process the list, and repackage it...
    //
    PACTRL_ACCESS_ENTRY_LIST pNew = (PACTRL_ACCESS_ENTRY_LIST)
                                    AccAlloc(sizeof(ACTRL_ACCESS_ENTRY_LIST) +
                                            ((pOldList->cEntries - cRemoved) *
                                                 sizeof(ACTRL_ACCESS_ENTRY)));
    if(pNew == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pNew->pAccessList = (PACTRL_ACCESS_ENTRY)((PBYTE)pNew +
                                             sizeof(ACTRL_ACCESS_ENTRY_LIST));
        //
        // Now, copy the ones that we still want to keep over
        //
        ULONG iNew = 0;
        ULONG Removed = 0;
        for(ULONG iIndex = 0; iIndex < pOldList->cEntries; iIndex++)
        {
            if(pOldList->pAccessList[iIndex].Access != 0xFFFFFFFF)
            {
                memcpy(&(pNew->pAccessList[iNew]),
                       &(pOldList->pAccessList[iIndex]),
                       sizeof(ACTRL_ACCESS_ENTRY));
                iNew++;
            }
            else
            {
                //
                // Remove the trustee from the list
                //
                dwErr = RemoveTrustee(&(pOldList->pAccessList[iIndex].Trustee));

                Removed++;
            }
        }

        //
        // If we've removed all of the entries, remove the item as well...
        //
        if(iNew == 0 && Removed > 0 )
        {
            AccFree( pNew );
            *ppNewList = NULL;
        }
        else
        {
            pNew->cEntries = iNew;
            *ppNewList = pNew;
        }
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::ShrinkList: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::BuildSDForAccessList, public
//
//  Synopsis:   Builds a security descriptor for the loaded access lists
//
//  Arguments:  [OUT  ppSD]         --      Where the built security
//                                          descriptor is returned
//              [OUT  pSeInfo]      --      Where the SeInfo corresponding
//                                          to the Security Descriptor is
//                                          returned
//              [IN   fFlags]       --      Flags that govern the lifetime
//                                          of the SD.  It controls whether
//                                          the class deletes the SD or  not
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::BuildSDForAccessList(OUT PSECURITY_DESCRIPTOR  *ppSD,
                                        OUT PSECURITY_INFORMATION  pSeInfo,
                                        IN  ULONG                  fFlags)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::BuildSDForAccessList\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // If our current SD is valid, simply return it...
    //
    if(_fSDValid == TRUE)
    {
        *ppSD = _pSD;
        *pSeInfo = _SeInfo;

        acDebugOut((DEB_TRACE_ACC,
                    "Out CAccessList::BuildSDForAccessList: 0\n"));
        return(dwErr);
    }
    else
    {
        AccFree(_pSD);
        _pSD = NULL;
        _fFreeSD = FALSE;
        _cSDSize = 0;
    }


    if(FLAG_ON(fFlags,ACCLIST_SD_NOFREE))
    {
        _fFreeSD = FALSE;
    }
    else
    {
        _fFreeSD = TRUE;
    }

    UCHAR    AclRevision = ACL_REVISION2;
    if(_ObjType == SE_DS_OBJECT || _ObjType == SE_DS_OBJECT_ALL)
    {
        AclRevision = ACL_REVISION_DS;
    }

    PACCLIST_CNODE  pCDAcl = NULL;
    PACCLIST_CNODE  pCSAcl = NULL;
    ULONG           cDAcls = 0;
    ULONG           cSAcls = 0;
    ULONG           cDAclSize = 0;
    ULONG           cSAclSize = 0;

    dwErr = CompressList(DACL_SECURITY_INFORMATION,
                         &pCDAcl,
                         &cDAcls);
    if(dwErr == ERROR_SUCCESS)
    {
        if(cDAcls != 0)
        {
            *pSeInfo = DACL_SECURITY_INFORMATION;
        }
        else
        {
            *pSeInfo = 0;
        }

        dwErr = CompressList(SACL_SECURITY_INFORMATION,
                             &pCSAcl,
                             &cSAcls);
        if(dwErr == ERROR_SUCCESS && cSAcls != 0)
        {
            *pSeInfo |= SACL_SECURITY_INFORMATION;
        }
    }

    //
    // Now, go through and size the DACL and SACL
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SizeCompressedListAsAcl(pCDAcl,
                                        cDAcls,
                                        &cDAclSize,
                                        FALSE);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SizeCompressedListAsAcl(pCSAcl,
                                            cSAcls,
                                            &cSAclSize,
                                            TRUE);
        }
    }

    //
    // If all that worked, add in our security descriptor size and owner/group
    //
    ULONG   cSize = 0;
    if(dwErr == ERROR_SUCCESS)
    {
        cSize = cDAclSize + cSAclSize;
        cSize += sizeof(SECURITY_DESCRIPTOR);

        //
        // Owner and group
        //
        if(_pOwner != NULL)
        {
            cSize += RtlLengthSid(_pOwner);
            *pSeInfo |= OWNER_SECURITY_INFORMATION;
        }

        if(_pGroup != NULL)
        {
            cSize += RtlLengthSid(_pGroup);
            *pSeInfo |= GROUP_SECURITY_INFORMATION;
        }

        if(FLAG_ON(fFlags, ACCLIST_SD_DS_STYLE))
        {
            cSize += sizeof(ULONG);
        }
    }

    //
    // If that worked, then we'll allocate for the security descriptor.
    // We allocate in a block, so we can free it in another routine later
    //
    BOOL                    fProtected=FALSE;
    PSECURITY_DESCRIPTOR    pSD;
    if(dwErr == ERROR_SUCCESS)
    {
        pSD = (PSECURITY_DESCRIPTOR)AccAlloc(cSize);
        if(pSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            PBYTE   pbEndOBuff = (PBYTE)pSD + cSize;

            if(FLAG_ON(fFlags, ACCLIST_SD_DS_STYLE))
            {
                pSD = (PSECURITY_DESCRIPTOR)((PBYTE)pSD + sizeof(ULONG));
            }

            _cSDSize = cSize;

            //
            // First, build an absolute SD
            //
            if(InitializeSecurityDescriptor(pSD,
                                            SECURITY_DESCRIPTOR_REVISION) ==
                                                                        FALSE)
            {
                dwErr = GetLastError();
            }

            //
            // First, set the owner
            //
            if(dwErr == ERROR_SUCCESS && _pOwner != NULL)
            {
                PSID pOwner = (PSID)(pbEndOBuff - RtlLengthSid(_pOwner));
                RtlCopySid((ULONG)(pbEndOBuff - (PBYTE)pOwner),
                           pOwner,
                           _pOwner);
                pbEndOBuff = (PBYTE)pOwner;
                if(SetSecurityDescriptorOwner(pSD,
                                              pOwner,
                                              FALSE) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            //
            // Next, try our hand with the group
            //
            if(dwErr == ERROR_SUCCESS && _pGroup != NULL)
            {
                PSID pGroup = (PSID)(pbEndOBuff - RtlLengthSid(_pGroup));
                RtlCopySid((ULONG)(pbEndOBuff - (PBYTE)pGroup),
                           pGroup,
                           _pGroup);
                pbEndOBuff = (PBYTE)pGroup;
                if(SetSecurityDescriptorGroup(pSD,
                                              pGroup,
                                              FALSE) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            //
            // Ok, then the DACL
            //
            if(dwErr == ERROR_SUCCESS && cDAclSize != 0)
            {
                PACL pAcl = (PACL)(pbEndOBuff - cDAclSize);

                pAcl->AclRevision = AclRevision;
                pAcl->Sbz1        = (BYTE)_fDAclFlags;
                pAcl->AclSize     = (USHORT)cDAclSize;
                pAcl->AceCount    = 0;

                if(cDAclSize > sizeof(ACL))
                {
                    dwErr = BuildAcl(pCDAcl,
                                     cDAcls,
                                     pAcl,
                                     DACL_SECURITY_INFORMATION,
                                     &fProtected);

#if DBG
                    if(dwErr == ERROR_SUCCESS)
                    {
                        DWORD cChk = 0;

                        PKNOWN_ACE pAce = (PKNOWN_ACE)FirstAce(pAcl);
                        for(ULONG z = 0; z < pAcl->AceCount; z++)
                        {
                            cChk += (DWORD)pAce->Header.AceSize;

                            pAce = (PKNOWN_ACE)NextAce(pAce);
                        }

                        cChk += sizeof(ACL);

                        ASSERT(cChk == cDAclSize);

                    }
#endif
                }
                else
                {
                    if( FLAG_ON(_fDAclFlags, ACCLIST_DACL_PROTECTED ))
                    {
                        ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_DACL_PROTECTED;
                    }

                }

                pbEndOBuff = (PBYTE)pAcl;

                if(dwErr == ERROR_SUCCESS)
                {
                    if(SetSecurityDescriptorDacl(pSD,
                                                 TRUE,
                                                 pAcl,
                                                 FALSE) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                    if(dwErr == ERROR_SUCCESS && fProtected == TRUE)
                    {
                        ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_DACL_PROTECTED;
                    }
                }

            }
            else
            {

                if( cDAclSize == 0 && FLAG_ON(_fDAclFlags,ACCLIST_DACL_PROTECTED ))
                {
                    ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_DACL_PROTECTED;
                }

                if ( FLAG_ON( *pSeInfo, DACL_SECURITY_INFORMATION ) )
                {
                    if(SetSecurityDescriptorDacl(pSD,
                                                 TRUE,
                                                 NULL,
                                                 FALSE) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }

            }

            //
            // Finally, the SACL
            //
            fProtected=FALSE;

            if(dwErr == ERROR_SUCCESS && cSAclSize != 0)
            {
                PACL pAcl = (PACL)(pbEndOBuff - cSAclSize);

                pAcl->AclRevision = AclRevision;
                pAcl->Sbz1        = (BYTE)_fSAclFlags;
                pAcl->AclSize     = (USHORT)cSAclSize;
                pAcl->AceCount    = 0;

                if(cSAclSize > sizeof(ACL))
                {
                    dwErr = BuildAcl(pCSAcl,
                                     cSAcls,
                                     pAcl,
                                     SACL_SECURITY_INFORMATION,
                                     &fProtected);
                }
                else
                {

                    if( FLAG_ON(_fSAclFlags,ACCLIST_SACL_PROTECTED ))
                    {
                        ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_SACL_PROTECTED;
                    }

                }


                pbEndOBuff = (PBYTE)pAcl;


                if(dwErr == ERROR_SUCCESS)
                {
                    if(SetSecurityDescriptorSacl(pSD,
                                                 TRUE,
                                                 pAcl,
                                                 FALSE) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                    if(dwErr == ERROR_SUCCESS && fProtected == TRUE)
                    {
                        ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_SACL_PROTECTED;
                    }
                }

            }
            else
            {
                if( cSAclSize == 0 && FLAG_ON(_fSAclFlags, ACCLIST_SACL_PROTECTED ))
                {
                    ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_SACL_PROTECTED;
                }

                if ( FLAG_ON( *pSeInfo, SACL_SECURITY_INFORMATION ) )
                {
                    if(SetSecurityDescriptorSacl(pSD,
                                                 TRUE,
                                                 NULL,
                                                 FALSE) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }
            }


#if DBG
            if(dwErr == ERROR_SUCCESS)
            {
                ASSERT(pbEndOBuff == (PBYTE)pSD + sizeof(SECURITY_DESCRIPTOR));
                acDebugOut((DEB_TRACE_ACC,"pbEndOBuff: 0x%lx\n", pbEndOBuff));
                acDebugOut((DEB_TRACE_ACC,"pSD: 0x%lx\n",
                                       (PBYTE)pSD + sizeof(SECURITY_DESCRIPTOR)));
            }
#endif


            //
            // Great.. Now if all of that worked, we'll convert it to
            // an absolute format if necessary, or
            //
            if(dwErr == ERROR_SUCCESS)
            {
                if(FLAG_ON(fFlags,ACCLIST_SD_ABSOK))
                {
                    *ppSD = pSD;
                }
                else
                {
                    //
                    // We'll need to make this self relative
                    //
                    ULONG cNewSDSize = 0;
                    MakeSelfRelativeSD(pSD,
                                       NULL,
                                       &cNewSDSize);
                    ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

                    if(FLAG_ON(fFlags,ACCLIST_SD_DS_STYLE))
                    {
                        cNewSDSize += sizeof(ULONG);
                    }

                    *ppSD = (PSECURITY_DESCRIPTOR)AccAlloc(cNewSDSize);
                    if(*ppSD == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        if(FLAG_ON(fFlags,ACCLIST_SD_DS_STYLE))
                        {
                            *ppSD = (PSECURITY_DESCRIPTOR)
                                       ((PBYTE)*ppSD + sizeof(ULONG));
                        }
                        _cSDSize = cNewSDSize;
                        if(MakeSelfRelativeSD(pSD,
                                              *ppSD,
                                              &cNewSDSize) == FALSE)
                        {
                            dwErr = GetLastError();
                        }
                        else
                        {
                            if(FLAG_ON(fFlags, ACCLIST_SD_DS_STYLE))
                            {
                                pSD = (PSECURITY_DESCRIPTOR)((PBYTE)pSD - sizeof(ULONG));
                            }
                            //
                            // It all worked, so free our initial sd
                            //
                            AccFree(pSD);
                        }
                    }
                }
            }



            if(dwErr != ERROR_SUCCESS)
            {
                if(FLAG_ON(fFlags, ACCLIST_SD_DS_STYLE))
                {
                    pSD = (PSECURITY_DESCRIPTOR)((PBYTE)pSD - sizeof(ULONG));
                }
                AccFree(pSD);
            }
        }
    }

    //
    // Save and return our security information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        _pSD     = *ppSD;
        _SeInfo  = *pSeInfo;
    }

    //
    // Set our flags properly
    //
    if(dwErr == ERROR_SUCCESS)
    {
        if(FLAG_ON(*pSeInfo, DACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR)_pSD)->Control |=
                                                    SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(*pSeInfo, SACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR)_pSD)->Control |=
                                                    SE_SACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(fFlags,ACCLIST_SD_DS_STYLE))
        {
            PULONG pSE = (PULONG)((PBYTE)*ppSD - sizeof(ULONG));
            *pSE = *pSeInfo;

            *ppSD = (PSECURITY_DESCRIPTOR)pSE;
        }
    }


    FreeCompressedList(pCDAcl, cDAcls);
    FreeCompressedList(pCSAcl, cSAcls);


    if(dwErr != ERROR_SUCCESS)
    {

        _fFreeSD = FALSE;

    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::BuildSDForAccessList: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddOwnerGroup, public
//
//  Synopsis:   Adds an owner and or group to the class
//
//  Arguments:  [IN  SeInfo]        --      Add owner or group?
//              [IN  pOwner]        --      Owner to add
//              [IN  pGroup]        --      Group to add
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddOwnerGroup(IN  SECURITY_INFORMATION      SeInfo,
                                 IN  PTRUSTEE                  pOwner,
                                 IN  PTRUSTEE                  pGroup)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::AddOwnerGroup\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    SID_NAME_USE    SidType;
    //
    // Basically, we'll simply add them in..
    //
    if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
    {
        if(pOwner->TrusteeForm ==  TRUSTEE_IS_SID)
        {
            if(RtlValidSid((PSID)pOwner->ptstrName) == FALSE)
            {
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else
            {
                ACC_ALLOC_AND_COPY_SID((PSID)pOwner->ptstrName,_pOwner, dwErr);
            }
        }
        else
        {
            dwErr = AccctrlLookupSid(_pwszLookupServer,
                                     pOwner->ptstrName,
                                     TRUE,
                                     &_pOwner,
                                     &SidType);
        }
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
    {
        if(pGroup->TrusteeForm ==  TRUSTEE_IS_SID)
        {
            if(RtlValidSid((PSID)pGroup->ptstrName) == FALSE)
            {
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else
            {
                ACC_ALLOC_AND_COPY_SID((PSID)pGroup->ptstrName,_pGroup, dwErr);
            }
        }
        else
        {
            dwErr = AccctrlLookupSid(_pwszLookupServer,
                                     pGroup->ptstrName,
                                     TRUE,
                                     &_pGroup,
                                     &SidType);
        }
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::AddOwnerGroup: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetSDSidAsTrustee, public
//
//  Synopsis:   Returns the specified owner/group as a trustee...
//
//  Arguments:  [IN  SeInfo]        --      Get owner or group?
//              [OUT ppTrustee]     --      Where the trustee is returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetSDSidAsTrustee(IN  SECURITY_INFORMATION      SeInfo,
                                     OUT PTRUSTEE                 *ppTrustee)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GetSDSidAsTrustee\n"));
    DWORD   dwErr = ERROR_SUCCESS;


    PSID    pSid;
    if(FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
    {
        pSid = _pGroup;
    }
    else
    {
        pSid = _pOwner;
    }

    dwErr = AccLookupAccountTrustee(_pwszLookupServer,
                                    pSid,
                                    ppTrustee);

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GetSDSidAsTrustee: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetExplicitEntries, public
//
//  Synopsis:   Returns a list of explicit entries for the given trustee.
//              This will lookup group membership
//
//  Arguments:  [IN  pTrustee]      --      Trustee to lookup
//              [IN  pwszProperty]  --      Property to worry about
//              [IN  SeInfo]        --      Look for access or audit list
//              [OUT pcEntries]     --      Where the count of items is
//                                          returned.
//              [OUT ppAEList]      --      Where the explicit entry list is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetExplicitEntries(IN  PTRUSTEE              pTrustee,
                                      IN  PWSTR                 pwszProperty,
                                      IN  SECURITY_INFORMATION  SeInfo,
                                      OUT PULONG                pcEntries,
                                      OUT PACTRL_ACCESS_ENTRYW *ppAEList)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GetExplicitEntries\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, get the specified access list for our property
    //
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)pwszProperty,
                                                           CompProps);
    if(pAccNode == NULL)
    {
        //
        // Whoops... No such property...
        //

        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PACTRL_ACCESS_ENTRY_LIST pList = pAccNode->pAccessList;

        if(pList != NULL)
        {
            //
            // Now, we'll process each one of the entries, and build our masks
            //

            CSList  MemberList(NULL);

            //
            // Add our trustee, so we get our information
            //
            PTRUSTEE_NODE   pTNode;
            dwErr = GetTrusteeNode(pTrustee,
                                   TRUSTEE_OPT_SID,
                                   &pTNode);

            if(dwErr == ERROR_SUCCESS)
            {
                CMemberCheck    MemberCheck(pTNode);
                dwErr = MemberCheck.Init();

                //
                // Now, we'll just go
                //
                for(ULONG iIndex = 0;
                    iIndex < pList->cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    PTRUSTEE_NODE   pATNode;
                    dwErr = GetTrusteeNode(
                                       &(pList->pAccessList[iIndex].Trustee),
                                       TRUSTEE_OPT_SID,
                                       &pATNode);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        BOOL    fAddMask;
                        dwErr = MemberCheck.IsMemberOf(pATNode,
                                                       &fAddMask);
                        if(dwErr == ERROR_SUCCESS && fAddMask == TRUE)
                        {
                            dwErr = MemberList.Insert((PVOID)
                                                &pList->pAccessList[iIndex]);
                        }
                    }
                }
            }

            //
            // Ok, if we have everything, build our list
            //
            if(dwErr == ERROR_SUCCESS)
            {
                *pcEntries = 0;
                if(MemberList.QueryCount() == 0)
                {
                    *ppAEList = NULL;
                }
                else
                {
                    dwErr = GetTrusteeNode(pTrustee,
                                           TRUSTEE_OPT_NAME,
                                           &pTNode);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        ULONG cSize = SIZE_PWSTR(pTNode->pwszTrusteeName);

                        cSize += MemberList.QueryCount() *
                                                   sizeof(ACTRL_ACCESS_ENTRY);

                        *ppAEList = (PACTRL_ACCESS_ENTRY)AccAlloc(cSize);

                        if(*ppAEList == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            PWSTR pwszTrustee = (PWSTR)((PBYTE)(*ppAEList) +
                                                    (MemberList.QueryCount() *
                                                     sizeof(ACTRL_ACCESS_ENTRY)));
                            wcscpy(pwszTrustee,
                                   pTNode->pwszTrusteeName);

                            //
                            // Now, copy the rest of the information
                            //
                            MemberList.Reset();
                            PACTRL_ACCESS_ENTRY pCurrent =
                                   (PACTRL_ACCESS_ENTRY)MemberList.NextData();
                            while(pCurrent != NULL)
                            {
                                memcpy(&((*ppAEList)[*pcEntries]),
                                       pCurrent,
                                       sizeof(ACTRL_ACCESS_ENTRY));

                                //
                                // Then, adjust the trustee...
                                //
                                (*ppAEList)[*pcEntries].Trustee.TrusteeType =
                                                       pTrustee->TrusteeType;

                                (*ppAEList)[*pcEntries].Trustee.TrusteeForm =
                                                             TRUSTEE_IS_NAME;
                                (*ppAEList)[*pcEntries].Trustee.ptstrName =
                                                                 pwszTrustee;
                                pCurrent =
                                   (PACTRL_ACCESS_ENTRY)MemberList.NextData();
                                (*pcEntries)++;
                            }
                        }
                    }
                }
            }
        }
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GetExplicitEntries: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::RevokeTrusteeAccess, public
//
//  Synopsis:   Removes any explicit entries that exist for the named
//              trustees
//
//  Arguments:  [IN  SeInfo]        --      Whether to process the access and
//                                          or audit list
//              [IN  pSrcList]      --      Trustee information list to
//                                          process
//              [IN  pwszProperty]  --      Optional property to do the revoke for
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::RevokeTrusteeAccess(IN  SECURITY_INFORMATION    SeInfo,
                                       IN  PACTRL_ACCESSW          pSrcList,
                                       IN  PWSTR                   pwszProperty OPTIONAL)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::RevokeTrusteeAccess\n"));

    CSList  TrusteeList(NULL);

    //
    // First, generate a list of all of the passed in trustees
    //
    for(ULONG iAcc = 0;
        iAcc < pSrcList->cEntries && dwErr == ERROR_SUCCESS;
        iAcc++)
    {
        PACTRL_ACCESS_ENTRY_LIST  pAEL =
                      pSrcList->pPropertyAccessList[iAcc].pAccessEntryList;

        //
        // Then the access entry strings
        //
        for(ULONG iEntry = 0;
            pAEL && iEntry < pAEL->cEntries && dwErr == ERROR_SUCCESS;
            iEntry++)
        {
            dwErr = TrusteeList.InsertIfUnique(
                              (PVOID)&(pAEL->pAccessList[iEntry].Trustee),
                              CompTrustees);
        }
    }

    //
    // Ok, now if that worked, we have a list of trustees... We'll simply
    // go through and revoke them all from our current list before
    // continuing
    //
    TrusteeList.Reset();
    PTRUSTEE    pTrustee = (PTRUSTEE)TrusteeList.NextData();
    while(pTrustee != NULL && dwErr == ERROR_SUCCESS)
    {
        TRUSTEE TempTrustee;
        TempTrustee.TrusteeForm = TRUSTEE_IS_SID;
        TempTrustee.ptstrName = NULL;

        //
        // If we have a domain relative name, we'll look the name as a sid
        //
        if(pTrustee->TrusteeForm == TRUSTEE_IS_NAME && wcschr(pTrustee->ptstrName, L'\\') == NULL)
        {
            SID_NAME_USE    Type;
            dwErr = AccctrlLookupSid(_pwszLookupServer,
                                     pTrustee->ptstrName,
                                     TRUE,
                                     (PSID *)&(TempTrustee.ptstrName),
                                     &Type);

            if(dwErr == ERROR_SUCCESS)
            {
                pTrustee = &TempTrustee;
            }

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = RemoveTrusteeFromAccess(SeInfo,
                                            pTrustee,
                                            pwszProperty);
        }

        AccFree(TempTrustee.ptstrName);

        pTrustee = (PTRUSTEE)TrusteeList.NextData();
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GetExplicitEntries: %lu\n",
                dwErr));
    return(dwErr);
}








//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CompressList, private
//
//  Synopsis:
//
//  Arguments:  []        --      Whether to process the access and
//                                          or audit list
//              []      --      Trustee information list to
//                                          process
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::CompressList(IN  SECURITY_INFORMATION   SeInfo,
                                OUT PACCLIST_CNODE        *ppList,
                                OUT PULONG                 pcItems)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::CompressList\n"));
    BOOL    fEmpty = FALSE;

    //
    // Ok, first, we'll have to go through and determine how many items there
    // are
    //
    *pcItems = 0;
    *ppList = 0;
    _AccList.Reset();
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.NextData();
    while(pAccNode != NULL)
    {
        if(FLAG_ON(pAccNode->SeInfo, SeInfo))
        {
            (*pcItems)++;
        }
        pAccNode = (PACCLIST_NODE)_AccList.NextData();
    }

    //
    // Now, do some allocations
    //
    if(*pcItems != 0)
    {
        *ppList = (PACCLIST_CNODE)AccAlloc(sizeof(ACCLIST_CNODE) * *pcItems);
        if(*ppList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            _AccList.Reset();
            ULONG i = 0;
            while(i < *pcItems )
            {
                pAccNode = (PACCLIST_NODE)_AccList.NextData();

                if(FLAG_ON(pAccNode->SeInfo, SeInfo))
                {
                    (*ppList)[i++].pONode = pAccNode;
                }
            }

            //
            // Now, sort the list based upon the property name
            //
            qsort(*ppList,
                  *pcItems,
                  sizeof(ACCLIST_CNODE),
                  CNodeCompare);
            //
            // Now, start processing them all...
            //
            for(i = 0; i < *pcItems; i++)
            {
                PACCLIST_CNODE pCN = &(*ppList)[i];
                PACTRL_ACCESS_ENTRY_LIST pList =
                        SeInfo == DACL_SECURITY_INFORMATION ?
                                                pCN->pONode->pAccessList :
                                                pCN->pONode->pAuditList;
                if(pList == NULL)
                {
                    continue;
                }

                if(pList->cEntries == 0)
                {

                    fEmpty = TRUE;
                    (*ppList)[i].Empty = TRUE;
                    pList->pAccessList = NULL;
                }
                else
                {
                    fEmpty = FALSE;
                }


                //
                // Go through and build some temprorary lists for each
                // type.
                //
                CSList  ExpList(NULL);
                CSList  L1List(NULL);
                CSList  L2List(NULL);

                //
                // We'll go through each entry and add it to our
                // proper list.  We'll also check for entries to
                // collapse here as well.  We'll do this by having our
                // node comparrison routine mark the new access entry with
                // a special bit if it finds a match
                //
                for(ULONG j = 0; j < pList->cEntries && !fEmpty; j++)
                {
                    //
                    // Mark our ordering information
                    //
                    pList->pAccessList[j].fAccessFlags |=
                            GetOrderTypeForAccessEntry(
                                            (*ppList)[i].pONode->pwszProperty,
                                            &pList->pAccessList[j],
                                            SeInfo);
                    if(FLAG_ON(pList->pAccessList[j].Inheritance,
                               INHERITED_GRANDPARENT))
                    {
                        dwErr = L2List.InsertIfUnique(
                                                &(pList->pAccessList[j]),
                                                CompAndMarkCompressNode);
                    }
                    else if(FLAG_ON(pList->pAccessList[j].Inheritance,
                                    INHERITED_PARENT) ||
                            FLAG_ON(pList->pAccessList[j].Inheritance,
                                    INHERITED_ACCESS_ENTRY))
                    {
                        dwErr = L1List.InsertIfUnique(
                                                &(pList->pAccessList[j]),
                                                CompAndMarkCompressNode);
                    }
                    else
                    {
                        dwErr = ExpList.InsertIfUnique(
                                                &(pList->pAccessList[j]),
                                                CompAndMarkCompressNode);
                    }

                    if(dwErr != ERROR_SUCCESS)
                    {
                        break;
                    }
                } // for(j = 0; j < pList->cEntries; j++)

                if ( fEmpty ) {

                     dwErr = ExpList.Insert( &(pList->pAccessList));

                }

                //
                // Ok, now we are read to actually build our new list
                //
                ULONG cUsed = ExpList.QueryCount() + L1List.QueryCount() +
                                                         L2List.QueryCount();
                ULONG cCompressed = pList->cEntries - cUsed;

                if(dwErr == ERROR_SUCCESS)
                {
                    pCN->pList = (PACTRL_ACCESS_ENTRY)AccAlloc(
                                    sizeof(ACTRL_ACCESS_ENTRY) * cUsed);
                    if(pCN->pList == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        //
                        // Start processing them all...
                        //
                        ULONG iIndex = 0;
                        ULONG cComp;
                        pCN->cExp = ExpList.QueryCount();
                        pCN->cL1Inherit = L1List.QueryCount();
                        pCN->cL2Inherit = L2List.QueryCount();

                        if(pCN->cExp != 0)
                        {
                            dwErr = AddSubList(pCN,
                                               ExpList,
                                               iIndex);
                        }

                        if(dwErr == ERROR_SUCCESS && pCN->cL1Inherit != 0)
                        {
                            iIndex += pCN->cExp;

                            dwErr = AddSubList(pCN,
                                               L1List,
                                               iIndex);
                        }

                        if(dwErr == ERROR_SUCCESS && pCN->cL2Inherit != 0)
                        {
                            iIndex += pCN->cL1Inherit;
                            dwErr = AddSubList(pCN,
                                               L2List,
                                               iIndex);
                        }


                        //
                        // If that worked, we'll see about compressing
                        //
                        if(dwErr == ERROR_SUCCESS && cCompressed > 0)
                        {
                            for(j = 0;
                                j < pList->cEntries && cCompressed > 0;
                                j++)
                            {
                                if(FLAG_ON(pList->pAccessList[j].fAccessFlags,
                                           ACCLIST_COMPRESS))
                                {
                                    for(ULONG k = 0; k < cUsed; k++)
                                    {
                                        if(CompAndMarkCompressNode(
                                                &(pList->pAccessList[j]),
                                                &(pCN->pList[k])) == TRUE)
                                        {
                                            pList->pAccessList[j].fAccessFlags &=
                                                ~ACCLIST_COMPRESS;
                                            pCN->pList[k].fAccessFlags |=
                                                pList->pAccessList[j].fAccessFlags;
                                            pCN->pList[k].Access |=
                                                pList->pAccessList[j].Access;
                                            pCN->pList[k].Inheritance |=
                                                pList->pAccessList[j].Inheritance;
                                            pCN->pList[k].ProvSpecificAccess |=
                                                pList->pAccessList[j].ProvSpecificAccess;
                                        }
                                    }
                                }
                            }

                        }
                    }
                }

                if(dwErr != ERROR_SUCCESS  && cCompressed > 0)
                {
                    //
                    // We'll have to go through and undo any compress
                    // bits we may have set
                    //
                    for(ULONG k = 0; k < j; k++)
                    {
                        pList->pAccessList[j].fAccessFlags &=
                                                    ~ACCLIST_COMPRESS;
                    }

                }


            }
        }

        if(dwErr != ERROR_SUCCESS)
        {
            FreeCompressedList(*ppList,
                               *pcItems);
            *ppList = 0;
        }
        //
        // Handle the special case of the non-zero, empty list
        //
        else if(fEmpty == TRUE)
        {
            (*ppList)[0].cExp = 1;
        }
    }


    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::CompressList: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CompressList, private
//
//  Synopsis:
//
//  Arguments:  []        --      Whether to process the access and
//                                          or audit list
//              []      --      Trustee information list to
//                                          process
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID CAccessList::FreeCompressedList(IN  PACCLIST_CNODE   pList,
                                     IN  ULONG            cItems)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::FreeCompressedList\n"));

    if(pList != NULL)
    {
        for(ULONG i = 0; i < cItems; i++)
        {
            if(pList[i].pList == NULL)
            {
                break;
            }
            else
            {
                AccFree(pList[i].pList);
            }
        }

        AccFree(pList);
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::FreeCompressedList\n"));
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddSubList, private
//
//  Synopsis:
//
//  Arguments:  []        --      Whether to process the access and
//                                          or audit list
//              []      --      Trustee information list to
//                                          process
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddSubList(IN  PACCLIST_CNODE            pCList,
                              IN  CSList&                   TempList,
                              IN  ULONG                     iStart)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::AddSubList\n"));

    if ( pCList->Empty ) {

        return( dwErr );
    }
    //
    // First, we copy all of the list entries
    //
    TempList.Reset();
    PACTRL_ACCESS_ENTRY pAE = (PACTRL_ACCESS_ENTRY)TempList.NextData();
    ULONG i = iStart;
    while(pAE != NULL)
    {
        memcpy(&(pCList->pList[i]), pAE, sizeof(ACTRL_ACCESS_ENTRY));
        i++;
        pAE = (PACTRL_ACCESS_ENTRY)TempList.NextData();
    }

    //
    // Now, order them...
    //
    dwErr = OrderListBySid(pCList,
                           iStart,
                           TempList.QueryCount());


    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::AddSubList: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CompressList, private
//
//  Synopsis:
//
//  Arguments:  []        --      Whether to process the access and
//                                          or audit list
//              []      --      Trustee information list to
//                                          process
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::SizeCompressedListAsAcl(IN  PACCLIST_CNODE  pList,
                                           IN  ULONG           cItems,
                                           OUT PULONG          pcSize,
                                           IN  BOOL            fForceNullToEmpty)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::SizeCompressedListAsAcl\n"));
    ULONG   cTotalEnts = 0;
    BOOL    Empty = FALSE;

    *pcSize = 0;

    for(ULONG i = 0; i < cItems; i++)
    {
        ULONG cEnts = pList[i].cExp + pList[i].cL1Inherit + pList[i].cL2Inherit;
        cTotalEnts += cEnts;
        for(ULONG j = 0; j < cEnts; j++)
        {
            BOOL    fObjectAce = FALSE;
            if(pList[i].pONode->pwszProperty != NULL)
            {
                (*pcSize) += sizeof(GUID);
                fObjectAce = TRUE;
            }

            if(pList[i].pList == NULL || pList[i].Empty == TRUE)
            {
                continue;
            }

            if(pList[i].pList[j].lpInheritProperty != NULL)
            {
                (*pcSize) += sizeof(GUID);
                fObjectAce = TRUE;
            }

            //
            // Find the trustee for this node
            //
            PTRUSTEE_NODE   pTN = NULL;
            dwErr = GetTrusteeNode(&(pList[i].pList[j].Trustee),
                                   TRUSTEE_OPT_SID,
                                   &pTN);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Then, add in the SID
                //
                (*pcSize) += RtlLengthSid(pTN->pSid) - sizeof(ULONG);
                if(pTN->pImpersonate != NULL)
                {
                    (*pcSize) += RtlLengthSid(pTN->pSid);
                }
            }
            else
            {
                break;
            }

            //
            // Then, add the size of the ACE
            //
            if(pTN->pImpersonate != NULL)
            {
                if(fObjectAce == FALSE)
                {
                    (*pcSize) += sizeof(KNOWN_COMPOUND_ACE);
                }
                else
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                if(fObjectAce == TRUE)
                {
                    (*pcSize) += sizeof(KNOWN_OBJECT_ACE);
                }
                else
                {
                    (*pcSize) += sizeof(KNOWN_ACE);
                }
            }
        }

        if(cEnts == 0 && fForceNullToEmpty == TRUE)
        {
            Empty = TRUE;
        }
    }

    if(cTotalEnts != 0 || Empty == TRUE)
    {
        (*pcSize) += sizeof(ACL);
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::SizeCompressedListAsAcl: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::BuildAcl, private
//
//  Synopsis:   The method will build an acl out of the individual access entries
//
//  Arguments:  [pList]         --      List of entries in compressed form
//              [cItems]        --      Number of items in the list
//              [pAcl]          --      Acl to fill in
//              [SeInfo]        --      Building DACL or SACL
//              [pfProtected]   --      If TRUE, the acl should be protected
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::BuildAcl(IN  PACCLIST_CNODE         pList,
                            IN  ULONG                  cItems,
                            IN  PACL                   pAcl,
                            IN  SECURITY_INFORMATION   SeInfo,
                            OUT BOOL                  *pfProtected)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::BuildAcl\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fIsSacl = FALSE;


    PULONG  pIList = (PULONG)AccAlloc(cItems * sizeof(ULONG));
    if(pIList == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    //
    // Ok, now we'll process this list several times, so we get entries
    // in the following order:
    //
    // ACCESS_DENIED_ACE on the object
    // ACCESS_DENIED_OBJECT_ACE
    // ACCESS_ALLOWED_ACE on the object
    // ACCESS_ALLOWED_OBJECT_ACE on an object
    // ACCESS_ALLOWED_OBJECT_ACE on a property set
    // ACCESS_ALLOWED_OBJECT_ACE on a property
    //

    //
    // List of entry attributes we're looking for
    //
    ULONG EntryAttribs[] = {ACCLIST_DENIED,
                            ACCLIST_OBJ_DENIED,
                            ACCLIST_ALLOWED,
                            ACCLIST_OBJ_ALLOWED,
                            ACCLIST_PSET_ALLOWED,
                            ACCLIST_PROP_ALLOWED,
                            0};         // Cover anything out of place...

    //
    // Process all of the items
    //

    *pfProtected = FALSE;
    //
    // We'll process the list of compressed entries each time, looking for
    // entries from a different level (base, then inherited, then grandparent
    // inherited
    //
    ULONG InheritAttribs[] = {0,
                              INHERITED_PARENT,
                              INHERITED_GRANDPARENT};

    for(ULONG iInherit = 0;
        iInherit < sizeof(InheritAttribs) / sizeof(ULONG) && dwErr == ERROR_SUCCESS;
        iInherit++)
    {
        for(ULONG iEntry = 0;
            iEntry < sizeof(EntryAttribs) / sizeof(ULONG) && dwErr == ERROR_SUCCESS;
            iEntry++)
        {
            for(ULONG i = 0; i < cItems && dwErr == ERROR_SUCCESS; i++)
            {
                LPGUID  pObjectId = NULL;
                if(pList[i].pONode->pwszProperty != NULL)
                {
                    dwErr = AccctrlLookupGuid(_pLDAP,
                                        _pwszDsPathReference,
                                        pList[i].pONode->pwszProperty,
                                        FALSE,
                                        &pObjectId);

                }

                //
                // Process the items in the lists that match our criteria...
                //
                for(ULONG j = pIList[i];
                    j < pList[i].cExp + pList[i].cL1Inherit +
                                                        pList[i].cL2Inherit &&
                    dwErr == ERROR_SUCCESS;
                    j++)
                {
                    if((FLAG_ON(pList[i].pList[j].Inheritance,
                                InheritAttribs[iInherit]) ||
                       InheritAttribs[iInherit] == 0 &&
                       !FLAG_ON(pList[i].pList[j].Inheritance,
                                INHERITED_PARENT | INHERITED_GRANDPARENT)) &&
                       (FLAG_ON(pList[i].pList[j].fAccessFlags,
                                EntryAttribs[iEntry]) ||
                        EntryAttribs[iEntry] == 0))
                    {
                        //
                        // Ok, we can add this in
                        //
                        dwErr = InsertEntryInAcl(&(pList[i].pList[j]),
                                                 pObjectId,
                                                 pAcl);

                    }
                    else
                    {
                        break;
                    }

                }

                pIList[i] = j;

                //
                // See if it's protected
                //
                if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) &&
                   FLAG_ON(pList[i].pONode->fState, ACCLIST_DACL_PROTECTED))
                {
                    *pfProtected = TRUE;
                }

                if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) &&
                   FLAG_ON(pList[i].pONode->fState, ACCLIST_SACL_PROTECTED))
                {
                    *pfProtected = TRUE;
                }
            }
        }
    }

    AccFree(pIList);

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::BuildAcl: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::InsertEntryInAcl, private
//
//  Synopsis:   Inserts an access entry into the acl
//
//  Arguments:  [pAE]           --      Access entry to insert
//              [pObject]       --      If present, this is an object type ace
//              [pAcl]          --      Acl to do the insertion for
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_INVALID_ACL       A compound ace type was specified
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::InsertEntryInAcl(IN  PACTRL_ACCESS_ENTRY pAE,
                                    IN  GUID               *pObject,
                                    IN  PACL                pAcl)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LPGUID  pInheritId = NULL;
    BOOL    fIsObjectAce = FALSE;
    BOOL    fIsSacl = FALSE;

    if(pAE->lpInheritProperty != NULL)
    {
        dwErr = AccctrlLookupGuid(_pLDAP,
                            _pwszDsPathReference,
                            pAE->lpInheritProperty,
                            FALSE,
                            &pInheritId);
        fIsObjectAce = TRUE;
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }
    }

    if(pObject != NULL)
    {
        fIsObjectAce = TRUE;
    }

    //
    // First, get the trustee
    //
    PTRUSTEE_NODE   pTN;
    dwErr = GetTrusteeNode(&(pAE->Trustee),
                           TRUSTEE_OPT_SID,
                           &pTN);
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //
    // Add the ace
    //
    ACCESS_MASK AM = AccessMaskForAccessEntry(pAE, _ObjType);
    ACCESS_RIGHTS fAccess = pAE->fAccessFlags & ~ACCLIST_VALID_TYPE_FLAGS;
    INHERIT_FLAGS Inherit = pAE->Inheritance & ~ACCLIST_VALID_IN_LEVEL_FLAGS;


    if(dwErr == ERROR_SUCCESS)
    {
        if(pTN->pImpersonate == NULL)
        {
            if(fAccess == ACTRL_ACCESS_ALLOWED)
            {
                if(fIsObjectAce == TRUE)
                {
                    if(AddAccessAllowedObjectAce(
                                        pAcl,
                                        ACL_REVISION4,
                                        Inherit,
                                        AM,
                                        pObject,
                                        pInheritId,
                                        pTN->pSid) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                }
                else
                {
                    if(AddAccessAllowedAceEx(
                                        pAcl,
                                        ACL_REVISION2,
                                        Inherit,
                                        AM,
                                        pTN->pSid) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }
            }
            else if(fAccess == ACTRL_ACCESS_DENIED)
            {
                if(fIsObjectAce == TRUE)
                {
                    if(AddAccessDeniedObjectAce(
                                        pAcl,
                                        ACL_REVISION4,
                                        Inherit,
                                        AM,
                                        pObject,
                                        pInheritId,
                                        pTN->pSid) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                }
                else
                {
                    if(AddAccessDeniedAceEx(
                                        pAcl,
                                        ACL_REVISION2,
                                        Inherit,
                                        AM,
                                        pTN->pSid) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }
            }
            else if(FLAG_ON(fAccess,
                            (ACTRL_AUDIT_SUCCESS |
                                    ACTRL_AUDIT_FAILURE)))
            {
                fIsSacl = TRUE;
                if(fIsObjectAce == TRUE)
                {
                    if(AddAuditAccessObjectAce(
                                        pAcl,
                                        ACL_REVISION4,
                                        Inherit,
                                        AM,
                                        pObject,
                                        pInheritId,
                                        pTN->pSid,
                              FLAG_ON(fAccess,
                                      ACTRL_AUDIT_SUCCESS),
                              FLAG_ON(fAccess,
                                      ACTRL_AUDIT_FAILURE)) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                }
                else
                {
                    if(AddAuditAccessAceEx(
                          pAcl,
                          ACL_REVISION2,
                          Inherit,
                          AM,
                          pTN->pSid,
                          (BOOL)FLAG_ON(fAccess,
                                        ACTRL_AUDIT_SUCCESS),
                          (BOOL)FLAG_ON(fAccess,
                                        ACTRL_AUDIT_FAILURE)) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }


            }
            else
            {
                dwErr = ERROR_INVALID_ACL;
            }
        }
        else
        {
        #if 0
            if(pAE->fAccessFlags == ACTRL_ACCESS_ALLOWED)
            {
                NTSTATUS Status;
                if(pANList[j].pNode->pwszProperty != NULL)
                {
                    dwErr = ERROR_INVALID_ACL;
                }
                else
                {
                    Status = RtlAddCompoundAce(
                                pAcl,
                                ACL_REVISION3,
                                ACCESS_ALLOWED_COMPOUND_ACE_TYPE,
                                AM,
                                pTN->pSid,
                                pTN->pImpersonate->pSid);
                }
            }
            else
            {
                dwErr = ERROR_INVALID_ACL;
            }
            #endif
            //
            // Compound aces are disabled for the PDC
            //
            dwErr = ERROR_INVALID_ACL;
        }

    }

    //
    // Add in our protected flag...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ULONG fFlags = fIsSacl == FALSE  ?
                                    _fDAclFlags :
                                    _fSAclFlags;
        if(FLAG_ON(fFlags,ACTRL_ACCESS_PROTECTED))
        {
            pAcl->Sbz1 |= fIsSacl == FALSE  ?
                                    SE_DACL_PROTECTED :
                                    SE_SACL_PROTECTED;
        }
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\alsup.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:        alsup.cxx
//
//  Contents:    CAccessList support functions
//
//  Classes:
//
//  History:     06-Nov-96      MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <alsup.hxx>
#include <netlib.h>
#include <seopaque.h>
#include <sertlp.h>
#include <martaevt.h>
#include <ntprov.hxx>
#include <strings.h>

DWORD
InitializeEvents(void);



//+---------------------------------------------------------------------------
//
//  Function:   GetOrderTypeForAccessEntry
//
//  Synopsis:   Determines the "order" type of entry given the node
//              information
//
//  Arguments:  [pwszProperty]      --      The property this entry is
//                                          associated with
//              [pAE]               --      The entry to check
//              [SeInfo]            --      Type of node this is supposed to
//                                          be
//
//  Returns:    The type of the node.  This is a bitmask flag of the types
//              ACCLIST_DENIED through ACCLIST_PROP_ALLOWED
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG   GetOrderTypeForAccessEntry(IN  PWSTR                pwszProperty,
                                   IN  PACTRL_ACCESS_ENTRY  pAE,
                                   IN  SECURITY_INFORMATION SeInfo)
{
    ULONG Type = 0;

    //
    // First, check the simple cases (like audit or invalid)
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        if(FLAG_ON(pAE->fAccessFlags,
                   ACTRL_AUDIT_SUCCESS | ACTRL_AUDIT_FAILURE))
        {
            Type = ACCLIST_AUDIT;
        }
    }
    else
    {
        if(!FLAG_ON(pAE->fAccessFlags,
                ACTRL_AUDIT_SUCCESS  | ACTRL_AUDIT_FAILURE) &&
           FLAG_ON(pAE->fAccessFlags,
                  ACTRL_ACCESS_ALLOWED | ACTRL_ACCESS_DENIED))
        {
            Type = ACCLIST_UNKOWN_ENTRY;
        }
        else
        {
            Type = ACCLIST_AUDIT;
        }
    }


    if(Type == 0)
    {
        if(pwszProperty == NULL && pAE->lpInheritProperty == NULL)
        {
            Type = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    ACCLIST_DENIED  :
                                                    ACCLIST_ALLOWED;
        }
        else if(pwszProperty == NULL)
        {
            Type = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    ACCLIST_OBJ_DENIED  :
                                                    ACCLIST_PROP_ALLOWED;
        }
        else
        {
            Type = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    ACCLIST_OBJ_DENIED  :
                                                    ACCLIST_OBJ_ALLOWED;
        }

        //
        // See if it's inherited.  If it is, and we don't have a level
        // flag, assume it's level 1 and mark it as such
        //
        if(FLAG_ON(pAE->Inheritance, INHERITED_ACCESS_ENTRY) &&
           !FLAG_ON(pAE->Inheritance,
                            INHERITED_PARENT | INHERITED_GRANDPARENT))
        {
            pAE->Inheritance |= INHERITED_PARENT;
        }
    }

    return(Type);
}



//+---------------------------------------------------------------------------
//
//  Function:   OrderListBySid
//
//  Synopsis:   Orders an acclist_cnode list by sid.  The order would be:
//                  Everyone
//                  Well known groups
//                  Groups
//                  Users
//                  Anyone else
//
//  Arguments:  [pList]             --      List of the nodes to sort
//              [iStart]            --      Where to start in the list
//              [iLen]              --      Number of nodes in the list
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG   OrderListBySid(IN  PACCLIST_CNODE   pList,
                       IN  ULONG            iStart,
                       IN  ULONG            iLen)
{
    DWORD   dwErr = ERROR_SUCCESS;


    return(dwErr);
}





//
// Local functions
//
//+---------------------------------------------------------------------------
//
//  Function:   DelAcclistNode
//
//  Synopsis:   Deletes an ACCLIST_NODE that's kept in the _AccList.  This is
//              used by the CSList
//
//  Arguments:  [IN pvNode]     --      Node to delete
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
void DelAcclistNode(PVOID   pvNode)
{
    PACCLIST_NODE pNode = (PACCLIST_NODE)pvNode;

    AccFree(pNode->pAccessList);
    AccFree(pNode->pAuditList);
    AccFree(pNode->pwszProperty);

    AccFree(pNode);
}




//+---------------------------------------------------------------------------
//
//  Function:   DelTrusteeNode
//
//  Synopsis:   Deletes an TRUSTEE_NODE that's kept in the _TrusteeList.
//              This is used by the CSList
//
//  Arguments:  [IN pvNode]     --      Node to delete
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
void DelTrusteeNode(PVOID   pvNode)
{
    acDebugOut((DEB_TRACE_ACC, "IN DelTrusteeNode\n"));

    PTRUSTEE_NODE pNode = (PTRUSTEE_NODE)pvNode;

    if(FLAG_ON(pNode->fFlags,TRUSTEE_DELETE_SID))
    {
        AccFree(pNode->pSid);
    }

    if(FLAG_ON(pNode->fFlags,TRUSTEE_DELETE_NAME))
    {
        AccFree(pNode->pwszTrusteeName);
        AccFree(pNode->pwszDomainName);
    }
    else if(FLAG_ON(pNode->fFlags, TRUSTEE_DELETE_DOMAIN))
    {
        AccFree(pNode->pwszDomainName);
    }

    AccFree(pNode);

    acDebugOut((DEB_TRACE_ACC, "Out DelTrusteeNode\n"));
}




//+---------------------------------------------------------------------------
//
//  Function:   CompInheritProps
//
//  Synopsis:   Compare the given property name to the PIPROP_IN_BUFF stuct
//
//  Arguments:  [IN pvTrustee]  --      Trustee to look for
//              [IN pvNode2]    --      2nd node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompInheritProps(IN  PVOID      pvInheritProp,
                         IN  PVOID      pvNode2)
{
    BOOL    fRet = FALSE;
    PIPROP_IN_BUFF  pPIB = (PIPROP_IN_BUFF)pvNode2;

    if(pvInheritProp != NULL)
    {
        if(_wcsicmp((PWSTR)pvInheritProp, (PWSTR)(pPIB->pwszIProp)) == 0)
        {
            fRet = TRUE;
        }
    }

    return(fRet);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompTrustees
//
//  Synopsis:   Compare two TRUSTEE_NODES.  Used by _TrusteeList.
//
//  Arguments:  [IN pvTrustee]  --      Trustee to look for
//              [IN pvNode2]    --      2nd node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompTrustees(IN  PVOID     pvTrustee,
                     IN  PVOID     pvTrustee2)
{
    PTRUSTEE        pTrustee = (PTRUSTEE)pvTrustee;
    TRUSTEE_NODE    TrusteeNode;
    BOOL            Result = FALSE;

    memset( &TrusteeNode, 0, sizeof( TrusteeNode ) );
    memcpy( &TrusteeNode.Trustee, pvTrustee2, sizeof( TRUSTEE ) );

    Result = CompTrusteeToTrusteeNode(pvTrustee, &TrusteeNode);


    if(FLAG_ON(TrusteeNode.fFlags,TRUSTEE_DELETE_SID))
    {
        AccFree(TrusteeNode.pSid);
    }

    if(FLAG_ON(TrusteeNode.fFlags,TRUSTEE_DELETE_NAME))
    {
        AccFree(TrusteeNode.pwszTrusteeName);
        AccFree(TrusteeNode.pwszDomainName);
        TrusteeNode.pwszDomainName = NULL;
    }

    if(FLAG_ON(TrusteeNode.fFlags, TRUSTEE_DELETE_DOMAIN))
    {
        AccFree(TrusteeNode.pwszDomainName);
    }

    return(Result);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompTrusteeToTrusteeNode
//
//  Synopsis:   Compare two trustees for equality
//
//  Arguments:  [IN pvTrustee]  --      Trustee to look for
//              [IN pvNode2]    --      2nd node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompTrusteeToTrusteeNode(IN  PVOID     pvTrustee,
                                 IN  PVOID     pvNode2)
{
    PTRUSTEE        pTrustee = (PTRUSTEE)pvTrustee;
    PTRUSTEE_NODE   pNode2 = (PTRUSTEE_NODE)pvNode2;

    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fMatch = FALSE;
    if(pTrustee->MultipleTrusteeOperation ==
                                    pNode2->Trustee.MultipleTrusteeOperation)
    {
        //
        // Ok, first compare the base trustee information...
        //
        if(pTrustee->TrusteeForm != pNode2->Trustee.TrusteeForm)
        {
            //
            // We don't have matching information, so we'll have to look
            // it up.
            //
            ULONG fOptions = 0;

            if(pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
            {
                fOptions = TRUSTEE_OPT_NAME;
            }
            else
            {
                fOptions = TRUSTEE_OPT_SID;
            }

            dwErr = LookupTrusteeNodeInformation(NULL,  
                                                 pNode2,
                                                 fOptions);
        }

        //
        // Now, do the comparrisons
        //
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, compare the trustees
            //
            if(pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
            {
                if(_wcsicmp(pTrustee->ptstrName,
                            pNode2->pwszTrusteeName ?
                                pNode2->pwszTrusteeName :
                                pNode2->Trustee.ptstrName) == 0)
                {
                    fMatch = TRUE;
                }
            }
            else
            {
                if(pTrustee->ptstrName == NULL ||
                   (pNode2->Trustee.ptstrName == NULL && pNode2->pSid == NULL))
                {
                    fMatch = FALSE;
                }
                else
                {
                    fMatch = RtlEqualSid((PSID)(pTrustee->ptstrName),
                                         (PSID)(pNode2->pSid ?
                                                    pNode2->pSid :
                                                    pNode2->Trustee.ptstrName));
                }
            }
        }

        //
        // Now, if that worked, look for the multiple trustee case
        //
        if(fMatch == TRUE &&
                pTrustee->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
        {
            fMatch = CompTrusteeToTrusteeNode(pTrustee->pMultipleTrustee,
                                              pNode2->pImpersonate);
        }
    }

    return(fMatch);
}




//+---------------------------------------------------------------------------
//
//  Function:   DoPropertiesMatch
//
//  Synopsis:   Determines if 2 properties are equal.  It takes into account
//              the possibility of a NULL property.
//
//  Arguments:  [IN pwszProp1]  --      1st property to compare
//              [IN pwszProp2]  --      2nd property to compare
//
//  Returns:    TRUE            --      Properties are equal
//              FALSE           --      Properties are not equal
//
//----------------------------------------------------------------------------
BOOL DoPropertiesMatch(IN  PWSTR    pwszProp1,
                       IN  PWSTR    pwszProp2)
{
    BOOL    fReturn = FALSE;

    if(pwszProp1 == NULL || pwszProp2 == NULL)
    {
        if(pwszProp1 == pwszProp2)
        {
            fReturn = TRUE;
        }
    }
    else
    {
        if(_wcsicmp(pwszProp1, pwszProp2) == 0)
        {
            fReturn = TRUE;
        }
    }

    return(fReturn);
}





//+---------------------------------------------------------------------------
//
//  Function:   CompProps
//
//  Synopsis:   Compare an ACCLIST_NODE to a property
//
//  Arguments:  [IN pvProp]     --      Property string
//              [IN pvNode]     --      Node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompProps(IN  PVOID     pvProp,
                  IN  PVOID     pvNode)
{
    PACCLIST_NODE    pAN = (PACCLIST_NODE)pvNode;

    return(DoPropertiesMatch((PWSTR)pvProp, pAN->pwszProperty));
}




//+---------------------------------------------------------------------------
//
//  Function:   CompGuids
//
//  Synopsis:   Compare an ACCLIST_ATOACCESS structure to a guid
//
//  Arguments:  [IN pvGuid]     --      Guid
//              [IN pvNode]     --      Node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompGuids(IN  PVOID     pvGuid,
                  IN  PVOID     pvNode)
{
    PACCLIST_ATOACCESS  pAA = (PACCLIST_ATOACCESS)pvNode;
    GUID               *pGuid = (GUID *)pvGuid;

    if(pGuid == NULL && pAA->pGuid == NULL)
    {
        return(TRUE);
    }
    else if(pGuid == NULL || pAA->pGuid == NULL)
    {
        return(FALSE);
    }

    return((BOOL)!memcmp(pGuid, pAA->pGuid, sizeof(GUID)));
}




//+---------------------------------------------------------------------------
//
//  Function:   LookupTrusteeNodeInformation
//
//  Synopsis:   Looks up the appropriate trustee information.  This involves
//              either looking up the trustees sid or name, depending on
//              the options
//
//  Arguments:  [pwszServer]        --      Name of server to lookup information on
//              [pTrusteeNode]      --      Trustee to lookup the information
//                                          for
//              [fOptions]          --      What information to lookup
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD LookupTrusteeNodeInformation(IN  PWSTR          pwszServer,
                                   IN  PTRUSTEE_NODE  pTrusteeNode,
                                   IN  ULONG          fOptions)
{
    DWORD   dwErr = ERROR_SUCCESS;

    SID_NAME_USE    SidType = SidTypeUnknown;

    //
    // Need to make sure we have the SID
    //
    if(FLAG_ON(fOptions, TRUSTEE_OPT_SID))
    {
        //
        // Make sure we have the sids
        //
        if(pTrusteeNode->pSid == NULL)
        {
            dwErr = AccctrlLookupSid(pwszServer,
                                     pTrusteeNode->Trustee.ptstrName,
                                     TRUE,
                                     &(pTrusteeNode->pSid),
                                     &SidType);

            if(dwErr == ERROR_SUCCESS)
            {
                pTrusteeNode->fFlags |= TRUSTEE_DELETE_SID;
            }
        }
    }

    //
    // Ok, we need to have the name
    //
    if(dwErr == ERROR_SUCCESS && FLAG_ON(fOptions, TRUSTEE_OPT_NAME))
    {
        //
        // Make sure we have the name
        //
        if(pTrusteeNode->pwszTrusteeName == NULL)
        {
            dwErr = AccctrlLookupName(pwszServer,
                                      pTrusteeNode->pSid,
                                      TRUE,
                                      &(pTrusteeNode->pwszTrusteeName),
                                      &SidType);
            if(dwErr == ERROR_SUCCESS)
            {
                pTrusteeNode->fFlags |= TRUSTEE_DELETE_NAME;
            }
        }
    }

    //
    // Then, take care of our sid type
    //
    if(dwErr == ERROR_SUCCESS && pTrusteeNode->SidType == SidTypeUnknown)
    {
        pTrusteeNode->SidType = SidType;

        if(SidType == SidTypeUnknown)
        {
            pTrusteeNode->Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
        }
        else
        {
            pTrusteeNode->Trustee.TrusteeType = (TRUSTEE_TYPE)(SidType);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetATypeForEntry
//
//  Synopsis:   Determines the type of entry given the node information
//
//  Arguments:  [pwszProperty]      --      The property this entry is
//                                          associated with
//              [pAE]               --      The entry to check
//              [SeInfo]            --      Type of node this is supposed to
//                                          be
//
//  Returns:    The type of the node
//
//  Notes:
//
//----------------------------------------------------------------------------
ACC_ACLBLD_TYPE   GetATypeForEntry(IN  PWSTR                pwszProperty,
                                   IN  PACTRL_ACCESS_ENTRY  pAE,
                                   IN  SECURITY_INFORMATION SeInfo)
{
    ACC_ACLBLD_TYPE AType = AAT_DENIED;

    //
    // First, check the simple cases (like audit or invalid)
    //

    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        if(FLAG_ON(pAE->fAccessFlags,
                   ACTRL_AUDIT_SUCCESS | ACTRL_AUDIT_FAILURE))
        {
            AType = AAT_INVALID;
        }
    }
    else
    {
        if(!FLAG_ON(pAE->fAccessFlags,
                ACTRL_AUDIT_SUCCESS  | ACTRL_AUDIT_FAILURE) &&
           FLAG_ON(pAE->fAccessFlags,
                  ACTRL_ACCESS_ALLOWED | ACTRL_ACCESS_DENIED))
        {
            AType = AAT_INVALID;
        }
        else
        {
            AType = AAT_AUDIT;
        }
    }


    if(AType == 0)
    {
        if(pwszProperty == NULL && pAE->lpInheritProperty == NULL)
        {
            AType = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    AAT_DENIED  :
                                                    AAT_ALLOWED;
        }
        else if(pwszProperty == NULL)
        {
            AType = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    AAT_OBJ_DENIED  :
                                                    AAT_PROP_ALLOWED;
        }
        else
        {
            AType = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    AAT_OBJ_DENIED  :
                                                    AAT_OBJ_ALLOWED;
        }

        //
        // See if it's inherited
        //
        if(FLAG_ON(pAE->Inheritance, INHERITED_ACCESS_ENTRY))
        {
            AType =(ACC_ACLBLD_TYPE)
                    ((ULONG)AType + ((ULONG)AAT_IDENIED - (ULONG)AAT_DENIED));
        }
    }

    return(AType);
}




//+---------------------------------------------------------------------------
//
//  Function:   CNodeCompare
//
//  Synopsis:   Used by CSList class.  Used to determine if 2 acclist_cnodes are
//              identical, based upon the property
//
//  Arguments:  [pv1]               --      1st node
//              [pv2]               --      2nd node
//
//  Returns:    0   on equality
//              non-0 otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
int __cdecl CNodeCompare(const void  *pv1, const void  *pv2)
{
    PACCLIST_CNODE  pCN1 = (PACCLIST_CNODE)pv1;
    PACCLIST_CNODE  pCN2 = (PACCLIST_CNODE)pv2;

    if(pCN1->pONode->pwszProperty == NULL)
    {
        return(-1);
    }

    if(pCN2->pONode->pwszProperty == NULL)
    {
        return(1);
    }

    return(_wcsicmp(pCN1->pONode->pwszProperty, pCN2->pONode->pwszProperty));
}








//+---------------------------------------------------------------------------
//
//  Function:   CompAndMarkCompressNode
//
//  Synopsis:   Used by CSList class.  Used to determine if 2 nodes can be
//              compressed into one.  If so, the first node has its access
//              flag marked with a bit signifying it can be compressed.  See
//              below for the definition of what it means to be compressible
//
//  Arguments:  [pvAE]              --      New node
//              [pvNode]            --      Node already existing in list
//
//  Returns:    0   on equality
//              non-0 otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL  CompAndMarkCompressNode(IN  PVOID pvAE,
                              IN  PVOID pvNode)
{
    PACTRL_ACCESS_ENTRY pAE1 = (PACTRL_ACCESS_ENTRY)pvAE;
    PACTRL_ACCESS_ENTRY pAE2 = (PACTRL_ACCESS_ENTRY)pvNode;

    //
    // We will consider nodes identical iff:
    // They match trustee, inheritance, and access flags exactly and the
    // inherit property or (along with the rest of the above):
    //  - Both nodes are inherited and one is marked l1 inherited and the
    //    other is not marked at all, or neither node is inherited
    //    and the inheritance is identical or the inheritance is different
    //    but the access masks are the same
    //  - fAccessFlags indicates that combining this 2 nodes will still
    //    yield an audit node.
    //
    if(CompTrustees(&pAE1->Trustee,&pAE2->Trustee) == TRUE &&
        //
        // Check the inheritance
        //
       (pAE1->Inheritance == pAE2->Inheritance ||
        (pAE1->Inheritance & ~INHERITED_PARENT) ==
                                    (pAE2->Inheritance & ~INHERITED_PARENT) ||
        (!FLAG_ON(pAE1->Inheritance, INHERITED_ACCESS_ENTRY) &&
         !FLAG_ON(pAE2->Inheritance, INHERITED_ACCESS_ENTRY)&&
         (pAE1->Inheritance != 0 && pAE2->Inheritance != 0) &&
         (pAE1->Access) == pAE2->Access)) &&
         //
         // Check the access
         //

        (((pAE1->fAccessFlags & ~(ACCLIST_COMPRESS | ~ACCLIST_VALID_TYPE_FLAGS)) ==
                                          ( pAE2->fAccessFlags & ~~ACCLIST_VALID_TYPE_FLAGS ) ||
        (((((pAE1->fAccessFlags & ~(ACCLIST_COMPRESS | ~ACCLIST_VALID_TYPE_FLAGS)) |
                                          (pAE2->fAccessFlags & ~~ACCLIST_VALID_TYPE_FLAGS)) &
                 ~(ACTRL_AUDIT_SUCCESS | ACTRL_AUDIT_FAILURE)) == 0))) &&
                 pAE1->Access == pAE2->Access) &&
        //
        // Check the properties
        //
        DoPropertiesMatch(pAE1->lpInheritProperty,
                          pAE2->lpInheritProperty) == TRUE)
    {
        pAE1->fAccessFlags |= ACCLIST_COMPRESS;
        return(TRUE);
    }

    return(FALSE);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetNodeForProperty
//
//  Synopsis:   This function will lookup the existing list node for the given
//              property.  If the node doesn't exist, it will be created and
//              inserted into the list
//
//  Arguments:  [List]              --      List to examine
//              [pwszProperty]      --      The property to look for
//              [ppNode]            --      Where the found or inserted node is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD GetNodeForProperty(CSList&        List,
                         PWSTR          pwszProperty,
                         PACCLIST_NODE *ppNode)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACCLIST_NODE pAccNode = (PACCLIST_NODE)List.Find(pwszProperty,
                                                      CompProps);
    if(pAccNode == NULL)
    {
        //
        // Doesn't exist.  We'll have to add it...
        //
        pAccNode = (PACCLIST_NODE)AccAlloc(sizeof(ACCLIST_NODE));
        if(pAccNode == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if(pwszProperty != NULL)
            {
                ACC_ALLOC_AND_COPY_STRINGW(pwszProperty,
                                           pAccNode->pwszProperty,
                                           dwErr);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = List.Insert((PVOID)pAccNode);

                if(dwErr != ERROR_SUCCESS)
                {
                    AccFree(pAccNode->pwszProperty);
                    AccFree(pAccNode);
                }
            }
            else
            {
                AccFree(pAccNode);
                pAccNode = 0;
            }
        }
    }

    *ppNode = pAccNode;

    return(dwErr);
}



VOID
FreeAToAccessStruct(PVOID pv)
{
    ((PACCLIST_ATOACCESS)pv)->AceList.FreeList((FreeFunc)AccFree);
    AccFree(pv);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNodeForGuid
//
//  Synopsis:   Finds the node in the given list based upon the guid.  If the
//              node doesn't exist, it is inserted
//
//  Arguments:  [List]              --      List to examine
//              [pGuid]             --      The guid to look for
//              [ppNode]            --      Where the found or inserted node is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD GetNodeForGuid(CSList&             List,
                     GUID               *pGuid,
                     PACCLIST_ATOACCESS *ppNode)
{
    DWORD   dwErr = ERROR_SUCCESS;

    List.Init((FreeFunc)FreeAToAccessStruct);

    PACCLIST_ATOACCESS pNode = (PACCLIST_ATOACCESS)List.Find(pGuid,
                                                             CompGuids);
    if(pNode == NULL)
    {
        //
        // Doesn't exist.  We'll have to add it...
        //
        pNode = (PACCLIST_ATOACCESS)AccAlloc(sizeof(ACCLIST_ATOACCESS));
        if(pNode == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            pNode->AceList.Init((FreeFunc)AccFree);

            if(pGuid != NULL)
            {
                pNode->pGuid = (GUID *)AccAlloc(sizeof(GUID));
                if(pNode->pGuid == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    AccFree(pNode);
                    pNode = 0;
                }
                else
                {
                    memcpy(pNode->pGuid,
                           pGuid,
                           sizeof(GUID));
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = List.Insert((PVOID)pNode);

                if(dwErr != ERROR_SUCCESS)
                {
                    AccFree(pNode->pGuid);
                    AccFree(pNode);
                }
            }
        }
    }

    *ppNode = pNode;

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   InsertAtoANode
//
//  Synopsis:   Inserts an access to ace node into the list.
//
//  Arguments:  [List]              --      List to insert in
//              [pProperty]         --      Property to match
//              [pAce]              --      Ace to be inserted
//              [fInherit]          --      Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD InsertAtoANode(CSList&        List,
                     GUID          *pProperty,
                     PACE_HEADER    pAce,
                     ULONG          fInherit)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACCLIST_ATOANODE pAANode =
                        (PACCLIST_ATOANODE)AccAlloc(sizeof(ACCLIST_ATOANODE));
    if(pAANode == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pAANode->pAce = pAce;
        pAANode->fInherit = fInherit;

        PACCLIST_ATOACCESS pParent;

        dwErr = GetNodeForGuid(List,
                               pProperty,
                               &pParent);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = pParent->AceList.Insert((PVOID)pAANode);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            AccFree(pAANode);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AceToAccessEntry
//
//  Synopsis:   Converts an ACE into an access entry
//
//  Arguments:  [pAce]              --      Ace to convert
//              [fInheritLevel]     --      What inheritance level (effective,
//                                          parent inherit, etc) are we at
//              [ObjType]           --      Type of object we're dealing with
//              [pAE]               --      Already existing access entry to
//                                          initialize
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_INVALID_ACL   --      A bad ace type was encountered
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD   AceToAccessEntry(PACE_HEADER            pAce,
                         ULONG                  fInheritLevel,
                         SE_OBJECT_TYPE         ObjType,
                         IN MARTA_KERNEL_TYPE   KernelObjectType,
                         PACTRL_ACCESS_ENTRY    pAE)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Go ahead and initialize the node
    //
    BOOL    fIsImpersonate = FALSE;
    BOOL    fIsExtendedAce = FALSE;

    //
    // Ok, now lets try to figure out what type of ACE this is, so we can
    // do the neccessary mapping into the provider rights
    //
    switch(pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_ALLOWED;
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_ALLOWED;
        fIsExtendedAce = TRUE;
        break;

    //
    // Currently unsupported
    //
    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_ALLOWED;
        fIsImpersonate = TRUE;
        dwErr = ERROR_INVALID_ACL;
        break;

    case ACCESS_DENIED_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_DENIED;
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_DENIED;
        fIsExtendedAce = TRUE;
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

        pAE->fAccessFlags = 0;

        if(FLAG_ON(pAce->AceFlags,SUCCESSFUL_ACCESS_ACE_FLAG))
        {
            pAE->fAccessFlags |= ACTRL_AUDIT_SUCCESS;
        }

        if(FLAG_ON(pAce->AceFlags,FAILED_ACCESS_ACE_FLAG))
        {
            pAE->fAccessFlags |= ACTRL_AUDIT_FAILURE;
        }
        fIsExtendedAce = TRUE;
        break;

    case SYSTEM_AUDIT_ACE_TYPE:

        pAE->fAccessFlags = 0;

        if(FLAG_ON(pAce->AceFlags,SUCCESSFUL_ACCESS_ACE_FLAG))
        {
            pAE->fAccessFlags |= ACTRL_AUDIT_SUCCESS;
        }

        if(FLAG_ON(pAce->AceFlags,FAILED_ACCESS_ACE_FLAG))
        {
            pAE->fAccessFlags |= ACTRL_AUDIT_FAILURE;
        }
        break;

    default:
        dwErr = ERROR_INVALID_ACL;
        break;

    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Pull what we can from the ace header
        //
        pAE->Inheritance = (INHERIT_FLAGS)( pAce->AceFlags & VALID_INHERIT_FLAGS );
        pAE->Inheritance |= fInheritLevel;

        PSID pSid = NULL;
        ACCESS_MASK AccessMask = 0;
        if(fIsImpersonate == FALSE)
        {
            if(fIsExtendedAce == TRUE)
            {
                pSid = RtlObjectAceSid(pAce);
                AccessMask = ((PKNOWN_OBJECT_ACE)pAce)->Mask;
            }
            else
            {
                pSid = &((PKNOWN_ACE)pAce)->SidStart;
                AccessMask = ((PKNOWN_ACE)pAce)->Mask;
            }
        }
        else
        {
            if(fIsExtendedAce == TRUE)
            {
                dwErr = ERROR_INVALID_ACL;
            }
            else
            {
                pSid =
                 (PSID)Add2Ptr(&((PCOMPOUND_ACCESS_ALLOWED_ACE)pAce)->SidStart,
                 RtlLengthSid(&((PCOMPOUND_ACCESS_ALLOWED_ACE)pAce)->SidStart));
                AccessMask = ((PCOMPOUND_ACCESS_ALLOWED_ACE)pAce)->Mask;
            }
        }

        //
        // Build the trustee
        //
        pAE->Trustee.pMultipleTrustee = NULL;
        pAE->Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        pAE->Trustee.TrusteeForm = TRUSTEE_IS_SID;
        pAE->Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
        pAE->Trustee.ptstrName = (LPWSTR)pSid;


        //
        // Convert our access
        //
        AccConvertAccessMaskToActrlAccess(AccessMask,
                                          ObjType,
                                          KernelObjectType,
                                          pAE);

        //
        // Deal with the inheritance property...
        //
        if(fIsExtendedAce == TRUE)
        {
            PACCESS_ALLOWED_OBJECT_ACE pExAce =
                               (PACCESS_ALLOWED_OBJECT_ACE)pAce;

            if(FLAG_ON(pExAce->Flags,
                       ACE_INHERITED_OBJECT_TYPE_PRESENT))
            {
                PWSTR StrUuid;
                dwErr = UuidToString(RtlObjectAceInheritedObjectType(pAce),
                                     &StrUuid );

                //
                // The calling functions expect a buffer allocated with AccAlloc
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    ACC_ALLOC_AND_COPY_STRINGW(StrUuid, (PWSTR)pAE->lpInheritProperty, dwErr);
                    RpcStringFree(&StrUuid);
                }

            }
        }
        else
        {
            pAE->lpInheritProperty = NULL;
        }

    }


    if(dwErr != ERROR_SUCCESS)
    {
        if(pAE->lpInheritProperty != NULL)
        {
            AccFree((PWSTR)pAE->lpInheritProperty);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertToAutoInheritSD
//
//  Synopsis:   Determines the inheritance necessary for the current security
//              descriptor given the parent security descriptor
//
//  Arguments:  [IN  pCurrentSD]        --      The security descriptor to
//                                              update
//              [IN  pParentSD]         --      The parent security descriptor
//              [IN  fIsContainer]      --      Does the Sec. Desc. refer to
//                                              a container?
//              [IN  pGenericMapping]   --      Generic mapping to apply
//              [OUT ppNewSD]           --      Where the new SD is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//  Notes:      The returned security descriptor must be freed via a call to
//              DestroyPrivateObjectSecurity
//
//----------------------------------------------------------------------------
DWORD
ConvertToAutoInheritSD(IN  PSECURITY_DESCRIPTOR   pParentSD,
                       IN  PSECURITY_DESCRIPTOR   pCurrentSD,
                       IN  BOOL                   fIsContainer,
                       IN  PGENERIC_MAPPING       pGenericMapping,
                       OUT PSECURITY_DESCRIPTOR  *ppNewSD)
{
    DWORD                       dwErr = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR_CONTROL OldControl;

    //
    // Turn off the inherited bits, so we can always do the
    // necessary inheritance checks.  This is because we don't know if some
    // downlevel process came in and messed with one of our security
    // descriptors, and left is in a hosed state
    //
    OldControl = ((SECURITY_DESCRIPTOR *)pCurrentSD)->Control;

    ((SECURITY_DESCRIPTOR *)pCurrentSD)->Control &=
                       ~(SE_DACL_AUTO_INHERITED | SE_SACL_AUTO_INHERITED);

#ifdef DBG
    if(pParentSD != NULL)
    {
        ASSERT(IsValidSecurityDescriptor(pParentSD));
        DebugDumpSD("CTAIPOS ParentSD", pParentSD);
    }

    ASSERT(IsValidSecurityDescriptor(pCurrentSD));
    DebugDumpSD("CTAIPOS CurrentSD",  pCurrentSD);
#endif

    if(ConvertToAutoInheritPrivateObjectSecurity(pParentSD,
                                                 pCurrentSD,
                                                 ppNewSD,
                                                 NULL,
                                                 fIsContainer != 0,
                                                 pGenericMapping) == FALSE)
    {
        dwErr = GetLastError();
    }
#ifdef DBG
    else
    {
        ASSERT(IsValidSecurityDescriptor(*ppNewSD));
        DebugDumpSD("CTAIPOS NewSD", *ppNewSD);
    }
#endif

    ((SECURITY_DESCRIPTOR *)pCurrentSD)->Control = OldControl;

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   MakeSDAbsolute
//
//  Synopsis:   Allocates a new security descriptor and makes an absolute copy
//              of the supplied SD
//
//  Arguments:  [IN  pOriginalSD]       --      The security descriptor to
//                                              convert
//              [IN  SeInfo]            --      SD components to care about
//              [IN  *ppNewSD]          --      Where the new SD is returned
//              [IN  pOwnerToAdd]       --      OPTIONAL.  Owner SID to add to
//                                              absolute SD.
//              [IN  pGroupToAdd]       --      OPTIONAL.  Group SID to add to
//                                              absolute SD.
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation falied
//
//  Notes:      The returned security descriptor must be freed via a call to
//              AccFree
//
//----------------------------------------------------------------------------
DWORD
MakeSDAbsolute(IN  PSECURITY_DESCRIPTOR     pOriginalSD,
               IN  SECURITY_INFORMATION     SeInfo,
               OUT PSECURITY_DESCRIPTOR    *ppNewSD,
               IN  PSID                     pOwnerToAdd,
               IN  PSID                     pGroupToAdd)
{
    DWORD   dwErr = ERROR_SUCCESS;

    BOOL    fDAclPresent = FALSE;
    BOOL    fSAclPresent = FALSE;
    BOOL    fDAclDef = FALSE, fSAclDef = FALSE;
    BOOL    fOwnerDef = FALSE, fGroupDef = FALSE;
    PACL    pDAcl = NULL, pSAcl = NULL;
    PSID    pOwner = NULL, pGroup = NULL;
    ULONG   cSize = 0;

    //
    // First, get the info out of the current SD
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        if(GetSecurityDescriptorDacl(pOriginalSD, &fDAclPresent, &pDAcl, &fDAclDef) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pDAcl != NULL)
            {
                cSize += pDAcl->AclSize;
            }
        }
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
    {
        if(GetSecurityDescriptorSacl(pOriginalSD, &fSAclPresent, &pSAcl, &fSAclDef) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pSAcl != NULL)
            {
                cSize += pSAcl->AclSize;
            }
        }
    }

    if(pOwnerToAdd != NULL)
    {
        pOwner = pOwnerToAdd;
    }
    else
    {
        if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
        {
            if(GetSecurityDescriptorOwner(pOriginalSD, &pOwner, &fOwnerDef) == FALSE)
            {
                dwErr = GetLastError();
            }
        }
    }

    if(pGroupToAdd != NULL)
    {
        pGroup = pGroupToAdd;
    }
    else
    {
        if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
        {
            if(GetSecurityDescriptorGroup(pOriginalSD, &pGroup, &fGroupDef) == FALSE)
            {
                dwErr = GetLastError();
            }
        }
    }

    if(pOwner != NULL)
    {
        cSize += RtlLengthSid(pOwner);
    }

    if(pGroup != NULL)
    {
        cSize += RtlLengthSid(pGroup);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Allocate the buffer...
        //
        PBYTE   pBuff = (PBYTE)AccAlloc(cSize + sizeof(SECURITY_DESCRIPTOR));
        if(pBuff == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Start copying in the existing items...
            //
            DWORD   cLen;
            PBYTE   pbEndOBuf = pBuff + cSize + sizeof(SECURITY_DESCRIPTOR);

            if(pOwner != NULL)
            {
                cLen = RtlLengthSid(pOwner);
                pbEndOBuf -= cLen;
                RtlCopyMemory(pbEndOBuf, pOwner, cLen);
                pOwner = (PSID)pbEndOBuf;
            }

            if(pGroup != NULL)
            {
                cLen = RtlLengthSid(pGroup);
                pbEndOBuf -= cLen;
                RtlCopyMemory(pbEndOBuf, pGroup, cLen);
                pGroup = (PSID)pbEndOBuf;
            }

            if(pDAcl != NULL)
            {
                pbEndOBuf -= pDAcl->AclSize;
                RtlCopyMemory(pbEndOBuf, pDAcl, pDAcl->AclSize);
                pDAcl = (PACL)pbEndOBuf;
            }

            if(pSAcl != NULL)
            {
                pbEndOBuf -= pSAcl->AclSize;
                RtlCopyMemory(pbEndOBuf, pSAcl, pSAcl->AclSize);
                pSAcl = (PACL)pbEndOBuf;
            }

            //
            // Ok, now build it...
            //
            *ppNewSD = (PSECURITY_DESCRIPTOR)pBuff;
            if(InitializeSecurityDescriptor(*ppNewSD, SECURITY_DESCRIPTOR_REVISION) == FALSE)
            {
                dwErr = GetLastError();
            }

            if(dwErr == ERROR_SUCCESS && fDAclPresent == TRUE)
            {
                if(SetSecurityDescriptorDacl(*ppNewSD, TRUE, pDAcl, fDAclDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && fSAclPresent == TRUE)
            {
                if(SetSecurityDescriptorSacl(*ppNewSD, TRUE, pSAcl, fSAclDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && pOwner != NULL)

            {
                if(SetSecurityDescriptorOwner(*ppNewSD, pOwner, fOwnerDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && pGroup != NULL)

            {
                if(SetSecurityDescriptorGroup(*ppNewSD, pGroup, fGroupDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            //
            // Set the new control bits to look like the old ones (minus the selfrel flag, of
            // course...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                RtlpPropagateControlBits((PISECURITY_DESCRIPTOR)*ppNewSD,
                                         (PISECURITY_DESCRIPTOR)pOriginalSD,
                                         ~SE_SELF_RELATIVE );
            }

            if(dwErr != ERROR_SUCCESS)
            {
                AccFree(*ppNewSD);
                *ppNewSD = NULL;
            }

        }

    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   EqualSecurityDescriptors
//
//  Synopsis:   Determines if 2 security descriptors are identical.  It does
//              this by comparing control fields, owner/group, and sids.
//
//  Arguments:  [IN  pSD1]              --      1st SD to compare
//              [IN  pSD2]              --      2nd SD to compare
//
//  Returns:    TRUE                    --      They are identical
//              FALSE                   --      They are not identical
//
//
//----------------------------------------------------------------------------
BOOL
EqualSecurityDescriptors(IN  PSECURITY_DESCRIPTOR   pSD1,
                         IN  PSECURITY_DESCRIPTOR   pSD2)
{
    BOOL    fRet = TRUE;

    SECURITY_DESCRIPTOR *pS1 = (SECURITY_DESCRIPTOR *)pSD1;
    SECURITY_DESCRIPTOR *pS2 = (SECURITY_DESCRIPTOR *)pSD2;

    if(pS1->Control != pS2->Control)
    {
        return(FALSE);
    }

    PACL    pA1, pA2;

    //
    // Dacl
    //
    pA1 = RtlpDaclAddrSecurityDescriptor(pS1);
    pA2 = RtlpDaclAddrSecurityDescriptor(pS2);

    if((pA1 == NULL && pA2 != NULL) || (pA2 == NULL && pA1 != NULL))
    {
        return(FALSE);
    }

    if(pA1 != NULL)
    {
        if(!(pA1->AclSize == pA2->AclSize && memcmp(pA1, pA2, pA1->AclSize)))
        {
            return(FALSE);
        }
    }

    //
    // Sacl
    //
    pA1 = RtlpSaclAddrSecurityDescriptor(pS1);
    pA2 = RtlpSaclAddrSecurityDescriptor(pS2);

    if((pA1 == NULL && pA2 != NULL) || (pA2 == NULL && pA1 != NULL))
    {
        return(FALSE);
    }

    if(pA1 != NULL)
    {
        if(!(pA1->AclSize == pA2->AclSize && memcmp(pA1, pA2, pA1->AclSize)))
        {
            return(FALSE);
        }
    }

    //
    // Group
    //
    PSID    pSid1, pSid2;
    pSid1 = RtlpGroupAddrSecurityDescriptor(pS1);
    pSid2 = RtlpGroupAddrSecurityDescriptor(pS2);

    if((pSid1 == NULL && pSid2 != NULL) || (pSid2 == NULL && pSid1 != NULL))
    {
        return(FALSE);
    }

    if(pSid1 != NULL)
    {
        if(!RtlEqualSid(pSid1, pSid2))
        {
            return(FALSE);
        }
    }

    //
    // Owner
    //
    pSid1 = RtlpOwnerAddrSecurityDescriptor(pS1);
    pSid2 = RtlpOwnerAddrSecurityDescriptor(pS2);

    if((pSid1 == NULL && pSid2 != NULL) || (pSid2 == NULL && pSid1 != NULL))
    {
        return(FALSE);
    }

    if(pSid1 != NULL)
    {
        if(!RtlEqualSid(pSid1, pSid2))
        {
            return(FALSE);
        }
    }

    acDebugOut((DEB_TRACE, "Nodes 0x%lx and 0x%lx are equal!\n", pSD1, pSD2));
#ifdef DBG
    DebugDumpSD("SD1", pSD1);
    DebugDumpSD("SD2", pSD2);
#endif

    return(TRUE);
}



//+---------------------------------------------------------------------------
//
//  Function:   InsertPropagationFailureEntry
//
//  Synopsis:   Adds a propagation failure entry to the list of items
//              to be written to the event log
//
//  Arguments:  [IN  LogList]           --      Reference to the log list
//              [IN  ErrorCode]         --      Error of propagation
//              [IN  Protected]         --      Flags determining whether the dacl
//                                              or sacl was protected
//              [IN  pwszPath]          --      Path that expierneced the error
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//
//----------------------------------------------------------------------------
DWORD
InsertPropagationFailureEntry( IN  CSList&  LogList,
                               IN  ULONG    ErrorCode,
                               IN  ULONG    Protected,
                               IN  PWSTR    pwszPath)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PACCESS_PROP_LOG_ENTRY pEntry = NULL;

    pEntry = (PACCESS_PROP_LOG_ENTRY)AccAlloc(sizeof(ACCESS_PROP_LOG_ENTRY));
    if(pEntry == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        ACC_ALLOC_AND_COPY_STRINGW(pwszPath, pEntry->pwszPath, dwErr );

        if(pwszPath == NULL)
        {
            AccFree(pEntry);
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            pEntry->Protected = Protected;
            pEntry->Error = ErrorCode;
            dwErr = LogList.Insert(pEntry);

            if(dwErr != ERROR_SUCCESS)
            {
                FreePropagationFailureListEntry(pEntry);
            }
        }
    }
    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreePropagationFailureListEntry
//
//  Synopsis:   Frees the propagation failure list
//
//  Arguments:  [IN  LogList]           --      Reference to the log list
//
//  Returns:    VOID
//
//
//----------------------------------------------------------------------------
VOID
FreePropagationFailureListEntry(IN PVOID Entry)
{
    PACCESS_PROP_LOG_ENTRY pLogEntry = (PACCESS_PROP_LOG_ENTRY)Entry;

    AccFree(pLogEntry->pwszPath);
    AccFree(pLogEntry);
}



//+---------------------------------------------------------------------------
//
//  Function:   WritePropagationFailureList
//
//  Synopsis:   Logs the propagation failures to the event log
//
//  Arguments:  [IN  EventType]         --      Type of event to log:
//                                                  registry or filesystem
//              [IN  LogList]           --      Reference to the log list
//              [IN  hToken]            --      Current process/thread token
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WritePropagationFailureList(IN ULONG   EventType,
                            IN CSList& LogList,
                            IN HANDLE  hToken)
{
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hEventlog = NULL;
    TOKEN_USER *UserInfo;
    ULONG InfoSize, StrCount, i;
    PSID pSid = NULL;
    BYTE Buffer[ 7 * sizeof( ULONG ) + sizeof( TOKEN_USER ) ], *pBuff = NULL;
    WCHAR ErrorNumberBuffer[25];
    WCHAR wszErrorBuffer[ 256];
    PWSTR pwszStringBuffer = NULL, pwszCurrent;
    PACCESS_PROP_LOG_ENTRY pLogEntry;
    ULONG ProtectedValue;

    if(LogList.QueryCount() == 0)
    {
        return(dwErr);
    }

    //
    // Get the user sid
    //
    if(GetTokenInformation(hToken,
                           TokenUser,
                           (PVOID)&Buffer,
                           sizeof(Buffer),
                           &InfoSize ) == FALSE )
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            pBuff = (PBYTE)AccAlloc( InfoSize );

            if(pBuff == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {

                if(GetTokenInformation(hToken,
                                       TokenUser,
                                       (PVOID)pBuff,
                                       InfoSize,
                                       &InfoSize ) == FALSE )
                {
                    dwErr = GetLastError();
                }
                else
                {
                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }
    else
    {
        pBuff = Buffer;
    }


    if(dwErr == ERROR_SUCCESS)
    {
        UserInfo = ( PTOKEN_USER )pBuff;
        pSid = UserInfo->User.Sid;
    }

    //
    // Build the list of paths and associated error codes
    // The format of the buffer is [tab][path]   [error][cr/lf]
    //
    if(dwErr == ERROR_SUCCESS)
    {
        InfoSize = 1;

        LogList.Reset();
        pLogEntry = (PACCESS_PROP_LOG_ENTRY)LogList.NextData();
        for(; pLogEntry;)
        {
            InfoSize += 1 + wcslen( pLogEntry->pwszPath ) + 5;

            //
            // Determine the size of the buffer for the error message
            //
            if(pLogEntry->Protected)
            {
                switch(pLogEntry->Protected & (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
                {
                case SE_DACL_PROTECTED | SE_SACL_PROTECTED:
                    ProtectedValue = ACCPROV_MARTA_BOTH_PROTECTED;
                    break;

                case SE_DACL_PROTECTED:
                    ProtectedValue = ACCPROV_MARTA_DACL_PROTECTED;
                    break;

                case SE_SACL_PROTECTED:
                    ProtectedValue = ACCPROV_MARTA_SACL_PROTECTED;
                    break;

                default:
                    ProtectedValue = 0;
                    break;
                }

                if (LoadString(ghDll,
                               ProtectedValue,
                               wszErrorBuffer,
                               sizeof( wszErrorBuffer ) / sizeof( WCHAR )) == 0)
                {
                    dwErr = GetLastError();
                    break;

                }
            }
            else
            {
                if( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                                   NULL,
                                   pLogEntry->Error,
                                   MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                   wszErrorBuffer,
                                   256,
                                   NULL ) == 0 )
                {
                    dwErr = GetLastError();
                    break;
                }

            }

            InfoSize += wcslen( wszErrorBuffer );
            pLogEntry = (PACCESS_PROP_LOG_ENTRY)LogList.NextData();
        }

        //
        // Now, allocate the buffer
        //
        if(dwErr == ERROR_SUCCESS)
        {
            pwszStringBuffer = (PWSTR)AccAlloc(( InfoSize + 1 ) * sizeof( WCHAR ));
            if(pwszStringBuffer == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                LogList.Reset();
                pwszCurrent = pwszStringBuffer;
                pLogEntry = (PACCESS_PROP_LOG_ENTRY)LogList.NextData();
                for(; pLogEntry;)
                {
                    if(pLogEntry->Protected == 0 )
                    {
                        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                                       NULL,
                                       pLogEntry->Error,
                                       MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                       wszErrorBuffer,
                                       256,
                                       NULL );
                    }
                    else
                    {
                        switch( pLogEntry->Protected & (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
                        {
                        case SE_DACL_PROTECTED | SE_SACL_PROTECTED:
                            ProtectedValue = ACCPROV_MARTA_BOTH_PROTECTED;
                            break;

                        case SE_DACL_PROTECTED:
                            ProtectedValue = ACCPROV_MARTA_DACL_PROTECTED;
                            break;

                        case SE_SACL_PROTECTED:
                            ProtectedValue = ACCPROV_MARTA_SACL_PROTECTED;
                            break;

                        default:
                            ProtectedValue = 0;
                            break;
                        }

                        LoadString(ghDll,
                                   ProtectedValue,
                                   wszErrorBuffer,
                                   sizeof( wszErrorBuffer ) / sizeof( WCHAR ));
                    }
                    InfoSize = swprintf( pwszCurrent,
                                         L"\r\n\t%ws\t\t%ws",
                                         pLogEntry->pwszPath,
                                         wszErrorBuffer );

                    pwszCurrent += InfoSize;
                    pLogEntry = (PACCESS_PROP_LOG_ENTRY)LogList.NextData();

                }
            }
        }
    }


    //
    // Write to the event log
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = InitializeEvents();

        if(dwErr == ERROR_SUCCESS)
        {

            hEventlog = RegisterEventSource( NULL, L"AclPropagation" );

            if(hEventlog == NULL)
            {

                dwErr = GetLastError();
                if(dwErr == RPC_S_UNKNOWN_IF)
                {
                    acDebugOut(( DEB_ERROR, "Eventlog service not started!\n" ));
                    dwErr = ERROR_SUCCESS;

                }

            }
            else
            {
                if( ReportEvent(hEventlog,
                                EVENTLOG_INFORMATION_TYPE,
                                CATEGORY_NTMARTA,
                                EventType,
                                pSid,
                                1,
                                0,
                                (LPCTSTR *)&pwszStringBuffer,
                                NULL ) == FALSE )
                {
                    dwErr = GetLastError();

                }

                DeregisterEventSource(hEventlog);
            }
        }
    }

    if(pBuff != Buffer)
    {
        AccFree(pBuff);
    }

    if ((dwErr != ERROR_SUCCESS) && (pwszStringBuffer != NULL))
    {
        AccFree(pwszStringBuffer);
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   InitializeEvents
//
//  Synopsis:   Sets the registry values to enable NTMARTA to act as an event source
//
//  Arguments:  void
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
InitializeEvents(void)
{

    HKEY    hKey;
    DWORD   dwErr, disp;

    dwErr = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                              TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\AclPropagation"),
                              0,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &disp);
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }


    if (disp == REG_CREATED_NEW_KEY)
    {
        RegSetValueEx(  hKey,
                        TEXT("EventMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\ntmarta.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\ntmarta.dll")) );

        RegSetValueEx(  hKey,
                        TEXT("CategoryMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\ntmarta.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\ntmarta.dll")) );

        disp = EVENTLOG_ERROR_TYPE          |
                    EVENTLOG_WARNING_TYPE   |
                    EVENTLOG_INFORMATION_TYPE ;

        RegSetValueEx(  hKey,
                        TEXT("TypesSupported"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );

        disp = CATEGORY_MAX_CATEGORY - 1;
        RegSetValueEx(  hKey,
                        TEXT("CategoryCount"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );


    }

    RegCloseKey(hKey);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetAccessListLookupServer
//
//  Synopsis:   Sets the name of the server to lookup the names/sids on for
//              the given path
//
//  Arguments:  [IN pwszPath]       --  Path to get the server name for
//              [IN AccessList]     --  Reference to CAccessList class that
//                                      needs the server name
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD   SetAccessListLookupServer(IN  PWSTR         pwszPath,
                                  IN  CAccessList  &AccessList )
{
    DWORD dwErr = ERROR_SUCCESS;
    PWSTR pwszServer, pwszSep;

    if( pwszPath && IS_UNC_PATH( pwszPath, wcslen( pwszPath )  ) )
    {
        pwszServer = pwszPath + 2;
        pwszSep = wcschr(pwszServer, L'\\');
        if(pwszSep)
        {
            *pwszSep = UNICODE_NULL;
        }

        dwErr = AccessList.SetLookupServer(pwszServer);

        if(pwszSep)
        {
            *pwszSep = L'\\';
        }
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\dfsext.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dfsext.c
//
//  Contents:   Code to see if a path refers to a Dfs path.
//
//  Classes:    None
//
//  Functions:  IsThisADfsPath
//
//  History:    March 11, 1996  Milans created
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <windows.h>

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  ULONG OutputBufferLength);

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle);

//+----------------------------------------------------------------------------
//
//  Function:   IsThisADfsPath, public
//
//  Synopsis:   Given a fully qualified UNC or Drive based path, this routine
//              will identify if it is a Dfs path or not.
//
//  Arguments:  [pwszPath] -- The fully qualified path to test.
//
//              [cwPath] -- Length, in WCHARs, of pwszPath. If this is 0,
//                      this routine will compute the length. If it is
//                      non-zero, it will assume that the length of pwszPath
//                      is cwPath WCHARs.
//
//  Returns:    TRUE if pwszPath is a Dfs path, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOL
IsThisADfsPath(
    IN LPCWSTR pwszPath,
    IN DWORD cwPath OPTIONAL)
{
    NTSTATUS Status;
    HANDLE hDfs;
    BOOL fIsDfsPath = FALSE;
    PDFS_IS_VALID_PREFIX_ARG pPrefixArg;
    ULONG Size;

    //
    // We only accept UNC or drive letter paths
    //

    if (pwszPath == NULL)
        return( FALSE );

    if (cwPath == 0)
        cwPath = wcslen( pwszPath );

    if (cwPath < 2)
        return( FALSE );

    Status = DfsOpen( &hDfs );

    if (!NT_SUCCESS(Status))
        return( FALSE );

    //
    // From this point on, we must remember to close hDfs before returning.
    //

    if (pwszPath[0] == L'\\' && pwszPath[1] == L'\\') {

        Size = sizeof(DFS_IS_VALID_PREFIX_ARG) +
                    cwPath * sizeof(WCHAR);

        pPrefixArg = (PDFS_IS_VALID_PREFIX_ARG) LocalAlloc(0, Size);

        if ( pPrefixArg ) {

            //
            // the InputBuffer must be in the structure of DFS_IS_VALID_PREFIX_ARG
            //

            pPrefixArg->CSCAgentCreate = FALSE;
            pPrefixArg->RemoteNameLen = (SHORT)( (cwPath-1) * sizeof(WCHAR));
            wcscpy(&pPrefixArg->RemoteName[0], pwszPath+1);

            Status = DfsFsctl(
                        hDfs,
                        FSCTL_DFS_IS_VALID_PREFIX,
                        (PVOID) pPrefixArg, // &pwszPath[1],
                        Size, // (cwPath - 1) * sizeof(WCHAR),
                        NULL,
                        0);

            LocalFree(pPrefixArg);

        } else {
            Status = STATUS_NO_MEMORY;
        }

        if (NT_SUCCESS(Status))
            fIsDfsPath = TRUE;

    } else if (pwszPath[1] == L':') {

        //
        // This is a drive based name. We'll fsctl to the driver to return
        // the prefix for this drive, if it is indeed a Dfs drive.
        //

        Status = DfsFsctl(
                    hDfs,
                    FSCTL_DFS_IS_VALID_LOGICAL_ROOT,
                    (PVOID) &pwszPath[0],
                    sizeof(WCHAR),
                    NULL,
                    0);

        if (NT_SUCCESS(Status))
            fIsDfsPath = TRUE;

    }

    NtClose( hDfs );

    return( fIsDfsPath );

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsOpen, private
//
//  Synopsis:   Opens a handle to the Dfs driver for fsctl purposes.
//
//  Arguments:  [DfsHandle] -- On successful return, contains handle to the
//                      driver.
//
//  Returns:    NTSTATUS of attempt to open the Dfs driver.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING name = {
        sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
        sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
        DFS_DRIVER_NAME};

    InitializeObjectAttributes(
        &objectAttributes,
        &name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctl, public
//
//  Synopsis:   Fsctl's to the Dfs driver.
//
//  Arguments:  [DfsHandle] -- Handle to the Dfs driver, usually obtained by
//                      calling DfsOpen.
//              [FsControlCode] -- The FSCTL code (see private\inc\dfsfsctl.h)
//              [InputBuffer] -- InputBuffer to the fsctl.
//              [InputBufferLength] -- Length, in BYTES, of InputBuffer
//              [OutputBuffer] -- OutputBuffer to the fsctl.
//              [OutputBufferLength] -- Length, in BYTES, of OutputBuffer
//
//  Returns:    NTSTATUS of Fsctl attempt.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  ULONG OutputBufferLength
)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    status = NtFsControlFile(
        DfsHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength
    );

    if(NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\dsctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dsctx.h
//
//  Contents:   NT Marta DS object context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__DSCTX_H__)
#define __DSCTX_H__

#include <windows.h>
#include <ds.h>
#include <ldapsp.h>
#include <assert.h>
#include <ntldap.h>
#include <rpc.h>
#include <rpcndr.h>
#include <ntdsapi.h>
#include <ole2.h>

//
// CDsObjectContext.  This represents a DS object to the NT Marta
// infrastructure
//

class CDsObjectContext
{
public:

    //
    // Construction
    //

    CDsObjectContext ();

    ~CDsObjectContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetDsObjectProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetDsObjectRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetDsObjectRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

    DWORD GetDsObjectGuid (
             GUID* pGuid
             );

private:

    //
    // Reference count
    //

    DWORD               m_cRefs;

    //
    // LDAP URL components
    //

    LDAP_URL_COMPONENTS m_LdapUrlComponents;

    //
    // LDAP binding handle
    //

    LDAP*               m_pBinding;
};

DWORD
MartaReadDSObjSecDesc(IN  PLDAP                  pLDAP,
                      IN  LPWSTR                 pszObject,
                      IN  SECURITY_INFORMATION   SeInfo,
                      OUT PSECURITY_DESCRIPTOR  *ppSD);

DWORD
MartaStampSD(IN  LPWSTR               pszObject,
             IN  ULONG                cSDSize,
             IN  SECURITY_INFORMATION SeInfo,
             IN  PSECURITY_DESCRIPTOR pSD,
             IN  PLDAP                pLDAP);

#define SD_PROP_NAME L"nTSecurityDescriptor"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\dsctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dsctx.cpp
//
//  Contents:   Implementation of CDsObjectContext and NT Marta DS object
//              Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <windows.h>
#include <dsctx.h>
//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::CDsObjectContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CDsObjectContext::CDsObjectContext ()
{
    m_cRefs = 1;
    memset( &m_LdapUrlComponents, 0, sizeof( m_LdapUrlComponents ) );
    m_pBinding = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::~CDsObjectContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CDsObjectContext::~CDsObjectContext ()
{
    LdapFreeBindings( m_pBinding );
    LdapFreeUrlComponents( &m_LdapUrlComponents );

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the lanman share
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    DWORD  Result = ERROR_SUCCESS;
    LPWSTR pwszName = NULL;
    ULONG  len = wcslen( pObjectName );
    ULONG  i, j;

    if ( _wcsnicmp( pObjectName, LDAP_SCHEME_U, wcslen( LDAP_SCHEME_U ) ) != 0 )
    {
        pwszName = new WCHAR [ len + wcslen( LDAP_SCHEME_UC ) + 2 ];

        if ( pwszName != NULL )
        {
            wcscpy( pwszName, LDAP_SCHEME_UC );
            wcscat( pwszName, L"/" );
            wcscat( pwszName, pObjectName );
        }
        else
        {
            Result = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        pwszName = new WCHAR [ len + 1 ];

        if ( pwszName != NULL )
        {
            wcscpy( pwszName, pObjectName );
        }
        else
        {
            Result = ERROR_OUTOFMEMORY;
        }
    }

    if ( Result == ERROR_SUCCESS )
    {
        for (i = j = 0; i <= len; i++, j++)
        {
            if (L'\\' == pwszName[i])
            {
                if (L'/' != pwszName[i+1])
                {
                    pwszName[j++] = pwszName[i++];
                }
                else
                {
                    i++;
                }
            }
            pwszName[j] = pwszName[i];
        }
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( LdapCrackUrl( pwszName, &m_LdapUrlComponents ) == FALSE )
        {
            Result = GetLastError();
        }
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( LdapGetBindings(
                 m_LdapUrlComponents.pwszHost,
                 m_LdapUrlComponents.Port,
                 0,
                 0,
                 &m_pBinding
                 ) == FALSE )
        {
            Result = GetLastError();
        }
    }

    if ( pwszName != pObjectName )
    {
        delete pwszName;
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::GetDsObjectProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::GetDsObjectProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::GetDsObjectRights, public
//
//  Synopsis:   get the DsObject security descriptor
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::GetDsObjectRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    DWORD Result;

    Result = MartaReadDSObjSecDesc(
                 m_pBinding,
                 m_LdapUrlComponents.pwszDN,
                 SecurityInfo,
                 ppSecurityDescriptor
                 );

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::SetDsObjectRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::SetDsObjectRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    DWORD                 Result;
    PISECURITY_DESCRIPTOR pisd = NULL;
    DWORD                 cb = 0;
    PSECURITY_DESCRIPTOR  psd = NULL;

    pisd = (PISECURITY_DESCRIPTOR)pSecurityDescriptor;

    if ( pisd->Control & SE_SELF_RELATIVE )
    {
        cb = GetSecurityDescriptorLength( pSecurityDescriptor );
        psd = pSecurityDescriptor;
    }
    else
    {
        if ( MakeSelfRelativeSD(
                 pSecurityDescriptor,
                 NULL,
                 &cb
                 ) == FALSE )
        {
            if ( cb > 0 )
            {
                psd = new BYTE [ cb ];
                if ( psd != NULL )
                {
                    if ( MakeSelfRelativeSD(
                             pSecurityDescriptor,
                             psd,
                             &cb
                             ) == FALSE )
                    {
                        delete psd;
                        return( GetLastError() );
                    }
                }
                else
                {
                    return( ERROR_OUTOFMEMORY );
                }
            }
            else
            {
                return( GetLastError() );
            }
        }
        else
        {
            assert( FALSE && "Should not get here!" );
            return( ERROR_INVALID_PARAMETER );
        }
    }

    assert( psd != NULL );

    Result = MartaStampSD(
                  m_LdapUrlComponents.pwszDN,
                  cb,
                  SecurityInfo,
                  psd,
                  m_pBinding
                  );

    if ( psd != pSecurityDescriptor )
    {
        delete psd;
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::GetDsObjectGuid, public
//
//  Synopsis:   get the object GUID
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::GetDsObjectGuid (GUID* pGuid)
{
    return( ERROR_INVALID_PARAMETER );
}

//
// Functions from Ds.h which dispatch unto the CDsObjectContext class
//

DWORD
MartaAddRefDsObjectContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CDsObjectContext *)Context )->AddRef() );
}

DWORD
MartaCloseDsObjectContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CDsObjectContext *)Context )->Release() );
}

DWORD
MartaGetDsObjectProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CDsObjectContext *)Context )->GetDsObjectProperties( pProperties ) );
}

DWORD
MartaGetDsObjectTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    pProperties->dwFlags = MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG;

    return( ERROR_SUCCESS );
}

DWORD
MartaGetDsObjectRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CDsObjectContext *)Context )->GetDsObjectRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenDsObjectNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CDsObjectContext* pDsObjectContext;

    pDsObjectContext = new CDsObjectContext;
    if ( pDsObjectContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pDsObjectContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pDsObjectContext->Release();
        return( Result );
    }

    *pContext = pDsObjectContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetDsObjectRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CDsObjectContext *)Context )->SetDsObjectRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}

DWORD
MartaConvertDsObjectNameToGuid(
    IN LPCWSTR pObjectName,
    OUT GUID* pGuid
    )
{
    DWORD               Result = ERROR_SUCCESS;
    LPWSTR              pwszName = NULL;
    LDAP_URL_COMPONENTS LdapUrlComponents;
    DS_NAME_RESULTW*    pnameresult;
    HANDLE              hDs = NULL;
    WCHAR               GuidString[ MAX_PATH ];

    memset( &LdapUrlComponents, 0, sizeof( LdapUrlComponents ) );

    if ( _wcsnicmp( pObjectName, LDAP_SCHEME_U, wcslen( LDAP_SCHEME_U ) ) != 0 )
    {
        pwszName = new WCHAR [ wcslen( pObjectName ) +
                               wcslen( LDAP_SCHEME_U ) + 2 ];

        if ( pwszName != NULL )
        {
            wcscpy( pwszName, LDAP_SCHEME_U );
            wcscat( pwszName, L"/" );
            wcscat( pwszName, pObjectName );
        }
        else
        {
            Result = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        pwszName = (LPWSTR)pObjectName;
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( LdapCrackUrl( pwszName, &LdapUrlComponents ) == FALSE )
        {
            Result = GetLastError();
        }
    }

    if ( Result == ERROR_SUCCESS )
    {
        Result = DsBindW( LdapUrlComponents.pwszHost, NULL, &hDs );
    }

    if ( Result == ERROR_SUCCESS )
    {
        Result = DsCrackNamesW(
                   hDs,
                   DS_NAME_NO_FLAGS,
                   DS_FQDN_1779_NAME,
                   DS_UNIQUE_ID_NAME,
                   1,
                   &LdapUrlComponents.pwszDN,
                   &pnameresult
                   );
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( ( pnameresult->cItems > 0 ) &&
             ( pnameresult->rItems[0].status == ERROR_SUCCESS ) )
        {
            Result = IIDFromString( pnameresult->rItems[0].pName, pGuid );
        }
        else
        {
            Result = ERROR_INVALID_PARAMETER;
        }

        DsFreeNameResultW( pnameresult );
    }

    if ( hDs != NULL )
    {
        DsUnBindW( &hDs );
    }

    LdapFreeUrlComponents( &LdapUrlComponents );

    if ( pwszName != pObjectName )
    {
        delete pwszName;
    }

    return( Result );
}

DWORD
MartaConvertGuidToDsName(
    IN  GUID     Guid,
    OUT LPWSTR * ppObjectName
    )
{
    DWORD            Result;
    HANDLE           hDs = NULL;
    WCHAR            GuidString[ MAX_PATH ];
    DS_NAME_RESULTW* pnameresult = NULL;
    LPWSTR           pObjectName = NULL;

    if ( StringFromGUID2( Guid, GuidString, MAX_PATH ) == 0 )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    Result = DsBindW( NULL, NULL, &hDs );

    if ( Result == ERROR_SUCCESS )
    {
        Result = DsCrackNamesW(
                   hDs,
                   DS_NAME_NO_FLAGS,
                   DS_UNIQUE_ID_NAME,
                   DS_FQDN_1779_NAME,
                   1,
                   (LPCWSTR *)&GuidString,
                   &pnameresult
                   );
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( ( pnameresult->cItems > 0 ) &&
             ( pnameresult->rItems[0].status == ERROR_SUCCESS ) )
        {
            pObjectName = (LPWSTR)LocalAlloc(
                                       LPTR,
                                       ( wcslen( pnameresult->rItems[0].pName )
                                         + 1 ) * sizeof( WCHAR )
                                       );

            if ( pObjectName != NULL )
            {
                wcscpy( pObjectName, pnameresult->rItems[0].pName );
                *ppObjectName = pObjectName;
            }
            else
            {
                Result = ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            Result = ERROR_INVALID_PARAMETER;
        }

        DsFreeNameResultW( pnameresult );
    }

    if ( hDs != NULL )
    {
        DsUnBindW( &hDs );
    }

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Function:   MartaReadDSObjSecDesc
//
//  Synopsis:   Reads the security descriptor from the specied object via
//              the open ldap connection
//
//  Arguments:  [IN  pLDAP]         --  The open LDAP connection
//              [IN  SeInfo]        --  Parts of the security descriptor to
//                                      read.
//              [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [OUT ppSD]          --  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
DWORD
MartaReadDSObjSecDesc(IN  PLDAP                  pLDAP,
                      IN  LPWSTR                 pwszObject,
                      IN  SECURITY_INFORMATION   SeInfo,
                      OUT PSECURITY_DESCRIPTOR  *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PLDAPMessage    pMessage = NULL;
    LPWSTR           rgAttribs[2];
    BYTE            berValue[8];

    //
    // JohnsonA The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControlW     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControlW    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    rgAttribs[0] = SD_PROP_NAME;
    rgAttribs[1] = NULL;



    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ldap_search_ext_sW(pLDAP,
                                   pwszObject,
                                   LDAP_SCOPE_BASE,
                                   L"(objectClass=*)",
                                   rgAttribs,
                                   0,
                                   (PLDAPControlW *)&ServerControls,
                                   NULL,
                                   NULL,
                                   10000,
                                   &pMessage);

        dwErr = LdapMapErrorToWin32( dwErr );
    }

    if(dwErr == ERROR_SUCCESS)
    {
        LDAPMessage *pEntry = NULL;

        pEntry = ldap_first_entry(pLDAP,pMessage);

        if(pEntry == NULL)
        {
            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            if (ERROR_SUCCESS == dwErr)
                dwErr = ERROR_ACCESS_DENIED;
        }
        else
        {
            PLDAP_BERVAL *pSize = ldap_get_values_lenW(pLDAP,
                                                       pMessage,
                                                       rgAttribs[0]);
            if(pSize == NULL)
            {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
            else
            {
                //
                // Allocate the security descriptor to return
                //
                *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, (*pSize)->bv_len);
                if(*ppSD == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    memcpy(*ppSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);
                }
                ldap_value_free_len(pSize);
            }
        }
    }

    if ( pMessage != NULL )
    {
        ldap_msgfree(pMessage);
    }

    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   MartaStampSD
//
//  Synopsis:   Actually stamps the security descriptor on the object.
//
//  Arguments:  [IN  pwszObject]        --      The object to stamp the SD on
//              [IN  cSDSize]           --      The size of the security descriptor
//              [IN  SeInfo]            --      SecurityInformation about the security
//                                              descriptor
//              [IN  pSD]               --      The SD to stamp
//              [IN  pLDAP]             --      The LDAP connection to use
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
MartaStampSD(IN  LPWSTR               pwszObject,
             IN  ULONG                cSDSize,
             IN  SECURITY_INFORMATION SeInfo,
             IN  PSECURITY_DESCRIPTOR pSD,
             IN  PLDAP                pLDAP)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Now, we'll do the write.  The security descriptor
    // we got passed in better not be in the old Ds  format,
    // where the leading 4 bytes are the SECURITY_INFORMATION, which we'll skip
    // and replace with control information
    //

    assert(*(PULONG)pSD > 0xF );

    PLDAPModW       rgMods[2];
    PLDAP_BERVAL    pBVals[2];
    LDAPModW        Mod;
    LDAP_BERVAL     BVal;
    BYTE            ControlBuffer[ 5 ];

    LDAPControlW     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) &ControlBuffer
                        },
                        TRUE
                    };

    //
    // !!! Hardcoded for now.  Use Andyhe's BER_printf once it's done.
    //

    ControlBuffer[0] = 0x30;
    ControlBuffer[1] = 0x3;
    ControlBuffer[2] = 0x02;    // Denotes an integer;
    ControlBuffer[3] = 0x01;    // Size
    ControlBuffer[4] = (BYTE)((ULONG)SeInfo & 0xF);

    PLDAPControlW    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    assert(IsValidSecurityDescriptor( pSD ) );

    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    BVal.bv_len = cSDSize;
    BVal.bv_val = (PCHAR)pSD;

    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = SD_PROP_NAME;
    Mod.mod_values  = (LPWSTR *)pBVals;

    //
    // Now, we'll do the write...
    //

    dwErr = ldap_modify_ext_sW(pLDAP,
                               pwszObject,
                               rgMods,
                               (PLDAPControlW *)&ServerControls,
                               NULL);

    dwErr = LdapMapErrorToWin32(dwErr);

    return(dwErr);
}

DWORD
MartaGetDsParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    )

/*++

Routine Description:

    Given the name of a DS object return the name of its parent. The routine
    allocates memory required to hold the parent name.

Arguments:

    ObjectName - Name of the DS object.

    pParentName - To return the pointer to the allocated parent name.
        In case of the root of the tree, we return NULL parent with ERROR_SUCCESS.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    LPCWSTR pKey  = NULL;
    LPCWSTR pVal  = NULL;
    DWORD  ccKey = 0;
    DWORD  ccDN  = 0;
    DWORD  ccVal = 0;
    DWORD  Size  = 0;
    DWORD  dwErr = ERROR_SUCCESS;
    LPCWSTR pDN   = (LPWSTR) ObjectName;

    ccDN = wcslen(pDN);
    *pParentName = NULL;

    //
    // The input is empty. There is no parent. Just return.
    //

    if (0 == ccDN)
    {
        return ERROR_SUCCESS;
    }

    //
    // Do the first pass to get to the next level. At the end of this call,
    // pDN will point to the next ','. One more call to DsGetRdnW will
    // return the right result in pKey.
    // Input:
    //   pDN = "CN=Kedar, DC=NTDEV, DC=Microsoft, DC=com"
    // Output:
    //   pDN = ", DC=NTDEV, DC=Microsoft, DC=com"
    //

    dwErr = DsGetRdnW(
                &pDN,
                &ccDN,
                &pKey,
                &ccKey,
                &pVal,
                &ccVal
                );

     if (ERROR_SUCCESS != dwErr)
     {
         return dwErr;
     }

     //
     // This is TRUE when the Object does not have any parent.
     //

     if (0 == ccDN)
     {
         return ERROR_SUCCESS;
     }

     //
     // Input:
     //   pDN = ", DC=NTDEV, DC=Microsoft, DC=com"
     // Output:
     //   pKey = "DC=NTDEV, DC=Microsoft, DC=com"
     //

     dwErr = DsGetRdnW(
                 &pDN,
                 &ccDN,
                 &pKey,
                 &ccKey,
                 &pVal,
                 &ccVal
                 );

     if (ERROR_SUCCESS != dwErr)
     {
         return dwErr;
     }

     //
     // We have to distinguish between LDAP://ServerName/ObjectName and
     // ObjectName.
     //

     if (!_wcsnicmp(ObjectName, LDAP_SCHEME_U, wcslen(LDAP_SCHEME_U)) != 0 )
     {
         ULONG HostSize;

         //
         // Compute the size of string required to hold "LDAP//ServerName/" in
         // HostSize.
         //

         pDN = ObjectName + sizeof("ldap://");
         pDN = wcschr(pDN, L'/');

         if (NULL == pDN) 
         {
             return ERROR_INVALID_PARAMETER;
         }

         HostSize = (ULONG) (pDN - ObjectName + 1);

         Size = (1 + wcslen(pKey) + HostSize) * sizeof(WCHAR);

         *pParentName = (LPWSTR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Size);

         if (NULL == *pParentName)
         {
             return ERROR_NOT_ENOUGH_MEMORY;
         }

         //
         // Copy the name of the parent into allocated memeory.
         //

         wcsncpy(*pParentName, ObjectName, HostSize);
         wcscpy((*pParentName) + HostSize, pKey);
     }
     else
     {
         Size = (1 + wcslen(pKey)) * sizeof(WCHAR);

         *pParentName = (LPWSTR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Size);

         if (NULL == *pParentName)
         {
             return ERROR_NOT_ENOUGH_MEMORY;
         }

         //
         // Copy the name of the parent into allocated memeory.
         //

         wcscpy(*pParentName, pKey);
     }


     return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\event.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       EVENT.C
//
//  Contents:   Routines used by the event viewer to map GUIDs to names
//
//  History:    25-Oct-97       CliffV        Created
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <lucache.h>



DWORD
EventGuidToName(
    IN LPCWSTR Source,
    IN LPCWSTR GuidString,
    OUT LPWSTR *NameString
    )
/*++

Routine Description:

    General purpose routine used by the event viewer to translate from a GUID
    in an event log message to a name of the GUID.

    This instance of the routine translates the following GUID types:
        Object Class Guids (e.g., user)
        Property set Guids (e.g., ATT_USER_PRINCIPLE_NAME)
        Property Guids (e.g., adminDisplayName)
        Object Guids (e.g., <DnsDomainName>/Users/<UserName>)

Arguments:

    Source - Specifies the source of the GUID.  The routine will use this field
        to differentiate between multiple sources potentially implemented by
        the routine.

        This instance of the routine requires the Source to be
        ACCESS_DS_SOURCE_W.

    GuidString - A string-ized version of the GUID to translate.  The GUID should
        be in the form 33ff431c-4d78-11d1-b61a-00c04fd8ebaa.

    NameString - Returns the name that corresponds to the GUID.  If the name cannot
        be found, a stringized version of the GUID is returned.
        The name should be freed by calling EventNameFree.

Return Value:

    NO_ERROR - The Name was successfully translated.

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the operation.

    ERROR_INVALID_PARAMETER - Source is not supported.

    RPC_S_INVALID_STRING_UUID - Syntax of GuidString is invalid

--*/

{
    DWORD dwErr;
    GUID Guid;

    //
    // Ensure the source is one we recognize.
    //

    if ( _wcsicmp( Source, ACCESS_DS_SOURCE_W) != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the specified GUID to binary.
    //

    dwErr = UuidFromString((LPWSTR)GuidString, &Guid);

    if ( dwErr != NO_ERROR ) {
        return dwErr;
    }


    //
    // Convert the GUID to a name.
    //

    dwErr = AccctrlLookupIdName(
                    NULL,   // No existing LDAP handle
                    L"",    // Only the root path
                    &Guid,
                    TRUE,   // Allocate the return buffer
                    TRUE,   // Handle individual object GUIDs
                    NameString );

    return dwErr;

}





VOID
EventNameFree(
    IN LPCWSTR NameString
    )
/*++

Routine Description:

    Routine to free strings returned by EventNameFree.

Arguments:

    NameString - Returns the name that corresponds to the GUID.

Return Value:

    None.

--*/

{
    LocalFree((PVOID)NameString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\geefa.cxx ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Microsoft Windows                                                         //
//  Copyright (C) Microsoft Corporation, 1999.                                //
//                                                                            //
//  File:    geefa.cxx                                                        //
//                                                                            //
//  Contents:    New marta rewrite functions for GetExplicitEntriesFromAcl    //
//                                                                            //
//  History:    4/99    KedarD     Created                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <stdio.h>
    #include <permit.h>
    #include <dsgetdc.h>
    #include <lmapibuf.h>
    #include <wmistr.h>
    #include <ntprov.hxx>
    #include <strings.h>
    #include <seopaque.h>
    #include <sertlp.h>
    #include <accctrl.h>
    #include <aclapi.h>
    #include <global.h>
}

#define MARTA_ALIGNED_SID_LENGTH(p) ((PtrAlignSize(RtlLengthSid((p)))))

DWORD
MartaGetAceToEntrySize(
    IN  PACE_HEADER pAce,
    OUT PULONG      pLen,
    OUT PULONG      pCount
    );

DWORD
MartaFillExplicitEntries(
    IN PACL   pacl,
    IN PUCHAR Buffer,
    IN ULONG  AccessCnt
    );

DWORD
AccRewriteGetExplicitEntriesFromAcl(
    IN  PACL                 pacl,
    OUT PULONG               pcCountOfExplicitEntries,
    OUT PEXPLICIT_ACCESS_W * pListOfExplicitEntries
    );

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteGetExplicitEntriesFromAcl                              //
//                                                                            //
// Description: Extract the explicit entries from an acl.                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pacl]                        Acl to be converted                   //
//     [OUT pcCountOfExplicitEntries]  To return the number of entries found  //
//     [OUT pListOfExplicitEntries]    To return the list of entries found    //
//                                                                            //
// Returns: ERROR_SUCCESS if the Acl could be converted to expcilt entries    //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteGetExplicitEntriesFromAcl(
    IN  PACL                 pacl,
    OUT PULONG               pcCountOfExplicitEntries,
    OUT PEXPLICIT_ACCESS_W * pListOfExplicitEntries)
{
    DWORD       dwErr     = ERROR_SUCCESS;
    ULONG       AccessCnt = 0;
    ULONG       Size      = 0;
    USHORT      AceCnt    = 0;
    ULONG       Count     = 0;
    ULONG       j         = 0;
    ULONG       Len       = 0;
    PUCHAR      Buffer    = NULL;
    PACE_HEADER pAce      = NULL;

    if ((NULL == pcCountOfExplicitEntries) || (NULL == pListOfExplicitEntries))
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pcCountOfExplicitEntries = 0;
    *pListOfExplicitEntries   = NULL;

    if ((NULL == pacl) || (0 == pacl->AceCount))
    {
        return ERROR_SUCCESS;
    }

    if (!RtlValidAcl(pacl))
    {
        return ERROR_INVALID_PARAMETER;
    }

    AceCnt = pacl->AceCount;

    pAce = (PACE_HEADER) FirstAce(pacl);

    for (j = 0; j < AceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            continue;
        }

        dwErr = MartaGetAceToEntrySize(pAce, &Len, &Count);

        CONDITIONAL_EXIT(dwErr, End);

        AccessCnt += Count;
        Size += Count * (Len + sizeof(EXPLICIT_ACCESS_W));
    }

    if (0 == Size)
    {
        goto End;
    }

    Buffer = (PUCHAR) AccAlloc(Size);

    if (NULL == Buffer)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    dwErr = MartaFillExplicitEntries(pacl, Buffer, AccessCnt);

    if (ERROR_SUCCESS != dwErr)
    {
        goto End;
    }

    *pcCountOfExplicitEntries = AccessCnt;
    *pListOfExplicitEntries   = (PEXPLICIT_ACCESS_W) Buffer;

End:
    if (ERROR_SUCCESS != dwErr)
    {
        if (NULL != Buffer)
        {
            AccFree(Buffer);
        }
    }
    return dwErr;

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetAceToEntrySize                                           //
//                                                                            //
// Description: Compute:                                                      //
//                Size needed to convert a given ace into explicit entry      //
//                Number of explicit entries for this ace                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pAce]       Ace to be converted to an explicit entry               //
//     [OUT pLen]      To return the length of the entry                      //
//     [OUT pCount]    To return the number of explict entries for this ace   //
//                                                                            //
// Returns: ERROR_SUCCESS if the ace could be converted to an expcilt entry   //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetAceToEntrySize(
    IN  PACE_HEADER pAce,
    OUT PULONG      pLen,
    OUT PULONG      pCount
    )
{
    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        *pLen = MARTA_ALIGNED_SID_LENGTH((PSID) &((PKNOWN_ACE) pAce)->SidStart);
        break;
    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        *pLen = MARTA_ALIGNED_SID_LENGTH(RtlCompoundAceServerSid(pAce));
        *pLen += sizeof(TRUSTEE_W) + MARTA_ALIGNED_SID_LENGTH(RtlCompoundAceClientSid(pAce)); 
        break;
    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        *pLen = MARTA_ALIGNED_SID_LENGTH(RtlObjectAceSid(pAce)) + sizeof(OBJECTS_AND_SID);
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    switch (pAce->AceType)
    {
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        *pCount = 0;
        if (FLAG_ON(pAce->AceFlags, SUCCESSFUL_ACCESS_ACE_FLAG))
        {
            *pCount += 1;
        }
        if (FLAG_ON(pAce->AceFlags, FAILED_ACCESS_ACE_FLAG))
        {
            *pCount += 1;
        }

        if (0 == *pCount)
        {
            return ERROR_INVALID_PARAMETER;
        }
        break;
    default:
        *pCount = 1;
        break;
    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaFillExplicitEntries                                         //
//                                                                            //
// Description: Convert an ace into explicit entry stucture(s)                //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pacl]        Acl to be converted                                   //
//     [IN Buffer]      Buffer to be filled with explicit entries             //
//     [IN AccessCnt]   Number of explicitentries created                     //
//                                                                            //
// Returns: ERROR_SUCCESS if the acl could be converted to expcilt entries    //
//          Appropriate failure otherwise                                     //
//                                                                            //
// Note: Since Audit aces might be converted into one/two entries we need a   //
//       flag to maintain whethe the given ace was already seen in the last   //
//       pass.                                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaFillExplicitEntries(
    IN PACL   pacl,
    IN PUCHAR Buffer,
    IN ULONG  AccessCnt
    )
{
    DWORD            dwErr         = ERROR_SUCCESS;
    ULONG            AceCnt        = pacl->AceCount;
    PUCHAR           CurrentBuffer = Buffer + sizeof(EXPLICIT_ACCESS_W) * AccessCnt;
    ACCESS_MASK      Mask          = 0;
    ULONG            j             = 0;
    ULONG            i             = 0;
    ULONG            Length        = 0;
    PACE_HEADER      pAce          = NULL;
    PSID             pSid          = NULL;
    POBJECTS_AND_SID pObjSid       = NULL;
    BOOL             bFlag         = FALSE;

    PEXPLICIT_ACCESS_W pExplicit = (PEXPLICIT_ACCESS_W) Buffer;

    pAce = (PACE_HEADER) FirstAce(pacl);

    for (i = j = 0; i < AceCnt; )
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            i++;
            pAce = (PACE_HEADER) NextAce(pAce);

            continue;
        }

        switch (pAce->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:

            Mask   = ((PKNOWN_ACE) pAce)->Mask;
            pSid   = (PSID) &((PKNOWN_ACE) pAce)->SidStart;
            Length = MARTA_ALIGNED_SID_LENGTH(pSid);

            memcpy(CurrentBuffer, pSid, Length);

            BuildTrusteeWithSidW(
                &(pExplicit[j].Trustee),
                (PSID) CurrentBuffer
                );

            CurrentBuffer += Length;
            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            Mask   = ((PKNOWN_COMPOUND_ACE) pAce)->Mask;
            pSid   = (PSID) &((PKNOWN_ACE) pAce)->SidStart;
            Length = MARTA_ALIGNED_SID_LENGTH(pSid);

            memcpy(CurrentBuffer, pSid, Length);

            BuildTrusteeWithSidW(
                &(pExplicit[j].Trustee),
                (PSID) CurrentBuffer
                );

            CurrentBuffer += Length;
            pSid           = (PSID) (((PUCHAR) &(((PKNOWN_ACE) pAce)->SidStart)) + Length);
            Length         = MARTA_ALIGNED_SID_LENGTH(pSid);

            memcpy(CurrentBuffer, pSid, Length);

            pSid           = (PSID) CurrentBuffer;
            CurrentBuffer += Length;

            BuildTrusteeWithSidW(
                (PTRUSTEE_W) CurrentBuffer,
                pSid
                );

            BuildImpersonateTrusteeW(
                &(pExplicit[j].Trustee),
                (PTRUSTEE_W) CurrentBuffer
                );

            CurrentBuffer += sizeof(TRUSTEE_W);
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:

            Mask   = ((PKNOWN_OBJECT_ACE) pAce)->Mask;
            pSid   = RtlObjectAceSid(pAce);
            Length = MARTA_ALIGNED_SID_LENGTH(pSid);

            memcpy((PUCHAR) CurrentBuffer, (PUCHAR) pSid, Length);

            pSid           = (PSID) CurrentBuffer;
            CurrentBuffer += Length;
            pObjSid        = (POBJECTS_AND_SID) CurrentBuffer;
            CurrentBuffer += sizeof(OBJECTS_AND_SID);

            BuildTrusteeWithObjectsAndSidW(
                &(pExplicit[j].Trustee),
                pObjSid,
                RtlObjectAceObjectType(pAce),
                RtlObjectAceInheritedObjectType(pAce),
                pSid
                );
            break;

        default:
            return ERROR_INVALID_PARAMETER;
        }

        switch (pAce->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            pExplicit[j].grfAccessMode = GRANT_ACCESS;
            break;

        case ACCESS_DENIED_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            pExplicit[j].grfAccessMode = DENY_ACCESS;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:

            if ((FALSE == bFlag) && (FLAG_ON(pAce->AceFlags, SUCCESSFUL_ACCESS_ACE_FLAG)))
            {
                pExplicit[j].grfAccessMode = SET_AUDIT_SUCCESS;
                if (FLAG_ON(pAce->AceFlags, FAILED_ACCESS_ACE_FLAG))
                {
                    bFlag = TRUE;
                }
            }
            else if (FLAG_ON(pAce->AceFlags, FAILED_ACCESS_ACE_FLAG))
            {
                pExplicit[j].grfAccessMode = SET_AUDIT_FAILURE;
                bFlag = FALSE;
            }

            break;

        default:
            return ERROR_INVALID_PARAMETER;
        }

        pExplicit[j].grfAccessPermissions = Mask;
        pExplicit[j].grfInheritance = pAce->AceFlags & VALID_INHERIT_FLAGS;

        if (FALSE == bFlag)
        {
            i++;
            pAce = (PACE_HEADER) NextAce(pAce);
        }

        j++;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\idcache.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:        idcache.cxx
//
//  Contents:    Implementation of the DS guid/name lookup cache
//
//  History:     20-Feb-97      MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <stdio.h>
#include <alsup.hxx>

//
// This list contains pointers to memory allocated when a node is converted
// to/from a guid via Rpc apis.  It gets freed during cleanup.
//
typedef struct _ACTRL_ID_MEM
{
    PVOID   pv;
    BOOL    fRpc;
    struct _ACTRL_ID_MEM   *pNext;
} ACTRL_ID_MEM, *PACTRL_ID_MEM;

//
// Global name/id cache
//
PACTRL_OBJ_ID_CACHE  grgIdNameCache[ACTRL_OBJ_ID_TABLE_SIZE];
PACTRL_OBJ_ID_CACHE  grgIdGuidCache[ACTRL_OBJ_ID_TABLE_SIZE];

//
// Mem list head pointer
//
PACTRL_ID_MEM   gpMemCleanupList;

//
// Last connection info/time we read from the schema
//
static ACTRL_ID_SCHEMA_INFO    LastSchemaRead;

//
// Defines for attribute strings
//
#define ACTRL_OBJ_NAME  L"NAME '"
#define ACTRL_OBJ_GUID  L"PROPERTY-GUID '"
#define ACTRL_OBJ_CLASS L"CLASS-GUID '"
#define ACTRL_OBJ_NAME_LEN  sizeof(ACTRL_OBJ_NAME) / sizeof(WCHAR) - 1
#define ACTRL_OBJ_GUID_LEN  sizeof(ACTRL_OBJ_GUID) / sizeof(WCHAR) - 1
#define ACTRL_OBJ_CLASS_LEN  sizeof(ACTRL_OBJ_CLASS) / sizeof(WCHAR) - 1

//
// Local function prototypes
//
PACTRL_NAME_CACHE AccctrlpLookupIdNameInCache(PWSTR   pwszName);

PACTRL_NAME_CACHE AccctrlpLookupGuidInCache(PSID     pSid);

DWORD   AccctrlpNewNameGuidNode(PWSTR                pwszName,
                                PGUID                pGuid,
                                PACTRL_OBJ_ID_CACHE *ppNewNode);

BOOL    AccctrlpInsertIdNameNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                                 PACTRL_OBJ_ID_CACHE  pNewNode);

BOOL    AccctrlpInsertGuidNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                               PACTRL_OBJ_ID_CACHE  pNewNode);

VOID    AccctrlpRemoveIdNameNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                                 PACTRL_OBJ_ID_CACHE  pNewNode);

VOID    AccctrlpFreeUserCacheName(PWSTR      pwszName,
                                  PWSTR      pwszCacheName);

DWORD   AccctrlpLoadCacheFromSchema(PLDAP   pLDAP,
                                    PWSTR   pwszDsPath);

static RTL_RESOURCE gIdCacheLock;
BOOL bIdCacheLockInitialized = FALSE;

//+----------------------------------------------------------------------------
//
//  Function:   ActrlHashIdName
//
//  Synopsis:   Determines the hash index for the given ldap display name
//
//  Arguments:  pwszName        --      Name to hash
//
//  Returns:    Hash index of the string
//
//-----------------------------------------------------------------------------
INT
ActrlHashIdName(PWSTR pwszName)
{
    INT Hash = 0;
#if DBG
    PWSTR   pwsz = pwszName;
#endif

    if(pwszName != NULL)
    {
        while(*pwszName != L'\0')
        {
            Hash = (Hash * 16 + ( tolower(*pwszName++))) % ACTRL_OBJ_ID_TABLE_SIZE;
        }
    }

#if DBG
    acDebugOut((DEB_TRACE_LOOKUP,"Hashing id name %ws to %lu\n",
                pwsz, Hash));
#endif

    return(Hash);
}




//+----------------------------------------------------------------------------
//
//  Function:   ActrlHashGuid
//
//  Synopsis:   Determines the hash index for the given guid
//
//  Arguments:  pGuid           --      Guid to hash
//
//  Returns:    Hash index of the Guid
//
//-----------------------------------------------------------------------------
INT
ActrlHashGuid(PGUID  pGuid)
{
    DWORD   dwTotal = 0;

    //
    // Just deal with the sub authorities
    //
    for(INT i = 0; i < sizeof(GUID) / sizeof(DWORD); i++)
    {
        dwTotal += ((PULONG)pGuid)[i];
    }

#if DBG
    CHAR    szGuid[38];
    memset( szGuid,
            0,
            sizeof(szGuid));
    sprintf(szGuid, "%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,pGuid->Data2,pGuid->Data3,pGuid->Data4[0],
                pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
                pGuid->Data4[7]);


    acDebugOut((DEB_TRACE_LOOKUP,
                "Hashing id %s (Total %lu) to %lu\n",
                szGuid, dwTotal, dwTotal % ACTRL_OBJ_ID_TABLE_SIZE));
#endif
    return(dwTotal % ACTRL_OBJ_ID_TABLE_SIZE);
}





//+----------------------------------------------------------------------------
//
//  Function:   AccctrlInitializeIdNameCache
//
//  Synopsis:   Initialize the ID name/Guid lookup cache
//
//  Arguments:  VOID
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD AccctrlInitializeIdNameCache(VOID)
{
    DWORD dwErr;

    if (TRUE == bIdCacheLockInitialized)
    {
        // Just a precautionary measure to make sure that we do not initialize
        // multiple times.
        //

        ASSERT(FALSE);
        return ERROR_SUCCESS;
    }

    memset(grgIdNameCache, 0,
           sizeof(PACTRL_OBJ_ID_CACHE) * ACTRL_OBJ_ID_TABLE_SIZE);
    memset(grgIdGuidCache, 0,
           sizeof(PACTRL_OBJ_ID_CACHE) * ACTRL_OBJ_ID_TABLE_SIZE);

    gpMemCleanupList = NULL;

    memset(&LastSchemaRead, 0, sizeof(ACTRL_ID_SCHEMA_INFO));

    __try
    {
        RtlInitializeResource(&gIdCacheLock);
        dwErr = ERROR_SUCCESS;
        bIdCacheLockInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RtlNtStatusToDosError(GetExceptionCode());
    }

    return dwErr;
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlFreeIdNameCache
//
//  Synopsis:   Frees any memory allocated for the id name/guid cache
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID AccctrlFreeIdNameCache(VOID)
{
    INT i;
    PACTRL_OBJ_ID_CACHE   pNode, pNext;

    if (FALSE == bIdCacheLockInitialized)
    {
        return;
    }

    for(i = 0; i < ACTRL_OBJ_ID_TABLE_SIZE; i++)
    {
        //
        // Nodes are only inserted into the name cache, so that is the only
        // place we delete them from
        //
        pNode = grgIdNameCache[i];
        while(pNode != NULL)
        {
            pNext = pNode->pNextName;
            AccFree(pNode->pwszName);
            AccFree(pNode);
            pNode = pNext;
        }
    }

    PACTRL_ID_MEM   pMem = gpMemCleanupList;

    while(pMem != NULL)
    {
        if(pMem->fRpc == TRUE)
        {
            PWSTR   pwsz = (PWSTR)pMem->pv;
            RpcStringFree(&pwsz);
        }
        else
        {
            AccFree(pMem->pv);
        }

        pMem = pMem->pNext;
    }

    AccFree(LastSchemaRead.pwszPath);

    RtlDeleteResource(&gIdCacheLock);

    bIdCacheLockInitialized = FALSE;

}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLookupIdNameInCache
//
//  Synopsis:   Determines if the given name exists in the cache or not
//
//  Arguments:  [pwszName]      --      Name to be looked up
//
//  Returns:    Matching node if found, NULL if not
//
//-----------------------------------------------------------------------------
PACTRL_OBJ_ID_CACHE AccctrlpLookupNameInCache(PWSTR   pwszName)
{
    PACTRL_OBJ_ID_CACHE pNode = NULL;

    pNode =  grgIdNameCache[ActrlHashIdName(pwszName)];

    while(pNode != NULL)
    {
        if(_wcsicmp(pwszName, pNode->pwszName) == 0)
        {
            break;
        }
        pNode = pNode->pNextName;
    }

#if DBG
    if(pNode != NULL )
    {
    CHAR    szGuid[38];
    PGUID   pGuid = &pNode->Guid;
    sprintf(szGuid, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,pGuid->Data2,pGuid->Data3,pGuid->Data4[0],
                pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
                pGuid->Data4[7]);

    acDebugOut((DEB_TRACE_LOOKUP,
                "LookupName on  %ws found %s\n",
                pwszName, szGuid));
    }
#endif

    return(pNode);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLookupGuidInCache
//
//  Synopsis:   Determines if the given guid exists in the cache or not
//
//  Arguments:  [pGuid]         --      Guid to be looked up
//
//  Returns:    Matching node if found, NULL if not
//
//-----------------------------------------------------------------------------
PACTRL_OBJ_ID_CACHE AccctrlpLookupGuidInCache(PGUID    pGuid)
{
    PACTRL_OBJ_ID_CACHE pNode = grgIdGuidCache[ActrlHashGuid(pGuid)];

    while(pNode != NULL)
    {
        if(memcmp(pGuid, &(pNode->Guid), sizeof(GUID)) == 0)
        {
            break;
        }
        pNode = pNode->pNextGuid;
    }

#if DBG
    if(pNode != NULL )
    {
    CHAR    szGuid[37];
    sprintf(szGuid, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,pGuid->Data2,pGuid->Data3,pGuid->Data4[0],
                pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
                pGuid->Data4[7]);

    acDebugOut((DEB_TRACE_LOOKUP,
                "LookupGuid on  %s found %ws\n",
                szGuid, pNode->pwszName));
    }
#endif


    return(pNode);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpNewNameGuidNode
//
//  Synopsis:   Allocates a new node and inserts them into the caches
//
//  Arguments:  [pwszName]      --      Name to insert
//              [pGuid]         --      Guid to insert
//              [pNewNode]      --      Newly added node
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_DATA      A node was only inserted in one list
//
//-----------------------------------------------------------------------------
DWORD  AccctrlpNewNameGuidNode(PWSTR                  pwszName,
                               PGUID                  pGuid,
                               PACTRL_OBJ_ID_CACHE   *ppNewNode)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fNameRet = FALSE, fGuidRet = FALSE;

    PACTRL_OBJ_ID_CACHE   pNewNode = (PACTRL_OBJ_ID_CACHE)AccAlloc(
                                                  sizeof(ACTRL_OBJ_ID_CACHE));
    if(pNewNode == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pNewNode->pwszName = pwszName;
        memcpy(&pNewNode->Guid, pGuid, sizeof(GUID));
        pNewNode->pNextName= NULL;
        pNewNode->pNextGuid= NULL;

        fNameRet = AccctrlpInsertIdNameNode(
                                &(grgIdNameCache[ActrlHashIdName(pwszName)]),
                                pNewNode);

        if ( fNameRet == TRUE ) {

            fGuidRet = AccctrlpInsertGuidNode(
                                    &(grgIdGuidCache[ActrlHashGuid(pGuid)]),
                                    pNewNode);
        }

        if(fNameRet == TRUE && fGuidRet == TRUE)
        {
            *ppNewNode = pNewNode;
        }
        else
        {
            dwErr = ERROR_INVALID_DATA;

            if( fNameRet == TRUE )
            {
                AccctrlpRemoveIdNameNode( &(grgIdNameCache[ActrlHashIdName(pwszName)]),
                                          pNewNode);
            }

            AccFree(pNewNode);
            *ppNewNode = NULL;

        }


    }
    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertIdNameNode
//
//  Synopsis:   Inserts the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to insert
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
BOOL AccctrlpInsertIdNameNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                              PACTRL_OBJ_ID_CACHE  pNewNode)
{
    PACTRL_OBJ_ID_CACHE   pNext = NULL, pTrail = NULL;
    BOOL                  fReturn = TRUE;

    if(*ppRootNode == NULL)
    {
        *ppRootNode = pNewNode;
    }
    else
    {
//        acDebugOut((DEB_TRACE_LOOKUP, "Collision inserting %ws with:\n",
//                    pNewNode->pwszName));

        pNext = *ppRootNode;
//        acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        while(pNext != NULL)
        {
            if(_wcsicmp(pNewNode->pwszName, pNext->pwszName) == 0)
            {
                //
                // If a node is already found, exit
                //
                fReturn = FALSE;
                acDebugOut((DEB_TRACE_LOOKUP, "Name %ws already exists. Bailing\n",
                            pNewNode->pwszName));
                break;
            }

            pTrail = pNext;
            pNext = pNext->pNextName;
//            acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        }

        if(fReturn == TRUE)
        {
            if ( pTrail == NULL ) {

                (*ppRootNode)->pNextName = pNewNode;

            } else {

                pTrail->pNextName = pNewNode;

            }
        }
    }

    return(fReturn);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertGuidNode
//
//  Synopsis:   Inserts the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to insert
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
BOOL   AccctrlpInsertGuidNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                              PACTRL_OBJ_ID_CACHE  pNewNode)
{
    PACTRL_OBJ_ID_CACHE   pNext = NULL, pTrail = NULL;
    BOOL                  fReturn = TRUE;

    if(*ppRootNode == NULL)
    {
        *ppRootNode = pNewNode;
    }
    else
    {
//        acDebugOut((DEB_TRACE_LOOKUP, "Collision inserting %ws with:\n",
//                    pNewNode->pwszName));

        pNext = *ppRootNode;
//        acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        while(pNext != NULL)
        {
            if(memcmp(&(pNewNode->Guid), &(pNext->Guid), sizeof(GUID)) == 0)
            {
                fReturn = FALSE;
                acDebugOut((DEB_TRACE_LOOKUP, "Guid for %ws already exists. Bailing\n",
                            pNewNode->pwszName));
                break;
            }

            pTrail = pNext;
            pNext = pNext->pNextGuid;

//            acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        }

        if(fReturn == TRUE)
        {
            if ( pTrail == NULL ) {

                (*ppRootNode)->pNextGuid = pNewNode;

            } else {

                pTrail->pNextGuid = pNewNode;
            }

        }
    }

    return(fReturn);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupIdName
//
//  Synopsis:   Looks up the name for the specified GUID.
//              Algorithm:
//                  Search cache for ID
//                  If not found, reload table from schema on DS referenced
//                      by the DS path
//                  Search the cache for the ID
//                  If not found, return the string version of the ID
//
//  Arguments:  [pGuid]         --      Guid to lookup
//              [fAllocateReturn]-      If true, the name returned is allocated
//                                      into a new buffer.  Otherwise, a
//                                      reference is returned.
//              [ppwszName]     --      Where the name is returned.
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupIdName(IN  PLDAP       pLDAP,
                    IN  PWSTR       pwszDsPath,
                    IN  PGUID       pGuid,
                    IN  BOOL        fAllocateReturn,
                    IN  BOOL        fHandleObjectGuids,
                    OUT PWSTR      *ppwszName)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PWSTR   pwszStringId = NULL;

    RtlAcquireResourceShared(&gIdCacheLock, TRUE);

#if DBG
    CHAR    szGuid[38];
    sprintf(szGuid,
            "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
             pGuid->Data1,pGuid->Data2,pGuid->Data3,
             pGuid->Data4[0],
             pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
             pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
             pGuid->Data4[7]);
#endif

    //
    // First, see if the sid alreadt exists in our cache
    //
    PACTRL_OBJ_ID_CACHE pNode = AccctrlpLookupGuidInCache(pGuid);
    if(pNode == NULL)
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Guid %s not found in cache\n", szGuid));
        //
        // Grab a write lock
        //
        RtlConvertSharedToExclusive(&gIdCacheLock);


        //
        // We'll have to look it up...
        //
        dwErr = AccctrlpLoadCacheFromSchema(pLDAP, pwszDsPath);
        if(dwErr == ERROR_SUCCESS)
        {
            pNode = AccctrlpLookupGuidInCache(pGuid);

            //
            // If we've been asked to handle individual object guids,
            //  see if this GUID is one.
            //

            if ( fHandleObjectGuids ) {
                PWSTR pwszUuid;
                DWORD dwUuidLen;
                PWSTR pwszDSObj;
                PDS_NAME_RESULTW pNameRes;

                //
                // Convert the GUID to a string.
                //

                dwErr = UuidToString(pGuid, &pwszUuid);

                if ( dwErr == ERROR_SUCCESS ) {

                    //
                    // Convert the string-ized GUID to an object name.
                    //

                    dwUuidLen = wcslen( pwszUuid );

                    pwszDSObj = (PWSTR) AccAlloc( (dwUuidLen+3)*sizeof(WCHAR) );

                    if ( pwszDSObj == NULL) {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    } else {
                        PWSTR pwszServer = NULL, pwszObject = NULL;

                        pwszDSObj[0] = L'{';
                        memcpy( &pwszDSObj[1], pwszUuid, dwUuidLen*sizeof(WCHAR) );
                        pwszDSObj[dwUuidLen+1] = L'}';
                        pwszDSObj[dwUuidLen+2] = L'\0';

                        //
                        // Crack the name into canonical form
                        //
                        dwErr = DspSplitPath( pwszDSObj, &pwszServer, &pwszObject );

                        if(dwErr == ERROR_SUCCESS)
                        {

                            dwErr = DspBindAndCrackEx(
                                        pwszServer,
                                        pwszObject,
                                        0,
                                        DS_CANONICAL_NAME,
                                        &pNameRes );

                            if ( dwErr == ERROR_SUCCESS ) {
                                if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0) {
                                    dwErr = ERROR_SUCCESS;
                                } else {
                                    //
                                    // Cache our newly found name.
                                    //

                                    dwErr = AccctrlpNewNameGuidNode( pNameRes->rItems[0].pName,
                                                                     pGuid,
                                                                     &pNode);
                                }


                                // Clean up
                                DsFreeNameResultW(pNameRes);
                            } else {

                                // Failure to find name isn't fatal
                                dwErr = ERROR_SUCCESS;
                            }

                            AccFree(pwszServer);
                        }

                        // Clean up
                        AccFree( pwszDSObj );
                    }

                    // Clean up
                    RpcStringFree(&pwszUuid);
                }
            }

            //
            // If it wasn't found, return the string version of the ID
            //
            if( dwErr == ERROR_SUCCESS && pNode == NULL)
            {
                dwErr = UuidToString(pGuid, &pwszStringId);
            }

        }
    }
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Guid %s found in cache\n", szGuid));
    }

    //
    // Finally, return the information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszName;

        if(pNode != NULL)
        {
            pwszName = pNode->pwszName;
        }
        else
        {
            pwszName = pwszStringId;
        }

        if(fAllocateReturn == TRUE)
        {
            ACC_ALLOC_AND_COPY_STRINGW(pwszName, *ppwszName, dwErr);
        }
        else
        {
            *ppwszName = pwszName;

            if(pwszStringId != NULL)
            {
                PACTRL_ID_MEM pMem = (PACTRL_ID_MEM)AccAlloc(sizeof(ACTRL_ID_MEM));
                if(pMem == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    RpcStringFree(&pwszStringId);
                }
                else
                {
                    pMem->pv = pwszStringId;
                    pMem->fRpc = TRUE;
                    pMem->pNext = gpMemCleanupList;
                    gpMemCleanupList = pMem;
                }
            }
        }
    }

    RtlReleaseResource(&gIdCacheLock);

    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupGuid
//
//  Synopsis:   Looks up the GUID for the specified name
//
//  Arguments:  [pwszName]      --      Name to lookup
//              [fAllocateReturn]-      If true, the name returned is allocated
//                                      into a new buffer.  Otherwise, a
//                                      reference is returned.
//              [ppGuid]        --      Where the guid is returned.
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupGuid(IN  PLDAP         pLDAP,
                  IN  PWSTR         pwszDsPath,
                  IN  PWSTR         pwszName,
                  IN  BOOL          fAllocateReturn,
                  OUT PGUID        *ppGuid)
{
    DWORD   dwErr = ERROR_SUCCESS;
    GUID    guid, *pguid = NULL;
    BOOL    fConverted = FALSE;

    RtlAcquireResourceShared(&gIdCacheLock, TRUE);

    //
    // First, see if the sid already exists in our cache
    //
    PACTRL_OBJ_ID_CACHE pNode = AccctrlpLookupNameInCache(pwszName);
    if(pNode == NULL)
    {
        //
        // Grab a write lock
        //
        RtlConvertSharedToExclusive(&gIdCacheLock);

        acDebugOut((DEB_TRACE_LOOKUP,"Name %ws not found in cache\n",
                    pwszName));
        //
        // We'll have to look it up...
        //
        dwErr = AccctrlpLoadCacheFromSchema(pLDAP, pwszDsPath);
        if(dwErr == ERROR_SUCCESS)
        {
            pNode = AccctrlpLookupNameInCache(pwszName);

            //
            // If it wasn't found, return the ID from the string
            //
            if(pNode == NULL)
            {
                dwErr = UuidFromString(pwszName, &guid);
                fConverted = TRUE;
                pguid = &guid;

            }
            else
            {
                pguid = &pNode->Guid;
            }
        }
    }
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP,"Name %ws found in cache\n", pwszName));
        pguid = &pNode->Guid;
    }

    //
    // Finally, return the information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        if(fAllocateReturn == TRUE)
        {
            ACC_ALLOC_AND_COPY_GUID(pguid, *ppGuid, dwErr);
        }
        else
        {
            if(fConverted == TRUE)
            {
                ACC_ALLOC_AND_COPY_GUID(pguid, *ppGuid, dwErr);

                if(dwErr == ERROR_SUCCESS)
                {
                    PACTRL_ID_MEM pMem = (PACTRL_ID_MEM)AccAlloc(
                                                        sizeof(ACTRL_ID_MEM));
                    if(pMem == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        AccFree(*ppGuid);
                    }
                    else
                    {
                        pMem->pv = *ppGuid;
                        pMem->pNext = gpMemCleanupList;
                        gpMemCleanupList = pMem;
                    }
                }
            }
            else
            {
                *ppGuid = pguid;
            }

        }
    }

    RtlReleaseResource(&gIdCacheLock);

    return(dwErr);
}


#define WCHAR_TO_HEX_BYTE(wc)           \
        (BYTE)((wc) >= L'0' && (wc) <= L'9' ? (wc) - L'0' : towlower( (wc) ) - L'a' + 10)
#define WCHAR_TO_HI_HEX_BYTE(wc)    (WCHAR_TO_HEX_BYTE(wc) << 4 )

//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpDsStrGuidToGuid
//
//  Synopsis:   Converts a read string guid into an actual guid
//
//  Arguments:  [pwszStrGuid]   --      String version of the id
//              [pGuid]         --      Where the build ID is returned
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD AccctrlpDsStrGuidToGuid(IN  PWSTR     pwszStrGuid,
                              OUT PGUID     pGuid)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pwszStrGuid == NULL || wcsstr(pwszStrGuid, L"'") - pwszStrGuid != sizeof(GUID) * sizeof(WCHAR))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
#if 1
        //
        // The string guid we're given is not in a standard UuidToString form,
        // so we'll have to convert it
        //
        PBYTE   pCurr = (PBYTE)pGuid;

        for(ULONG i = 0; i < sizeof(GUID); i++)
        {
            *pCurr = WCHAR_TO_HI_HEX_BYTE(*pwszStrGuid) | WCHAR_TO_HEX_BYTE(*(pwszStrGuid + 1));
            pCurr++;
            pwszStrGuid += 2;
        }
#else

        //
        // Whack it into the right form...
        //
        WCHAR   wszStrFormat[sizeof(GUID) * sizeof(WCHAR) + 7];
        ULONG   Blocks[] = {8, 4, 4, 4, 12};

        PWSTR   pwszStrFor = wszStrFormat;
        for(ULONG i = 0 ; i < sizeof(Blocks) / sizeof(ULONG) ; i++ )
        {
            for(ULONG j = 0; j < Blocks[i]; j++)
            {
                *pwszStrFor++ = *pwszStrGuid++;
            }
            *pwszStrFor++ = L'-';
        }

        pwszStrFor--;
        *pwszStrFor = UNICODE_NULL;

        dwErr = UuidFromString(wszStrFormat, pGuid);
#endif

    }

    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLoadCacheFromSchema
//
//  Synopsis:   Reads the schema cache and adds the entries into the
//              cache
//
//  Arguments:  [pLDAP]         --      LDAP connection to the server
//              [pwszPath]      --      DS path to the object
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD   AccctrlpLoadCacheFromSchema(PLDAP   pLDAP,
                                    PWSTR   pwszDsPath)
{
    DWORD       dwErr = ERROR_SUCCESS;
    PLDAP       pLocalLDAP = pLDAP;
    ULONG       cValues[2];
    PWSTR      *ppwszValues[2];
    PWSTR       rgwszGuidStrs[] = {ACTRL_OBJ_CLASS, ACTRL_OBJ_GUID};
    ULONG       rgGuidStrLen[] = {ACTRL_OBJ_CLASS_LEN, ACTRL_OBJ_GUID_LEN};

    acDebugOut((DEB_TRACE_LOOKUP, "Reloading cache from schema\n"));

    //
    // If we have no parameters, just return...
    //
    if(pLDAP == NULL && pwszDsPath == NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // See if we need to read...  If our data is over 5 minutes old or if our path referenced is
    // not the same as the last one...
    //
#define FIVE_MINUTES    300000
    if((LastSchemaRead.LastReadTime != 0 &&
                            (GetTickCount() - LastSchemaRead.LastReadTime < FIVE_MINUTES)) &&
       DoPropertiesMatch(pwszDsPath, LastSchemaRead.pwszPath) &&
       ((pLDAP == NULL && LastSchemaRead.fLDAP == FALSE) ||
        (pLDAP != NULL && memcmp(pLDAP, &(LastSchemaRead.LDAP), sizeof(LDAP)))))

    {
        acDebugOut((DEB_TRACE_LOOKUP,"Cache up to date...\n"));
        return(ERROR_SUCCESS);
    }
    else
    {
        //
        // Need to reinitialize it...
        //
        if(pLDAP == NULL)
        {
            LastSchemaRead.fLDAP = FALSE;
        }
        else
        {
            LastSchemaRead.fLDAP = TRUE;
            memcpy(&(LastSchemaRead.LDAP), pLDAP, sizeof(LDAP));
        }

        AccFree(LastSchemaRead.pwszPath);
        if(pwszDsPath != NULL)
        {
            ACC_ALLOC_AND_COPY_STRINGW(pwszDsPath, LastSchemaRead.pwszPath, dwErr);
        }

        LastSchemaRead.LastReadTime = GetTickCount();
    }



    if(dwErr == ERROR_SUCCESS && pLocalLDAP == NULL)
    {
        PWSTR pwszServer = NULL, pwszObject = NULL;

        dwErr = DspSplitPath( pwszDsPath, &pwszServer, &pwszObject );

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = BindToDSObject(pwszServer, pwszObject, &pLocalLDAP);
            LocalFree(pwszServer);
        }
    }

    //
    // Now, get the info.  First, extended rights, then the schema info
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccDsReadExtendedRights(pLocalLDAP,
                                        &(cValues[0]),
                                        &(ppwszValues[0]),
                                        &(ppwszValues[1]));
        if(dwErr == ERROR_SUCCESS )
        {
            for(ULONG j = 0; j < cValues[0]  && dwErr == ERROR_SUCCESS; j++)
            {
                GUID    guid;

                dwErr = UuidFromString(ppwszValues[1][j], &guid);

                if(dwErr == ERROR_SUCCESS)
                {
                    PACTRL_OBJ_ID_CACHE pNewNode;

                    PWSTR   pwsz;
                    ACC_ALLOC_AND_COPY_STRINGW(ppwszValues[0][j], pwsz, dwErr);

                    if(dwErr == ERROR_SUCCESS )
                    {

                        dwErr = AccctrlpNewNameGuidNode(pwsz,
                                                        &guid,
                                                        &pNewNode);

                        if(dwErr != ERROR_SUCCESS)
                        {
                            AccFree(pwsz);

                            if ( dwErr == ERROR_INVALID_DATA ) {

                                dwErr = ERROR_SUCCESS;
                            }
                        }
                    }
                }
            }

            AccDsFreeExtendedRights(cValues[0],
                                    ppwszValues[0],
                                    ppwszValues[1]);
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccDsReadSchemaInfo(pLocalLDAP,
                                        &(cValues[0]),
                                        &(ppwszValues[0]),
                                        &(cValues[1]),
                                        &(ppwszValues[1]));
            if(dwErr == ERROR_SUCCESS )
            {
                for(ULONG i = 0; i < 2 && dwErr == ERROR_SUCCESS; i++)
                {
                    for(ULONG j = 0;
                        j < cValues[i]  && dwErr == ERROR_SUCCESS; j++)
                    {
                        PWSTR   pwszVal = ppwszValues[i][j];
                        GUID    guid;

                        PWSTR   pwszName, pwszGuid, pwszTick;

                        pwszName = wcswcs(pwszVal, ACTRL_OBJ_NAME) + ACTRL_OBJ_NAME_LEN;
                        pwszGuid = wcswcs(pwszName, rgwszGuidStrs[i]) + rgGuidStrLen[i];
                        pwszTick = wcswcs(pwszName, L"'");

                        if(pwszTick != NULL)
                        {
                            *pwszTick = UNICODE_NULL;
                        }

                        dwErr = AccctrlpDsStrGuidToGuid(pwszGuid, &guid);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            PACTRL_OBJ_ID_CACHE pNewNode;

                            PWSTR   pwsz;
                            ACC_ALLOC_AND_COPY_STRINGW(pwszName, pwsz, dwErr);

                            if(dwErr == ERROR_SUCCESS )
                            {

                                dwErr = AccctrlpNewNameGuidNode(pwsz,
                                                                &guid,
                                                                &pNewNode);

                                if(dwErr != ERROR_SUCCESS)
                                {
                                    AccFree(pwsz);

                                    if ( dwErr == ERROR_INVALID_DATA ) {

                                        dwErr = ERROR_SUCCESS;
                                    }
                                }
                            }
                        }

                        pwszVal = pwszGuid;
                    }
                }


                ldap_value_free(ppwszValues[0]);
                ldap_value_free(ppwszValues[1]);
            }


        }

    }

    //
    // See if we need to release our ldap connection
    //
    if(pLocalLDAP != pLDAP && pLocalLDAP != NULL)
    {
        UnBindFromDSObject(&pLocalLDAP);
    }
    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpRemoveIdNameNode
//
//  Synopsis:   Removes the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to remove
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID AccctrlpRemoveIdNameNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                              PACTRL_OBJ_ID_CACHE  pNewNode)
{
    PACTRL_OBJ_ID_CACHE   pNext = NULL, pPrev;

    ASSERT( *ppRootNode != NULL );
    if(_wcsicmp((*ppRootNode)->pwszName, pNewNode->pwszName) == 0)
    {
        *ppRootNode = NULL;
    }
    else
    {

        pNext = (*ppRootNode)->pNextName;
        pPrev = *ppRootNode;
        while(pNext != NULL)
        {
            if(_wcsicmp(pNewNode->pwszName, pNext->pwszName) == 0)
            {
                //
                // Remove the node
                //
                pPrev->pNextName = pNext->pNextName;
                acDebugOut((DEB_TRACE_LOOKUP, "Removed node for %ws\n",
                            pNext->pwszName));
                break;
            }

            pPrev = pNext;
            pNext = pNext->pNextName;
        }

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\init.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       INIT.C
//
//  Contents:   DLL Initialization routine
//
//  History:    22-Aug-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <accdbg.h>
#include <lucache.h>
#include <seopaque.h>

HINSTANCE    ghDll;

RTL_RESOURCE gWrkrLock;
BOOL bWrkrLockInitialized = FALSE;

RTL_RESOURCE gCacheLock;
BOOL bCacheLockInitialized = FALSE;

RTL_RESOURCE gLocalSidCacheLock;
BOOL bLocalSidCacheLockInitialized = FALSE;

#if DBG

    #include <seopaque.h>
    #include <sertlp.h>

    #define IsObjectAceType(Ace) (                                              \
        (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && \
            (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)    \
                )

    DEFINE_DEBUG2(ac);

    DEBUG_KEY   acDebugKeys[] = {{DEB_ERROR,         "Error"},
                                 {DEB_WARN,          "Warn"},
                                 {DEB_TRACE,         "Trace"},
                                 {DEB_TRACE_API,     "AccAPI"},
                                 {DEB_TRACE_ACC,     "AccList"},
                                 {DEB_TRACE_CACHE,   "AccCache"},
                                 {DEB_TRACE_PROP,    "AccProp"},
                                 {DEB_TRACE_SD,      "AccSD"},
                                 {DEB_TRACE_LOOKUP,  "AccLU"},
                                 {DEB_TRACE_MEM,     "AccMem"},
                                 {DEB_TRACE_HANDLE,  "AccHandle"},
                                 {0,                 NULL}};


    VOID
    DebugInitialize()
    {
        acInitDebug(acDebugKeys);
    }

    VOID
    DebugUninit()
    {
        acUnloadDebug();
    }

    PVOID   DebugAlloc(ULONG cSize)
    {
        PVOID   pv = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cSize);

        acDebugOut((DEB_TRACE_MEM, "Allocated %lu at 0x%lx\n", cSize, pv ));

        return(pv);
    }

    VOID    DebugFree(PVOID  pv)
    {
        if(pv == NULL)
        {
            return;
        }
        acDebugOut((DEB_TRACE_MEM, "Freeing 0x%lx\n", pv ));

        ASSERT(RtlValidateHeap(RtlProcessHeap(),0,NULL));

        LocalFree(pv);
    }
#endif // DBG


//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Initialize state for NTMARTA.DLL
//
//  Arguments:  [hInstance]     --      Module handle
//              [dwReason]      --      Reason this function is being called
//              [lpReserved]    --      Reserved
//
//  Returns:    TRUE            --      Success
//              FALSE           --      Failure
//
//-----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(HINSTANCE       hInstance,
        DWORD           dwReason,
        LPVOID          lpReserved)
{
    BOOL    fRet = TRUE;
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        ghDll = hInstance;

        __try
        {
            RtlInitializeResource(&gWrkrLock);
            bWrkrLockInitialized = TRUE;
            RtlInitializeResource(&gCacheLock);
            bCacheLockInitialized = TRUE;
            RtlInitializeResource(&gLocalSidCacheLock);
            bLocalSidCacheLockInitialized = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            fRet = FALSE;
        }

        if (FALSE == fRet)
        {
            goto ProcessAttachCleanup;
        }

#if DBG
        DebugInitialize();
#endif

        if(AccctrlInitializeSidNameCache() != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto ProcessAttachCleanup;
        }

        if(AccctrlInitializeIdNameCache() != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto ProcessAttachCleanup;
        }

        if (AccctrlInitializeRightsCache() != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto ProcessAttachCleanup;
        }

        return TRUE;

ProcessAttachCleanup:

        if (TRUE == bWrkrLockInitialized)
        {
            RtlDeleteResource(&gWrkrLock);
        }

        if (TRUE == bCacheLockInitialized)
        {
            RtlDeleteResource(&gCacheLock);
        }

        if (TRUE == bLocalSidCacheLockInitialized)
        {
            RtlDeleteResource(&gLocalSidCacheLock);
        }

        AccctrlFreeSidNameCache();

        AccctrlFreeIdNameCache();

        break;

    case DLL_PROCESS_DETACH:

#if DBG
        DebugUninit();
#endif
        if (TRUE == bWrkrLockInitialized)
        {
            RtlDeleteResource(&gWrkrLock);
        }

        if (TRUE == bCacheLockInitialized)
        {
            RtlDeleteResource(&gCacheLock);
        }

        if (TRUE == bLocalSidCacheLockInitialized)
        {
            RtlDeleteResource(&gLocalSidCacheLock);
        }

        AccctrlFreeSidNameCache();
        AccctrlFreeIdNameCache();
        AccctrlFreeRightsCache();

        if(WmiGuidHandle)
        {
            CloseHandle(WmiGuidHandle);
        }
        break;

    default:
        break;

    }

    return(fRet);

}


#if DBG
VOID
DebugDumpSid(PSTR   pszTag,
             PSID   pSid)
{
    if(pSid == NULL)
    {
        acDebugOut((DEB_TRACE_SD, "%s NULL\n", pszTag));
    }
    else
    {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString(&SidString,
                                              pSid,
                                              TRUE);
        if(!NT_SUCCESS(Status))
        {
            acDebugOut((DEB_ERROR, "%s Can't convert sid to string: 0x%lx\n",
                        pszTag, Status));
        }
        else
        {
            acDebugOut((DEB_TRACE_SD, "%s %wZ\n", pszTag, &SidString));
            RtlFreeUnicodeString(&SidString);
        }
    }
}

VOID
DebugDumpSD(PSTR                    pszTag,
            PSECURITY_DESCRIPTOR    pSD)
{
    if(pSD == NULL)
    {
        acDebugOut((DEB_TRACE_SD,"%s NULL\n", pszTag));
    }
    else
    {
        PISECURITY_DESCRIPTOR   pISD = (PISECURITY_DESCRIPTOR)pSD;


        acDebugOut((DEB_TRACE_SD,"%s: 0x%lx\n", pszTag, pSD));
        acDebugOut((DEB_TRACE_SD,"\tRevision: 0x%lx\n",pISD->Revision));
        acDebugOut((DEB_TRACE_SD,"\tSbz1: 0x%lx\n", pISD->Sbz1));
        acDebugOut((DEB_TRACE_SD,"\tControl: 0x%lx\n",pISD->Control));

        DebugDumpSid("\tOwner", RtlpOwnerAddrSecurityDescriptor(pISD));
        DebugDumpSid("\tGroup", RtlpGroupAddrSecurityDescriptor(pISD));
        DebugDumpAcl("\tDAcl",  RtlpDaclAddrSecurityDescriptor(pISD));
        DebugDumpAcl("\tSAcl",  RtlpSaclAddrSecurityDescriptor(pISD));
    }
}



VOID
DebugDumpAcl(PSTR   pszTag,
             PACL   pAcl)
{
    ACL_SIZE_INFORMATION        AclSize;
    ACL_REVISION_INFORMATION    AclRev;
    PKNOWN_ACE                  pAce;
    PSID                        pSid;
    DWORD                       iIndex;

    if(pAcl == NULL)
    {
        acDebugOut((DEB_TRACE_SD,"%s NULL\n", pszTag));
    }
    else
    {
        acDebugOut((DEB_TRACE_SD, "%s: 0x%lx\n", pszTag, pAcl));

        if(GetAclInformation(pAcl,
                             &AclRev,
                             sizeof(ACL_REVISION_INFORMATION),
                             AclRevisionInformation) == FALSE)
        {
            acDebugOut((DEB_TRACE_SD,
                        "GetAclInformation [Revision] failed: %lu\n",
                        GetLastError()));
            return;
        }

        if(GetAclInformation(pAcl,
                             &AclSize,
                             sizeof(ACL_SIZE_INFORMATION),
                             AclSizeInformation) == FALSE)
        {
            acDebugOut((DEB_TRACE_SD,
                        "GetAclInformation [Size] failed: %lu\n",
                        GetLastError()));
            return;
        }

        acDebugOut((DEB_TRACE_SD, "\t\tRevision: %lu\n", AclRev.AclRevision));
        acDebugOut((DEB_TRACE_SD, "\t\tAceCount: %lu\n", AclSize.AceCount));
        acDebugOut((DEB_TRACE_SD, "\t\tInUse: %lu\n", AclSize.AclBytesInUse));
        acDebugOut((DEB_TRACE_SD, "\t\tFree: %lu\n", AclSize.AclBytesFree));
        acDebugOut((DEB_TRACE_SD, "\t\tFlags: %lu\n", pAcl->Sbz1));


        //
        // Now, dump all of the aces
        //
        pAce = FirstAce(pAcl);
        for(iIndex = 0; iIndex < pAcl->AceCount; iIndex++)
        {
            acDebugOut((DEB_TRACE_SD,"\t\tAce %lu\n", iIndex));

            acDebugOut((DEB_TRACE_SD,"\t\t\tType: %lu\n",
                        pAce->Header.AceType));
            acDebugOut((DEB_TRACE_SD,"\t\t\tFlags: 0x%lx\n",
                        pAce->Header.AceFlags));
            acDebugOut((DEB_TRACE_SD,"\t\t\tSize: 0x%lx\n",
                        pAce->Header.AceSize));
            acDebugOut((DEB_TRACE_SD,"\t\t\tMask: 0x%lx\n",
                        pAce->Mask));

            //
            // If it's an object ace, dump the guids
            //
            if(IsObjectAceType(pAce))
            {
                DebugDumpGuid("\t\t\tObjectId", RtlObjectAceObjectType(pAce));
                DebugDumpGuid("\t\t\tInheritId",
                              RtlObjectAceInheritedObjectType(pAce));
                DebugDumpSid("\t\t\tSid", RtlObjectAceSid(pAce));
            }
            else
            {
                DebugDumpSid("\t\t\tSid", ((PSID)&(pAce->SidStart)));
            }

            pAce = NextAce(pAce);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\filctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
//  File:       file.cpp
//
//  Contents:   NtMarta file functions
//
//  History:    4/99    philh       Created
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <kernel.h>
#include <assert.h>
#include <ntstatus.h>

extern "C" {
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmdfs.h>
}

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stddef.h>

#include <file.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

//+-------------------------------------------------------------------------
//  File Context data structures
//--------------------------------------------------------------------------
typedef struct _FILE_FIND_DATA FILE_FIND_DATA, *PFILE_FIND_DATA;

typedef struct _FILE_CONTEXT {
    DWORD                   dwRefCnt;
    DWORD                   dwFlags;

    // Only closed when FILE_CONTEXT_CLOSE_HANDLE_FLAG is set
    HANDLE                  hFile;

    // Following is allocated and updated for FindFirst, FindNext
    PFILE_FIND_DATA         pFileFindData;
} FILE_CONTEXT, *PFILE_CONTEXT;

#define FILE_CONTEXT_CLOSE_HANDLE_FLAG  0x1

typedef struct _QUERY_NAMES_INFO_BUFFER {
    FILE_NAMES_INFORMATION  NamesInfo;
    WCHAR                   Names[MAX_PATH];
} QUERY_NAMES_INFO_BUFFER;

struct _FILE_FIND_DATA {
    HANDLE                  hDir;
    BOOL                    fRestartScan;       // TRUE on first Find
    QUERY_NAMES_INFO_BUFFER NamesInfoBuffer;
};

//+-------------------------------------------------------------------------
//  File allocation functions
//--------------------------------------------------------------------------
#define I_MartaFileZeroAlloc(size)     \
            LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, size)
#define I_MartaFileNonzeroAlloc(size)  \
            LocalAlloc(LMEM_FIXED, size)

STATIC
inline
VOID
I_MartaFileFree(
    IN LPVOID pv
    )

/*++

Routine Description:

   Free the given memory.

Arguments:

    pv - Ponter to memory to be freed.

Return Value:

    None.

--*/

{
    if (pv)
        LocalFree(pv);
}

STATIC
DWORD
I_MartaFileGetNtParentString(
    IN OUT LPWSTR pwszNtParent
    )

/*++

Routine Description:

    Given the name for a file/dir, get the name of its parent. Does not allocate
    memory. Scans till the first '\' from the right and deletes the name after
    that.

Arguments:

    pwszNtParent - Object name which will be converted to its parent name.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    DWORD cch;
    LPWSTR pwsz;

    if (NULL == pwszNtParent)
        return ERROR_INVALID_NAME;

    cch = wcslen(pwszNtParent);
    pwsz = pwszNtParent + cch;
    if (0 == cch)
        goto InvalidNameReturn;
    pwsz--;

    //
    // Remove any trailing '\'s
    //

    while (L'\\' == *pwsz) {
        if (pwsz == pwszNtParent)
            goto InvalidNameReturn;
        pwsz--;
    }

    //
    // Peal off the last path name component
    //

    while (L'\\' != *pwsz) {
        if (pwsz == pwszNtParent)
            goto InvalidNameReturn;
        pwsz--;
    }

    //
    // Remove all trailing '\'s from the parent.
    //

    while (L'\\' == *pwsz) {
        if (pwsz == pwszNtParent)
            goto InvalidNameReturn;
        pwsz--;
    }
    pwsz++;
    assert(L'\\' == *pwsz);

    //
    // Required to distinguish between the device and root directory.
    //

    pwsz++;

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *pwsz = L'\0';
    return dwErr;
InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto CommonReturn;
}


STATIC
DWORD
I_MartaFileInitContext(
    OUT PFILE_CONTEXT *ppFileContext
    )

/*++

Routine Description:

    Allocate and initialize memory for the context.

Arguments:

    ppFileContext - To return the pointer to the allcoated memory.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    PFILE_CONTEXT pFileContext;

    if (pFileContext = (PFILE_CONTEXT) I_MartaFileZeroAlloc(
            sizeof(FILE_CONTEXT))) {
        pFileContext->dwRefCnt = 1;
        dwErr = ERROR_SUCCESS;
    } else {
        pFileContext = NULL;
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppFileContext = pFileContext;
    return dwErr;
}

STATIC
DWORD
I_MartaFileNtOpenFile(
    IN PUNICODE_STRING pFileName,
    IN HANDLE hContainingDirectory, // NULL if pFileName is absolute
    IN ACCESS_MASK AccessMask,
    IN OUT PFILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Open the given file/dir with requested permissions and copy the handle into
    the supplied context.

Arguments:

    pFileName - Name of the file/dir to be opened.
    
    hContainingDirectory - Handle to the parent dir.
    
    AccessMask - Desired access mask for the open.
    
    pFileContext - Handle will be copied into the context structure.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    // cut and paste code from windows\base\advapi\security.c SetFileSecurityW

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;

    InitializeObjectAttributes(
        &Obja,
        pFileName,
        OBJ_CASE_INSENSITIVE,
        hContainingDirectory,
        NULL
        );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior. Thus, the
    // security will always be set, as before, in the file denoted by the name.
    //

    Status = NtOpenFile(
                 &pFileContext->hFile,
                 AccessMask,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_REPARSE_POINT
                 );

    //
    // Back-level file systems may not support the FILE_OPEN_REPARSE_POINT
    // flag. We treat this case explicitly.
    //

    if ( Status == STATUS_INVALID_PARAMETER ) {
        //
        // Open without inhibiting the reparse behavior.
        //

        Status = NtOpenFile(
                     &pFileContext->hFile,
                     AccessMask,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     );
    }

    if (NT_SUCCESS(Status)) {
        pFileContext->dwFlags |= FILE_CONTEXT_CLOSE_HANDLE_FLAG;
        return ERROR_SUCCESS;
    } else
        return RtlNtStatusToDosError(Status);
}

DWORD
MartaOpenFileNamedObject(
    IN  LPCWSTR              pwszObject,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    )

/*++

Routine Description:

    Open the given file/dir with desired access mask and return a context
    handle.

Arguments:

    pwszObject - Name of the file/dir which will be opened.
    
    AccessMask - Desired access mask with which the file/dir will be opened.
    
    pContext - To return a context handle.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PFILE_CONTEXT pFileContext = NULL;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer = NULL;

    if (NULL == pwszObject)
        goto InvalidNameReturn;

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileContext)))
        goto ErrorReturn;

    //
    // Convert the name into NT pathname.
    //

    if (!RtlDosPathNameToNtPathName_U(
            pwszObject,
            &FileName,
            NULL,
            &RelativeName
            ))
        goto InvalidNameReturn;
    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Call the helper routine that does the actual open.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileNtOpenFile(
            &FileName,
            RelativeName.ContainingDirectory,
            AccessMask,
            pFileContext
            )))
        goto ErrorReturn;
CommonReturn:
    if (FreeBuffer)
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    *pContext = (MARTA_CONTEXT) pFileContext;
    return dwErr;

ErrorReturn:
    if (pFileContext) {
        MartaCloseFileContext((MARTA_CONTEXT) pFileContext);
        pFileContext = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto ErrorReturn;
}

void
I_MartaFileFreeFindData(
    IN PFILE_FIND_DATA pFileFindData
    )

/*++

Routine Description:

    Free up the memory associated with the internal structure.

Arguments:

    pFileFindData - Internal file structure to be freed.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    if (NULL == pFileFindData)
        return;
    if (pFileFindData->hDir)
        NtClose(pFileFindData->hDir);

    I_MartaFileFree(pFileFindData);
}

DWORD
MartaCloseFileContext(
    IN MARTA_CONTEXT Context
    )

/*++

Routine Description:

    Close the context.

Arguments:

    Context - Context to be closed.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        return ERROR_INVALID_PARAMETER;

    //
    // If the refcnt has gone to zero then free up the memory associated with
    // the context handle. Also, close the file handle.
    //

    if (0 == --pFileContext->dwRefCnt) {
        if (pFileContext->pFileFindData)
            I_MartaFileFreeFindData(pFileContext->pFileFindData);

        if (pFileContext->dwFlags & FILE_CONTEXT_CLOSE_HANDLE_FLAG)
            NtClose(pFileContext->hFile);

        I_MartaFileFree(pFileContext);
    }

    return ERROR_SUCCESS;
}

DWORD
MartaAddRefFileContext(
    IN MARTA_CONTEXT Context
    )

/*++

Routine Description:

    Bump up the ref count for this context.

Arguments:

    Context - Context whose ref count should be bumped up.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        return ERROR_INVALID_PARAMETER;

    pFileContext->dwRefCnt++;
    return ERROR_SUCCESS;
}

DWORD
MartaOpenFileHandleObject(
    IN  HANDLE               Handle,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    )

/*++

Routine Description:

    Given a file handle, open the context with the desired access mask and 
    return a context handle.

Arguments:

    Handle - Existing file handle.
    
    AccessMask - Desired access mask for file open.
    
    pContext - To return a handle to the context.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    PFILE_CONTEXT pFileContext = NULL;

    //
    // Allocate and initialize context.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileContext)))
        goto ErrorReturn;

    //
    // Duplicate the handle for desired access mask.
    //

    if (0 == AccessMask)
        pFileContext->hFile = Handle;
    else {
        if (!DuplicateHandle(
                GetCurrentProcess(),
                Handle,
                GetCurrentProcess(),
                &pFileContext->hFile,
                AccessMask,
                FALSE,                  // bInheritHandle
                0                       // fdwOptions
                )) {
            dwErr = GetLastError();
            goto ErrorReturn;
        }
        pFileContext->dwFlags |= FILE_CONTEXT_CLOSE_HANDLE_FLAG;
    }

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *pContext = (MARTA_CONTEXT) pFileContext;
    return dwErr;

ErrorReturn:
    if (pFileContext) {
        MartaCloseFileContext((MARTA_CONTEXT) pFileContext);
        pFileContext = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;
}


DWORD
MartaGetFileParentContext(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pParentContext
    )

/*++

Routine Description:

    Given the context for a file/dir, get the context for its parent.

Arguments:

    Context - Context for the file/dir.
    
    AccessMask - Desired access mask with which the parent will be opened.
    
    pParentContext - To return the context for the parent.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    LPWSTR pwszNtParentObject = NULL;
    PFILE_CONTEXT pFileContext = NULL;
    UNICODE_STRING FileName;

    //
    // Convert the context into the name of the file/dir.
    //

    if (ERROR_SUCCESS != (dwErr = MartaConvertFileContextToNtName(
            Context, &pwszNtParentObject)))
        goto ErrorReturn;

    //
    // Get the name of the parent.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileGetNtParentString(
            pwszNtParentObject)))
        goto NoParentReturn;

    //
    // Initialize the context structure.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileContext)))
        goto ErrorReturn;

    RtlInitUnicodeString(&FileName, pwszNtParentObject);

    //
    // Open the parent dir with the requested permissions.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileNtOpenFile(
            &FileName,
            NULL,               // hContainingDirectory,
            AccessMask,
            pFileContext
            )))
        goto NoParentReturn;
CommonReturn:
    I_MartaFileFree(pwszNtParentObject);
    *pParentContext = (MARTA_CONTEXT) pFileContext;
    return dwErr;

NoParentReturn:
    dwErr = ERROR_SUCCESS;
ErrorReturn:
    if (pFileContext) {
        MartaCloseFileContext((MARTA_CONTEXT) pFileContext);
        pFileContext = NULL;
    }
    goto CommonReturn;
}



DWORD
MartaFindFirstFile(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pChildContext
    )

/*++

Routine Description:

    FInd the first file/dir in the given directory.

Arguments:

    Context - Context for the directory.
    
    AccessMask - Desired access mask for opening the child file/dir.

    pChildContext - To return the context for the first child in the given dir.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:
    Does not free up the current context. 

--*/

{
    DWORD dwErr;
    NTSTATUS Status;
    PFILE_CONTEXT pFileParentContext = (PFILE_CONTEXT) Context;
    PFILE_CONTEXT pFileFirstContext = NULL;
    PFILE_FIND_DATA pFileFindData;    // freed as part of pFileFirstContext
    UNICODE_STRING FileName;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;

    // 
    // Allocate a context for the first child.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileFirstContext)))
        goto ErrorReturn;
    if (NULL == (pFileFindData = (PFILE_FIND_DATA) I_MartaFileZeroAlloc(
            sizeof(FILE_FIND_DATA))))
        goto NotEnoughMemoryReturn;
  
    pFileFindData->fRestartScan = TRUE;
 
    pFileFirstContext->pFileFindData = pFileFindData;

    //
    // Duplicate the parent's file handle for synchronized directory access
    //

    RtlInitUnicodeString(&FileName, NULL);
    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        pFileParentContext->hFile,
        NULL
        );

    //
    // Obtained following parameter values from windows\base\filefind.c
    //

    Status = NtOpenFile(
        &pFileFindData->hDir,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_REPARSE_POINT |  FILE_OPEN_FOR_BACKUP_INTENT
        );

    //
    // Back-level file systems may not support the FILE_OPEN_REPARSE_POINT
    // flag. We treat this case explicitly.
    //

    if ( Status == STATUS_INVALID_PARAMETER ) {

        //
        // Open without inhibiting the reparse behavior.
        //

        Status = NtOpenFile(
            &pFileFindData->hDir,
            FILE_LIST_DIRECTORY | SYNCHRONIZE,
            &Obja,
            &IoStatusBlock,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
                FILE_OPEN_FOR_BACKUP_INTENT
            );
    }

    if (!NT_SUCCESS(Status))
        goto StatusErrorReturn;

    //
    // Following closes / frees pFileFirstContext
    //

    dwErr = MartaFindNextFile(
        (MARTA_CONTEXT) pFileFirstContext,
        AccessMask,
        pChildContext
        );
CommonReturn:
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    if (pFileFirstContext)
        MartaCloseFileContext((MARTA_CONTEXT) pFileFirstContext);
    *pChildContext = NULL;

    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;
}

STATIC
BOOL
I_MartaIsDfsJunctionPoint(
    IN MARTA_CONTEXT        Context
    );


DWORD
MartaFindNextFile(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pSiblingContext
    )

/*++

Routine Description:

    Get the next object in the tree. This is the sibling for the current context.

Arguments:

    Context - Context for the current object.

    AccessMask - Desired access mask for the opening the sibling.
    
    pSiblingContext - To return a handle for the sibling.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:

    Closes the current context.
    
--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS Status;

    PFILE_CONTEXT pFilePrevContext = (PFILE_CONTEXT) Context;
    PFILE_CONTEXT pFileSiblingContext = NULL;

    //
    // Following don't need to be freed or closed
    //

    PFILE_FIND_DATA pFileFindData;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_NAMES_INFORMATION pNamesInfo;
    HANDLE hDir;

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileSiblingContext)))
        goto ErrorReturn;

    //
    // Move the FindData on to the sibling context
    //

    pFileFindData = pFilePrevContext->pFileFindData;
    if (NULL == pFileFindData)
        goto InvalidParameterReturn;
    pFilePrevContext->pFileFindData = NULL;
    pFileSiblingContext->pFileFindData = pFileFindData;

    hDir = pFileFindData->hDir;
    pNamesInfo = &pFileFindData->NamesInfoBuffer.NamesInfo;
    while (TRUE) {
        UNICODE_STRING FileName;
        DWORD cchFileName;
        LPCWSTR pwszFileName;

        //
        // Get the name of the sibling object.
        //

        Status = NtQueryDirectoryFile(
            hDir,
            NULL,           // HANDLE Event OPTIONAL,
            NULL,           // PIO_APC_ROUTINE ApcRoutine OPTIONAL,
            NULL,           // ApcContext OPTIONAL,
            &IoStatusBlock,
            pNamesInfo,
            sizeof(pFileFindData->NamesInfoBuffer),
            FileNamesInformation,
            TRUE,           // BOOLEAN ReturnSingleEntry,
            NULL,           // PUNICODE_STRING FileName OPTIONAL,
            pFileFindData->fRestartScan != FALSE
            );
        if (ERROR_SUCCESS != Status)
            goto StatusErrorReturn;

        pFileFindData->fRestartScan = FALSE;

        FileName.Length = (USHORT) pNamesInfo->FileNameLength;
        FileName.MaximumLength = (USHORT) FileName.Length;
        FileName.Buffer = pNamesInfo->FileName;
        cchFileName = FileName.Length / sizeof(WCHAR);
        pwszFileName = FileName.Buffer;

        // Skip "." and ".."
        if (0 < cchFileName && L'.' == pwszFileName[0] &&
                (1 == cchFileName ||
                    (2 == cchFileName && L'.' == pwszFileName[1])))
            continue;

        //
        //  For an error still return this context. This allows the caller
        //  to continue on to the next sibling object and know there was an
        //  error with this sibling object
        //

        dwErr = I_MartaFileNtOpenFile(
            &FileName,
            hDir,
            AccessMask,
            pFileSiblingContext
            );

        //
        // Per Praerit, skip DFS junction points.
        //

        if (ERROR_SUCCESS == dwErr &&
                I_MartaIsDfsJunctionPoint(pFileSiblingContext)) {
            assert(pFileSiblingContext->dwFlags &
                FILE_CONTEXT_CLOSE_HANDLE_FLAG);
            if (pFileSiblingContext->dwFlags &
                    FILE_CONTEXT_CLOSE_HANDLE_FLAG) {
                NtClose(pFileSiblingContext->hFile);
                pFileSiblingContext->hFile = NULL;
                pFileSiblingContext->dwFlags &=
                    ~FILE_CONTEXT_CLOSE_HANDLE_FLAG;
            }
            continue;
        } else
            break;
    }

CommonReturn:
    MartaCloseFileContext(Context);
    *pSiblingContext = (MARTA_CONTEXT) pFileSiblingContext;
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    if (pFileSiblingContext) {
        MartaCloseFileContext((MARTA_CONTEXT) pFileSiblingContext);
        pFileSiblingContext = NULL;
    }

    //
    // If there are no more chidren, return ERROR_SUCCESS with a NULL sibling
    // context.
    //

    if (ERROR_NO_MORE_FILES == dwErr)
        dwErr = ERROR_SUCCESS;
    goto CommonReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}

#define WINDFS_DEVICE       L"\\Device\\WinDfs"
#define WINDFS_DEVICE_LEN   (sizeof(WINDFS_DEVICE) / sizeof(WCHAR) - 1)
#define WINDFS_PREFIX       WINDFS_DEVICE L"\\Root"
#define WINDFS_PREFIX_LEN   (sizeof(WINDFS_PREFIX) / sizeof(WCHAR) - 1)

#define MAX_QUERY_RETRY_CNT 16

STATIC
DWORD
I_MartaFileHandleToNtDfsName(
    IN HANDLE hFile,
    OUT LPWSTR *ppwszNtObject
    )

/*++

Routine Description:

    Covert the given file handle for a DFS object into name. Allocates memory.

Arguments:

    hFile - Handle for the DFS object.
    
    ppwszNtObject - To return the name of the DFS object.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:

    Couple of problems in the name returned by NtQueryObject for DFS objects:
      - Name contains 4 extra, bogus bytes (This is a BUG that should be fixed)
      - For logical drives, returns \Device\WinDfs\X:0\server\share. This
      needs to be converted to \Device\WinDfs\Root\server\share.
      Where X is the drive letter.
      
   This routine is called when it has already been determined the hFile
   refers to a DFS object name.

--*/

{
    NTSTATUS Status;
    DWORD dwErr;
    LPWSTR pwszNtObject = NULL;

    IO_STATUS_BLOCK IoStatusBlock;
    BYTE Buff[MAX_PATH * 4];
    PFILE_NAME_INFORMATION pAllocNI = NULL;
    PFILE_NAME_INFORMATION pNI;                     // not allocated
    LPWSTR pwszFileName;
    DWORD cchFileName;
    DWORD cchNtObject;
    ULONG cbNI;
    DWORD cRetry;

    pNI = (PFILE_NAME_INFORMATION) Buff;
    cbNI = sizeof(Buff);
    cRetry = 0;
    while (TRUE) {

        //
        // This returns the filename without the Nt Dfs object name prefix.
        //
        // Assumption: the returned filename always has a leading '\'.
        //

        Status = NtQueryInformationFile(
            hFile,
            &IoStatusBlock,
            pNI,
            cbNI,
            FileNameInformation
            );

        if (ERROR_SUCCESS == Status)
            break;

        if (!(Status == STATUS_BUFFER_TOO_SMALL ||
                Status == STATUS_INFO_LENGTH_MISMATCH ||
                Status == STATUS_BUFFER_OVERFLOW))
            goto StatusErrorReturn;

        if (++cRetry >= MAX_QUERY_RETRY_CNT)
            goto InvalidNameReturn;

        //
        // Double buffer length and retry
        //

        cbNI = cbNI * 2;
        I_MartaFileFree(pAllocNI);
        if (NULL == (pAllocNI = (PFILE_NAME_INFORMATION)
                I_MartaFileNonzeroAlloc(cbNI)))
            goto NotEnoughMemoryReturn;
        pNI = pAllocNI;
    }

    //
    // Compute the length of the buffer required to hold the name.
    //

    pwszFileName = pNI->FileName;
    cchFileName = pNI->FileNameLength / sizeof(WCHAR);
    if (0 == cchFileName)
        goto InvalidNameReturn;

    cchNtObject = WINDFS_PREFIX_LEN + cchFileName;

    //
    // Allocate memory.
    //

    if (NULL == (pwszNtObject = (LPWSTR) I_MartaFileNonzeroAlloc(
            (cchNtObject + 1) * sizeof(WCHAR))))
        goto NotEnoughMemoryReturn;

    //
    // Copy the prefix and the file name.
    //

    memcpy(pwszNtObject, WINDFS_PREFIX, WINDFS_PREFIX_LEN * sizeof(WCHAR));
    memcpy(pwszNtObject + WINDFS_PREFIX_LEN, pwszFileName,
        cchFileName * sizeof(WCHAR));
    pwszNtObject[cchNtObject] = L'\0';

    dwErr = ERROR_SUCCESS;

CommonReturn:
    I_MartaFileFree(pAllocNI);
    *ppwszNtObject = pwszNtObject;
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    assert(NULL == pwszNtObject);
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;

InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto ErrorReturn;
}

STATIC
BOOL
I_MartaIsDfsJunctionPoint(
    IN MARTA_CONTEXT        Context
    )

/*++

Routine Description:

    Determine whether this is a DFS junction point.

Arguments:

    Context - Context for which the caller want to determine whether this is a
        dfs junction point.
        
Return Value:

    TRUE if this is a DFS junction point.
    FALSE o/w.

--*/

{
    BOOL fDfsJunctionPoint = FALSE;
    LPWSTR pwszNtObject = NULL;
    DWORD cchNtObject;
    LPWSTR pwszDfs;                 // not allocated
    NET_API_STATUS NetStatus;
    LPBYTE pbNetInfo = NULL;

    if (ERROR_SUCCESS != MartaConvertFileContextToNtName(
            Context, &pwszNtObject))
        goto CommonReturn;

    //
    // Check the prefix.
    //

    if (0 != _wcsnicmp(pwszNtObject, WINDFS_PREFIX, WINDFS_PREFIX_LEN))
        goto CommonReturn;

    //
    // Convert the NtDfs name to a UNC name
    //

    pwszDfs = pwszNtObject + WINDFS_PREFIX_LEN - 1;
    *pwszDfs = L'\\';

    //
    // Assumption: the following is only successful for DFS junction point
    // filename.
    //

    NetStatus = NetDfsGetInfo(
        pwszDfs,
        NULL,               // ServerName
        NULL,               // ShareName
        1,
        &pbNetInfo
        );
    if (0 == NetStatus) {
        fDfsJunctionPoint = TRUE;
    }

CommonReturn:
    if (pwszNtObject)
        LocalFree(pwszNtObject);
    if (pbNetInfo)
        NetApiBufferFree(pbNetInfo);

    return fDfsJunctionPoint;
}

DWORD
MartaConvertFileContextToNtName(
    IN MARTA_CONTEXT        Context,
    OUT LPWSTR              *ppwszNtObject
    )

/*++

Routine Description:

    Returns the NT Object Name for the given context. Allocates memory.

Arguments:

    Context - Context for the file/dir.

    ppwszNtbject - To return the name of the file/dir.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;
    LPWSTR pwszNtObject = NULL;

    BYTE Buff[MAX_PATH * 4];
    ULONG cLen = 0;
    POBJECT_NAME_INFORMATION pNI;                   // not allocated
    POBJECT_NAME_INFORMATION pAllocNI = NULL;

    NTSTATUS Status;
    HANDLE hFile;               // not opened
    LPWSTR pwszPath;
    DWORD cchPath;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        goto InvalidParameterReturn;

    hFile = pFileContext->hFile;

    //
    // First, determine the size of the buffer we need.
    //

    pNI = (POBJECT_NAME_INFORMATION) Buff;

    Status = NtQueryObject(hFile,
        ObjectNameInformation,
        pNI,
        sizeof(Buff),
        &cLen);

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_BUFFER_TOO_SMALL ||
                Status == STATUS_INFO_LENGTH_MISMATCH ||
                Status == STATUS_BUFFER_OVERFLOW) {
            //
            // Allocate a big enough buffer
            //

            if (NULL == (pAllocNI = (POBJECT_NAME_INFORMATION)
                    I_MartaFileNonzeroAlloc(cLen)))
                goto NotEnoughMemoryReturn;

            pNI = pAllocNI;

            Status = NtQueryObject(hFile,
                                   ObjectNameInformation,
                                   pNI,
                                   cLen,
                                   NULL);
            if (!NT_SUCCESS(Status))
                goto StatusErrorReturn;
        } else
            goto StatusErrorReturn;
    }

    pwszPath = pNI->Name.Buffer;
    cchPath = pNI->Name.Length / sizeof(WCHAR);

    //
    // For DFS names, call a helper routine.
    //

    if (WINDFS_DEVICE_LEN <= cchPath &&
            0 == _wcsnicmp(pwszPath, WINDFS_DEVICE, WINDFS_DEVICE_LEN))
        dwErr = I_MartaFileHandleToNtDfsName(hFile, &pwszNtObject);
    else {

        //
        // Allocate and return the name of the object.
        //

        if (NULL == (pwszNtObject = (LPWSTR) I_MartaFileNonzeroAlloc(
                (cchPath + 1) * sizeof(WCHAR))))
            goto NotEnoughMemoryReturn;

        memcpy(pwszNtObject, pwszPath, cchPath * sizeof(WCHAR));
        pwszNtObject[cchPath] = L'\0';

        dwErr = ERROR_SUCCESS;
    }


CommonReturn:
    I_MartaFileFree(pAllocNI);
    *ppwszNtObject = pwszNtObject;
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    assert(NULL == pwszNtObject);
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}


DWORD
MartaGetFileProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    )

/*++

Routine Description:

    Return the properties for file/dir represented by the context.

Arguments:

    Context - Context whose properties the caller has asked for.
    
    pProperties - To return the properties for this file/dir.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS Status;
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicFileInfo;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        goto InvalidParameterReturn;

    //
    // Query the attributes for the file/dir.
    // In case of error, assume that it is a dir.
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile(
            pFileContext->hFile,
            &IoStatusBlock,
            &BasicFileInfo,
            sizeof(BasicFileInfo),
            FileBasicInformation)))
        pProperties->dwFlags |= MARTA_OBJECT_IS_CONTAINER;
    else if (BasicFileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        pProperties->dwFlags |= MARTA_OBJECT_IS_CONTAINER;

    dwErr = ERROR_SUCCESS;
CommonReturn:
    return dwErr;

ErrorReturn:
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}

DWORD
MartaGetFileTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    )

/*++

Routine Description:

    Return the properties of file system objects.

Arguments:

    pProperties - To return the properties of file system objects.

Return Value:

    ERROR_SUCCESS.

--*/

{
    const GENERIC_MAPPING GenMap = {
        FILE_GENERIC_READ,
        FILE_GENERIC_WRITE,
        FILE_GENERIC_EXECUTE,
        FILE_ALL_ACCESS
        };

    //
    // Propagation to be done on the client side.
    //
    pProperties->dwFlags |= MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG;

    //
    // Tree organization of obects is present.
    //

    pProperties->dwFlags |= MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG;

    //
    // Return the generic mapping too.
    //

    pProperties->GenMap = GenMap;

    return ERROR_SUCCESS;
}

DWORD
MartaGetFileRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )

/*++

Routine Description:

    Get the security descriptor for the given handle.

Arguments:

    Context - Context for file/dir.
    
    SecurityInfo - Type of security information to be read.
    
    ppSecurityDescriptor - To return a self-relative security decriptor pointer.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    BOOL fResult;
    DWORD dwErr = ERROR_SUCCESS;
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;
    DWORD cbSize;
    PISECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        goto InvalidParameterReturn;

    //
    // First, get the size we need
    //

    cbSize = 0;
    if (GetKernelObjectSecurity(
            pFileContext->hFile,
            SecurityInfo,
            NULL,                       // pSecDesc
            0,
            &cbSize
            ))
        goto InternalErrorReturn;

    dwErr = GetLastError();
    if (ERROR_INSUFFICIENT_BUFFER == dwErr) {
        if (NULL == (pSecurityDescriptor =
                (PISECURITY_DESCRIPTOR) I_MartaFileNonzeroAlloc(cbSize)))
            goto NotEnoughMemoryReturn;

        //
        // Now get the security descriptor.
        //

        if (!GetKernelObjectSecurity(
                pFileContext->hFile,
                SecurityInfo,
                pSecurityDescriptor,
                cbSize,
                &cbSize
                ))
            goto LastErrorReturn;
    } else
        goto ErrorReturn;

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *ppSecurityDescriptor = pSecurityDescriptor;
    return dwErr;

LastErrorReturn:
    dwErr = GetLastError();
ErrorReturn:
    if (pSecurityDescriptor) {
        I_MartaFileFree(pSecurityDescriptor);
        pSecurityDescriptor = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
InternalErrorReturn:
    dwErr = ERROR_INTERNAL_ERROR;
    goto ErrorReturn;
}


DWORD
MartaSetFileRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    Set the given security descriptor on the file/dir represented by the context.

Arguments:

    Context - Context for the file/dir.

    SecurityInfo - Type of security info to be stamped on the file/dir.

    pSecurityDescriptor - Security descriptor to be stamped.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;

    //
    // Basic validation on the context.
    //

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        goto InvalidParameterReturn;

    //
    // Set the security on the file/dir.
    //

    if (!SetKernelObjectSecurity(
            pFileContext->hFile,
            SecurityInfo,
            pSecurityDescriptor
            ))
        goto LastErrorReturn;

    dwErr = ERROR_SUCCESS;
CommonReturn:
    return dwErr;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto CommonReturn;
LastErrorReturn:
    dwErr = GetLastError();
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;
}

ACCESS_MASK
MartaGetFileDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    )

/*++

Routine Description:

    Gets the access required to open object to be able to set or get the 
    specified security info.

Arguments:

    OpenType - Flag indicating if the object is to be opened to read or write
        the security information

    Attribs - TRUE indicates that additional access bits should be returned.

    SecurityInfo - owner/group/dacl/sacl

Return Value:

    Desired access mask with which open should be called.

--*/

{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    //
    // ONLY FOR FILES.
    //

    if (Attribs)
    {
        DesiredAccess |= FILE_READ_ATTRIBUTES | READ_CONTROL;
    }

    return (DesiredAccess);
}

DWORD
MartaReopenFileContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    )

/*++

Routine Description:

    Given the context for a file/dir, close the existing handle if one exists 
    and reopen the context with new permissions.

Arguments:

    Context - Context to be reopened.
    
    AccessMask - Permissions for the reopen.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;

    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;

    //
    // Following don't need to be freed or closed
    //

    PFILE_FIND_DATA pFileFindData;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_NAMES_INFORMATION pNamesInfo;
    HANDLE hDir;

    UNICODE_STRING FileName;

    //
    // VishnuP: Bug #384222 (AV since Context == NULL).
    // In MartaUpdateTree(), we don't error in case the 
    // ChildContext is NULL so return here too with success
    //

    if ( NULL == Context) 
    
    {
        return ERROR_SUCCESS;
    }

    //
    // Extract the data needed to open the file.
    //

    pFileFindData = pFileContext->pFileFindData;

    hDir = pFileFindData->hDir;
    pNamesInfo = &pFileFindData->NamesInfoBuffer.NamesInfo;

    FileName.Length = (USHORT) pNamesInfo->FileNameLength;
    FileName.MaximumLength = (USHORT) FileName.Length;
    FileName.Buffer = pNamesInfo->FileName;

    //
    // Close the original handle. We do not expect to hit this given the way
    // the code is organized now.
    //

    if (pFileContext->dwFlags & FILE_CONTEXT_CLOSE_HANDLE_FLAG)
        NtClose(pFileContext->hFile);

    //
    // Open the file with the access mask desired.
    //

    dwErr = I_MartaFileNtOpenFile(
        &FileName,
        hDir,
        AccessMask,
        pFileContext
        );

    //
    // In case of a successful open mark the context.
    //

    if (ERROR_SUCCESS == dwErr)
    {
        pFileContext->dwFlags |= FILE_CONTEXT_CLOSE_HANDLE_FLAG;
    }

    return dwErr;
}

DWORD
MartaReopenFileOrigContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    )

/*++

Routine Description:

    This is a dummy routine.

Arguments:

     Are ignored.

Return Value:

    ERROR_SUCCESS

Note: 

    The context structure must be left untouched.

--*/

{
    //
    // This is a dummy routine. The real reopen is done by MartaFindFirstFile
    // that is called just after this call. The context contains a valid handle
    // which was used to set a new DACL on the file/dir.
    //

    return ERROR_SUCCESS;
}

DWORD
MartaGetFileNameFromContext(
    IN MARTA_CONTEXT Context,
    OUT LPWSTR *pObjectName
    )

/*++

Routine Description:

    Get the name of the file/dir from the context. This routine allocates 
    memory required to hold the name of the object.

Arguments:

    Context - Handle to the context.
    
    pObjectName - To return the pointer to the allocated string.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    return MartaConvertFileContextToNtName(Context, pObjectName);
}

DWORD
MartaGetFileParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    )

/*++

Routine Description:

    Given the name of a file/dir return the name of its parent. The routine 
    allocates memory required to hold the parent name.

Arguments:

    ObjectName - Name of the file/dir.
    
    pParentName - To return the pointer to the allocated parent name.
        In case of the root of the tree, we return NULL parent with ERROR_SUCCESS.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    ULONG Length = wcslen(ObjectName) + 1;
    PWCHAR Name = (PWCHAR) I_MartaFileNonzeroAlloc(sizeof(WCHAR) * Length);
    DWORD dwErr = ERROR_SUCCESS;

    *pParentName = NULL;

    if (!Name)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the name of the object into the allocated buffer.
    //

    wcscpy((WCHAR *) Name, ObjectName);

    //
    // Convert the object name intp its parent name.
    //

    dwErr = I_MartaFileGetNtParentString(Name);

    if (ERROR_SUCCESS != dwErr)
    {
        I_MartaFileFree(Name);

        //
        // This is the root of the tree which does not have a parent. Return
        // ERROR_SUCCESS with ParentName as NULL.
        //

        if (ERROR_INVALID_NAME == dwErr)
            return ERROR_SUCCESS;

        return dwErr;
    }

    *pParentName = Name;

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\kernel.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       kernel.cxx
//
//  Contents:   Kernel support functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <seopaque.h>
#include <sertlp.h>
#pragma warning(disable: 4200)
#include <wmistr.h>
#include <wmiumkm.h>

#define BASED_NAMED_OBJECTS_DIR     L"\\BaseNamedObjects"

//
// Function prototypes
//
ULONG WmipOpenKernelGuid(
    CONST GUID *Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle
    );

HANDLE WmiGuidHandle = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   OpenKernelObject
//
//  Synopsis:   Gets a handle to the specified kernel object
//
//  Arguments:  [IN  pwszObject]        --      Object to open
//              [IN  AccessMask]        --      Type of open to do
//              [OUT pHandle]           --      Where the handle to the object
//                                              is returned
//              [OUT KernelType]        --      Type of the kernel object
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
OpenKernelObject(IN  LPWSTR       pwszObject,
                 IN  ACCESS_MASK  AccessMask,
                 OUT PHANDLE      pHandle,
                 OUT PMARTA_KERNEL_TYPE KernelType)
{
    #define BUFFERSIZE  1024

    HANDLE              hRootDir;
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   Attributes;
    UCHAR               Buffer[BUFFERSIZE];
    BOOL                fFound = FALSE;
    ULONG               Context = 0;
    DWORD               dwErr = ERROR_SUCCESS;
    POBJECT_DIRECTORY_INFORMATION DirInfo = NULL;


    //
    // Get a handle to the base named and iterate through that directory
    // to find the object name.
    //

    RtlInitUnicodeString(&UnicodeString,
                         BASED_NAMED_OBJECTS_DIR);

    InitializeObjectAttributes(&Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenDirectoryObject(&hRootDir,
                                   DIRECTORY_QUERY,
                                   &Attributes);

    if (!NT_SUCCESS(Status))
    {
        return(RtlNtStatusToDosError(Status));
    }

    //
    // Get the entries in batches that will fit in a buffer of size
    // BUFFERSIZE until we find the entry that we want
    //
    while (NT_SUCCESS(Status) && !fFound )
    {
        RtlZeroMemory(Buffer,
                      BUFFERSIZE);

        Status = NtQueryDirectoryObject(hRootDir,
                                        (PVOID)&Buffer,
                                        BUFFERSIZE,
                                        FALSE,
                                        FALSE,
                                        &Context,
                                        NULL);
        if(NT_SUCCESS(Status))
        {
            //
            // Keep looking until we've examined all the entries in this
            // batch or we find what we're looking for.
            //
            DirInfo = (POBJECT_DIRECTORY_INFORMATION)&Buffer[0];
            while(!fFound && DirInfo->Name.Length != 0)
            {
                ULONG cChar;

                cChar = DirInfo->Name.Length/sizeof(WCHAR);
                if((cChar == wcslen(pwszObject)) &&
                     (!wcsncmp(pwszObject,
                               DirInfo->Name.Buffer,
                               cChar )) )
                {
                    fFound = TRUE;
                }
                else
                {
                    DirInfo++;
                }
            }
        }
    }

    if (!fFound)
    {
        if(Status !=  STATUS_NO_MORE_ENTRIES)
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
        else
        {
            dwErr = ERROR_RESOURCE_NAME_NOT_FOUND;
        }
    }
    else
    {
        ASSERT( DirInfo != NULL );
        ASSERT( DirInfo->Name.Length != 0 );
        ASSERT( DirInfo->TypeName.Length != 0 );

        RtlInitUnicodeString(&UnicodeString,
                             pwszObject);
        InitializeObjectAttributes(&Attributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   hRootDir,
                                   NULL);

        //
        // Open the object to get its handle based on its type
        //
        if (wcsncmp(L"Event",
                    DirInfo->TypeName.Buffer,
                    DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenEvent(pHandle,
                                 AccessMask,
                                 &Attributes);
            *KernelType = MARTA_EVENT;
        }
        else if (wcsncmp( L"EventPair",
                          DirInfo->TypeName.Buffer,
                          DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenEventPair(pHandle,
                                     AccessMask,
                                     &Attributes);
            *KernelType = MARTA_EVENT_PAIR;
        }
        else if (wcsncmp(L"Mutant",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenMutant(pHandle,
                                  AccessMask,
                                  &Attributes);
            *KernelType = MARTA_MUTANT;
        }
        else if (wcsncmp(L"Process",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenProcess(pHandle,
                                   AccessMask,
                                   &Attributes,
                                   NULL);
            *KernelType = MARTA_PROCESS;
        }
        else if (wcsncmp( L"Section",
                          DirInfo->TypeName.Buffer,
                          DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenSection(pHandle,
                                   AccessMask,
                                   &Attributes);
            *KernelType = MARTA_SECTION;
        }
        else if (wcsncmp(L"Semaphore",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenSemaphore(pHandle,
                                     AccessMask,
                                     &Attributes);
            *KernelType = MARTA_SEMAPHORE;
        }
        else if (wcsncmp(L"SymbolicLink",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenSymbolicLinkObject(pHandle,
                                              AccessMask,
                                              &Attributes);
            *KernelType = MARTA_SYMBOLIC_LINK;
        }
        else if (wcsncmp(L"Thread",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenThread(pHandle,
                                  AccessMask,
                                  &Attributes,
                                  NULL);
            *KernelType = MARTA_THREAD;
        }
        else if (wcsncmp(L"Timer",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenTimer(pHandle,
                                 AccessMask,
                                 &Attributes);
            *KernelType = MARTA_TIMER;
        }
        else if (wcsncmp(L"Job",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenJobObject(pHandle,
                                     AccessMask,
                                     &Attributes);
            *KernelType = MARTA_JOB;
        }
        else
        {
            Status = STATUS_OBJECT_NAME_INVALID;
        }

        if(!NT_SUCCESS(Status))
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }

    NtClose(hRootDir);

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadKernelPropertyRights
//
//  Synopsis:   Gets the specified rights from the kernel object
//
//  Arguments:  [IN  pwszObject]        --      The object to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//
//  Note:      Kernel objects are assumed to be created through the
//             Win32 APIs so they all reside in the \basenamedobjects
//             directory.
//
//----------------------------------------------------------------------------
DWORD
ReadKernelPropertyRights(IN  LPWSTR                 pwszObject,
                         IN  PACTRL_RIGHTS_INFO     pRightsList,
                         IN  ULONG                  cRights,
                         IN  CAccessList&           AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadKernelPropertyRights\n"));

    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hObject = NULL;
    MARTA_KERNEL_TYPE KernelType;

    //
    // Kernel objects don't have parents from whom they can inherit
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = OpenKernelObject(pwszObject,
                             GetDesiredAccess(READ_ACCESS_RIGHTS,
                                              pRightsList[0].SeInfo),
                             &hObject,
                             &KernelType);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetKernelSecurityInfo(hObject,
                                      pRightsList,
                                      cRights,
                                      AccessList);
        NtClose(hObject);
    }

    acDebugOut((DEB_TRACE, "Out ReadKernelPropertyRights: %lu\n", dwErr));

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetKernelSecurityInfo
//
//  Arguments:  [IN  hObject]           --      The handle to the object to
//                                              get the rights for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetKernelSecurityInfo(IN  HANDLE                 hObject,
                      IN  PACTRL_RIGHTS_INFO     pRightsList,
                      IN  ULONG                  cRights,
                      IN  CAccessList&           AccessList)
{
    acDebugOut((DEB_TRACE, "in GetKernelSecurityInfo\n"));

    UCHAR                   pSDBuff[PSD_BASE_LENGTH];
    PISECURITY_DESCRIPTOR   pSD;
    DWORD                   dwErr = ERROR_SUCCESS;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;

    for(ULONG iIndex = 0; iIndex < cRights && dwErr == ERROR_SUCCESS; iIndex++)
    {
        pSD = (PISECURITY_DESCRIPTOR)pSDBuff;

        Status = NtQuerySecurityObject(hObject,
                                       pRightsList[iIndex].SeInfo,
                                       pSD,
                                       PSD_BASE_LENGTH,
                                       &cNeeded);
        if(!NT_SUCCESS(Status))
        {
            if(Status == STATUS_BUFFER_TOO_SMALL)
            {
                //
                // Fine.. Allocate a big enough buffer
                //
                pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cNeeded);
                if(pSD == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                Status = NtQuerySecurityObject(hObject,
                                               pRightsList[iIndex].SeInfo,
                                               pSD,
                                               cNeeded,
                                               &cNeeded);
            }
        }

        //
        // Now, we've either got a failure or a valid SD...
        //
        if(NT_SUCCESS(Status))
        {
            dwErr = AccessList.AddSD(pSD,
                                     pRightsList[iIndex].SeInfo,
                                     pRightsList[iIndex].pwszProperty);
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }

        if(pSD != (PISECURITY_DESCRIPTOR)pSDBuff)
        {
            AccFree(pSD);
        }
    }

    acDebugOut((DEB_TRACE, "Out GetKernelSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetKernelParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for kernel objects
//
//  Arguments:  [IN  pwszObject]        --      The object to get the parent
//                                              for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_INVALID_FUNCTION  --      Call doesn't make sense here
//
//----------------------------------------------------------------------------
DWORD
GetKernelParentRights(IN  LPWSTR                    pwszObject,
                      IN  PACTRL_RIGHTS_INFO        pRightsList,
                      IN  ULONG                     cRights,
                      OUT PACL                     *ppDAcl,
                      OUT PACL                     *ppSAcl,
                      OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    //
    // This doesn't currently make sense for kernel objects, so simply
    // return an error
    //
    return(ERROR_INVALID_FUNCTION);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetKernelSecurityInfo
//
//  Synopsis:   Sets the specified security info for the handle's
//              kernel object
//
//  Arguments:  [IN  hKernel]           --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetKernelSecurityInfo(IN  HANDLE                    hKernel,
                      IN  SECURITY_INFORMATION      SeInfo,
                      IN  PWSTR                     pwszProperty,
                      IN  PSECURITY_DESCRIPTOR      pSecurityDescriptor)
{
    acDebugOut((DEB_TRACE, "in SetNamedKernelSecurityInfo\n"));

    DWORD dwErr = ERROR_SUCCESS;

    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        NTSTATUS Status = NtSetSecurityObject(hKernel,
                                              SeInfo,
                                              pSecurityDescriptor);

        dwErr = RtlNtStatusToDosError(Status);
    }

    acDebugOut((DEB_TRACE, "Out SetKernelSecurityInfo %lu\n", dwErr));

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetKernelSecurityInfo
//
//  Arguments:  [IN  hObject]           --      The handle to the object to
//                                              get the rights for
//              [IN  SeInfo]            --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetKernelSecurityInfo(IN  HANDLE                    hObject,
                      IN  SECURITY_INFORMATION      SeInfo,
                      OUT PACL                     *ppDAcl,
                      OUT PACL                     *ppSAcl,
                      OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    acDebugOut((DEB_TRACE, "in GetKernelSecurityInfo\n"));

    PISECURITY_DESCRIPTOR   pSD = NULL;
    DWORD                   dwErr = ERROR_SUCCESS;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;

    Status = NtQuerySecurityObject(hObject,
                                   SeInfo,
                                   pSD,
                                   0,
                                   &cNeeded);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // Fine.. Allocate a big enough buffer
            //
            pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cNeeded);
            if(pSD == NULL)
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                Status = NtQuerySecurityObject(hObject,
                                               SeInfo,
                                               pSD,
                                               cNeeded,
                                               &cNeeded);
            }
        }
    }

    //
    // Now, we've either got a failure or a valid SD...
    //
    if(NT_SUCCESS(Status))
    {
        if (pSD != NULL)
        {
            if(ppDAcl != NULL)
            {
                *ppDAcl = RtlpDaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)pSD);
            }

            if(ppSAcl != NULL)
            {
                *ppSAcl = RtlpSaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)pSD);
            }

            *ppSD = pSD;
        }
        else
        {
            dwErr = ERROR_ACCESS_DENIED;
        }

    }
    else
    {
        dwErr = RtlNtStatusToDosError(Status);
    }


    acDebugOut((DEB_TRACE, "Out GetKernelSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}


//
// Routines provided by AlanWar for accessind WmiGuid objects
//
_inline HANDLE WmipAllocEvent(
    VOID
    )
{
    HANDLE EventHandle;

    EventHandle = (HANDLE)InterlockedExchangePointer(( PVOID *)&WmiGuidHandle, NULL );

    if ( EventHandle == NULL ) {

        EventHandle = CreateEvent( NULL, FALSE, FALSE, NULL );
    }

    return( EventHandle );
}

_inline void WmipFreeEvent(
    HANDLE EventHandle
    )
{
    if ( InterlockedCompareExchangePointer( &WmiGuidHandle,
                                            EventHandle,
                                            NULL) != NULL ) {

        CloseHandle( EventHandle );
    }
}

ULONG WmipSendWmiKMRequest(
    ULONG Ioctl,
    PVOID Buffer,
    ULONG InBufferSize,
    ULONG MaxBufferSize,
    ULONG *ReturnSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input and output buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED Overlapped;
    ULONG Status;
    BOOL IoctlSuccess;
    HANDLE WmipKMHandle = NULL;
    //
    // If device is not open for then open it now. The
    // handle is closed in the process detach dll callout (DlllMain)
    WmipKMHandle = CreateFile(WMIDataDeviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                              FILE_FLAG_OVERLAPPED,
                              NULL);
    if (WmipKMHandle == (HANDLE)-1)
    {
        WmipKMHandle = NULL;
        return(GetLastError());
    }

    Overlapped.hEvent = WmipAllocEvent();
    if (Overlapped.hEvent == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    do
    {
        IoctlSuccess = DeviceIoControl(WmipKMHandle,
                              Ioctl,
                              Buffer,
                              InBufferSize,
                              Buffer,
                              MaxBufferSize,
                              ReturnSize,
                              &Overlapped);

        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                               &Overlapped,
                                               ReturnSize,
                                               TRUE);
        }

        if (! IoctlSuccess)
        {
            Status = GetLastError();
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);


    NtClose( WmipKMHandle );

    WmipFreeEvent(Overlapped.hEvent);

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenWmiGuidObject
//
//  Synopsis:   Gets a handle to the specified WmiGuid object
//
//  Arguments:  [IN  pwszObject]        --      Object to open
//              [IN  AccessMask]        --      Type of open to do
//              [OUT pHandle]           --      Where the handle to the object
//                                              is returned
//              [OUT KernelType]        --      Type of the kernel object
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
OpenWmiGuidObject(IN  LPWSTR       pwszObject,
                  IN  ACCESS_MASK  AccessMask,
                  OUT PHANDLE      pHandle,
                  OUT PMARTA_KERNEL_TYPE KernelType)
{
    DWORD dwErr;
    UNICODE_STRING GuidString;
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    WCHAR GuidObjectNameBuffer[WmiGuidObjectNameLength+1];
    PWCHAR GuidObjectName = GuidObjectNameBuffer;
    ULONG ReturnSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Length;

    acDebugOut((DEB_TRACE, "In OpenWmiGuidObject\n"));

    Length = (wcslen(WmiGuidObjectDirectory) + wcslen(pwszObject) + 1) * sizeof(WCHAR);

    if ( Length > sizeof(GuidObjectNameBuffer) ) 
    {
        GuidObjectName = (PWCHAR)LocalAlloc( LPTR, Length );

        if ( GuidObjectName == NULL ) 
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    wcscpy(GuidObjectName, WmiGuidObjectDirectory);
    wcscat(GuidObjectName, pwszObject);
    RtlInitUnicodeString(&GuidString, GuidObjectName);

    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &GuidString;

    WmiOpenGuidBlock.ObjectAttributes = &ObjectAttributes;

    WmiOpenGuidBlock.DesiredAccess = AccessMask;

    dwErr = WmipSendWmiKMRequest(IOCTL_WMI_OPEN_GUID,
                                     (PVOID)&WmiOpenGuidBlock,
                                     sizeof(WMIOPENGUIDBLOCK),
                                     sizeof(WMIOPENGUIDBLOCK),
                                     &ReturnSize);

    if (dwErr == ERROR_SUCCESS)
    {
        *pHandle = WmiOpenGuidBlock.Handle.Handle;
        *KernelType = MARTA_WMI_GUID;
    }
    else
    {
        *pHandle = NULL;
    }

    if ( GuidObjectName != GuidObjectNameBuffer )
    {
        LocalFree( GuidObjectName );
    }

    acDebugOut((DEB_TRACE, "Out OpenWmiGuidObject: %lu\n", dwErr));

    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadWmiGuidPropertyRights
//
//  Synopsis:   Gets the specified rights from the WmiGuids object
//
//  Arguments:  [IN  pwszObject]        --      The object to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//
//  Note:      Kernel objects are assumed to be created through the
//             Win32 APIs so they all reside in the \basenamedobjects
//             directory.
//
//----------------------------------------------------------------------------
DWORD
ReadWmiGuidPropertyRights(IN  LPWSTR                 pwszObject,
                          IN  PACTRL_RIGHTS_INFO     pRightsList,
                          IN  ULONG                  cRights,
                          IN  CAccessList&           AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadKernelPropertyRights\n"));

    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hObject;
    MARTA_KERNEL_TYPE KernelType;

    //
    // Kernel objects don't have parents from whom they can inherit
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = OpenWmiGuidObject(pwszObject,
                              GetDesiredAccess(READ_ACCESS_RIGHTS,
                                               pRightsList[0].SeInfo),
                              &hObject,
                              &KernelType);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetWmiGuidSecurityInfo(hObject,
                                       pRightsList,
                                       cRights,
                                       AccessList);
        CloseWmiGuidObject(hObject);
    }

    acDebugOut((DEB_TRACE, "Out ReadKernelPropertyRights: %lu\n", dwErr));

    return (dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetKernelSecurityInfo
//
//  Arguments:  [IN  hObject]           --      The handle to the object to
//                                              get the rights for
//              [IN  SeInfo]            --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetWmiGuidSecurityInfo(IN  HANDLE                    hObject,
                       IN  PACTRL_RIGHTS_INFO        pRightsList,
                       IN  ULONG                     cRights,
                       IN  CAccessList&              AccessList)
{
    acDebugOut((DEB_TRACE, "in GetWmiGuidSecurityInfo\n"));

    UCHAR                   pSDBuff[PSD_BASE_LENGTH];
    PISECURITY_DESCRIPTOR   pSD;
    DWORD                   dwErr = ERROR_SUCCESS;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;

    for(ULONG iIndex = 0; iIndex < cRights && dwErr == ERROR_SUCCESS; iIndex++)
    {
        pSD = (PISECURITY_DESCRIPTOR)pSDBuff;

        Status = NtQuerySecurityObject(hObject,
                                       pRightsList[iIndex].SeInfo,
                                       pSD,
                                       PSD_BASE_LENGTH,
                                       &cNeeded);
        if(!NT_SUCCESS(Status))
        {
            if(Status == STATUS_BUFFER_TOO_SMALL)
            {
                //
                // Fine.. Allocate a big enough buffer
                //
                pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cNeeded);
                if(pSD == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                Status = NtQuerySecurityObject(hObject,
                                               pRightsList[iIndex].SeInfo,
                                               pSD,
                                               cNeeded,
                                               &cNeeded);
            }
        }

        //
        // Now, we've either got a failure or a valid SD...
        //
        if(NT_SUCCESS(Status))
        {
            dwErr = AccessList.AddSD(pSD,
                                     pRightsList[iIndex].SeInfo,
                                     pRightsList[iIndex].pwszProperty);
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }

        if(pSD != (PISECURITY_DESCRIPTOR)pSDBuff)
        {
            AccFree(pSD);
        }
    }

    acDebugOut((DEB_TRACE, "Out GetWmiGuidSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetWmiGuidSecurityInfo
//
//  Synopsis:   Sets the specified security info for the handle's
//              WmiGuid object
//
//  Arguments:  [IN  hKernel]           --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetWmiGuidSecurityInfo(IN  HANDLE                    hWmiGuid,
                       IN  SECURITY_INFORMATION      SeInfo,
                       IN  PWSTR                     pwszProperty,
                       IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetWmiGuidSecurityInfo\n"));

    DWORD dwErr = ERROR_SUCCESS;

    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        NTSTATUS Status = NtSetSecurityObject(hWmiGuid,
                                              SeInfo,
                                              pSD);

        dwErr = RtlNtStatusToDosError(Status);
    }

    acDebugOut((DEB_TRACE, "Out SetWmiGuidSecurityInfo %lu\n", dwErr));

    return (dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetKernelSecurityInfo
//
//  Arguments:  [IN  hObject]           --      The handle to the object to
//                                              get the rights for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetWmiGuidSecurityInfo(IN  HANDLE                    hObject,
                       IN  SECURITY_INFORMATION      SeInfo,
                       OUT PACL                     *ppDAcl,
                       OUT PACL                     *ppSAcl,
                       OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    acDebugOut((DEB_TRACE, "in GetWmiGuidSecurityInfo\n"));

    PISECURITY_DESCRIPTOR   pSD = NULL;
    DWORD                   dwErr = ERROR_SUCCESS;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;

    Status = NtQuerySecurityObject(hObject,
                                   SeInfo,
                                   pSD,
                                   0,
                                   &cNeeded);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // Fine.. Allocate a big enough buffer
            //
            pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cNeeded);
            if(pSD == NULL)
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                Status = NtQuerySecurityObject(hObject,
                                               SeInfo,
                                               pSD,
                                               cNeeded,
                                               &cNeeded);
            }
        }
    }

    //
    // Now, we've either got a failure or a valid SD...
    //
    if(NT_SUCCESS(Status))
    {
        if (pSD != NULL)
        {
            if(ppDAcl != NULL)
            {
                *ppDAcl = RtlpDaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)pSD);
            }

            if(ppSAcl != NULL)
            {
                *ppSAcl = RtlpSaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)pSD);
            }

            *ppSD = pSD;
        }
        else
        {
            dwErr = ERROR_ACCESS_DENIED;
        }
    }
    else
    {
        dwErr = RtlNtStatusToDosError(Status);
    }


    acDebugOut((DEB_TRACE, "Out GetWmiGuidSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\dsobject.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       DSOBJECT.CXX
//
//  Contents:   DSObject support functions
//
//  History:    01-Jul-96        MacM           Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#define NO_PROPAGATE

#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"
#define ACTRL_EXT_RIGHTS_CONTAINER L"CN=Extended-Rights,"

#include <dsgetdc.h>
#include <lmapibuf.h>
#include <mapicode.h>
extern "C"
{
    #include <permit.h>
    #include <seopaque.h>
    #include <sertlp.h>
    #include <ntdsguid.h>
    #include <ntldap.h>
}

#define PSD_FROM_DS_PSD(psd)  (PSECURITY_DESCRIPTOR)((PBYTE)psd + sizeof(ULONG))

#define BYTE_0_MASK 0xFF
#define BYTE_3(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_0(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)

#define MartaPutUlong(Buffer, Value) {          \
    ((PBYTE)Buffer)[0] = BYTE_0(Value),         \
    ((PBYTE)Buffer)[1] = BYTE_1(Value),         \
    ((PBYTE)Buffer)[2] = BYTE_2(Value),         \
    ((PBYTE)Buffer)[3] = BYTE_3(Value);         \
}

DWORD
ConvertStringAToStringW (
    IN  PSTR            pszString,
    OUT PWSTR          *ppwszString
)
/*++

Routine Description:

    This routine will convert an ASCII string to a UNICODE string.

    The returned string buffer must be freed via a call to LocalFree


Arguments:

    pszString - The string to convert
    ppwszString - Where the converted string is returned

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{

    if(pszString == NULL)
    {
        *ppwszString = NULL;
    }
    else
    {
        ULONG cLen = strlen(pszString);
        *ppwszString = (PWSTR)AccAlloc(sizeof(WCHAR) *
                                                        (mbstowcs(NULL, pszString, cLen + 1) + 1));
        if(*ppwszString  != NULL)
        {
             mbstowcs(*ppwszString,
                      pszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}




DWORD
ConvertStringWToStringA (
    IN  PWSTR           pwszString,
    OUT PSTR           *ppszString
)
/*++

Routine Description:

    This routine will convert a UNICODE string to an ANSI string.

    The returned string buffer must be freed via a call to LocalFree


Arguments:

    pwszString - The string to convert
    ppszString - Where the converted string is returned



Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{

    if(pwszString == NULL)
    {
        *ppszString = NULL;
    }
    else
    {
        ULONG cLen = wcslen(pwszString);
        *ppszString = (PSTR)AccAlloc(sizeof(CHAR) *
                                  (wcstombs(NULL, pwszString, cLen + 1) + 1));
        if(*ppszString  != NULL)
        {
             wcstombs(*ppszString,
                      pwszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   DspSplitPath
//
//  Synopsis:   This function splits a path into the server portion and the
//              path portion.  If the server portion doesn't exist, a NULL is
//              returned
//
//  Arguments:  [IN  pwszObjectPath]--  The name of the object to be split
//              [OUT ppwszAllocatedServer]  -- Where the server name is returned.
//                                      Must be freed via AccFree
//              [OUT ppwszReferencePath]    --  Ptr within the input path that
//                                      contains the path portion.
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_PATH_NOT_FOUND--  The object was not reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD DspSplitPath(IN  PWSTR    pwszObjectPath,
                   OUT PWSTR   *ppwszAllocatedServer,
                   OUT PWSTR   *ppwszReferencePath)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWSTR Temp = NULL;
    ULONG Len = 0;

    if(IS_UNC_PATH(pwszObjectPath, wcslen(pwszObjectPath)))
    {

        Temp = wcschr(pwszObjectPath + 2, L'\\');

        if (Temp == NULL) {

            Len = wcslen(pwszObjectPath);
        }
        else
        {
            Len = (ULONG)(Temp - pwszObjectPath);
        }

        *ppwszAllocatedServer = ( PWSTR )AccAlloc( ( Len + 1 ) * sizeof( WCHAR ) );

        if(*ppwszAllocatedServer == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

        }
        else
        {
            wcsncpy( *ppwszAllocatedServer, pwszObjectPath, Len );
            *( *ppwszAllocatedServer + Len ) = UNICODE_NULL;
        }

        if(Temp != NULL)
        {
            *ppwszReferencePath = Temp + 1;
        }
        else
        {
            *ppwszReferencePath = NULL;
        }
    }
    else
    {
        *ppwszReferencePath = pwszObjectPath;
        *ppwszAllocatedServer = NULL;
    }

    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   PingDSObjByNameRes
//
//  Synopsis:   "Pings" the specified DS object, to determine if it is
//              reachable or not
//
// REMOVE POST BETA - 1.  Raid 107329
//
//  Arguments:  [IN  pObjectName]   --  The name of the object
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_PATH_NOT_FOUND--  The object was not reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
PingDSObjByNameRes(IN PWSTR pwszDSObj,
                   IN PDS_NAME_RESULTW pNameRes)
{
    acDebugOut((DEB_TRACE, "in PingDSObjByNameRes\n"));
    DWORD dwErr;

    if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
    {
        dwErr = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        //
        // Now, we'll bind to the object, and then do the read
        //
        PLDAP   pLDAP;

        dwErr = BindToDSObject(NULL,
                               pNameRes->rItems[0].pDomain,
                               &pLDAP);

        if(dwErr == ERROR_SUCCESS)
        {
            PLDAPMessage    pMessage = NULL;
            PWSTR           rgAttribs[2];

            rgAttribs[0] = L"distinguishedName";
            rgAttribs[1] = NULL;


            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = ldap_search_s(pLDAP,
                                      (PWSTR)pwszDSObj,
                                      LDAP_SCOPE_BASE,
                                      L"(objectClass=*)",
                                      rgAttribs,
                                      0,
                                      &pMessage);

                dwErr = LdapMapErrorToWin32( dwErr );
            }

            if(dwErr == ERROR_SUCCESS)
            {
                LDAPMessage *pEntry = NULL;
                pEntry = ldap_first_entry(pLDAP,
                                          pMessage);

                if(pEntry == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    //
                    // Now, we'll have to get the values
                    //
                    PWSTR *ppwszValues = ldap_get_values(pLDAP,
                                                         pEntry,
                                                         rgAttribs[0]);
                    if(ppwszValues == NULL)
                    {

                        if(pLDAP->ld_errno == LDAP_NO_SUCH_ATTRIBUTE )
                        {

                            dwErr =  ERROR_SUCCESS;
                        }
                        else
                        {
                            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                        }
                    }
                    else
                    {
                        ldap_value_free(ppwszValues);
                    }
                }

                ldap_msgfree(pMessage);
            }
        }
    }

    acDebugOut((DEB_TRACE, "out PingDSObjByNameRes: %lu\n", dwErr));
    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   DspBindAndCrack
//
//  Synopsis:   Does a DsCrackName on the object
//
//  Arguments:  [IN  pwszServer]    --  Optional server name to bind to
//              [IN  pwszDSObj]     --  The DS object to bind to
//              [OUT pResults]      --  The returned cracked name
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD DspBindAndCrack( IN  PWSTR pwszServer, OPTIONAL
                       IN  PWSTR pwszDSObj,
                       IN  DWORD OptionalDsGetDcFlags,
                       OUT PDS_NAME_RESULTW *pResults )
{
    return DspBindAndCrackEx( pwszServer,
                              pwszDSObj,
                              OptionalDsGetDcFlags,
                              DS_FQDN_1779_NAME,
                              pResults );
}


//+---------------------------------------------------------------------------
//
//  Function:   DspBindAndCrackEx
//
//  Synopsis:   Does a DsCrackName on the object
//
//  Arguments:  [IN  pwszServer]    --  Optional server name to bind to
//              [IN  pwszDSObj]     --  The DS object to bind to
//              [IN  formatDesired] --  indicates the format of the returned name
//              [OUT pResults]      --  The returned cracked name
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD DspBindAndCrackEx( IN  PWSTR pwszServer,
                         IN  PWSTR pwszDSObj,
                         IN  DWORD OptionalDsGetDcFlags,
                         IN  DS_NAME_FORMAT formatDesired,
                         OUT PDS_NAME_RESULTW *pResults )
{
    DWORD dwErr = ERROR_SUCCESS;

    HANDLE  hDS = NULL;
    PDS_NAME_RESULTW   pNameRes;
    PDOMAIN_CONTROLLER_INFOW pDCI = NULL;
    BOOL NamedServer = FALSE;

    //
    // The path we are given could be of the form \\\\servername\\path.  If it is, it
    // is not necessary to do the DsGetDcName call.  We'll just use the server name
    // we are given
    //
    if(pwszServer != NULL)
    {
        NamedServer = TRUE;
    }
    else
    {
        dwErr = DsGetDcNameW(NULL,
                             NULL,
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED | OptionalDsGetDcFlags,  // DS_IP_REQUIRED
                             &pDCI);

        if(dwErr == ERROR_SUCCESS)
        {
            pwszServer = pDCI[0].DomainControllerName; // pDCI[0].DomainControllerAddress;
        }
    }


    //
    // Do the bind and crack
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = DsBindW(pwszServer,
                        NULL,
                        &hDS);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = DsCrackNamesW(hDS,
                                  DS_NAME_NO_FLAGS,
                                  DS_UNKNOWN_NAME,
                                  formatDesired,
                                  1,
                                  &pwszDSObj,
                                  &pNameRes);

            if (dwErr == ERROR_SUCCESS)
            {

                if(pNameRes->cItems != 0 &&
                   pNameRes->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY &&
                   NamedServer == FALSE )
                {
                    NetApiBufferFree(pDCI);
                    pDCI = NULL;
                    dwErr = DsGetDcNameW(NULL,
                                         pNameRes->rItems[0].pDomain,
                                         NULL,
                                         NULL,
                                         DS_DIRECTORY_SERVICE_REQUIRED | OptionalDsGetDcFlags, // DS_IP_REQUIRED |
                                         &pDCI);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        DsUnBindW(&hDS);
                        hDS = NULL;

                        dwErr = DsBindW(pDCI[0].DomainControllerName, // DomainControllerAddress,
                                        NULL,
                                        &hDS);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = DsCrackNamesW(hDS,
                                                  DS_NAME_NO_FLAGS,
                                                  DS_UNKNOWN_NAME,
                                                  formatDesired,
                                                  1,
                                                  &pwszDSObj,
                                                  &pNameRes);
                        }

                    }

                }

                //
                // If this is a case where we don't have a named server, handle
                // the case where an object was created on one Dc, but we've just
                // bound to a second one
                //
                //
                if (dwErr == ERROR_SUCCESS && formatDesired == DS_FQDN_1779_NAME &&
                    NamedServer == FALSE )
                {
                    dwErr = PingDSObjByNameRes( pwszDSObj,pNameRes );

                    if(dwErr != ERROR_SUCCESS)
                    {
                        DsFreeNameResultW(pNameRes);
                    }

                    if(dwErr == ERROR_PATH_NOT_FOUND && OptionalDsGetDcFlags == 0)
                    {
                        dwErr = DspBindAndCrackEx( pDCI[0].DomainControllerName, //DomainControllerAddress,
                                                   pwszDSObj,
                                                   DS_WRITABLE_REQUIRED,
                                                   formatDesired,
                                                   &pNameRes );
                    }
                }

                *pResults = pNameRes;
            }


            if(hDS != NULL)
            {
                DsUnBindW(&hDS);
            }
        }
    }

    if(pDCI != NULL)
    {
        NetApiBufferFree(pDCI);
    }

    return( dwErr );
}


//+---------------------------------------------------------------------------
//
//  Function:   BindToDSObject
//
//  Synopsis:   Binds to a DS object
//
//  Arguments:  [IN  pwszServer]    --  OPTIONAL.  If specified, this is the name
//                                      of the server to bind to
//              [IN  pwszDSObj]     --  The DS object to bind to
//              [OUT ppLDAP]        --  The returned LDAP handle
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_PATH_NOT_FOUND--  The object was not reachable
//
//  Notes:      The returned LDAP handle must be closed via UnbindFromDSObject
//
//----------------------------------------------------------------------------
DWORD   BindToDSObject(IN  PWSTR    pwszServer, OPTIONAL
                       IN  LPWSTR   pwszDSObj,
                       OUT PLDAP   *ppLDAP)
{
    acDebugOut((DEB_TRACE, "in BindToDSObject\n"));
    PDOMAIN_CONTROLLER_INFOW pDCI = NULL;
    DWORD dwErr = ERROR_SUCCESS;

    //
    // The path we are given could be of the form \\\\servername\\path.  If it is, it
    // is not necessary to do the DsGetDcName call.  We'll just use the server name
    // we are given
    //
    // Change: in order to use mutual authentication, A DNS format domain name must
    // be passed into ldap_open/ldap_init. So even a servername is passed in, it's
    // necessary to call DsGetDcNameW to get the DNS format domain name.
    // Since we asked for DIRECTORY_SERVICE_REQUIRED, this call won't talk to any
    // NT4 domain and the DNS name should always be returned. If it fails to get the
    // DNS name, we will fail this function - by design.
    //

    dwErr = DsGetDcNameW(pwszServer,
                         NULL,
                         NULL,
                         NULL,
                         DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                         &pDCI);


    if(dwErr == ERROR_SUCCESS)
    {
        *ppLDAP = ldap_open(pDCI->DomainName, LDAP_PORT);

        if(*ppLDAP == NULL)
        {
            dwErr = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            //
            // Do a bind...
            //
            dwErr = ldap_bind_s(*ppLDAP,
                                NULL,
                                NULL,
                                LDAP_AUTH_SSPI);

        }

    }

    if(pDCI != NULL)
    {
        NetApiBufferFree(pDCI);
    }

    acDebugOut((DEB_TRACE, "out BindToDSObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   UnBindFromDSObject
//
//  Synopsis:   Closes a binding to a DS object
//
//  Arguments:  [IN  ppLDAP]        --  The LDAP connection to close
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD   UnBindFromDSObject(OUT PLDAP               *ppLDAP)
{
    acDebugOut((DEB_TRACE, "in UnBindFromDSObject\n"));
    DWORD dwErr = ERROR_SUCCESS;

    if(*ppLDAP != NULL)
    {
        ldap_unbind(*ppLDAP);
        *ppLDAP = NULL;
    }

    acDebugOut((DEB_TRACE, "out UnBindFromDSObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadDSObjSecDesc
//
//  Synopsis:   Reads the security descriptor from the specied object via
//              the open ldap connection
//
//  Arguments:  [IN  pLDAP]         --  The open LDAP connection
//              [IN  SeInfo]        --  Parts of the security descriptor to
//                                      read.
//              [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [OUT ppSD]          --  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
DWORD
ReadDSObjSecDesc(IN  PLDAP                  pLDAP,
                 IN  PWSTR                  pwszObject,
                 IN  SECURITY_INFORMATION   SeInfo,
                 OUT PSECURITY_DESCRIPTOR  *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PLDAPMessage    pMessage = NULL;
    PWSTR           rgAttribs[2];
    BYTE            berValue[8];

    //
    // JohnsonA The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    rgAttribs[0] = ACTRL_SD_PROP_NAME;
    rgAttribs[1] = NULL;



    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ldap_search_ext_s(pLDAP,
                                  pwszObject,
                                  LDAP_SCOPE_BASE,
                                  L"(objectClass=*)",
                                  rgAttribs,
                                  0,
                                  (PLDAPControl *)&ServerControls,
                                  NULL,
                                  NULL,
                                  10000,
                                  &pMessage);

        dwErr = LdapMapErrorToWin32( dwErr );
    }

    if(dwErr == ERROR_SUCCESS)
    {
        LDAPMessage *pEntry = NULL;
        pEntry = ldap_first_entry(pLDAP,
                                  pMessage);

        if(pEntry == NULL)
        {
            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
        }
        else
        {
            //
            // Now, we'll have to get the values
            //
            PWSTR *ppwszValues = ldap_get_values(pLDAP,
                                                 pEntry,
                                                 rgAttribs[0]);
            if(ppwszValues == NULL)
            {
                if(pLDAP->ld_errno == LDAP_NO_SUCH_ATTRIBUTE)
                {
                    dwErr = ERROR_ACCESS_DENIED;
                }
                else
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }

            }
            else
            {
                PLDAP_BERVAL *pSize = ldap_get_values_len(pLDAP,
                                                          pMessage,
                                                          rgAttribs[0]);
                if(pSize == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    //
                    // Allocate the security descriptor to return
                    //
                    *ppSD = (PSECURITY_DESCRIPTOR)AccAlloc((*pSize)->bv_len);
                    if(*ppSD == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        memcpy(*ppSD,
                               (PBYTE)(*pSize)->bv_val,
                               (*pSize)->bv_len);
                    }
                    ldap_value_free_len(pSize);
                }

                ldap_value_free(ppwszValues);
            }
        }

        ldap_msgfree(pMessage);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetSDForDSObj
//
//  Synopsis:   Gets a security descriptor from a DS object
//
//  Arguments:  [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [OUT ppSD]          --  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_PARAMETER The object name that was given was in
//                                      a bad format (not \\x\y)
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
DWORD
GetSDForDSObj(IN  LPWSTR                pwszDSObj,
              IN  SECURITY_INFORMATION  SeInfo,
              OUT PSECURITY_DESCRIPTOR *ppSD)
{
    acDebugOut((DEB_TRACE, "in GetSDForDSObj\n"));
    DWORD dwErr = ERROR_SUCCESS;
    PWSTR pwszServer = NULL, pwszPath = NULL;

    dwErr = DspSplitPath(pwszDSObj,
                         &pwszServer,
                         &pwszPath);

    if(dwErr == ERROR_SUCCESS)
    {

        //
        // Convert the name into attributed format
        //
        PDS_NAME_RESULTW   pNameRes;

        dwErr = DspBindAndCrack( pwszServer, pwszPath, 0, &pNameRes );

        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                //
                // Now, we'll bind to the object, and then do the read
                //
                PLDAP   pLDAP;

                dwErr = BindToDSObject(pwszServer,
                                       pNameRes->rItems[0].pDomain,
                                       &pLDAP);

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Now, we'll do the read...
                    //
                    dwErr = ReadDSObjSecDesc(pLDAP,
                                             pNameRes->rItems[0].pName,
                                             SeInfo,
                                             ppSD);
                    UnBindFromDSObject(&pLDAP);
                }
            }
            DsFreeNameResultW(pNameRes);
        }

        AccFree(pwszServer);
    }

    acDebugOut((DEB_TRACE, "Out GetSDForDSObj: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadDSObjPropertyRights
//
//  Synopsis:   Reads the specified property rights from the named DS object
//
//  Arguments:  [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [IN  pRightsList]   --  The rights information to get
//              [IN  cRights]       --  Number of items in the rights list
//              [IN  AccessList]    --  The access list to initialize
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_INVALID_PARAMETER A NULL parameter was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReadDSObjPropertyRights(IN  LPWSTR               pwszDSObj,
                        IN  PACTRL_RIGHTS_INFO   pRightsList,
                        IN  ULONG                cRights,
                        IN  CAccessList&         AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadDSObjPropertyRights\n"));
    DWORD dwErr = ERROR_SUCCESS;

    if(pwszDSObj == NULL || pRightsList == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Build the security info structure we will need
        //
        SECURITY_INFORMATION SeInfo = 0;

        for(ULONG i = 0; i < cRights; i++)
        {
            SeInfo |= pRightsList[i].SeInfo;
        }

        PSECURITY_DESCRIPTOR    pSD;
        dwErr = GetSDForDSObj(pwszDSObj,
                              SeInfo,
                              &pSD);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, we'll simply add the appropriate property based entries
            // to our access list.
            //
            for(ULONG iIndex = 0;
                iIndex < cRights && dwErr == ERROR_SUCCESS;
                iIndex++)
            {
                dwErr = AccessList.AddSD(pSD,
                                         pRightsList[iIndex].SeInfo,
                                         pRightsList[iIndex].pwszProperty,
                                         FALSE);

            }
            AccFree(pSD);
        }

    }

    acDebugOut((DEB_TRACE, "out ReadDSObjPropertyRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadAllDSObjPropertyRights
//
//  Synopsis:   Reads the all the property rights from the named DS object
//
//  Arguments:  [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [IN  pRightsList]   --  The rights information to get
//              [IN  cRights]       --  Number of items in the rights list
//              [IN  AccessList]    --  The access list to initialize
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_INVALID_PARAMETER A NULL parameter was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReadAllDSObjPropertyRights(IN  LPWSTR               pwszDSObj,
                           IN  PACTRL_RIGHTS_INFO   pRightsList,
                           IN  ULONG                cRights,
                           IN  CAccessList&         AccessList)
{
    DWORD dwErr = ERROR_SUCCESS;

    if(pwszDSObj == NULL || pRightsList == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Build the security info structure we will need
        //
        SECURITY_INFORMATION SeInfo = 0;

        for(ULONG i = 0; i < cRights; i++)
        {
            SeInfo |= pRightsList[i].SeInfo;
        }

        PSECURITY_DESCRIPTOR    pSD;
        dwErr = GetSDForDSObj(pwszDSObj,
                              SeInfo,
                              &pSD);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, we'll simply add it to our access list.  We'll ignore
            // any rights info after the first one.
            //
            dwErr = AccessList.AddSD(pSD,
                                     pRightsList[0].SeInfo,
                                     NULL,
                                     TRUE);
            AccFree(pSD);
        }

    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDSObjSecurityInfo
//
//  Synopsis:   Sets the security descriptor on the DS object
//
//  Arguments:  [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [IN  SeInfo]        --  Security Infofor the security
//                                      descriptor
//              [IN  pwszProperty]  --  Object property to set the access on
//              [IN  pSD]           --  Security descriptor to set
//              [IN  cSDSize]       --  Size of the security descriptor
//              [IN  pfStopFlag]    --  The stop flag to monitor
//              [IN  pcProcessed]   --  Where to increment the count of
//                                      processsed items
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_INVALID_PARAMETER A NULL parameter was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SetDSObjSecurityInfo(IN  LPWSTR                  pwszDSObj,
                     IN  SECURITY_INFORMATION    SeInfo,
                     IN  PWSTR                   pwszProperty,
                     IN  PSECURITY_DESCRIPTOR    pSD,
                     IN  ULONG                   cSDSize,
                     IN  PULONG                  pfStopFlag,
                     IN  PULONG                  pcProcessed)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWSTR pwszServer = NULL, pwszPath = NULL;

    dwErr = DspSplitPath(pwszDSObj,
                         &pwszServer,
                         &pwszPath);

    if(dwErr == ERROR_SUCCESS)
    {


        //
        // Convert the name into attributed format
        //
        PDS_NAME_RESULTW pNameRes;

        dwErr = DspBindAndCrack( pwszServer, pwszPath, 0, &pNameRes );

        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                //
                // Convert our name to ascii
                //
                PLDAP   pLDAP;

                dwErr = BindToDSObject(pwszServer,
                                       pNameRes->rItems[0].pDomain,
                                       &pLDAP);

                if(dwErr == ERROR_SUCCESS)
                {
#ifdef NO_PROPAGATE
                    dwErr = StampSD(pNameRes->rItems[0].pName,
                                    cSDSize,
                                    SeInfo,
                                    pSD,
                                    pLDAP);
#else
                    dwErr = PropagateDSRightsDeep(NULL,
                                                  pSD,
                                                  SeInfo,
                                                  pNameRes->rItems[0].pName,
                                                  pLDAP,
                                                  pcProcessed,
                                                  pfStopFlag);
#endif
                    UnBindFromDSObject(&pLDAP);
                }

            }

            DsFreeNameResultW(pNameRes);
        }

        AccFree(pwszServer);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   PingDSObj
//
//  Synopsis:   "Pings" the specified DS object, to determine if it is
//              reachable or not
//
//  Arguments:  [IN  pObjectName]   --  The name of the object
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_PATH_NOT_FOUND--  The object was not reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
PingDSObj(IN LPCWSTR  pwszDSObj)
{
    acDebugOut((DEB_TRACE, "in PingDSObj\n"));
    DWORD dwErr;

    PWSTR pwszServer = NULL, pwszPath = NULL;

    dwErr = DspSplitPath((PWSTR)pwszDSObj,
                         &pwszServer,
                         &pwszPath);

    if(dwErr == ERROR_SUCCESS)
    {

        //
        // Convert the name into attributed format
        //
        PDS_NAME_RESULTW   pNameRes;
        dwErr = DspBindAndCrack(pwszServer, pwszPath, 0, &pNameRes);
        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                //
                // Now, we'll bind to the object, and then do the read
                //
                PLDAP   pLDAP;

                dwErr = BindToDSObject(pwszServer,
                                       pNameRes->rItems[0].pDomain,
                                       &pLDAP);

                if(dwErr == ERROR_SUCCESS)
                {
                    PLDAPMessage    pMessage = NULL;
                    PWSTR           rgAttribs[2];

                    rgAttribs[0] = L"distinguishedName";
                    rgAttribs[1] = NULL;


                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = ldap_search_s(pLDAP,
                                              pwszPath,
                                              LDAP_SCOPE_BASE,
                                              L"(objectClass=*)",
                                              rgAttribs,
                                              0,
                                              &pMessage);

                        dwErr = LdapMapErrorToWin32( dwErr );
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        LDAPMessage *pEntry = NULL;
                        pEntry = ldap_first_entry(pLDAP,
                                                  pMessage);

                        if(pEntry == NULL)
                        {
                            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                        }
                        else
                        {
                            //
                            // Now, we'll have to get the values
                            //
                            PWSTR *ppwszValues = ldap_get_values(pLDAP,
                                                                 pEntry,
                                                                 rgAttribs[0]);
                            if(ppwszValues == NULL)
                            {

                                if(pLDAP->ld_errno == LDAP_NO_SUCH_ATTRIBUTE )
                                {

                                    dwErr =  ERROR_SUCCESS;
                                }
                                else
                                {
                                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                                }
                            }
                            else
                            {
                                ldap_value_free(ppwszValues);
                            }
                        }

                        ldap_msgfree(pMessage);
                    }
                }
            }
            DsFreeNameResultW(pNameRes);
        }

        AccFree(pwszServer);
    }
    acDebugOut((DEB_TRACE, "out PingDSObj: %lu\n", dwErr));
    return(dwErr);
}




DWORD
Nt4NameToNt5Name(IN  PWSTR      pwszName,
                 IN  PWSTR      pwszDomain,
                 OUT PWSTR     *ppwszNt5Name)
{
    DWORD   dwErr = ERROR_SUCCESS;

    WCHAR   wszFullName[MAX_PATH + 1];
    LPWSTR  pwszFullName;

    ULONG   cLen = wcslen(pwszName) + 1;

    if(pwszDomain != NULL)
    {
        cLen += wcslen(pwszDomain) + 1;
    }

    if(cLen < MAX_PATH + 1)
    {
        pwszFullName = wszFullName;
    }
    else
    {
        pwszFullName = (PWSTR)AccAlloc(cLen * sizeof(WCHAR));
        if(pwszFullName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        if(pwszDomain != NULL)
        {
            wcscpy(pwszFullName, pwszDomain);
            wcscat(pwszFullName, L"\\");
        }
        else
        {
            *pwszFullName = L'\0';
        }
        wcscat(pwszFullName, pwszName);

    }

    //
    // Now, for the crack name...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PDS_NAME_RESULTW   pNameRes;

        dwErr = DspBindAndCrack(NULL, wszFullName, 0, &pNameRes );
        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                ACC_ALLOC_AND_COPY_STRINGW(pNameRes->rItems[0].pName,
                                           *ppwszNt5Name,
                                           dwErr);
            }
        }
        else
        {
            if(dwErr == MAPI_E_LOGON_FAILED)
            {
                dwErr = ERROR_LOGON_FAILURE;
            }

        }

        DsFreeNameResultW(pNameRes);
    }


    //
    // See if we need to free our buffer
    //
    if(pwszFullName != wszFullName)
    {
        AccFree(pwszFullName);
    }

    return(dwErr);
}




#define CLEANUP_ON_INTERRUPT(pstopflag)                                     \
if(*pstopflag != 0)                                                         \
{                                                                           \
    goto DSCleanup;                                                         \
}
//+---------------------------------------------------------------------------
//
//  Function:   PropagateDSRightsDeep, recursive
//
//  Synopsis:   Does a deep propagation of the access.
//
//  Arguments:  [IN  pParentSD]         --      The current parent sd
//              [IN  SeInfo]            --      What is being written
//              [IN  pwszFile]          --      Parent file path
//              [IN  pcProcessed]       --      Where the number processed is
//                                              returned.
//              [IN  pfStopFlag]        --      Stop flag to monitor
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
PropagateDSRightsDeep(IN  PSECURITY_DESCRIPTOR    pParentSD,
                      IN  PSECURITY_DESCRIPTOR    pChildSD,
                      IN  SECURITY_INFORMATION    SeInfo,
                      IN  PWSTR                   pwszDSObject,
                      IN  PLDAP                   pLDAP,
                      IN  PULONG                  pcProcessed,
                      IN  PULONG                  pfStopFlag)
{
    acDebugOut((DEB_TRACE, "in PropagateDSRightsDeep\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fFreeChildSD = FALSE;


    acDebugOut((DEB_TRACE_PROP, "Processing %ws\n", pwszDSObject));

    //
    // If our security descriptor is already in DS form, then we'll have
    // to adjust for that
    //
    if(pChildSD != NULL)
    {
        PULONG pSE = (PULONG)(pChildSD);
        if(*pSE == SeInfo)
        {
            pChildSD = (PSECURITY_DESCRIPTOR)((PBYTE)pChildSD + sizeof(ULONG));
        }
    }
    else
    {
        dwErr = ReadDSObjSecDesc(pLDAP,
                                 pwszDSObject,
                                 SeInfo,
                                 &pChildSD);
        if(dwErr == ERROR_SUCCESS)
        {
            fFreeChildSD = TRUE;
        }
        else
        {
            return(dwErr);
        }
    }

    //
    // Ok, we'll convert our path to a narrow string, and then we'll enumerate
    // all of the children
    //
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    PLDAPMessage            pMessage = NULL;

    //
    // First, we'll create the new SD...
    //
    HANDLE                  hProcessToken = NULL;
    GENERIC_MAPPING GenMap;
    GenMap.GenericRead    = GENERIC_READ_MAPPING;
    GenMap.GenericWrite   = GENERIC_WRITE_MAPPING;
    GenMap.GenericExecute = GENERIC_EXECUTE_MAPPING;
    GenMap.GenericAll     = GENERIC_ALL_MAPPING;

    dwErr = GetCurrentToken( &hProcessToken );
    if(dwErr == ERROR_SUCCESS)
    {
#ifdef DBG
        DebugDumpSD("CPOSE ParentSD", pParentSD);
        DebugDumpSD("CPOSE ChildSD",  pChildSD);
#endif
        if(CreatePrivateObjectSecurityEx(pParentSD,
                                         pChildSD,
                                         &pNewSD,
                                         NULL,
                                         TRUE,
                                         SEF_DACL_AUTO_INHERIT |
                                            SEF_SACL_AUTO_INHERIT,
                                         hProcessToken,
                                         &GenMap) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
#ifdef DBG
            DebugDumpSD("CPOSE NewSD", pNewSD);
#endif
            //
            // Stamp the SD on the object...  This means that we'll have
            // to allocate a new security descriptor that is 4 bytes
            // bigger than what we need, and set our SeInfo
            //
            PSECURITY_DESCRIPTOR    pSetSD = NULL;
            ULONG cNewSDSize = 0;

            if(RtlpAreControlBitsSet((PISECURITY_DESCRIPTOR)pChildSD,
                                     SE_SELF_RELATIVE))
            {
                cNewSDSize = RtlLengthSecurityDescriptor(pNewSD);
                ASSERT(cNewSDSize != 0);
            }
            else
            {
                MakeSelfRelativeSD(pNewSD,
                                   NULL,
                                   &cNewSDSize);
                ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);
            }

            cNewSDSize += sizeof(ULONG);

            pSetSD = (PSECURITY_DESCRIPTOR)AccAlloc(cNewSDSize);
            if(pSetSD == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                pSetSD = (PSECURITY_DESCRIPTOR)
                               ((PBYTE)pSetSD + sizeof(ULONG));

                if(RtlpAreControlBitsSet((PISECURITY_DESCRIPTOR)pChildSD,
                                         SE_SELF_RELATIVE))
                {
                    memcpy(pSetSD, pNewSD, cNewSDSize - sizeof(ULONG));
                }
                else
                {
                    if(MakeSelfRelativeSD(pNewSD,
                                          pSetSD,
                                          &cNewSDSize) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }


                PULONG pSE = (PULONG)((PBYTE)pSetSD - sizeof(ULONG));
                *pSE = SeInfo;

                //
                // We need to pass in the security_information
                //
                pSetSD = (PSECURITY_DESCRIPTOR)pSE;


                //
                // Now, do the write
                //
                dwErr = StampSD(pwszDSObject,
                                cNewSDSize,
                                SeInfo,
                                pSetSD,
                                pLDAP);
                AccFree(pSetSD);
            }
        }
    }


    CLEANUP_ON_INTERRUPT(pfStopFlag);
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR            rgAttribs[2];
        WCHAR            wszAttrib[]=L"distinguishedName";

        //
        // Do the search...
        //
        rgAttribs[0] = wszAttrib;
        rgAttribs[1] = NULL;


        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ldap_search_s(pLDAP,
                                  pwszDSObject,
                                  LDAP_SCOPE_ONELEVEL,
                                  L"(objectClass=*)",
                                  rgAttribs,
                                  0,
                                  &pMessage);

            dwErr = LdapMapErrorToWin32( dwErr );
        }

        if(dwErr == ERROR_SUCCESS)
        {

            ULONG   cChildren = ldap_count_entries(pLDAP,
                                                   pMessage);
            acDebugOut((DEB_TRACE_PROP,
                        "%ws has %lu children\n",
                        pwszDSObject, cChildren));

            LDAPMessage *pEntry = ldap_first_entry(pLDAP,
                                                   pMessage);
            for(ULONG i = 0; i < cChildren; i++)
            {
                if(pEntry == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                    break;
                }

                //
                // Now, we'll have to get the values
                //
                CLEANUP_ON_INTERRUPT(pfStopFlag);
                PWSTR  *ppwszValues = ldap_get_values(pLDAP,
                                                      pEntry,
                                                      rgAttribs[0]);

                if(ppwszValues == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    //
                    // Go ahead and propagate to the child
                    //
                    acDebugOut((DEB_TRACE_PROP,
                                "Child %ws of %ws [%lu]\n",
                                ppwszValues[0], pwszDSObject, i));

                    dwErr = PropagateDSRightsDeep(pNewSD,
                                                  NULL,
                                                  SeInfo,
                                                  ppwszValues[0],
                                                  pLDAP,
                                                  pcProcessed,
                                                  pfStopFlag);

                    ldap_value_free(ppwszValues);
                    CLEANUP_ON_INTERRUPT(pfStopFlag);
                }

                pEntry = ldap_next_entry(pLDAP,
                                         pEntry);
            }
        }
    }

DSCleanup:
    ldap_msgfree(pMessage);
    DestroyPrivateObjectSecurity(&pNewSD);

    if(fFreeChildSD == TRUE)
    {
        AccFree(pChildSD);
    }

    acDebugOut((DEB_TRACE, "Out PropagateDSRightsDeep: %ld\n", dwErr));
    return(dwErr);

}





//+---------------------------------------------------------------------------
//
//  Function:   StampSD
//
//  Synopsis:   Actually stamps the security descriptor on the object.
//
//  Arguments:  [IN  pwszObject]        --      The object to stamp the SD on
//              [IN  cSDSize]           --      The size of the security descriptor
//              [IN  SeInfo]            --      SecurityInformation about the security
//                                              descriptor
//              [IN  pSD]               --      The SD to stamp
//              [IN  pLDAP]             --      The LDAP connection to use
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
StampSD(IN  PWSTR                pwszObject,
        IN  ULONG                cSDSize,
        IN  SECURITY_INFORMATION SeInfo,
        IN  PSECURITY_DESCRIPTOR pSD,
        IN  PLDAP                pLDAP)
{
    DWORD   dwErr = ERROR_SUCCESS;

    acDebugOut((DEB_TRACE_PROP, "Stamping %ws\n", pwszObject));

    //
    // Now, we'll do the write.  The security descriptor
    // we got passed in better not be in the old Ds  format,
    // where the leading 4 bytes are the SECURITY_INFORMATION, which we'll skip
    // and replace with control information
    //

    ASSERT(*(PULONG)pSD > 0xF );

    PLDAPMod        rgMods[2];
    PLDAP_BERVAL    pBVals[2];
    LDAPMod         Mod;
    LDAP_BERVAL     BVal;
    BYTE            ControlBuffer[ 5 ];

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) &ControlBuffer
                        },
                        TRUE
                    };

    //
    // !!! Hardcoded for now.  Use Andyhe's BER_printf once it's done.
    //

    ControlBuffer[0] = 0x30;
    ControlBuffer[1] = 0x3;
    ControlBuffer[2] = 0x02;    // Denotes an integer;
    ControlBuffer[3] = 0x01;    // Size
    ControlBuffer[4] = (BYTE)((ULONG)SeInfo & 0xF);

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    ASSERT(IsValidSecurityDescriptor( pSD ) );


    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    BVal.bv_len = cSDSize;
    BVal.bv_val = (PCHAR)pSD;

    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = ACTRL_SD_PROP_NAME;
    Mod.mod_values  = (PWSTR *)pBVals;

    //
    // Now, we'll do the write...
    //
    dwErr = ldap_modify_ext_s(pLDAP,
                              pwszObject,
                              rgMods,
                              (PLDAPControl *)&ServerControls,
                              NULL);

    dwErr = LdapMapErrorToWin32(dwErr);

#if DBG
    PACL pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR)pSD);
    ACL_SIZE_INFORMATION        AclSize;
    ACL_REVISION_INFORMATION    AclRev;
    PKNOWN_ACE                  pAce;
    PSID                        pSid;
    DWORD                       iIndex;
    DWORD                       GuidPart;
    DWORD                       OldInfoLevel;

    //
    // Now, dump all of the aces
    //
    if(pAcl)
    {
        pAce = (PKNOWN_ACE)FirstAce(pAcl);
        for(iIndex = 0; iIndex < pAcl->AceCount; iIndex++)
        {
            //
            // If it's an object ace, dump the guids
            //
            if(IsObjectAceType(pAce))
            {
                OldInfoLevel = acInfoLevel;
//                acInfoLevel |= DEB_TRACE_SD;
                DebugDumpGuid("\t\t\tObjectId", RtlObjectAceObjectType(pAce));
                GuidPart = (ULONG)((ULONG_PTR)RtlObjectAceObjectType(pAce));
                ASSERT(GuidPart != 0x2bfff20);
                acInfoLevel = OldInfoLevel;
            }
            pAce = (PKNOWN_ACE)NextAce(pAce);
        }
    }
#endif

    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   AccDsReadSchemaInfo
//
//  Synopsis:   Reads the schema object/property info.
//
//  Arguments:  [IN  pLDAP]                 --      LDAP connection to use
//              [OUT pcClasses]             --      Where the count of class info
//                                                  is returned
//              [OUT pppwszClasses]         --      Where the list of classes info
//                                                  is returned.  Freed with
//                                                  ldap_value_free
//              [OUT pcAttributes]          --      Where the count of property infos
//                                                  is returned
//              [OUT pppwszAttributes]      --      Where the list of property infos
//                                                  is returned.  Freed with
//                                                  ldap_value_free
//
//  Returns:    ERROR_SUCCESS               --      Success
//
//----------------------------------------------------------------------------
DWORD
AccDsReadSchemaInfo (IN  PLDAP          pLDAP,
                     OUT PULONG         pcClasses,
                     OUT PWSTR        **pppwszClasses,
                     OUT PULONG         pcAttributes,
                     OUT PWSTR        **pppwszAttributes)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PWSTR              *ppwszValues = NULL;
    PWSTR               rgwszAttribs[3];
    PDS_NAME_RESULTW    pNameRes = NULL;
    LDAPMessage         *pMessage, *pEntry;

    *pcClasses    = 0;
    *pcAttributes = 0;
    *pppwszAttributes = NULL;
    *pppwszClasses = NULL;

    //
    // Get the subschema path
    //
    if(dwErr == ERROR_SUCCESS)
    {
        rgwszAttribs[0] = L"subschemaSubentry";
        rgwszAttribs[1] = NULL;

        dwErr = ldap_search_s(pLDAP,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgwszAttribs,
                              0,
                              &pMessage);
        if(dwErr == ERROR_SUCCESS)
        {
            pEntry = ldap_first_entry(pLDAP,
                                      pMessage);

            if(pEntry == NULL)
            {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
            else
            {
                //
                // Now, we'll have to get the values
                //
                ppwszValues = ldap_get_values(pLDAP,
                                              pEntry,
                                              rgwszAttribs[0]);
                ldap_msgfree(pMessage);

                if(ppwszValues == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    rgwszAttribs[0] = L"extendedClassInfo";
                    rgwszAttribs[1] = L"extendedAttributeInfo";
                    rgwszAttribs[2] = NULL;

                    dwErr = ldap_search_s(pLDAP,
                                          ppwszValues[0],
                                          LDAP_SCOPE_BASE,
                                          L"(objectClass=*)",
                                          rgwszAttribs,
                                          0,
                                          &pMessage);
                    ldap_value_free(ppwszValues);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        ldap_count_entries( pLDAP, pMessage );
                        pEntry = ldap_first_entry(pLDAP,
                                                  pMessage);

                        if(pEntry == NULL)
                        {
                            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                        }
                        else
                        {
                            //
                            // Now, we'll have to get the values
                            //
                            *pppwszClasses = ldap_get_values(pLDAP,
                                                             pEntry,
                                                             rgwszAttribs[0]);
                            if(*pppwszClasses == NULL)
                            {
                                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                            }
                            else
                            {
                                *pcClasses = ldap_count_values(*pppwszClasses);

                                *pppwszAttributes = ldap_get_values(pLDAP,
                                                                    pEntry,
                                                                    rgwszAttribs[1]);
                                if(*pppwszAttributes == NULL)
                                {
                                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

                                    ldap_value_free(*pppwszClasses);
                                }
                                else
                                {
                                    *pcAttributes =
                                            ldap_count_values(*pppwszAttributes);
                                }
                            }
                        }

                    }
                    else
                    {
                        dwErr = LdapMapErrorToWin32( dwErr );
                    }

                    ldap_msgfree(pMessage);
                }
            }

        }
        else
        {
            dwErr = LdapMapErrorToWin32( dwErr );
        }

    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccDsReadExtendedRights
//
//  Synopsis:   Reads the list of extended rights from the schema
//
//  Arguments:  [IN  pLDAP]                 --      LDAP connection to use
//              [OUT pcItems]               --      Where the count of items
//                                                  is returned
//              [OUT ppwszNames]            --      Where the list of Names is
//                                                  returned.
//              [OUT ppwszGuids]            --      Where the list of guids is
//                                                  returned.
//
//  Notes:      Freed via AccDsFreeExtendedRights
//
//  Returns:    ERROR_SUCCESS               --      Success
//
//----------------------------------------------------------------------------
DWORD
AccDsReadExtendedRights(IN PLDAP        pLDAP,
                        OUT PULONG      pcItems,
                        OUT PWSTR     **pppwszNames,
                        OUT PWSTR     **pppwszGuids)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PWSTR              *ppwszValues = NULL;
    PWSTR               rgwszAttribs[3];
    PWSTR               pwszERContainer = NULL;
    PDS_NAME_RESULTW    pNameRes = NULL;
    LDAPMessage         *pMessage, *pEntry;
    ULONG               cEntries = 0, i;

    *pcItems = 0;
    *pppwszNames = NULL;
    *pppwszGuids = NULL;

    //
    // Get the subschema path
    //
    if(dwErr == ERROR_SUCCESS)
    {
        rgwszAttribs[0] = L"configurationNamingContext";
        rgwszAttribs[1] = NULL;

        dwErr = ldap_search_s(pLDAP,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgwszAttribs,
                              0,
                              &pMessage);
        if(dwErr == ERROR_SUCCESS)
        {
            pEntry = ldap_first_entry(pLDAP,
                                      pMessage);

            if(pEntry == NULL)
            {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
            else
            {
                //
                // Now, we'll have to get the values
                //
                ppwszValues = ldap_get_values(pLDAP,
                                              pEntry,
                                              rgwszAttribs[0]);
                ldap_msgfree(pMessage);

                if(ppwszValues == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    pwszERContainer = (PWSTR)AccAlloc((wcslen(ppwszValues[0]) * sizeof(WCHAR)) +
                                                      sizeof(ACTRL_EXT_RIGHTS_CONTAINER));
                    if(pwszERContainer == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        wcscpy(pwszERContainer,
                               ACTRL_EXT_RIGHTS_CONTAINER);
                        wcscat(pwszERContainer,
                               ppwszValues[0]);


                        rgwszAttribs[0] = L"displayName";
                        rgwszAttribs[1] = L"rightsGuid";
                        rgwszAttribs[2] = NULL;

                        //
                        // Read the control access rights
                        //
                        dwErr = ldap_search_s(pLDAP,
                                              pwszERContainer,
                                              LDAP_SCOPE_ONELEVEL,
                                              L"(objectClass=controlAccessRight)",
                                              rgwszAttribs,
                                              0,
                                              &pMessage);

                        dwErr = LdapMapErrorToWin32( dwErr );

                        AccFree(pwszERContainer);
                    }
                    ldap_value_free(ppwszValues);


                    if(dwErr == ERROR_SUCCESS)
                    {
                        cEntries = ldap_count_entries( pLDAP, pMessage );

                        *pppwszNames = (PWSTR *)AccAlloc( sizeof( PWSTR ) * cEntries );

                        if(*pppwszNames == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            *pppwszGuids = (PWSTR *)AccAlloc( sizeof( PWSTR ) * cEntries );

                            if(*pppwszGuids == NULL)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                                AccFree(*pppwszNames);
                                *pppwszNames = NULL;
                            }
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            pEntry = ldap_first_entry(pLDAP,
                                                      pMessage);

                            if(pEntry == NULL)
                            {
                                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                            }
                            else
                            {
                                for(i = 0; i < cEntries && dwErr == ERROR_SUCCESS; i++) {
                                    ppwszValues = ldap_get_values(pLDAP,
                                                                  pEntry,
                                                                  rgwszAttribs[0]);
                                    if(ppwszValues == NULL)
                                    {
                                        dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                                    }
                                    else
                                    {
                                        //
                                        // Now, we'll have to get the values
                                        //
                                        ACC_ALLOC_AND_COPY_STRINGW(ppwszValues[0],
                                                                   (*pppwszNames)[i],
                                                                   dwErr);

                                        ldap_value_free(ppwszValues);

                                        if(dwErr == ERROR_SUCCESS)
                                        {
                                            ppwszValues = ldap_get_values(pLDAP,
                                                                          pEntry,
                                                                          rgwszAttribs[1]);
                                            if(ppwszValues == NULL)
                                            {
                                                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

                                            }
                                            else
                                            {
                                                ACC_ALLOC_AND_COPY_STRINGW(ppwszValues[0],
                                                                           (*pppwszGuids)[i],
                                                                           dwErr);
                                                ldap_value_free(ppwszValues);
                                            }
                                        }
                                    }

                                    pEntry = ldap_next_entry( pLDAP, pEntry );
                                }

                                if(dwErr != ERROR_SUCCESS)
                                {
                                    AccDsFreeExtendedRights(i,
                                                            *pppwszNames,
                                                            *pppwszGuids);
                                }
                            }
                        }

                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        *pcItems = cEntries;
                    }

                    ldap_msgfree(pMessage);
                }
            }

        }
        else
        {
            dwErr = LdapMapErrorToWin32( dwErr );
        }

    }

    return(dwErr) ;
}




VOID
AccDsFreeExtendedRights(IN ULONG      cItems,
                        IN PWSTR     *ppwszNames,
                        IN PWSTR     *ppwszGuids)
{
    ULONG i;

    for(i = 0;i < cItems;i++ )
    {
        AccFree( ppwszNames[ i ]);
        AccFree( ppwszGuids[ i ]);
    }

    AccFree(ppwszNames);
    AccFree(ppwszGuids);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\file.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       file.cxx
//
//  Contents:   Local file support functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <ntprov.hxx>
#include <alsup.hxx>
#include <martaevt.h>

extern "C"
{
    #include <lmdfs.h>
    #include <stdio.h>
    #include <seopaque.h>
    #include <sertlp.h>
}

#define LMRDR   L"\\Device\\LanmanRedirector"
#define WINDFS  L"\\Device\\WinDfs"

GENERIC_MAPPING gFileGenMap = {FILE_GENERIC_READ,
                              FILE_GENERIC_WRITE,
                              FILE_GENERIC_EXECUTE,
                              FILE_ALL_ACCESS};

//+---------------------------------------------------------------------------
//
//  Function:   ConvertFileHandleToName
//
//  Synopsis:   Determines the file name for a handle.  Issues an
//              NtQueryInformationFile to determine the file name
//
//  Arguments:  [IN hFile]              --      The (open) handle of the file
//                                              object
//              [OUT ppwszName]         --      Where the name is returned
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//  Notes:      The returned memory must be freed with AccFree
//
//----------------------------------------------------------------------------
DWORD
ConvertFileHandleToName(IN  HANDLE      hFile,
                        OUT PWSTR      *ppwszName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP

    //
    // First, determine the size of the buffer we need...
    //
    HANDLE      hRootDir = NULL;
    BYTE        pBuff[512];
    ULONG       cLen = 0;
    POBJECT_NAME_INFORMATION pNI = NULL;
    PWSTR       pwszPath = NULL;
    NTSTATUS    Status = NtQueryObject(hFile,
                                       ObjectNameInformation,
                                       (POBJECT_NAME_INFORMATION)pBuff,
                                       512,
                                       &cLen);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL ||
            Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            //
            // Fine.. Allocate a big enough buffer
            //
            pNI = (POBJECT_NAME_INFORMATION)AccAlloc(cLen);
            if(pNI != NULL)
            {
                Status = NtQueryObject(hFile,
                                       ObjectNameInformation,
                                       pNI,
                                       cLen,
                                       NULL);
                if(NT_SUCCESS(Status))
                {
                    pwszPath = pNI->Name.Buffer;

                    acDebugOut((DEB_TRACE_HANDLE, "Path for handle 0x%lx: %ws\n",
                                hFile, pwszPath));
                }
                AccFree(pNI);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }

        dwErr = RtlNtStatusToDosError(Status);

        if(dwErr == ERROR_SUCCESS && pwszPath == NULL)
        {
            dwErr = ERROR_INVALID_HANDLE;
        }

        if (dwErr != ERROR_SUCCESS)
        {
            acDebugOut(( DEB_ERROR,
                         "Failed to get path for handle 0x%lx: %lu\n",
                         hFile, dwErr ));

            ASSERT( dwErr == ERROR_SUCCESS );

        }

    }
    else
    {
        pwszPath =((POBJECT_NAME_INFORMATION)pBuff)->Name.Buffer;
        acDebugOut((DEB_TRACE_HANDLE, "Path for handle 0x%lx: %ws\n", hFile, pwszPath));
    }

    if(dwErr == ERROR_SUCCESS &&
       _wcsnicmp(pwszPath,
                 LMRDR,
                 sizeof(LMRDR) / sizeof(WCHAR) - 1) == 0)
    {
        *ppwszName = (PWSTR)AccAlloc(sizeof(WCHAR) *
              (wcslen(pwszPath + ((sizeof(LMRDR) - 1) / sizeof(WCHAR))) + 2));
        if(*ppwszName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            swprintf(*ppwszName,
                     L"\\%ws",
                     pwszPath + (sizeof(LMRDR) / sizeof(WCHAR) - 1));
        }

        acDebugOut((DEB_TRACE_HANDLE, "returning path %ws as LM Rdr path\n",
                    *ppwszName ));


        return(dwErr);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_ERROR,
                    "ConvertFileHandleToPath on 0x%lx failed with %lu\n",
                    hFile,
                    dwErr));
        return(dwErr);
    }

    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   Attributes;
    UCHAR               Buffer[1024];
    BOOL                fFound = FALSE;
    ULONG               Context = 0;
    POBJECT_DIRECTORY_INFORMATION DirInfo = NULL;
    //
    // Get a handle to the directory and iterate through that directory
    // to find the object name.
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\??");

    InitializeObjectAttributes(&Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenDirectoryObject(&hRootDir,
                                   DIRECTORY_QUERY,
                                   &Attributes);

    if (!NT_SUCCESS(Status))
    {
        return(RtlNtStatusToDosError(Status));
    }

    //
    // Get the entries in batches that will fit in a buffer of size
    // BUFFERSIZE until we find the entry that we want
    //
    while (NT_SUCCESS(Status) && !fFound )
    {
        RtlZeroMemory(Buffer,
                      1024);

        Status = NtQueryDirectoryObject(hRootDir,
                                        (PVOID)&Buffer,
                                        1024,
                                        FALSE,
                                        FALSE,
                                        &Context,
                                        NULL);
        if(NT_SUCCESS(Status))
        {
            //
            // Keep looking until we've examined all the entries in this
            // batch or we find what we're looking for.
            //
            DirInfo = (POBJECT_DIRECTORY_INFORMATION)&Buffer[0];
            while(!fFound && DirInfo->Name.Length != 0)
            {
                HANDLE LinkHandle;
                UNICODE_STRING LinkTarget;

                ASSERT( DirInfo != NULL );
                ASSERT( DirInfo->Name.Length != 0 );
                ASSERT( DirInfo->TypeName.Length != 0 );

                acDebugOut((DEB_TRACE_HANDLE, "Checking dir entry %wZ\n",
                            &DirInfo->Name));


                RtlInitUnicodeString(&UnicodeString,
                                     DirInfo->Name.Buffer);
                InitializeObjectAttributes(&Attributes,
                                           &UnicodeString,
                                           OBJ_CASE_INSENSITIVE,
                                           hRootDir,
                                           NULL);
                Status = NtOpenSymbolicLinkObject(&LinkHandle,
                                                  SYMBOLIC_LINK_QUERY,
                                                  &Attributes);
                if(NT_SUCCESS(Status))
                {
                    WCHAR LinkTargetBuffer[1024];
                    memset(LinkTargetBuffer,0,1024 * sizeof(WCHAR));
                    LinkTarget.Buffer = LinkTargetBuffer;
                    LinkTarget.Length = 0;
                    LinkTarget.MaximumLength = sizeof(LinkTargetBuffer);
                    Status = NtQuerySymbolicLinkObject(LinkHandle,
                                                       &LinkTarget,
                                                       NULL);
                    if(NT_SUCCESS(Status))
                    {
                        acDebugOut((DEB_TRACE_HANDLE, "Symbolic link for %wZ: %wZ\n",
                                    &DirInfo->Name, &LinkTarget));

                        if(_wcsnicmp(pwszPath,
                                     LinkTargetBuffer,
                                     LinkTarget.Length / sizeof(WCHAR)) == 0 &&
                            IS_FILE_PATH( DirInfo->Name.Buffer,
                                          DirInfo->Name.Length / sizeof(WCHAR) ) )
                        {
                            fFound = TRUE;
                            *ppwszName = (PWSTR)AccAlloc((wcslen(DirInfo->Name.Buffer) +
                                                         wcslen(pwszPath + (LinkTarget.Length / sizeof(WCHAR))) +
                                                         1) * sizeof(WCHAR));
                            if(*ppwszName == NULL)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                            }
                            else
                            {
                                swprintf(*ppwszName,
                                         L"%ws%ws",
                                         DirInfo->Name.Buffer,
                                         pwszPath + (LinkTarget.Length / sizeof(WCHAR)));

                                acDebugOut((DEB_TRACE_HANDLE, "Returning path %ws\n", *ppwszName ));

                            }
                        }
                    }
                    NtClose(LinkHandle);
                }

                DirInfo++;
            }
        }
    }

    if (!fFound)
    {
        if(Status !=  STATUS_NO_MORE_ENTRIES)
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
        else
        {
            dwErr = ERROR_RESOURCE_NAME_NOT_FOUND;
        }
    }

    if(hRootDir != NULL)
    {
        NtClose(hRootDir);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadFileSD
//
//  Synopsis:   Reads the file descriptor off of the given file handle
//
//  Arguments:  [IN hFile]              --      The (open) handle of the file
//                                              object
//              [IN  SeInfo]            --      The security information to
//                                              read
//              [IN  cKnownSize]        --      If non-0, this is the size
//                                              of the buffer to allocate
//                                              for the SD.  If 0, the buffer
//                                              size is determined
//              [OUT ppSD]              --      Where the security descriptor
//                                               is returned
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//  Notes:      The returned memory must be freed with AccFree
//
//----------------------------------------------------------------------------
DWORD
ReadFileSD(IN  HANDLE                   hFile,
           IN  SECURITY_INFORMATION     SeInfo,
           IN  ULONG                    cKnownSize,
           OUT PSECURITY_DESCRIPTOR    *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP


    NTSTATUS Status;
    ULONG   cNeeded;

    //
    // If we don't know the size of the object, go ahead and determine it
    //
    if(cKnownSize == 0)
    {
        Status = NtQuerySecurityObject(hFile,
                                       SeInfo,
                                       *ppSD,
                                       0,
                                       &cNeeded);
        if(!NT_SUCCESS(Status))
        {
            if(Status == STATUS_BUFFER_TOO_SMALL)
            {
                cKnownSize = cNeeded;
                Status = STATUS_SUCCESS;
            }
        }

        dwErr = RtlNtStatusToDosError(Status);
    }

    //
    // Now, the actual read
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppSD = (PISECURITY_DESCRIPTOR)AccAlloc(cKnownSize);
        if(*ppSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            Status = NtQuerySecurityObject(hFile,
                                           SeInfo,
                                           *ppSD,
                                           cKnownSize,
                                           &cNeeded);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   IsFileContainer
//
//  Synopsis:   Determines if the file is a container (directory)
//
//  Arguments:  [IN Handle]             --      the (open) handle of the file
//                                              object
//              [OUT pfIsContainer]     --      flag indicating if the object
//                                              is a container
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//
//----------------------------------------------------------------------------
DWORD
IsFileContainer(HANDLE          Handle,
                PBOOL           pfIsContainer)
{
    NTSTATUS        ntstatus;
    IO_STATUS_BLOCK iosb;
    FILE_BASIC_INFORMATION basicfileinfo;
    *pfIsContainer = FALSE;

    //
    // call NtQueryInformationFile to get basic file information
    //
    if (NT_SUCCESS(ntstatus = NtQueryInformationFile(Handle,
                                               &iosb,
                                               &basicfileinfo,
                                               sizeof(FILE_BASIC_INFORMATION),
                                               FileBasicInformation)))
    {
        *pfIsContainer =
                (basicfileinfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)   ?
                                                                    TRUE    :
                                                                    FALSE;
        return(ERROR_SUCCESS);
    }
    else
    {
        return(RtlNtStatusToDosError(ntstatus));
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   IsFilePathLocalOrLM
//
//  Synopsis:   Determines if the path is that of a local object or a remote
//              (network) object
//
//  Arguments:  [IN pwszFile]           --      The file to check
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//              ERROR_PATH_NOT_FOUND    --      No such path exists
//
//----------------------------------------------------------------------------
DWORD
IsFilePathLocalOrLM(IN  LPWSTR      pwszFile)
{
    DWORD       dwErr = ERROR_SUCCESS;
    BOOL        fIsDfs = FALSE;
    NTSTATUS    Status;

    if (pwszFile && wcsncmp(pwszFile, L"\\\\?\\", 4) == 0)
    {
        pwszFile += 4;
    }

    //
    // First, try the simply case of it not being accessible...
    //
    if(GetFileAttributes(pwszFile) == 0xFFFFFFFF)
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_PATH_NOT_FOUND || dwErr == ERROR_FILE_NOT_FOUND)
        {
            return(ERROR_PATH_NOT_FOUND);
        }
    }

    //
    // Otherwise, we need to find out whether it's a path that only we have
    // access to or not
    //

#if 0
    // for some reason, the full path name built is never used - waste time
    // First, we'll see if it's a relative path.  If so, we'll have to
    // build a full path...
    //
    PWSTR   pwszFullPath = pwszFile;
    DWORD   dwSize;
    if(wcslen(pwszFile) < 2 || (pwszFile[1] != L':' && pwszFile[1] != L'\\'))
    {
        //
        // It's a relative path...
        //
        dwSize = GetFullPathName(pwszFile,
                                 0,
                                 NULL,
                                 NULL);
        if(dwSize == 0)
        {
            dwErr = GetLastError();
        }
        else
        {
            pwszFullPath = (PWSTR)AccAlloc((dwSize + 1) * sizeof(WCHAR));
            if(pwszFullPath == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                PWSTR   pwszFilePart;
                if(GetFullPathName(pwszFile,
                                   dwSize,
                                   pwszFullPath,
                                   &pwszFilePart) == 0)
                {
                    dwErr = GetLastError();
                }
            }
        }
    }
#endif

    if(pwszFile[1] == L':')
    {
        if(GetDriveType(pwszFile) == DRIVE_REMOTE)
        {
            //
            // Have to figure out what it is...
            //
            #define BUFFERSIZE  1024

            HANDLE              hRootDir;
            UNICODE_STRING      ObjDir;
            OBJECT_ATTRIBUTES   Attributes;
            UCHAR               Buffer[BUFFERSIZE];
            ULONG               Context = 0;
            POBJECT_DIRECTORY_INFORMATION pDirInfo = NULL;

            RtlInitUnicodeString(&ObjDir,
                                 L"\\??");

            InitializeObjectAttributes(&Attributes,
                                       &ObjDir,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Status = NtOpenDirectoryObject(&hRootDir,
                                           DIRECTORY_QUERY,
                                           &Attributes);

            //
            // Get the entries in batches that will fit in a buffer of size
            // BUFFERSIZE until we find the entry that we want
            //
            BOOL    fFound = FALSE;
            while (NT_SUCCESS(Status) && !fFound )
            {
                RtlZeroMemory(Buffer,
                              BUFFERSIZE);

                Status = NtQueryDirectoryObject(hRootDir,
                                                (PVOID)&Buffer,
                                                BUFFERSIZE,
                                                FALSE,
                                                FALSE,
                                                &Context,
                                                NULL);
                if(NT_SUCCESS(Status))
                {
                    //
                    // Keep looking until we've examined all the entries in this
                    // batch or we find what we're looking for.
                    //
                    pDirInfo = (POBJECT_DIRECTORY_INFORMATION)&Buffer[0];
                    while(pDirInfo->Name.Length != 0)
                    {
                        ULONG cChar;

                        cChar = pDirInfo->Name.Length/sizeof(WCHAR);
                        if(_wcsnicmp(pDirInfo->Name.Buffer,
                                     pwszFile,
                                     2) == 0)
                        {
                            fFound = TRUE;
                            break;
                        }
                        else
                        {
                            pDirInfo++;
                        }
                    }
                }
            }

            NtClose(hRootDir);

            if(fFound != TRUE)
            {
                dwErr = RtlNtStatusToDosError(Status);

                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = ERROR_PATH_NOT_FOUND;
                }
            }
            else
            {
                //
                // Now, figure out what type of path I have
                //
                if(wcscmp(pDirInfo->TypeName.Buffer,
                          L"SymbolicLink") == 0)
                {
                    HANDLE  hLink;
                    RtlInitUnicodeString(&ObjDir,
                                         pDirInfo->Name.Buffer);
                    InitializeObjectAttributes(&Attributes,
                                               &ObjDir,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               NULL);

                    Status = NtOpenSymbolicLinkObject(&hLink,
                                                      SYMBOLIC_LINK_QUERY,
                                                      &Attributes);

                    if(NT_SUCCESS(Status))
                    {
                        UNICODE_STRING  Link;
                        Link.Buffer = (PWSTR)Buffer;
                        Link.Length = 0;
                        Link.MaximumLength = sizeof(Buffer);
                        Status = NtQuerySymbolicLinkObject(hLink,
                                                           &Link,
                                                           NULL);
                        NtClose(hLink);

                        if(NT_SUCCESS(Status))
                        {
                            //
                            // See if this is part of the lanman redir set
                            //
                            if(_wcsnicmp(Link.Buffer,
                                         LMRDR,
                                         sizeof(LMRDR) / sizeof(WCHAR)) != 0)
                            {
                                //
                                // See if it's a DFS path before passing
                                // judgement
                                //
                                if(_wcsnicmp(Link.Buffer,
                                             WINDFS,
                                             sizeof(WINDFS) / sizeof(WCHAR)) == 0)
                                {
//                                    fIsDfs = TRUE;
                                }
                                else
                                {
                                    dwErr = ERROR_PATH_NOT_FOUND;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if(fIsDfs == TRUE || IS_UNC_PATH(pwszFile, wcslen(pwszFile)))
    {

        //
        // Try and open it...
        //
/*
        //
        // First, see if it's a DFS path...
        //
        if(fIsDfs || IsThisADfsPath((LPCWSTR)pwszFile, 0) == TRUE)
        {
            ULONG cLocals = 0;
            dwErr = GetLMDfsPaths(pwszFile,
                                  &cLocals,
                                  NULL);
            if(dwErr == ERROR_SUCCESS && cLocals == 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
        }
        else
        {
*/
        //
        // We'll try to open it...
        //
        UNICODE_STRING      FileName;
        if ( RtlDosPathNameToNtPathName_U(pwszFile,
                                          &FileName,
                                          NULL,
                                          NULL) ) {

/*
            WCHAR   wszPath[MAX_PATH + 1 + sizeof(LMRDR) / sizeof(WCHAR) + 1];

            //
            // Build the path...
            //
            ASSERT(wcslen(pwszFile) < MAX_PATH + 1);

            swprintf(wszPath,
                     L"%ws%ws",
                     LMRDR,
                     pwszFile + 1);
*/
//            UNICODE_STRING      Path;
            OBJECT_ATTRIBUTES   ObjAttribs;
            IO_STATUS_BLOCK     IOSb;
            HANDLE              hRmt;

//            RtlInitUnicodeString(&Path, wszPath);
            InitializeObjectAttributes(&ObjAttribs,
                                       &FileName, // &Path,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Status = NtCreateFile(&hRmt,
                                  SYNCHRONIZE,
                                  &ObjAttribs,
                                  &IOSb,
                                  NULL,
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_SHARE_READ,
                                  FILE_OPEN_IF,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                                  NULL,
                                  0);
            if(!NT_SUCCESS(Status))
            {
                dwErr = RtlNtStatusToDosError(Status);
            }
            else
            {
                NtClose(hRmt);
            }

            RtlFreeHeap(RtlProcessHeap(), 0, FileName.Buffer );

        } else {
            dwErr = ERROR_INVALID_NAME;
        }
    }

#if 0
    //
    // never used!!! Free our memory
    //
    if(pwszFullPath != pwszFile)
    {
        AccFree(pwszFullPath);
    }
#endif

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function :  OpenFileObject
//
//  Synopsis :  opens the specified file (or directory) object
//
//  Arguments: [IN pObjectName]         --      The name of the file object
//             [IN AccessMask]          --      How to open the file
//             [OUT Handle]             --      Where to return the file
//                                              handle
//             [IN fOpenRoot]           --      Open the path as the root of a drive
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
OpenFileObject(IN  LPWSTR       pObjectName,
               IN  ACCESS_MASK  AccessMask,
               OUT PHANDLE      Handle,
               IN  BOOL         fOpenRoot)
{
    acDebugOut((DEB_TRACE, "in OpenFileObject\n"));

    NTSTATUS            ntstatus;
    DWORD               status = ERROR_SUCCESS;
    WCHAR               PathBuff[ 7 ];
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     isb;
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME   RelativeName;
    IO_STATUS_BLOCK     IoStatusBlock;
    PVOID               FreeBuffer = NULL;

    //
    // cut and paste code from windows\base\advapi\security.c SetFileSecurityW
    //

    if(fOpenRoot == TRUE && wcslen(pObjectName) == 2)
    {
        wcscpy(PathBuff, L"\\??\\");
        wcscat(PathBuff, pObjectName);
        RtlInitUnicodeString(&FileName, PathBuff);
        RtlZeroMemory(&RelativeName, sizeof(RTL_RELATIVE_NAME));

    } else {

        if(RtlDosPathNameToNtPathName_U(pObjectName, &FileName, NULL, &RelativeName))
        {

            FreeBuffer = FileName.Buffer;

            if ( RelativeName.RelativeName.Length )
            {
                FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
            }
            else
            {
                RelativeName.ContainingDirectory = NULL;
            }
        }
        else
        {
            status = ERROR_INVALID_NAME;
        }
    }


    if(status == ERROR_SUCCESS)
    {

        InitializeObjectAttributes(&oa,
                                   &FileName,
                                   OBJ_CASE_INSENSITIVE,
                                   RelativeName.ContainingDirectory,
                                   NULL);


        ntstatus = NtOpenFile( Handle,
                               AccessMask,
                               &oa,
                               &isb,
                               FILE_SHARE_READ |
                               FILE_SHARE_WRITE |
                               FILE_SHARE_DELETE,
                               0);

        if (!NT_SUCCESS(ntstatus))
        {
            status = RtlNtStatusToDosError(ntstatus);
        }

        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
    else
    {
        status = ERROR_INVALID_NAME;
    }

    acDebugOut((DEB_TRACE, "OutOpenFileObject: %lu\n", status));
    return(status);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadFilePropertyRights
//
//  Synopsis:   Reads the access rights from the specified properties on the
//              specified file
//
//  Arguments:  [IN  pwszFile]          --      The file to get the rights for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//
//----------------------------------------------------------------------------
DWORD
ReadFilePropertyRights(IN  PWSTR                    pwszFile,
                       IN  PACTRL_RIGHTS_INFO       pRightsList,
                       IN  ULONG                    cRights,
                       IN  CAccessList&             AccessList)
{
    acDebugOut((DEB_TRACE,
                "in ReadFilePropertyRights\n"));

    DWORD   dwErr = ERROR_SUCCESS;
    PWSTR   pwszPath;

    CHECK_HEAP


    //
    // For the moment, there is only file properties itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Set the server name to lookup accounts on
    //
    dwErr = SetAccessListLookupServer( pwszFile,
                                       AccessList );

    //
    // Always open with READ_CONTROL..
    //
    HANDLE  hFile;
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = OpenFileObject(pwszFile,
                               GetDesiredAccess(READ_ACCESS_RIGHTS,
                                                pRightsList[0].SeInfo)              |
                                                         FILE_READ_ATTRIBUTES   |
                                                         READ_CONTROL,
                               &hFile,
                               FALSE);
    }

    if(dwErr == ERROR_SUCCESS && IS_FILE_PATH(pwszFile,wcslen(pwszFile)))
    {
        //
        // See if there is a server associated with this path
        //
        dwErr = ConvertFileHandleToName(hFile,
                                        &pwszPath );

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetAccessListLookupServer( pwszPath,
                                               AccessList );

            AccFree(pwszPath);
        }
        //
        // jinhuang: do not care if it finds the remote server or not
        //
        dwErr = ERROR_SUCCESS;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        PSECURITY_DESCRIPTOR    pSD = NULL;
        dwErr = GetKernelSecurityInfo(hFile,
                                      pRightsList[0].SeInfo,
                                      NULL,
                                      NULL,
                                      &pSD);

        if(dwErr == ERROR_SUCCESS && pSD == NULL)
        {
            dwErr = ERROR_ACCESS_DENIED;

        }

        //
        // If that worked, we'll have to get the parent SD, if it exists,
        // and see if we can determine the inheritance on our current object.
        // We only have to do this if we are reading the DACL or SACL
        //
        if(dwErr == ERROR_SUCCESS)
        {
            if((FLAG_ON(pRightsList[0].SeInfo, DACL_SECURITY_INFORMATION) &&
                !FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                         SE_DACL_AUTO_INHERITED | SE_DACL_PROTECTED)) ||
               (FLAG_ON(pRightsList[0].SeInfo, SACL_SECURITY_INFORMATION) &&
                !FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                         SE_SACL_AUTO_INHERITED | SE_SACL_PROTECTED)))
            {
                //
                // Ok, it's downlevel, so get the parent SD...
                //
                PSECURITY_DESCRIPTOR    pParentSD;
                dwErr = GetFileParentRights(pwszFile,
                                            pRightsList,
                                            cRights,
                                            NULL,
                                            NULL,
                                            &pParentSD);

                //
                // gross hack for the NTFS people, who don't allow opens on the $Extend directory
                //
                if ( dwErr == ERROR_ACCESS_DENIED &&
                     _wcsnicmp( pwszFile + 1, L":\\$Extend", 9 ) == 0 ) {

                    pParentSD = NULL;
                    dwErr = ERROR_SUCCESS;
                }

                //
                // Also, the routine to convert from nt4 to nt5 security
                // descriptor requires that we have the owner and group,
                // so we may have to reread the child SD if we don't have
                // that info
                //
                if(dwErr == ERROR_SUCCESS && (!FLAG_ON(pRightsList[0].SeInfo,
                                            OWNER_SECURITY_INFORMATION)  ||
                                            !FLAG_ON(pRightsList[0].SeInfo,
                                            GROUP_SECURITY_INFORMATION)))
                {
                    AccFree(pSD);
                    pSD = NULL;
                    dwErr = GetKernelSecurityInfo(hFile,
                                                  pRightsList[0].SeInfo |
                                                   OWNER_SECURITY_INFORMATION |
                                                   GROUP_SECURITY_INFORMATION,
                                                  NULL,
                                                  NULL,
                                                  &pSD);
                }

                //
                // A NULL parent SD means this object has no parent!
                //
                if(dwErr == ERROR_SUCCESS)
                {

                    if(pParentSD != NULL)
                    {
                        BOOL    fIsContainer;
                        dwErr = IsFileContainer(hFile,
                                                &fIsContainer);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            PSECURITY_DESCRIPTOR    pNewSD;
                            dwErr = ConvertToAutoInheritSD(pParentSD,
                                                           pSD,
                                                           fIsContainer,
                                                           &gFileGenMap,
                                                           &pNewSD);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = AccessList.AddSD(pNewSD,
                                                     pRightsList[0].SeInfo,
                                                     pRightsList[0].pwszProperty);

                                DestroyPrivateObjectSecurity(&pNewSD);
                            }

                        }

                        AccFree(pParentSD);
                    }
                    else
                    {
                        dwErr = AccessList.AddSD(pSD,
                                                 pRightsList[0].SeInfo,
                                                 pRightsList[0].pwszProperty);
                    }
                }
            }
            else
            {
                //
                // Simply add the SD to our list
                //
                dwErr = AccessList.AddSD(pSD,
                                         pRightsList[0].SeInfo,
                                         pRightsList[0].pwszProperty);

            }

            //
            // Make sure to free the security descriptor...
            //
            AccFree(pSD);
        }


        NtClose(hFile);
    }

    acDebugOut((DEB_TRACE,
                "Out ReadFilePropertyRights %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadFileRights
//
//  Synopsis:   Reads the access rights from the specified properties on the
//              open file
//
//  Arguments:  [IN  pwszFile]          --      The file to get the rights for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//
//----------------------------------------------------------------------------
DWORD
ReadFileRights(IN  HANDLE               hObject,
               IN  PACTRL_RIGHTS_INFO   pRightsList,
               IN  ULONG                cRights,
               IN  CAccessList&         AccessList)
{
    acDebugOut((DEB_TRACE,
                "in ReadFileRights\n"));

    DWORD   dwErr = ERROR_SUCCESS;
    PACL                    pDAcl, pSAcl;
    PSECURITY_DESCRIPTOR    pSD;
    PWSTR   pwszPath = NULL;


    CHECK_HEAP

    //
    // See if there is a server associated with this path
    //
    dwErr = ConvertFileHandleToName(hObject,
                                    &pwszPath );

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SetAccessListLookupServer( pwszPath,
                                           AccessList );

        AccFree(pwszPath);
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetKernelSecurityInfo(hObject,
                                      pRightsList[0].SeInfo,
                                      &pDAcl,
                                      &pSAcl,
                                      &pSD);
    }

    //
    // If that worked, we'll have to get the parent SD, if it exists,
    // and see if we can determine the inheritance on our current object
    //
    if(dwErr == ERROR_SUCCESS && !FLAG_ON(pRightsList[0].SeInfo,
                                            DACL_SECURITY_INFORMATION   |
                                              SACL_SECURITY_INFORMATION))
    {
        //
        // Just insert it and continue
        //
        dwErr = AccessList.AddSD(pSD,
                                 pRightsList[0].SeInfo,
                                 pRightsList[0].pwszProperty);
        AccFree(pSD);

    }
    else if(dwErr == ERROR_SUCCESS)
    {
        if(!FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                     SE_SACL_AUTO_INHERITED |
                        SE_DACL_AUTO_INHERITED))
        {
            //
            // Ok, it's downlevel, so get the parent SD...  In order to
            // do this, we'll have to determine who the parent is (path wise)
            //
            PWSTR   pwszName = NULL;

            dwErr = ConvertFileHandleToName(hObject,
                                            &pwszName);
            if(dwErr == ERROR_SUCCESS)
            {
                PSECURITY_DESCRIPTOR    pParentSD;
                PACL                    pParentDAcl, pParentSAcl;
                dwErr = GetFileParentRights(pwszName,
                                            pRightsList,
                                            cRights,
                                            &pParentDAcl,
                                            &pParentSAcl,
                                            &pParentSD);

                if(dwErr == ERROR_SUCCESS && (!FLAG_ON(pRightsList[0].SeInfo,
                                            OWNER_SECURITY_INFORMATION)  ||
                                            !FLAG_ON(pRightsList[0].SeInfo,
                                            GROUP_SECURITY_INFORMATION)))
                {
                    AccFree(pSD);
                    pSD = NULL;
                    dwErr = GetKernelSecurityInfo(hObject,
                                                  pRightsList[0].SeInfo |
                                                   OWNER_SECURITY_INFORMATION |
                                                   GROUP_SECURITY_INFORMATION,
                                                  NULL,
                                                  NULL,
                                                  &pSD);
                }

                //
                // A NULL parent SD means this object has no parent!
                //
                if(dwErr == ERROR_SUCCESS && pParentSD != NULL)
                {
                    BOOL    fIsContainer;
                    dwErr = IsFileContainer(hObject,
                                            &fIsContainer);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        PSECURITY_DESCRIPTOR    pNewSD;
                        dwErr = ConvertToAutoInheritSD(pParentSD,
                                                       pSD,
                                                       fIsContainer,
                                                       &gFileGenMap,
                                                       &pNewSD);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = AccessList.AddSD(pNewSD,
                                                 pRightsList[0].SeInfo,
                                                 pRightsList[0].pwszProperty);

                            DestroyPrivateObjectSecurity(&pNewSD);
                        }

                    }

                    AccFree(pParentSD);
                }
                AccFree(pwszName);

            }
        }
        else
        {
            //
            // Simply add the SD to our list
            //
            dwErr = AccessList.AddSD(pSD,
                                     pRightsList[0].SeInfo,
                                     pRightsList[0].pwszProperty);

        }

        //
        // Make sure to free the security descriptor...
        //
        AccFree(pSD);
    }

    acDebugOut((DEB_TRACE,
                "Out ReadFileRights %lu\n",
                dwErr));

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetFileParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//  Arguments:  [IN  pwszFile]          --      The file/directory to get the
//                                              parent for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
GetFileParentRights(IN  LPWSTR                      pwszFile,
                    IN  PACTRL_RIGHTS_INFO          pRightsList,
                    IN  ULONG                       cRights,
                    OUT PACL                       *ppDAcl,
                    OUT PACL                       *ppSAcl,
                    OUT PSECURITY_DESCRIPTOR       *ppSD)
{
    acDebugOut((DEB_TRACE, "in GetFileParentRights\n"));

    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fNoParent = FALSE;
    WCHAR   pwszLocalFileNameBuffer[MAX_PATH+1];
    PWSTR   pwszLocalFileName = (PWSTR) pwszLocalFileNameBuffer;
    ULONG   filesize;
    PWSTR   pwszLastComp;

    CHECK_HEAP

    if (0 == (filesize = RtlGetFullPathName_U(pwszFile, sizeof(WCHAR)*MAX_PATH, pwszLocalFileName, NULL)))
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        goto FileCleanup;
    }

    if (filesize > sizeof(WCHAR)*MAX_PATH)
    {
        //
        // The buffer is too small. We have to allocate more.
        //

        if (NULL == (pwszLocalFileName = (PWSTR) AccAlloc(sizeof(WCHAR)+filesize)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FileCleanup;
        }

        //
        // Try to get the full pathname again. This time the buffer is big enough to hold the full pathname.
        //

        if (0 == (RtlGetFullPathName_U(pwszFile, filesize, pwszLocalFileName, NULL)))
        {
            dwErr = ERROR_FILE_NOT_FOUND;
            goto FileCleanup;
        }
    }

    //
    // First, we have to figure out who are parent is.  For now, since there
    // are no supported properties, we'll simply open the parent object
    //
    pwszLastComp = wcsrchr(pwszLocalFileName, L'\\');
    if(pwszLastComp == NULL)
    {
        //
        // Ok, we must be at the root, so we won't have any inheritance
        //
        //
        // Return success after nulling out SD.
        //
        *ppSD = NULL;

    }
    else
    {
        //
        // We'll shorten our path, and then get the info
        //
        WCHAR   wcLast;

        // Leave the trailing \, it doesn't hurt to have them on directories.
        // Plus, we don't end up querying security on the Device (x:) instead
        // of the intended root (x:\)
        //
        // We restore

        pwszLastComp ++;

        wcLast = *pwszLastComp;

        *pwszLastComp = L'\0';

        //
        // Make sure if we were looking at the root of a share, that we don't try and go to far
        //
        if (IS_UNC_PATH(pwszLocalFileName, wcslen(pwszLocalFileName)))
        {
            //
            //
            // Have to pass "\\server" if the original string was "\\server\share"
            //

            *(pwszLastComp-1) = L'\0';

            if(wcsrchr(pwszLocalFileName+2, L'\\') == NULL)
            {
                //
                // It's impossible for us to have a parent, so return
                //
                *ppSD = NULL;
                fNoParent = TRUE;
            }

            //
            // Restore the '\'
            //
            *(pwszLastComp-1) = L'\\';
        }

        if(fNoParent == FALSE)
        {
            HANDLE  hFile;

            SECURITY_INFORMATION    SeInfo = pRightsList[0].SeInfo;

            //
            // Don't want owner or group
            //
            SeInfo &= ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION);
            dwErr = OpenFileObject(pwszLocalFileName,
                                   GetDesiredAccess(READ_ACCESS_RIGHTS,SeInfo),
                                   &hFile,
                                   TRUE);

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = GetKernelSecurityInfo(hFile,
                                              SeInfo,
                                              NULL,
                                              NULL,
                                              ppSD);
                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Convert it to self relative
                    //
                    PSECURITY_DESCRIPTOR    pNewSD;
                    dwErr = MakeSDSelfRelative(*ppSD,
                                               &pNewSD,
                                               ppDAcl,
                                               ppSAcl);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        *ppSD = pNewSD;
                    }
                    else
                    {
                        AccFree(*ppSD);
                    }

                }
                NtClose(hFile);
            }

        }
        *pwszLastComp = wcLast;
    }

FileCleanup:

    if ((pwszLocalFileName != (PWSTR) pwszLocalFileNameBuffer) && (NULL != pwszLocalFileName))
    {
        AccFree(pwszLocalFileName);
    }

    acDebugOut((DEB_TRACE, "Out GetFileParentRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetFilePropertyRights
//
//  Synopsis:   Sets the specified security info on the specified file object
//              property
//
//  Arguments:  [IN  hFile]             --      The handle to the open object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      Property to set it on
//              [IN  pSD]               --      The security desciptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetFilePropertyRights(IN  HANDLE                    hFile,
                      IN  SECURITY_INFORMATION      SeInfo,
                      IN  PWSTR                     pwszProperty,
                      IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetFilePropertyRights\n"));

    DWORD dwErr = ERROR_SUCCESS;

    //
    // Filesystems don't support properties yet...
    //
    ASSERT(pwszProperty == NULL);
    if(pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Marta only writes uplevel security descriptors.
    //
    // The caller of SetFilePropertyRights will call with SE_xACL_AUTO_INHERITED off in those
    //  cases that it wants the underlying file system to do auto inheritance.
    // The caller of SetFilePropertyRights will call with SE_xACL_AUTO_INHERITED on in those
    //  cases that it wants the underlying file system to simply store the bits.
    //
    // In the later case, the OS uses the SE_xACL_AUTO_INHERIT_REQ bit as a flag indicating
    // that it is OK to preserve SE_xACL_AUTO_INHERITED bit.
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION)) {
        ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION)) {
        ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }


    //
    // Otherwise, do the set
    //
    NTSTATUS Status = NtSetSecurityObject(hFile,
                                          SeInfo,
                                          pSD);
    dwErr = RtlNtStatusToDosError(Status);


    acDebugOut((DEB_TRACE,
               "Out SetFilePropertyRights: %ld\n",
               dwErr));
    return(dwErr);
}




#define CLEANUP_ON_INTERRUPT(pstopflag)                                     \
if(*pstopflag != 0)                                                         \
{                                                                           \
    goto FileCleanup;                                                       \
}
//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropagateFilePropertyRights
//
//  Synopsis:   Sets the speecified access on the object and, if appropriate,
//              propagates the access to the apporpriate child objects
//
//  Arguments:  [IN  pwszFile]          --      The path to set and propagate
//              [IN  pwszProperty]      --      Property to set it on
//              [IN  RootAccList]       --      CAccessList that indicates
//                                              what access is to be set on
//                                              the object
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      Count of processed items
//              [IN  hOpenObject]       --      OPTIONAL handle to the file object
//                                              if it's already open
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetAndPropagateFilePropertyRights(IN  PWSTR             pwszFile,
                                  IN  PWSTR             pwszProperty,
                                  IN  CAccessList&      RootAccList,
                                  IN  PULONG            pfStopFlag,
                                  IN  PULONG            pcProcessed,
                                  IN  HANDLE            hOpenObject OPTIONAL)
{
    acDebugOut((DEB_TRACE, "in SetAndPropagateFilePropertyRights\n"));

    DWORD                   dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pReadSD = NULL;
    HANDLE                  hObject = NULL;
    BOOL                    fManualProp = FALSE;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;
    BOOL                    fIsCont = FALSE;
    ULONG                   fProtected = 0;
    HANDLE                  hProcessToken;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_INFORMATION    SeInfo = 0;
    PSECURITY_DESCRIPTOR    pUpdateSD = NULL;

    CSList                  FailureLogList(FreePropagationFailureListEntry);

    //
    // First, get the security descriptor
    //
    dwErr = RootAccList.BuildSDForAccessList(&pSD,
                                             &SeInfo,
                                             ACCLIST_SD_ABSOK);

    if(dwErr == ERROR_SUCCESS &&
            FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION))
    {
        //
        // Next, open it
        //
        if(hOpenObject == NULL)
        {
            dwErr = OpenFileObject(pwszFile,
                                   GetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                    SeInfo) | FILE_READ_ATTRIBUTES | READ_CONTROL,
                                   &hObject,
                                   FALSE);
        }
        else
        {
            hObject = hOpenObject;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = IsFileContainer(hObject,
                                    &fIsCont);
        }

        if(dwErr != ERROR_SUCCESS || *pfStopFlag != 0)
        {
            goto FileCleanup;
        }

        //
        // Ok, first, we have to read the SD off the object.  We do this
        // so that we can determine what the potential inheritance is for
        // our children following the object getting an updated security
        // descriptor.
        //
        if(dwErr == ERROR_SUCCESS && fIsCont == TRUE)
        {
            dwErr = ReadFileSD(hObject,
                               SeInfo,
                               0,
                               &pReadSD);

        }

        //
        // Now, write the current SD out to the object.  Note that it's being
        // written out as an uplevel acl
        //
        if(dwErr == ERROR_SUCCESS)
        {
            CLEANUP_ON_INTERRUPT(pfStopFlag);
            dwErr = SetFilePropertyRights(hObject,
                                          SeInfo,
                                          pwszProperty,
                                          pSD);
            if(dwErr == ERROR_SUCCESS)
            {
                PSECURITY_DESCRIPTOR    pVerifySD;
                (*pcProcessed)++;
                CLEANUP_ON_INTERRUPT(pfStopFlag);

                //
                // Now, we have to reread the new SD, to see if we need
                // to do manual propagation
                //
                dwErr = ReadFileSD(hObject,
                                   SeInfo,
                                   RootAccList.QuerySDSize(),
                                   &pVerifySD);

                //
                // Get our process token
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = GetCurrentToken(&hProcessToken);
                }

                if(dwErr == ERROR_SUCCESS)
                {

                    //
                    // Check to see if this was done uplevel...
                    //
                    PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pVerifySD;
                    if(!(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) &&
                        FLAG_ON(pISD->Control, SE_DACL_AUTO_INHERITED) &&
                        !FLAG_ON(pISD->Control, SE_DACL_PROTECTED)) &&
                       !(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) &&
                        FLAG_ON(pISD->Control, SE_SACL_AUTO_INHERITED &&
                        !FLAG_ON(pISD->Control, SE_SACL_PROTECTED))))
                    {
                        //
                        // It's not uplevel, so we'll turn the AutoInherit
                        // flags on, rewrite it, and do our own propagation,
                        // only if this is a container and we're setting the
                        // dacl or sacl
                        //
                        if(FLAG_ON(SeInfo,
                                   (DACL_SECURITY_INFORMATION |
                                                SACL_SECURITY_INFORMATION)) &&
                                   fIsCont == TRUE)
                        {
                            fManualProp = TRUE;
                        }


                        //
                        // Upgrade it...
                        //
                        dwErr = UpdateFileSDByPath(pSD,
                                                   pwszFile,
                                                   hObject,
                                                   hProcessToken,
                                                   SeInfo,
                                                   fIsCont,
                                                   &pUpdateSD);


                        //
                        // Now, if we're going to do manual propagation,
                        // we'll write out the old SD until we get everyone
                        // else updated
                        //
                        PSECURITY_DESCRIPTOR    pWriteSD = pUpdateSD;
                        if(fManualProp == TRUE)
                        {
                            pWriteSD = pReadSD;
                        }

                        //
                        // Reset it...
                        //
                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = SetFilePropertyRights(hObject,
                                                          SeInfo,
                                                          pwszProperty,
                                                          pWriteSD);
                        }
                    }

                    AccFree(pVerifySD);
                }

                CLEANUP_ON_INTERRUPT(pfStopFlag);

            }
        }


        //
        // Ok, now we'll do the right thing
        //
        if(dwErr == ERROR_SUCCESS && fManualProp == TRUE)
        {
            //
            // We'll have to do our own propagation...
            //
            PSECURITY_DESCRIPTOR    pUpdateParentSD = NULL;
            if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
               !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
            {
                dwErr = GetKernelSecurityInfo(hObject,
                                      SeInfo |
                                        OWNER_SECURITY_INFORMATION |
                                        GROUP_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      &pUpdateParentSD);
            }

            //
            // Ok, go ahead and do deep.  This will possibly save us
            // some storage space in the long run...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Set our protected flags.  If we aren't messing with a particular acl, we'll
                // pretend it's protected
                //

                fProtected = ((SECURITY_DESCRIPTOR *)pUpdateSD)->Control &
                                                        ~(SE_DACL_PROTECTED | SE_SACL_PROTECTED);
                if(!FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                {
                    fProtected |= SE_DACL_PROTECTED;
                }

                if(!FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                {
                    fProtected |= SE_SACL_PROTECTED;
                }

                dwErr = PropagateFileRightsDeep(pUpdateSD,
                                                pUpdateParentSD,
                                                SeInfo,
                                                pwszFile,
                                                pwszProperty,
                                                pcProcessed,
                                                pfStopFlag,
                                                fProtected,
                                                hProcessToken,
                                                FailureLogList);
            }

            //
            // If that worked, write out our updated root security descriptor
            //
            if(dwErr == ERROR_SUCCESS)
            {

                dwErr = SetFilePropertyRights(hObject,
                                              SeInfo,
                                              pwszProperty,
                                              pUpdateSD );
            }

            AccFree(pUpdateParentSD);
        }

        if(pUpdateSD != NULL)
        {
            DestroyPrivateObjectSecurity(&pUpdateSD);
        }
    }
    else
    {
        if(dwErr == ERROR_SUCCESS &&
           FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
        {
            if(hOpenObject == NULL)
            {
                dwErr = OpenFileObject(pwszFile,
                                       GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                        SeInfo),
                                       &hObject,
                                       FALSE);

            }
            else
            {
                hObject = hOpenObject;
            }
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = SetFilePropertyRights(hObject,
                                              SeInfo,
                                              pwszProperty,
                                              pSD);
            }

        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = WritePropagationFailureList(MARTAEVT_DIRECTORY_PROPAGATION_FAILED,
                                            FailureLogList,
                                            hProcessToken);
        //
        // Temporary hack. The failure list should be written to the eventlog rather
        // than to a registry key.
        //
        // Remember to change this in future.
        // KedarD
        //

        dwErr = ERROR_SUCCESS;
    }

FileCleanup:
    if(hObject != hOpenObject)
    {
        NtClose(hObject);
    }

    AccFree(pReadSD);

    acDebugOut((DEB_TRACE,
               "Out SetAndPropagateFilePropertyRights: %ld\n",
               dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropagateFilePropertyRightsByHandle
//
//  Synopsis:   Same as above, but deals with a handle to the open object
//              as opposed to a file name.
//
//  Arguments:  [IN  hObject]           --      File handle
//              [IN  pwszProperty]      --      Property to set it on
//              [IN  RootAccList]       --      CAccessList that indicates
//                                              what access is to be set on
//                                              the object
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      Count of processed items
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetAndPropagateFilePropertyRightsByHandle(IN  HANDLE        hObject,
                                          IN  PWSTR         pwszProperty,
                                          IN  CAccessList&  RootAccList,
                                          IN  PULONG        pfStopFlag,
                                          IN  PULONG        pcProcessed)
{
    acDebugOut((DEB_TRACE, "in SetAndPropagateFilePropertyRightsByHandle\n"));



    CHECK_HEAP


    //
    // We'll do this the easy way... convert it to a path, and call on up
    //
    PWSTR   pwszPath = NULL;

    DWORD   dwErr = ConvertFileHandleToName(hObject,
                                            &pwszPath);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SetAndPropagateFilePropertyRights(pwszPath,
                                                  pwszProperty,
                                                  RootAccList,
                                                  pfStopFlag,
                                                  pcProcessed,
                                                  hObject);
        AccFree(pwszPath);
    }


    acDebugOut((DEB_TRACE,
               "Out SetAndPropagateFilePropertyRightsByHandle: %ld\n",
               dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetLMDfsPaths
//
//  Synopsis:   Given a DFS path, this function will return a list of the
//              LANMAN shares supporting this path.  If any non-LM paths are
//              found, they are ignored.
//
//  Arguments:  [IN  pwszPath]          --      Path to check
//              [OUT pcItems]           --      Where the count of the
//                                              number of items in the list
//                                              is returned
//              [OUT pppwszLocalList]   --      OPTIONAL.  If present, the
//                                              list of LM paths is returned
//                                              here.
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetLMDfsPaths(IN  PWSTR     pwszPath,
              OUT PULONG    pcItems,
              OUT PWSTR   **pppwszLocalList OPTIONAL)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP


    PDFS_INFO_3 pDI3;

    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    dwErr = (*DLLFuncs.PNetDfsGetInfo)(pwszPath,
                                       NULL,
                                       NULL,
                                       3,
                                       (PBYTE *)&pDI3);
    //
    // Now, build the list of information to return.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Go through and size our list
        //
        *pcItems = 0;
        DWORD   dwSize = sizeof(PWSTR) * pDI3->NumberOfStorages;

        for(ULONG iIndex = 0; iIndex < pDI3->NumberOfStorages; iIndex++)
        {
            WCHAR   wszUNCPath[MAX_PATH + 1];
            swprintf(wszUNCPath,
                     L"\\\\%ws\\%ws",
                     pDI3->Storage[iIndex].ServerName,
                     pDI3->Storage[iIndex].ShareName);

            dwErr = IsFilePathLocalOrLM(wszUNCPath);

            if(dwErr != ERROR_SUCCESS)
            {
                if(dwErr == ERROR_PATH_NOT_FOUND)
                {
                    dwErr = ERROR_SUCCESS;
                    continue;
                }
                else
                {
                    break;
                }
            }
            (*pcItems)++;
            if(pppwszLocalList != NULL)
            {
                //
                // Set a flag in the information so we can look up the
                // valid names quicker below, when we copy them
                //
                pDI3->Storage[iIndex].State = 0xFFFFFFFF;
                dwSize += SIZE_PWSTR(pDI3->Storage[iIndex].ServerName);
                dwSize += SIZE_PWSTR(pDI3->Storage[iIndex].ShareName);
                dwSize += 2 * sizeof(WCHAR);    // Room for leading \\'s.  The
                                                // NULL of the server name
                                                // gives the seperator
            }
        }

        if(dwErr == ERROR_SUCCESS && pppwszLocalList != NULL)
        {
            //
            // Now, allocate, and we'll fill
            //
            *pppwszLocalList = (PWSTR *)AccAlloc(dwSize);
            if(*pppwszLocalList == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                PWSTR   pwszStrStart = (PWSTR)(*pppwszLocalList +
                                    (sizeof(PWSTR) * pDI3->NumberOfStorages));

                for(iIndex = 0; iIndex < pDI3->NumberOfStorages; iIndex++)
                {
                    if(pDI3->Storage[iIndex].State == 0xFFFFFFFF)
                    {
                        (*pppwszLocalList)[iIndex] = pwszStrStart;
                        swprintf(pwszStrStart,
                                 L"\\\\%ws\\%ws",
                                 pDI3->Storage[iIndex].ServerName,
                                 pDI3->Storage[iIndex].ShareName);

                        pwszStrStart += wcslen(pwszStrStart) + 1;
                    }

                }
            }
        }

        //
        // Make sure to free our buffer
        //
        (*DLLFuncs.PNetApiBufferFree)(pDI3);


    }
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   PropagateFileRightsDeep, recursive
//
//  Synopsis:   Does a deep propagation of the access.  At the same time, it
//              will update NT4 acls to NT5 acls.  This function is only
//              called on downlevel file systems, so the update will always
//              happen (where appropriate).  The algorithm is:
//                  - Read the current security descriptor from the object
//                  - If it's a downlevel acl, update it using the OLD
//                    parent security descriptor (to set any inheritied aces)
//                  - Update the security descriptor using the NEW parent
//                    security descriptor.
//                  - Repeat for its children.  (This is necessar, since there
//                    could have been unmarked inheritance off of the old
//                    security descriptor)
//
//  Arguments:  [IN  pParentSD]         --      The current parent sd
//              [IN  pOldParentSD]      --      The previous parent SD (before
//                                              the current parent SD was
//                                              stamped on the object)
//              [IN  SeInfo]            --      What is being written
//              [IN  pwszFile]          --      Parent file path
//              [IN  pwszProperty]      --      What property is being
//                                              written
//              [IN  pcProcessed]       --      Where the number processed is
//                                              returned.
//              [IN  pfStopFlag]        --      Stop flag to monitor
//              [IN  fProtectedFlag]    --      Indicates whether acls are protected or not
//              [IN  hToken]            --      Handle to the process token
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
#define ALL_STR L"\\*.*"
DWORD
PropagateFileRightsDeep(IN  PSECURITY_DESCRIPTOR    pParentSD,
                        IN  PSECURITY_DESCRIPTOR    pOldParentSD,
                        IN  SECURITY_INFORMATION    SeInfo,
                        IN  PWSTR                   pwszFile,
                        IN  PWSTR                   pwszProperty,
                        IN  PULONG                  pcProcessed,
                        IN  PULONG                  pfStopFlag,
                        IN  ULONG                   fProtectedFlag,
                        IN  HANDLE                  hToken,
                        IN OUT CSList&              LogList)
{
    acDebugOut((DEB_TRACE, "in PropagateFileRightsDeep\n"));
    DWORD       dwErr = ERROR_SUCCESS;

    WIN32_FIND_DATA         FindData;
    HANDLE                  hFind = NULL;
    HANDLE                  hChild = NULL;
    ULONG                   cRootLen = SIZE_PWSTR(pwszFile), Protected = 0;
    SECURITY_DESCRIPTOR    *pChildSD = NULL;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    PWSTR                   pwszFull = NULL;
    BOOL                    fUpdateChild = FALSE;   // Write out the child?
    BOOL                    fAccFreeChild = TRUE;   // How to free the child
    BOOL                    fNoPropagate = FALSE;
    BOOL                    fLoggedFailure = FALSE;

    acDebugOut((DEB_TRACE_PROP, " Path: %ws\n", pwszFile));
    acDebugOut((DEB_TRACE_PROP, "   ParentSD: 0x%lx, OldParentSD: 0x%lx\n",
               pParentSD, pOldParentSD));

    //
    // If the any part of the node is going be ingnored because of protection, log it
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) && FLAG_ON(fProtectedFlag, SE_DACL_PROTECTED))
    {
        Protected |= SE_DACL_PROTECTED;
    }

    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) && FLAG_ON(fProtectedFlag, SE_SACL_PROTECTED))
    {
        Protected |= SE_SACL_PROTECTED;
    }


    if( Protected != 0)
    {
        dwErr = InsertPropagationFailureEntry(LogList,
                                              0,
                                              Protected,
                                              pwszFile);
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

    }

    //
    // Check to see if we've reached full protection saturation
    //
    if(fProtectedFlag == (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
    {
        acDebugOut((DEB_TRACE_PROP, "Parent of %ws is fully or effectively protected\n",
                    pwszFile));
        return(ERROR_SUCCESS);
    }


    //
    // Build the full path name
    //
    PWSTR   pwszFindRoot = (PWSTR)AccAlloc(cRootLen + sizeof(ALL_STR));
    if(pwszFindRoot == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        swprintf(pwszFindRoot,
                 L"%ws%ws",
                 pwszFile,
                 ALL_STR);

        hFind = FindFirstFile(pwszFindRoot,
                              &FindData);
        if(hFind == INVALID_HANDLE_VALUE)
        {
            dwErr = InsertPropagationFailureEntry(LogList,
                                                  GetLastError(),
                                                  0,
                                                  pwszFile);
            fNoPropagate = TRUE;
        }

    }

    //
    // Start processing all the files
    //
    while(dwErr == ERROR_SUCCESS && fNoPropagate == FALSE)
    {
        //
        // Ignore the . and ..
        //
        if(_wcsicmp(FindData.cFileName, L".") != 0 &&
           wcscmp(FindData.cFileName, L"..") != 0)
        {
            //
            // Now, build the full path...
            //
            pwszFull = (PWSTR)AccAlloc(cRootLen + SIZE_PWSTR(FindData.cFileName));
            if(pwszFull == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            wcscpy(pwszFull,
                   pwszFile);
            if(pwszFull[(cRootLen / sizeof(WCHAR)) - 2] != L'\\')
            {
                wcscat(pwszFull,
                       L"\\");
            }
            wcscat(pwszFull,
                   FindData.cFileName);

            acDebugOut((DEB_TRACE_PROP,
                        "Processing %ws\n",
                        pwszFull));

            //
            // Open the object
            //
            if(hChild != NULL)
            {
                NtClose(hChild);
                hChild = NULL;
            }

            dwErr = OpenFileObject(pwszFull,
                                   GetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                    SeInfo) | FILE_READ_ATTRIBUTES | READ_CONTROL,
                                   &hChild,
                                   FALSE);

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Ok, is it a file or directory
                //
                BOOL    fIsCont;
                dwErr = IsFileContainer(hChild,
                                        &fIsCont);
                //
                // First, we have to read the current security descriptor
                // on the object
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Get the owner and the group if we have to
                    //
                    if(pChildSD == NULL ||
                       !FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
                       !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                    {
                        AccFree(pChildSD);
                        pChildSD = NULL;
                        dwErr = ReadFileSD(hChild,
                                           SeInfo                           |
                                                OWNER_SECURITY_INFORMATION  |
                                                GROUP_SECURITY_INFORMATION,
                                           0,
                                           (PSECURITY_DESCRIPTOR *)&pChildSD);
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // If we don't have an uplevel SecurityDescriptor,
                        // we'll need to update it with our old parent sd
                        //
                        if(!FLAG_ON(pChildSD->Control,
                                   SE_DACL_AUTO_INHERITED |
                                                     SE_SACL_AUTO_INHERITED))
                        {
                            dwErr = ConvertToAutoInheritSD(pOldParentSD,
                                                           pChildSD,
                                                           fIsCont,
                                                           &gFileGenMap,
                                                           &pNewSD);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                if(fAccFreeChild == TRUE)
                                {
                                    AccFree(pChildSD);
                                }
                                else
                                {
                                    DestroyPrivateObjectSecurity((PSECURITY_DESCRIPTOR *)&pChildSD);
                                }
                                pChildSD = (SECURITY_DESCRIPTOR *)pNewSD;
                                fAccFreeChild = FALSE;
                                pNewSD = NULL;
                            }
                        }
                    }

                    //
                    // Now, compute the new security descriptor
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        DebugDumpSD("CPOS ParentSD", pParentSD);
                        DebugDumpSD("CPOS ChildSD",  pChildSD);

                        if(CreatePrivateObjectSecurityEx(
                                            pParentSD,
                                            pChildSD,
                                            &pNewSD,
                                            NULL,
                                            fIsCont,
                                            SEF_DACL_AUTO_INHERIT          |
                                                SEF_SACL_AUTO_INHERIT      |
                                                SEF_AVOID_OWNER_CHECK      |
                                                SEF_AVOID_PRIVILEGE_CHECK,
                                            hToken,
                                            &gFileGenMap) == FALSE)
                        {
                            dwErr = GetLastError();
                        }

#ifdef DBG
                        if(dwErr == ERROR_SUCCESS)
                        {
                            DebugDumpSD("CPOS NewChild", pNewSD);
                        }
#endif
                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // If the resultant child is protected, don't bother propagating
                            // down.
                            //
                            if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                            {
                                if(DACL_PROTECTED(pNewSD))
                                {
                                    fProtectedFlag |= SE_DACL_PROTECTED;
                                }
                            }

                            if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                            {
                                if(SACL_PROTECTED(pNewSD))
                                {
                                    fProtectedFlag |= SE_SACL_PROTECTED;
                                }
                            }

                            if(fProtectedFlag == (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
                            {
                                fIsCont = FALSE;
                            }

                            //
                            // If we haven't changed the acl, security descriptor, then
                            // we can also quit
                            //
                            if(EqualSecurityDescriptors(pNewSD, pChildSD))
                            {
                                fIsCont = FALSE;
                            }
                        }
                    }

                    //
                    // Now, if it's a directory, call ourselves
                    //
                    if(dwErr == ERROR_SUCCESS && fIsCont == TRUE)
                    {
                        dwErr = PropagateFileRightsDeep(pNewSD,
                                                        pChildSD,
                                                        SeInfo,
                                                        pwszFull,
                                                        pwszProperty,
                                                        pcProcessed,
                                                        pfStopFlag,
                                                        fProtectedFlag,
                                                        hToken,
                                                        LogList);
                    }

                    //
                    // Free the old child, since we won't need it anymore
                    //
                    if(fAccFreeChild == TRUE)
                    {
                        AccFree(pChildSD);
                    }
                    else
                    {
                        DestroyPrivateObjectSecurity((PSECURITY_DESCRIPTOR *)
                                                                   &pChildSD);
                    }
                    pChildSD = NULL;

                }
            }
            else
            {
                dwErr = InsertPropagationFailureEntry(LogList,
                                                      dwErr,
                                                      0,
                                                      pwszFull);
                fLoggedFailure = TRUE;

            }

            acDebugOut((DEB_TRACE_PROP,
                        "Processed %ws: %lu\n",
                        pwszFull,
                        dwErr));

            //
            // Finally, set the new security
            //
            if(dwErr == ERROR_SUCCESS && fLoggedFailure == FALSE)
            {
                //
                // Now, we'll simply stamp it on the object
                //

                dwErr = SetFilePropertyRights(hChild,
                                              SeInfo,
                                              pwszProperty,
                                              pNewSD);
                (*pcProcessed)++;

            }


            DestroyPrivateObjectSecurity(&pNewSD);
            pNewSD = NULL;
            AccFree(pwszFull);
            pwszFull = NULL;
            fLoggedFailure = FALSE;
        }

        CLEANUP_ON_INTERRUPT(pfStopFlag);

        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }

        if(FindNextFile(hFind,
                        &FindData) == FALSE)
        {
            dwErr = GetLastError();
        }
    }

    if(dwErr == ERROR_NO_MORE_FILES)
    {
        dwErr = ERROR_SUCCESS;
    }



FileCleanup:
    if(hChild != NULL)
    {
        NtClose(hChild);
    }

    if(hFind != NULL)
    {
        FindClose(hFind);
    }

    AccFree(pwszFull);
    AccFree(pwszFindRoot);
    if(pNewSD != NULL)
    {
        DestroyPrivateObjectSecurity(&pNewSD);
    }

    acDebugOut((DEB_TRACE, "Out PropagateFileRightsDeep: %ld\n", dwErr));
    return(dwErr);

}




//+---------------------------------------------------------------------------
//
//  Function:   MakeSDSelfRelative
//
//  Synopsis:   Makes the indicated security descriptor self relative,
//              if it isn't already.
//
//  Arguments:  [IN  pOldSD]            --      The security descriptor to
//                                              convert
//              [OUT ppNewSD]           --      Where the new SD is returned
//              [OUT ppDAcl]            --      If non-NULL, the DACL pointer
//                                              is returned here
//              [OUT ppSAcl]            --      If non-NULL, the SACL pointer
//                                              is returned here
//              [IN  fFreeOldSD]        --      If true, AccFree is called
//                                              on the old SD.
//              [IN  fRtlAlloc]         --      If true, use the RtlAllocation
//                                              routines instead of AccAlloc
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
MakeSDSelfRelative(IN  PSECURITY_DESCRIPTOR     pOldSD,
                   OUT PSECURITY_DESCRIPTOR    *ppNewSD,
                   OUT PACL                    *ppDAcl,
                   OUT PACL                    *ppSAcl,
                   IN  BOOL                     fFreeOldSD,
                   IN  BOOL                     fRtlAlloc)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP


    if(pOldSD == NULL)
    {
        *ppNewSD = NULL;
        return(dwErr);
    }

    //
    // If it's already self relative and we don't need it to be allocated via
    // RtlAllocateHead, simply return what we have
    //
    if(FLAG_ON(((SECURITY_DESCRIPTOR *)pOldSD)->Control,
                    SE_SELF_RELATIVE) && fRtlAlloc == FALSE)
    {
        *ppNewSD = pOldSD;
    }
    else
    {
        DWORD   dwSize = RtlLengthSecurityDescriptor(pOldSD);

        if(fRtlAlloc == FALSE)
        {
            *ppNewSD = (PSECURITY_DESCRIPTOR)AccAlloc(dwSize);
        }
        else
        {
            *ppNewSD = (PSECURITY_DESCRIPTOR)RtlAllocateHeap(RtlProcessHeap(),
                                                             0, dwSize);
        }

        if(*ppNewSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if(FLAG_ON(((SECURITY_DESCRIPTOR *)pOldSD)->Control, SE_SELF_RELATIVE))
            {
                RtlCopyMemory(*ppNewSD, pOldSD, dwSize);
            }
            else
            {
                if(MakeSelfRelativeSD(pOldSD,
                                      *ppNewSD,
                                      &dwSize) == FALSE)
                {
                    dwErr = GetLastError();
                    if(fRtlAlloc == FALSE)
                    {
                        AccFree(*ppNewSD);
                        *ppNewSD = NULL;
                    }
                    else
                    {
                        RtlFreeHeap(RtlProcessHeap(), 0, *ppNewSD);
                    }
                }
            }
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        if(ppDAcl != NULL)
        {
            *ppDAcl =
              RtlpDaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)*ppNewSD);
        }

        if(ppSAcl != NULL)
        {
            *ppSAcl =
               RtlpSaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)*ppNewSD);
        }

        //
        // Don't release it if we're returning it...
        //
        if(fFreeOldSD == TRUE && *ppNewSD != pOldSD)
        {
            AccFree(pOldSD);
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   UpdateFileSDByPath
//
//  Synopsis:   Determines the inheritance necessary for the current security
//              descriptor given the path to the object
//
//  Arguments:  [IN  pCurrentSD]        --      The security descriptor to
//                                              update
//              [IN  pwszPath]          --      The path to th object
//              [IN  hFile]             --      Handle to the open file
//              [IN  SeInfo]            --      The security information of
//                                              the current SD.
//              [IN  fIsContainer]      --      Does the Sec. Desc. refer to
//                                              a container?
//              [OUT ppNewSD]           --      Where the new SD is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//  Notes:      The returned security descriptor must be freed via a call to
//              DestroyPrivateObjectSecurity
//
//----------------------------------------------------------------------------
DWORD
UpdateFileSDByPath(IN  PSECURITY_DESCRIPTOR     pCurrentSD,
                   IN  PWSTR                    pwszPath,
                   IN  HANDLE                   hFile,
                   IN  HANDLE                   hProcessToken,
                   IN  SECURITY_INFORMATION     SeInfo,
                   IN  BOOL                     fIsContainer,
                   OUT PSECURITY_DESCRIPTOR    *ppNewSD)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP


    acDebugOut((DEB_TRACE, "In UpdateFileSDByPath\n"));

    PSECURITY_DESCRIPTOR    pSD = pCurrentSD;
    PSECURITY_DESCRIPTOR    pParentSD = NULL;

    if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
       !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
    {
        //
        // We'll have to reopen by path to get this to work properly, since we're
        // now reading the owner/group
        //
        HANDLE  hLocalFile;
        dwErr = OpenFileObject(pwszPath,
                               GetDesiredAccess(READ_ACCESS_RIGHTS,
                                                SeInfo                          |
                                                    OWNER_SECURITY_INFORMATION  |
                                                    GROUP_SECURITY_INFORMATION) |
                                                         FILE_READ_ATTRIBUTES,
                               &hLocalFile,
                               FALSE);

        //
        // If we get back an access denied from the open request, try it with the
        // handle we were given on input
        //
        if(dwErr == ERROR_ACCESS_DENIED)
        {
            hLocalFile = hFile;
            dwErr = ERROR_SUCCESS;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = GetKernelSecurityInfo(hLocalFile,
                                          SeInfo |
                                            OWNER_SECURITY_INFORMATION |
                                            GROUP_SECURITY_INFORMATION,
                                          NULL,
                                          NULL,
                                          &pSD);
            if(hLocalFile != hFile)
            {
                NtClose(hLocalFile);
            }
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Get the parent security descriptor
        //
        ACTRL_RIGHTS_INFO  RightsInfo;
        RightsInfo.SeInfo = SeInfo;
        RightsInfo.pwszProperty = 0;
        dwErr = GetFileParentRights(pwszPath,
                                    &RightsInfo,
                                    1,
                                    NULL,
                                    NULL,
                                    &pParentSD);
    }

    //
    // Finally, do the update
    //
    if(dwErr == ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE_PROP,"Update being called:  Parent info: 0x%lx\n",
                    pParentSD));
        acDebugOut((DEB_TRACE_PROP,"Child: path %ws, 0x%lx\n",
                    pwszPath, pSD));


        //
        // Turn off impersonation here
        //

        HANDLE hThreadToken;

        if (OpenThreadToken(
                 GetCurrentThread(),
                 MAXIMUM_ALLOWED,
                 TRUE,                    // OpenAsSelf
                 &hThreadToken
                 )) {

            //
            // We're impersonating, turn it off and remember the handle
            //

            RevertToSelf();

        } else {

            hThreadToken = NULL;
        }

        if(CreatePrivateObjectSecurityEx(pParentSD,
                                         pSD,
                                         ppNewSD,
                                         NULL,
                                         fIsContainer,
                                         SEF_DACL_AUTO_INHERIT      |
                                             SEF_SACL_AUTO_INHERIT  |
                                             SEF_AVOID_OWNER_CHECK  |
                                             SEF_AVOID_PRIVILEGE_CHECK,
                                         hProcessToken,
                                         &gFileGenMap) == FALSE)
        {
            dwErr = GetLastError();
        }


        if (hThreadToken != NULL)
        {
            (VOID) SetThreadToken (
                      NULL,
                      hThreadToken
                      );

            CloseHandle( hThreadToken );
            hThreadToken = NULL;
        }

        AccFree(pParentSD);
    }

    //
    // See if we had to read a new security descriptor for the object.  If so,
    // we'll need to release that memory as well
    //
    if(pSD != pCurrentSD)
    {
        AccFree(pSD);
    }

    acDebugOut((DEB_TRACE, "Out UpdateFileSDByPath: %ld\n", dwErr));

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\krnctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       krnctx.h
//
//  Contents:   NT Marta kernel context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__KRNCTX_H__)
#define __KRNCTX_H__

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <kernel.h>
#include <assert.h>
#include <ntstatus.h>

//
// CKernelContext.  This represents a LanMan share object to the NT Marta
// infrastructure
//

class CKernelContext
{
public:

    //
    // Construction
    //

    CKernelContext ();

    ~CKernelContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    DWORD InitializeByWmiName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    DWORD InitializeByHandle (HANDLE Handle);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetKernelProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetKernelRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetKernelRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

private:

    //
    // Reference count
    //

    DWORD  m_cRefs;

    //
    // Kernel object handle
    //

    HANDLE m_hObject;

    //
    // Initialized by name
    //

    BOOL   m_fNameInitialized;
};

DWORD
OpenWmiGuidObject(IN  LPWSTR       pwszObject,
                  IN  ACCESS_MASK  AccessMask,
                  OUT PHANDLE      pHandle);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\lmsctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       lmsctx.h
//
//  Contents:   NT Marta LanMan share context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LMSCTX_H__)
#define __LMSCTX_H__

#include <windows.h>
#include <lmsh.h>
#include <assert.h>

//
// CLMShareContext.  This represents a LanMan share object to the NT Marta
// infrastructure
//

class CLMShareContext
{
public:

    //
    // Construction
    //

    CLMShareContext ();

    ~CLMShareContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetLMShareProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetLMShareRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetLMShareRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

private:

    //
    // Reference count
    //

    DWORD       m_cRefs;

    //
    // Parsed machine and share
    //

    LPWSTR      m_pwszMachine;
    LPWSTR      m_pwszShare;
};

//
// Private functions
//

DWORD
LMShareContextParseLMShareName (
       LPCWSTR pwszName,
       LPWSTR* ppMachine,
       LPWSTR* ppLMShare
       );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\ldapsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ldapsp.h
//
//  Contents:   LDAP Scheme Provider definitions
//
//  History:    28-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LDAPSP_H__)
#define __LDAPSP_H__

#include <windows.h>
#include <wininet.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <stdlib.h>

#define LDAP_SCHEME_U L"ldap://"
#define LDAP_SCHEME_UC L"LDAP://"

//
// LDAP Scheme Provider Support API
//

typedef struct _LDAP_URL_COMPONENTS {

    LPWSTR  pwszHost;
    ULONG   Port;
    LPWSTR  pwszDN;
    ULONG   cAttr;
    LPWSTR* apwszAttr;
    ULONG   Scope;
    LPWSTR  pwszFilter;

} LDAP_URL_COMPONENTS, *PLDAP_URL_COMPONENTS;

BOOL
LdapCrackUrl (
    LPCWSTR pwszUrl,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedHost (
    LPWSTR pwszHost,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedDN (
    LPWSTR pwszDN,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedAttributeList (
    LPWSTR pwszAttrList,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedScopeAndFilter (
    LPWSTR pwszScope,
    LPWSTR pwszFilter,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

VOID
LdapFreeUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapGetBindings (
    LPWSTR pwszHost,
    ULONG  Port,
    DWORD  dwRetrievalFlags,
    DWORD  dwTimeout,
    LDAP** ppld
    );

VOID
LdapFreeBindings (
    LDAP* pld
    );

BOOL
LdapBindWithOptionalRediscover (LDAP* pld, LPWSTR pwszHost);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\ldapsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ldapsp.cpp
//
//  Contents:   LDAP Scheme Provider for Remote Object Retrieval
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------

#include <aclpch.hxx>
#pragma hdrstop

#include <ldapsp.h>
#include <shlwapi.h>
//+---------------------------------------------------------------------------
//
//  Function:   LdapCrackUrl
//
//  Synopsis:   Crack an LDAP URL into its relevant parts.  The result must
//              be freed using LdapFreeUrlComponents
//
//----------------------------------------------------------------------------
BOOL
LdapCrackUrl (
    LPCWSTR pwszUrl,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    BOOL   fResult = TRUE;
    ULONG  cbUrl = INTERNET_MAX_PATH_LENGTH;
    LPWSTR pwszHostInfo = NULL;
    LPWSTR pwszDN = NULL;
    LPWSTR pwszAttrList = NULL;
    LPWSTR pwszScope = NULL;
    LPWSTR pwszFilter = NULL;
    LPWSTR pwszToken = NULL;
    WCHAR  pwszBuffer[INTERNET_MAX_PATH_LENGTH+1];
    PWCHAR pwsz = pwszBuffer;
    DWORD  len = 0;
    HRESULT hr;

    //
    // Capture the URL and initialize the out parameter
    //

    if ( wcsncmp( pwszUrl, LDAP_SCHEME_U, wcslen( LDAP_SCHEME_U ) ) == 0 )
    {
        __try
        {
            hr = UrlCanonicalizeW(
                         pwszUrl,
                         pwsz,
                         &cbUrl,
                         ICU_DECODE | URL_WININET_COMPATIBILITY);

            if(FAILED(hr))
            {
                return( FALSE );
            }
        }

        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError( GetExceptionCode() );
            return( FALSE );
        }
    }
    else
    {
        len = wcslen(pwszUrl);

        if (len > INTERNET_MAX_PATH_LENGTH)
        {
            pwsz = new WCHAR [len + 1];

            if (pwsz == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return( FALSE );
            }
        }

        wcscpy(pwsz, pwszUrl);
    }

    memset( pLdapUrlComponents, 0, sizeof( LDAP_URL_COMPONENTS ) );

    //
    // Find the host
    //

    pwszHostInfo = pwsz + sizeof( "ldap://" ) - sizeof( CHAR );
    if ( *pwszHostInfo == L'/' )
    {
        pwszToken = pwszHostInfo + 1;
        pwszHostInfo = NULL;
    }
    else
    {
        pwszHostInfo = wcstok( pwszHostInfo, L"/" );
    }

    //
    // Find the DN
    //

    if ( wcsncmp( pwszUrl, LDAP_SCHEME_U, wcslen( LDAP_SCHEME_U ) ) == 0 )
    {
        if ( pwszToken != NULL )
        {
            pwszDN = L"";

            if ( *pwszToken != L'\0' )
            {
                if ( *pwszToken == L'?' )
                {
                    pwszToken += 1;
                }
                else
                {
                    pwszDN = pwszToken;

                    do
                    {
                        pwszToken += 1;
                    }
                    while ( ( *pwszToken != L'\0' ) && ( *pwszToken != L'?' ) );

                    if ( *pwszToken == L'?' )
                    {
                        *pwszToken = L'\0';
                        pwszToken += 1;
                    }
                }
            }
        }
        else
        {
            pwszDN = wcstok( pwszToken, L"?" );
            pwszToken = NULL;
            if ( pwszDN == NULL )
            {
                SetLastError( E_INVALIDARG );
                return( FALSE );
            }
        }

        //
        // Check for attributes
        //

        if ( pwszToken != NULL )
        {
            if ( *pwszToken == L'?' )
            {
                pwszAttrList = L"";
                pwszToken += 1;
            }
            else if ( *pwszToken == L'\0' )
            {
                pwszAttrList = NULL;
            }
            else
            {
                pwszAttrList = wcstok( pwszToken, L"?" );
                pwszToken = NULL;
            }
        }
        else
        {
            pwszAttrList = wcstok( NULL, L"?" );
        }

        //
        // Check for a scope and filter
        //

        if ( pwszAttrList != NULL )
        {
            pwszScope = wcstok( pwszToken, L"?" );
            if ( pwszScope != NULL )
            {
                pwszFilter = wcstok( NULL, L"?" );
            }
        }

        if ( pwszScope == NULL )
        {
            pwszScope = L"base";
        }

        if ( pwszFilter == NULL )
        {
            pwszFilter = L"(objectClass=*)";
        }
    }
    else
    {
        if ( pwszToken != NULL )
        {
            pwszDN = pwszToken;
        }
        else
        {
            //
            // pwszDN = wcstok( pwszToken, L"\0" );
            //

            pwszDN = pwszHostInfo + wcslen( pwszHostInfo ) + 1;
        }

        pwszAttrList = NULL;
        pwszFilter = L"(objectClass=*)";
        pwszScope = L"base";
    }
    //
    // Now we build up our URL components
    //

    fResult = LdapParseCrackedHost( pwszHostInfo, pLdapUrlComponents );

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedDN( pwszDN, pLdapUrlComponents );
    }

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedAttributeList(
                      pwszAttrList,
                      pLdapUrlComponents
                      );
    }

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedScopeAndFilter(
                      pwszScope,
                      pwszFilter,
                      pLdapUrlComponents
                      );
    }

    if ( fResult != TRUE )
    {
        LdapFreeUrlComponents( pLdapUrlComponents );
    }

    if (pwsz != pwszBuffer)
    {
        delete pwsz;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedHost
//
//  Synopsis:   Parse the cracked host string (pwszHost is modified)
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedHost (
    LPWSTR pwszHost,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    LPWSTR pwszPort;

    if ( pwszHost == NULL )
    {
        pLdapUrlComponents->pwszHost = NULL;
        pLdapUrlComponents->Port = LDAP_PORT;
        return( TRUE );
    }

    pwszPort = wcschr( pwszHost, L':' );
    if ( pwszPort != NULL )
    {
        *pwszPort = L'\0';
        pwszPort++;
    }

    pLdapUrlComponents->pwszHost = new WCHAR [wcslen( pwszHost ) + 1];
    if ( pLdapUrlComponents->pwszHost == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszHost, pwszHost );
    pLdapUrlComponents->Port = 0;

    if ( pwszPort != NULL )
    {
        pLdapUrlComponents->Port = _wtol( pwszPort );
    }

    if ( pLdapUrlComponents->Port == 0 )
    {
        pLdapUrlComponents->Port = LDAP_PORT;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedDN
//
//  Synopsis:   Parse the cracked DN
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedDN (
    LPWSTR pwszDN,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    pLdapUrlComponents->pwszDN = new WCHAR [wcslen( pwszDN ) + 1];
    if ( pLdapUrlComponents->pwszDN == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszDN, pwszDN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedAttributeList
//
//  Synopsis:   Parse the cracked attribute list
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedAttributeList (
    LPWSTR pwszAttrList,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    LPWSTR pwsz;
    LPWSTR pwszAttr;
    ULONG  cAttr = 0;
    ULONG  cCount;

    if ( ( pwszAttrList == NULL ) || ( wcslen( pwszAttrList ) == 0 ) )
    {
        pLdapUrlComponents->cAttr = 0;
        pLdapUrlComponents->apwszAttr = NULL;
        return( TRUE );
    }

    pwsz = new WCHAR [wcslen( pwszAttrList ) + 1];
    if ( pwsz == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pwsz, pwszAttrList );

    pwszAttr = wcstok( pwsz, L"," );
    while ( pwszAttr != NULL )
    {
        cAttr += 1;
        pwszAttr = wcstok( NULL, L"," );
    }

    pLdapUrlComponents->apwszAttr = new LPWSTR [cAttr+1];
    if ( pLdapUrlComponents->apwszAttr == NULL )
    {
        delete pwsz;
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    pLdapUrlComponents->cAttr = cAttr;
    for ( cCount = 0; cCount < cAttr; cCount++ )
    {
        pLdapUrlComponents->apwszAttr[cCount] = pwsz;
        pwsz += ( wcslen(pwsz) + 1 );
    }

    pLdapUrlComponents->apwszAttr[cAttr] = NULL;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedScopeAndFilter
//
//  Synopsis:   Parse the cracked scope and filter
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedScopeAndFilter (
    LPWSTR pwszScope,
    LPWSTR pwszFilter,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    ULONG Scope;

    if ( _wcsicmp( pwszScope, L"base" ) == 0 )
    {
        Scope = LDAP_SCOPE_BASE;
    }
    else if ( _wcsicmp( pwszScope, L"one" ) == 0 )
    {
        Scope = LDAP_SCOPE_ONELEVEL;
    }
    else if ( _wcsicmp( pwszScope, L"sub" ) == 0 )
    {
        Scope = LDAP_SCOPE_SUBTREE;
    }
    else
    {
        SetLastError( E_INVALIDARG );
        return( FALSE );
    }

    pLdapUrlComponents->pwszFilter = new WCHAR [wcslen( pwszFilter ) + 1];
    if ( pLdapUrlComponents->pwszFilter == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszFilter, pwszFilter );
    pLdapUrlComponents->Scope = Scope;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeUrlComponents
//
//  Synopsis:   Frees allocate URL components returned from LdapCrackUrl
//
//----------------------------------------------------------------------------
VOID
LdapFreeUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    delete pLdapUrlComponents->pwszHost;
    delete pLdapUrlComponents->pwszDN;

    if ( pLdapUrlComponents->apwszAttr != NULL )
    {
        delete pLdapUrlComponents->apwszAttr[0];
    }

    delete pLdapUrlComponents->apwszAttr;
    delete pLdapUrlComponents->pwszFilter;
}


//+---------------------------------------------------------------------------
//
//  Function:   LdapGetBindings
//
//  Synopsis:   allocates and initializes the LDAP session binding
//
//----------------------------------------------------------------------------
BOOL
LdapGetBindings (
    LPWSTR pwszHost,
    ULONG Port,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,
    LDAP** ppld
    )
{
    BOOL  fResult = TRUE;
    LDAP* pld;

    pld = ldap_initW( pwszHost, Port );
    if ( pld != NULL )
    {
        ULONG ldaperr;

        if ( dwTimeout != 0 )
        {
            ldap_set_option( pld, LDAP_OPT_TIMELIMIT, (void *)&dwTimeout );
        }

        fResult = LdapBindWithOptionalRediscover( pld, pwszHost );
    }
    else
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *ppld = pld;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeBindings
//
//  Synopsis:   frees allocated LDAP session binding
//
//----------------------------------------------------------------------------
VOID
LdapFreeBindings (
    LDAP* pld
    )
{
    if ( pld != NULL )
    {
        ldap_unbind_s( pld );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapBindWithOptionalRediscover
//
//  Synopsis:   bind to the host with optional DC rediscovery if the host is
//              NULL (which means use default via DsGetDcName)
//
//----------------------------------------------------------------------------
BOOL
LdapBindWithOptionalRediscover (LDAP* pld, LPWSTR pwszHost)
{
    BOOL  fResult = TRUE;
    ULONG ldaperr;
    ULONG ldapsaveerr;
    DWORD dwFlags = DS_FORCE_REDISCOVERY;

    ldaperr = ldap_bind_sW(
                   pld,
                   NULL,
                   NULL,
                   LDAP_AUTH_SSPI
                   );

    if ( ( ldaperr != LDAP_SUCCESS ) && ( pwszHost == NULL ) )
    {
        ldapsaveerr = ldaperr;

        ldaperr = ldap_set_option(
                       pld,
                       LDAP_OPT_GETDSNAME_FLAGS,
                       (LPVOID)&dwFlags
                       );

        if ( ldaperr == LDAP_SUCCESS )
        {
            ldaperr = ldap_bind_sW(
                           pld,
                           NULL,
                           NULL,
                           LDAP_AUTH_SSPI
                           );
        }
        else
        {
            ldaperr = ldapsaveerr;
        }
    }

    if ( ldaperr != LDAP_SUCCESS )
    {
        fResult = FALSE;
        SetLastError( LdapMapErrorToWin32(ldaperr) );
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\lmsctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       lmsctx.cpp
//
//  Contents:   Implementation of CLMShareContext and NT Marta LanMan Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <lmshare.h>
#include <lmcons.h>
#include <lmsctx.h>
#include <svcctx.h>
//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::CLMShareContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLMShareContext::CLMShareContext ()
{
    m_cRefs = 1;
    m_pwszMachine = NULL;
    m_pwszShare = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::~CLMShareContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLMShareContext::~CLMShareContext ()
{
    if ( m_pwszMachine != NULL )
    {
        delete m_pwszMachine;
    }

    if ( m_pwszShare != NULL )
    {
        delete m_pwszShare;
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the lanman share
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    return( LMShareContextParseLMShareName(
                   pObjectName,
                   &m_pwszMachine,
                   &m_pwszShare
                   ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::GetLMShareProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::GetLMShareProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::GetLMShareRights, public
//
//  Synopsis:   get the LMShare security descriptor
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::GetLMShareRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    DWORD                 Result;
    PSHARE_INFO_502       psi = NULL;
    PISECURITY_DESCRIPTOR pisd = NULL;
    PSECURITY_DESCRIPTOR  psd = NULL;
    DWORD                 cb = 0;

    assert( m_pwszShare != NULL );

    Result = NetShareGetInfo( m_pwszMachine, m_pwszShare, 502, (PBYTE *)&psi );

    if ( Result == ERROR_SUCCESS )
    {
        if ( psi->shi502_security_descriptor == NULL )
        {
            *ppSecurityDescriptor = NULL;
            Result = ERROR_SUCCESS;
            goto Cleanup;
        }

        pisd = (PISECURITY_DESCRIPTOR)psi->shi502_security_descriptor;
        if ( pisd->Control & SE_SELF_RELATIVE )
        {
            cb = GetSecurityDescriptorLength( psi->shi502_security_descriptor );
            psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
            if ( psd == NULL )
            {
                Result = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }

            memcpy( psd, psi->shi502_security_descriptor, cb );
        }
        else
        {
            if ( MakeSelfRelativeSD(
                     psi->shi502_security_descriptor,
                     NULL,
                     &cb
                     ) == FALSE )
            {
                if ( cb > 0 )
                {
                    psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
                    if ( psd != NULL )
                    {
                        if ( MakeSelfRelativeSD(
                                 psi->shi502_security_descriptor,
                                 psd,
                                 &cb
                                 ) == FALSE )
                        {
                            LocalFree( psd );
                            Result = GetLastError();
                            goto Cleanup;
                        }
                    }
                    else
                    {
                        Result = ERROR_OUTOFMEMORY;
                        goto Cleanup;
                    }
                }
                else
                {
                    Result = GetLastError();
                    goto Cleanup;
                }
            }
            else
            {
                assert( FALSE && "Should not get here!" );
                Result = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        *ppSecurityDescriptor = psd;
    }

Cleanup:

    if (psi != NULL) 
    {
        NetApiBufferFree(psi);
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::SetLMShareRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::SetLMShareRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    DWORD           Result;
    SHARE_INFO_1501 si;

    si.shi1501_reserved = 0;
    si.shi1501_security_descriptor = pSecurityDescriptor;

    Result = NetShareSetInfo(
                m_pwszMachine,
                m_pwszShare,
                1501,
                (PBYTE)&si,
                NULL
                );

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Function:   LMShareContextParseLMShareName
//
//  Synopsis:   parse the service name and machine
//
//----------------------------------------------------------------------------
DWORD
LMShareContextParseLMShareName (
       LPCWSTR pwszName,
       LPWSTR* ppMachine,
       LPWSTR* ppLMShare
       )
{
    return( StandardContextParseName( pwszName, ppMachine, ppLMShare ) );
}

//
// Functions from LMShare.h which dispatch unto the CLMShareContext class
//

DWORD
MartaAddRefLMShareContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CLMShareContext *)Context )->AddRef() );
}

DWORD
MartaCloseLMShareContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CLMShareContext *)Context )->Release() );
}

DWORD
MartaGetLMShareProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CLMShareContext *)Context )->GetLMShareProperties( pProperties ) );
}

DWORD
MartaGetLMShareTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetLMShareRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CLMShareContext *)Context )->GetLMShareRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenLMShareNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CLMShareContext* pLMShareContext;

    pLMShareContext = new CLMShareContext;
    if ( pLMShareContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pLMShareContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pLMShareContext->Release();
        return( Result );
    }

    *pContext = pLMShareContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetLMShareRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CLMShareContext *)Context )->SetLMShareRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\krnctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       krnctx.cpp
//
//  Contents:   Implementation of CKernelContext and NT Marta Kernel Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <krnctx.h>
#include <wmistr.h>
#include <wmiumkm.h>
//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::CKernelContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CKernelContext::CKernelContext ()
{
    m_cRefs = 1;
    m_hObject = NULL;
    m_fNameInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::~CKernelContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CKernelContext::~CKernelContext ()
{
    if ( ( m_hObject != NULL ) && ( m_fNameInitialized == TRUE ) )
    {
        CloseHandle( m_hObject );
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the Kernel
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    DWORD LastError;

    m_fNameInitialized = TRUE;

    m_hObject = OpenMutexW( AccessMask, FALSE, pObjectName );
    if ( m_hObject != NULL )
    {
        return( ERROR_SUCCESS );
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenEventW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }
    else
    {
        goto ErrorReturn;
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenSemaphoreW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }
    else
    {
        goto ErrorReturn;
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenFileMappingW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }
    else
    {
        goto ErrorReturn;
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenJobObjectW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }
    else
    {
        goto ErrorReturn;
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenWaitableTimerW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }

    LastError = GetLastError();

ErrorReturn:

    m_fNameInitialized = FALSE;

    return( LastError );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::InitializeByWmiName, public
//
//  Synopsis:   initlialize a WMI kernel context
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::InitializeByWmiName (
                          LPCWSTR pObjectName,
                          ACCESS_MASK AccessMask
                          )
{
    DWORD  Result;
    HANDLE hObject;

    Result = OpenWmiGuidObject( (LPWSTR)pObjectName, AccessMask, &hObject );

    if ( Result == ERROR_SUCCESS )
    {
        m_hObject = hObject;
        m_fNameInitialized = TRUE;
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::InitializeByHandle, public
//
//  Synopsis:   initialize the context given a Kernel handle
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::InitializeByHandle (HANDLE Handle)
{
    m_hObject = Handle;

    assert( m_fNameInitialized == FALSE );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::GetKernelProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::GetKernelProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::GetKernelRights, public
//
//  Synopsis:   get the Kernel security descriptor
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::GetKernelRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    BOOL                 fResult;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                cb = 0;

    assert( m_hObject != NULL );

    fResult = GetKernelObjectSecurity(
                 m_hObject,
                 SecurityInfo,
                 pSecurityDescriptor,
                 0,
                 &cb
                 );

    if ( ( fResult == FALSE ) && ( cb > 0 ) )
    {
        assert( ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ||
                ( GetLastError() == STATUS_BUFFER_TOO_SMALL ) );

        pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
        if ( pSecurityDescriptor == NULL )
        {
            return( ERROR_OUTOFMEMORY );
        }

        fResult = GetKernelObjectSecurity(
                     m_hObject,
                     SecurityInfo,
                     pSecurityDescriptor,
                     cb,
                     &cb
                     );
    }
    else
    {
        assert( fResult == FALSE );

        return( GetLastError() );
    }

    if ( fResult == TRUE )
    {
        *ppSecurityDescriptor = pSecurityDescriptor;
    }
    else
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::SetKernelRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::SetKernelRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    assert( m_hObject != NULL );

    if ( SetKernelObjectSecurity(
            m_hObject,
            SecurityInfo,
            pSecurityDescriptor
            ) == FALSE )
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//
// Functions from Kernel.h which dispatch unto the CKernelContext class
//

DWORD
MartaAddRefKernelContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CKernelContext *)Context )->AddRef() );
}

DWORD
MartaCloseKernelContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CKernelContext *)Context )->Release() );
}

DWORD
MartaGetKernelProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CKernelContext *)Context )->GetKernelProperties( pProperties ) );
}

DWORD
MartaGetKernelTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetKernelRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CKernelContext *)Context )->GetKernelRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenKernelNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CKernelContext* pKernelContext;

    pKernelContext = new CKernelContext;
    if ( pKernelContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pKernelContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pKernelContext->Release();
        return( Result );
    }

    *pContext = pKernelContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenKernelHandleObject(
    IN HANDLE   Handle,
    IN ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CKernelContext* pKernelContext;

    pKernelContext = new CKernelContext;
    if ( pKernelContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pKernelContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pKernelContext->Release();
        return( Result );
    }

    *pContext = pKernelContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetKernelRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CKernelContext *)Context )->SetKernelRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}

//
// Routines provided by AlanWar for accessing WmiGuid objects
//

HANDLE RWmiGuidHandle = NULL;

_inline HANDLE WmipAllocEvent(
    VOID
    )
{
    HANDLE EventHandle;

    EventHandle = (HANDLE)InterlockedExchangePointer(( PVOID *)&RWmiGuidHandle, NULL );

    if ( EventHandle == NULL ) {

        EventHandle = CreateEvent( NULL, FALSE, FALSE, NULL );
    }

    return( EventHandle );
}

_inline void WmipFreeEvent(
    HANDLE EventHandle
    )
{
    if ( InterlockedCompareExchangePointer( &RWmiGuidHandle,
                                            EventHandle,
                                            NULL) != NULL ) {

        CloseHandle( EventHandle );
    }
}

ULONG RWmipSendWmiKMRequest(
    ULONG Ioctl,
    PVOID Buffer,
    ULONG InBufferSize,
    ULONG MaxBufferSize,
    ULONG *ReturnSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input and output buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED Overlapped;
    ULONG Status;
    BOOL IoctlSuccess;
    HANDLE WmipKMHandle = NULL;
    //
    // If device is not open for then open it now. The
    // handle is closed in the process detach dll callout (DlllMain)
    WmipKMHandle = CreateFile(WMIDataDeviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                              FILE_FLAG_OVERLAPPED,
                              NULL);
    if (WmipKMHandle == (HANDLE)-1)
    {
        WmipKMHandle = NULL;
        return(GetLastError());
    }

    Overlapped.hEvent = WmipAllocEvent();
    if (Overlapped.hEvent == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    do
    {
        IoctlSuccess = DeviceIoControl(WmipKMHandle,
                              Ioctl,
                              Buffer,
                              InBufferSize,
                              Buffer,
                              MaxBufferSize,
                              ReturnSize,
                              &Overlapped);

        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                               &Overlapped,
                                               ReturnSize,
                                               TRUE);
        }

        if (! IoctlSuccess)
        {
            Status = GetLastError();
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);


    NtClose( WmipKMHandle );

    WmipFreeEvent(Overlapped.hEvent);

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenWmiGuidObject
//
//  Synopsis:   Gets a handle to the specified WmiGuid object
//
//  Arguments:  [IN  pwszObject]        --      Object to open
//              [IN  AccessMask]        --      Type of open to do
//              [OUT pHandle]           --      Where the handle to the object
//                                              is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
OpenWmiGuidObject(IN  LPWSTR       pwszObject,
                  IN  ACCESS_MASK  AccessMask,
                  OUT PHANDLE      pHandle)
{
    DWORD dwErr;
    UNICODE_STRING GuidString;
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    WCHAR GuidObjectNameBuffer[WmiGuidObjectNameLength+1];
    PWCHAR GuidObjectName = GuidObjectNameBuffer;
    ULONG ReturnSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Length;

    Length = (wcslen(WmiGuidObjectDirectory) + wcslen(pwszObject) + 1) * sizeof(WCHAR);

    if ( Length > sizeof(GuidObjectNameBuffer) ) 
    {
        GuidObjectName = (PWCHAR)LocalAlloc( LPTR, Length );

        if ( GuidObjectName == NULL ) 
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    wcscpy(GuidObjectName, WmiGuidObjectDirectory);
    wcscat(GuidObjectName, pwszObject);	
    RtlInitUnicodeString(&GuidString, GuidObjectName);
	
    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &GuidString;
	
    WmiOpenGuidBlock.ObjectAttributes = &ObjectAttributes;

    WmiOpenGuidBlock.DesiredAccess = AccessMask;

    dwErr = RWmipSendWmiKMRequest(IOCTL_WMI_OPEN_GUID,
                                     (PVOID)&WmiOpenGuidBlock,
                                     sizeof(WMIOPENGUIDBLOCK),
                                     sizeof(WMIOPENGUIDBLOCK),
                                     &ReturnSize);

    if (dwErr == ERROR_SUCCESS)
    {
        *pHandle = WmiOpenGuidBlock.Handle.Handle;
    }
    else
    {
        *pHandle = NULL;
    }

    if ( GuidObjectName != GuidObjectNameBuffer )
    {
        LocalFree( GuidObjectName );
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\lmshare.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       lmshare.cxx
//
//  Contents:   local functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <lmerr.h>
#include <lmcons.h>

//+---------------------------------------------------------------------------
//
//  Function:   PingLmShare
//
//  Synopsis:   Determines whether the given share is a Lanman share or not...
//
//  Arguments:  [IN  pwszShare]   --  The name of the share to ping
//
//  Returns:    ERROR_SUCCESS       --  The share is lanman
//              ERROR_INVALID_NAME  --  The format of the name is unrecognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
PingLmShare( IN LPCWSTR     pwszShareName)
{
    acDebugOut((DEB_TRACE, "in PingLmShare\n"));

    DWORD   dwErr;

    dwErr = LoadDLLFuncTable();
    if(dwErr != NO_ERROR)
    {
        return(dwErr);
    }

    if(pwszShareName != NULL)
    {
        //
        // save the object since we must crack it to go to remote machines
        //
        WCHAR   wszUseName[RMLEN + 1];
        LPWSTR  pwszUseName;

        dwErr = AccGetBufferOfSizeW((PWSTR)pwszShareName,
                                    wszUseName,
                                    &pwszUseName);
        if(dwErr == ERROR_SUCCESS)
        {
            PWSTR   pwszShare, pwszMachine;

            //
            // get the machinename from the full name
            //
            dwErr = ParseName(pwszUseName,
                              &pwszMachine,
                              &pwszShare);
            if(dwErr == ERROR_SUCCESS)
            {
                PSHARE_INFO_0 pSI0;

                //
                // get share infolevel 0
                //
                dwErr = (*DLLFuncs.PNetShareGetInfo)(pwszMachine,
                                                     pwszShare,
                                                     0,
                                                     (PBYTE *)&pSI0);
                if(dwErr == ERROR_SUCCESS)
                {
                    (*DLLFuncs.PNetApiBufferFree)(pSI0);
                }
                else
                {
                    if(dwErr == NERR_NetNameNotFound)
                    {
                        dwErr = ERROR_PATH_NOT_FOUND;
                    }

                    //
                    // Any other error will be returned to the calling
                    // API
                    //
                }
            }
            AccFreeBufferOfSizeW(wszUseName,
                                 pwszUseName);
        }
    }
    else
    {
        dwErr = ERROR_INVALID_NAME;
    }

    acDebugOut((DEB_TRACE, "Out PingLmShare(%d)\n", dwErr));

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadSharePropertyRights
//
//  Synopsis:   Gets the specified security info for the specified net share
//              object
//
//  Arguments:  [IN  pwszShare]         --      The share to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadSharePropertyRights(IN  LPWSTR                pwszShare,
                        IN  PACTRL_RIGHTS_INFO    pRightsList,
                        IN  ULONG                 cRights,
                        IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadSharePropertyRights\n"));

    DWORD dwErr;
    PSHARE_INFO_502 pSI502;

    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }


    //
    // For the moment, there is only the share itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if(pwszShare != NULL)
    {
        WCHAR   wszName[MAX_PATH + 1];
        PWSTR   pwszName;
        //
        // save the object since we must crack it to go to remote machines
        //
        dwErr = AccGetBufferOfSizeW(pwszShare,
                                    wszName,
                                    &pwszName);
        if(dwErr == ERROR_SUCCESS)
        {
            PWSTR   pwszShr, pwszMachine;

            //
            // Separate the names
            //
            dwErr = ParseName(pwszName,
                              &pwszMachine,
                              &pwszShr);

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // get share infolevel 502 (a bunch of stuff) since
                // level 1501 seems to be write only
                //
                PSHARE_INFO_0 pSI0;
                dwErr = (*DLLFuncs.PNetShareGetInfo)(pwszMachine,
                                                     pwszShr,
                                                     502,
                                                     (PBYTE *)&pSI502);
                if(dwErr == ERROR_SUCCESS &&
                                    pSI502->shi502_security_descriptor != NULL)
                {
                    //
                    // Add it
                    //
                    dwErr = AccessList.AddSD(
                                          pSI502->shi502_security_descriptor,
                                          pRightsList->SeInfo,
                                          pRightsList->pwszProperty);

                    (*DLLFuncs.PNetApiBufferFree)(pSI502);
                }
            }

            AccFreeBufferOfSizeW(wszName, pwszName);
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    acDebugOut((DEB_TRACE, "Out ReadSharePropertyRights: %lu\n", dwErr));
    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetShareParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for share objects
//
//  Arguments:  [IN  pwszShare]         --      The share to get the parent
//                                              for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_INVALID_FUNCTION  --      Call doesn't make sense here
//
//----------------------------------------------------------------------------
DWORD
GetShareParentRights(IN  LPWSTR                    pwszShare,
                      IN  PACTRL_RIGHTS_INFO       pRightsList,
                      IN  ULONG                    cRights,
                      OUT PACL                    *ppDAcl,
                      OUT PACL                    *ppSAcl,
                      OUT PSECURITY_DESCRIPTOR    *ppSD)
{
    //
    // This doesn't currently make sense for share objects, so simply
    // return an error
    //
    return(ERROR_INVALID_FUNCTION);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetShareSecurityInfo
//
//  Synopsis:   Sets the specified security info on the specified share
//              object
//
//  Arguments:  [IN  pwszShare]         --      Share to set it on
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetShareSecurityInfo(IN  PWSTR                     pwszShare,
                     IN  SECURITY_INFORMATION      SeInfo,
                     IN  PWSTR                     pwszProperty,
                     IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetShareSecurityInfo \n"));

    DWORD           dwErr = ERROR_SUCCESS;
    SHARE_INFO_1501 SI1501;

    //
    // Net shares don't have properties
    //
    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwErr = LoadDLLFuncTable();
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

        if(pwszShare != NULL)
        {
            WCHAR   wszName[MAX_PATH + 1];
            PWSTR   pwszName;
            //
            // save the object since we must crack it to go to remote machines
            //
            dwErr = AccGetBufferOfSizeW(pwszShare,
                                        wszName,
                                        &pwszName);
            if(dwErr == ERROR_SUCCESS)
            {
                PWSTR   pwszShr, pwszMachine;

                //
                // Separate the names
                //
                dwErr = ParseName(pwszName,
                                  &pwszMachine,
                                  &pwszShr);
                if(dwErr == ERROR_SUCCESS)
                {
                    SI1501.shi1501_reserved = 0;
                    SI1501.shi1501_security_descriptor = pSD;

                    //
                    // set the security descriptor
                    //
                    dwErr = (*DLLFuncs.PNetShareSetInfo)(pwszMachine,
                                                          pwszShr,
                                                          1501,
                                                          (PBYTE)&SI1501,
                                                          NULL);
                }

                AccFreeBufferOfSizeW(wszName, pwszName);

            }
            else
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }
    acDebugOut((DEB_TRACE, "Out SetShareSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\martabas.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       MARTABAS.CXX
//
//  Contents:   Implementation of the base MARTA funcitons
//
//  History:    22-Jul-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <ntprov.hxx>
#include <strings.h>
#include <ntdsguid.h>


CSList      gWrkrList(NtProvFreeWorkerItem); // List of active worker threads

//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetCapabilities
//
//  Synopsis:   Gets the provider capabilities
//
//  Arguments:  [IN  fClass]        --  Class of capabilities to request
//              [OUT pulCaps]       --  Provider capabilities
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
AccProvGetCapabilities(IN  ULONG       fClass,
                       OUT PULONG      pulCaps)
{
    acDebugOut((DEB_TRACE_API,"in.out AccProvGetCapabilities\n"));

    if(fClass == ACTRL_CLASS_GENERAL)
    {
        *pulCaps = ACTRL_CAP_KNOWS_SIDS | ACTRL_CAP_SUPPORTS_HANDLES;
    }
    else
    {
        *pulCaps = ACTRL_CAP_NONE;
    }

    return;
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvIsObjectAccessible
//
//  Synopsis:   Determines if the given path is accessible or not
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//
//  Returns:    ERROR_SUCCESS           --  The path is recognized
//              ERROR_PATH_NOT_FOUND    --  The path was not recognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvIsObjectAccessible(IN  LPCWSTR           pwszObjectPath,
                          IN  SE_OBJECT_TYPE    ObjectType)
{
    acDebugOut((DEB_TRACE_API,"in AccProvIsObjectAccessible\n"));
    DWORD   dwErr = ERROR_PATH_NOT_FOUND;
    PWSTR   DsServerlessPath, OldServerPath = NULL;

    static  NTMARTA_ACCESS_CACHE    rgAccessCache[MAX_ACCESS_ENTRIES];
    static  ULONG                   cCacheEntries = 0;
    static  ULONG                   iCacheOldest  = 0;


    //
    // First, check our cache.  Maybe we can get out cheap.  Note that
    // we expect our result to be failure when we start.
    //
    ULONG   dwObjLen = wcslen(pwszObjectPath);
    if(dwObjLen < MAX_PATH)
    {
        RtlAcquireResourceShared(&gCacheLock, TRUE);
        for(ULONG iIndex = 0;
            iIndex < cCacheEntries && dwErr == ERROR_PATH_NOT_FOUND;
            iIndex++)
        {
            //
            // We'll have to do this base on object type...
            //
            switch(ObjectType)
            {
                case SE_SERVICE:
                case SE_PRINTER:
                case SE_REGISTRY_KEY:
                    //
                    // See if it's a UNC name, in which case we'll compare
                    // the only the server\\share name.
                    //
                    if(dwObjLen > 1 && pwszObjectPath[1] == L'\\')
                    {
                        //
                        // It's a UNC name
                        //
                        if(_wcsnicmp(pwszObjectPath,
                                     rgAccessCache[iIndex].wszPath,
                                     rgAccessCache[iIndex].cLen) == 0 &&
                           (*(pwszObjectPath + rgAccessCache[iIndex].cLen)
                                                                  == L'\0' ||
                            *(pwszObjectPath + rgAccessCache[iIndex].cLen)
                                                                  == L'\\'))
                        {
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    else
                    {
                        if(_wcsicmp(pwszObjectPath,
                                    rgAccessCache[iIndex].wszPath) == 0)
                        {
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    break;

                case SE_DS_OBJECT:
                case SE_DS_OBJECT_ALL:
                    //
                    // These have to match exact.  Handle the case where we were given a
                    // server name prefixed DS path
                    //
                    if(IS_UNC_PATH(pwszObjectPath, dwObjLen ) )
                    {
                        DsServerlessPath = wcschr(pwszObjectPath+2, L'\\');

                        if(DsServerlessPath != NULL)
                        {
                            DsServerlessPath++;
                            OldServerPath = ( PWSTR )pwszObjectPath;
                            pwszObjectPath = DsServerlessPath;
                            dwObjLen = wcslen(DsServerlessPath);
                        }
                    }

                    if(dwObjLen == rgAccessCache[iIndex].cLen &&
                       _wcsicmp(pwszObjectPath,
                                rgAccessCache[iIndex].wszPath) == 0)
                    {
                        dwErr = ERROR_SUCCESS;
                    }

                    break;


                case SE_FILE_OBJECT:
                case SE_KERNEL_OBJECT:
                case SE_LMSHARE:
                case SE_WMIGUID_OBJECT:

                    if(dwObjLen == rgAccessCache[iIndex].cLen &&
                       _wcsicmp(pwszObjectPath,
                                rgAccessCache[iIndex].wszPath) == 0)
                    {
                        dwErr = ERROR_SUCCESS;
                    }

                    break;
            }

            //
            // Make sure our types match...
            //
            if(dwErr == ERROR_SUCCESS && ObjectType != rgAccessCache[iIndex].ObjectType)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
#ifdef DBG
            if(dwErr == ERROR_SUCCESS)
            {
                acDebugOut((DEB_TRACE_CACHE, "Object %ws [%lu] found in cache!\n",
                            rgAccessCache[iIndex].wszPath,
                            rgAccessCache[iIndex].ObjectType));
            }
#endif

        }

        RtlReleaseResource(&gCacheLock);
    }

    //
    // If we got a match, return
    //
    if(dwErr == ERROR_SUCCESS)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Well, that didn't work, so we'll have to go check.  Note that there
    // is not a lock here, so there is a window whereby an entry could be added
    // for the path that we are currently checking.  If that happens, it only
    // means that the same entry will be in the cache more than once.  This
    // is harmless.
    //
    HANDLE  hHandle;

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
        dwErr = IsFilePathLocalOrLM((PWSTR)pwszObjectPath);
        break;

    case SE_SERVICE:
        dwErr = OpenServiceObject((PWSTR)pwszObjectPath,
                                  SERVICE_USER_DEFINED_CONTROL,
                                  (SC_HANDLE *)&hHandle);
        if(dwErr == ERROR_SUCCESS)
        {
            CloseServiceHandle((SC_HANDLE)hHandle);
        }
        else
        {
            if(dwErr == ERROR_SERVICE_DOES_NOT_EXIST ||
               dwErr == ERROR_INVALID_NAME)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
        }
        break;

    case SE_PRINTER:
        dwErr = OpenPrinterObject((PWSTR)pwszObjectPath,
                                  PRINTER_ACCESS_USE,
                                  &hHandle);
        if(dwErr == ERROR_SUCCESS)
        {
            ClosePrinter(hHandle);
        }
        else
        {
            if(dwErr == ERROR_INVALID_PRINTER_NAME)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
        }
        break;

    case SE_REGISTRY_KEY:
        dwErr = OpenRegistryObject((PWSTR)pwszObjectPath,
                                   KEY_EXECUTE,
                                   &hHandle);
        if(dwErr == ERROR_SUCCESS)
        {
            RegCloseKey((HKEY)hHandle);
        }
        else
        {
            if(dwErr == ERROR_INVALID_PARAMETER ||
               dwErr == ERROR_FILE_NOT_FOUND)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }

        }

        break;

    case SE_LMSHARE:
        //
        // Note that this doesn't have to be a local share, just a lan man
        // share
        //
        dwErr = PingLmShare(pwszObjectPath);

        break;

    case SE_KERNEL_OBJECT:                          // FALL THROUGH
    case SE_WMIGUID_OBJECT:

        //
        // Can't have kernel objects outside of NT, so just return success
        //
        dwErr = ERROR_SUCCESS;
        break;

    case SE_DS_OBJECT:                              // FALL THROUGH
    case SE_DS_OBJECT_ALL:
        dwErr = PingDSObj(OldServerPath ? OldServerPath : pwszObjectPath);
        break;

    default:

        //
        // Unknown object type.  Pass it on.
        //
        dwErr = ERROR_PATH_NOT_FOUND;
        break;
    }


    if(dwErr == ERROR_ACCESS_DENIED)
    {

        dwErr = ERROR_SUCCESS;
    }

    //
    // Add it to the cache, if we succeeded
    //
    if(dwErr == ERROR_SUCCESS &&
       (ObjectType != SE_KERNEL_OBJECT || ObjectType != SE_WMIGUID_OBJECT))
    {
        //
        // Lock the cache
        //
        RtlAcquireResourceExclusive(&gCacheLock, TRUE);

        //
        // For some items, we'll want to save the root of the path, since it
        // is not possible to have linked services, registry keys, etc, while
        // for files and shares, it can cause problems.  If an entry is too
        // long to be cached, we'll ignore it.
        //

        if(dwObjLen <= MAX_PATH)
        {
            //
            // Save off the object type and path name.  For those that
            // need it, we'll go through and shorten them as requried.
            //
            rgAccessCache[iCacheOldest].ObjectType = ObjectType;
            wcscpy(rgAccessCache[iCacheOldest].wszPath,
                   pwszObjectPath);
            rgAccessCache[iCacheOldest].cLen = dwObjLen;

            PWSTR   pwszLop = rgAccessCache[iCacheOldest].wszPath;
            switch (ObjectType)
            {
                case SE_SERVICE:
                case SE_PRINTER:
                case SE_REGISTRY_KEY:
                    //
                    // See if it's a UNC name, in which case we'll lop
                    // it off
                    //
                    if(IS_UNC_PATH(pwszObjectPath, dwObjLen))
                    {
                        //
                        // It's a UNC name, so lop it off
                        //
                        pwszLop = wcschr(pwszLop + 2,
                                         L'\\');
                        if(pwszLop != NULL)
                        {
                            pwszLop = wcschr(pwszLop + 1, '\\');

                            if(pwszLop != NULL)
                            {
                                *pwszLop = L'\0';
                                rgAccessCache[iCacheOldest].cLen = (DWORD)(pwszLop -
                                          rgAccessCache[iCacheOldest].wszPath);
                            }
                        }
                    }
                    break;

                case SE_DS_OBJECT:
                case SE_DS_OBJECT_ALL:
                    //
                    // Save off the domain name part
                    //

                    //
                    // Note that we'll get the object in RDN format, so
                    // it's a simple matter to lop it off if necessary
                    pwszLop = wcschr(pwszLop, L'\\');
                    if(pwszLop != NULL)
                    {
                        *pwszLop = L'\0';
                        rgAccessCache[iCacheOldest].cLen = (DWORD)(pwszLop -
                                          rgAccessCache[iCacheOldest].wszPath);
                    }
                    break;
            }

            //
            // Update our indexes and counts
            //
            if(cCacheEntries < MAX_ACCESS_ENTRIES)
            {
                cCacheEntries++;
            }

            iCacheOldest++;
            if(iCacheOldest == MAX_ACCESS_ENTRIES)
            {
                iCacheOldest = 0;
            }
        }

        RtlReleaseResource(&gCacheLock);
    }

    if ( dwErr == ERROR_INVALID_NAME ) {

        acDebugOut(( DEB_ERROR, "%ws returned ERROR_INVALID_NAME\n", pwszObjectPath ));
        ASSERT( FALSE );

    }
    acDebugOut((DEB_TRACE_API,"out AccProvIsObjectAccessible: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleIsObjectAccessible
//
//  Synopsis:   Determines if the given object is accessible or not given
//              a handle to it
//
//  Arguments:  [IN  hObject]           --  Object handle
//              [IN  ObjectType]        --  Type of the object
//
//  Returns:    ERROR_SUCCESS           --  The path is recognized
//              ERROR_PATH_NOT_FOUND    --  The path was not recognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleIsObjectAccessible(IN  HANDLE            hObject,
                                IN  SE_OBJECT_TYPE    ObjectType)
{
    acDebugOut((DEB_TRACE_API,"in AccProvHandleIsObjectAccessible\n"));

    DWORD dwErr = ERROR_PATH_NOT_FOUND;

    //
    // Because a handle can get reused, we can't cache them like we did
    // above...
    //

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
        {
            DWORD   dwHigh;
            DWORD   dwSize = GetFileSize(hObject,
                                         &dwHigh);
            if(dwSize == 0xFFFFFFFF)
            {
                dwErr = GetLastError();
            }
            else
            {
                dwErr = ERROR_SUCCESS;
            }
        }
        break;

    case SE_SERVICE:
        {
            SERVICE_STATUS  SvcStatus;

            if(QueryServiceStatus((SC_HANDLE)hObject,
                                  &SvcStatus) == FALSE)
            {
                dwErr = GetLastError();
            }
            else
            {
                dwErr = ERROR_SUCCESS;
            }
        }
        break;

    case SE_PRINTER:
        {
            dwErr = LoadDLLFuncTable();
            if(dwErr == ERROR_SUCCESS)
            {
                ULONG cNeeded;
                if(DLLFuncs.PGetPrinter(hObject,
                                        1,
                                        NULL,
                                        0,
                                        &cNeeded) == FALSE)
                {
                    dwErr = GetLastError();
                    if(dwErr == ERROR_INSUFFICIENT_BUFFER)
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                }
            }
        }
        break;

    case SE_REGISTRY_KEY:
        dwErr = RegQueryInfoKey((HKEY)hObject,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);
        break;

    case SE_KERNEL_OBJECT:                          // FALL THROUGH
    case SE_WINDOW_OBJECT:                          // FALL THROUGH
    case SE_WMIGUID_OBJECT:
        //
        // Can't have kernel/windows objects outside of NT, so just return
        // success
        //
        dwErr = ERROR_SUCCESS;
        break;

    case SE_LMSHARE:                                // FALL THROUGH
    case SE_DS_OBJECT:                              // FALL THROUGH
    case SE_DS_OBJECT_ALL:
        //
        // Can't have handles to DS objects
        //
        dwErr = ERROR_PATH_NOT_FOUND;
        break;


    default:

        //
        // Unknown object type.  Pass it on.
        //
        dwErr = ERROR_PATH_NOT_FOUND;
        break;
    }



    //
    // Make sure the reason we failed isn't because of permissions
    //
    if(dwErr == ERROR_ACCESS_DENIED)
    {
        dwErr = ERROR_SUCCESS;
    }

    acDebugOut((DEB_TRACE_API,"out AccProvIsObjectAccessible: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvCancelOperation
//
//  Synopsis:   Cancels an ongoing operation.
//
//  Arguments:  [IN  pOverlapped]       --  Operation to cancel
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_INVALID_PARAMETER --  A bad overlapped structure was
//                                          given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvCancelOperation(IN   PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, grab a read lock, so nobody inserts on us, and find the
    // right node
    //
    PNTMARTA_WRKR_INFO  pWrkrNode = NULL;

    {
        // RtlAcquireResourceShared(&gWrkrLock, TRUE);
        RtlAcquireResourceExclusive(&gWrkrLock, TRUE);

        pWrkrNode = (PNTMARTA_WRKR_INFO)gWrkrList.Find((PVOID)pOverlapped,
                                                       NtProvFindWorkerItem);
        RtlReleaseResource(&gWrkrLock);
    }

    if(pWrkrNode == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // All right.  We'll set our stop flag, and wait for it to return..
        // It doesn't matter what we set the flag to, since all we need to do
        // is set it non-0
        //
        pWrkrNode->fState++;

        //
        // Now, wait for the call to finish
        //
        WaitForSingleObject(pWrkrNode->hWorker,
                            INFINITE);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetOperationResults
//
//  Synopsis:   Gets the results of an operation
//
//  Arguments:  [IN  pOverlapped]       --  Operation to cancel
//              [OUT dwResults]         --  Where the results are returned
//              [OUT pcProcessed]       --  Number of items processed
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_INVALID_PARAMETER --  A bad overlapped structure was
//                                          given
//              ERROR_IO_PENDING        --  Operation hasn't completed yet
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGetOperationResults(IN   PACTRL_OVERLAPPED   pOverlapped,
                           OUT  PDWORD              dwResults,
                           OUT  PDWORD              pcProcessed)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PNTMARTA_WRKR_INFO  pWrkrNode = NULL;

    //
    // Ok, first, grab a write lock.  This will prevent anyone from
    // reading and or writing to the list, until we get done updating
    // our overlapped structure.
    //
    RtlAcquireResourceExclusive(&gWrkrLock, TRUE);

    pWrkrNode = (PNTMARTA_WRKR_INFO)gWrkrList.Find((PVOID)pOverlapped,
                                                   NtProvFindWorkerItem);

    RtlReleaseResource(&gWrkrLock);

    if(pWrkrNode == NULL)
    {
        //
        // Now, the reason we may have not found the node is that somebody
        // has removed it.  If so, check our overlapped structure, since
        // that will have been updated by the last call
        //
        if(pOverlapped->hEvent != NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            *dwResults = pOverlapped->Reserved2;
            if(pcProcessed != NULL)
            {
                *pcProcessed = pOverlapped->Reserved1;
            }
        }
    }
    else
    {
        //
        // See if the thread has stopped processing or not
        //
        if(WaitForSingleObject(pWrkrNode->hWorker, 0) == WAIT_TIMEOUT)
        {
            if(pcProcessed != NULL)
            {
                *pcProcessed = pWrkrNode->cProcessed;
            }
            dwErr = ERROR_IO_PENDING;
        }
        else
        {
            //
            // Get the results of the thread exit first.
            //
            if(GetExitCodeThread(pWrkrNode->hWorker,
                                 dwResults) == FALSE)
            {
                dwErr = GetLastError();
            }
            else
            {
                dwErr = ERROR_SUCCESS;
                CloseHandle(pWrkrNode->hWorker);
                pWrkrNode->hWorker = NULL;

                //
                // Save off the results.  They go in Reserved2 parameter
                //
                pOverlapped->Reserved2 = *dwResults;
                pOverlapped->Reserved1 = pWrkrNode->cProcessed;

                //
                // Remove the node from our list, and do our updates.  We
                // need to do all of this before releasing our resource,
                // to prevent some race conditions
                //
                RtlAcquireResourceExclusive(&gWrkrLock, TRUE);

                gWrkrList.Remove((PVOID)pWrkrNode);

                RtlReleaseResource(&gWrkrLock);

                //
                // Deallocate our memory
                //
                AccFree(pWrkrNode);
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvSetAccessRights
//
//  Synopsis:   Sets the access rights on the given object.  It replaces any
//              existing rights.
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pAccessList]       --  Optional.  The list of access
//                                          rights to set.
//              [IN  pAuditList]        --  Optional.  The list of access
//                                          rights to set.
//              [IN  pOwner]            --  Optional.  Owner to set
//              [IN  pGroup]            --  Optional.  Group to set
//              [IN  pOverlapped]       --  Overlapped structure to use for
//                                          asynchronous control
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvSetAccessRights(IN           LPCWSTR                 pwszObjectPath,
                       IN           SE_OBJECT_TYPE          ObjectType,
                       IN           SECURITY_INFORMATION    SecurityInfo,
                       IN  OPTIONAL PACTRL_ACCESS           pAccessList,
                       IN  OPTIONAL PACTRL_AUDIT            pAuditList,
                       IN  OPTIONAL PTRUSTEE                pOwner,
                       IN  OPTIONAL PTRUSTEE                pGroup,
                       IN           PACTRL_OVERLAPPED       pOverlapped)
{
    DWORD   dwErr;

    CAccessList *pAccList = new CAccessList;
    if(pAccList == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        dwErr = pAccList->SetObjectType(ObjectType);
        if(dwErr == ERROR_SUCCESS)
        {
            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = pAccList->AddAccessLists(DACL_SECURITY_INFORMATION,
                                                 pAccessList,
                                                 FALSE);
            }

            if(dwErr == ERROR_SUCCESS &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = pAccList->AddAccessLists(SACL_SECURITY_INFORMATION,
                                                 pAuditList,
                                                 FALSE);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Add the owner and group
                //
                dwErr = pAccList->AddOwnerGroup(SecurityInfo,
                                                pOwner,
                                                pGroup);
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Finally, if all that worked, we'll do the rest
            //
            dwErr = NtProvDoSet(pwszObjectPath,
                                ObjectType,
                                pAccList,
                                pOverlapped,
                                NTMARTA_DELETE_ALIST);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            delete(pAccList);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleSetAccessRights
//
//  Synopsis:   Sets the access rights on the given object.  It replaces any
//              existing rights.
//
//  Arguments:  [IN  hObject]           --  Handle to the object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pAccessList]       --  Optional.  The list of access
//                                          rights to set.
//              [IN  pAuditList]        --  Optional.  The list of access
//                                          rights to set.
//              [IN  pOwner]            --  Optional.  Owner to set
//              [IN  pGroup]            --  Optional.  Group to set
//              [IN  pOverlapped]       --  Overlapped structure to use for
//                                          asynchronous control
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleSetAccessRights(IN   HANDLE                  hObject,
                             IN   SE_OBJECT_TYPE          ObjectType,
                             IN   SECURITY_INFORMATION    SecurityInfo,
                             IN   PACTRL_ACCESS           pAccessList  OPTIONAL,
                             IN   PACTRL_AUDIT            pAuditList   OPTIONAL,
                             IN   PTRUSTEE                pOwner       OPTIONAL,
                             IN   PTRUSTEE                pGroup       OPTIONAL,
                             IN   PACTRL_OVERLAPPED       pOverlapped)
{
    DWORD   dwErr;

    CAccessList *pAccList = new CAccessList;
    if(pAccList == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        dwErr = pAccList->SetObjectType(ObjectType);
        if(dwErr == ERROR_SUCCESS)
        {
            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = pAccList->AddAccessLists(DACL_SECURITY_INFORMATION,
                                                 pAccessList,
                                                 FALSE);
            }

            if(dwErr == ERROR_SUCCESS &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = pAccList->AddAccessLists(SACL_SECURITY_INFORMATION,
                                                 pAuditList,
                                                 FALSE);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Add the owner and group
                //
                dwErr = pAccList->AddOwnerGroup(SecurityInfo,
                                                pOwner,
                                                pGroup);
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Finally, if all that worked, we'll do the rest
            //
            dwErr = NtProvDoHandleSet(hObject,
                                      ObjectType,
                                      pAccList,
                                      pOverlapped,
                                      NTMARTA_DELETE_ALIST);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            delete pAccList;
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGrantAccessRights
//
//  Synopsis:   Grants the access rights on the given object.  It merges the
//              supplied rights with any existing rights.
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pAccessList]       --  Optional.  The list of access
//                                          rights to set.
//              [IN  pAuditList]        --  Optional.  The list of access
//                                          rights to set.
//
//  Returns:    ERROR_SUCCESS           --  The path is recognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGrantAccessRights(IN             LPCWSTR            pwszObjectPath,
                         IN             SE_OBJECT_TYPE     ObjectType,
                         IN  OPTIONAL   PACTRL_ACCESS      pAccessList,
                         IN  OPTIONAL   PACTRL_AUDIT       pAuditList,
                         IN             PACTRL_OVERLAPPED  pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, read the relevant information.  This will involve getting the
    // access and audit lists for each property specified in the access and
    // audit list.
    //
    PACTRL_RIGHTS_INFO      pRightsList = NULL;
    ULONG                   cItems;
    dwErr = NtProvSetRightsList(pAccessList,
                                pAuditList,
                                &cItems,
                                &pRightsList);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, read all of the rights
        //
        CAccessList *pAccList = NULL;

        //
        // NtProvGetAccessListForObject modifies its first
        // parameter, so we can't pass in a CONST string.
        //

        PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

        if (pwszTmpObjectPath)
        {
            wcscpy( pwszTmpObjectPath, pwszObjectPath );
            pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

            dwErr = NtProvGetAccessListForObject( pwszTmpObjectPath,
                                                  ObjectType,
                                                  pRightsList,
                                                  cItems,
                                                  &pAccList);

            //
            // Now, process the input lists
            //
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // First, the access list
                //
                if(pAccessList != NULL)
                {
                    dwErr = pAccList->AddAccessLists(DACL_SECURITY_INFORMATION,
                                                     pAccessList,
                                                     TRUE);

                }

                //
                // Then, the audit list
                //
                if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
                {
                    dwErr = pAccList->AddAccessLists(SACL_SECURITY_INFORMATION,
                                                     pAuditList,
                                                     TRUE);
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Finally, if all that worked, we'll do the rest
                //
                dwErr = NtProvDoSet(pwszObjectPath,
                                    ObjectType,
                                    pAccList,
                                    pOverlapped,
                                    NTMARTA_DELETE_ALIST);
            }

            if(dwErr != ERROR_SUCCESS)
            {
                delete pAccList;
            }

            AccFree( pwszTmpObjectPath );
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }

        AccFree(pRightsList);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleGrantAccessRights
//
//  Synopsis:   Grants the access rights on the given object.  It merges the
//              supplied rights with any existing rights.
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pAccessList]       --  Optional.  The list of access
//                                          rights to set.
//              [IN  pAuditList]        --  Optional.  The list of access
//                                          rights to set.
//
//  Returns:    ERROR_SUCCESS           --  The path is recognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleGrantAccessRights(IN             HANDLE             hObject,
                               IN             SE_OBJECT_TYPE     ObjectType,
                               IN  OPTIONAL   PACTRL_ACCESS      pAccessList,
                               IN  OPTIONAL   PACTRL_AUDIT       pAuditList,
                               IN             PACTRL_OVERLAPPED  pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, read the relevant information.  This will involve getting the
    // access and audit lists for each property specified in the access and
    // audit list.
    //
    PACTRL_RIGHTS_INFO      pRightsList = NULL;
    ULONG                   cItems;
    dwErr = NtProvSetRightsList(pAccessList,
                                pAuditList,
                                &cItems,
                                &pRightsList);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, read all of the rights
        //
        CAccessList *pAccList = NULL;
        dwErr = NtProvGetAccessListForHandle(hObject,
                                             ObjectType,
                                             pRightsList,
                                             cItems,
                                             &pAccList);
        //
        // Don't need the rights list, so we might as well release it
        //
        AccFree(pRightsList);

        //
        // Now, process the input lists
        //
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // First, the access list
            //
            if(pAccessList != NULL)
            {
                dwErr = pAccList->AddAccessLists(DACL_SECURITY_INFORMATION,
                                                 pAccessList,
                                                 TRUE);

            }

            //
            // Then, the audit list
            //
            if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
            {
                dwErr = pAccList->AddAccessLists(SACL_SECURITY_INFORMATION,
                                                 pAuditList,
                                                 TRUE);
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Finally, if all that worked, we'll do the rest
            //
            dwErr = NtProvDoHandleSet(hObject,
                                      ObjectType,
                                      pAccList,
                                      pOverlapped,
                                      NTMARTA_DELETE_ALIST);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            delete pAccList;
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvRevokeAccessRights
//
//  Synopsis:   Revokes the access rights on the given object.  It goes
//              through and removes any explicit entries for the given
//              trustees
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  cTrustees]         --  Number of trustees in list
//              [IN  prgTrustees]       --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvRevokeAccessRights(IN            LPCWSTR             pwszObjectPath,
                          IN            SE_OBJECT_TYPE      ObjectType,
                          IN  OPTIONAL  LPCWSTR             pwszProperty,
                          IN            ULONG               cTrustees,
                          IN            PTRUSTEE            prgTrustees,
                          IN            PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CAccessList *pAccList = NULL;
    //
    // First, read the relevant information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_RIGHTS_INFO    RI;
        RI.pwszProperty = (PWSTR)pwszProperty;
        RI.SeInfo       = DACL_SECURITY_INFORMATION;

        PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

        if (pwszTmpObjectPath)
        {
            wcscpy( pwszTmpObjectPath, pwszObjectPath );
            pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

            dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                                 ObjectType,
                                                 &RI,
                                                 1,
                                                 &pAccList);

            AccFree( pwszTmpObjectPath );
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for(DWORD iIndex = 0;
        iIndex < cTrustees && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        dwErr = pAccList->RemoveTrusteeFromAccess(DACL_SECURITY_INFORMATION,
                                                  &(prgTrustees[iIndex]),
                                                  (PWSTR)pwszProperty);
    }

    //
    // Then, do the set
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvDoSet(pwszObjectPath,
                            ObjectType,
                            pAccList,
                            pOverlapped,
                            NTMARTA_DELETE_ALIST);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        delete pAccList;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleRevokeAccessRights
//
//  Synopsis:   Revokes the access rights on the given object.  It goes
//              through and removes any explicit entries for the given
//              trustees
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  cTrustees]         --  Number of trustees in list
//              [IN  prgTrustees]       --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleRevokeAccessRights(IN            HANDLE              hObject,
                                IN            SE_OBJECT_TYPE      ObjectType,
                                IN  OPTIONAL  LPCWSTR             pwszProperty,
                                IN            ULONG               cTrustees,
                                IN            PTRUSTEE            prgTrustees,
                                IN            PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CAccessList *pAccList = NULL;

    //
    // First, read the relevant information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_RIGHTS_INFO    RI;
        RI.pwszProperty = (PWSTR)pwszProperty;
        RI.SeInfo       = DACL_SECURITY_INFORMATION;
        dwErr = NtProvGetAccessListForHandle(hObject,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);
    }

    for(DWORD iIndex = 0;
        iIndex < cTrustees && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        dwErr = pAccList->RemoveTrusteeFromAccess(DACL_SECURITY_INFORMATION,
                                                  &(prgTrustees[iIndex]),
                                                  (PWSTR)pwszProperty);
    }

    //
    // Then, do the set
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvDoHandleSet(hObject,
                                  ObjectType,
                                  pAccList,
                                  pOverlapped,
                                  NTMARTA_DELETE_ALIST);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        delete pAccList;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvRevokeAuditRights
//
//  Synopsis:   Revokes the audit rights on the given object.  It goes
//              through and removes any explicit entries for the given
//              trustees
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  cTrustees]         --  Number of trustees in list
//              [IN  prgTrustees]       --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvRevokeAuditRights(IN             LPCWSTR             pwszObjectPath,
                         IN             SE_OBJECT_TYPE      ObjectType,
                         IN  OPTIONAL   LPCWSTR             pwszProperty,
                         IN             ULONG               cTrustees,
                         IN             PTRUSTEE            prgTrustees,
                         IN             PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CAccessList *pAccList = NULL;
    //
    // First, read the relevant information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_RIGHTS_INFO    RI;
        RI.pwszProperty = (PWSTR)pwszProperty;
        RI.SeInfo       = SACL_SECURITY_INFORMATION;

        PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

        if (pwszTmpObjectPath)
        {
            wcscpy( pwszTmpObjectPath, pwszObjectPath );
            pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

            dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                                 ObjectType,
                                                 &RI,
                                                 1,
                                                 &pAccList);
            AccFree( pwszTmpObjectPath );
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for(DWORD iIndex = 0;
        iIndex < cTrustees && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        dwErr = pAccList->RemoveTrusteeFromAccess(SACL_SECURITY_INFORMATION,
                                                  &(prgTrustees[iIndex]),
                                                  (PWSTR)pwszProperty);
    }

    //
    // Then, do the set
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvDoSet(pwszObjectPath,
                            ObjectType,
                            pAccList,
                            pOverlapped,
                            NTMARTA_DELETE_ALIST);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        delete pAccList;
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleRevokeAuditRights
//
//  Synopsis:   Revokes the audit rights on the given object.  It goes
//              through and removes any explicit entries for the given
//              trustees
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  cTrustees]         --  Number of trustees in list
//              [IN  prgTrustees]       --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleRevokeAuditRights(IN             HANDLE              hObject,
                               IN             SE_OBJECT_TYPE      ObjectType,
                               IN  OPTIONAL   LPCWSTR             pwszProperty,
                               IN             ULONG               cTrustees,
                               IN             PTRUSTEE            prgTrustees,
                               IN             PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CAccessList *pAccList = NULL;
    //
    // First, read the relevant information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_RIGHTS_INFO    RI;
        RI.pwszProperty = (PWSTR)pwszProperty;
        RI.SeInfo       = SACL_SECURITY_INFORMATION;
        dwErr = NtProvGetAccessListForHandle(hObject,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);
    }

    for(DWORD iIndex = 0;
        iIndex < cTrustees && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        dwErr = pAccList->RemoveTrusteeFromAccess(SACL_SECURITY_INFORMATION,
                                                  &(prgTrustees[iIndex]),
                                                  (PWSTR)pwszProperty);
    }

    //
    // Then, do the set
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvDoHandleSet(hObject,
                                  ObjectType,
                                  pAccList,
                                  pOverlapped,
                                  NTMARTA_DELETE_ALIST);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        delete pAccList;
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetAllRights
//
//  Synopsis:   Gets the all the requested rights from the object.  This
//              includes the access rights, audit rights, and owner and group
//              if supported.
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [OUT ppAccessList]      --  Optional.  Where to return the
//                                          access list
//              [OUT ppAuditList]       --  Optional.  Where to return the
//                                          audit list.
//              [OUT ppOwner]           --  Number of trustees in list
//              [OUT ppGroup]           --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  An non-NULL property name was
//                                          given on an object that doesn't
//                                          support properties.
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGetAllRights(IN              LPCWSTR             pwszObjectPath,
                    IN              SE_OBJECT_TYPE      ObjectType,
                    IN              LPCWSTR             pwszProperty,
                    OUT OPTIONAL    PACTRL_ACCESS      *ppAccessList,
                    OUT OPTIONAL    PACTRL_AUDIT       *ppAuditList,
                    OUT OPTIONAL    PTRUSTEE           *ppOwner,
                    OUT OPTIONAL    PTRUSTEE           *ppGroup)
{
    acDebugOut((DEB_TRACE_API,"in AccProvGetAllRights\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Do the simple parameter checks first...
    //
    if(pwszProperty != NULL &&
           !(ObjectType == SE_DS_OBJECT_ALL || ObjectType == SE_DS_OBJECT))
    {
        return(ERROR_INVALID_PARAMETER);
    }

    SECURITY_INFORMATION    SeInfo = 0;

    //
    // Determine what we need to read
    //
    if(ppAccessList != NULL)
    {
        SeInfo |= DACL_SECURITY_INFORMATION;
        *ppAccessList = NULL;
    }

    if(ppAuditList != NULL)
    {
        SeInfo |= SACL_SECURITY_INFORMATION;
        *ppAuditList = NULL;
    }

    if(ppOwner != NULL)
    {
        SeInfo |= OWNER_SECURITY_INFORMATION;
        *ppOwner = NULL;
    }

    if(ppGroup != NULL)
    {
        SeInfo |= GROUP_SECURITY_INFORMATION;
        *ppGroup = NULL;
    }

    //
    // If nothing was requested, do nothing...
    //
    if(SeInfo == 0)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Now, go ahead and do the read...
    //
    CAccessList   *pAccList;

    ACTRL_RIGHTS_INFO    RI;
    RI.pwszProperty = (PWSTR)pwszProperty;
    RI.SeInfo       = SeInfo;

    //
    // NtProvGetAccessListForObject modifies its first
    // parameter, so we can't pass in a CONST string.
    //

    PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

    if (pwszTmpObjectPath)
    {
        wcscpy( pwszTmpObjectPath, pwszObjectPath );
        pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

        dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);


        //
        // Now, get the data in the form we need
        //
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, convert the stuff that we need to...
            //
            dwErr = pAccList->MarshalAccessLists(SeInfo,
                                                 ppAccessList,
                                                 ppAuditList);

            if(dwErr == ERROR_SUCCESS && ppOwner != NULL)
            {
                dwErr = pAccList->GetSDSidAsTrustee(OWNER_SECURITY_INFORMATION,
                                                    ppOwner);
            }

            if(dwErr == ERROR_SUCCESS && ppGroup != NULL)
            {
                dwErr = pAccList->GetSDSidAsTrustee(GROUP_SECURITY_INFORMATION,
                                                    ppGroup);
            }

            //
            // Ok, if anything failed, we'll do the cleanup
            //
            if(dwErr != ERROR_SUCCESS)
            {
                if((SeInfo & DACL_SECURITY_INFORMATION) != 0)
                {
                    AccFree(*ppAccessList);
                }

                if((SeInfo & SACL_SECURITY_INFORMATION) != 0)
                {
                    AccFree(*ppAuditList);
                }

                if((SeInfo & OWNER_SECURITY_INFORMATION) != 0)
                {
                    AccFree(*ppOwner);
                }

                if((SeInfo & GROUP_SECURITY_INFORMATION) != 0)
                {
                    AccFree(*ppGroup);
                }
            }

            delete pAccList;
        }

        AccFree( pwszTmpObjectPath );
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // The destruction of the CAclList class will clean up all of the
    // memory we obtained
    //
    acDebugOut((DEB_TRACE_API,"out AccProvGetAllRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleGetAllRights
//
//  Synopsis:   Gets the all the requested rights from the object.  This
//              includes the access rights, audit rights, and owner and group
//              if supported.
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [OUT ppAccessList]      --  Optional.  Where to return the
//                                          access list
//              [OUT ppAuditList]       --  Optional.  Where to return the
//                                          audit list.
//              [OUT ppOwner]           --  Number of trustees in list
//              [OUT ppGroup]           --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  An non-NULL property name was
//                                          given on an object that doesn't
//                                          support properties.
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleGetAllRights(IN              HANDLE              hObject,
                          IN              SE_OBJECT_TYPE      ObjectType,
                          IN              LPCWSTR             pwszProperty,
                          OUT OPTIONAL    PACTRL_ACCESS      *ppAccessList,
                          OUT OPTIONAL    PACTRL_AUDIT       *ppAuditList,
                          OUT OPTIONAL    PTRUSTEE           *ppOwner,
                          OUT OPTIONAL    PTRUSTEE           *ppGroup)
{
    acDebugOut((DEB_TRACE_API,"in AccProvHandleGetAllRights\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Do the simple parameter checks first...
    //
    if(pwszProperty != NULL &&
           (ObjectType != SE_DS_OBJECT_ALL || ObjectType != SE_DS_OBJECT))
    {
        return(ERROR_INVALID_PARAMETER);
    }

    SECURITY_INFORMATION    SeInfo = 0;

    //
    // Determine what we need to read
    //
    if(ppAccessList != NULL)
    {
        SeInfo |= DACL_SECURITY_INFORMATION;
        *ppAccessList = NULL;
    }

    if(ppAuditList != NULL)
    {
        SeInfo |= SACL_SECURITY_INFORMATION;
        *ppAuditList = NULL;
    }

    if(ppOwner != NULL)
    {
        SeInfo |= OWNER_SECURITY_INFORMATION;
        *ppOwner = NULL;
    }

    if(ppGroup != NULL)
    {
        SeInfo |= GROUP_SECURITY_INFORMATION;
        *ppGroup = NULL;
    }

    //
    // If nothing was requested, do nothing...
    //
    if(SeInfo == 0)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Now, go ahead and do the read...
    //
    CAccessList   *pAccList;

    ACTRL_RIGHTS_INFO    RI;
    RI.pwszProperty = (PWSTR)pwszProperty;
    RI.SeInfo       = SeInfo;
    dwErr = NtProvGetAccessListForHandle(hObject,
                                         ObjectType,
                                         &RI,
                                         1,
                                         &pAccList);


    //
    // Now, get the data in the form we need
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, convert the stuff that we need to...
        //
        dwErr = pAccList->MarshalAccessLists(SeInfo,
                                             ppAccessList,
                                             ppAuditList);

        if(dwErr == ERROR_SUCCESS && ppOwner != NULL)
        {
            dwErr = pAccList->GetSDSidAsTrustee(OWNER_SECURITY_INFORMATION,
                                                ppOwner);
        }

        if(dwErr == ERROR_SUCCESS && ppGroup != NULL)
        {
            dwErr = pAccList->GetSDSidAsTrustee(GROUP_SECURITY_INFORMATION,
                                                ppGroup);
        }

        //
        // Ok, if anything failed, we'll do the cleanup
        //
        if(dwErr != ERROR_SUCCESS)
        {
            if((SeInfo & DACL_SECURITY_INFORMATION) != 0)
            {
                AccFree(*ppAccessList);
            }

            if((SeInfo & SACL_SECURITY_INFORMATION) != 0)
            {
                AccFree(*ppAuditList);
            }

            if((SeInfo & OWNER_SECURITY_INFORMATION) != 0)
            {
                AccFree(*ppOwner);
            }

            if((SeInfo & GROUP_SECURITY_INFORMATION) != 0)
            {
                AccFree(*ppGroup);
            }
        }

        delete pAccList;
    }

    //
    // The destruction of the CAclList class will clean up all of the
    // memory we obtained
    //
    acDebugOut((DEB_TRACE_API,"out AccProvHandleGetAllRights: %lu\n", dwErr));
    return(dwErr);
}




DWORD
AccProvpDoTrusteeAccessCalculations(IN      CAccessList    *pAccList,
                                    IN      PTRUSTEE        pTrustee,
                                    IN OUT  PTRUSTEE_ACCESS pTrusteeAccess)
{
    DWORD   dwErr;

    ULONG   DeniedMask;
    ULONG   AllowedMask;
    dwErr = pAccList->GetExplicitAccess(pTrustee,
                                        (PWSTR)pTrusteeAccess->lpProperty,
                                        &DeniedMask,
                                        &AllowedMask);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Process the entries
        //

        //
        // It depends on what it is we're looking for...
        //
        pTrusteeAccess->fReturnedAccess = 0;
        if(pTrusteeAccess->fAccessFlags == TRUSTEE_ACCESS_EXPLICIT)
        {
            //
            // Ok, we'll look for these explicit rights
            //

            //
            // First, see if any of our denieds match...
            //
            if (pTrusteeAccess->Access == TRUSTEE_ACCESS_ALL)
            {
                pTrusteeAccess->fReturnedAccess = AllowedMask & ~DeniedMask;
            }
            else
            {
                if((pTrusteeAccess->Access & DeniedMask) == 0)
                {
                    //
                    // Now, see if we're allowed
                    //
                    if((pTrusteeAccess->Access & AllowedMask) ==
                                                       pTrusteeAccess->Access)
                    {
                        pTrusteeAccess->fReturnedAccess =
                                                      TRUSTEE_ACCESS_ALLOWED;
                    }
                }
            }
        }
        else if(FLAG_ON(pTrusteeAccess->fAccessFlags, TRUSTEE_ACCESS_READ) ||
                FLAG_ON(pTrusteeAccess->fAccessFlags, TRUSTEE_ACCESS_WRITE))
        {
            //
            // We're only looking for read/write access
            //
            ACCESS_RIGHTS   Access[2];
            ULONG           fValue[2], i = 0;

            if(FLAG_ON(pTrusteeAccess->fAccessFlags, TRUSTEE_ACCESS_READ))
            {
                Access[i] = ACTRL_READ_CONTROL;
                fValue[i] = TRUSTEE_ACCESS_READ;
                i++;
            }

            if(FLAG_ON(pTrusteeAccess->fAccessFlags, TRUSTEE_ACCESS_WRITE))
            {
                Access[i] = ACTRL_CHANGE_ACCESS | ACTRL_CHANGE_OWNER;
                fValue[i] = TRUSTEE_ACCESS_WRITE;
                i++;
            }

            for(ULONG iIndex = 0; iIndex < i; iIndex++)
            {
                if((Access[iIndex] & DeniedMask) == 0)
                {
                    //
                    // Now, see if we're allowed
                    //
                    if((Access[iIndex] & AllowedMask) == Access[iIndex])
                    {
                        pTrusteeAccess->fReturnedAccess |= fValue[iIndex];
                    }
                }
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        //
        // If we asked for read/write access, make sure we have them both
        //
        if(dwErr == ERROR_SUCCESS && pTrusteeAccess->fAccessFlags == TRUSTEE_ACCESS_READ_WRITE)
        {
            if( pTrusteeAccess->fReturnedAccess != TRUSTEE_ACCESS_READ_WRITE )
            {
                pTrusteeAccess->fReturnedAccess = 0;
            }
        }

    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetTrusteesAccess
//
//  Synopsis:   Determines whether the given trustee has the specified
//              rights to the object
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN OUT pTrusteeAccess] --  Type of access to check for
//                                          and where the access is returned
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGetTrusteesAccess(IN     LPCWSTR             pwszObjectPath,
                         IN     SE_OBJECT_TYPE      ObjectType,
                         IN     PTRUSTEE            pTrustee,
                         IN OUT PTRUSTEE_ACCESS     pTrusteeAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, we'll load all the objects entries that we need
    //
    CAccessList    *pAccList;
    ACTRL_RIGHTS_INFO    RI;
    RI.pwszProperty = (PWSTR)pTrusteeAccess->lpProperty;
    RI.SeInfo       = DACL_SECURITY_INFORMATION;

    PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

    if (pwszTmpObjectPath)
    {
        wcscpy( pwszTmpObjectPath, pwszObjectPath );
        pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

        dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);
        AccFree( pwszTmpObjectPath );
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpDoTrusteeAccessCalculations(pAccList,
                                                    pTrustee,
                                                    pTrusteeAccess);
        delete pAccList;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleGetTrusteesAccess
//
//  Synopsis:   Determines whether the given trustee has the specified
//              rights to the object
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN OUT pTrusteeAccess] --  Type of access to check for
//                                          and where the access is returned
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleGetTrusteesAccess(IN     HANDLE              hObject,
                               IN     SE_OBJECT_TYPE      ObjectType,
                               IN     PTRUSTEE            pTrustee,
                               IN OUT PTRUSTEE_ACCESS     pTrusteeAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, we'll load all the objects entries that we need
    //
    CAccessList    *pAccList;
    ACTRL_RIGHTS_INFO    RI;
    RI.pwszProperty = (PWSTR)pTrusteeAccess->lpProperty;
    RI.SeInfo       = DACL_SECURITY_INFORMATION;

    dwErr = NtProvGetAccessListForHandle(hObject,
                                         ObjectType,
                                         &RI,
                                         1,
                                         &pAccList);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpDoTrusteeAccessCalculations(pAccList,
                                                    pTrustee,
                                                    pTrusteeAccess);

        delete pAccList;
    }

    return(dwErr);
}




DWORD
AccProvpDoAccessAuditedCalculations(IN   CAccessList   *pAccList,
                                    IN   LPCWSTR        pwszProperty,
                                    IN   PTRUSTEE       pTrustee,
                                    IN   ACCESS_RIGHTS  ulAuditRights,
                                    OUT  PBOOL          pfAuditedSuccess,
                                    OUT  PBOOL          pfAuditedFailure)
{
    ULONG   SuccessMask;
    ULONG   FailureMask;
    DWORD   dwErr = pAccList->GetExplicitAudits(pTrustee,
                                               (PWSTR)pwszProperty,
                                                &SuccessMask,
                                                &FailureMask);
    if(dwErr == ERROR_SUCCESS)
    {

        //
        // Process the entries
        //
        *pfAuditedSuccess = FALSE;
        *pfAuditedFailure = FALSE;
        if((ulAuditRights & SuccessMask) == ulAuditRights)
        {
            *pfAuditedSuccess = TRUE;
        }

        if((ulAuditRights & FailureMask) == ulAuditRights)
        {
            *pfAuditedFailure = TRUE;
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvIsAccessAudited
//
//  Synopsis:   Determines whether the given trustee will envoke an audit
//              entry by accessing the object
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  pTrustee]          --  Trustee for which to check access
//              [IN  AuditRights]       --  Type of audit we care about
//              [OUT pfAccessAllowed]   --  Where the results are returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvIsAccessAudited(IN  LPCWSTR          pwszObjectPath,
                       IN  SE_OBJECT_TYPE   ObjectType,
                       IN  LPCWSTR          pwszProperty,
                       IN  PTRUSTEE         pTrustee,
                       IN  ACCESS_RIGHTS    AuditRights,
                       OUT PBOOL            pfAuditedSuccess,
                       OUT PBOOL            pfAuditedFailure)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, we'll load all the objects entries that we need
    //
    CAccessList    *pAccList;

    ACTRL_RIGHTS_INFO   RI;
    RI.pwszProperty = (PWSTR)pwszProperty;
    RI.SeInfo       = SACL_SECURITY_INFORMATION;

    PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

    if (pwszTmpObjectPath)
    {
        wcscpy( pwszTmpObjectPath, pwszObjectPath );
        pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

        dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);
        AccFree( pwszTmpObjectPath );
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpDoAccessAuditedCalculations(pAccList,
                                                    pwszProperty,
                                                    pTrustee,
                                                    AuditRights,
                                                    pfAuditedSuccess,
                                                    pfAuditedFailure);
        delete pAccList;
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleIsAccessAudited
//
//  Synopsis:   Determines whether the given trustee will envoke an audit
//              entry by accessing the object
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  pTrustee]          --  Trustee for which to check access
//              [IN  ulAuditRights]     --  Type of audit we care about
//              [OUT pfAccessAllowed]   --  Where the results are returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleIsAccessAudited(IN  HANDLE           hObject,
                             IN  SE_OBJECT_TYPE   ObjectType,
                             IN  LPCWSTR          pwszProperty,
                             IN  PTRUSTEE         pTrustee,
                             IN  ACCESS_RIGHTS    AuditRights,
                             OUT PBOOL            pfAuditedSuccess,
                             OUT PBOOL            pfAuditedFailure)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, we'll load all the objects entries that we need
    //
    CAccessList    *pAccList;

    ACTRL_RIGHTS_INFO   RI;
    RI.pwszProperty = (PWSTR)pwszProperty;
    RI.SeInfo       = SACL_SECURITY_INFORMATION;
    dwErr = NtProvGetAccessListForHandle(hObject,
                                         ObjectType,
                                         &RI,
                                         1,
                                         &pAccList);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpDoAccessAuditedCalculations(pAccList,
                                                    pwszProperty,
                                                    pTrustee,
                                                    AuditRights,
                                                    pfAuditedSuccess,
                                                    pfAuditedFailure);
        delete pAccList;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetAccessInfoPerObjectType
//
//  Synopsis:   Returns the list of available access permissions for the
//              specified object type
//
//  Arguments:  [IN  ObjectType]        --  Type of the object
//              [IN  DsObjType]         --  If this is a DS object, the type
//                                          of the object
//              [IN  pwszDsPath]        --  Full path to the object
//
//              [IN  lpProperty]        --  Optional.  If present, the name of
//                                          the property to get the access
//                                          rights for.
//              [IN  fIsDir]            --  If TRUE, the path is a directory
//              [OUT pcEntries]         --  Where the count of items is returned
//              [OUT ppAccessInfo]      --  Where the list of items is returned
//              [OUT pcControlRights]   --  Count of control rights are
//                                          is returned here
//              [OUT ppControlRights]   --  Where the list of control rights
//                                          is returned
//              [OUT pfAccessFlags]     --  Where the provider flags are
//                                          returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  The operation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvpGetAccessInfoPerObjectType(IN   SE_OBJECT_TYPE           ObjectType,
                                   IN   BOOL                     fIsDir,
                                   IN   PWSTR                    pwszDsPath,
                                   IN   PWSTR                    lpProperty,
                                   OUT  PULONG                   pcEntries,
                                   OUT  PACTRL_ACCESS_INFO  *ppAccessInfoList,
                                   OUT  PULONG               pcControlRights,
                                   OUT  PACTRL_CONTROL_INFOW *ppControlRights,
                                   OUT  PULONG               pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    ControlRightsValid = FALSE;
    ULONG   cStart = 0;
    ULONG   cItems = 0;

    #define LENGTH_OF_STR_GUID 37
    #define LENGTH_OF_LONGEST_STRING   20

    //
    // DS control rights
    //
    *pfAccessFlags = ACTRL_ACCESS_NO_OPTIONS;

    *ppControlRights = NULL;
    *pcControlRights = 0;

    *ppAccessInfoList = 0;
    *pcEntries = 0;

    //
    // Do the right thing based on the object type
    //
    switch (ObjectType)
    {
    case SE_LMSHARE:                                // FALL THROUGH
    case SE_FILE_OBJECT:
        if(fIsDir == TRUE)
        {
            cStart = ACCPROV_DIR_ACCESS;
            cItems = ACCPROV_NUM_DIR;
        }
        else
        {
            cStart = ACCPROV_FILE_ACCESS;
            cItems = ACCPROV_NUM_FILE;
        }
        break;

    case SE_SERVICE:
        cStart = ACCPROV_SERVICE_ACCESS;
        cItems = ACCPROV_NUM_SERVICE;
        break;

    case SE_PRINTER:
        cStart = ACCPROV_PRINT_ACCESS;
        cItems = ACCPROV_NUM_PRINT;
        break;

    case SE_REGISTRY_KEY:
        cStart = ACCPROV_REGISTRY_ACCESS;
        cItems = ACCPROV_NUM_REGISTRY;
        break;

    case SE_KERNEL_OBJECT:                          // FALL THROUGH
    case SE_WMIGUID_OBJECT:
        cStart = ACCPROV_KERNEL_ACCESS;
        cItems = ACCPROV_NUM_KERNEL;
        break;

    case SE_DS_OBJECT:                              // FALL THROUGH
    case SE_DS_OBJECT_ALL:
        cStart = ACCPROV_DS_ACCESS;
        cItems = ACCPROV_NUM_DS;
        ControlRightsValid = TRUE;
        break;

    case SE_WINDOW_OBJECT:
        cStart = ACCPROV_WIN_ACCESS;
        cItems = ACCPROV_NUM_WIN;
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
    }

    if(dwErr == ERROR_SUCCESS && ControlRightsValid == FALSE && lpProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Ok, we go through and size all of the strings that we need to add
        //
        ULONG cSize = 0;
        WCHAR   wszBuff[ACCPROV_LONGEST_STRING + 1];
        for(ULONG iIndex = 0; iIndex < cItems; iIndex++)
        {
            LoadString(ghDll, cStart + iIndex, wszBuff, ACCPROV_LONGEST_STRING);

            cSize += SIZE_PWSTR(wszBuff);
        }


        //
        // Always return the standard rights, as well...
        //
        for(iIndex = 0; iIndex < ACCPROV_NUM_STD; iIndex++)
        {
            LoadString(ghDll,
                       ACCPROV_STD_ACCESS + iIndex,
                       wszBuff,
                       ACCPROV_LONGEST_STRING);
            cSize += SIZE_PWSTR(wszBuff);
        }

        //
        // Make sure to return the proper count
        //
        *pcEntries = cItems + ACCPROV_NUM_STD;

        //
        // Ok, now we can allocate, and do the same thing again
        //
        *ppAccessInfoList = (PACTRL_ACCESS_INFO)AccAlloc(
                        (cItems + ACCPROV_NUM_STD) * sizeof(ACTRL_ACCESS_INFO) +
                        cSize);
        if(*ppAccessInfoList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }

        if(*ppAccessInfoList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            PWSTR   pwszStart = (PWSTR)((PBYTE)(*ppAccessInfoList) +
                          (cItems + ACCPROV_NUM_STD) * sizeof(ACTRL_ACCESS_INFO));
            //
            // Start with the standard items
            //
            ULONG iLst = 0;
            for(iIndex = 0; iIndex < ACCPROV_NUM_STD; iIndex++)
            {
                LoadString(ghDll,
                           ACCPROV_STD_ACCESS + iIndex,
                           wszBuff,
                           ACCPROV_LONGEST_STRING);
                cSize = SIZE_PWSTR(wszBuff);

                memcpy(pwszStart,
                       wszBuff,
                       cSize);

                //
                // Handle STD_RIGTHS_ALL as a special case...
                //
                if(iIndex == ACCPROV_NUM_STD - 1)
                {
                    (*ppAccessInfoList)[iLst].fAccessPermission = ACTRL_STD_RIGHTS_ALL;
                }
                else
                {
                    (*ppAccessInfoList)[iLst].fAccessPermission =
                                                           ACTRL_SYSTEM_ACCESS << iIndex;
                }
                (*ppAccessInfoList)[iLst].lpAccessPermissionName = pwszStart;
                pwszStart = (PWSTR)Add2Ptr(pwszStart,cSize);
                iLst++;
            }


            for(ULONG iIndex = 0; iIndex < cItems; iIndex++)
            {
                LoadString(ghDll,
                           cStart + iIndex, wszBuff, ACCPROV_LONGEST_STRING);

                cSize = SIZE_PWSTR(wszBuff);

                memcpy(pwszStart,
                       wszBuff,
                       cSize);
                (*ppAccessInfoList)[iLst].fAccessPermission =
                                                           ACTRL_PERM_1 << iIndex;
                (*ppAccessInfoList)[iLst].lpAccessPermissionName = pwszStart;
                pwszStart = (PWSTR)Add2Ptr(pwszStart,cSize);
                iLst++;
            }

            //
            // Now, add extra control rights
            //

            if(ObjectType == SE_DS_OBJECT || ObjectType == SE_DS_OBJECT_ALL )
            {
                dwErr = AccctrlLookupRightsByName( NULL,
                                                   pwszDsPath,
                                                   lpProperty,
                                                   pcControlRights,
                                                   ppControlRights);

                //
                // If we can't find the entry we want, return 0 items...
                //
                if(dwErr == ERROR_NOT_FOUND)
                {
                    *pcControlRights = 0;
                    *ppControlRights = NULL;
                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        *pcEntries = cItems + ACCPROV_NUM_STD;

    }
    else
    {
        if(*ppAccessInfoList != NULL)
        {
            AccFree(*ppAccessInfoList);
            *pcEntries = 0;
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetAccessInfoPerObjectType
//
//  Synopsis:   Returns the list of available access permissions for the
//              specified object type
//
//  Arguments:  [IN  lpObject]          --  Full path to the object
//              [IN  ObjectType]        --  Type of the object
//              [IN  lpProperty]        --  Optional.  If present, the name of
//                                          the property to get the access
//                                          rights for.
//              [OUT pcEntries]         --  Where the count of items is returned
//              [OUT ppAccessInfo]      --  Where the list of items is returned
//              [OUT pfAccessFlags]     --  Where the provider flags are
//                                          returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  The operation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGetAccessInfoPerObjectType(IN   LPCWSTR              lpObject,
                                  IN   SE_OBJECT_TYPE       ObjectType,
                                  IN   LPCWSTR              lpProperty,
                                  OUT  PULONG               pcEntries,
                                  OUT  PACTRL_ACCESS_INFO  *ppAccessInfoList,
                                  OUT  PULONG               pcControlRights,
                                  OUT  PACTRL_CONTROL_INFOW *ppControlRights,
                                  OUT  PULONG               pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fIsDir = FALSE;

    if(ObjectType == SE_LMSHARE || ObjectType == SE_FILE_OBJECT)
    {
        //
        // Check to see whether this is a file or a directory...
        //
        ULONG ulAttribs = GetFileAttributes((PWSTR)lpObject);
        if(FLAG_ON(ulAttribs, FILE_ATTRIBUTE_DIRECTORY))
        {
            fIsDir = TRUE;
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpGetAccessInfoPerObjectType(ObjectType,
                                                   fIsDir,
                                                   (LPWSTR)lpObject,
                                                   (LPWSTR)lpProperty,
                                                   pcEntries,
                                                   ppAccessInfoList,
                                                   pcControlRights,
                                                   ppControlRights,
                                                   pfAccessFlags);
    }
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleGetAccessInfoPerObjectType
//
//  Synopsis:   Returns the list of available access permissions for the
//              specified object type
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  lpProperty]        --  Optional.  If present, the name of
//                                          the property to get the access
//                                          rights for.
//              [OUT pcEntries]         --  Where the count of items is returned
//              [OUT ppAccessInfo]      --  Where the list of items is returned
//              [OUT pfAccessFlags]     --  Where the provider flags are
//                                          returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  The operation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleGetAccessInfoPerObjectType(IN   HANDLE               hObject,
                                        IN   SE_OBJECT_TYPE       ObjectType,
                                        IN   LPCWSTR              lpProperty,
                                        OUT  PULONG               pcEntries,
                                        OUT  PACTRL_ACCESS_INFO  *ppAccessInfoList,
                                        OUT  PULONG               pcControlRights,
                                        OUT  PACTRL_CONTROL_INFOW *ppControlRights,
                                        OUT  PULONG               pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fIsDir = FALSE;

    if(ObjectType == SE_LMSHARE || ObjectType == SE_FILE_OBJECT)
    {
        BY_HANDLE_FILE_INFORMATION  BHFI;
        //
        // Check to see whether this is a file or a directory...
        //
        if(GetFileInformationByHandle(hObject,
                                      &BHFI) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(FLAG_ON(BHFI.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
            fIsDir = TRUE;
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpGetAccessInfoPerObjectType(ObjectType,
                                                   fIsDir,
                                                   NULL,
                                                   (LPWSTR)lpProperty,
                                                   pcEntries,
                                                   ppAccessInfoList,
                                                   pcControlRights,
                                                   ppControlRights,
                                                   pfAccessFlags);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\ntmarta.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       NTMARTA.CXX
//
//  Contents:   Implementation of the private provider functions and
//              worker threads
//
//  History:    22-Jul-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <ntprov.hxx>


//
// This macro montiors the worker thread interrupt flag, and goes to to the
// CleanUp label when it discovers it has been set.
//
#define CLEANUP_ON_INTERRUPT(info)                                          \
if(info->pWrkrInfo->fState != 0)                                            \
{                                                                           \
    goto CleanUp;                                                           \
}

DWORD
InsertAndContinueWorkerThread(IN  PNTMARTA_WRKR_INFO      pWrkrInfo);



//+---------------------------------------------------------------------------
//
//  Function:   NtProvFreeWorkerItem
//
//  Synopsis:   Used by the linked list class that maintains the list of
//              active worker threads.  This is used to delete an item
//              in the worker list.  If the thread is still active, it
//              will be given some amount of time to finish.  If it hasn't
//              finished in that amount of time, it will be killed.  Note
//              that this means that a memory leak could occur.
//
//  Arguments:  [IN  pv]                --  Item to be freed
//
//  Returns:    void
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NtProvFreeWorkerItem(PVOID    pv)
{
    PNTMARTA_WRKR_INFO pWI = (PNTMARTA_WRKR_INFO)pv;

    if(pWI != NULL && pWI->hWorker != NULL)
    {
        pWI->fState++;

        DWORD   dwPop = WaitForSingleObject(pWI->hWorker,
                                            THREAD_KILL_WAIT);
        if(dwPop == WAIT_ABANDONED)
        {
            //
            // The wait timed out, so kill it.  Note also that the rules
            // state that anytime the thread stops, we need to set the
            // event as well.
            //
            TerminateThread(pWI->hWorker,
                            ERROR_OPERATION_ABORTED);
            SetEvent(pWI->pOverlapped->hEvent);

            //
            // The memory passed in to the thread as an argument was just
            // leaked.  this is fixable.
            //
        }
    }

    //
    // Deallocate our memory
    //
    AccFree(pv);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvFindWorkerItem
//
//  Synopsis:   Used by the linked list class that maintains the list of
//              active worker threads.  This is used locate a particular
//              worker item in the list
//
//  Arguments:  [IN  pv1]               --  Item to be found.  In this
//                                          case, a pOverlapped struct
//              [IN  pv2]               --  Item in the list.  In this case,
//                                          a PNTMARTA_WRKR_INFO struct.
//
//  Returns:    TRUE                    --  They match
//              FALSE                   --  They don't match
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
NtProvFindWorkerItem(PVOID    pv1,
                     PVOID    pv2)
{
    PNTMARTA_WRKR_INFO  pWI = (PNTMARTA_WRKR_INFO)pv2;
    PACTRL_OVERLAPPED   pOL = (PACTRL_OVERLAPPED)pv1;
    if(pWI->pOverlapped->hEvent == pOL->hEvent)
    {
        return(TRUE);
    }

    return(FALSE);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvGetBasePathForFilePath
//
//  Synopsis:   Gets the base path for this item as necessary.  For
//              a FILE type object, it will check to see if it is a DFS path,
//              and if so, will retrieve the list of machine paths that
//              support this DFS path.  For a non-File object, the path is
//              simply copied.
//
//  Arguments:  [IN  pwszObject]            --      Object path
//              [IN  ObjectType]            --      The type of the object
//              [OUT pcPaths]               --      Where the count of paths
//                                                  is to be returned
//              [OUT pppwszBasePaths]       --      The list of paths.
//
//  Returns:    VOID
//
//  Notes:      The returned list must be free via a call to AccFree
//
//----------------------------------------------------------------------------
DWORD
NtProvGetBasePathsForFilePath(PWSTR             pwszObject,
                              SE_OBJECT_TYPE    ObjectType,
                              PULONG            pcPaths,
                              PWSTR           **pppwszBasePaths)
{
    DWORD   dwErr = ERROR_SUCCESS;

    *pcPaths = 0;
    //
    // First, we'll see if it's a relative path.  If so, we'll have to
    // build a full path...
    //
    PWSTR   pwszFullPath = pwszObject;
    DWORD   dwSize;
    if(ObjectType == SE_FILE_OBJECT)
    {
        if(wcslen(pwszObject) < 2 ||
                            (pwszObject[1] != L':' && pwszObject[1] != L'\\'))
        {
            //
            // It's a relative path...
            //
            dwSize = GetFullPathName(pwszObject,
                                     0,
                                     NULL,
                                     NULL);
            if(dwSize == 0)
            {
                dwErr = GetLastError();
            }
            else
            {
                pwszFullPath = (PWSTR)AccAlloc((dwSize + 1) * sizeof(WCHAR));
                if(pwszFullPath == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    PWSTR   pwszFilePart;
                    if(GetFullPathName(pwszObject,
                                       dwSize,
                                       pwszFullPath,
                                       &pwszFilePart) == 0)
                    {
                        dwErr = GetLastError();
                    }
                }
            }
        }

        //
        // Ok, now see if it's a DFS path
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = LoadDLLFuncTable();

            if(dwErr == ERROR_SUCCESS)
            {
/*
                if(IsThisADfsPath(pwszFullPath,0) == TRUE)
                {
                    dwErr = GetLMDfsPaths(pwszFullPath,
                                          pcPaths,
                                          pppwszBasePaths);
                }
                else
                {
*/
                    *pppwszBasePaths = (PWSTR *)AccAlloc(sizeof(PWSTR) +
                                                     SIZE_PWSTR(pwszObject));
                    if(*pppwszBasePaths == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        (*pppwszBasePaths)[0] =
                             (PWSTR)((PBYTE)*pppwszBasePaths + sizeof(PWSTR));
                        wcscpy((PWSTR)((PBYTE)*pppwszBasePaths + sizeof(PWSTR)),
                               pwszObject);
                        *pcPaths = 1;
                    }
//                }
            }
        }
    }
    else
    {
        *pppwszBasePaths = (PWSTR *)AccAlloc(sizeof(PWSTR) +
                                             SIZE_PWSTR(pwszObject));
        if(*pppwszBasePaths == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            (*pppwszBasePaths)[0] =
                                (PWSTR)((PBYTE)*pppwszBasePaths + sizeof(PWSTR));
            wcscpy((PWSTR)((PBYTE)*pppwszBasePaths + sizeof(PWSTR)),
                   pwszObject);
            *pcPaths = 1;
        }
    }

    //
    // Make sure to deallocate any memory
    //
    if(pwszFullPath != pwszObject)
    {
        AccFree(pwszFullPath);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvSetAccessRightsWorkerThread
//
//  Synopsis:   Sets the access rights on the given object.  It replaces any
//              existing rights.
//
//  Arguments:  [IN  pWorkerArgs]       --  Pointer to the structure that
//                                          contains all of the thread
//                                          arguments.
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_OPERATION_ABORTED --  The operation was aborted
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvSetAccessRightsWorkerThread(IN PVOID pWorkerArgs)
{
    PNTMARTA_SET_WRKR_INFO  pSetInfo = (PNTMARTA_SET_WRKR_INFO)pWorkerArgs;
    DWORD                   dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    MARTA_KERNEL_TYPE       KernelType;
    {
        //
        // Now, we'll do this in a loop, so we can handle the DFS case where
        // we get a failure on one path, but another path may work
        //
        pSetInfo->pWrkrInfo->cProcessed = 0;
        ULONG iIndex = 0;
        do
        {
            CLEANUP_ON_INTERRUPT(pSetInfo)

            //
            // If it worked, write them all out...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                CLEANUP_ON_INTERRUPT(pSetInfo)

                //
                // First, get the Security Descriptor
                //
                SECURITY_INFORMATION    SeInfo;
                ULONG                   fSDFlags = ACCLIST_SD_ABSOK;

                if(pSetInfo->ObjectType == SE_DS_OBJECT ||
                                    pSetInfo->ObjectType == SE_DS_OBJECT_ALL)
                {
                    pSetInfo->pAccessList->SetDsPathInfo(NULL,
                                  (PWSTR)pSetInfo->ppwszObjectList[iIndex]);
                    fSDFlags = 0;

                }

                dwErr = pSetInfo->pAccessList->BuildSDForAccessList(&pSD,
                                                                    &SeInfo,
                                                                    fSDFlags);
                CLEANUP_ON_INTERRUPT(pSetInfo)
                if(dwErr == ERROR_SUCCESS)
                {
                    HANDLE  hObject = NULL;
                    BOOL    fHandleLocal = TRUE;

                    if(FLAG_ON(pSetInfo->fFlags, NTMARTA_HANDLE_VALID))
                    {
                        hObject = pSetInfo->hObject;
                        fHandleLocal = FALSE;

                    }
                    switch (pSetInfo->ObjectType)
                    {
                    case SE_SERVICE:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = OpenServiceObject(
                                    (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                    GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                     SeInfo),
                                    (SC_HANDLE *)&hObject);
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            if(pSetInfo->pWrkrInfo->fState != 0)
                            {
                                CloseServiceObject((SC_HANDLE)hObject);
                                goto CleanUp;
                            }

                            dwErr = SetServiceSecurityInfo((SC_HANDLE)hObject,
                                                           SeInfo,
                                                           NULL,
                                                           pSD);

                            if(fHandleLocal == TRUE)
                            {
                                CloseServiceObject((SC_HANDLE)hObject);
                            }
                        }
                        break;

                    case SE_PRINTER:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = OpenPrinterObject(
                                    (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                    GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                     SeInfo),
                                    &hObject);
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            if(pSetInfo->pWrkrInfo->fState != 0)
                            {
                                ClosePrinterObject(hObject);
                                goto CleanUp;
                            }

                            dwErr = SetPrinterSecurityInfo(hObject,
                                                           SeInfo,
                                                           NULL,
                                                           pSD);

                            if(fHandleLocal == TRUE)
                            {
                                ClosePrinterObject(hObject);
                            }

                        }
                        break;

                    case SE_LMSHARE:
                        dwErr = SetShareSecurityInfo(
                                    (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                    SeInfo,
                                    NULL,
                                    pSD);
                        break;

                    case SE_KERNEL_OBJECT:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = OpenKernelObject(
                                    (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                    GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                     SeInfo),
                                    &hObject,
                                    &KernelType);

                            if(dwErr == ERROR_SUCCESS)
                            {
                                pSetInfo->pAccessList->SetKernelObjectType( KernelType );
                            }
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            if(pSetInfo->pWrkrInfo->fState != 0)
                            {
                                CloseKernelObject(hObject);
                                goto CleanUp;
                            }

                            dwErr = SetKernelSecurityInfo(hObject,
                                                          SeInfo,
                                                          NULL,
                                                          pSD);

                            if(fHandleLocal == TRUE)
                            {
                                CloseKernelObject(hObject);
                            }

                        }
                        break;


                    case SE_WMIGUID_OBJECT:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = OpenWmiGuidObject(
                                            (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                            GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                             SeInfo),
                                            &hObject,
                                            &KernelType);

                            if(dwErr == ERROR_SUCCESS)
                            {
                                pSetInfo->pAccessList->SetKernelObjectType( KernelType );
                            }
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            if(pSetInfo->pWrkrInfo->fState != 0)
                            {
                                CloseKernelObject(hObject);
                                goto CleanUp;
                            }

                            dwErr = SetWmiGuidSecurityInfo(hObject,
                                                           SeInfo,
                                                           NULL,
                                                           pSD);

                            if(fHandleLocal == TRUE)
                            {
                                CloseWmiGuidObject(hObject);
                            }

                        }
                        break;


                    case SE_FILE_OBJECT:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = SetAndPropagateFilePropertyRights(
                                     (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                     NULL,
                                     *(pSetInfo->pAccessList),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed),
                                     NULL);
                        }
                        else
                        {
                            dwErr = SetAndPropagateFilePropertyRightsByHandle(
                                     hObject,
                                     NULL,
                                     *(pSetInfo->pAccessList),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed));

                        }
                        break;

                    case SE_REGISTRY_KEY:

                        if(fHandleLocal == TRUE)
                        {
                            dwErr = SetAndPropagateRegistryPropertyRights(
                                     (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                     NULL,
                                     *(pSetInfo->pAccessList),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed));

                        }
                        else
                        {
                            dwErr = SetAndPropagateRegistryPropertyRightsByHandle(
                                     (HKEY)hObject,
                                     *(pSetInfo->pAccessList),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed));

                        }
                        break;

                    case SE_DS_OBJECT:
                    case SE_DS_OBJECT_ALL:

                        dwErr = SetDSObjSecurityInfo(
                                     (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                     SeInfo,
                                     NULL,
                                     pSD,
                                     pSetInfo->pAccessList->QuerySDSize(),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed));
                        break;

                    case SE_WINDOW_OBJECT:

                        if(SetUserObjectSecurity(hObject,
                                                 &SeInfo,
                                                 pSD) == FALSE)
                        {
                            dwErr = GetLastError();
                        }
                        break;

                    default:
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;

                    }
                }
            }

            CLEANUP_ON_INTERRUPT(pSetInfo)

            iIndex++;
        } while(dwErr != ERROR_SUCCESS && iIndex < pSetInfo->cObjects);

    }

    //
    // This is the cleanup section
    //
CleanUp:
    AccFree(pSetInfo->ppwszObjectList);


    //
    // See if we need to clean up any allocated memory
    //
    if(pSetInfo->fFlags & NTMARTA_DELETE_ALIST)
    {
        delete pSetInfo->pAccessList;
    }

    if(pSetInfo->pWrkrInfo->fState != 0)
    {
        dwErr = ERROR_OPERATION_ABORTED;
    }

    HANDLE  hEvent = pSetInfo->pWrkrInfo->pOverlapped->hEvent;

    //
    // See if we need to delete the arguments themselves
    //
    if(pSetInfo->fFlags & NTMARTA_DELETE_ARGS)
    {
        AccFree(pSetInfo);
    }

    //
    // Finally, set our event
    //
    SetEvent(hEvent);

    ExitThread(dwErr);
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvDoSet
//
//  Synopsis:   Sets up the worker thread to do the SetAccessRights
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pSetInfo]          --  List of rights infos
//              [IN  cRightsInfos]      --  Number of items in list
//              [IN  pAccessList]       --  Ptr to a CAccessList class
//              [IN  pOwner]            --  Optional.  Owner to set
//              [IN  pGroup]            --  Optional.  Group to set
//              [IN  pOverlapped]       --  Overlapped structure to use for
//                                          asynchronous control
//              [IN  fSetFlags]         --  Flags governing the control of
//                                          the worker thread
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvDoSet(IN  LPCWSTR                 pwszObjectPath,
            IN  SE_OBJECT_TYPE          ObjectType,
            IN  CAccessList            *pAccessList,
            IN  PACTRL_OVERLAPPED       pOverlapped,
            IN  DWORD                   fSetFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, we'll create the relevant information structures, create
    // the thread, and then let it go.
    //
    PNTMARTA_WRKR_INFO      pWrkrInfo = NULL;
    PNTMARTA_SET_WRKR_INFO  pSetWrkrInfo =
              (PNTMARTA_SET_WRKR_INFO)AccAlloc(sizeof(NTMARTA_SET_WRKR_INFO));
    if(pSetWrkrInfo == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pSetWrkrInfo->ppwszObjectList = NULL;

        //
        // Initialize the rest of the items
        //
        pSetWrkrInfo->ObjectType = ObjectType;
        pSetWrkrInfo->pAccessList= pAccessList;
        pSetWrkrInfo->fFlags     = fSetFlags | NTMARTA_DELETE_ARGS;
    }

    //
    // If that worked, create the new worker info struct
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, create a new structure
        //
        pWrkrInfo = (PNTMARTA_WRKR_INFO)AccAlloc(sizeof(NTMARTA_WRKR_INFO));
        if(pWrkrInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Initialize the structure members
            //
            pWrkrInfo->pOverlapped  = pOverlapped;
            pWrkrInfo->fState       = 0;
            pSetWrkrInfo->pWrkrInfo = pWrkrInfo;
        }
    }

    //
    // Now, get the path information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvGetBasePathsForFilePath((PWSTR)pwszObjectPath,
                                              pSetWrkrInfo->ObjectType,
                                              &(pSetWrkrInfo->cObjects),
                                              &(pSetWrkrInfo->ppwszObjectList));
    }

    //
    // Then, create the thread, SUSPENDED.  The insertion routine will send
    // if off.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        DWORD   dwThreadId;

        HANDLE hThreadToken;
        if (OpenThreadToken(
                 GetCurrentThread(),
                 MAXIMUM_ALLOWED,
                 TRUE,                    // OpenAsSelf
                 &hThreadToken
                 ))

        {
            //
            // We're impersonating, turn it off and remember the handle
            //

            RevertToSelf();

        } else {

            hThreadToken = NULL;
        }

        HANDLE  hWorker = CreateThread(NULL,
                                       0,
                                       NtProvSetAccessRightsWorkerThread,
                                       (LPVOID)pSetWrkrInfo,
                                       CREATE_SUSPENDED,
                                       &dwThreadId);



        if (hThreadToken != NULL) {

            (VOID) SetThreadToken (
                      NULL,
                      hThreadToken
                      );

            CloseHandle( hThreadToken );
            hThreadToken = NULL;
        }

        if(hWorker == NULL)
        {
            dwErr = GetLastError();
        }
        else
        {
            pWrkrInfo->hWorker = hWorker;

            //
            // Now, insert the new node in the list.  Note the use of the
            // resource, since the list is not multi-thread safe.  Note the
            // scoping, since we need to protect the list until the thread
            // actually gets started
            //
            dwErr = InsertAndContinueWorkerThread(pWrkrInfo);
        }
    }


    if(dwErr != ERROR_SUCCESS)
    {
        //
        // Clean up the allocated memory
        //
        if(pSetWrkrInfo != NULL)
        {
            AccFree(pSetWrkrInfo->ppwszObjectList);
        }
        AccFree(pSetWrkrInfo);

        if(pWrkrInfo != NULL)
        {
            AccFree(pWrkrInfo);
        }
    }

    return(dwErr);
}








//+---------------------------------------------------------------------------
//
//  Function:   NtProvDoHandleSet
//
//  Synopsis:   Sets up the worker thread to do the SetAccessRights for the
//              handle based APIs
//
//  Arguments:  [IN  hObject]           --  Handle to the object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pSetInfo]          --  List of rights infos
//              [IN  cRightsInfos]      --  Number of items in list
//              [IN  pAccessList]       --  Ptr to a CAccessList class
//              [IN  pOwner]            --  Optional.  Owner to set
//              [IN  pGroup]            --  Optional.  Group to set
//              [IN  pOverlapped]       --  Overlapped structure to use for
//                                          asynchronous control
//              [IN  fSetFlags]         --  Flags governing the control of
//                                          the worker thread
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvDoHandleSet(IN  HANDLE              hObject,
                  IN  SE_OBJECT_TYPE      ObjectType,
                  IN  CAccessList        *pAccessList,
                  IN  PACTRL_OVERLAPPED   pOverlapped,
                  IN  DWORD               fSetFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, we'll create the relevant information structures, create
    // the thread, and then let it go.
    //
    PNTMARTA_WRKR_INFO      pWrkrInfo = NULL;
    PNTMARTA_SET_WRKR_INFO  pSetWrkrInfo =
              (PNTMARTA_SET_WRKR_INFO)AccAlloc(sizeof(NTMARTA_SET_WRKR_INFO));
    if(pSetWrkrInfo == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pSetWrkrInfo->ppwszObjectList = NULL;

        //
        // Initialize the rest of the items
        //
        pSetWrkrInfo->ObjectType = ObjectType;
        pSetWrkrInfo->pAccessList= pAccessList;
        pSetWrkrInfo->fFlags     = fSetFlags                |
                                        NTMARTA_DELETE_ARGS |
                                        NTMARTA_HANDLE_VALID;
        pSetWrkrInfo->hObject    = hObject;
    }

    //
    // If that worked, create the new worker info struct
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, create a new structure
        //
        pWrkrInfo = (PNTMARTA_WRKR_INFO)AccAlloc(sizeof(NTMARTA_WRKR_INFO));
        if(pWrkrInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Initialize the structure members
            //
            pWrkrInfo->pOverlapped  = pOverlapped;
            pWrkrInfo->fState       = 0;
            pSetWrkrInfo->pWrkrInfo = pWrkrInfo;
        }
    }

    //
    // Then, create the thread, SUSPENDED.  The insertion routine will send
    // if off.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        DWORD   dwThreadId;
        HANDLE  hWorker = CreateThread(NULL,
                                       0,
                                       NtProvSetAccessRightsWorkerThread,
                                       (LPVOID)pSetWrkrInfo,
                                       CREATE_SUSPENDED,
                                       &dwThreadId);
        if(hWorker == NULL)
        {
            dwErr = GetLastError();
        }
        else
        {
            pWrkrInfo->hWorker = hWorker;

            //
            // Now, insert the new node in the list.  Note the use of the
            // resource, since the list is not multi-thread safe.  Note the
            // scoping, since we need to protect the list until the thread
            // actually gets started
            //
            dwErr = InsertAndContinueWorkerThread(pWrkrInfo);
        }
    }


    if(dwErr != ERROR_SUCCESS)
    {
        //
        // Clean up the allocated memory
        //
        if(pSetWrkrInfo != NULL)
        {
            AccFree(pSetWrkrInfo->ppwszObjectList);
        }
        AccFree(pSetWrkrInfo);

        if(pWrkrInfo != NULL)
        {
            AccFree(pWrkrInfo);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvGetAccessListForObject
//
//  Synopsis:
//
//  Arguments:  [IN  pObjectName]       --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  SecurityInfo]      --  What information is be obtained
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN OUT AccList]        --  The CAccessList reference to fill
//              [OUT ppOwner]           --  Number of trustees in list
//              [OUT ppGroup]           --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvGetAccessListForObject(IN  PWSTR                      pwszObject,
                             IN  SE_OBJECT_TYPE             ObjectType,
                             IN  PACTRL_RIGHTS_INFO         pRightsInfo,
                             IN  ULONG                      cProps,
                             OUT CAccessList              **ppAccessList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, allocate a new class pointer
    //
    *ppAccessList = new CAccessList;

    if(*ppAccessList == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    dwErr = (*ppAccessList)->SetObjectType(ObjectType);

    for(ULONG iIndex = 0; iIndex < cProps && dwErr == ERROR_SUCCESS; iIndex++)
    {
        //
        // Now, do the read
        //
        switch (ObjectType)
        {
        case SE_KERNEL_OBJECT:
            dwErr = ReadKernelPropertyRights(pwszObject,
                                             pRightsInfo,
                                             cProps,
                                             **ppAccessList);
            break;

        case SE_WMIGUID_OBJECT:
            dwErr = ReadWmiGuidPropertyRights(pwszObject,
                                              pRightsInfo,
                                              cProps,
                                              **ppAccessList);
            break;

        case SE_FILE_OBJECT:
            dwErr = ReadFilePropertyRights(pwszObject,
                                           pRightsInfo,
                                           cProps,
                                           **ppAccessList);

            break;

        case SE_SERVICE:
            dwErr = ReadServicePropertyRights(pwszObject,
                                              pRightsInfo,
                                              cProps,
                                              **ppAccessList);
            break;

        case SE_PRINTER:
            dwErr = ReadPrinterPropertyRights(pwszObject,
                                              pRightsInfo,
                                              cProps,
                                              **ppAccessList);
            break;

        case SE_REGISTRY_KEY:
            dwErr = ReadRegistryPropertyRights(pwszObject,
                                              pRightsInfo,
                                              cProps,
                                              **ppAccessList);
            break;

        case SE_LMSHARE:
            dwErr = ReadSharePropertyRights(pwszObject,
                                            pRightsInfo,
                                            cProps,
                                            **ppAccessList);
            break;

        case SE_DS_OBJECT:
#ifdef ACTRL_NEED_SET_PRIVS
            dwErr = SetPriv();
            if(dwErr == ERROR_SUCCESS)
            {
#endif
            dwErr = ReadDSObjPropertyRights(pwszObject,
                                            pRightsInfo,
                                            cProps,
                                            **ppAccessList);
#ifdef ACTRL_NEED_SET_PRIVS
            }
#endif
            break;

        case SE_DS_OBJECT_ALL:
#ifdef ACTRL_NEED_SET_PRIVS
            dwErr = SetPriv();
            if(dwErr == ERROR_SUCCESS)
            {
#endif
            (**ppAccessList).SetDsPathInfo(NULL,
                                           (PWSTR)pwszObject);
            dwErr = ReadAllDSObjPropertyRights(pwszObject,
                                               pRightsInfo,
                                               cProps,
                                               **ppAccessList);
#ifdef ACTRL_NEED_SET_PRIVS
            }
#endif
            break;

        default:
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    if (dwErr != ERROR_SUCCESS) {
        delete (*ppAccessList);
        *ppAccessList = 0;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvGetAccessListForHandle
//
//  Synopsis:
//
//  Arguments:  [IN  hObject]           --  Handle to the object
//              [IN  ObjectType]        --  Type of the object
//              [IN  SecurityInfo]      --  What information is be obtained
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN OUT AccList]        --  The CAccessList reference to fill
//              [OUT ppOwner]           --  Number of trustees in list
//              [OUT ppGroup]           --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvGetAccessListForHandle(IN  HANDLE                     hObject,
                             IN  SE_OBJECT_TYPE             ObjectType,
                             IN  PACTRL_RIGHTS_INFO         pRightsInfo,
                             IN  ULONG                      cProps,
                             OUT CAccessList              **ppAccessList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, allocate a new class pointer
    //
    *ppAccessList = new CAccessList;

    if(*ppAccessList == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    dwErr = (*ppAccessList)->SetObjectType(ObjectType);

    for(ULONG iIndex = 0; iIndex < cProps && dwErr == ERROR_SUCCESS; iIndex++)
    {
        //
        // Now, do the read
        //
        switch (ObjectType)
        {
        case SE_KERNEL_OBJECT:
            dwErr = GetKernelSecurityInfo(hObject,
                                          pRightsInfo,
                                          cProps,
                                          **ppAccessList);
            break;

        case SE_WMIGUID_OBJECT:
            dwErr = GetWmiGuidSecurityInfo(hObject,
                                           pRightsInfo,
                                           cProps,
                                           **ppAccessList);
            break;

        case SE_FILE_OBJECT:
            dwErr = ReadFileRights(hObject,
                                   pRightsInfo,
                                   cProps,
                                   **ppAccessList);

            break;

        case SE_SERVICE:
            dwErr = ReadServiceRights((SC_HANDLE)hObject,
                                      pRightsInfo,
                                      cProps,
                                      **ppAccessList);
            break;

        case SE_PRINTER:
            dwErr = ReadPrinterRights(hObject,
                                      pRightsInfo,
                                      cProps,
                                      **ppAccessList);
            break;

        case SE_REGISTRY_KEY:
            dwErr = ReadRegistryRights(hObject,
                                       pRightsInfo,
                                       cProps,
                                       **ppAccessList);
            break;

        case SE_WINDOW_OBJECT:
            dwErr = ReadWindowPropertyRights(hObject,
                                             pRightsInfo,
                                             cProps,
                                             **ppAccessList);
            break;


        case SE_LMSHARE:            // FALL THROUGH
        case SE_DS_OBJECT:          // FALL THROUGH
        case SE_DS_OBJECT_ALL:      // FALL THROUGH
            dwErr = ERROR_INVALID_PARAMETER;
            break;

        default:
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    if (dwErr != ERROR_SUCCESS) {
        delete (*ppAccessList);
        *ppAccessList = 0;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProSetRightsList
//
//  Synopsis:   Goes through an optional access and audit list, and builds
//              the required RIGHTS_INFO list
//
//  Arguments:  [IN  pAccessList]       --  Optional access list to scan
//              [IN  pAuditList]        --  Optional audit list to scan
//              [OUT pcItems]           --  Where the count of items in the
//                                          rights info list is returned
//              [OUT ppRightsList]      --  Where the rights list is returned
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvSetRightsList(IN  OPTIONAL   PACTRL_ACCESS            pAccessList,
                    IN  OPTIONAL   PACTRL_AUDIT             pAuditList,
                    OUT            PULONG                   pcItems,
                    OUT            PACTRL_RIGHTS_INFO      *ppRightsList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Simple.  We'll go through and count the number of entries we need
    //
    ULONG   cItems = 0;

    if(pAccessList == NULL)
    {
        if(pAuditList != NULL)
        {
            cItems = pAuditList->cEntries;
        }
    }
    else
    {
        cItems = pAccessList->cEntries;
        if(pAuditList != NULL)
        {
            //
            // We'll make the assumption that they are all different.  In that
            // way, at worst, we'll allocate a few more pointers than we need
            // to.
            //
            cItems += pAuditList->cEntries;
        }
    }

    //
    // Now, do the allocation
    //
    *ppRightsList = (PACTRL_RIGHTS_INFO)AccAlloc(
                                       cItems * sizeof(ACTRL_RIGHTS_INFO));
    if(*ppRightsList == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        //
        // Ok, now we'll copy over only the unique lists
        //

        *pcItems = 0;
        //
        // Start with the access list
        //
        ULONG cAccess = 0;
        if(pAccessList != NULL)
        {
            for(ULONG iIndex = 0; iIndex < pAccessList->cEntries; iIndex++)
            {
                (*ppRightsList)[iIndex].pwszProperty = (PWSTR)
                        (pAccessList->pPropertyAccessList[iIndex].lpProperty);
                (*ppRightsList)[iIndex].SeInfo = DACL_SECURITY_INFORMATION;
            }

            *pcItems = pAccessList->cEntries;
            cAccess  = pAccessList->cEntries;
        }

        //
        // Ok, now process the audit list
        //
        if(pAuditList != NULL)
        {
            for(ULONG iIndex = 0; iIndex < pAuditList->cEntries; iIndex++)
            {
                //
                // See if this is a new entry or not...
                //
                for(ULONG iChk = 0; iChk < cAccess; iChk++)
                {
                    if(_wcsicmp((PWSTR)(pAuditList->
                                      pPropertyAccessList[iIndex].lpProperty),
                                (*ppRightsList)[iChk].pwszProperty) == 0)
                    {
                        (*ppRightsList)[iIndex].SeInfo |=
                                                    SACL_SECURITY_INFORMATION;
                        break;
                    }
                }

                //
                // Ok, if we got and didn't find the entry, add it
                //
                if(iChk >= cAccess)
                {
                    (*ppRightsList)[*pcItems].pwszProperty = (PWSTR)
                        (pAuditList->pPropertyAccessList[iIndex].lpProperty);
                    (*ppRightsList)[*pcItems].SeInfo =
                                                   SACL_SECURITY_INFORMATION;
                }
            }
        }
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   InsertAndContinueWorkerThread
//
//  Synopsis:   Inserts a new worker thread info into the list, and resumes
//              the worker thread
//
//  Arguments:  [IN  pWrkrInfo]         --  Worker info to insert
//
//  Returns:    ERROR_SUCCESS           --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
InsertAndContinueWorkerThread(PNTMARTA_WRKR_INFO      pWrkrInfo)
{
    DWORD   dwErr = ERROR_SUCCESS;
    HANDLE  Token = NULL;

    //
    // If there is a thread token, make sure we set it as our current thread token before
    // we continue execution
    //
    if(!OpenThreadToken(GetCurrentThread(),
                        MAXIMUM_ALLOWED,
                        TRUE,
                        &Token))
    {
        dwErr = GetLastError();

        //
        // if not, use the process token
        //
        if(dwErr == ERROR_NO_TOKEN)
        {
            dwErr = ERROR_SUCCESS;
        }
    }
    else
    {
        if(SetThreadToken(&(pWrkrInfo->hWorker),
                          Token) == FALSE )
        {

            dwErr = GetLastError();
        }
    }

    if (dwErr == ERROR_SUCCESS)
    {

        RtlAcquireResourceExclusive(&gWrkrLock, TRUE);

        dwErr = gWrkrList.Insert((PVOID)pWrkrInfo);

        if(dwErr == ERROR_SUCCESS)
        {
            if(ResumeThread(pWrkrInfo->hWorker) == 0xFFFFFFFF)
            {
                dwErr = GetLastError();
            }
        }

        RtlReleaseResource(&gWrkrLock);

        //
        // If we failed to insert or resume the thread, make sure to
        // kill it
        //
        if(dwErr != ERROR_SUCCESS)
        {
            TerminateThread(pWrkrInfo->hWorker,
                            dwErr);
        }

    }


    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\printer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:    printer.cxx
//
//  Contents:    local functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   OpenPrinterObject
//
//  Synopsis:   Opens the specified printer object
//
//  Arguments:  [IN pwszPrinter]        --      The name of the printer to
//                                              open
//              [IN AccessMask]         --      Flags indicating if the object
//                                              is to be opened to read or write
//                                              the DACL
//              [OUT pHandle]           --      Where the open handle is
//                                              returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad name was given
//
//----------------------------------------------------------------------------
DWORD
OpenPrinterObject( IN  LPWSTR       pwszPrinter,
                   IN  ACCESS_MASK  AccessMask,
                   OUT PHANDLE      pHandle)
{
    acDebugOut((DEB_TRACE, "in OpenPrinterObject\n"));

    DWORD dwErr;

    //
    // Make sure the printer functions are loaded
    //
    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    if(pwszPrinter != NULL)
    {
        PRINTER_DEFAULTS pd;
        pd.pDatatype     = NULL;
        pd.pDevMode      = NULL;
        pd.DesiredAccess = AccessMask;

        //
        // open the printer
        //
        if(DLLFuncs.POpenPrinter(pwszPrinter, pHandle, &pd) == FALSE)
        {
            dwErr = GetLastError();
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    acDebugOut((DEB_TRACE, "Out OpenPrinterObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadPrinterPropertyRights
//
//  Synopsis:   Gets the specified security info for the specified printer
//              object
//
//  Arguments:  [IN  pwszPrinter]       --      The printer to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadPrinterPropertyRights(IN  LPWSTR                pwszPrinter,
                          IN  PACTRL_RIGHTS_INFO    pRightsList,
                          IN  ULONG                 cRights,
                          IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadPrinterPropertyRights \n"));

    HANDLE  hPrinter;
    DWORD   dwErr;

    //
    // For the moment, there is only the printer property itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = OpenPrinterObject(pwszPrinter,
                              GetDesiredAccess(READ_ACCESS_RIGHTS,
                                               pRightsList[0].SeInfo),
                              &hPrinter);

    if(dwErr == ERROR_SUCCESS)
    {

        dwErr = ReadPrinterRights(hPrinter,
                                  pRightsList,
                                  cRights,
                                  AccessList);


        //
        // Close the printer handle
        //
        DLLFuncs.PClosePrinter(hPrinter);
    }

    acDebugOut((DEB_TRACE, "Out ReadPrinterPropertyRights: %lu\n", dwErr));
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ReadPrinterRights
//
//  Synopsis:   Gets the specified security info for the specified printer
//              object
//
//  Arguments:  [IN  hPrinter]          --      Open printer handle
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadPrinterRights(IN  HANDLE                hPrinter,
                  IN  PACTRL_RIGHTS_INFO    pRightsList,
                  IN  ULONG                 cRights,
                  IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadPrinterRights \n"));

    DWORD   dwErr = ERROR_SUCCESS;

    //
    // For the moment, there is only the printer property itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    UCHAR           PI3Buff[PSD_BASE_LENGTH];
    PPRINTER_INFO_3 pPI3 = (PPRINTER_INFO_3)PI3Buff;
    ULONG           cSize = 0;
    BOOLEAN         fDummy, fParmPresent;
    NTSTATUS        Status;
    PACL            pAcl = NULL;

    //
    // Get printer info 3 (a security descriptor)
    //
    if(DLLFuncs.PGetPrinter(hPrinter,
                            3,
                            (LPBYTE)pPI3,
                            PSD_BASE_LENGTH,
                            &cSize) == FALSE )
    {
        dwErr = GetLastError();
        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // Allocate one big enough
            //
            pPI3 = (PPRINTER_INFO_3)AccAlloc(cSize);
            if(pPI3 == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                dwErr = ERROR_SUCCESS;
                if(DLLFuncs.PGetPrinter(hPrinter,
                                        3,
                                        (LPBYTE)pPI3,
                                        cSize,
                                        &cSize) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

        }
    }

    //
    // Because the printer APIs are not very smart, we need to make
    // an explicit check to see if the handle was opened with the correct
    // access to return what the caller wants.
    //
    // eg. if caller wants a DACL but got the handle with only
    // ACCESS_SYSTEM_INFO, then we need to return ACCESS_DENIED.
    //

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // If caller wants DACL, group, or owner, then they must open
        // the handle with READ_CONTROL. The only way we can check this
        // is to see if there is a DACL present.
        //
        fParmPresent = FALSE;
        Status = RtlGetDaclSecurityDescriptor(pPI3->pSecurityDescriptor,
                                              &fParmPresent,
                                              &pAcl,
                                              &fDummy);
        if(NT_SUCCESS(Status))
        {
            if (fParmPresent == FALSE &&
               (FLAG_ON(pRightsList[0].SeInfo,DACL_SECURITY_INFORMATION) ||
                FLAG_ON(pRightsList[0].SeInfo,OWNER_SECURITY_INFORMATION)||
                FLAG_ON(pRightsList[0].SeInfo,GROUP_SECURITY_INFORMATION)))

            {
                //
                // this means that the handle was not open with correct access.
                //
                dwErr = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Do same hack with SACL
        //
        fParmPresent = FALSE;
        Status = RtlGetSaclSecurityDescriptor(pPI3->pSecurityDescriptor,
                                              &fParmPresent,
                                              &pAcl,
                                              &fDummy);
        if(NT_SUCCESS(Status))
        {
            if(fParmPresent == FALSE &&
               FLAG_ON(pRightsList[0].SeInfo,SACL_SECURITY_INFORMATION))
            {
                dwErr = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }

    //
    // Finally, add the security descriptor
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccessList.AddSD(pPI3->pSecurityDescriptor,
                                 pRightsList->SeInfo,
                                 pRightsList->pwszProperty);
    }

    if(cSize > PSD_BASE_LENGTH)
    {
        AccFree(pPI3);
    }


    acDebugOut((DEB_TRACE, "Out ReadPrinterRights: %lu\n", dwErr));
    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetPrinterParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for kernel objects
//
//  Arguments:  [IN  pwszPrinter]       --      The printer to get the parent
//                                              for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_INVALID_FUNCTION  --      Call doesn't make sense here
//
//----------------------------------------------------------------------------
DWORD
GetPrinterParentRights(IN  LPWSTR                    pwszPrinter,
                       IN  PACTRL_RIGHTS_INFO        pRightsList,
                       IN  ULONG                     cRights,
                       OUT PACL                     *ppDAcl,
                       OUT PACL                     *ppSAcl,
                       OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    //
    // This doesn't currently make sense for kernel objects, so simply
    // return an error
    //
    return(ERROR_INVALID_FUNCTION);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetPrinterSecurityInfo
//
//  Synopsis:   Sets the specified security info on the specified printer
//              object
//
//  Arguments:  [IN  hPrinter]          --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetPrinterSecurityInfo(IN  HANDLE                    hPrinter,
                       IN  SECURITY_INFORMATION      SeInfo,
                       IN  PWSTR                     pwszProperty,
                       IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetPrinterSecurityInfo\n"));
    DWORD dwErr = ERROR_SUCCESS;

    //
    // Make sure the printer functions are loaded
    //

    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //
    // Service don't have properties
    //
    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PRINTER_INFO_3 PI3;

        PI3.pSecurityDescriptor = pSD;

        if (DLLFuncs.PSetPrinter(hPrinter,
                                 3,
                                 (LPBYTE)&PI3,
                                 0) == FALSE)
        {
            dwErr = GetLastError();
        }
    }

    acDebugOut((DEB_TRACE, "Out SetPrinterSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ClosePrinterObject
//
//  Synopsis:   Closes the opened printer handle
//
//  Arguments:  [IN  hPrinter]          --      The handle of the printer
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
ClosePrinterObject(IN  HANDLE   hPrinter)
{
    acDebugOut((DEB_TRACE, "in ClosePrinterObject\n"));
    DWORD dwErr = ERROR_SUCCESS;

    //
    // Make sure the printer functions are loaded
    //

    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //
    // Close the printer handle
    //
    DLLFuncs.PClosePrinter(hPrinter);

    acDebugOut((DEB_TRACE, "Out ClosePrinterObject: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\member.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1994 - 1996.
//
// File:        member.cxx
//
// Classes:     CMemberCheck
//
// History:     Nov-94      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <ntprov.hxx>
    #include <strings.h>
}

SID WORLD_SID = {SID_REVISION,
                 1,
                 SECURITY_WORLD_SID_AUTHORITY,
                 SECURITY_WORLD_RID};

#define MARTA_MAX_RECURSION_COUNT 256
//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::Init, public
//
//  Synopsis:   initializes the class
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::Init()
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::Init\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // get the local machine name
    //
    ULONG   cSize = MAX_COMPUTERNAME_LENGTH + 1;
    if(GetComputerName(_wszComputerName, &cSize) == FALSE)
    {
        dwErr = GetLastError();
    }

    acDebugOut((DEB_TRACE, "Out CMemberCheck::Init: %lu\n", dwErr));

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::IsMemberOf, public
//
//  Synopsis:   Checks if the current sid is a member of the input sid.
//              The current sid is a part of our initialize TRUSTEE_NODE and
//              the input sid is in our passed in TRUSTEE_NODE
//
//  Arguments:  [IN  pTrusteeNode]          --  Input TRUSTEE_NODE
//              [OUT pfIsMemberOf]          --  Where the results are returned.
//                                              Is TRUE if the initialization
//                                              SID is a member of the input
//                                              SID.
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::IsMemberOf(IN  PTRUSTEE_NODE  pTrusteeNode,
                               OUT PBOOL          pfIsMemberOf)
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::IsMemberOf\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    if(RtlEqualSid(pTrusteeNode->pSid, &WORLD_SID) == TRUE)
    {
        *pfIsMemberOf = TRUE;
    }
    else if(RtlEqualSid(_pCurrentNode->pSid, pTrusteeNode->pSid) == TRUE)
    {
        //
        // If they're the same sid, they're bound to be a member of eachother
        //
        *pfIsMemberOf = TRUE;
    }
    else if(pTrusteeNode->SidType == SidTypeGroup)
    {
        //
        // We'll have to look it up, and check for group membership
        //
        dwErr = CheckGroup(pTrusteeNode->pSid,
                           pfIsMemberOf, 
                           1);
    }
    else if(pTrusteeNode->SidType == SidTypeAlias)
    {
        //
        // We'll have to expand the alias and look
        //
        dwErr = CheckAlias(pTrusteeNode->pSid,
                           pfIsMemberOf, 
                           1);
    }
    else
    {
        //
        // Well, here's something we don't know how to handle
        //
        *pfIsMemberOf = FALSE;
    }

    acDebugOut((DEB_TRACE,
                "Out CMemberCheck::IsMemberOf(%lx)(%d)\n",
                dwErr,
                *pfIsMemberOf));
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Member:     GetDomainName, private
//
//  Synopsis:   gets the domain name for the given sid
//
//  Arguments:  [IN  pSid]             --  Input Sid
//              [OUT ppwszDomainName]  --  To return the domain name
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------

DWORD
GetDomainName(
    IN PSID pSid,
    OUT PWSTR *ppwszDomainName
    )
{
    LPWSTR Name = NULL;
    LPWSTR RefName = NULL;
    SID_NAME_USE SidType;

    //
    // Lookup the sid and get the name for the user.
    //

    DWORD dwErr = AccLookupAccountName(
                      NULL,
                      pSid,
                      ppwszDomainName,
                      &RefName,
                      &SidType
                      );

    if (dwErr == ERROR_SUCCESS) 
    {
        //
        // The returned string is of the type "Domain\\User". Strip off the 
        // backslash to get the name of the domain.
        //

        PWSTR pwszTmp = wcschr(*ppwszDomainName, L'\\');

        if(pwszTmp != NULL)
        {
            *pwszTmp = L'\0';
        }

        //
        // We do not need this one. Free it.
        //

        AccFree(RefName);
    }

    return dwErr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::GetDomainInfo, private
//
//  Synopsis:   gets the domain handle for the domain of the specified account
//
//  Arguments:  [IN  pSid]          --  Input Sid
//
//  Returns:    ERROR_SUCCESS               --  Success
//              ERROR_NOT_ENOUGH_MEMORY     --  A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::GetDomainInfo(IN  PSID    pSid)
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::GetDomainInfo\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     fSidMatched = FALSE;
    PISID    pCheckSid;


    DWORD dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //
    // allocate a spare sid so we can grovel in it for the domain id
    //
    pCheckSid = (PISID)AccAlloc(RtlLengthSid(pSid));
    if(pCheckSid != NULL)
    {
        Status = RtlCopySid(RtlLengthSid(pSid),
                                         pCheckSid,
                                         pSid);
        if(NT_SUCCESS(Status))
        {

            //
            // make it the domain identifier 
            //
            if(pCheckSid->SubAuthorityCount > 1)
            {
                --(pCheckSid->SubAuthorityCount);
            }

            //
            // if we already have a domain sid, check it against the input sid
            //
            if(_pDomainSid != NULL)
            {
                if(RtlEqualSid(pCheckSid, _pDomainSid))
                {
                    //
                    // in this case we are all done.
                    //
                    AccFree(pCheckSid);
                    pCheckSid = NULL;
                    fSidMatched = TRUE;
                }
            }


            if ( fSidMatched == FALSE)
            {
                PDOMAIN_CONTROLLER_INFO DomainInfo = NULL;

                //
                // Free the current sid
                //
                AccFree(_pDomainSid);
                _pDomainSid = NULL;

                if(_hDomain)
                {
                    (*DLLFuncs.PSamCloseHandle)(_hDomain);
                    _hDomain = NULL;
                }

                SAM_HANDLE      hSam = NULL;

                PWSTR pwszDomainName = NULL;

                dwErr = GetDomainName(pSid, &pwszDomainName);

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // If we know the domain name of the input sid, check for
                    // well known, and local names
                    //
                    if(pwszDomainName != NULL)
                    {
                        WCHAR wszStringBuffer[256];

                        if (!LoadString(ghDll,
                                   ACCPROV_BUILTIN,
                                   wszStringBuffer,
                                   sizeof( wszStringBuffer ) / sizeof( WCHAR ))
                                   ) {
                            wszStringBuffer[0] = L'\0';
                        }

                        if(_wcsicmp(pwszDomainName,
                                    wszStringBuffer) != 0)
                        {
                            if (!LoadString(ghDll,
                                       ACCPROV_NTAUTHORITY,
                                       wszStringBuffer,
                                       sizeof( wszStringBuffer ) / sizeof( WCHAR ))
                                       ) {
                                wszStringBuffer[0] = L'\0';
                            }

                            if(_wcsicmp(pwszDomainName,
                                        wszStringBuffer) != 0)
                            {
                                if(_wcsicmp(_wszComputerName,
                                          pwszDomainName) != 0)
                                {
                                    dwErr = DsGetDcName(NULL, pwszDomainName, NULL, NULL, 0, &DomainInfo);
                                }
                            }
                        }
                    }


                    if(dwErr == ERROR_SUCCESS)
                    {
                        UNICODE_STRING UnicodeString = {0};
                        
                        if (DomainInfo != NULL)
                        {
                            RtlInitUnicodeString(&UnicodeString, DomainInfo->DomainControllerName);
                        }

                        OBJECT_ATTRIBUTES ObjAttrib;
                        Status = (*DLLFuncs.PSamConnect)(
                                       DomainInfo ? &UnicodeString : NULL,
                                       &hSam,
                                       GENERIC_EXECUTE,
                                       &ObjAttrib);


                        if(NT_SUCCESS(Status))
                        {
                            //
                            // open the domain
                            //
                            Status = (*DLLFuncs.PSamOpenDomain)(
                                                hSam,
                                                GENERIC_READ | DOMAIN_LOOKUP,
                                                pCheckSid,
                                                &_hDomain);

                            (*DLLFuncs.PSamCloseHandle)(hSam);
                        }

                        dwErr = RtlNtStatusToDosError(Status);
                    }

                       
                    if (DomainInfo)
                    {
                        NetApiBufferFree(DomainInfo);
                        DomainInfo = NULL;
                    }

                    AccFree(pwszDomainName);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // We have a new DomainSid
                        //
                        _pDomainSid = pCheckSid;
                        pCheckSid = NULL;
                    }
                }
            }
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (pCheckSid != NULL) 
    {
        AccFree(pCheckSid);
    }

    acDebugOut((DEB_TRACE, "Out CMemberCheck::_GetDomainInfo: %lu\n",
               dwErr));

    return(dwErr);
}
//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::CheckDomainUsers, private
//
//  Synopsis:   Checks if the Group is Domain Users and if the Users Domain sid
//              is the same as that of the group.
//
//  Arguments:  [IN  pSid]          --  Input Sid
//              [OUT pfIsMemberOf]          --  Where the results are returned.
//                                              Is TRUE if the current SID
//                                              is a member of the input SID
//                                              group.
//              [OUT pbQuitEarly]          --  Is TRUE if the group is Domain Users
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::CheckDomainUsers(IN  PSID  pSid,
                                     OUT PBOOL pfIsMemberOf, 
                                     OUT PBOOL pbQuitEarly)
{
    DWORD Rid = ((PISID) pSid)->SubAuthority[((PISID) pSid)->SubAuthorityCount-1];
    BOOL b = FALSE;
    BOOL bEqual = FALSE;
    SAM_HANDLE hUser = 0;
    PUCHAR Buffer = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    if (Rid != DOMAIN_GROUP_RID_USERS)
    {
        //
        // No need to do anything. Just return.
        //

        return ERROR_SUCCESS;
    }

    //
    // Since it is domain users we will quit early.
    //

    *pbQuitEarly = TRUE;

    b = EqualDomainSid(pSid, _pCurrentNode->pSid, &bEqual);

    //
    // ERROR_NON_DOMAIN_SID is returned for wellknown sids.
    // It is ok to ignore this error and continue.
    //

    if ((b == FALSE) && (GetLastError() != ERROR_NON_DOMAIN_SID))
    {
        return GetLastError();
    }

    //
    // If the domains do not match, return FALSE.
    //

    if (!bEqual)
    {
        return ERROR_SUCCESS;
    }

    //
    // Get the Rid for the user.
    //

    DWORD dwRelativeId = *RtlSubAuthoritySid(
                             _pCurrentNode->pSid,
                             *RtlSubAuthorityCountSid(_pCurrentNode->pSid) - 1
                             );

    //
    // Open the user for read.
    //
    
    status = SamOpenUser(
                 _hDomain,
                 USER_READ_GENERAL,
                 dwRelativeId,
                 &hUser
                 );
    
    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }
    
    //
    // Get the primary group information for the user.
    //
    
    status = SamQueryInformationUser(
                 hUser,
                 UserPrimaryGroupInformation,
                 (PVOID *) &Buffer
                 );

    SamCloseHandle(hUser);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    //
    // If the primary group matched then return TRUE.
    //

    if (DOMAIN_GROUP_RID_USERS == ((USER_PRIMARY_GROUP_INFORMATION *) Buffer)->PrimaryGroupId)
    {
        *pfIsMemberOf = TRUE;
    }

    (VOID) SamFreeMemory(Buffer);

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::CheckGroup, private
//
//  Synopsis:   Checks if the objects account is in the specifed group
//              account
//
//  Arguments:  [IN  pSid]                  --  Input Sid
//              [OUT pfIsMemberOf]          --  Where the results are returned.
//                                              Is TRUE if the current SID
//                                              is a member of the input SID
//                                              group.
//              [IN RecursionCount]         -- Recursion level 
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::CheckGroup(IN  PSID  pSid,
                               OUT PBOOL pfIsMemberOf,
                               IN  DWORD RecursionCount)
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::CheckGroup\n"));
    NTSTATUS    Status;
    SAM_HANDLE  hSam = NULL;
    ULONG       rid = ((PISID)(pSid))->SubAuthority[
                         ((PISID)(pSid))->SubAuthorityCount-1];
    BYTE LocalBuffer[8 + 4 * SID_MAX_SUB_AUTHORITIES];
    PISID LocalSid = (PISID) LocalBuffer;
    PULONG      attributes = NULL;
    PULONG      Members = NULL;
    ULONG       cMembers;
    DWORD       dwErr;
    BOOL bQuitEarly = FALSE;

    *pfIsMemberOf = FALSE;

    if (RecursionCount > MARTA_MAX_RECURSION_COUNT)
    {
        return ERROR_CIRCULAR_DEPENDENCY;
    }

    dwErr = LoadDLLFuncTable();
    if (dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
        return(dwErr);
    }

    dwErr = GetDomainInfo(pSid);
    if(dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
        return(dwErr);
    }

    Status = RtlCopySid(RtlLengthSid(_pDomainSid), LocalSid, _pDomainSid);

    if(!NT_SUCCESS(Status))
    {
        return RtlNtStatusToDosError(Status);
    }

    //
    // Special case the Domain Users sid.
    //

    dwErr = CheckDomainUsers(pSid, pfIsMemberOf, &bQuitEarly);
  
    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
 
    if (bQuitEarly)
    {
        //
        // We are looking at Domain Users group. No need to enumerate this one.
        //

        return ERROR_SUCCESS;
    }             

    //
    // open the group
    //
    Status = (*DLLFuncs.PSamOpenGroup)(_hDomain,
                                       GENERIC_READ,
                                       rid,
                                       &hSam);
    if(NT_SUCCESS(Status))
    {
        //
        // Get the members
        //
        Status = (*DLLFuncs.PSamGetMembersInGroup)(hSam,
                                                   &Members,
                                                   &attributes,
                                                   &cMembers);
        if(NT_SUCCESS(Status) && cMembers )
        {
            //
            // ugly sid rid twiddling
            //
            ++(LocalSid->SubAuthorityCount);

            //
            // loop thru the members and check if the user sid is an immediate
            // member.
            //
            for (ULONG iIndex = 0; iIndex < cMembers; iIndex++ )
            {
                //
                // Plug the rid into the sid
                //
                LocalSid->SubAuthority[LocalSid->SubAuthorityCount-1] =
                        Members[iIndex];

                //
                // and compare
                //
                if(RtlEqualSid(_pCurrentNode->pSid,LocalSid) == TRUE)
                {
                    *pfIsMemberOf = TRUE;
                    break;
                }
            }

            //
            // If we did not match the sid, enumerate recursively.
            //

            if (*pfIsMemberOf == FALSE)
            {
                ULONG SidLength = RtlLengthSid(LocalSid);
                ULONG TotalSize = cMembers * (sizeof(PSID) + SidLength);
                PUCHAR Buffer = NULL;
                PSID *Sids = NULL;


                //
                // Allocate memory to hold the sid array.
                //

                Buffer = (PUCHAR) AccAlloc(TotalSize);
                Sids = (PSID *) Buffer; 

                if (Sids != NULL)
                {
                    PLSA_TRANSLATED_NAME Names = NULL;
                    Buffer += (sizeof(PSID) * cMembers);

                    //
                    // Copy the sids into the allocated array.
                    //

                    for (ULONG iIndex = 0; iIndex < cMembers; iIndex++ )
                    {
                        Sids[iIndex] = Buffer;
                        Buffer += SidLength;

                        LocalSid->SubAuthority[LocalSid->SubAuthorityCount-1] =
                                Members[iIndex];

                        Status = RtlCopySid(SidLength, Sids[iIndex], LocalSid);

                        if (!NT_SUCCESS( Status ))
                        {
                            break;
                        }

                    }

                    if (NT_SUCCESS( Status ))
                    {

                        //
                        // Do a single lookup and get the types of the sids 
                        // in the group.
                        //

                        dwErr = GetSidTypeMultiple(
                                     cMembers,
                                     Sids,
                                     &Names
                                     );

                        if (dwErr == ERROR_SUCCESS)
                        {
                            //
                            // Loop thru the sids and call the recursive routines
                            // if the sidtype is a group or alias.
                            // 

                            for (ULONG iIndex = 0; iIndex < cMembers; iIndex++ )
                            {
                                if (Names[iIndex].Use == SidTypeGroup)
                                {
                                    dwErr = CheckGroup(Sids[iIndex], pfIsMemberOf, RecursionCount+1);

                                    if (dwErr != ERROR_SUCCESS)
                                    {
                                        break;
                                    }

                                    if (*pfIsMemberOf == TRUE)
                                    {
                                        //
                                        // We have a match. There is no need to
                                        // enumerate any more.
                                        //

                                        break;
                                    }
                                }
                                else if (Names[iIndex].Use == SidTypeAlias)
                                {
                                    dwErr = CheckAlias(Sids[iIndex], pfIsMemberOf, RecursionCount+1);

                                    if (dwErr != ERROR_SUCCESS)
                                    {
                                        break;
                                    }

                                    if (*pfIsMemberOf == TRUE)
                                    {
                                        //
                                        // We have a match. There is no need to
                                        // enumerate any more.
                                        //

                                        break;
                                    }
                                }
                            }

                            (VOID) LsaFreeMemory(Names);
                        }
                    }

                    AccFree(Sids);
                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                }
            }

        }

        if (attributes != NULL)
        {
            LocalFree(attributes);
            attributes = NULL;
        }

        if (Members != NULL)
        {
            LocalFree(Members);
            Members = NULL;
        }

        (*DLLFuncs.PSamCloseHandle)(hSam);
    }

    if(!NT_SUCCESS(Status))
    {
        dwErr = RtlNtStatusToDosError(Status);
    }

    acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::GetSidType, private
//
//  Synopsis:   Returns the type of the Sid
//
//  Arguments:  [IN  pSid]         --  Input Sid
//              [OUT pSidType]     --  Returns the type of Sid.
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::GetSidType(
    IN PSID Sid,
    OUT SID_NAME_USE *pSidType)
{
    LPWSTR Name = NULL;
    LPWSTR DomainName = NULL;
    DWORD dwErr;

    dwErr = AccLookupAccountName(NULL,
                                 Sid,
                                 &Name,
                                 &DomainName,
                                 pSidType);

    if (dwErr == ERROR_SUCCESS)
    {
        AccFree(Name);
        AccFree(DomainName);
    }

    return dwErr;
    
}

//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::GetSidTypeMultiple, private
//
//  Synopsis:   Returns the tanslated names of the Sids
//
//  Arguments:  [IN  Count]        --  Number of sids
//              [IN  pSid]         --  Input Sid
//              [OUT pNames]       --  Returns lsa names structure
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::GetSidTypeMultiple(
    IN LONG Count,
    IN PSID *Sids,
    OUT PLSA_TRANSLATED_NAME *pNames
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE PolicyHandle;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains;
    PLSA_TRANSLATED_NAME Names = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    NTSTATUS Status;
    NTSTATUS TmpStatus;

    *pNames = NULL;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError(Status);
    }

    Status = LsaLookupSids(
                 PolicyHandle,
                 Count,
                 Sids,
                 &ReferencedDomains,
                 &Names
                 );

    TmpStatus = LsaClose( PolicyHandle );

    //
    // If an error was returned, check specifically for STATUS_NONE_MAPPED.
    // In this case, we may need to dispose of the returned Referenced Domain
    // List and Names structures.  For all other errors, LsaLookupSids()
    // frees these structures prior to exit.
    //

    if ( !NT_SUCCESS( Status )) {

        if (Status == STATUS_NONE_MAPPED) {

            if (ReferencedDomains != NULL) {

                TmpStatus = LsaFreeMemory( ReferencedDomains );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }

            if (Names != NULL) {

                TmpStatus = LsaFreeMemory( Names );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }
        }


        return RtlNtStatusToDosError(Status);
    }

    if (ReferencedDomains != NULL) {

        Status = LsaFreeMemory( ReferencedDomains );
        ASSERT( NT_SUCCESS( Status ));
    }

    *pNames = Names;

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::CheckAlias, private
//
//  Synopsis:   checks if the objects account is in the specifed alias account
//
//  Arguments:  [IN  pSid]                  --  Input Sid
//              [OUT pfIsMemberOf]          --  Where the results are returned.
//                                              Is TRUE if the current SID
//                                              is a member of the input SID
//                                              group.
//              [IN RecursionCount]         -- Recursion level 
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::CheckAlias(IN  PSID  pSid,
                               OUT PBOOL          pfIsMemberOf,
                               IN DWORD RecursionCount)
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::CheckAlias\n"));
    NTSTATUS    Status;
    SAM_HANDLE  hSam = NULL;
    ULONG       rid = ((PISID)(pSid))->SubAuthority[
                         ((PISID)(pSid))->SubAuthorityCount-1];
    ULONG_PTR * Members;
    ULONG       cMembers;
    DWORD       dwErr;

    *pfIsMemberOf = FALSE;

    if (RecursionCount > MARTA_MAX_RECURSION_COUNT)
    {
        return ERROR_CIRCULAR_DEPENDENCY;
    }

    dwErr = LoadDLLFuncTable();
    if (dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
        return(dwErr);
    }

    dwErr = GetDomainInfo(pSid);
    if(dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
        return(dwErr);
    }


    //
    // open the alias
    //
    Status = (*DLLFuncs.PSamOpenAlias)(_hDomain,
                                       GENERIC_READ,
                                       rid,
                                       &hSam);
    if(NT_SUCCESS(Status))
    {
        //
        // get the members
        //
        Status = (*DLLFuncs.PSamGetMembersInAlias)(hSam,
                                                  (void ***)&Members,
                                                  &cMembers);
        if(NT_SUCCESS(Status) && cMembers)
        {
            //
            // loop thru the members
            //
            for (ULONG iIndex = 0; iIndex < cMembers; iIndex++)
            {
                if(RtlEqualSid(_pCurrentNode->pSid,
                              ((SID **)(Members))[iIndex]) == TRUE)
                {
                    *pfIsMemberOf = TRUE;
                    break;
                }

            }

            //
            // If we did not match the sid, enumerate recursively.
            //

            if (*pfIsMemberOf == FALSE)
            {
                PLSA_TRANSLATED_NAME Names = NULL;

                //
                // Do a single lookup and get the types of the sids 
                // in the group.
                //

                dwErr = GetSidTypeMultiple(
                             cMembers,
                             (PSID *) Members,
                             &Names
                             );

                if (dwErr == ERROR_SUCCESS)
                {
                    //
                    // Loop thru the sids and call the recursive routines
                    // if the sidtype is a group or an alias.
                    // 

                    for (ULONG iIndex = 0; iIndex < cMembers; iIndex++ )
                    {
                        if (Names[iIndex].Use == SidTypeGroup)
                        {
                            dwErr = CheckGroup(((SID **) (Members))[iIndex], pfIsMemberOf, RecursionCount+1);

                            if (dwErr != ERROR_SUCCESS)
                            {
                                break;
                            }

                            if (*pfIsMemberOf == TRUE)
                            {
                                //
                                // We have a match. There is no need to
                                // enumerate any more.
                                //

                                break;
                            }
                        }
                        else if (Names[iIndex].Use == SidTypeAlias)
                        {
                            dwErr = CheckAlias(((SID **) (Members))[iIndex], pfIsMemberOf, RecursionCount+1);

                            if (dwErr != ERROR_SUCCESS)
                            {
                                break;
                            }

                            if (*pfIsMemberOf == TRUE)
                            {
                                //
                                // We have a match. There is no need to
                                // enumerate any more.
                                //

                                break;
                            }
                        }
                    }

                    (VOID) LsaFreeMemory(Names);
                }
            }

            if(cMembers > 0)
            {
                LocalFree(Members);
            }
        }

        (*DLLFuncs.PSamCloseHandle)(hSam);
    }

    if(!NT_SUCCESS(Status))
    {
        dwErr = RtlNtStatusToDosError(Status);
    }

    acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\prtctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       prtctx.h
//
//  Contents:   NT Marta printer context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__PRTCTX_H__)
#define __PRTCTX_H__

#include <windows.h>
#include <printer.h>
#include <assert.h>
#include <winspool.h>

//
// CPrinterContext.  This represents a printer object to the NT Marta
// infrastructure
//

class CPrinterContext
{
public:

    //
    // Construction
    //

    CPrinterContext ();

    ~CPrinterContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    DWORD InitializeByHandle (HANDLE Handle);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetPrinterProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetPrinterRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetPrinterRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

private:

    //
    // Reference count
    //

    DWORD     m_cRefs;

    //
    // Printer handles
    //

    HANDLE    m_hPrinter;

    //
    // Were we initialized by name or handle?
    //

    BOOL      m_fNameInitialized;
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\prtctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       prtctx.cpp
//
//  Contents:   Implementation of CPrinterContext and NT Marta Printer Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <prtctx.h>
//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::CPrinterContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CPrinterContext::CPrinterContext ()
{
    m_cRefs = 1;
    m_hPrinter = NULL;
    m_fNameInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::~CPrinterContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CPrinterContext::~CPrinterContext ()
{
    if ( ( m_hPrinter != NULL ) && ( m_fNameInitialized == TRUE ) )
    {
        ClosePrinter( m_hPrinter );
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the printer
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    PRINTER_DEFAULTSW PrinterDefaults;

    PrinterDefaults.pDatatype = NULL;
    PrinterDefaults.pDevMode = NULL;
    PrinterDefaults.DesiredAccess = AccessMask;

    if ( OpenPrinterW(
             (LPWSTR)pObjectName,
             &m_hPrinter,
             &PrinterDefaults
             ) == FALSE )
    {
        return( GetLastError() );
    }

    m_fNameInitialized = TRUE;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::InitializeByHandle, public
//
//  Synopsis:   initialize the context given a printer handle
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::InitializeByHandle (HANDLE Handle)
{
    m_hPrinter = Handle;
    assert( m_fNameInitialized == FALSE );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::GetPrinterProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::GetPrinterProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::GetPrinterRights, public
//
//  Synopsis:   get the Printer security descriptor
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::GetPrinterRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    PISECURITY_DESCRIPTOR pisd = NULL;
    PSECURITY_DESCRIPTOR  psd = NULL;
    DWORD                 cb = 0;
    PPRINTER_INFO_3       pPrinterInfo = NULL;

    assert( m_hPrinter != NULL );

    if ( ( GetPrinterW(
              m_hPrinter,
              3,
              (LPBYTE)pPrinterInfo,
              cb,
              &cb
              ) == FALSE ) &&
         ( cb > 0 ) )
    {
        pPrinterInfo = (PPRINTER_INFO_3)new BYTE [ cb ];
        if ( pPrinterInfo != NULL )
        {
            if ( GetPrinterW(
                    m_hPrinter,
                    3,
                    (LPBYTE)pPrinterInfo,
                    cb,
                    &cb
                    ) == FALSE )
            {
                delete pPrinterInfo;
                return( GetLastError() );
            }
        }
        else
        {
            return( E_OUTOFMEMORY );
        }
    }
    else
    {
        return( GetLastError() );
    }

    pisd = (PISECURITY_DESCRIPTOR)pPrinterInfo->pSecurityDescriptor;
    if ( pisd->Control & SE_SELF_RELATIVE )
    {
        cb = GetSecurityDescriptorLength( pPrinterInfo->pSecurityDescriptor );
        psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
        if ( psd == NULL )
        {
            delete pPrinterInfo;
            return( ERROR_OUTOFMEMORY );
        }

        memcpy( psd, pPrinterInfo->pSecurityDescriptor, cb );
    }
    else
    {
        if ( MakeSelfRelativeSD(
                 pPrinterInfo->pSecurityDescriptor,
                 NULL,
                 &cb
                 ) == FALSE )
        {
            if ( cb > 0 )
            {
                psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
                if ( psd != NULL )
                {
                    if ( MakeSelfRelativeSD(
                             pPrinterInfo->pSecurityDescriptor,
                             psd,
                             &cb
                             ) == FALSE )
                    {
                        LocalFree( psd );
                        delete pPrinterInfo;
                        return( GetLastError() );
                    }
                }
            }
            else
            {
                delete pPrinterInfo;
                return( GetLastError() );
            }
        }
    }

    delete pPrinterInfo;
    *ppSecurityDescriptor = psd;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::SetPrinterRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::SetPrinterRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    PRINTER_INFO_3 PrinterInfo;

    assert( m_hPrinter != NULL );

    PrinterInfo.pSecurityDescriptor = pSecurityDescriptor;

    if ( SetPrinterW( m_hPrinter, 3, (LPBYTE)&PrinterInfo, 0 ) == FALSE )
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//
// Functions from printer.h which dispatch unto the CPrinterContext class
//

DWORD
MartaAddRefPrinterContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CPrinterContext *)Context )->AddRef() );
}

DWORD
MartaClosePrinterContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CPrinterContext *)Context )->Release() );
}

DWORD
MartaGetPrinterProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CPrinterContext *)Context )->GetPrinterProperties( pProperties ) );
}

DWORD
MartaGetPrinterTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetPrinterRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CPrinterContext *)Context )->GetPrinterRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenPrinterNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CPrinterContext* pPrinterContext;

    pPrinterContext = new CPrinterContext;
    if ( pPrinterContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pPrinterContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pPrinterContext->Release();
        return( Result );
    }

    *pContext = pPrinterContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenPrinterHandleObject(
    IN  HANDLE   Handle,
    IN ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CPrinterContext* pPrinterContext;

    pPrinterContext = new CPrinterContext;
    if ( pPrinterContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pPrinterContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pPrinterContext->Release();
        return( Result );
    }

    *pContext = pPrinterContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetPrinterRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CPrinterContext *)Context )->SetPrinterRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:    registry.cxx
//
//  Contents:    local functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <alsup.hxx>
#include <martaevt.h>

//
// Registry generic mapping
//
GENERIC_MAPPING         gRegGenMapping = {STANDARD_RIGHTS_READ     | 0x1,
                                          STANDARD_RIGHTS_WRITE    | 0x2,
                                          STANDARD_RIGHTS_EXECUTE  | 0x4,
                                          STANDARD_RIGHTS_REQUIRED | 0x3F};



//+---------------------------------------------------------------------------
//
//  Function : GetDesiredAccess
//
//  Synopsis : Gets the access required to open object to be able to set or
//             get the specified security info.
//
//  Arguments: IN [SecurityOpenType]  - Flag indicating if the object is to be
//                                      opened to read or write the DACL
//
//----------------------------------------------------------------------------
ACCESS_MASK RegGetDesiredAccess(IN SECURITY_OPEN_TYPE   OpenType,
                                IN SECURITY_INFORMATION SecurityInfo)
{
    acDebugOut((DEB_TRACE_ACC, "in GetDesiredAccess \n"));

    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    acDebugOut((DEB_TRACE_ACC, "out RegGetDesiredAccess: %lu\n", DesiredAccess));

    return (DesiredAccess);
}


//+---------------------------------------------------------------------------
//
//  Function:   OpenRegistryObject
//
//  Synopsis:   Opens the specified registry object
//
//  Arguments:  [IN pwszRegistry]       --      The name of the registry key
//                                              to open
//              [IN AccessMask]         --      Flags indicating if the object
//                                              is to be opened to read or write
//                                              the DACL
//              [OUT pHandle]           --      Where the open handle is
//                                              returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//              ERROR_INVALID_PARAMETER --      A bad name was given
//
//----------------------------------------------------------------------------
DWORD
OpenRegistryObject(IN  LPWSTR       pwszRegistry,
                   IN  ACCESS_MASK  AccessMask,
                   OUT PHANDLE      pHandle)
{
    acDebugOut((DEB_TRACE, "in OpenRegistryObject\n"));

    DWORD dwErr;
    HKEY  hBase;

    if(pwszRegistry != NULL)
    {
        WCHAR   wszName[MAX_PATH + 1];
        PWSTR   pwszName;
        //
        // save the object since we must crack it to go to remote machines
        //
        dwErr = AccGetBufferOfSizeW(pwszRegistry,
                                    wszName,
                                    &pwszName);
        if(dwErr == ERROR_SUCCESS)
        {
            PWSTR   pwszRemaining, pwszMachine;

            //
            // Separate the names
            //
            dwErr = ParseName(pwszName,
                              &pwszMachine,
                              &pwszRemaining);

            if(dwErr == ERROR_SUCCESS)
            {
                PWSTR   pwszKey = NULL;
                //
                // look for the key names  localization required.
                //
                if (pwszRemaining != NULL)
                {
                    PWSTR   pwszBase = pwszRemaining;
                    pwszKey  = wcschr(pwszRemaining, L'\\');
                    if(pwszKey != NULL)
                    {
                        *pwszKey = L'\0';
                        pwszKey++;
                    }

                    //
                    // Now, figure out what our base key will be
                    //
                    if(_wcsicmp(pwszBase, L"MACHINE") == 0)
                    {
                        hBase = HKEY_LOCAL_MACHINE;
                    }
                    else if(_wcsicmp(pwszBase, L"USERS") == 0 ||
                            _wcsicmp(pwszBase, L"USER") == 0 )
                    {
                        hBase = HKEY_USERS;
                    }
                    //
                    // The next three are valid only for the local machine
                    //
                    else if(pwszMachine == NULL &&
                            _wcsicmp(pwszBase, L"CLASSES_ROOT") == 0)
                    {
                        hBase = HKEY_CLASSES_ROOT;
                    }
                    else if(pwszMachine == NULL &&
                            _wcsicmp(pwszBase,L"CURRENT_USER") == 0)
                    {
                        hBase = HKEY_CURRENT_USER;
                    }
                    else if(pwszMachine == NULL &&
                            _wcsicmp(pwszBase, L"CONFIG") == 0)
                    {
                        hBase = HKEY_CURRENT_CONFIG;
                    }
                    else
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                }
                else
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // if it is a remote name, connect to that registry
                    //
                    if(pwszMachine != NULL)
                    {
                        HKEY hMach = hBase;
                        dwErr = RegConnectRegistry(pwszMachine,
                                                   hMach,
                                                   &hBase);
                    }

                    //
                    // Now, open the key
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = RegOpenKeyEx(hBase,
                                             pwszKey,
                                             0,
                                             AccessMask,
                                             (PHKEY)pHandle);

                        if(pwszMachine != NULL)
                        {
                            RegCloseKey(hBase);
                        }
                    }
                }
            }

            AccFreeBufferOfSizeW(wszName, pwszName);
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    acDebugOut((DEB_TRACE, "Out OpenRegistryObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistryPropertyRights
//
//  Synopsis:   Gets the specified security info for the specified registry
//              object
//
//  Arguments:  [IN  pwszRegistry]      --      The reg key to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadRegistryPropertyRights(IN  LPWSTR                pwszRegistry,
                           IN  PACTRL_RIGHTS_INFO    pRightsList,
                           IN  ULONG                 cRights,
                           IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadRegistryPropertyRights\n"));

    HANDLE hReg;
    DWORD  dwErr;

    //
    // Currently, there are only registry object properties
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Set the lookup server name
    //
    dwErr = SetAccessListLookupServer( pwszRegistry,
                                       AccessList );

    //
    // Open the registry key
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = OpenRegistryObject(pwszRegistry,
                                   RegGetDesiredAccess(READ_ACCESS_RIGHTS,
                                                       pRightsList[0].SeInfo),
                                   &hReg);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        PSECURITY_DESCRIPTOR    pSD;
        dwErr = ReadRegistrySecurityInfo(hReg,
                                         pRightsList[0].SeInfo,
                                         &pSD);
        //
        // If that worked, we'll have to get the parent SD, if it exists,
        // and see if we can determine the inheritance on our current object
        //
        if(dwErr == ERROR_SUCCESS)
        {
            if((pRightsList[0].SeInfo & ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION)) != 0 &&
                !FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                         SE_SACL_AUTO_INHERITED |
                            SE_DACL_AUTO_INHERITED))
            {
                //
                // Ok, it's downlevel, so get the parent SD...
                //
                PSECURITY_DESCRIPTOR    pParentSD;
                dwErr = GetRegistryParentRights(pwszRegistry,
                                                pRightsList[0].SeInfo,
                                                &pParentSD);

                //
                // Also, the routine to convert from nt4 to nt5 security
                // descriptor requires that we have the owner and group,
                // so we may have to reread the child SD if we don't have
                // that info
                //
                if(dwErr == ERROR_SUCCESS && (!FLAG_ON(pRightsList[0].SeInfo,
                                            OWNER_SECURITY_INFORMATION)  ||
                                            !FLAG_ON(pRightsList[0].SeInfo,
                                            GROUP_SECURITY_INFORMATION)))
                {
                    AccFree(pSD);
                    pSD = NULL;
                    dwErr = ReadRegistrySecurityInfo(hReg,
                                                     pRightsList[0].SeInfo          |
                                                        OWNER_SECURITY_INFORMATION  |
                                                        GROUP_SECURITY_INFORMATION,
                                                     &pSD);
                }

                //
                // A NULL parent SD means this object has no parent!
                //
                if(dwErr == ERROR_SUCCESS && pParentSD != NULL)
                {
                    PSECURITY_DESCRIPTOR    pNewSD;
                    dwErr = ConvertToAutoInheritSD(pParentSD,
                                                   pSD,
                                                   TRUE,
                                                   &gRegGenMapping,
                                                   &pNewSD);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = AccessList.AddSD(pNewSD,
                                                 pRightsList[0].SeInfo,
                                                 pRightsList[0].pwszProperty);

                        DestroyPrivateObjectSecurity(&pNewSD);
                    }

                    AccFree(pParentSD);
                }
            }
            else
            {
                //
                // Simply add the SD to our list
                //
                dwErr = AccessList.AddSD(pSD,
                                         pRightsList[0].SeInfo,
                                         pRightsList[0].pwszProperty);

            }

            //
            // Make sure to free the security descriptor...
            //
            AccFree(pSD);
        }


        RegCloseKey((HKEY)hReg);
    }


    acDebugOut((DEB_TRACE, "Out  ReadRegistryPropertyRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistryRights
//
//  Synopsis:   Gets the specified security info for the specified registry
//              object
//
//  Arguments:  [IN  hRegistry]         --      Reg handle to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadRegistryRights(IN  HANDLE                hRegistry,
                   IN  PACTRL_RIGHTS_INFO    pRightsList,
                   IN  ULONG                 cRights,
                   IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadRegistryRights\n"));

    DWORD  dwErr;

    //
    // Currently, there are only registry object properties
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }


    PSECURITY_DESCRIPTOR    pSD = NULL;

    dwErr = ReadRegistrySecurityInfo(hRegistry,
                                     pRightsList[0].SeInfo,
                                     &pSD);
    if((dwErr != ERROR_SUCCESS) || (pSD == NULL))
    {
        return(dwErr);
    }

    //
    // Take a look at it... If it's a downlevel object, let's reread it as an uplevel, if
    // possible
    //
    if(!FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                  SE_SACL_AUTO_INHERITED |
                               SE_DACL_AUTO_INHERITED))
    {
        PWSTR   pwszRegPath = NULL;

        dwErr = ConvertRegHandleToName((HKEY)hRegistry,
                                       &pwszRegPath);
        if(dwErr != ERROR_SUCCESS)
        {
            if(dwErr == ERROR_INVALID_HANDLE)
            {
                //
                // It's remote, so add it as is...
                //
                dwErr = AccessList.AddSD(pSD,
                                         pRightsList->SeInfo,
                                         pRightsList->pwszProperty);
            }
        }
        else
        {
            dwErr = ReadRegistryPropertyRights(pwszRegPath,
                                               pRightsList,
                                               cRights,
                                               AccessList);
            AccFree(pwszRegPath);
        }

    }
    else
    {
        //
        // It's already uplevel, so add it as is...
        //
        dwErr = AccessList.AddSD(pSD,
                                 pRightsList->SeInfo,
                                 pRightsList->pwszProperty);
    }

    AccFree(pSD);

    acDebugOut((DEB_TRACE, "Out  ReadRegistryRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistrySecurityInfo
//
//  Synopsis:   Reads the specified security info for the handle's registry
//              key object
//
//  Arguments:  [IN  hRegistry]         --      The handle to the object to
//                                              get the rights for
//              [IN  SeInfo]            --      SecurityInfo to read based
//              [OUT ppOwner]           --      The owner sid
//              [OUT ppGroup]           --      The group sid
//              [OUT pDAcl]             --      The DACL
//              [OUT pSAcl]             --      The SACL
//              [OUT pSD]               --      The security descriptor itself
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadRegistrySecurityInfo(IN  HANDLE                 hRegistry,
                         IN  SECURITY_INFORMATION   SeInfo,
                         OUT PSECURITY_DESCRIPTOR  *ppSD)
{
    acDebugOut((DEB_TRACE, "in ReadRegistrySecurityInfo \n"));

    ULONG                   cSize = 0;
    DWORD                   dwErr;

    //
    // First, get the size we need
    //
    dwErr = RegGetKeySecurity((HKEY)hRegistry,
                              SeInfo,
                              *ppSD,
                              &cSize);
    if(dwErr == ERROR_INSUFFICIENT_BUFFER)
    {
        dwErr = ERROR_SUCCESS;
        *ppSD = (PISECURITY_DESCRIPTOR)AccAlloc(cSize);
        if(*ppSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            dwErr = RegGetKeySecurity((HKEY)hRegistry,
                                      SeInfo,
                                      *ppSD,
                                      &cSize);


            if(dwErr == ERROR_SUCCESS &&
                FLAG_ON(((SECURITY_DESCRIPTOR *)*ppSD)->Control,SE_SELF_RELATIVE))
            {
                PSECURITY_DESCRIPTOR    pAbs;
                dwErr = MakeSDAbsolute(*ppSD,
                                       SeInfo,
                                       &pAbs);
                if(dwErr == ERROR_SUCCESS)
                {
                    AccFree(*ppSD);
                    *ppSD = pAbs;
                }
            }
        }
    }
    else

    {
        ASSERT(dwErr != ERROR_INSUFFICIENT_BUFFER);
    }


    acDebugOut((DEB_TRACE, "Out ReadRegistrySecurityInfo: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetRegistryParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for kernel objects
//
//  Arguments:  [IN  pwszRegistry]      --      The reg path to get the parent
//                                              for
//              [IN  SeInfo]            --      The security information to do
//                                              the read for
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//
//----------------------------------------------------------------------------
DWORD
GetRegistryParentRights(IN  LPWSTR                    pwszRegistry,
                        IN  SECURITY_INFORMATION      SeInfo,
                        OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;
    //
    // Basically, we'll figure out who our parent is, and get their info
    //
    PWSTR   pwszLastComp = wcsrchr(pwszRegistry, L'\\');
    if(pwszLastComp == NULL)
    {
        //
        // Ok, we must be at the root, so we won't have any inheritance
        //
        //
        // Return success after nulling out SD.
        //
        *ppSD = NULL;
    }
    else
    {
        //
        // We'll shorten our path, and then get the info
        //
        *pwszLastComp = L'\0';

        HANDLE  hReg;

        //
        // Don't want owner or group
        //
        SeInfo &= ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION);
        dwErr = OpenRegistryObject(pwszRegistry,
                                   RegGetDesiredAccess(READ_ACCESS_RIGHTS,SeInfo),
                                   &hReg);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ReadRegistrySecurityInfo(hReg,
                                             SeInfo,
                                             ppSD);
            RegCloseKey((HKEY)hReg);
        }

        *pwszLastComp = L'\\';

    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetRegistrySecurityInfo
//
//  Synopsis:   Sets the specified security info on the specified registry
//              object
//
//  Arguments:  [IN  hService]          --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetRegistrySecurityInfo(IN  HANDLE                    hRegistry,
                        IN  SECURITY_INFORMATION      SeInfo,
                        IN  PWSTR                     pwszProperty,
                        IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetNamedRegistrySecurityInfo\n"));

    DWORD dwErr;

    //
    // Registry keys don't have properties
    //
    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Marta only writes uplevel security descriptors.
        //
        // The caller of SetRegistrySecurityInfo will call with SE_xACL_AUTO_INHERITED off in those
        //  cases that it wants the underlying registry to do auto inheritance.
        // The caller of SetRegistrySecurityInfo will call with SE_xACL_AUTO_INHERITED on in those
        //  cases that it wants the underlying registry to simply store the bits.
        //
        // In the later case, the OS uses the SE_xACL_AUTO_INHERIT_REQ bit as a flag indicating
        // that it is OK to preserve SE_xACL_AUTO_INHERITED bit.
        //
        if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION)) {
            ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION)) {
            ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
        }

        dwErr = RegSetKeySecurity((HKEY)hRegistry,
                                  SeInfo,
                                  pSD);

    }

    acDebugOut((DEB_TRACE, "Out SetRegistrySecurityInfo: %lu\n", dwErr));
    return(dwErr);
}




#define CLEANUP_ON_INTERRUPT(pstopflag)                                     \
if(*pstopflag != 0)                                                         \
{                                                                           \
    goto RegCleanup;                                                        \
}
//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropagateRegistryPropertyRights
//
//  Synopsis:   Sets the access on the given registry path and propagates
//              it as necessary
//
//  Arguments:  [IN  pwszRegistry]      --      The path to set and propagate
//              [IN  pwszProperty]      --      The registry property to
//                                              operate upon
//              [IN  RootAccList]       --      The CAccessList class that has
//                                              the security descriptor/info
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      count of processed items to
//                                              be incremented.
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetAndPropagateRegistryPropertyRights(IN  PWSTR                 pwszRegistry,
                                      IN  PWSTR                 pwszProperty,
                                      IN  CAccessList&          RootAccList,
                                      IN  PULONG                pfStopFlag,
                                      IN  PULONG                pcProcessed)
{
    acDebugOut((DEB_TRACE, "in SetAndPropagateRegistryPropertyRights\n"));

    DWORD                   dwErr = ERROR_SUCCESS;

    //
    // First, get our security descriptor and sec info
    //
    HKEY                    hReg = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSECURITY_DESCRIPTOR    pParentSD = NULL;
    SECURITY_INFORMATION    SeInfo = 0;

    dwErr = RootAccList.BuildSDForAccessList(&pSD,
                                             &SeInfo,
                                             ACCLIST_SD_ABSOK);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Next, open the registry
        //
        dwErr = OpenRegistryObject(pwszRegistry,
                                   RegGetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                    SeInfo)             |
                                        KEY_ENUMERATE_SUB_KEYS          |
                                        KEY_QUERY_VALUE,
                                   (PHANDLE)&hReg);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Next, get our parent security descriptor
            //
            //
            // If we are only setting the owner or group, we don't need to get the parent
            //
            if (FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) ||
                FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) ) {

                dwErr = GetRegistryParentRights(pwszRegistry,
                                                SeInfo,
                                                &pParentSD);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Make the call
                //
                dwErr = SetAndPropRegRights(hReg,
                                            pwszRegistry,
                                            SeInfo,
                                            pParentSD,
                                            pSD,
                                            pfStopFlag,
                                            pcProcessed);
            }

        }

    }

    //
    // Clean up
    //
    if(hReg != NULL)
    {
        RegCloseKey(hReg);
    }

    AccFree(pParentSD);

    acDebugOut((DEB_TRACE,
               "Out SetAndPropagateRegistryPropertyRights: %ld\n", dwErr));
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropagateRegistryPropertyRightsByHandle
//
//  Synopsis:   Same as above, but assumes the registry key has already
//              been opened
//
//  Arguments:  [IN  hReg]              --      The registry key to use
//              [IN  RootAccList]       --      The CAccessList class that has
//                                              the security descriptor/info
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      count of processed items to
//                                              be incremented.
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetAndPropagateRegistryPropertyRightsByHandle(IN  HKEY          hReg,
                                              IN  CAccessList&  RootAccList,
                                              IN  PULONG        pfStopFlag,
                                              IN  PULONG        pcProcessed)
{
    acDebugOut((DEB_TRACE, "in SetAndPropagateRegistryPropertyRightsByHandle\n"));

    DWORD                   dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pParentSD = NULL;
    HANDLE                  hObject = NULL;
    BOOL                    fUplevelAcl = TRUE;
    PWSTR                   pwszRegPath = NULL;

    //
    // First, get our security descriptor and sec info
    //
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_INFORMATION    SeInfo = 0;

    dwErr = RootAccList.BuildSDForAccessList(&pSD,
                                             &SeInfo,
                                             ACCLIST_SD_ABSOK);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // If we are only setting the owner or group, we don't need to get the parent
        //
        if (FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) ||
            FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) ) {

            dwErr = ConvertRegHandleToName(hReg,
                                           &pwszRegPath);
            if((dwErr != ERROR_SUCCESS) || (pwszRegPath == NULL))
            {
                if(dwErr == ERROR_INVALID_HANDLE)
                {
                    dwErr = ERROR_SUCCESS;
                }
            }
            else
            {
                dwErr = GetRegistryParentRights(pwszRegPath,
                                                SeInfo,
                                                &pParentSD);
            }
        }


        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Make the call
            //
            dwErr = SetAndPropRegRights(hReg,
                                        NULL,
                                        SeInfo,
                                        pParentSD,
                                        pSD,
                                        pfStopFlag,
                                        pcProcessed);

            if(dwErr == ERROR_ACCESS_DENIED)
            {
                //
                // See if we can reopen the path adding in readcontrol, and try it all again
                //
                if(pwszRegPath == NULL)
                {
                    dwErr = ConvertRegHandleToName(hReg,
                                                   &pwszRegPath);
                }

                if(pwszRegPath != NULL)
                {
                    dwErr = SetAndPropagateRegistryPropertyRights(pwszRegPath,
                                                                  NULL,
                                                                  RootAccList,
                                                                  pfStopFlag,
                                                                  pcProcessed);
                }

            }
        }
    }

    //
    // Clean up
    //
    AccFree(pwszRegPath);
    AccFree(pParentSD);

    acDebugOut((DEB_TRACE,
               "Out SetAndPropagateRegistryPropertyRightsByHandle: %ld\n", dwErr));
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   PropagateRegRightsDeep, recursive
//
//  Synopsis:   Does a deep propagation of the access.  At the same time, it
//              will update NT4 acls to NT5 acls.  This function is only
//              called on downlevel registries, so the update will always
//              happen (where appropriate).  The algorithm is:
//                  - Read the current security descriptor from the object
//                  - If it's a downlevel acl, update it using the OLD
//                    parent security descriptor (to set any inheritied aces)
//                  - Update the security descriptor using the NEW parent
//                    security descriptor.
//                  - Repeat for its children.  (This is necessar, since there
//                    could have been unmarked inheritance off of the old
//                    security descriptor)
//
//  Arguments:  [IN  pOldParentSD]      --      The previous parent SD (before
//                                              the current parent SD was
//                                              stamped on the object)
//              [IN  pParentSD]         --      The current parent sd
//              [IN  SeInfo]            --      What is being written
//              [IN  hParent]           --      Opened parent registry key
//              [IN  pcProcessed]       --      Where the number processed is
//                                              returned.
//              [IN  pfStopFlag]        --      Stop flag to monitor
//              [IN  fProtectedFlag]    --      Determines whether the acls are already
//                                              protected
//              [IN  hProcessToken]     --      Handle to the process token
//              [IN  LogList]           --      List of keys to which propagation failed
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
PropagateRegRightsDeep(IN  PSECURITY_DESCRIPTOR    pOldParentSD,
                       IN  PSECURITY_DESCRIPTOR    pParentSD,
                       IN  SECURITY_INFORMATION    SeInfo,
                       IN  HKEY                    hParent,
                       IN  PULONG                  pcProcessed,
                       IN  PULONG                  pfStopFlag,
                       IN  ULONG                   fProtectedFlag,
                       IN  HANDLE                  hProcessToken,
                       IN OUT CSList&              LogList)
{
    acDebugOut((DEB_TRACE, "in  PropagteRegRightsDeep\n"));

    DWORD                   dwErr = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR    *pChildSD = NULL;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    BOOL                    fUpdateChild = FALSE;   // Write out the child?
    BOOL                    fAccFreeChild = TRUE;   // How to free the child

    //
    // Check to see if we've reached full protection saturation
    //
    if(fProtectedFlag == (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
    {
        acDebugOut((DEB_TRACE_PROP, "Parent is fully or effectively protected\n"));
        return(ERROR_SUCCESS);
    }


    HKEY    hChild = NULL;

    ULONG    cSubKeys;
    dwErr = RegQueryInfoKey(hParent,
                            NULL,
                            NULL,
                            NULL,
                            &cSubKeys,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);

    CLEANUP_ON_INTERRUPT(pfStopFlag);


    if(dwErr == ERROR_SUCCESS && cSubKeys != 0)
    {
        WCHAR   wszBuff[MAX_PATH + 1];

        ULONG       iIndex = 0;
        ULONG       cSize;
        FILETIME    WriteTime;
        while(dwErr == ERROR_SUCCESS)
        {
            cSize = MAX_PATH + 1;
            dwErr = RegEnumKeyEx(hParent,
                                 iIndex,
                                 wszBuff,
                                 &cSize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &WriteTime);
            if(dwErr == ERROR_NO_MORE_ITEMS)
            {
                dwErr = ERROR_SUCCESS;
                break;
            }

            acDebugOut((DEB_TRACE_PROP,"Propagating to %ws\n", wszBuff));

            CLEANUP_ON_INTERRUPT(pfStopFlag);

            //
            // Now, determine if we need to propagate or not...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                ULONG                   cSDLen = 0;
                BOOL                    fWriteSD = FALSE;

                dwErr = RegOpenKeyEx(hParent,
                                     wszBuff,
                                     0,
                                     RegGetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                      SeInfo)           |
                                     KEY_ENUMERATE_SUB_KEYS             |
                                     KEY_QUERY_VALUE,
                                     &hChild);

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Get our number of children
                    //
                    dwErr = RegQueryInfoKey(hChild,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &cSubKeys,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);

                    if ( dwErr == ERROR_INSUFFICIENT_BUFFER ) {

                        acDebugOut((DEB_ERROR,"RegQueryInfoKey failure on %ws\n", wszBuff));
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        CLEANUP_ON_INTERRUPT(pfStopFlag);

                        //
                        // Read the current security descriptor
                        //
                        dwErr = ReadRegistrySecurityInfo(hChild,
                                                         SeInfo,
                                                         (PSECURITY_DESCRIPTOR *)&pChildSD);

                        CLEANUP_ON_INTERRUPT(pfStopFlag);

                        if(dwErr == ERROR_SUCCESS &&
                           !(FLAG_ON(pChildSD->Control,
                                     SE_DACL_AUTO_INHERITED |
                                     SE_SACL_AUTO_INHERITED)))
                        {
                            //
                            // Before we convert this, we may need to reread the SD... if
                            // we don't have owner and group
                            //
                            if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
                               !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                            {
                                AccFree(pChildSD);
                                pChildSD = NULL;
                                dwErr = ReadRegistrySecurityInfo(
                                                    hChild,
                                                    SeInfo                          |
                                                        OWNER_SECURITY_INFORMATION  |
                                                        GROUP_SECURITY_INFORMATION,
                                                    (PSECURITY_DESCRIPTOR *)&pChildSD);
                                if(dwErr == ERROR_ACCESS_DENIED)
                                {
                                    RegCloseKey(hChild);
                                    dwErr = RegOpenKeyEx(hParent,
                                                         wszBuff,
                                                         0,
                                                         RegGetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                              SeInfo    |
                                                              OWNER_SECURITY_INFORMATION |
                                                              GROUP_SECURITY_INFORMATION)   |
                                                         KEY_ENUMERATE_SUB_KEYS             |
                                                         KEY_QUERY_VALUE,
                                                         &hChild);
                                    if(dwErr == ERROR_SUCCESS)
                                    {
                                        dwErr = ReadRegistrySecurityInfo(
                                                            hChild,
                                                            SeInfo                          |
                                                                OWNER_SECURITY_INFORMATION  |
                                                                GROUP_SECURITY_INFORMATION,
                                                            (PSECURITY_DESCRIPTOR *)&pChildSD);
                                    }
                                }
                            }

                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = ConvertToAutoInheritSD(pOldParentSD,
                                                               pChildSD,
                                                               TRUE,
                                                               &gRegGenMapping,
                                                               &pNewSD);
                                AccFree(pChildSD);

                                if(dwErr == ERROR_SUCCESS)
                                {
                                    pChildSD = (SECURITY_DESCRIPTOR *)pNewSD;
                                    fAccFreeChild = FALSE;
                                    pNewSD = NULL;
                                }
                            }
                        }


                        //
                        // Now, compute the new security descriptor
                        if(dwErr == ERROR_SUCCESS)
                        {
                            DebugDumpSD("CPOS ParentSD", pParentSD);
                            DebugDumpSD("CPOS CreatorSD",  pChildSD);

                            if(CreatePrivateObjectSecurityEx(pParentSD,
                                                             pChildSD,
                                                             &pNewSD,
                                                             NULL,
                                                             TRUE,
                                                             SEF_DACL_AUTO_INHERIT      |
                                                                 SEF_SACL_AUTO_INHERIT  |
                                                                 SEF_AVOID_OWNER_CHECK  |
                                                                 SEF_AVOID_PRIVILEGE_CHECK,
                                                             hProcessToken,
                                                             &gRegGenMapping) == FALSE)
                            {
                                dwErr = GetLastError();
                            }
                        }
#ifdef DBG
                        else
                        {
                            DebugDumpSD("CPOS NewChild", pNewSD);
                        }
#endif

                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // If the resultant child is protected, don't bother propagating
                            // down.
                            //
                            if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                            {
                                if(DACL_PROTECTED(pNewSD))
                                {
                                    fProtectedFlag |= SE_DACL_PROTECTED;
                                }
                            }

                            if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                            {
                                if(SACL_PROTECTED(pNewSD))
                                {
                                    fProtectedFlag |= SE_SACL_PROTECTED;
                                }
                            }

                            if(FLAG_ON( fProtectedFlag, (SE_DACL_PROTECTED | SE_SACL_PROTECTED)))
                            {
                                cSubKeys = 0;
                                dwErr = InsertPropagationFailureEntry(LogList,
                                                                      0,
                                                                      fProtectedFlag,
                                                                      wszBuff);
                            }

                            //
                            // If we haven't changed the acl, security descriptor, then
                            // we can also quit
                            //
                            if(EqualSecurityDescriptors(pNewSD, pChildSD))
                            {
                                cSubKeys = 0;
                            }
                        }


                    }

                    //
                    // Now, if it's a directory, call ourselves
                    //
                    if(dwErr == ERROR_SUCCESS && cSubKeys != 0)
                    {
                        dwErr = PropagateRegRightsDeep(pChildSD,
                                                       pNewSD,
                                                       SeInfo,
                                                       hChild,
                                                       pcProcessed,
                                                       pfStopFlag,
                                                       fProtectedFlag,
                                                       hProcessToken,
                                                       LogList);

                        if(dwErr == ERROR_ACCESS_DENIED)
                        {
                            dwErr = InsertPropagationFailureEntry(LogList,
                                                                  dwErr,
                                                                  0,
                                                                  wszBuff);
                        }
                    }

                    //
                    // Free the old child, since we won't need it anymore
                    //
                    if(fAccFreeChild == TRUE)
                    {
                        AccFree(pChildSD);
                    }
                    else
                    {
                        DestroyPrivateObjectSecurity((PSECURITY_DESCRIPTOR *)
                                                                   &pChildSD);
                    }
                    pChildSD = NULL;

                }
            }

            acDebugOut((DEB_TRACE_PROP,
                        "Processed %ws: %lu\n",
                        wszBuff,
                        dwErr));

            //
            // Finally, set the new security
            //
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Now, we'll simply stamp it on the object
                //

                dwErr = SetRegistrySecurityInfo(hChild,
                                                SeInfo,
                                                NULL,
                                                pNewSD);
                (*pcProcessed)++;

            }


            DestroyPrivateObjectSecurity(&pNewSD);
            pNewSD = NULL;

            CLEANUP_ON_INTERRUPT(pfStopFlag);
            iIndex++;
        }
    }

    if(dwErr == ERROR_NO_MORE_FILES)
    {
        dwErr = ERROR_SUCCESS;
    }

RegCleanup:
    if(hChild != NULL)
    {
        RegCloseKey(hChild);
    }

    if(pNewSD != NULL)
    {
        DestroyPrivateObjectSecurity(&pNewSD);
    }

    acDebugOut((DEB_TRACE,
               "Out PropagteRegRightsDeep: %ld\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropRegRights
//
//  Synopsis:   Sets the access on the given registry path and propagates
//              it as necessary
//
//  Arguments:  [IN  hReg]              --      Handle to the reg. object to set
//              [IN  pwszPath]          --      Registry path referred to by hReg,
//                                              if known
//              [IN  SeInfo]            --      Security information to set
//              [IN  pParentSD]         --      Security descriptor of the parent
//              [IN  pSD]               --      SD to set
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      count of processed items to
//                                              be incremented.
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
SetAndPropRegRights(IN  HKEY                    hReg,
                    IN  PWSTR                   pwszPath,
                    IN  SECURITY_INFORMATION    SeInfo,
                    IN  PSECURITY_DESCRIPTOR    pParentSD,
                    IN  PSECURITY_DESCRIPTOR    pSD,
                    IN  PULONG                  pfStopFlag,
                    IN  PULONG                  pcProcessed)
{
    acDebugOut((DEB_TRACE, "in SetAndPropRegRights\n"));

    DWORD                   dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pOldObjSD = NULL;
    PSECURITY_DESCRIPTOR    pUpdatedSD = NULL;
    PSECURITY_DESCRIPTOR    pVerifySD = NULL;
    BOOL                    fManualProp = FALSE;
    ULONG                   fProtected = 0;
    ULONG                   cSubKeys;
    HANDLE                  hProcessToken = NULL;
    PSID                    pOwner = NULL, pGroup = NULL;

    CSList                  FailureLogList(FreePropagationFailureListEntry);



    //
    // Ok, read the existing security
    //
    dwErr = ReadRegistrySecurityInfo(hReg,
                                     SeInfo,
                                     &pOldObjSD);

    //
    // Now, we'll write out the current, and then read it back and make sure
    // that it's properly updated
    //
    if(dwErr == ERROR_SUCCESS &&
        FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION) )
    {
        CLEANUP_ON_INTERRUPT(pfStopFlag);
        dwErr = SetRegistrySecurityInfo(hReg,
                                        SeInfo,
                                        NULL,
                                        pSD);
        if(dwErr == ERROR_SUCCESS)
        {
            (*pcProcessed)++;
            CLEANUP_ON_INTERRUPT(pfStopFlag);

            dwErr = ReadRegistrySecurityInfo(hReg,
                                             SeInfo,
                                             &pVerifySD);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check to see if this was done uplevel...
                //
                PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pVerifySD;
                if(!(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) &&
                    FLAG_ON(pISD->Control, SE_DACL_AUTO_INHERITED)) &&
                   !(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) &&
                    FLAG_ON(pISD->Control, SE_SACL_AUTO_INHERITED)))
                {
                    //
                    // It's not uplevel, so we'll turn the AutoInherit
                    // flags on, rewrite it, and do our own propagation,
                    // only if this is a container and we're setting the
                    // dacl or sacl
                    //
                    if(FLAG_ON(SeInfo,
                               (DACL_SECURITY_INFORMATION |
                                            SACL_SECURITY_INFORMATION)))
                    {
                        fManualProp = TRUE;
                    }

                    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                    {
                        pISD->Control |= SE_DACL_AUTO_INHERITED;
                    }

                    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                    {
                        pISD->Control |= SE_SACL_AUTO_INHERITED;
                    }

                    //
                    // Go ahead and upgrade it to autoinherit
                    //
                    if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
                       !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                    {
                        //
                        // Need to reread it to get the owner and group
                        //
                        AccFree(pVerifySD);
                        dwErr = ReadRegistrySecurityInfo(hReg,
                                                         SeInfo |
                                                            OWNER_SECURITY_INFORMATION |
                                                            GROUP_SECURITY_INFORMATION,
                                                         &pVerifySD);
                        //
                        // If we failed to read it because we didn't originally have permissions
                        // and we have the path, we'll try to reopen the handle with the
                        // proper rights
                        //
                        if(dwErr == ERROR_ACCESS_DENIED && pwszPath != NULL)
                        {
                            HKEY    hReg2;

                            dwErr = OpenRegistryObject(pwszPath,
                                                       RegGetDesiredAccess(READ_ACCESS_RIGHTS,
                                                            SeInfo |
                                                                OWNER_SECURITY_INFORMATION |
                                                                GROUP_SECURITY_INFORMATION),
                                                       (PHANDLE)&hReg2);

                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = ReadRegistrySecurityInfo(hReg2,
                                                         SeInfo |
                                                            OWNER_SECURITY_INFORMATION |
                                                            GROUP_SECURITY_INFORMATION,
                                                         &pVerifySD);
                                RegCloseKey(hReg2);
                            }

                        }


                        //
                        // Set our owner/group in the old security descriptor
                        //
                        if(dwErr == ERROR_SUCCESS)
                        {
                            BOOL    fDefaulted;

                            if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                            {
                                if(!GetSecurityDescriptorOwner(pVerifySD, &pOwner, &fDefaulted))
                                {
                                    dwErr = GetLastError();
                                }
                            }

                            if(!FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                            {
                                if(!GetSecurityDescriptorGroup(pVerifySD, &pGroup, &fDefaulted))
                                {
                                    dwErr = GetLastError();
                                }
                            }

                            if(dwErr == ERROR_SUCCESS)
                            {
                                //
                                // If it's self relative, we'll have to make it absolute.
                                //
                                if(FLAG_ON(((SECURITY_DESCRIPTOR *)pSD)->Control,
                                            SE_SELF_RELATIVE))
                                {
                                    PSECURITY_DESCRIPTOR pSD2;
                                    dwErr = MakeSDAbsolute(pSD,
                                                           SeInfo,
                                                           &pSD2,
                                                           pOwner,
                                                           pGroup);
                                    if(dwErr == ERROR_SUCCESS)
                                    {
                                        AccFree(pSD);
                                        pSD = pSD2;
                                    }
                                }
                                else
                                {
                                    if(pOwner != NULL)
                                    {
                                        if(SetSecurityDescriptorOwner(pOldObjSD,
                                                                      pOwner,
                                                                      FALSE) == FALSE)
                                        {
                                            dwErr = GetLastError();
                                        }
                                    }

                                    if(pGroup != NULL)
                                    {
                                        if(SetSecurityDescriptorGroup(pOldObjSD,
                                                                      pGroup,
                                                                      FALSE) == FALSE)
                                        {
                                            dwErr = GetLastError();
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = GetCurrentToken( &hProcessToken );
                    }


                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = ConvertToAutoInheritSD(pParentSD,
                                                       pOldObjSD,
                                                       TRUE,
                                                       &gRegGenMapping,
                                                       &pUpdatedSD);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // Now, if we're going to do manual propagation,
                            // we'll write out the old SD until we get everyone
                            // else updated
                            //
                            PSECURITY_DESCRIPTOR    pWriteSD = pUpdatedSD;
                            if(fManualProp == TRUE)
                            {
                                pWriteSD = pOldObjSD;
                            }
                            else
                            {
                                if(SetPrivateObjectSecurity(SeInfo,
                                                            pParentSD,
                                                            &pUpdatedSD,
                                                            &gRegGenMapping,
                                                            hProcessToken) == FALSE)
                                {
                                    dwErr = GetLastError();
                                }
                            }

                            //
                            // Reset it...
                            //
                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = SetRegistrySecurityInfo(hReg,
                                                                SeInfo,
                                                                NULL,
                                                                pWriteSD);
                            }
                        }
                    }
                    else
                    {
                        pVerifySD = NULL;
                    }



                }

            }

        }
    }
    else
    {
        if(dwErr == ERROR_SUCCESS &&
           FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
        {

            dwErr = SetRegistrySecurityInfo(hReg,
                                            SeInfo,
                                            NULL,
                                            pSD);
        }
    }

    //
    // Ok, now if we're doing propagation, we'll get busy and do that...
    //
    if(dwErr == ERROR_SUCCESS && fManualProp == TRUE)
    {
        //
        // Set our protected flags.  If we aren't messing with a particular acl, we'll
        // pretend it's protected
        //

        fProtected = ((SECURITY_DESCRIPTOR *)pUpdatedSD)->Control &
                                                ~(SE_DACL_PROTECTED | SE_SACL_PROTECTED);
        if(FLAG_ON(fProtected, SE_DACL_PROTECTED ) || FLAG_ON(fProtected, SE_SACL_PROTECTED ))
        {
            dwErr = InsertPropagationFailureEntry(FailureLogList,
                                                  0,
                                                  fProtected,
                                                  pwszPath == NULL ?
                                                        L"<Unkown Registry Root>" :
                                                        pwszPath);
        }

        if(!FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
        {
            fProtected |= SE_DACL_PROTECTED;
        }

        if(!FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
        {
            fProtected |= SE_SACL_PROTECTED;
        }

        //
        // Ok, go ahead and do deep.  This will possibly save us
        // some storage space in the long run...
        //
        dwErr = PropagateRegRightsDeep(pOldObjSD,
                                       pUpdatedSD,
                                       SeInfo,
                                       hReg,
                                       pcProcessed,
                                       pfStopFlag,
                                       fProtected,
                                       hProcessToken,
                                       FailureLogList);
        if(dwErr == ERROR_ACCESS_DENIED)
        {
            dwErr = InsertPropagationFailureEntry(FailureLogList,
                                                  dwErr,
                                                  0,
                                                  pwszPath == NULL ?
                                                        L"<Unkown Registry Root>" :
                                                        pwszPath);
        }


        //
        // If that worked, write out our updated root security descriptor
        //
        if(dwErr == ERROR_SUCCESS)
        {
            PSECURITY_DESCRIPTOR    pSet;

            if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
            {
                if(!SetSecurityDescriptorOwner(pSD, pOwner, FALSE))
                {
                    dwErr = GetLastError();
                }
            }

            if(!FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
            {
                if(!SetSecurityDescriptorGroup(pSD, pGroup, FALSE))
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                if(CreatePrivateObjectSecurityEx(pParentSD,
                                                 pSD,
                                                 &pSet,
                                                 NULL,
                                                 TRUE,
                                                 SEF_DACL_AUTO_INHERIT      |
                                                     SEF_SACL_AUTO_INHERIT  |
                                                     SEF_AVOID_OWNER_CHECK  |
                                                     SEF_AVOID_PRIVILEGE_CHECK,
                                                 hProcessToken,
                                                 &gRegGenMapping) == FALSE)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    dwErr = SetRegistrySecurityInfo(hReg,
                                                    SeInfo,
                                                    NULL,
                                                    pSet);
                    DestroyPrivateObjectSecurity(&pSet);
                }
            }
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = WritePropagationFailureList(MARTAEVT_REGISTRY_PROPAGATION_FAILED,
                                            FailureLogList,
                                            hProcessToken);
    }

RegCleanup:
    AccFree(pOldObjSD);
    AccFree(pVerifySD);

    if(pUpdatedSD != NULL)
    {
        DestroyPrivateObjectSecurity(&pUpdatedSD);
    }

    acDebugOut((DEB_TRACE, "Out SetAndPropRegRights: %ld\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertRegHandleToName
//
//  Synopsis:   Determines the registry path for a handle.  Issues an
//              NtQueryInformationFile to determine the path name
//
//  Arguments:  [IN  hKey]              --      The (open) handle of the file
//                                              object
//              [OUT ppwszName]         --      Where the name is returned
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//  Notes:      The returned memory must be freed with AccFree
//
//----------------------------------------------------------------------------
DWORD
ConvertRegHandleToName(IN  HKEY       hKey,
                       OUT PWSTR      *ppwszName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, determine the size of the buffer we need...
    //
    BYTE        pBuff[512];
    ULONG       cLen = 0;
    POBJECT_NAME_INFORMATION pNI = NULL;
    PWSTR       pwszPath = NULL;
    NTSTATUS    Status = NtQueryObject(hKey,
                                       ObjectNameInformation,
                                       (POBJECT_NAME_INFORMATION)pBuff,
                                       512,
                                       &cLen);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL ||
            Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            //
            // Fine.. Allocate a big enough buffer
            //
            pNI = (POBJECT_NAME_INFORMATION)AccAlloc(cLen);
            if(pNI != NULL)
            {
                Status = NtQueryObject(hKey,
                                       ObjectNameInformation,
                                       pNI,
                                       cLen,
                                       NULL);
                if(NT_SUCCESS(Status))
                {
                    pwszPath = pNI->Name.Buffer;
                }
                AccFree(pNI);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = RtlNtStatusToDosError(Status);
        }

    }
    else
    {
        pwszPath = ((POBJECT_NAME_INFORMATION)pBuff)->Name.Buffer;
    }

    //
    // If we have a path, then it's a simple matter to pull out the appropriate string,
    // since what gets returned is something in the form of \\REGISTRY\\MACHINE\\somepath
    // which is pretty close to what we want
    //
    #define REG_OBJ_TAG L"\\REGISTRY\\"

    if(pwszPath != NULL)
    {
        pwszPath += (sizeof(REG_OBJ_TAG) / sizeof(WCHAR) - 1);
        ACC_ALLOC_AND_COPY_STRINGW(pwszPath,
                                   *ppwszName,
                                   dwErr);

    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\prtctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       prtctx.cpp
//
//  Contents:   Implementation of CPrinterContext and NT Marta Printer Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::CPrinterContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CPrinterContext::CPrinterContext ()
{
    m_cRefs = 1;
    m_hPrinter = NULL;
    m_fNameInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::~CPrinterContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CPrinterContext::~CPrinterContext ()
{
    if ( ( m_hPrinter != NULL ) && ( m_fNameInitialized == TRUE ) )
    {
        ClosePrinter( m_hPrinter );
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the printer
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    PRINTER_DEFAULTSW PrinterDefaults;

    PrinterDefaults.pDatatype = NULL;
    PrinterDefaults.pDevMode = NULL;
    PrinterDefaults.DesiredAccess = AccessMask;

    if ( OpenPrinterW(
             (LPWSTR)pObjectName,
             &m_hPrinter,
             &PrinterDefaults
             ) == FALSE )
    {
        return( GetLastError() );
    }

    m_fNameInitialized = TRUE;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::InitializeByHandle, public
//
//  Synopsis:   initialize the context given a printer handle
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::InitializeByHandle (HANDLE Handle)
{
    m_hPrinter = Handle;
    assert( m_fNameInitialized == FALSE );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::GetPrinterProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::GetPrinterProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::GetPrinterRights, public
//
//  Synopsis:   get the Printer security descriptor
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::GetPrinterRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    PISECURITY_DESCRIPTOR pisd = NULL;
    PSECURITY_DESCRIPTOR  psd = NULL;
    DWORD                 cb = 0;
    PPRINTER_INFO_3       pPrinterInfo = NULL;

    assert( m_hPrinter != NULL );

    if ( ( GetPrinterW(
              m_hPrinter,
              3,
              (LPBYTE)pPrinterInfo,
              cb,
              &cb
              ) == FALSE ) &&
         ( cb > 0 ) )
    {
        pPrinterInfo = (PPRINTER_INFO_3)new BYTE [ cb ];
        if ( pPrinterInfo != NULL )
        {
            if ( GetPrinterW(
                    m_hPrinter,
                    3,
                    (LPBYTE)pPrinterInfo,
                    cb,
                    &cb
                    ) == FALSE )
            {
                delete pPrinterInfo;
                return( GetLastError() );
            }
        }
        else
        {
            return( E_OUTOFMEMORY );
        }
    }
    else
    {
        return( GetLastError() );
    }

    pisd = (PISECURITY_DESCRIPTOR)pPrinterInfo->pSecurityDescriptor;
    if ( pisd->Control & SE_SELF_RELATIVE )
    {
        cb = GetSecurityDescriptorLength( pPrinterInfo->pSecurityDescriptor );
        psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
        if ( psd == NULL )
        {
            return( ERROR_OUTOFMEMORY );
        }

        memcpy( psd, pPrinterInfo->pSecurityDescriptor, cb );
    }
    else
    {
        if ( MakeSelfRelativeSD(
                 pPrinterInfo->pSecurityDescriptor,
                 NULL,
                 &cb
                 ) == FALSE )
        {
            if ( cb > 0 )
            {
                psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
                if ( psd != NULL )
                {
                    if ( MakeSelfRelativeSD(
                             pPrinterInfo->pSecurityDescriptor,
                             psd,
                             &cb
                             ) == FALSE )
                    {
                        LocalFree( psd );
                        return( GetLastError() );
                    }
                }
            }
            else
            {
                return( GetLastError() );
            }
        }
    }

    *ppSecurityDescriptor = psd;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::SetPrinterRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::SetPrinterRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    PRINTER_INFO_3 PrinterInfo;

    assert( m_hPrinter != NULL );

    PrinterInfo.pSecurityDescriptor = pSecurityDescriptor;

    if ( SetPrinterW( m_hPrinter, 3, (LPBYTE)&PrinterInfo, 0 ) == FALSE )
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//
// Functions from printer.h which dispatch unto the CPrinterContext class
//

DWORD
MartaAddRefPrinterContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CPrinterContext *)Context )->AddRef() );
}

DWORD
MartaClosePrinterContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CPrinterContext *)Context )->Release() );
}

DWORD
MartaGetPrinterProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CPrinterContext *)Context )->GetPrinterProperties( pProperties ) );
}

DWORD
MartaGetPrinterTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetPrinterRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CPrinterContext *)Context )->GetPrinterRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenPrinterNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CPrinterContext* pPrinterContext;

    pPrinterContext = new CPrinterContext;
    if ( pPrinterContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pPrinterContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pPrinterContext->Release();
        return( Result );
    }

    *pContext = pPrinterContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenPrinterHandleObject(
    IN  HANDLE   Handle,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CPrinterContext* pPrinterContext;

    pPrinterContext = new CPrinterContext;
    if ( pPrinterContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pPrinterContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pPrinterContext->Release();
        return( Result );
    }

    *pContext = pPrinterContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetPrinterRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CPrinterContext *)Context )->SetPrinterRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\regctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
//  File:       registry.cpp
//
//  Contents:   NtMarta registry functions
//
//  History:    4/99    philh       Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <kernel.h>
#include <assert.h>
#include <ntstatus.h>

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stddef.h>


#include <registry.h>
#include <wow64reg.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// Registry object names returned by NtQueryObject are prefixed by
// the following
#define REG_OBJ_TAG L"\\REGISTRY\\"
#define REG_OBJ_TAG_LEN (sizeof(REG_OBJ_TAG) / sizeof(WCHAR) - 1)

//+-------------------------------------------------------------------------
//  Registry Context data structures
//--------------------------------------------------------------------------
typedef struct _REG_FIND_DATA REG_FIND_DATA, *PREG_FIND_DATA;

typedef struct _REG_CONTEXT {
    DWORD               dwRefCnt;
    DWORD               dwFlags;

    // Only closed when REG_CONTEXT_CLOSE_HKEY_FLAG is set
    HKEY                hKey;
    LPWSTR              pwszObject;     // optional, allocated

    // Following is allocated and updated for FindFirst, FindNext
    PREG_FIND_DATA      pRegFindData;
} REG_CONTEXT, *PREG_CONTEXT;

#define REG_CONTEXT_CLOSE_HKEY_FLAG     0x1

struct _REG_FIND_DATA {
    PREG_CONTEXT        pRegParentContext;  // ref counted
    DWORD               cSubKeys;
    DWORD               cchMaxSubKey;
    DWORD               iSubKey;            // index of next FindNext

    // Following isn't allocated separately, it follows this data structure
    LPWSTR              pwszSubKey;
};

//+-------------------------------------------------------------------------
//  Registry allocation functions
//--------------------------------------------------------------------------
#define I_MartaRegZeroAlloc(size)     \
            LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, size)
#define I_MartaRegNonzeroAlloc(size)  \
            LocalAlloc(LMEM_FIXED, size)

STATIC
inline
VOID
I_MartaRegFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree(pv);
}

STATIC
DWORD
I_MartaRegDupString(
    IN LPCWSTR pwszOrig,
    OUT LPWSTR *ppwszDup
    )

/*++

Routine Description:

    Allocate memory and copy the given name into it.

Arguments:

    pwszOrig - String to be duplicated.
    
    ppwszDup - To return the duplicate.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    DWORD dwErr;
    DWORD cchOrig;
    LPWSTR pwszDup;

    cchOrig = wcslen(pwszOrig);
    if (NULL == (pwszDup = (LPWSTR) I_MartaRegNonzeroAlloc(
            (cchOrig + 1) * sizeof(WCHAR)))) {
        *ppwszDup = NULL;
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        memcpy(pwszDup, pwszOrig, (cchOrig + 1) * sizeof(WCHAR));
        *ppwszDup = pwszDup;
        dwErr = ERROR_SUCCESS;
    }

    return dwErr;
}

STATIC
DWORD
I_MartaRegGetParentString(
    IN OUT LPWSTR pwszParent
    )

/*++

Routine Description:

    Given the name for a registry key, get the name of its parent. Does not allocate
    memory. Scans till the first '\' from the right and deletes the name after
    that.

Arguments:

    pwszParent - Object name which will be converted to its parent name.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    DWORD cch;
    LPWSTR pwsz;

    if (NULL == pwszParent)
        return ERROR_INVALID_NAME;

    cch = wcslen(pwszParent);
    pwsz = pwszParent + cch;
    if (0 == cch)
        goto InvalidNameReturn;
    pwsz--;

    //
    // Remove any trailing '\'s
    //

    while (L'\\' == *pwsz) {
        if (pwsz == pwszParent)
            goto InvalidNameReturn;
        pwsz--;
    }

    //
    // Peal off the last path name component
    //

    while (L'\\' != *pwsz) {
        if (pwsz == pwszParent)
            goto InvalidNameReturn;
        pwsz--;
    }

    //
    // Remove all trailing '\'s from the parent.
    // This could also be the leading '\\'s for a computer name.
    //

    while (L'\\' == *pwsz) {
        if (pwsz == pwszParent)
            goto InvalidNameReturn;
        pwsz--;
    }
    pwsz++;
    assert(L'\\' == *pwsz);

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *pwsz = L'\0';
    return dwErr;
InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto CommonReturn;
}

STATIC
DWORD
I_MartaRegCreateChildString(
    IN LPCWSTR pwszParent,
    IN LPCWSTR pwszSubKey,
    OUT LPWSTR *ppwszChild
    )

/*++

Routine Description:

    Given the name of the parent and the name of the subkey, create the full
    name of the child.

Arguments:

    pwszParent - Name of the parent.
    
    pwszSubKey - Name of the subkey.
    
    ppwszChild - To return the name of the child.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    DWORD dwErr;
    DWORD cchParent;
    DWORD cchSubKey;
    DWORD cchChild;
    LPWSTR pwszChild = NULL;

    if (NULL == pwszParent || NULL == pwszSubKey)
        goto InvalidNameReturn;

    cchParent = wcslen(pwszParent);

    //
    // Remove any trailing '\'s from parent
    //

    while (0 < cchParent && L'\\' == pwszParent[cchParent - 1])
        cchParent--;
    if (0 == cchParent)
        goto InvalidNameReturn;

    cchSubKey = wcslen(pwszSubKey);
    if (0 == cchSubKey)
        goto InvalidNameReturn;

    cchChild = cchParent + 1 + cchSubKey;
    if (NULL == (pwszChild = (LPWSTR) I_MartaRegNonzeroAlloc(
            (cchChild + 1) * sizeof(WCHAR))))
        goto NotEnoughMemoryReturn;

    //
    // Construct the name of the child from the given strings.
    //

    memcpy(pwszChild, pwszParent, cchParent * sizeof(WCHAR));
    pwszChild[cchParent] = L'\\';
    memcpy(pwszChild + cchParent + 1, pwszSubKey, cchSubKey * sizeof(WCHAR));
    pwszChild[cchChild] = L'\0';

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *ppwszChild = pwszChild;
    return dwErr;

InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto CommonReturn;
NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto CommonReturn;
}


STATIC
DWORD
I_MartaRegParseName(
    IN OUT  LPWSTR  pwszObject,
    OUT     LPWSTR *ppwszMachine,
    OUT     LPWSTR *ppwszRemaining
    )

/*++

Routine Description:

    Parses a registry object name for the machine name.

Arguments:

    pwszObject - the name of the object

    ppwszMachine - the machine the object is on

    ppwszRemaining - the remaining name after the machine name

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    if (pwszObject == wcsstr(pwszObject, L"\\\\")) {
        *ppwszMachine = pwszObject + 2;
        *ppwszRemaining =  wcschr(*ppwszMachine, L'\\');
        if (*ppwszRemaining != NULL) {
            **ppwszRemaining = L'\0';
            *ppwszRemaining += 1;
        }
    } else {
        *ppwszMachine = NULL;
        *ppwszRemaining = pwszObject;
    }

    return ERROR_SUCCESS;
}


STATIC
DWORD
I_MartaRegInitContext(
    OUT PREG_CONTEXT *ppRegContext
    )

/*++

Routine Description:

    Allocate and initialize memory for the context.

Arguments:

    ppRegContext - To return the pointer to the allcoated memory.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    PREG_CONTEXT pRegContext;

    if (pRegContext = (PREG_CONTEXT) I_MartaRegZeroAlloc(
            sizeof(REG_CONTEXT))) {
        pRegContext->dwRefCnt = 1;
        dwErr = ERROR_SUCCESS;
    } else {
        pRegContext = NULL;
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppRegContext = pRegContext;
    return dwErr;
}

DWORD
MartaOpenRegistryKeyNamedObject(
    IN  LPCWSTR              pwszObject,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    )

/*++

Routine Description:

    Open the given registry key with desired access mask and return a context
    handle.

Arguments:

    pwszObject - Name of the registry key which will be opened.
    
    AccessMask - Desired access mask with which the registry key will be opened.
    
    pContext - To return a context handle.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PREG_CONTEXT pRegContext = NULL;
    LPWSTR pwszDupObject = NULL;
    HKEY hKeyRemote = NULL;
    HKEY hKeyBase;              // not opened, don't close at return

    //
    // Following aren't allocated
    //

    LPWSTR pwszMachine, pwszRemaining, pwszBaseKey, pwszSubKey;

    if (NULL == pwszObject)
        goto InvalidNameReturn;

    if (ERROR_SUCCESS != (dwErr = I_MartaRegInitContext(&pRegContext)))
        goto ErrorReturn;

    //
    // Allocate and copy the name into the context
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaRegDupString(pwszObject,
            &pRegContext->pwszObject)))
        goto ErrorReturn;

    //
    // Save another copy of the name since we must crack it.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaRegDupString(pwszObject,
            &pwszDupObject)))
        goto ErrorReturn;

    //
    // Get the optional machine name and the remaining name
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaRegParseName(pwszDupObject,
            &pwszMachine, &pwszRemaining)))
        goto ErrorReturn;
    if (NULL == pwszRemaining)
        goto InvalidNameReturn;

    //
    // Get the base key name and the subkey name
    //

    pwszBaseKey = pwszRemaining;
    pwszSubKey = wcschr(pwszRemaining, L'\\');
    if (NULL != pwszSubKey) {
        *pwszSubKey = L'\0';

        pwszSubKey++;

        //
        // Advance past any more '\'s separating the BaseKey from the SubKey
        //

        while (L'\\' == *pwszSubKey)
            pwszSubKey++;
    }

    if (0 == _wcsicmp(pwszBaseKey, L"MACHINE")) {
        hKeyBase = HKEY_LOCAL_MACHINE;
    } else if (0 == _wcsicmp(pwszBaseKey, L"USERS") ||
               0 == _wcsicmp(pwszBaseKey, L"USER")) {
        hKeyBase = HKEY_USERS;
    } else if (NULL == pwszMachine) {

        //
        // these are only valid on the local machine
        //

        if (0 == _wcsicmp(pwszBaseKey, L"CLASSES_ROOT")) {
            hKeyBase = HKEY_CLASSES_ROOT;
        } else if (0 == _wcsicmp(pwszBaseKey, L"CURRENT_USER")) {
            hKeyBase = HKEY_CURRENT_USER;
        } else if (0 == _wcsicmp(pwszBaseKey, L"CONFIG")) {
            hKeyBase = HKEY_CURRENT_CONFIG;
        } else {
            goto InvalidParameterReturn;
        }
    } else {
        goto InvalidParameterReturn;
    }

    //
    // If it is a remote name, connect to that registry
    //

    if (pwszMachine) {
        if (ERROR_SUCCESS != (dwErr = RegConnectRegistryW(
                pwszMachine,
                hKeyBase,
                &hKeyRemote
                )))
            goto ErrorReturn;
        hKeyBase = hKeyRemote;
    }

    if (NULL == pwszMachine && (NULL == pwszSubKey || L'\0' == *pwszSubKey))

        //
        // Opening a predefined handle causes the previously opened handle
        // to be closed. Therefore, we won't reopen here.
        //

        pRegContext->hKey = hKeyBase;
    else {
        if (ERROR_SUCCESS != (dwErr = RegOpenKeyExW(
                hKeyBase,
                pwszSubKey,
                0,              // dwReversed
                AccessMask,
                &pRegContext->hKey)))
            goto ErrorReturn;
        pRegContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;
    }

    dwErr = ERROR_SUCCESS;
CommonReturn:
    I_MartaRegFree(pwszDupObject);
    if (hKeyRemote)
        RegCloseKey(hKeyRemote);
    *pContext = (MARTA_CONTEXT) pRegContext;
    return dwErr;

ErrorReturn:
    if (pRegContext) {
        MartaCloseRegistryKeyContext((MARTA_CONTEXT) pRegContext);
        pRegContext = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto ErrorReturn;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}

void
I_MartaRegFreeFindData(
    IN PREG_FIND_DATA pRegFindData
    )

/*++

Routine Description:

    Free up the memory associated with the internal structure.

Arguments:

    pRegFindData - Internal structure to be freed.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    if (NULL == pRegFindData)
        return;
    if (pRegFindData->pRegParentContext)
        MartaCloseRegistryKeyContext(pRegFindData->pRegParentContext);

    I_MartaRegFree(pRegFindData);
}

DWORD
MartaCloseRegistryKeyContext(
    IN MARTA_CONTEXT Context
    )

/*++

Routine Description:

    Close the context.

Arguments:

    Context - Context to be closed.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        return ERROR_INVALID_PARAMETER;

    //
    // If the ref cnt goes to zero then free the handle as well as all other
    // associated structures.
    //

    if (0 == --pRegContext->dwRefCnt) {
        if (pRegContext->pRegFindData)
            I_MartaRegFreeFindData(pRegContext->pRegFindData);

        if (pRegContext->dwFlags & REG_CONTEXT_CLOSE_HKEY_FLAG)
            RegCloseKey(pRegContext->hKey);
        I_MartaRegFree(pRegContext->pwszObject);

        I_MartaRegFree(pRegContext);
    }

    return ERROR_SUCCESS;
}

DWORD
MartaAddRefRegistryKeyContext(
    IN MARTA_CONTEXT Context
    )

/*++

Routine Description:

    Bump up the ref count for this context.

Arguments:

    Context - Context whose ref count should be bumped up.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        return ERROR_INVALID_PARAMETER;

    pRegContext->dwRefCnt++;

    return ERROR_SUCCESS;
}


STATIC
inline
BOOL
I_MartaRegIsPredefinedKey(
    IN HKEY hKey
    )

/*++

Routine Description:

    Find if the given key is a predefined key.

Arguments:

    key - Handle to the key.
    
Return Value:

   TRUE - if the key is a predefined key.
   FALSE - Otherwise.

--*/

{
    if (HKEY_CURRENT_USER == hKey ||
            HKEY_LOCAL_MACHINE == hKey ||
            HKEY_USERS == hKey ||
            HKEY_CLASSES_ROOT == hKey ||
            HKEY_CURRENT_CONFIG == hKey)
        return TRUE;
    else
        return FALSE;
}


DWORD
MartaOpenRegistryKeyHandleObject(
    IN  HANDLE               Handle,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    )

/*++

Routine Description:

    Given a registry key handle, open the context with the desired access mask and 
    return a context handle.

Arguments:

    Handle - Existing registry key handle.
    
    AccessMask - Desired access mask for open.
    
    pContext - To return a handle to the context.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/


{
    DWORD dwErr;
    HKEY hKey = (HKEY) Handle;
    PREG_CONTEXT pRegContext = NULL;

    if (ERROR_SUCCESS != (dwErr = I_MartaRegInitContext(&pRegContext)))
        goto ErrorReturn;
    if (0 == AccessMask || I_MartaRegIsPredefinedKey(hKey))
        pRegContext->hKey = hKey;
    else {
        if (ERROR_SUCCESS != (dwErr = RegOpenKeyExW(
                hKey,
                NULL,           // pwszSubKey
                0,              // dwReversed
                AccessMask,
                &pRegContext->hKey)))
            goto ErrorReturn;
        pRegContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;
    }

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *pContext = (MARTA_CONTEXT) pRegContext;
    return dwErr;

ErrorReturn:
    if (pRegContext) {
        MartaCloseRegistryKeyContext((MARTA_CONTEXT) pRegContext);
        pRegContext = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;
}


DWORD
MartaGetRegistryKeyParentContext(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pParentContext
    )

/*++

Routine Description:

    Given the context for a registry key, get the context for its parent.

Arguments:

    Context - Context for the registry key.
    
    AccessMask - Desired access mask with which the parent will be opened.
    
    pParentContext - To return the context for the parent.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/



{
    DWORD dwErr;
    LPWSTR pwszParentObject = NULL;

    if (ERROR_SUCCESS != (dwErr = MartaConvertRegistryKeyContextToName(
            Context, &pwszParentObject)))
        goto ErrorReturn;
    if (ERROR_SUCCESS != (dwErr = I_MartaRegGetParentString(
            pwszParentObject)))
        goto NoParentReturn;

    MartaOpenRegistryKeyNamedObject(
        pwszParentObject,
        AccessMask,
        pParentContext
        );

    //
    // Ignore any open errors
    //

    dwErr = ERROR_SUCCESS;

CommonReturn:
    I_MartaRegFree(pwszParentObject);
    return dwErr;

NoParentReturn:
    dwErr = ERROR_SUCCESS;
ErrorReturn:
    *pParentContext = NULL;
    goto CommonReturn;
}


DWORD
MartaFindFirstRegistryKey(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pChildContext
    )

/*++

Routine Description:

    FInd the first registry key in the given container.

Arguments:

    Context - Context for the container.
    
    AccessMask - Desired access mask for opening the child registry key.

    pChildContext - To return the context for the first child in the given container.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:
    Does not free up the current context. 

--*/

{
    DWORD dwErr;
    PREG_CONTEXT pRegParentContext = (PREG_CONTEXT) Context;
    HKEY hKeyParent = pRegParentContext->hKey;

    PREG_CONTEXT pRegFirstContext = NULL;
    PREG_FIND_DATA pRegFindData;    // freed as part of pRegFirstContext
    DWORD cSubKeys;
    DWORD cchMaxSubKey;

    if (ERROR_SUCCESS != (dwErr = I_MartaRegInitContext(&pRegFirstContext)))
        goto ErrorReturn;

    if (ERROR_SUCCESS != (dwErr = RegQueryInfoKeyW(
            hKeyParent,
            NULL,       // lpszClass
            NULL,       // lpcchClass
            NULL,       // lpdwReserved
            &cSubKeys,
            &cchMaxSubKey,
            NULL,       // lpcchMaxClass
            NULL,       // lpcValues
            NULL,       // lpcchMaxValuesName
            NULL,       // lpcbMaxValueData
            NULL,       // lpcbSecurityDescriptor
            NULL        // lpftLastWriteTime
            )))
        goto ErrorReturn;

    //
    // Above returned count doesn't include the terminating null character
    //

    cchMaxSubKey++;

    //
    // Note: HKEY_CURRENT_CONFIG returns a cchMaxSubKey of 0 ????
    //

    if (MAX_PATH > cchMaxSubKey)
        cchMaxSubKey = MAX_PATH;

    if (NULL == (pRegFindData = (PREG_FIND_DATA) I_MartaRegZeroAlloc(
            sizeof(REG_FIND_DATA) + cchMaxSubKey * sizeof(WCHAR))))
        goto NotEnoughMemoryReturn;

    pRegFirstContext->pRegFindData = pRegFindData;
    MartaAddRefRegistryKeyContext((MARTA_CONTEXT) pRegParentContext);
    pRegFindData->pRegParentContext = pRegParentContext;
    pRegFindData->cSubKeys = cSubKeys;
    pRegFindData->cchMaxSubKey = cchMaxSubKey;
    pRegFindData->pwszSubKey =
        (LPWSTR) (((BYTE *) pRegFindData) + sizeof(REG_FIND_DATA));

    //
    // Following closes / frees pRegFirstContext
    //

    dwErr = MartaFindNextRegistryKey(
        (MARTA_CONTEXT) pRegFirstContext,
        AccessMask,
        pChildContext
        );
CommonReturn:
    return dwErr;
ErrorReturn:
    if (pRegFirstContext)
        MartaCloseRegistryKeyContext((MARTA_CONTEXT) pRegFirstContext);
    *pChildContext = NULL;

    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;
}

DWORD
MartaFindNextRegistryKey(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pSiblingContext
    )

/*++

Routine Description:

    Get the next object in the tree. This is the sibling for the current context.

Arguments:

    Context - Context for the current object.

    AccessMask - Desired access mask for the opening the sibling.
    
    pSiblingContext - To return a handle for the sibling.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:

    Closes the current context.
    
--*/

{
    DWORD dwErr;

    PREG_CONTEXT pRegPrevContext = (PREG_CONTEXT) Context;
    PREG_CONTEXT pRegSiblingContext = NULL;

    //
    // Following don't need to be freed or closed
    //

    PREG_CONTEXT pRegParentContext;
    PREG_FIND_DATA pRegFindData;
    HKEY hKeyParent;
    DWORD cchMaxSubKey;
    LPWSTR pwszSubKey;

    if (ERROR_SUCCESS != (dwErr = I_MartaRegInitContext(&pRegSiblingContext)))
        goto ErrorReturn;

    //
    // Move the FindData on to the sibling context
    //

    pRegFindData = pRegPrevContext->pRegFindData;
    if (NULL == pRegFindData)
        goto InvalidParameterReturn;
    pRegPrevContext->pRegFindData = NULL;
    pRegSiblingContext->pRegFindData = pRegFindData;

    if (pRegFindData->iSubKey >= pRegFindData->cSubKeys)
        goto NoMoreItemsReturn;

    pRegParentContext = pRegFindData->pRegParentContext;
    hKeyParent = pRegParentContext->hKey;
    pwszSubKey = pRegFindData->pwszSubKey;
    cchMaxSubKey = pRegFindData->cchMaxSubKey;
    if (ERROR_SUCCESS != (dwErr = RegEnumKeyExW(
            hKeyParent,
            pRegFindData->iSubKey,
            pwszSubKey,
            &cchMaxSubKey,
            NULL,               // lpdwReserved
            NULL,               // lpszClass
            NULL,               // lpcchClass
            NULL                // lpftLastWriteTime
            )))
        goto ErrorReturn;
    pRegFindData->iSubKey++;

    if (pRegParentContext->pwszObject)

        //
        // Ignore errors. Mainly here for testing purposes.
        //

        I_MartaRegCreateChildString(
            pRegParentContext->pwszObject,
            pwszSubKey,
            &pRegSiblingContext->pwszObject
            );

    if (ERROR_SUCCESS == (dwErr = RegOpenKeyExW(
            hKeyParent,
            pwszSubKey,
            0,              // dwReversed
            AccessMask,
            &pRegSiblingContext->hKey)))
        pRegSiblingContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;

    // 
    //  For an error still return this context. This allows the caller
    //  to continue on to the next sibling object and know there was an
    //  error with this sibling object
    //

CommonReturn:
    MartaCloseRegistryKeyContext(Context);
    *pSiblingContext = (MARTA_CONTEXT) pRegSiblingContext;
    return dwErr;

ErrorReturn:
    if (pRegSiblingContext) {
        MartaCloseRegistryKeyContext((MARTA_CONTEXT) pRegSiblingContext);
        pRegSiblingContext = NULL;
    }

    // kedar wants this mapped to success
    if (ERROR_NO_MORE_ITEMS == dwErr)
        dwErr = ERROR_SUCCESS;
    goto CommonReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
NoMoreItemsReturn:
    dwErr = ERROR_NO_MORE_ITEMS;
    goto ErrorReturn;
}


DWORD
MartaConvertRegistryKeyContextToName(
    IN MARTA_CONTEXT        Context,
    OUT LPWSTR              *ppwszObject
    )

/*++

Routine Description:

    Returns the NT Object Name for the given context. Allocates memory.

Arguments:

    Context - Context for the registry key.

    ppwszObject - To return the name of the registry key.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/


{
    DWORD dwErr = ERROR_SUCCESS;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;
    LPWSTR pwszObject = NULL;

    BYTE Buff[512];
    ULONG cLen = 0;
    POBJECT_NAME_INFORMATION pNI;                   // not allocated
    POBJECT_NAME_INFORMATION pAllocNI = NULL;
    NTSTATUS Status;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        goto InvalidParameterReturn;

    if (pRegContext->pwszObject) {

        //
        // Already have the object's name
        //

        if (ERROR_SUCCESS != (dwErr = I_MartaRegDupString(
                pRegContext->pwszObject, &pwszObject)))
            goto ErrorReturn;
        else
            goto SuccessReturn;
    } else {
        HKEY hKey = pRegContext->hKey;
        LPWSTR pwszPath;
        DWORD cchPath;

        //
        // First, determine the size of the buffer we need...
        //

        pNI = (POBJECT_NAME_INFORMATION) Buff;
        Status = NtQueryObject(hKey,
            ObjectNameInformation,
            pNI,
            sizeof(Buff),
            &cLen);
        if (!NT_SUCCESS(Status) || sizeof(*pNI) > cLen ||
                0 == pNI->Name.Length) {
            if (Status == STATUS_BUFFER_TOO_SMALL ||
                    Status == STATUS_INFO_LENGTH_MISMATCH ||
                    Status == STATUS_BUFFER_OVERFLOW) {

                //
                // Allocate a big enough buffer
                //

                if (NULL == (pAllocNI = (POBJECT_NAME_INFORMATION)
                        I_MartaRegNonzeroAlloc(cLen)))
                    goto NotEnoughMemoryReturn;
                pNI = pAllocNI;

                Status = NtQueryObject(hKey,
                                       ObjectNameInformation,
                                       pNI,
                                       cLen,
                                       NULL);
                if (!NT_SUCCESS(Status))
                    goto StatusErrorReturn;
            } else {

                //
                // Check if one of the predefined base keys
                //

                LPCWSTR pwszBaseKey = NULL;

                if (HKEY_LOCAL_MACHINE == hKey)
                    pwszBaseKey = L"MACHINE";
                else if (HKEY_USERS == hKey)
                    pwszBaseKey = L"USERS";
                else if (HKEY_CLASSES_ROOT == hKey)
                    pwszBaseKey = L"CLASSES_ROOT";
                else if (HKEY_CURRENT_USER == hKey)
                    pwszBaseKey = L"CURRENT_USER";
                else if (HKEY_CURRENT_CONFIG == hKey)
                    pwszBaseKey = L"CONFIG";
                else if (!NT_SUCCESS(Status))
                    goto StatusErrorReturn;
                else
                    goto InvalidHandleReturn;

                if (ERROR_SUCCESS != (dwErr = I_MartaRegDupString(
                        pwszBaseKey, &pwszObject)))
                    goto ErrorReturn;
                else
                    goto SuccessReturn;
            }
        }

        pwszPath = pNI->Name.Buffer;
        cchPath = pNI->Name.Length / sizeof(WCHAR);

        if (REG_OBJ_TAG_LEN > cchPath ||
                0 != _wcsnicmp(pwszPath, REG_OBJ_TAG, REG_OBJ_TAG_LEN))
            goto BadPathnameReturn;

        pwszPath += REG_OBJ_TAG_LEN;
        cchPath -= REG_OBJ_TAG_LEN;

        if (NULL == (pwszObject = (LPWSTR) I_MartaRegNonzeroAlloc(
                (cchPath + 1) * sizeof(WCHAR))))
            goto NotEnoughMemoryReturn;

        memcpy(pwszObject, pwszPath, cchPath * sizeof(WCHAR));
        pwszObject[cchPath] = L'\0';
    }

SuccessReturn:
    dwErr = ERROR_SUCCESS;

CommonReturn:
    I_MartaRegFree(pAllocNI);
    *ppwszObject = pwszObject;
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    assert(NULL == pwszObject);
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;

InvalidHandleReturn:
    dwErr = ERROR_INVALID_HANDLE;
    goto ErrorReturn;

BadPathnameReturn:
    dwErr = ERROR_BAD_PATHNAME;
    goto ErrorReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}

DWORD
MartaConvertRegistryKeyContextToHandle(
    IN MARTA_CONTEXT        Context,
    OUT HANDLE              *pHandle
    )

/*++

Routine Description:

    The following is for testing

    The returned Handle isn't duplicated. It has the same lifetime as
    the Context

Arguments:

    Context - Context whose properties the caller has asked for.
    
    pHandle - To return the handle.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    DWORD dwErr;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt) {
        *pHandle = NULL;
        dwErr = ERROR_INVALID_PARAMETER;
    } else {
        *pHandle = (HANDLE) pRegContext->hKey;
        dwErr = ERROR_SUCCESS;
    }

    return dwErr;
}

DWORD
MartaGetRegistryKeyProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    )

/*++

Routine Description:

    Return the properties for registry key represented by the context.

Arguments:

    Context - Context whose properties the caller has asked for.
    
    pProperties - To return the properties for this registry key.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    pProperties->dwFlags |= MARTA_OBJECT_IS_CONTAINER;
    return ERROR_SUCCESS;
}

DWORD
MartaGetRegistryKeyTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    )

/*++

Routine Description:

    Return the properties of registry key objects.

Arguments:

    pProperties - To return the properties of registry key objects.

Return Value:

    ERROR_SUCCESS.

--*/

{
    const GENERIC_MAPPING GenMap = {
        KEY_READ,
        KEY_WRITE,
        KEY_EXECUTE,
        KEY_ALL_ACCESS
        };

    pProperties->dwFlags |= MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG;
    pProperties->dwFlags |= MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG;
    pProperties->GenMap = GenMap;

    return ERROR_SUCCESS;
}

DWORD
MartaGetRegistryKeyRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )

/*++

Routine Description:

    Get the security descriptor for the given handle.

Arguments:

    Context - Context for registry key.
    
    SecurityInfo - Type of security information to be read.
    
    ppSecurityDescriptor - To return a self-relative security decriptor pointer.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;
    DWORD cbSize;
    PISECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        goto InvalidParameterReturn;

    //
    // First, get the size we need
    //

    cbSize = 0;
    dwErr = RegGetKeySecurity(
        pRegContext->hKey,
        SecurityInfo,
        NULL,                       // pSecDesc
        &cbSize
        );

    if (ERROR_INSUFFICIENT_BUFFER == dwErr) {
        if (NULL == (pSecurityDescriptor =
                (PISECURITY_DESCRIPTOR) I_MartaRegNonzeroAlloc(cbSize)))
            goto NotEnoughMemoryReturn;

        dwErr = RegGetKeySecurity(
            pRegContext->hKey,
            SecurityInfo,
            pSecurityDescriptor,
            &cbSize
            );
    } else if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;

    if (ERROR_SUCCESS != dwErr)
        goto ErrorReturn;

CommonReturn:
    *ppSecurityDescriptor = pSecurityDescriptor;
    return dwErr;

ErrorReturn:
    if (pSecurityDescriptor) {
        I_MartaRegFree(pSecurityDescriptor);
        pSecurityDescriptor = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}


DWORD
MartaSetRegistryKeyRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )


/*++

Routine Description:

    Set the given security descriptor on the registry key represented by the context.

Arguments:

    Context - Context for the registry key.

    SecurityInfo - Type of security info to be stamped on the registry key.

    pSecurityDescriptor - Security descriptor to be stamped.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        goto InvalidParameterReturn;

    dwErr = RegSetKeySecurity(
        pRegContext->hKey,
        SecurityInfo,
        pSecurityDescriptor
        );

CommonReturn:
    return dwErr;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto CommonReturn;
}

ACCESS_MASK
MartaGetRegistryKeyDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    )

/*++

Routine Description:

    Gets the access required to open object to be able to set or get the 
    specified security info.

Arguments:

    OpenType - Flag indicating if the object is to be opened to read or write
        the security information

    Attribs - TRUE indicates that additional access bits should be returned.

    SecurityInfo - owner/group/dacl/sacl

Return Value:

    Desired access mask with which open should be called.

--*/

{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    if (TRUE == Attribs)
    {
        DesiredAccess |= KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE;
    }

    return (DesiredAccess);
}

ACCESS_MASK
MartaGetRegistryKey32DesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    )

/*++

Routine Description:

    Gets the access required to open object to be able to set or get the 
    specified security info.

Arguments:

    OpenType - Flag indicating if the object is to be opened to read or write
        the security information

    Attribs - TRUE indicates that additional access bits should be returned.

    SecurityInfo - owner/group/dacl/sacl

Return Value:

    Desired access mask with which open should be called.

--*/

{
    ACCESS_MASK DesiredAccess = KEY_WOW64_32KEY;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    if (TRUE == Attribs)
    {
        DesiredAccess |= KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE;
    }

    return (DesiredAccess);
}
ACCESS_MASK
MartaGetDefaultDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    )

/*++

Routine Description:

    Gets the access required to open object to be able to set or get the 
    specified security info. This default routine is used for all resource
    managers except for files/reg.

Arguments:

    OpenType - Flag indicating if the object is to be opened to read or write
        the security information

    Attribs - TRUE indicates that additional access bits should be returned.

    SecurityInfo - owner/group/dacl/sacl

Return Value:

    Desired access mask with which open should be called.

--*/

{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    return (DesiredAccess);
}

DWORD
MartaReopenRegistryKeyContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    )

/*++

Routine Description:

    Given the context for a registry key, close the existing handle if one exists 
    and reopen the context with new permissions.

Arguments:

    Context - Context to be reopened.
    
    AccessMask - Permissions for the reopen.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    HKEY hKey;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;
    PREG_FIND_DATA pRegFindData = pRegContext->pRegFindData;
    PREG_CONTEXT pRegParentContext = pRegFindData->pRegParentContext;

    dwErr = RegOpenKeyExW(
                pRegParentContext->hKey,
                pRegFindData->pwszSubKey,
                0,              // dwReversed
                AccessMask,
                &hKey);

    if (ERROR_SUCCESS == dwErr) {
        if (pRegContext->dwFlags & REG_CONTEXT_CLOSE_HKEY_FLAG)
            RegCloseKey(pRegContext->hKey);
        pRegContext->hKey = hKey;
        pRegContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;
    }

    return dwErr;
}

DWORD
MartaReopenRegistryKeyOrigContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    )

/*++

Routine Description:

    Reopen the original context with a new access mask. Close the original 
    handle.

Arguments:

    Context - Context to reopen.
    
    AccessMask - Desired access for open.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    DWORD dwErr;
    HKEY hKey;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    dwErr = RegOpenKeyExW(
                pRegContext->hKey,
                NULL,           // pwszSubKey
                0,              // dwReversed
                AccessMask,
                &hKey);

    if (ERROR_SUCCESS == dwErr) {
        if (pRegContext->dwFlags & REG_CONTEXT_CLOSE_HKEY_FLAG)
            RegCloseKey(pRegContext->hKey);
        pRegContext->hKey = hKey;
        pRegContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;
    }

    return dwErr;
}

DWORD
MartaGetRegistryKeyNameFromContext(
    IN MARTA_CONTEXT Context,
    OUT LPWSTR *pObjectName
    )

/*++

Routine Description:

    Get the name of the registry key from the context. This routine allocates 
    memory required to hold the name of the object.

Arguments:

    Context - Handle to the context.
    
    pObjectName - To return the pointer to the allocated string.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    return MartaConvertRegistryKeyContextToName(
               Context,
               pObjectName
               );
}

DWORD
MartaGetRegistryKeyParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    )

/*++

Routine Description:

    Given the name of a registry key return the name of its parent. The routine 
    allocates memory required to hold the parent name.

Arguments:

    ObjectName - Name of the registry key.
    
    pParentName - To return the pointer to the allocated parent name.
        In case of the root of the tree, we return NULL parent with ERROR_SUCCESS.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    ULONG Length = wcslen(ObjectName) + 1;
    PWCHAR Name = (PWCHAR) I_MartaRegNonzeroAlloc(sizeof(WCHAR) * Length);
    DWORD dwErr = ERROR_SUCCESS;

    *pParentName = NULL;

    if (!Name)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy((WCHAR *) Name, ObjectName);

    dwErr = I_MartaRegGetParentString(Name);

    if (ERROR_SUCCESS != dwErr)
    {
        I_MartaRegFree(Name);

        if (ERROR_INVALID_NAME == dwErr)
            return ERROR_SUCCESS;

        return dwErr;
    }

    *pParentName = Name;

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\rightsca.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:        rightsca.cxx
//
//  Contents:    Implementation of the DS access control rights cache
//
//  History:     20-Feb-98      MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <stdio.h>
#include <alsup.hxx>

//
// Global name/id cache
//
PACTRL_RIGHTS_CACHE  grgRightsNameCache[ACTRL_OBJ_ID_TABLE_SIZE];

//
// Last connection info/time we read from the schema
//
static ACTRL_ID_SCHEMA_INFO    LastSchemaRead;

static RTL_RESOURCE RightsCacheLock;
BOOL bRightsCacheLockInitialized = FALSE;

#define ACTRL_EXT_RIGHTS_CONTAINER L"CN=Extended-Rights,"

//+----------------------------------------------------------------------------
//
//  Function:   AccctrlInitializeRightsCache
//
//  Synopsis:   Initialize the access control rights lookup cache
//
//  Arguments:  VOID
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD AccctrlInitializeRightsCache(VOID)
{
    DWORD dwErr;
    
    if (TRUE == bRightsCacheLockInitialized)
    {
        //
        // Just a precautionary measure to make sure that we do not initialize
        // multiple times.
        //

        ASSERT(FALSE);
        return ERROR_SUCCESS;
    }

    memset(grgRightsNameCache, 0,
           sizeof(PACTRL_RIGHTS_CACHE) * ACTRL_OBJ_ID_TABLE_SIZE);

    memset(&LastSchemaRead, 0, sizeof(ACTRL_ID_SCHEMA_INFO));

    __try
    {
        RtlInitializeResource(&RightsCacheLock);
        dwErr = ERROR_SUCCESS;
        bRightsCacheLockInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RtlNtStatusToDosError(GetExceptionCode());
    }

    return dwErr;
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlFreeRightsCache
//
//  Synopsis:   Frees any memory allocated for the id name/guid cache
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID AccctrlFreeRightsCache(VOID)
{
    INT i,j;
    PACTRL_RIGHTS_CACHE   pNode, pNext;

    if (FALSE == bRightsCacheLockInitialized)
    {
        return;
    }

    for(i = 0; i < ACTRL_OBJ_ID_TABLE_SIZE; i++)
    {
        pNode = grgRightsNameCache[i];
        while(pNode != NULL)
        {
            pNext = pNode->pNext;
            for (j = 0; j < (INT)pNode->cRights; j++)
            {
                AccFree(pNode->RightsList[j]);
            }
            AccFree(pNode->RightsList);

            AccFree(pNode);
            pNode = pNext;
        }
    }

    AccFree(LastSchemaRead.pwszPath);

    RtlDeleteResource(&RightsCacheLock);

    bRightsCacheLockInitialized = FALSE;

}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlFindRightsNode
//
//  Synopsis:   Looks up the node for the given class GUID
//
//  Arguments:  [ClassGuid]     --      Class guid to look up
//
//  Returns:    NULL            --      Node not found
//              else a valid node pointer
//
//-----------------------------------------------------------------------------
PACTRL_RIGHTS_CACHE
AccctrlpLookupClassGuidInCache(IN  PGUID ClassGuid)
{
    PACTRL_RIGHTS_CACHE pNode = NULL;

    pNode =  grgRightsNameCache[ActrlHashGuid(ClassGuid)];

    while(pNode != NULL)
    {
        if(memcmp(ClassGuid, &pNode->ObjectClassGuid,sizeof(GUID)) == 0)
        {
            break;
        }
        pNode = pNode->pNext;
    }

#if DBG
    if(pNode != NULL )
    {
    CHAR    szGuid[38];
    PGUID   pGuid = &pNode->ObjectClassGuid;
    sprintf(szGuid, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,pGuid->Data2,pGuid->Data3,pGuid->Data4[0],
                pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
                pGuid->Data4[7]);

    acDebugOut((DEB_TRACE_LOOKUP,
                "Found guid %s\n",
                szGuid));
    }
#endif

    return(pNode);
}



//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertRightsNode
//
//  Synopsis:   Updates the information for an existing node or creates and
//              inserts a new one
//
//  Arguments:  [AppliesTo]     --      Guid this control right applies to
//              [RightsGuid]    --      Control right
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//-----------------------------------------------------------------------------
DWORD AccctrlpInsertRightsNode(IN PGUID AppliesTo,
                               IN PWSTR ControlRight)
{
    DWORD dwErr = ERROR_SUCCESS;
    PACTRL_RIGHTS_CACHE Node, pNext, pTrail = NULL;
    PWSTR *NewList;
    BOOL NewNode = FALSE;

    //
    // First, find the existing node, if it exists
    //
    Node = AccctrlpLookupClassGuidInCache( AppliesTo );

    if(Node == NULL)
    {
        //
        // Have to create and insert a new one
        //
        Node = (PACTRL_RIGHTS_CACHE)AccAlloc(sizeof(ACTRL_RIGHTS_CACHE));

        if(Node == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            NewNode = TRUE;
            memcpy(&Node->ObjectClassGuid, AppliesTo, sizeof(GUID));
            Node->cRights=0;

            pNext = grgRightsNameCache[ActrlHashGuid(AppliesTo)];

            while(pNext != NULL)
            {
                if(memcmp(AppliesTo, &(pNext->ObjectClassGuid), sizeof(GUID)) == 0)
                {
                    dwErr = ERROR_ALREADY_EXISTS;
                    acDebugOut((DEB_TRACE_LOOKUP, "Guid collision. Bailing\n"));
                    break;
                }

                pTrail = pNext;
                pNext = pNext->pNext;
            }

        }

        if(dwErr == ERROR_SUCCESS)
        {
            if(pTrail == NULL)
            {

                grgRightsNameCache[ActrlHashGuid(AppliesTo)] = Node;

            }
            else {

                pTrail->pNext = Node;
            }

        }
    }

    //
    // Now, insert the new applies to list
    if(dwErr == ERROR_SUCCESS)
    {
        NewList = (PWSTR *)AccAlloc((Node->cRights + 1) * sizeof(PWSTR));
        if(NewList==NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memcpy(NewList, Node->RightsList, Node->cRights * sizeof( PWSTR ));

            NewList[Node->cRights] = (PWSTR)AccAlloc((wcslen(ControlRight) + 1) * sizeof(WCHAR));
            if(NewList[Node->cRights] == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                AccFree(NewList);
            }
            else
            {
                wcscpy(NewList[Node->cRights], ControlRight);
                Node->cRights++;
                AccFree(Node->RightsList);
                Node->RightsList = NewList;
            }
        }
    }

    //
    // Clean up if necessary
    //
    if(dwErr != ERROR_SUCCESS && NewNode == TRUE)
    {
        AccFree(Node);
    }

    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AccDsReadAndInsertExtendedRights
//
//  Synopsis:   Reads the full list of extended rights from the schema
//
//  Arguments:  [IN  pLDAP]                 --      LDAP connection to use
//              [OUT pcItems]               --      Where the count of items
//                                                  is returned
//              [OUT RightsList]            --      Where the list of rights
//                                                  entries is returned.
//
//  Notes:
//
//  Returns:    ERROR_SUCCESS               --      Success
//
//----------------------------------------------------------------------------
DWORD
AccDsReadAndInsertExtendedRights(IN PLDAP   pLDAP)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PWSTR              *ppwszValues = NULL, *ppwszApplies = NULL;
    PWSTR               rgwszAttribs[3];
    PWSTR               pwszERContainer = NULL;
    PDS_NAME_RESULTW    pNameRes = NULL;
    LDAPMessage         *pMessage, *pEntry;
    ULONG               cEntries, i, j;
    PACTRL_RIGHTS_CACHE pCurrentEntry;
    GUID                RightsGuid;

    //
    // Get the subschema path
    //
    if(dwErr == ERROR_SUCCESS)
    {
        rgwszAttribs[0] = L"configurationNamingContext";
        rgwszAttribs[1] = NULL;

        dwErr = ldap_search_s(pLDAP,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgwszAttribs,
                              0,
                              &pMessage);
        if(dwErr == ERROR_SUCCESS)
        {
            pEntry = ldap_first_entry(pLDAP,
                                      pMessage);

            if(pEntry == NULL)
            {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
            else
            {
                //
                // Now, we'll have to get the values
                //
                ppwszValues = ldap_get_values(pLDAP,
                                              pEntry,
                                              rgwszAttribs[0]);
                ldap_msgfree(pMessage);

                if(ppwszValues == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    pwszERContainer = (PWSTR)AccAlloc((wcslen(ppwszValues[0]) * sizeof(WCHAR)) +
                                                      sizeof(ACTRL_EXT_RIGHTS_CONTAINER));
                    if(pwszERContainer == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        wcscpy(pwszERContainer,
                               ACTRL_EXT_RIGHTS_CONTAINER);
                        wcscat(pwszERContainer,
                               ppwszValues[0]);


                        rgwszAttribs[0] = L"rightsGuid";
                        rgwszAttribs[1] = L"appliesTo";
                        rgwszAttribs[2] = NULL;

                        //
                        // Read the control access rights
                        //
                        dwErr = ldap_search_s(pLDAP,
                                              pwszERContainer,
                                              LDAP_SCOPE_ONELEVEL,
                                              L"(objectClass=controlAccessRight)",
                                              rgwszAttribs,
                                              0,
                                              &pMessage);

                        dwErr = LdapMapErrorToWin32( dwErr );

                        AccFree(pwszERContainer);
                    }
                    ldap_value_free(ppwszValues);


                    //
                    // Process the entries
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        pEntry = ldap_first_entry(pLDAP,
                                                 pMessage);

                        if(pEntry == NULL)
                        {
                            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                        }
                        else
                        {
                            cEntries = ldap_count_entries( pLDAP, pMessage );

                            for(i = 0; i < cEntries && dwErr == ERROR_SUCCESS; i++) {

                                ppwszValues = ldap_get_values(pLDAP,
                                                              pEntry,
                                                              rgwszAttribs[0]);
                                if(ppwszValues == NULL)
                                {
                                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                                }
                                else
                                {
                                    //
                                    // Then the list of applies to
                                    //
                                    ppwszApplies = ldap_get_values(pLDAP,
                                                                  pEntry,
                                                                  rgwszAttribs[1]);
                                    j = 0;

                                    while(ppwszApplies[j] != NULL && dwErr == ERROR_SUCCESS)
                                    {

                                        dwErr = UuidFromString(ppwszApplies[j],
                                                               &RightsGuid);

                                        if(dwErr == ERROR_SUCCESS)
                                        {
                                            dwErr = AccctrlpInsertRightsNode( &RightsGuid,
                                                                              ppwszValues[0]);
                                        }
                                        j++;
                                    }

                                    ldap_value_free(ppwszApplies);
                                    ppwszApplies = NULL;
                                    ldap_value_free(ppwszValues);

                                }

                                pEntry = ldap_next_entry( pLDAP, pEntry );
                            }

                        }
                    }

                    ldap_msgfree(pMessage);
                }
            }

        }
        else
        {
            dwErr = LdapMapErrorToWin32( dwErr );
        }

    }

    return(dwErr) ;
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLoadRightsCacheFromSchema
//
//  Synopsis:   Reads the control rights schema cache and adds the entries into the
//              cache
//
//  Arguments:  [pLDAP]         --      LDAP connection to the server
//              [pwszPath]      --      DS path to the object
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD   AccctrlpLoadRightsCacheFromSchema(PLDAP   pLDAP,
                                          PWSTR   pwszDsPath)
{
    DWORD       dwErr = ERROR_SUCCESS;
    PLDAP       pLocalLDAP = pLDAP;
    ULONG       cValues[2];
    PWSTR      *ppwszValues[2];

    acDebugOut((DEB_TRACE_LOOKUP, "Reloading rights cache from schema\n"));

    //
    // If we have no parameters, just return...
    //
    if(pLDAP == NULL && pwszDsPath == NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // See if we need to read...  If our data is over 5 minutes old or if our path referenced is
    // not the same as the last one...
    //
#define FIVE_MINUTES    300000
    if((LastSchemaRead.LastReadTime != 0 &&
                            (GetTickCount() - LastSchemaRead.LastReadTime < FIVE_MINUTES)) &&
       DoPropertiesMatch(pwszDsPath, LastSchemaRead.pwszPath) &&
       ((pLDAP == NULL && LastSchemaRead.fLDAP == FALSE) ||
        (pLDAP != NULL && memcmp(pLDAP, &(LastSchemaRead.LDAP), sizeof(LDAP)))))

    {
        acDebugOut((DEB_TRACE_LOOKUP,"Cache up to date...\n"));
        return(ERROR_SUCCESS);
    }
    else
    {
        //
        // Need to reinitialize it...
        //
        if(pLDAP == NULL)
        {
            LastSchemaRead.fLDAP = FALSE;
        }
        else
        {
            LastSchemaRead.fLDAP = TRUE;
            memcpy(&(LastSchemaRead.LDAP), pLDAP, sizeof(LDAP));
        }

        AccFree(LastSchemaRead.pwszPath);
        if(pwszDsPath != NULL)
        {
            ACC_ALLOC_AND_COPY_STRINGW(pwszDsPath, LastSchemaRead.pwszPath, dwErr);
        }

        LastSchemaRead.LastReadTime = GetTickCount();
    }



    if(dwErr == ERROR_SUCCESS && pLocalLDAP == NULL)
    {
        PWSTR pwszServer = NULL, pwszObject = NULL;

        dwErr = DspSplitPath( pwszDsPath, &pwszServer, &pwszObject );

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = BindToDSObject(pwszServer, pwszObject, &pLocalLDAP);
            LocalFree(pwszServer);
        }
    }

    //
    // Now, get the info.  First, extended rights, then the schema info
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccDsReadAndInsertExtendedRights(pLocalLDAP);
    }

    //
    // See if we need to release our ldap connection
    //
    if(pLocalLDAP != pLDAP && pLocalLDAP != NULL)
    {
        UnBindFromDSObject(&pLocalLDAP);
    }

    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupRightByName
//
//  Synopsis:   Returns the list of control rights for a given object class
//
//  Arguments:  [pLDAP]         --      LDAP connection to the server
//              [pwszPath]      --      DS path to the object
//              [pwszName]      --      Object class name
//              [pCount]        --      Where the count if items is returned
//              [ppRightsList]  --      List of control rights
//              [ppwszNameList] --      List of control rights names
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_NOT_FOUND --      No such ID exists
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupRightsByName(IN  PLDAP      pLDAP,
                          IN  PWSTR      pwszDsPath,
                          IN  PWSTR      pwszName,
                          OUT PULONG     pCount,
                          OUT PACTRL_CONTROL_INFOW *ControlInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    GUID *ObjectClassGuid, RightsGuid;
    PACTRL_RIGHTS_CACHE Node;
    ULONG Size = 0, i;
    PWSTR GuidName, Current;

    if((pwszDsPath == NULL && pLDAP == NULL) || pwszName == NULL)
    {
        *pCount = 0;
        *ControlInfo = NULL;
        return(ERROR_SUCCESS);
    }

    RtlAcquireResourceShared(&RightsCacheLock, TRUE);

    //
    // This is a multi-staged process.  First, we have to lookup the guid associated
    // with the object class name.  Then, we get the list of control rights for it
    //
    dwErr = AccctrlLookupGuid(pLDAP,
                              pwszDsPath,
                              pwszName,
                              FALSE,        // Don't allocate
                              &ObjectClassGuid);
    if(dwErr == ERROR_SUCCESS)
    {
        Node = AccctrlpLookupClassGuidInCache(ObjectClassGuid);

        if(Node == NULL)
        {
            RtlConvertSharedToExclusive( &RightsCacheLock );

            dwErr = AccctrlpLoadRightsCacheFromSchema(pLDAP, pwszDsPath );

            if(dwErr == ERROR_SUCCESS)
            {
                Node = AccctrlpLookupClassGuidInCache(ObjectClassGuid);
                if(Node == NULL)
                {
                    dwErr = ERROR_NOT_FOUND;
                }
            }

        }


        if(Node != NULL)
        {
            //
            // Size all of the return strings
            //
            for (i = 0;i < Node->cRights && dwErr == ERROR_SUCCESS; i++) {

                dwErr = UuidFromString( Node->RightsList[i],&RightsGuid);

                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AccctrlLookupIdName(pLDAP,
                                                pwszDsPath,
                                                &RightsGuid,
                                                FALSE,
                                                FALSE,
                                                &GuidName);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        Size += wcslen( GuidName ) + 1;
                        Size += wcslen( Node->RightsList[i] ) + 1;
                    }

                }
            }

            //
            // Now, allocate the return information
            //
            if(dwErr == ERROR_SUCCESS)
            {
                *ControlInfo = (PACTRL_CONTROL_INFOW)AccAlloc((Size * sizeof(WCHAR)) +
                                                   (Node->cRights * sizeof(ACTRL_CONTROL_INFOW)));
                if(*ControlInfo == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    Current = (PWSTR)((*ControlInfo) + Node->cRights);
                    for (i = 0;i < Node->cRights && dwErr == ERROR_SUCCESS; i++) {

                        UuidFromString( Node->RightsList[i],&RightsGuid);

                        dwErr = AccctrlLookupIdName(pLDAP,
                                                    pwszDsPath,
                                                    &RightsGuid,
                                                    FALSE,
                                                    FALSE,
                                                    &GuidName);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            (*ControlInfo)[i].lpControlId = Current;
                            wcscpy(Current, Node->RightsList[i]);
                            Current += wcslen(Node->RightsList[i]);
                            *Current = L'\0';
                            Current++;

                            (*ControlInfo)[i].lpControlName = Current;
                            wcscpy(Current, GuidName);
                            Current += wcslen(GuidName);
                            *Current = L'\0';
                            Current++;
                        }
                    }


                    if(dwErr != ERROR_SUCCESS)
                    {
                        AccFree(*ControlInfo);
                    }
                    else
                    {
                        *pCount = Node->cRights;
                    }
                }

            }

        }
    }

    RtlReleaseResource(&RightsCacheLock);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\seia.cxx ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Microsoft Windows                                                         //
//  Copyright (C) Microsoft Corporation, 1999.                                //
//                                                                            //
//  File:    seia.cxx                                                         //
//                                                                            //
//  Contents:    New marta rewrite functions for SetEntriesInAcl              //
//                                                                            //
//  History:    4/99    KedarD     Created                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <stdio.h>
    #include <permit.h>
    #include <dsgetdc.h>
    #include <lmapibuf.h>
    #include <wmistr.h>
    #include <ntprov.hxx>
    #include <strings.h>
    #include <seopaque.h>
    #include <sertlp.h>
    #include <accctrl.h>
    #include <guidtables.h>
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// MACRO DEFINITIONS START HERE                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define MARTA_SID_FOR_NAME                                                     \
        {                                                                      \
           ((PKNOWN_ACE) *ppAcl)->Mask = pAccessInfo->Mask;                    \
           AceSize = RtlLengthSid(pAccessInfo->pSid);                          \
           memcpy(                                                             \
               ((PUCHAR) *ppAcl) + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK),   \
               (PUCHAR) pAccessInfo->pSid,                                     \
               AceSize                                                         \
               );                                                              \
           AceSize += sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);                \
        }

#define MARTA_SID_FOR_SID                                                      \
        {                                                                      \
           ((PKNOWN_ACE) *ppAcl)->Mask = pAccessInfo->Mask;                    \
           AceSize = RtlLengthSid((PSID) pExplicitAccess->Trustee.ptstrName);  \
           memcpy(                                                             \
               ((PUCHAR) *ppAcl) + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK),   \
               (PUCHAR) pExplicitAccess->Trustee.ptstrName,                    \
               AceSize                                                         \
               );                                                              \
           AceSize += sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);                \
        }

#define MARTA_SID_AND_GUID_FOR_OBJECT_NAME                                     \
        {                                                                      \
           pObjName = (POBJECTS_AND_NAME_W) pExplicitAccess->Trustee.ptstrName;\
           ((PKNOWN_OBJECT_ACE) *ppAcl)->Flags = pObjName->ObjectsPresent;     \
           ((PKNOWN_OBJECT_ACE) *ppAcl)->Mask = pAccessInfo->Mask;             \
           AceSize = RtlLengthSid(pAccessInfo->pSid);                          \
           memcpy(                                                             \
               (PUCHAR) RtlObjectAceSid(*ppAcl),                               \
               (PUCHAR) pAccessInfo->pSid,                                     \
               AceSize                                                         \
               );                                                              \
           pGuid = RtlObjectAceObjectType(*ppAcl);                             \
           if (NULL != pGuid)                                                  \
           {                                                                   \
               memcpy(                                                         \
                   (PUCHAR) pGuid,                                             \
                   (PUCHAR) pAccessInfo->pObjectTypeGuid,                      \
                   sizeof(GUID)                                                \
                   );                                                          \
               AceSize += sizeof(GUID);                                        \
           }                                                                   \
           pGuid = RtlObjectAceInheritedObjectType(*ppAcl);                    \
           if (NULL != pGuid)                                                  \
           {                                                                   \
               memcpy(                                                         \
                   (PUCHAR) pGuid,                                             \
                   (PUCHAR) pAccessInfo->pInheritedObjectTypeGuid,             \
                   sizeof(GUID)                                                \
                   );                                                          \
               AceSize += sizeof(GUID);                                        \
           }                                                                   \
           AceSize += sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(ULONG);\
        }

#define MARTA_SID_AND_GUID_FOR_OBJECT_SID                                      \
        {                                                                      \
           pObjSid = (POBJECTS_AND_SID) pExplicitAccess->Trustee.ptstrName;    \
           ((PKNOWN_OBJECT_ACE) *ppAcl)->Flags = pObjSid->ObjectsPresent;      \
           ((PKNOWN_OBJECT_ACE) *ppAcl)->Mask = pAccessInfo->Mask;             \
           AceSize = RtlLengthSid(pObjSid->pSid);                              \
           memcpy(                                                             \
               (PUCHAR) RtlObjectAceSid(*ppAcl),                               \
               (PUCHAR) pObjSid->pSid,                                         \
               AceSize                                                         \
               );                                                              \
           pGuid = RtlObjectAceObjectType(*ppAcl);                             \
           if (NULL != pGuid)                                                  \
           {                                                                   \
               memcpy(                                                         \
                   (PUCHAR) pGuid,                                             \
                   (PUCHAR) &(pObjSid->ObjectTypeGuid),                        \
                   sizeof(GUID)                                                \
                   );                                                          \
               AceSize += sizeof(GUID);                                        \
           }                                                                   \
           pGuid = RtlObjectAceInheritedObjectType(*ppAcl);                    \
           if (NULL != pGuid)                                                  \
           {                                                                   \
               memcpy(                                                         \
                   (PUCHAR) pGuid,                                             \
                   (PUCHAR) &(pObjSid->InheritedObjectTypeGuid),               \
                   sizeof(GUID)                                                \
                   );                                                          \
               AceSize += sizeof(GUID);                                        \
           }                                                                   \
           AceSize += sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(ULONG);\
        }

typedef struct _MARTA_ACCESS_INFO
{
    ACCESS_MASK   Mask;
    ULONG         Size;
    PSID          pSid;
    PSID          pServerSid;
    GUID        * pObjectTypeGuid;
    GUID        * pInheritedObjectTypeGuid;
} MARTA_ACCESS_INFO, *PMARTA_ACCESS_INFO;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// FUNCTION PROTOTYPES START HERE                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
AccRewriteSetEntriesInAcl(
    IN  ULONG                cCountOfExplicitEntries,
    IN  PEXPLICIT_ACCESS_W   pListOfExplicitEntries,
    IN  PACL                 OldAcl,
    OUT PACL               * pNewAcl
    );

BOOL
MartaIsExplicitAclCanonical(
    IN  PACL   pAcl,
    OUT PULONG pExplicitAceCnt
    );

DWORD
MartaTrusteeSidAndGuidSize(
    IN  PTRUSTEE_W  pTrustee,
    IN  BOOL        bComputeGuidSize,
    OUT PSID      * ppSid,
    OUT PULONG      pSize,
    OUT PULONG      pGuidCnt          OPTIONAL
    );

DWORD
MartaAddExplicitEntryToAcl(
    IN OUT PUCHAR             * ppAcl,
    IN     PEXPLICIT_ACCESS_W   pExplicitAccess,
    IN     PMARTA_ACCESS_INFO   pAccessInfo
    );

DWORD
MartaGetSidFromName(
    IN  LPWSTR   pName,
    OUT PSID   * ppSid
    );

DWORD
MartaGetGuid(
    IN  LPWSTR           pObjectName,
    IN  SE_OBJECT_TYPE   ObjectType,
    OUT GUID           * pGuid
    );

DWORD
MartaGetExplicitAccessEntrySize(
    IN  PEXPLICIT_ACCESS_W pExplicitAccess,
    OUT PMARTA_ACCESS_INFO pAccessInfo,
    OUT PULONG             pGuidCnt,
    OUT PUCHAR             pAclRevision
    );

DWORD
MartaCompareAcesAndMarkMasks(
    IN PUCHAR             pAce,
    IN PACCESS_MASK       pAceMask,
    IN PEXPLICIT_ACCESS_W pExplicitAccess,
    IN PMARTA_ACCESS_INFO pAccessInfo,
    IN BOOL               bCanonical
    );

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaAddExplicitEntryToAcl                                       //
//                                                                            //
// Description: Convert an explicit entry into an ace and store it in the     //
//              acl. Update the acl pointer to the end.                       //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN OUT ppAcl]        Acl pointer where the ace should be stored       //
//                                                                            //
//     [IN pExplicitAccess]  Explicit entry to convert into an ace            //
//     [IN pAccessInfo]      Temp info associated with the explicit entry     //
//                                                                            //
// Returns: ERROR_SUCCESS if the entry could be converted into an ACE         //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaAddExplicitEntryToAcl(
    IN OUT PUCHAR             * ppAcl,
    IN     PEXPLICIT_ACCESS_W   pExplicitAccess,
    IN     PMARTA_ACCESS_INFO   pAccessInfo
    )
{
    DWORD                 dwErr      = ERROR_SUCCESS;
    ULONG                 AceSize    = 0;
    ULONG                 SidSize    = 0;
    UCHAR                 AceType    = 0;
    UCHAR                 AceFlags   = 0;
    PSID                  pSid       = NULL;
    GUID                * pGuid      = NULL;
    POBJECTS_AND_SID      pObjSid    = NULL;
    POBJECTS_AND_NAME_W   pObjName   = NULL;

    if (REVOKE_ACCESS == pExplicitAccess->grfAccessMode)
    {
        return ERROR_SUCCESS;
    }

    if (FLAG_ON(pExplicitAccess->grfInheritance, INHERITED_ACE))
    {
        return ERROR_SUCCESS;
    }

    if (0 == pAccessInfo->Size)
    {
        return ERROR_SUCCESS;
    }

    if (TRUSTEE_IS_IMPERSONATE == pExplicitAccess->Trustee.MultipleTrusteeOperation)
    {
        ((PKNOWN_COMPOUND_ACE) *ppAcl)->CompoundAceType = COMPOUND_ACE_IMPERSONATION;
        ((PKNOWN_COMPOUND_ACE) *ppAcl)->Mask = pAccessInfo->Mask;
        ((PKNOWN_COMPOUND_ACE) *ppAcl)->Reserved        = 0;

        AceSize = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(LONG);

        pSid = pAccessInfo->pServerSid     ?
                   pAccessInfo->pServerSid :
                   (PSID) pExplicitAccess->Trustee.ptstrName;

        SidSize = RtlLengthSid(pSid);

        memcpy(
            ((PUCHAR) *ppAcl) + AceSize,
            (PUCHAR) pSid,
            SidSize
            );

        AceSize += SidSize;

        pSid = pAccessInfo->pSid     ?
                   pAccessInfo->pSid :
                   (PSID) (pExplicitAccess->Trustee.pMultipleTrustee->ptstrName);

        SidSize = RtlLengthSid(pSid);

        memcpy(
            ((PUCHAR) *ppAcl) + AceSize,
            (PUCHAR) pSid,
            SidSize
            );

        AceSize += SidSize;

        CONDITIONAL_ACE_SIZE_ERROR(AceSize);

        ((PACE_HEADER) *ppAcl)->AceType  = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
        ((PACE_HEADER) *ppAcl)->AceFlags = (UCHAR) pExplicitAccess->grfInheritance;
        ((PACE_HEADER) *ppAcl)->AceSize  = (USHORT) AceSize;
        *ppAcl  += AceSize;

        return ERROR_SUCCESS;
    }

    switch (pExplicitAccess->grfAccessMode)
    {
    case GRANT_ACCESS:
    case SET_ACCESS:
        AceFlags = (UCHAR) pExplicitAccess->grfInheritance;
        switch (pExplicitAccess->Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:
            AceType = ACCESS_ALLOWED_ACE_TYPE;
            MARTA_SID_FOR_NAME
            break;
        case TRUSTEE_IS_SID:
            AceType = ACCESS_ALLOWED_ACE_TYPE;
            MARTA_SID_FOR_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_SID:
            AceType  = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_NAME:
            AceType  = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_NAME
            break;
        default:
            break;
        }
        break;
    case DENY_ACCESS:
        AceFlags = (UCHAR) pExplicitAccess->grfInheritance;
        switch (pExplicitAccess->Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:
            AceType = ACCESS_DENIED_ACE_TYPE;
            MARTA_SID_FOR_NAME
            break;
        case TRUSTEE_IS_SID:
            AceType = ACCESS_DENIED_ACE_TYPE;
            MARTA_SID_FOR_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_SID:
            AceType = ACCESS_DENIED_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_NAME:
            AceType = ACCESS_DENIED_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_NAME
            break;
        default:
            break;
        }
        break;
    case SET_AUDIT_SUCCESS:
        AceFlags = (UCHAR) (pExplicitAccess->grfInheritance | SUCCESSFUL_ACCESS_ACE_FLAG);
        switch (pExplicitAccess->Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:
            AceType = SYSTEM_AUDIT_ACE_TYPE;
            MARTA_SID_FOR_NAME
            break;
        case TRUSTEE_IS_SID:
            AceType = SYSTEM_AUDIT_ACE_TYPE;
            MARTA_SID_FOR_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_SID:
            AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_NAME:
            AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_NAME
            break;
        default:
            break;
        }
        break;
    case SET_AUDIT_FAILURE:
        AceFlags = (UCHAR) (pExplicitAccess->grfInheritance | FAILED_ACCESS_ACE_FLAG);
        switch (pExplicitAccess->Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:
            AceType = SYSTEM_AUDIT_ACE_TYPE;
            MARTA_SID_FOR_NAME
            break;
        case TRUSTEE_IS_SID:
            AceType = SYSTEM_AUDIT_ACE_TYPE;
            MARTA_SID_FOR_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_SID:
            AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_NAME:
            AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_NAME
            break;
        default:
            break;
        }
        break;
    case REVOKE_ACCESS:
        return ERROR_SUCCESS;
    default:
        return ERROR_SUCCESS;
    }

    CONDITIONAL_ACE_SIZE_ERROR(AceSize);

    ((PACE_HEADER) *ppAcl)->AceType  = AceType;
    ((PACE_HEADER) *ppAcl)->AceFlags = AceFlags;
    ((PACE_HEADER) *ppAcl)->AceSize  = (USHORT) AceSize;

    *ppAcl += AceSize;

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaCompareAcesAndMarkMasks                                     //
//                                                                            //
// Description: Check if the explicit entry is supposed to make any changes   //
//              to the ace. If so, store the change into the temp structure   //
//              assoiciated with the ace.                                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pAce]             Ace to compare with the explict entry            //
//     [IN pAceMask]         Temp info associated with the ace                //
//     [IN pExplicitAccess]  Explicit entry                                   //
//     [IN pAccessInfo]      Temp info associated with the explicit entry     //
//     [IN bCanonical]       Whether the acl passed in is canonical           //
//                                                                            //
// Returns: ERROR_SUCCESS if the entry could be converted into an ACE         //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaCompareAcesAndMarkMasks(
    IN PUCHAR             pAce,
    IN PACCESS_MASK       pAceMask,
    IN PEXPLICIT_ACCESS_W pExplicitAccess,
    IN PMARTA_ACCESS_INFO pAccessInfo,
    IN BOOL               bCanonical
    )
{
    ULONG                 SidLength                = 0;
    DWORD                 ObjectsPresent           = 0;
    GUID                * pGuid                    = NULL;
    GUID                * pObjectTypeGuid          = NULL;
    GUID                * pInheritedObjectTypeGuid = NULL;
    PSID                  pSid                     = NULL;
    POBJECTS_AND_SID      pObjSid                  = NULL;
    POBJECTS_AND_NAME_W   pObjName                 = NULL;
    ULONG                 AuditFlag                = FAILED_ACCESS_ACE_FLAG;
    UCHAR                 AceFlags                 = 0;

    if (FLAG_ON(pExplicitAccess->grfInheritance, INHERITED_ACE))
    {
        return ERROR_SUCCESS;
    }

    if (TRUSTEE_IS_IMPERSONATE == pExplicitAccess->Trustee.MultipleTrusteeOperation)
    {
        if (ACCESS_ALLOWED_COMPOUND_ACE_TYPE != ((PACE_HEADER) pAce)->AceType)
        {
            return ERROR_SUCCESS;
        }

        pSid = pAccessInfo->pServerSid     ?
                   pAccessInfo->pServerSid :
                   (PSID) pExplicitAccess->Trustee.ptstrName;

        if (!RtlEqualSid(
                pSid,
                (PSID) &(((PCOMPOUND_ACCESS_ALLOWED_ACE) pAce)->SidStart)
                ))
        {
            return ERROR_SUCCESS;
        }

        SidLength = RtlLengthSid(pSid);

        pSid = pAccessInfo->pSid     ?
                   pAccessInfo->pSid :
                   (PSID) (pExplicitAccess->Trustee.pMultipleTrustee->ptstrName);

        if (!RtlEqualSid(
                pSid,
                (PSID) (((PUCHAR) &(((PCOMPOUND_ACCESS_ALLOWED_ACE) pAce)->SidStart)) + SidLength)
                ))
        {
            return ERROR_SUCCESS;
        }
    }
    else
    {
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            switch (pExplicitAccess->Trustee.TrusteeForm)
            {
            case TRUSTEE_IS_SID:
                pSid = (PSID) pExplicitAccess->Trustee.ptstrName;
                break;
            case TRUSTEE_IS_NAME:
                pSid = pAccessInfo->pSid;
                break;
            default:
                return ERROR_SUCCESS;
            }

            if (!RtlEqualSid(
                    pSid,
                    (PSID) &(((PKNOWN_ACE) pAce)->SidStart)
                    ))
            {
                return ERROR_SUCCESS;
            }

            break;
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
            return ERROR_SUCCESS;
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:

            switch (pExplicitAccess->Trustee.TrusteeForm)
            {
            case TRUSTEE_IS_OBJECTS_AND_SID:
                pObjSid = (POBJECTS_AND_SID) pExplicitAccess->Trustee.ptstrName;
                ObjectsPresent           = pObjSid->ObjectsPresent;
                pSid                     = pObjSid->pSid;
                pObjectTypeGuid          = &(pObjSid->ObjectTypeGuid);
                pInheritedObjectTypeGuid = &(pObjSid->InheritedObjectTypeGuid);
                break;
            case TRUSTEE_IS_OBJECTS_AND_NAME:
                pObjName = (POBJECTS_AND_NAME_W) pExplicitAccess->Trustee.ptstrName;
                ObjectsPresent           = pObjName->ObjectsPresent;
                pSid                     = pAccessInfo->pSid;
                pObjectTypeGuid          = pAccessInfo->pObjectTypeGuid;
                pInheritedObjectTypeGuid = pAccessInfo->pInheritedObjectTypeGuid;
                break;
            default:
                return ERROR_SUCCESS;
            }

            if (ObjectsPresent != ((PKNOWN_OBJECT_ACE) pAce)->Flags)
            {
                return ERROR_SUCCESS;
            }

            if (!RtlEqualSid(pSid, RtlObjectAceSid(pAce)))
            {
                return ERROR_SUCCESS;
            }

            pGuid = RtlObjectAceObjectType(pAce);

            if (NULL != pGuid)
            {
                if ((NULL == pObjectTypeGuid) ||
                    !RtlpIsEqualGuid(pGuid, pObjectTypeGuid))
                {
                    return ERROR_SUCCESS;
                }
            }

            pGuid = RtlObjectAceInheritedObjectType(pAce);

            if (NULL != pGuid)
            {
                if ((NULL == pInheritedObjectTypeGuid) ||
                    !RtlpIsEqualGuid(pGuid, pInheritedObjectTypeGuid))
                {
                    return ERROR_SUCCESS;
                }
            }

            break;
        }
    }

    AceFlags = (((PACE_HEADER) pAce)->AceFlags) & VALID_INHERIT_FLAGS;

    if (pExplicitAccess->grfInheritance != AceFlags)
    {
        return ERROR_SUCCESS;
    }

    switch (pExplicitAccess->grfAccessMode)
    {
    case REVOKE_ACCESS:
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_ACE_TYPE:
            *pAceMask = 0;
            break;
        default:
            break;
        }
        break;
    case GRANT_ACCESS:
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_ACE_TYPE:
            if (TRUE == bCanonical)
            {
                *pAceMask |= pAccessInfo->Mask;
                pAccessInfo->Size = 0;
            }
            break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
            *pAceMask &= ~pAccessInfo->Mask;
            break;
        default:
            return ERROR_SUCCESS;
        }
        break;
    case DENY_ACCESS:
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // Do not delete existing Allow aces!
            //
            // *pAceMask &= ~pAccessInfo->Mask;
            //

            break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
            if (TRUE == bCanonical)
            {
                *pAceMask |= pAccessInfo->Mask;
                pAccessInfo->Size = 0;
            }
            break;
        default:
            return ERROR_SUCCESS;
        }
        break;
    case SET_ACCESS:
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
            *pAceMask = 0;
            break;
        default:
            return ERROR_SUCCESS;
        }
        break;
    case SET_AUDIT_SUCCESS:
        AuditFlag = SUCCESSFUL_ACCESS_ACE_FLAG;
    case SET_AUDIT_FAILURE:
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            if (!FLAG_ON(((PACE_HEADER) pAce)->AceFlags, AuditFlag))
            {
                return ERROR_SUCCESS;
            }

            *pAceMask |= pAccessInfo->Mask;
            pAccessInfo->Size = 0;
            break;
        default:
            return ERROR_SUCCESS;
        }
    }

    return ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetExplicitAccessEntrySize                                  //
//                                                                            //
// Description: Computes the memory size in bytes for the ace for the         //
//              explicit entry.                                               //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pExplicitAccess]  Explicit entry to convert into an ace            //
//     [IN pAccessInfo]      Temp info associated with the explicit entry     //
//                                                                            //
//     [IN OUT pGuidCnt]     Number of guid-names that have to be convrted    //
//                           to guid structs.                                 //
//                                                                            //
// Returns: ERROR_SUCCESS if the entry could be converted into an ACE         //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetExplicitAccessEntrySize(
    IN  PEXPLICIT_ACCESS_W pExplicitAccess,
    OUT PMARTA_ACCESS_INFO pAccessInfo,
    OUT PULONG             pGuidCnt,
    OUT PUCHAR             pAclRevision
    )
{
    DWORD dwErr          = ERROR_SUCCESS;
    ULONG SidAndGuidSize = 0;

    if (FLAG_ON(pExplicitAccess->grfInheritance, ~VALID_INHERIT_FLAGS))
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch (pExplicitAccess->grfAccessMode)
    {
    case REVOKE_ACCESS:
    case DENY_ACCESS:
    case GRANT_ACCESS:
    case SET_ACCESS:
    case SET_AUDIT_SUCCESS:
    case SET_AUDIT_FAILURE:
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    if (FLAG_ON(pExplicitAccess->grfInheritance, INHERITED_ACE))
    {
        pAccessInfo->Size = 0;
        return ERROR_SUCCESS;
    }

    //
    // For an impersonate trustee, two sids contribute to the size.
    //

    if (TRUSTEE_IS_IMPERSONATE == pExplicitAccess->Trustee.MultipleTrusteeOperation)
    {
        pAccessInfo->Size = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(ULONG);

        dwErr = MartaTrusteeSidAndGuidSize(
                    &(pExplicitAccess->Trustee),
                    FALSE,
                    &(pAccessInfo->pServerSid),
                    &SidAndGuidSize,
                    NULL
                    );

        if (ERROR_SUCCESS != dwErr)
        {
            return dwErr;
        }

        pAccessInfo->Size += SidAndGuidSize;

        if (NULL == pExplicitAccess->Trustee.pMultipleTrustee)
        {
            return ERROR_INVALID_PARAMETER;
        }

        dwErr = MartaTrusteeSidAndGuidSize(
                    pExplicitAccess->Trustee.pMultipleTrustee,
                    FALSE,
                    &(pAccessInfo->pSid),
                    &SidAndGuidSize,
                    NULL
                    );

        if (ERROR_SUCCESS != dwErr)
        {
            return dwErr;
        }

        pAccessInfo->Size += SidAndGuidSize;

        if (*pAclRevision < ACL_REVISION3)
        {
            *pAclRevision = ACL_REVISION3;
        }

        return ERROR_SUCCESS;
    }

    //
    // For any other type of trustee, compute the space required for the SID as
    // well as Guids, if any.
    //

    switch (pExplicitAccess->Trustee.TrusteeForm)
    {
    case TRUSTEE_IS_OBJECTS_AND_SID:
    case TRUSTEE_IS_OBJECTS_AND_NAME:
        pAccessInfo->Size = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(ULONG);
        *pAclRevision     = ACL_REVISION_DS;
        break;
    case TRUSTEE_IS_SID:
    case TRUSTEE_IS_NAME:
        pAccessInfo->Size = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = MartaTrusteeSidAndGuidSize(
                &(pExplicitAccess->Trustee),
                TRUE,
                &(pAccessInfo->pSid),
                &SidAndGuidSize,
                pGuidCnt
                );

    if (ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    if (REVOKE_ACCESS == pExplicitAccess->grfAccessMode)
    {
        pAccessInfo->Size = 0;
    }
    else
    {
        pAccessInfo->Size += SidAndGuidSize;
    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaIsExplicitAclCanonical                                      //
//                                                                            //
// Description: Determines whether the explicit part of the acl is canonical. //
//              Finds the first explicit allow ace.                           //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pAcl]              Acl                                             //
//     [OUT pExplicitAceCnt]  To return the first allow explicit ace          //
//                                                                            //
// Returns: TRUE     if the acl is canonical                                  //
//          FALSE    otherwise                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaIsExplicitAclCanonical(
    IN  PACL   pAcl,
    OUT PULONG pExplicitAceCnt
    )
{
    USHORT      j;
    USHORT      AceCnt;
    PACE_HEADER pAce;

    *pExplicitAceCnt = 0;

    if ((NULL == pAcl) || (0 == pAcl->AceCount))
    {
        return TRUE;
    }

    AceCnt = pAcl->AceCount;

    pAce = (PACE_HEADER) FirstAce(pAcl);
    for (j = 0; j < AceCnt; pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            j++;
            continue;
        }

        if ((ACCESS_ALLOWED_ACE_TYPE == pAce->AceType) ||
            (ACCESS_ALLOWED_OBJECT_ACE_TYPE == pAce->AceType) ||
            (ACCESS_ALLOWED_COMPOUND_ACE_TYPE == pAce->AceType))
        {
            break;
        }

        *pExplicitAceCnt = ++j;
    }

    for (; j < AceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            continue;
        }

        if ((ACCESS_DENIED_ACE_TYPE == pAce->AceType) ||
            (ACCESS_DENIED_OBJECT_ACE_TYPE == pAce->AceType))
        {
            return FALSE;
        }
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaTrusteeSidAndGuidSize                                       //
//                                                                            //
// Description: Compute the size for the Sid(s) and Guid(s) for the trustee.  //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pTrustee]           Trsutee for which the size has to be computed //
//     [IN  bComputeGuidSize]   Whether Guidsize should be computed           //
//                                                                            //
//     [OUT ppSid]              To return the Sid if trustee is "named"       //
//     [OUT pSize]              To return the size computed                   //
//     [OUT pGuidCnt]           To return the number of guids                 //
//                                                                            //
// Returns: ERROR_SUCCESS if Name to Sid resolution passed                    //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaTrusteeSidAndGuidSize(
    IN  PTRUSTEE_W  pTrustee,
    IN  BOOL        bComputeGuidSize,
    OUT PSID      * ppSid,
    OUT PULONG      pSize,
    OUT PULONG      pGuidCnt          OPTIONAL
    )
{
    PSID         pSid    = NULL;
    SID_NAME_USE SidType = SidTypeUnknown;
    DWORD        dwErr   = ERROR_SUCCESS;

    switch (pTrustee->TrusteeForm)
    {
    case TRUSTEE_IS_SID:

        pSid = (PSID) pTrustee->ptstrName;

        if ((NULL == pSid) || (!RtlValidSid(pSid)))
        {
            return ERROR_INVALID_PARAMETER;
        }

        *pSize = RtlLengthSid(pSid);

        break;

    case TRUSTEE_IS_OBJECTS_AND_SID:

        pSid = ((POBJECTS_AND_SID) pTrustee->ptstrName)->pSid;

        if ((NULL == pSid) || (!RtlValidSid(pSid)))
        {
            return ERROR_INVALID_PARAMETER;
        }

        *pSize = RtlLengthSid(pSid);

        if (TRUE == bComputeGuidSize)
        {
            if (FLAG_ON(((POBJECTS_AND_SID) pTrustee->ptstrName)->ObjectsPresent,
                        ACE_OBJECT_TYPE_PRESENT))
            {
                *pSize += sizeof(GUID);
            }

            if (FLAG_ON(((POBJECTS_AND_SID) pTrustee->ptstrName)->ObjectsPresent,
                        ACE_INHERITED_OBJECT_TYPE_PRESENT))
            {
                *pSize += sizeof(GUID);
            }
        }

        break;

    case TRUSTEE_IS_NAME:

        dwErr = MartaGetSidFromName(pTrustee->ptstrName, ppSid);

        CONDITIONAL_RETURN(dwErr);

        *pSize = RtlLengthSid(*ppSid);

        break;

    case TRUSTEE_IS_OBJECTS_AND_NAME:

        dwErr = MartaGetSidFromName(
                    ((POBJECTS_AND_NAME_W) pTrustee->ptstrName)->ptstrName,
                    ppSid
                    );

        CONDITIONAL_RETURN(dwErr);

        *pSize = RtlLengthSid(*ppSid);

        if (TRUE == bComputeGuidSize)
        {
            if (FLAG_ON(((POBJECTS_AND_NAME_W) pTrustee->ptstrName)->ObjectsPresent,
                        ACE_OBJECT_TYPE_PRESENT))
            {
                *pSize += sizeof(GUID);
                (*pGuidCnt)++;
            }

            if (FLAG_ON(((POBJECTS_AND_NAME_W) pTrustee->ptstrName)->ObjectsPresent,
                        ACE_INHERITED_OBJECT_TYPE_PRESENT))
            {
                *pSize += sizeof(GUID);
                (*pGuidCnt)++;
            }
        }

        break;

    default:
        return ERROR_NONE_MAPPED;

    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetSidFromName                                              //
//                                                                            //
// Description: Resolves a given Name to Sid.                                 //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pName]              Name to be resolved                           //
//     [OUT ppSid]              To return the Sid for the trustee             //
//                                                                            //
// Returns: ERROR_SUCCESS if Name to Sid resolution passed                    //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetSidFromName(
    IN  LPWSTR   pName,
    OUT PSID   * ppSid
    )
{

#define MARTA_DEFAULT_SID_SIZE    64
#define MARTA_DEFAULT_DOMAIN_SIZE 256

    WCHAR        DomainBuffer[MARTA_DEFAULT_DOMAIN_SIZE];
    ULONG        SidSize    = MARTA_DEFAULT_SID_SIZE;
    ULONG        DomainSize = MARTA_DEFAULT_DOMAIN_SIZE;
    LPWSTR       Domain     = (LPWSTR) DomainBuffer;
    SID_NAME_USE SidNameUse = SidTypeUnknown;
    DWORD        dwErr      = ERROR_SUCCESS;

    if (NULL == ppSid)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(0 == _wcsicmp(pName, L"CURRENT_USER"))
    {
        HANDLE TokenHandle;

        dwErr = GetCurrentToken(&TokenHandle);

        if(dwErr != ERROR_SUCCESS)
        {
            return dwErr;
        }

        dwErr = AccGetSidFromToken(
                    NULL,
                    TokenHandle,
                    TokenUser,
                    ppSid
                    );

        CloseHandle(TokenHandle);

        return dwErr;
    }

    *ppSid = (PSID) AccAlloc(SidSize);

    if(NULL == *ppSid)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if(!LookupAccountName(
            NULL,
            pName,
            *ppSid,
            &SidSize,
            Domain,
            &DomainSize,
            &SidNameUse))
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            dwErr = ERROR_SUCCESS;

            if (SidSize > MARTA_DEFAULT_SID_SIZE)
            {
                AccFree(*ppSid);

                *ppSid = (PSID) AccAlloc(SidSize);

                if (*ppSid == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto End;
                }
            }

            if(DomainSize > MARTA_DEFAULT_DOMAIN_SIZE)
            {
                Domain = (LPWSTR) AccAlloc(DomainSize * sizeof(WCHAR));

                if (NULL == Domain)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto End;
                }

                if(!LookupAccountName(
                        NULL,
                        pName,
                        *ppSid,
                        &SidSize,
                        Domain,
                        &DomainSize,
                        &SidNameUse))
                {
                    dwErr = GetLastError();
                    goto End;
                }
            }
        }
    }

End:

    if (Domain != (LPWSTR) DomainBuffer)
    {
        AccFree(Domain);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        if (NULL != *ppSid)
        {
            AccFree(*ppSid);
            *ppSid = NULL;
        }
    }
    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetGuid                                                     //
//                                                                            //
// Description: Resolves a given Guid Name to a Guid struct.                  //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pObjectName]        Name to be resolved                           //
//     [IN  ObjectType]         Object type of the name to be resolved        //
//     [OUT pGuid]              To return the guid                            //
//                                                                            //
// Returns: ERROR_SUCCESS if Name to guid resolution passed                   //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetGuid(
    IN  LPWSTR           pObjectName,
    IN  SE_OBJECT_TYPE   ObjectType,
    OUT GUID           * pGuid
    )
{
    switch (ObjectType)
    {
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    return MartaConvertNameToGuid[ObjectType](
               pObjectName,
               pGuid
               );
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteSetEntriesInAcl                                        //
//                                                                            //
// Description: Resolves a given Name to Sid.                                 //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  cCountOfExplicitEntries]  Number of items in list                 //
//     [IN  pListOfExplicitEntries]   List of entries to be added             //
//     [IN  OldAcl]                   The old acl to add the entries to       //
//     [OUT pNewAcl]                  To return the new acl                   //
//                                                                            //
// Returns: ERROR_SUCCESS if everything passed                                //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
AccRewriteSetEntriesInAcl(
    IN  ULONG                cCountOfExplicitEntries,
    IN  PEXPLICIT_ACCESS_W   pListOfExplicitEntries,
    IN  PACL                 OldAcl,
    OUT PACL               * pNewAcl
    )

{
    PMARTA_ACCESS_INFO    pAccessInfo    = NULL;
    PACCESS_MASK          pAceMaskInfo   = NULL;
    PACE_HEADER           pAce           = NULL;
    GUID                * pGuid          = NULL;
    GUID                * pCurrentGuid   = NULL;
    POBJECTS_AND_NAME_W   pObjName       = NULL;
    PUCHAR                pAcl           = NULL;
    USHORT                OldAceCnt      = 0;
    USHORT                NewAceCnt      = 0;
    ULONG                 ExplicitAceCnt = 0;
    ULONG                 NewAclSize     = sizeof(ACL);
    BOOL                  bCanonical     = TRUE;
    DWORD                 dwErr          = ERROR_SUCCESS;
    ULONG                 i              = 0;
    ULONG                 j              = 0;
    ULONG                 GuidCnt        = 0;
    ULONG                 ObjectsPresent = 0;
    UCHAR                 AclRevision    = ACL_REVISION;

    if ((NULL == pNewAcl) || ((NULL != OldAcl) && (!RtlValidAcl(OldAcl))))

    {
        return ERROR_INVALID_PARAMETER;
    }

    *pNewAcl = NULL;

    //
    // If the number of entries to be added is zero then make a copy of the Old
    // Acl as it is. Do not try to convert it into Canonical form if it's not.
    //

    if (0 == cCountOfExplicitEntries)
    {
        if (NULL != OldAcl)
        {
            *pNewAcl = (PACL) AccAlloc(OldAcl->AclSize);

            if (NULL == *pNewAcl)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            memcpy((PUCHAR) *pNewAcl, (PUCHAR) OldAcl, OldAcl->AclSize);
        }
        return ERROR_SUCCESS;
    }

    //
    // Canonical acls processing will be done as in the past.
    // Note: We now support non-canonical acls as well..
    //

    bCanonical = MartaIsExplicitAclCanonical(OldAcl, &ExplicitAceCnt);

    //
    // The Mask for all the aces is stored in a pAceMaskInfo and modified as
    // dictated by the ExplicitAccess entries.
    //

    if (NULL != OldAcl)
    {
        OldAceCnt  = OldAcl->AceCount;
        NewAclSize = OldAcl->AclSize;
        NewAceCnt  = OldAceCnt;

        pAceMaskInfo = (PACCESS_MASK) AccAlloc(sizeof(ACCESS_MASK) * OldAceCnt);

        if (NULL == pAceMaskInfo)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto End;
        }

        AclRevision = OldAcl->AclRevision;
    }

    //
    // Note: cCountOfExplicitEntries is non-zero at this point.
    //

    pAccessInfo = (PMARTA_ACCESS_INFO) AccAlloc(sizeof(MARTA_ACCESS_INFO) * cCountOfExplicitEntries);

    if (NULL == pAccessInfo)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    //
    // Initialize the temp structures for the acl and the explicit entries.
    //

    pAce = (PACE_HEADER) FirstAce(OldAcl);

    for (j = 0; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        pAceMaskInfo[j] = ((PKNOWN_ACE) pAce)->Mask;
    }

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        pAccessInfo[i].pServerSid               = NULL;
        pAccessInfo[i].pSid                     = NULL;
        pAccessInfo[i].pObjectTypeGuid          = NULL;
        pAccessInfo[i].pInheritedObjectTypeGuid = NULL;
        pAccessInfo[i].Mask = pListOfExplicitEntries[i].grfAccessPermissions;
    }

    //
    // Compute the size required to add this explicit entry to the acl.
    //

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        dwErr = MartaGetExplicitAccessEntrySize(
                    pListOfExplicitEntries + i,
                    pAccessInfo + i,
                    &GuidCnt,
                    &AclRevision
                    );

        CONDITIONAL_EXIT(dwErr, End);
    }

    //
    // For TRUSTEE_IS_OBJECTS_AND_NAME, resolve the GuidNames to Guids and store
    // them in the temp structure.
    //

    if (0 != GuidCnt)
    {
        pGuid = pCurrentGuid = (GUID *) AccAlloc(sizeof(GUID) * GuidCnt);

        if (NULL == pGuid)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto End;
        }

        for (i = 0; i < cCountOfExplicitEntries; i++)
        {
            pObjName = (POBJECTS_AND_NAME_W) pListOfExplicitEntries[i].Trustee.ptstrName;
            ObjectsPresent = pObjName->ObjectsPresent;

            if (FLAG_ON(ObjectsPresent, ACE_OBJECT_TYPE_PRESENT))
            {
                dwErr = MartaGetGuid(
                            pObjName->ObjectTypeName,
                            pObjName->ObjectType,
                            pCurrentGuid
                            );

                CONDITIONAL_EXIT(dwErr, End);

                pAccessInfo[i].pObjectTypeGuid = pCurrentGuid++;
            }

            if (FLAG_ON(ObjectsPresent, ACE_INHERITED_OBJECT_TYPE_PRESENT))
            {
                dwErr = MartaGetGuid(
                            pObjName->InheritedObjectTypeName,
                            pObjName->ObjectType,
                            pCurrentGuid
                            );

                CONDITIONAL_EXIT(dwErr, End);

                pAccessInfo[i].pInheritedObjectTypeGuid = pCurrentGuid++;
            }
        }
    }

    //
    // Compute the effect of explict entries added on the exisiting acl.
    // The size of an explicit entry will be set to zero if the entry will be
    // absorbed by some existing ace.
    // The Mask for an ace will be set to zero if the AceMask flags have been
    // nulled out by explicit entries.
    //

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        pAce = (PACE_HEADER) FirstAce(OldAcl);

        for (j = 0; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
        {
            dwErr = MartaCompareAcesAndMarkMasks(
                        (PUCHAR) pAce,
                        pAceMaskInfo + j,
                        pListOfExplicitEntries + i,
                        pAccessInfo + i,
                        bCanonical
                        );
            CONDITIONAL_EXIT(dwErr, End);
        }
    }

    //
    // Compute the size required for the new acl and the number of aces in it.
    //

    pAce = (PACE_HEADER) FirstAce(OldAcl);

    for (j = 0; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (0 == pAceMaskInfo[j])
        {
            NewAclSize -= pAce->AceSize;
            NewAceCnt--;
        }
    }

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        if (0 != pAccessInfo[i].Size)
        {
            NewAclSize += pAccessInfo[i].Size;
            NewAceCnt++;
        }
    }

    *pNewAcl = (PACL) AccAlloc(NewAclSize);

    if (NULL == *pNewAcl)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    if (FALSE == InitializeAcl(*pNewAcl, NewAclSize, AclRevision))
    {
        dwErr = GetLastError();
        goto End;
    }

    (*pNewAcl)->AceCount = NewAceCnt;

    pAcl = ((PUCHAR) *pNewAcl) + sizeof(ACL);

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        //
        // Add all the DENY ACES to the ACL.
        //

        switch (pListOfExplicitEntries[i].grfAccessMode)
        {
        case DENY_ACCESS:
        case SET_AUDIT_SUCCESS:
        case SET_AUDIT_FAILURE:
            dwErr = MartaAddExplicitEntryToAcl(
                        &pAcl,
                        pListOfExplicitEntries + i,
                        pAccessInfo + i
                        );
            CONDITIONAL_EXIT(dwErr, End);
            break;
        default:
            break;
        }
    }

    //
    // Copy the explicit aces from the OldAcl that have not been invalidated by
    // the new Aces added.
    // Inherited aces will be copied afterthe explict ones have been copied.
    //

    pAce = (PACE_HEADER) FirstAce(OldAcl);

    for (j = 0; j < ExplicitAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            continue;
        }

        if (0 != pAceMaskInfo[j])
        {
            memcpy((PUCHAR) pAcl, (PUCHAR) pAce, pAce->AceSize);

            ((PKNOWN_ACE) pAcl)->Mask = pAceMaskInfo[j];
            pAcl += pAce->AceSize;
        }
    }

    //
    // Add all the NON-DENY ACES to the ACL.
    // DENY aces have already been added.
    //
    // If the ACL was canonical then follow the old behavior i.e. add the
    // remaining explicit entries to the beginning of the "allowed" acl.
    // Otherwise, add the ACEs to the end of the explicit part of the ACL.
    //

    if (FALSE == bCanonical)
    {
        for (; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
        {
            if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
            {
                continue;
            }

            if (0 != pAceMaskInfo[j])
            {
                memcpy((PUCHAR) pAcl, (PUCHAR) pAce, pAce->AceSize);

                ((PKNOWN_ACE) pAcl)->Mask = pAceMaskInfo[j];
                pAcl += pAce->AceSize;
            }
        }

        for (i = 0; i < cCountOfExplicitEntries; i++)
        {
            switch (pListOfExplicitEntries[i].grfAccessMode)
            {
            case GRANT_ACCESS:
            case SET_ACCESS:
                dwErr = MartaAddExplicitEntryToAcl(
                            &pAcl,
                            pListOfExplicitEntries + i,
                            pAccessInfo + i
                            );
                CONDITIONAL_EXIT(dwErr, End);
                break;
            default:
                break;
            }
        }
    }
    else
    {
        for (i = 0; i < cCountOfExplicitEntries; i++)
        {
            switch (pListOfExplicitEntries[i].grfAccessMode)
            {
            case GRANT_ACCESS:
            case SET_ACCESS:
                dwErr = MartaAddExplicitEntryToAcl(
                            &pAcl,
                            pListOfExplicitEntries + i,
                            pAccessInfo + i
                            );
                CONDITIONAL_EXIT(dwErr, End);
                break;
            default:
                break;
            }
        }

        for (; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
        {
            if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
            {
                continue;
            }

            if (0 != pAceMaskInfo[j])
            {
                memcpy((PUCHAR) pAcl, (PUCHAR) pAce, pAce->AceSize);

                ((PKNOWN_ACE) pAcl)->Mask = pAceMaskInfo[j];
                pAcl += pAce->AceSize;
            }
        }
    }

    //
    // Add the inherited aces to the new ACL. This will reorder the ACEs so that
    // the EXPLICIT ACEs precede the INHERITED ONES but will not arrange the ACL
    // in canonical form if it was not to start with.
    //

    pAce = (PACE_HEADER) FirstAce(OldAcl);

    for (j = 0; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            memcpy((PUCHAR) pAcl, (PUCHAR) pAce, pAce->AceSize);

            pAcl += pAce->AceSize;
        }
    }

End:
    if (NULL != pAccessInfo)
    {
        for (i = 0; i < cCountOfExplicitEntries; i++ )
        {
            if (NULL != pAccessInfo[i].pServerSid)
            {
                AccFree(pAccessInfo[i].pServerSid);
            }

            if (NULL != pAccessInfo[i].pSid)
            {
                AccFree(pAccessInfo[i].pSid);
            }
        }
        AccFree(pAccessInfo);
    }

    if (NULL != pGuid)
    {
        AccFree(pGuid);
    }

    if (NULL != pAceMaskInfo)
    {
        AccFree(pAceMaskInfo);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        if (NULL != *pNewAcl)
        {
            AccFree(*pNewAcl);
            *pNewAcl = NULL;
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\sidcache.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:        sidcache.cxx
//
//  Contents:    Implementation of the sid/name lookup cache
//
//  History:     2-Feb-97       MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//
// Global name/sid cache
//
PACTRL_NAME_CACHE    grgNameCache[ACTRL_NAME_TABLE_SIZE];
PACTRL_NAME_CACHE    grgSidCache[ACTRL_NAME_TABLE_SIZE];

//
// Local function prototypes
//
PACTRL_NAME_CACHE AccctrlpLookupNameInCache(PWSTR   pwszName);

PACTRL_NAME_CACHE AccctrlpLookupSidInCache(PSID     pSid);

DWORD   AccctrlpNewNameSidNode(PWSTR                pwszName,
                               PSID                 pSid,
                               SID_NAME_USE         SidNameUse,
                               PACTRL_NAME_CACHE   *ppNewNode);

VOID    AccctrlpInsertNameNode(PACTRL_NAME_CACHE *ppRootNode,
                               PACTRL_NAME_CACHE  pNewNode);

VOID    AccctrlpInsertSidNode(PACTRL_NAME_CACHE *ppRootNode,
                              PACTRL_NAME_CACHE  pNewNode);

DWORD   AccctrlpConvertUserToCacheName(PWSTR      pwszServer,
                                       PWSTR      pwszName,
                                       PWSTR     *ppwszCacheName);

VOID    AccctrlpFreeUserCacheName(PWSTR      pwszName,
                                  PWSTR      pwszCacheName);

static RTL_RESOURCE gSidCacheLock;
BOOL bSidCacheLockInitialized = FALSE;

//+----------------------------------------------------------------------------
//
//  Function:   ActrlHashName
//
//  Synopsis:   Determines the hash index for the given name
//
//  Arguments:  pwszName        --      Name to hash
//
//  Returns:    Hash index of the string
//
//-----------------------------------------------------------------------------
INT
ActrlHashName(PWSTR pwszName)
{
    //
    // We'll hash off of just the user name, not the domain name or
    // any other name format
    //
    PWSTR   pwszUser = wcschr(pwszName, L'\\');
    if(pwszUser == NULL)
    {
        pwszUser = pwszName;
    }
    else
    {
        pwszUser++;
    }

    INT Hash = 0;
    if(pwszUser != NULL)
    {
        while(*pwszUser != L'\0')
        {
            Hash = (Hash * 16 + ( *pwszUser++)) % ACTRL_NAME_TABLE_SIZE;
        }
    }

    acDebugOut((DEB_TRACE_LOOKUP,"Hashing %ws to %lu\n", pwszName, Hash));

    return(Hash);
}




//+----------------------------------------------------------------------------
//
//  Function:   ActrlHashSid
//
//  Synopsis:   Determines the hash index for the given sid
//
//  Arguments:  pSid            --      Sid to hash
//
//  Returns:    Hash index of the Sid
//
//-----------------------------------------------------------------------------
INT
ActrlHashSid(PSID   pSid)
{
    DWORD   dwTotal = 0;

    //
    // Just deal with the sub authorities
    //
    for(INT i = 0; i < (INT)(((PISID)pSid)->SubAuthorityCount); i++)
    {
        dwTotal += ((PISID)pSid)->SubAuthority[i];
    }

#if DBG

    UNICODE_STRING SidString;

    memset(&SidString, 0, sizeof(UNICODE_STRING));

    if(pSid != NULL)
    {
        NTSTATUS Status = RtlConvertSidToUnicodeString(&SidString,
                                                       pSid,
                                                       TRUE);
        if(!NT_SUCCESS(Status))
        {
            acDebugOut((DEB_ERROR, "Can't convert sid to string: 0x%lx\n", Status));
        }
        else
        {
            acDebugOut((DEB_TRACE_LOOKUP,"Hashing %wZ (Total %lu) to %lu\n", &SidString,
                       dwTotal, dwTotal % ACTRL_NAME_TABLE_SIZE));
        }
    }


#endif
    return(dwTotal % ACTRL_NAME_TABLE_SIZE);
}





//+----------------------------------------------------------------------------
//
//  Function:   AccctrlInitializeSidNameCache
//
//  Synopsis:   Initialize the name/sid lookup cache
//
//  Arguments:  VOID
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD AccctrlInitializeSidNameCache(VOID)
{
    DWORD dwErr;

    if (TRUE == bSidCacheLockInitialized)
    {
        //
        // Just a precautionary measure to make sure that we do not initialize
        // multiple times.
        //

        ASSERT(FALSE);
        return ERROR_SUCCESS;
    }

    memset(grgNameCache, 0, sizeof(PACTRL_NAME_CACHE) * ACTRL_NAME_TABLE_SIZE);
    memset(grgSidCache, 0, sizeof(PACTRL_NAME_CACHE) * ACTRL_NAME_TABLE_SIZE);

    __try
    {
        RtlInitializeResource(&gSidCacheLock);
        dwErr = ERROR_SUCCESS;
        bSidCacheLockInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RtlNtStatusToDosError(GetExceptionCode());
    }

    return dwErr;
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlFreeSidNameCache
//
//  Synopsis:   Frees any memory allocated for the name/sid cache
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID AccctrlFreeSidNameCache(VOID)
{
    INT i;
    PACTRL_NAME_CACHE   pNode, pNext;

    if (FALSE == bSidCacheLockInitialized)
    {
        return;
    }

    for(i = 0; i < ACTRL_NAME_TABLE_SIZE; i++)
    {
        //
        // Nodes are only inserted into the name cache, so that is the only
        // place we delete them from
        //
        pNode = grgNameCache[i];
        while(pNode != NULL)
        {
            pNext = pNode->pNextName;
            AccFree(pNode->pwszName);
            AccFree(pNode->pSid);
            AccFree(pNode);
            pNode = pNext;
        }
    }

    RtlDeleteResource(&gSidCacheLock);

    bSidCacheLockInitialized = FALSE;

}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLookupNameInCache
//
//  Synopsis:   Determines if the given name exists in the cache or not
//
//  Arguments:  [pwszName]      --      Name to be looked up
//
//  Returns:    Matching node if found, NULL if not
//
//-----------------------------------------------------------------------------
PACTRL_NAME_CACHE AccctrlpLookupNameInCache(PWSTR   pwszName)
{
    PACTRL_NAME_CACHE   pNode = NULL;

    pNode =  grgNameCache[ActrlHashName(pwszName)];

    while(pNode != NULL)
    {
        if(_wcsicmp(pwszName, pNode->pwszName) == 0)
        {
            break;
        }
        pNode = pNode->pNextName;
    }

    return(pNode);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLookupSidInCache
//
//  Synopsis:   Determines if the given sid exists in the cache or not
//
//  Arguments:  [pSid]          --      Sid to be looked up
//
//  Returns:    Matching node if found, NULL if not
//
//-----------------------------------------------------------------------------
PACTRL_NAME_CACHE AccctrlpLookupSidInCache(PSID     pSid)
{
    PACTRL_NAME_CACHE   pNode = grgSidCache[ActrlHashSid(pSid)];

    while(pNode != NULL)
    {
        if(RtlEqualSid(pSid, pNode->pSid) == TRUE)
        {
            break;
        }
        pNode = pNode->pNextSid;
    }

    return(pNode);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpNewNameSidNode
//
//  Synopsis:   Allocates a new node and inserts them into the caches
//
//  Arguments:  [pwszName]      --      Name to insert
//              [pSid]          --      Sid to insert
//              [SidNameUse]    --      Name use
//              [pNewNode]      --      Newly added node
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//-----------------------------------------------------------------------------
DWORD   AccctrlpNewNameSidNode(PWSTR                pwszName,
                               PSID                 pSid,
                               SID_NAME_USE         SidNameUse,
                               PACTRL_NAME_CACHE   *ppNewNode)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACTRL_NAME_CACHE   pNewNode = (PACTRL_NAME_CACHE)AccAlloc(
                                                    sizeof(ACTRL_NAME_CACHE));
    if(pNewNode == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pNewNode->pwszName = pwszName;
        pNewNode->pSid     = pSid;
        pNewNode->SidUse   = SidNameUse;
        pNewNode->pNextName= NULL;
        pNewNode->pNextSid = NULL;

        AccctrlpInsertNameNode(&(grgNameCache[ActrlHashName(pwszName)]),
                               pNewNode);

        AccctrlpInsertSidNode(&(grgSidCache[ActrlHashSid(pSid)]),
                              pNewNode);

        *ppNewNode = pNewNode;

    }
    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertNameNode
//
//  Synopsis:   Inserts the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to insert
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID    AccctrlpInsertNameNode(PACTRL_NAME_CACHE *ppRootNode,
                               PACTRL_NAME_CACHE  pNewNode)
{
    PACTRL_NAME_CACHE   pNext = NULL;

    if(*ppRootNode == NULL)
    {
        *ppRootNode = pNewNode;
    }
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Collision inserting %ws with:\n", pNewNode->pwszName));

        pNext = *ppRootNode;
        acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        while(pNext->pNextName != NULL)
        {
#if DBG
            if(_wcsicmp(pNewNode->pwszName, pNext->pwszName) == 0)
            {
                acDebugOut((DEB_ERROR, "Name %ws already in list: 0x%lx\n",
                            pNewNode->pwszName,
                            *ppRootNode));
//                ASSERT(FALSE);
            }
#endif

            pNext = pNext->pNextName;
            acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        }
        pNext->pNextName = pNewNode;
    }
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertSidNode
//
//  Synopsis:   Inserts the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to insert
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID    AccctrlpInsertSidNode(PACTRL_NAME_CACHE *ppRootNode,
                              PACTRL_NAME_CACHE  pNewNode)
{
    PACTRL_NAME_CACHE   pNext = NULL;

    if(*ppRootNode == NULL)
    {
        *ppRootNode = pNewNode;
    }
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Collision inserting %ws with:\n", pNewNode->pwszName));

        pNext = *ppRootNode;
        acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        while(pNext->pNextSid != NULL)
        {
#if DBG
            if(RtlEqualSid(pNewNode->pSid, pNext->pSid) == TRUE)
            {
                acDebugOut((DEB_ERROR, "Sid for %ws already in list: 0x%lx\n",
                            pNewNode->pwszName,
                            *ppRootNode));
//                ASSERT(FALSE);
            }
#endif

            pNext = pNext->pNextSid;

            acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        }
        pNext->pNextSid = pNewNode;
    }
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupName
//
//  Synopsis:   Looks up the name for the specified SID
//
//  Arguments:  [pwszServer]    --      Name of the server to remote the call to
//              [pSid]          --      Sid to lookup
//              [fAllocateReturn]-      If true, the name returned is allocated
//                                      into a new buffer.  Otherwise, a
//                                      reference is returned.
//              [ppwszName]     --      Where the name is returned.
//              [pSidNameUse]   --      Type of the name that's returned.
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupName(IN  PWSTR          pwszServer,
                  IN  PSID           pSid,
                  IN  BOOL           fAllocateReturn,
                  OUT PWSTR         *ppwszName,
                  OUT PSID_NAME_USE  pSidNameUse)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pSid == NULL)
    {
        return(ERROR_NONE_MAPPED);
    }

    RtlAcquireResourceShared(&gSidCacheLock, TRUE);

#if DBG
    UNICODE_STRING SidString;

    memset(&SidString, 0, sizeof(UNICODE_STRING));

    if(pSid != NULL)
    {
        NTSTATUS Status = RtlConvertSidToUnicodeString(&SidString,
                                                       pSid,
                                                       TRUE);
        if(!NT_SUCCESS(Status))
        {
            acDebugOut((DEB_ERROR, "Can't convert sid to string: 0x%lx\n", Status));
        }
    }
#endif

    //
    // First, see if the sid alreadt exists in our cache
    //
    PACTRL_NAME_CACHE pNode = AccctrlpLookupSidInCache(pSid);
    if(pNode == NULL)
    {
#if DBG
        acDebugOut((DEB_TRACE_LOOKUP, "Sid %wZ not found in cache\n", &SidString));
#endif
        //
        // Grab a write lock
        //
        RtlConvertSharedToExclusive(&gSidCacheLock);


        //
        // We'll have to look it up...
        //
        PWSTR   pwszName, pwszDomain;
        dwErr = AccLookupAccountName(pwszServer,
                                     pSid,
                                     &pwszName,
                                     &pwszDomain,
                                     pSidNameUse);
        if(dwErr == ERROR_SUCCESS)
        {
            PSID    pNewSid = NULL;
            ACC_ALLOC_AND_COPY_SID(pSid, pNewSid, dwErr);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccctrlpNewNameSidNode(pwszName,
                                               pNewSid,
                                               *pSidNameUse,
                                               &pNode);
            }

            if(dwErr != ERROR_SUCCESS)
            {
                AccFree(pwszName);
                AccFree(pwszDomain);
                AccFree(pNewSid);
            }
        }
    }
#if DBG
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Sid %wZ found in cache\n", &SidString));
    }
#endif

    //
    // Finally, return the information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        if(fAllocateReturn == TRUE)
        {
            ACC_ALLOC_AND_COPY_STRINGW(pNode->pwszName, *ppwszName, dwErr);
        }
        else
        {
            *ppwszName = pNode->pwszName;
        }

        *pSidNameUse = pNode->SidUse;
    }

    RtlReleaseResource(&gSidCacheLock);

    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupSid
//
//  Synopsis:   Looks up the SID for the specified name
//
//  Arguments:  [pwszServer]    --      Name of the server to remote the call to
//              [pwszName]      --      Name to lookup
//              [fAllocateReturn]-      If true, the name returned is allocated
//                                      into a new buffer.  Otherwise, a
//                                      reference is returned.
//              [ppwszName]     --      Where the name is returned.
//              [pSidNameUse]   --      Type of the sid that's returned.
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupSid(IN  PWSTR          pwszServer,
                 IN  PWSTR          pwszName,
                 IN  BOOL           fAllocateReturn,
                 OUT PSID          *ppSid,
                 OUT PSID_NAME_USE  pSidNameUse)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PWSTR   pwszLookupName = pwszName;

    RtlAcquireResourceShared(&gSidCacheLock, TRUE);

    //
    // If we get a local name, convert it into machine/domain relative, so we can
    // look it up properly.
    //
    dwErr = AccctrlpConvertUserToCacheName(pwszServer, pwszName, &pwszLookupName);

    //
    // Just return if the conversion failed.
    //

    if (pwszLookupName == NULL)
    {
        if (dwErr == ERROR_SUCCESS)
        {
            dwErr = ERROR_ACCESS_DENIED;
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, see if the sid already exists in our cache
        //
        PACTRL_NAME_CACHE pNode = AccctrlpLookupNameInCache(pwszLookupName);
        if(pNode == NULL)
        {
            //
            // Grab a write lock
            //
            RtlConvertSharedToExclusive(&gSidCacheLock);

            acDebugOut((DEB_TRACE_LOOKUP,"Name %ws not found in cache\n", pwszLookupName));
            //
            // We'll have to look it up...
            //
            TRUSTEE_W   Trustee;
            memset(&Trustee, 0, sizeof(TRUSTEE_W));
            Trustee.TrusteeForm = TRUSTEE_IS_NAME;
            Trustee.ptstrName = pwszLookupName;

            dwErr = AccLookupAccountSid(pwszServer,
                                        &Trustee,
                                        ppSid,
                                        pSidNameUse);
            if(dwErr == ERROR_SUCCESS)
            {
                PWSTR   pwszNewName = NULL;
                ACC_ALLOC_AND_COPY_STRINGW(pwszLookupName, pwszNewName, dwErr);
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AccctrlpNewNameSidNode(pwszNewName,
                                                   *ppSid,
                                                   *pSidNameUse,
                                                   &pNode);
                }

                if(dwErr != ERROR_SUCCESS)
                {
                    AccFree(pwszNewName);
                    AccFree(*ppSid);
                }
            }
        }
    #if DBG
        else
        {
            acDebugOut((DEB_TRACE_LOOKUP,"Name %ws found in cache\n", pwszLookupName));
        }
    #endif

        //
        // Finally, return the information
        //
        if(dwErr == ERROR_SUCCESS)
        {
            if(fAllocateReturn == TRUE)
            {
                ACC_ALLOC_AND_COPY_SID(pNode->pSid, *ppSid, dwErr);
            }
            else
            {
                *ppSid = pNode->pSid;
            }

            *pSidNameUse = pNode->SidUse;
        }

        AccctrlpFreeUserCacheName(pwszName, pwszLookupName);
    }

    RtlReleaseResource(&gSidCacheLock);


    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpConvertUserToCacheName
//
//  Synopsis:   Converts an input name that could be domain relative into a
//              standard format for caching/returning
//
//  Arguments:  [pwszServer]    --      Server to lookup the name on
//              [pwszName]      --      Original name format
//              [ppwszCacheName]--      Name in the proper format
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//-----------------------------------------------------------------------------
DWORD   AccctrlpConvertUserToCacheName(PWSTR      pwszServer,
                                       PWSTR      pwszName,
                                       PWSTR     *ppwszCacheName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // This is temporary until the name conversion APIs come into being
    //
    PSID    pSid;
    SID_NAME_USE    SNE;
    TRUSTEE_W   Trustee;
    memset(&Trustee, 0, sizeof(TRUSTEE_W));
    Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    Trustee.ptstrName = pwszName;

    dwErr = AccLookupAccountSid(pwszServer,
                                &Trustee,
                                &pSid,
                                &SNE);
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszDomain;
        dwErr = AccLookupAccountName(pwszServer,
                                     pSid,
                                     ppwszCacheName,
                                     &pwszDomain,
                                     &SNE);
        if(dwErr == ERROR_SUCCESS)
        {
            AccFree(pwszDomain);
        }

        AccFree(pSid);
    }


    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpFreeUserCacheName
//
//  Synopsis:   Frees any memory potentially allocated by
//              AccctrlpConvertUserToCacheName
//
//  Arguments:  [pwszName]      --      Original name format
//              [pwszCacheName] --      Name returned by
//                                      AccctrlpConvertUserToCacheName
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID    AccctrlpFreeUserCacheName(PWSTR      pwszName,
                                  PWSTR      pwszCacheName)
{
    if(pwszName != pwszCacheName)
    {
        AccFree(pwszCacheName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\ntmarta\newsrc\rewrite.cxx ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Microsoft Windows                                                         //
//  Copyright (C) Microsoft Corporation, 1999.                                //
//                                                                            //
//  File:    rewrite.cxx                                                      //
//                                                                            //
//  Contents:    New marta rewrite functions.                                 //
//                                                                            //
//  History:    4/99    KedarD     Created                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <stdio.h>
    #include <permit.h>
    #include <dsgetdc.h>
    #include <lmapibuf.h>
    #include <wmistr.h>
    #include <ntprov.hxx>
    #include <strings.h>
    #include <seopaque.h>
    #include <sertlp.h>
    #include <tables.h>

}

#define MARTA_DEBUG_NO 0

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// STRUCTURES DEFINITIONS TO HOLD FUNCTION POINTERS START HERE                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

typedef struct _MARTA_GET_FUNCTION_CONTEXT {
    FN_ADD_REF_CONTEXT     fAddRefContext;
    FN_CLOSE_CONTEXT       fCloseContext;
    FN_GET_DESIRED_ACCESS  fGetDesiredAccess;
    FN_GET_PARENT_CONTEXT  fGetParentContext;
    FN_GET_PROPERTIES      fGetProperties;
    FN_GET_TYPE_PROPERTIES fGetTypeProperties;
    FN_OPEN_NAMED_OBJECT   fOpenNamedObject;
    FN_OPEN_HANDLE_OBJECT  fOpenHandleObject;
    FN_GET_RIGHTS          fGetRights;
} MARTA_GET_FUNCTION_CONTEXT, *PMARTA_GET_FUNCTION_CONTEXT;

typedef struct _MARTA_SET_FUNCTION_CONTEXT {
    FN_ADD_REF_CONTEXT       fAddRefContext;
    FN_CLOSE_CONTEXT         fCloseContext;
    FN_FIND_FIRST            fFindFirst;
    FN_FIND_NEXT             fFindNext;
    FN_GET_DESIRED_ACCESS    fGetDesiredAccess;
    FN_GET_PARENT_CONTEXT    fGetParentContext;
    FN_GET_PROPERTIES        fGetProperties;
    FN_GET_TYPE_PROPERTIES   fGetTypeProperties;
    FN_GET_RIGHTS            fGetRights;
    FN_OPEN_NAMED_OBJECT     fOpenNamedObject;
    FN_OPEN_HANDLE_OBJECT    fOpenHandleObject;
    FN_SET_RIGHTS            fSetRights;
    FN_REOPEN_CONTEXT        fReopenContext;
    FN_REOPEN_ORIG_CONTEXT   fReopenOrigContext;
    FN_GET_NAME_FROM_CONTEXT fGetNameFromContext;
} MARTA_SET_FUNCTION_CONTEXT, *PMARTA_SET_FUNCTION_CONTEXT;

typedef struct _MARTA_INDEX_FUNCTION_CONTEXT {
    FN_OPEN_NAMED_OBJECT  fOpenNamedObject;
    FN_CLOSE_CONTEXT      fCloseContext;
    FN_GET_RIGHTS         fGetRights;
    FN_GET_PARENT_NAME    fGetParentName;
} MARTA_INDEX_FUNCTION_CONTEXT, *PMARTA_INDEX_FUNCTION_CONTEXT;

typedef struct _MARTA_RESET_FUNCTION_CONTEXT {
    FN_ADD_REF_CONTEXT     fAddRefContext;
    FN_CLOSE_CONTEXT       fCloseContext;
    FN_GET_DESIRED_ACCESS  fGetDesiredAccess;
    FN_GET_PARENT_CONTEXT  fGetParentContext;
    FN_GET_PROPERTIES      fGetProperties;
    FN_GET_TYPE_PROPERTIES fGetTypeProperties;
    FN_OPEN_NAMED_OBJECT   fOpenNamedObject;
    FN_GET_RIGHTS          fGetRights;
} MARTA_RESET_FUNCTION_CONTEXT, *PMARTA_RESET_FUNCTION_CONTEXT;
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// MACRO DEFINITIONS START HERE                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define MARTA_DACL_NOT_PROTECTED(sd, si)                                       \
        (FLAG_ON((si), DACL_SECURITY_INFORMATION) &&                           \
         !FLAG_ON((sd)->Control, SE_DACL_PROTECTED))

#define MARTA_SACL_NOT_PROTECTED(sd, si)                                       \
        (FLAG_ON((si), SACL_SECURITY_INFORMATION) &&                           \
         !FLAG_ON((sd)->Control, SE_SACL_PROTECTED))

#define MARTA_SD_NOT_PROTECTED(sd, si)                                         \
        ((MARTA_DACL_NOT_PROTECTED((sd), (si))) ||                             \
         (MARTA_SACL_NOT_PROTECTED((sd), (si))))

#define MARTA_NT5_FLAGS_ON(c)                                                  \
        (FLAG_ON((c), (SE_SACL_AUTO_INHERITED   | SE_DACL_AUTO_INHERITED |     \
                       SE_DACL_PROTECTED        | SE_SACL_PROTECTED |          \
                       SE_DACL_AUTO_INHERIT_REQ | SE_SACL_AUTO_INHERIT_REQ)))


#if 1
#define MARTA_TURN_OFF_IMPERSONATION                                           \
        if (OpenThreadToken(                                                   \
                GetCurrentThread(),                                            \
                MAXIMUM_ALLOWED,                                               \
                TRUE,                                                          \
                &ThreadHandle                                                  \
                ))                                                             \
        { RevertToSelf(); }                                                    \
        else                                                                   \
        { ThreadHandle = NULL; }

#define MARTA_TURN_ON_IMPERSONATION                                            \
        if (ThreadHandle != NULL)                                              \
        {                                                                      \
            (VOID) SetThreadToken(NULL, ThreadHandle);                         \
            CloseHandle(ThreadHandle);                                         \
            ThreadHandle = NULL;                                               \
        }

#else

#define MARTA_TURN_ON_IMPERSONATION 
#define MARTA_TURN_OFF_IMPERSONATION 

#endif

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// FUNCTION PROTOTYPES START HERE                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteSetHandleRights(
    IN     HANDLE               Handle,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

DWORD
AccRewriteSetNamedRights(
    IN     LPWSTR               pObjectName,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN     BOOL                 bSkipInheritanceComputation
    );

VOID
MartaInitializeGetContext(
    IN  SE_OBJECT_TYPE              ObjectType,
    OUT PMARTA_GET_FUNCTION_CONTEXT pFunctionContext
    );

VOID
MartaInitializeIndexContext(
    IN  SE_OBJECT_TYPE                ObjectType,
    OUT PMARTA_INDEX_FUNCTION_CONTEXT pFunctionContext
    );

BOOL
MartaUpdateTree(
    IN SECURITY_INFORMATION        SecurityInfo,
    IN PSECURITY_DESCRIPTOR        pNewSD,
    IN PSECURITY_DESCRIPTOR        pOldSD,
    IN MARTA_CONTEXT               Context,
    IN HANDLE                      ProcessHandle,
    IN PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN PGENERIC_MAPPING            pGenMap
    );

BOOL
MartaResetTree(
    IN SECURITY_INFORMATION        SecurityInfo,
    IN SECURITY_INFORMATION        TmpSeInfo,
    IN PSECURITY_DESCRIPTOR        pNewSD,
    IN PSECURITY_DESCRIPTOR        pEmptySD,
    IN MARTA_CONTEXT               Context,
    IN HANDLE                      ProcessHandle,
    IN PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN PGENERIC_MAPPING            pGenMap,
    IN ACCESS_MASK                 MaxAccessMask,
    IN ACCESS_MASK                 AccessMask,
    IN ACCESS_MASK                 RetryAccessMask,
    IN OUT PPROG_INVOKE_SETTING    pOperation,
    IN FN_PROGRESS                 fnProgress,
    IN PVOID                       Args,
    IN BOOL                        KeepExplicit
    );

DWORD
MartaGetNT4NodeSD(
    IN     PSECURITY_DESCRIPTOR pOldSD,
    IN OUT PSECURITY_DESCRIPTOR pOldChildSD,
    IN     HANDLE               ProcessHandle,
    IN     BOOL                 bIsChildContainer,
    IN     PGENERIC_MAPPING     pGenMap,
    IN     SECURITY_INFORMATION SecurityInfo
    );

DWORD
MartaCompareAndMarkInheritedAces(
    IN  PACL    pParentAcl,
    IN  PACL    pChildAcl,
    IN  BOOL    bIsChildContainer,
    OUT PBOOL   pCompareStatus
    );

BOOL
MartaEqualAce(
    IN PACE_HEADER pParentAce,
    IN PACE_HEADER pChildAce,
    IN BOOL        bIsChildContainer
    );

DWORD
MartaManualPropagation(
    IN     MARTA_CONTEXT               Context,
    IN     SECURITY_INFORMATION        SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR        pSD,
    IN     PGENERIC_MAPPING            pGenMap,
    IN     BOOL                        bDoPropagate,
    IN     BOOL                        bReadOldProtectedBits,
    IN     PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN     BOOL                        bSkipInheritanceComputation
    );

VOID
MartaInitializeSetContext(
    IN  SE_OBJECT_TYPE              ObjectType,
    OUT PMARTA_SET_FUNCTION_CONTEXT pFunctionContext
    );

DWORD
AccRewriteGetHandleRights(
    IN  HANDLE                 Handle,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
AccRewriteGetNamedRights(
    IN  LPWSTR                 pObjectName,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaGetRightsFromContext(
    IN  MARTA_CONTEXT               Context,
    IN  PMARTA_GET_FUNCTION_CONTEXT pGetFunctionContext,
    IN  SECURITY_INFORMATION        SecurityInfo,
    OUT PSID                      * ppSidOwner,
    OUT PSID                      * ppSidGroup,
    OUT PACL                      * ppDacl,
    OUT PACL                      * ppSacl,
    OUT PSECURITY_DESCRIPTOR      * ppSecurityDescriptor
    );

VOID
MartaGetSidsAndAclsFromSD(
    IN  SECURITY_INFORMATION   SecurityInfo,
    IN  PSECURITY_DESCRIPTOR   pSD,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

BOOL
MartaIsSDNT5Style(
    IN PSECURITY_DESCRIPTOR SD
    );

BOOL
MartaIsAclNt5Style(
    PACL pAcl
    );

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// FUNCTIONS START HERE                                                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaIsSDNT5Style                                                //
//                                                                            //
// Description: Determine if the Security Descriptor is NT5 style.            //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pSD]                    Security Descriptor                       //
//                                                                            //
// Returns:  TRUE if any of the following is true                             //
//               Presence of Protected/AutoInherited in the contol bits of SD //
//               Presence of INHERITED_ACE flag in DACL/SACL                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaIsSDNT5Style(
    IN PSECURITY_DESCRIPTOR pSD
    )
{
    BOOL                  bRetval = TRUE;
    PACL                  pAcl    = NULL;
    PISECURITY_DESCRIPTOR pISD    = (PISECURITY_DESCRIPTOR) pSD;

    if (MARTA_NT5_FLAGS_ON(pISD->Control))
    {
        return TRUE;
    }

    pAcl = RtlpDaclAddrSecurityDescriptor(pISD);

    if (NULL != pAcl)
    {
        bRetval = FALSE;

        if (MartaIsAclNt5Style(pAcl))
        {
            return TRUE;
        }
    }

    pAcl = RtlpSaclAddrSecurityDescriptor(pISD);

    if (NULL != pAcl)
    {
        bRetval = FALSE;

        if (MartaIsAclNt5Style(pAcl))
        {
            return TRUE;
        }
    }

    return bRetval;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaIsAclNT5Style                                               //
//                                                                            //
// Description: Determine if the Acl is NT5 style.                            //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pAcl]                    ACL                                      //
//                                                                            //
// Returns: TRUE if INHERITED_ACE flags exists in the AceFlags                //
//          FALSE otherwise                                                   //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaIsAclNt5Style(
    PACL pAcl
    )
{
    ULONG       i    = 0;
    PACE_HEADER pAce = (PACE_HEADER) FirstAce(pAcl);

    for (; i < pAcl->AceCount; i++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            return TRUE;
        }
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaInitializeGetContext                                        //
//                                                                            //
// Description: Initializes the function pointers based on object-type.       //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  ObjectType]        Type of the object                             //
//     [OUT pFunctionContext]  Structure to hold function pointers            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

VOID
MartaInitializeGetContext(
    IN  SE_OBJECT_TYPE              ObjectType,
    OUT PMARTA_GET_FUNCTION_CONTEXT pFunctionContext
    )
{
    pFunctionContext->fAddRefContext     = MartaAddRefContext[ObjectType];
    pFunctionContext->fCloseContext      = MartaCloseContext[ObjectType];
    pFunctionContext->fOpenNamedObject   = MartaOpenNamedObject[ObjectType];
    pFunctionContext->fOpenHandleObject  = MartaOpenHandleObject[ObjectType];
    pFunctionContext->fGetRights         = MartaGetRights[ObjectType];
    pFunctionContext->fGetDesiredAccess  = MartaGetDesiredAccess[ObjectType];
    pFunctionContext->fGetParentContext  = MartaGetParentContext[ObjectType];
    pFunctionContext->fGetTypeProperties = MartaGetTypeProperties[ObjectType];
    pFunctionContext->fGetProperties     = MartaGetProperties[ObjectType];
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetSidsAndAclsFromSD                                        //
//                                                                            //
// Description: Fill in the fields requested by GetSecurity API.              //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  SecurityInfo]           Security Information requested            //
//     [IN  pSD]                    Security Descriptor from which the out    //
//                                  fields will be returned                   //
//                                                                            //
//     [OUT  ppSIdOwner]            To return the owner                       //
//     [OUT  ppSidGroup]            To return the group                       //
//     [OUT  ppDacl]                To return the Dacl                        //
//     [OUT  ppSacl]                To return the Sacl                        //
//     [OUT  ppSecurityDescriptor]  To return the Security Descriptor         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

VOID
MartaGetSidsAndAclsFromSD(
    IN  SECURITY_INFORMATION   SecurityInfo,
    IN  PSECURITY_DESCRIPTOR   pSD,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR) pSD;

    if (FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) && (NULL != ppSidOwner))
    {
        *ppSidOwner = RtlpOwnerAddrSecurityDescriptor(pISD);
    }

    if (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) && (NULL != ppSidGroup))
    {
        *ppSidGroup = RtlpGroupAddrSecurityDescriptor(pISD);
    }

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) && (NULL != ppDacl))
    {
       *ppDacl = RtlpDaclAddrSecurityDescriptor(pISD);
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) && (ppSacl != NULL))
    {
        *ppSacl = RtlpSaclAddrSecurityDescriptor(pISD);
    }

    if (NULL != ppSecurityDescriptor)
    {
        *ppSecurityDescriptor = pSD;
    }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetRightsFromContext                                        //
//                                                                            //
// Description: Get the security information requested given the Context.     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  Context]                Context structure for the object          //
//     [IN  pGetFunctionContext]    Structure holding the function pointers   //
//     [IN  SecurityInfo]           Security Information requested            //
//                                                                            //
//     [OUT  ppSIdOwner]            To return the owner                       //
//     [OUT  ppSidGroup]            To return the group                       //
//     [OUT  ppDacl]                To return the Dacl                        //
//     [OUT  ppSacl]                To return the Sacl                        //
//     [OUT  ppSecurityDescriptor]  To return the Security Descriptor         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetRightsFromContext(
    IN  MARTA_CONTEXT               Context,
    IN  PMARTA_GET_FUNCTION_CONTEXT pGetFunctionContext,
    IN  SECURITY_INFORMATION        SecurityInfo,
    OUT PSID                      * ppSidOwner,
    OUT PSID                      * ppSidGroup,
    OUT PACL                      * ppDacl,
    OUT PACL                      * ppSacl,
    OUT PSECURITY_DESCRIPTOR      * ppSecurityDescriptor
    )
{
    DWORD                dwErr         = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSD           = NULL;
    PSECURITY_DESCRIPTOR pParentSD     = NULL;
    HANDLE               ProcessHandle = NULL;
    GENERIC_MAPPING      ZeroGenMap    = {0, 0, 0, 0};
    MARTA_CONTEXT        ParentContext = NULL_MARTA_CONTEXT;
    BOOL                 bIsContainer  = FALSE;

    MARTA_OBJECT_PROPERTIES      ObjectProperties;
    MARTA_OBJECT_TYPE_PROPERTIES ObjectTypeProperties;

    dwErr = (*(pGetFunctionContext->fGetRights))(
                   Context,
                   SecurityInfo,
                   &pSD
                   );

    CONDITIONAL_RETURN(dwErr);

    if (NULL == pSD)
    {
        goto End;
    }

    if (!FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION))
    {
        goto GetResults;
    }

    //
    // If the SD is NT4 && acl requested is not PROTECTED && ManualPropagation
    // is required then
    //     Get the ParentSD and convert the SD into NT5 style
    // else
    //     Goto GetResults
    //

    if (!MARTA_SD_NOT_PROTECTED((PISECURITY_DESCRIPTOR) pSD, SecurityInfo))
    {
        goto GetResults;
    }

    if (MartaIsSDNT5Style(pSD))
    {
        goto GetResults;
    }

    //
    // Get the "Type" properties for the object,
    //

    ObjectTypeProperties.cbSize  = sizeof(ObjectTypeProperties);
    ObjectTypeProperties.dwFlags = 0;
    ObjectTypeProperties.GenMap  = ZeroGenMap;

    dwErr = (*(pGetFunctionContext->fGetTypeProperties))(&ObjectTypeProperties);

    CONDITIONAL_EXIT(dwErr, End);

    if (!FLAG_ON(ObjectTypeProperties.dwFlags, MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG))
    {
        goto GetResults;
    }

    dwErr = (*(pGetFunctionContext->fGetParentContext))(
                Context,
                (*(pGetFunctionContext->fGetDesiredAccess))(READ_ACCESS_RIGHTS, FALSE, SecurityInfo),
                &ParentContext
                );

    CONDITIONAL_EXIT(dwErr, End);

    //
    // The SD is NT4 style. Read the parent SD to determine whether the aces are
    // the "same" on both the parent and the child.
    //

    if (NULL == ParentContext)
    {
        goto GetResults;
    }

    dwErr = (*(pGetFunctionContext->fGetRights))(
                   ParentContext,
                   SecurityInfo,
                   &pParentSD
                   );

    (VOID) (*(pGetFunctionContext->fCloseContext))(ParentContext);

    CONDITIONAL_EXIT(dwErr, End);

    if (NULL == pParentSD)
    {
        goto GetResults;
    }

    dwErr = GetCurrentToken(&ProcessHandle);

    CONDITIONAL_EXIT(dwErr, End);

    if (!((FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION)) &&
          (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))))
    {
        AccFree(pSD);
        pSD = NULL;

        dwErr = (*(pGetFunctionContext->fGetRights))(
                       Context,
                       (SecurityInfo | OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION),
                       &pSD
                       );

        CONDITIONAL_EXIT(dwErr, End);
    }

    ObjectProperties.cbSize  = sizeof(ObjectProperties);
    ObjectProperties.dwFlags = 0;

    dwErr = (*(pGetFunctionContext->fGetProperties))(
                   Context,
                   &ObjectProperties
                   );

    CONDITIONAL_EXIT(dwErr, End);

    bIsContainer = FLAG_ON(ObjectProperties.dwFlags, MARTA_OBJECT_IS_CONTAINER);

    dwErr = MartaGetNT4NodeSD(
                pParentSD,
                pSD,
                ProcessHandle,
                bIsContainer,
                &(ObjectTypeProperties.GenMap),
                SecurityInfo
                );

    CONDITIONAL_EXIT(dwErr, End);

GetResults:

    MartaGetSidsAndAclsFromSD(
        SecurityInfo,
        pSD,
        ppSidOwner,
        ppSidGroup,
        ppDacl,
        ppSacl,
        ppSecurityDescriptor
        );

End:

    if (NULL != pParentSD)
    {
        AccFree(pParentSD);
    }

    if (NULL != ProcessHandle)
    {
        CloseHandle(ProcessHandle);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        AccFree(pSD);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteGetNamedRights                                         //
//                                                                            //
// Description: Get the security information requested given the object       //
//              name and information. This is the routine that is called by   //
//              advapi32.                                                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pObjectName]            Name of the Object                        //
//     [IN  ObjectType]             Type of the object                        //
//     [IN  SecurityInfo]           Security Information requested            //
//                                                                            //
//     [OUT  ppSIdOwner]            To return the owner                       //
//     [OUT  ppSidGroup]            To return the group                       //
//     [OUT  ppDacl]                To return the Dacl                        //
//     [OUT  ppSacl]                To return the Sacl                        //
//     [OUT  ppSecurityDescriptor]  To return the Security Descriptor         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteGetNamedRights(
    IN  LPWSTR                 pObjectName,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    DWORD         dwErr   = ERROR_SUCCESS;
    MARTA_CONTEXT Context = NULL_MARTA_CONTEXT;

    MARTA_GET_FUNCTION_CONTEXT MartaGetFunctionContext;

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_SERVICE:
    case SE_PRINTER:
    case SE_REGISTRY_KEY:
    case SE_REGISTRY_WOW64_32KEY:
    case SE_LMSHARE:
    case SE_KERNEL_OBJECT:
    case SE_WINDOW_OBJECT:
    case SE_WMIGUID_OBJECT:
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
        break;
    case SE_PROVIDER_DEFINED_OBJECT:
    case SE_UNKNOWN_OBJECT_TYPE:
    default:
        return ERROR_INVALID_PARAMETER;
    }

    MartaInitializeGetContext(ObjectType, &MartaGetFunctionContext);

    //
    // Open the object with permissions to read the object type as well. If that
    // fails, open the object with just read permissions. This has to be done in
    // order to accomodate NT4 SDs.
    //

    dwErr = (*(MartaGetFunctionContext.fOpenNamedObject))(
                   pObjectName,
                   (*(MartaGetFunctionContext.fGetDesiredAccess))(READ_ACCESS_RIGHTS, TRUE, SecurityInfo),
                   &Context
                   );

    if (ERROR_SUCCESS != dwErr)
    {
        dwErr = (*(MartaGetFunctionContext.fOpenNamedObject))(
                       pObjectName,
                       (*(MartaGetFunctionContext.fGetDesiredAccess))(READ_ACCESS_RIGHTS, FALSE, SecurityInfo),
                       &Context
                       );

        CONDITIONAL_EXIT(dwErr, End);
    }

    dwErr = MartaGetRightsFromContext(
                Context,
                &MartaGetFunctionContext,
                SecurityInfo,
                ppSidOwner,
                ppSidGroup,
                ppDacl,
                ppSacl,
                ppSecurityDescriptor
                );

    (VOID) (*(MartaGetFunctionContext.fCloseContext))(Context);

End:
    return dwErr;

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteGetHandleRights                                        //
//                                                                            //
// Description: Get the security information requested given the object       //
//              handle and information. This is the routine that is called by //
//              advapi32.                                                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  Handle]                 Handle to the Object                      //
//     [IN  pGetFunctionContext]    Structure holding the function pointers   //
//     [IN  SecurityInfo]           Security Information requested            //
//                                                                            //
//     [OUT  ppSIdOwner]            To return the owner                       //
//     [OUT  ppSidGroup]            To return the group                       //
//     [OUT  ppDacl]                To return the Dacl                        //
//     [OUT  ppSacl]                To return the Sacl                        //
//     [OUT  ppSecurityDescriptor]  To return the Security Descriptor         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteGetHandleRights(
    IN  HANDLE                 Handle,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    DWORD         dwErr   = ERROR_SUCCESS;
    MARTA_CONTEXT Context = NULL_MARTA_CONTEXT;

    MARTA_GET_FUNCTION_CONTEXT MartaGetFunctionContext;

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_SERVICE:
    case SE_PRINTER:
    case SE_REGISTRY_KEY:
    case SE_LMSHARE:
    case SE_KERNEL_OBJECT:
    case SE_WINDOW_OBJECT:
    case SE_WMIGUID_OBJECT:
        break;
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
    case SE_PROVIDER_DEFINED_OBJECT:
    case SE_UNKNOWN_OBJECT_TYPE:
    default:
        return ERROR_INVALID_PARAMETER;
    }

    MartaInitializeGetContext(ObjectType, &MartaGetFunctionContext);

    //
    // Open the object with permissions to read the object type as well. If that
    // fails, open the object with just read permissions. This has to be done in
    // order to accomodate NT4 SDs.
    //

    dwErr = (*(MartaGetFunctionContext.fOpenHandleObject))(
                   Handle,
                   (*(MartaGetFunctionContext.fGetDesiredAccess))(READ_ACCESS_RIGHTS, TRUE, SecurityInfo),
                   &Context
                   );

    if (ERROR_SUCCESS != dwErr)
    {
        dwErr = (*(MartaGetFunctionContext.fOpenHandleObject))(
                       Handle,
                       (*(MartaGetFunctionContext.fGetDesiredAccess))(READ_ACCESS_RIGHTS, FALSE, SecurityInfo),
                       &Context
                       );

        CONDITIONAL_EXIT(dwErr, End);
    }

    dwErr = MartaGetRightsFromContext(
                Context,
                &MartaGetFunctionContext,
                SecurityInfo,
                ppSidOwner,
                ppSidGroup,
                ppDacl,
                ppSacl,
                ppSecurityDescriptor
                );

    (VOID) (*(MartaGetFunctionContext.fCloseContext))(Context);

End:
    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaInitializeSetContext                                        //
//                                                                            //
// Description: Initializes the function pointers based on object-type.       //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  ObjectType]        Type of the object                             //
//     [OUT pFunctionContext]  Structure to hold function pointers            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


VOID
MartaInitializeSetContext(
    IN  SE_OBJECT_TYPE              ObjectType,
    OUT PMARTA_SET_FUNCTION_CONTEXT pFunctionContext
    )
{
    pFunctionContext->fAddRefContext      = MartaAddRefContext[ObjectType];
    pFunctionContext->fCloseContext       = MartaCloseContext[ObjectType];
    pFunctionContext->fFindFirst          = MartaFindFirst[ObjectType];
    pFunctionContext->fFindNext           = MartaFindNext[ObjectType];
    pFunctionContext->fGetParentContext   = MartaGetParentContext[ObjectType];
    pFunctionContext->fGetProperties      = MartaGetProperties[ObjectType];
    pFunctionContext->fGetTypeProperties  = MartaGetTypeProperties[ObjectType];
    pFunctionContext->fGetRights          = MartaGetRights[ObjectType];
    pFunctionContext->fOpenNamedObject    = MartaOpenNamedObject[ObjectType];
    pFunctionContext->fOpenHandleObject   = MartaOpenHandleObject[ObjectType];
    pFunctionContext->fSetRights          = MartaSetRights[ObjectType];
    pFunctionContext->fGetDesiredAccess   = MartaGetDesiredAccess[ObjectType];
    pFunctionContext->fReopenContext      = MartaReopenContext[ObjectType];
    pFunctionContext->fReopenOrigContext  = MartaReopenOrigContext[ObjectType];
    pFunctionContext->fGetNameFromContext = MartaGetNameFromContext[ObjectType];
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaManualPropagation                                           //
//                                                                            //
// Description: Stamp the security descriptor on the object referred by the   //
//              context and propagate the inheritable aces to its children.   //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  Context]                Context structure for the object          //
//     [IN  SecurityInfo]           Security Information requested            //
//     [IN  OUT pSD]                Security Descriptor to be stamped on the  //
//                                  object in absolute format.                //
//     [IN  pGenMap]                Generic mapping of the object rights      //
//     [IN  bDoPropagate]           Whether propagation _can_ be done         //
//     [IN  bReadOldProtectedBits]  Whether to read existing protection info  //
//     [IN  pSetFunctionContext]    Structure holding the function pointers   //
//     [IN  bSkipInheritanceComputation]  Whether to compute inherited aces   //
//                                        from the parent
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaManualPropagation(
    IN     MARTA_CONTEXT               Context,
    IN     SECURITY_INFORMATION        SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR        pSD,
    IN     PGENERIC_MAPPING            pGenMap,
    IN     BOOL                        bDoPropagate,
    IN     BOOL                        bReadOldProtectedBits,
    IN     PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN     BOOL                        bSkipInheritanceComputation
    )
{
    DWORD                       dwErr             = ERROR_SUCCESS;
    BOOL                        bProtected        = TRUE;
    BOOL                        bIsChildContainer = FALSE;
    BOOL                        bRetryPropagation = FALSE;
    PSECURITY_DESCRIPTOR        pParentSD         = NULL;
    PSECURITY_DESCRIPTOR        pOldSD            = NULL;
    PSECURITY_DESCRIPTOR        pNewSD            = NULL;
    PSID                        pSidOwner         = NULL;
    HANDLE                      ProcessHandle     = NULL;
    HANDLE                      ThreadHandle      = NULL;
    MARTA_CONTEXT               ParentContext     = NULL_MARTA_CONTEXT;
    SECURITY_DESCRIPTOR_CONTROL LocalControl      = (SECURITY_DESCRIPTOR_CONTROL) 0;

    MARTA_OBJECT_PROPERTIES ObjectProperties;

    //
    // Check if manual propagation should be done. Propagation is not tried if
    // any errors are encountered.
    //

    ObjectProperties.cbSize  = sizeof(ObjectProperties);
    ObjectProperties.dwFlags = 0;

    dwErr = (*(pMartaSetFunctionContext->fGetProperties))(
                   Context,
                   &ObjectProperties
                   );

    CONDITIONAL_EXIT(dwErr, End);

    bIsChildContainer = FLAG_ON(ObjectProperties.dwFlags, MARTA_OBJECT_IS_CONTAINER);

    dwErr = GetCurrentToken(&ProcessHandle);

    CONDITIONAL_EXIT(dwErr, End);

    //
    // Compute inherited aces if the caller has not already. This is the usual
    // case.
    //

    if (FALSE == bSkipInheritanceComputation)
    {
        //
        // Read the parent ACL only if xACL is to be stamped on is not protected.
        //

        if (MARTA_SD_NOT_PROTECTED((PISECURITY_DESCRIPTOR) pSD, SecurityInfo))
        {
            bProtected = FALSE;

            dwErr = (*(pMartaSetFunctionContext->fGetParentContext))(
                        Context,
                        (*(pMartaSetFunctionContext->fGetDesiredAccess))(READ_ACCESS_RIGHTS, FALSE, SecurityInfo),
                        &ParentContext
                        );

            CONDITIONAL_EXIT(dwErr, End);

            if (NULL != ParentContext)
            {
                dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                               ParentContext,
                               SecurityInfo,
                               &pParentSD
                               );

                (VOID) (*(pMartaSetFunctionContext->fCloseContext))(ParentContext);

                CONDITIONAL_EXIT(dwErr, End);

                if (NULL != pParentSD)
                {
                    if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                    {
                        ((PISECURITY_DESCRIPTOR) pParentSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
                    }

                    if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                    {
                        ((PISECURITY_DESCRIPTOR) pParentSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
                    }
                }
            }
        }

        //
        // Read the old security descriptor on the child if xAcl is not protected
        // and is to be stamped on the child.
        // To take case of creator-owner/group aces, read in Owner/Group info as
        // well and set it in the SD passed in if it is not already present.
        //

        if (FALSE == bProtected)
        {
            SECURITY_INFORMATION LocalSeInfo = SecurityInfo;

            if (NULL == RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD))
            {
                LocalSeInfo |= OWNER_SECURITY_INFORMATION;
            }

            if (NULL == RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD))
            {
                LocalSeInfo |= GROUP_SECURITY_INFORMATION;
            }

            dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                           Context,
                           LocalSeInfo,
                           &pOldSD
                           );

            CONDITIONAL_EXIT(dwErr, End);

            if (NULL == RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD))
            {
                if (FALSE == SetSecurityDescriptorOwner(
                                 pSD,
                                 RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldSD),
                                 FALSE))
                {
                    dwErr = GetLastError();
                }

                CONDITIONAL_EXIT(dwErr, End);
            }

            if (NULL == RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD))
            {
                if (FALSE == SetSecurityDescriptorGroup(
                                 pSD,
                                 RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldSD),
                                 FALSE))
                {
                    dwErr = GetLastError();
                }

                CONDITIONAL_EXIT(dwErr, End);
            }

        }

        //
        // Read the old security descriptor on the child if xAcl it is a container.
        //

        else if (bIsChildContainer || bReadOldProtectedBits)
        {
            dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                           Context,
                           SecurityInfo,
                           &pOldSD
                           );

            CONDITIONAL_EXIT(dwErr, End);
        }

        //
        // If none of the PROTECTED flags are passed in then do the "right" thing.
        // Read the PROTECTED bit from the existing security descriptor and set it
        // in the new one.
        //

        if (bReadOldProtectedBits && (NULL != pOldSD))
        {
            if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                if (!FLAG_ON(SecurityInfo, (PROTECTED_DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION)))
                {
                    ((PISECURITY_DESCRIPTOR) pSD)->Control |= ((PISECURITY_DESCRIPTOR) pOldSD)->Control & SE_DACL_PROTECTED;
                }
            }

            if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                if (!FLAG_ON(SecurityInfo, (PROTECTED_SACL_SECURITY_INFORMATION | UNPROTECTED_SACL_SECURITY_INFORMATION)))
                {
                    ((PISECURITY_DESCRIPTOR) pSD)->Control |= ((PISECURITY_DESCRIPTOR) pOldSD)->Control & SE_SACL_PROTECTED;
                }
            }
        }

        //
        // Merge the SD with the parent SD whether or not it is protected.
        // This is done to lose the inherited aces if the child is protected.
        //

        MARTA_TURN_OFF_IMPERSONATION;

        if (FALSE == CreatePrivateObjectSecurityEx(
                         pParentSD,
                         pSD,
                         &pNewSD,
                         NULL,
                         bIsChildContainer,
                         (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT | SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                         ProcessHandle,
                         pGenMap
                         ))
        {
            dwErr = GetLastError();
        }

        MARTA_TURN_ON_IMPERSONATION;

        CONDITIONAL_EXIT(dwErr, End);
    }
    else
    {
        //
        // Stamp the security descriptor as prvided by the caller. The only
        // caller of this is SCE.
        //

        pNewSD = pSD;

        //
        // Read the old security descriptor on the child if xAcl it is a container.
        //

        if (bIsChildContainer)
        {
            dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                           Context,
                           (SecurityInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)),
                           &pOldSD
                           );

            CONDITIONAL_EXIT(dwErr, End);
        }
    }

    //
    // If the child is a container then update the subtree underneath it.
    //

    if (bIsChildContainer)
    {
        if (bDoPropagate)
        {
            bRetryPropagation = MartaUpdateTree(
                                    SecurityInfo,
                                    pNewSD,
                                    pOldSD,
                                    Context,
                                    ProcessHandle,
                                    pMartaSetFunctionContext,
                                    pGenMap
                                    );
        }
        else
        {
            bRetryPropagation = TRUE;
        }
    }

    //
    // Stamp NewNodeSD on the node
    //

    if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        ((PISECURITY_DESCRIPTOR) pNewSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        ((PISECURITY_DESCRIPTOR) pNewSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }

    dwErr = (*(pMartaSetFunctionContext->fSetRights))(
                   Context,
                   SecurityInfo,
                   pNewSD
                   );

    CONDITIONAL_EXIT(dwErr, End);

    //
    // If propagation had failed in the first attept then try again. This is to
    // cover the case when the container can be enumerated after setting the new
    // security.

    if (bRetryPropagation && (SecurityInfo & DACL_SECURITY_INFORMATION))
    {
        ACCESS_MASK Access = (*(pMartaSetFunctionContext->fGetDesiredAccess))(
                                    NO_ACCESS_RIGHTS,
                                    TRUE,
                                    SecurityInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)
                                    );

        DWORD lErr = (*(pMartaSetFunctionContext->fReopenOrigContext))(
                       Context,
                       Access
                       );

        CONDITIONAL_EXIT(lErr, End);

        (VOID) MartaUpdateTree(
                   SecurityInfo,
                   pNewSD,
                   pOldSD,
                   Context,
                   ProcessHandle,
                   pMartaSetFunctionContext,
                   pGenMap
                   );
    }

End:

    if (NULL != ProcessHandle)
    {
        CloseHandle(ProcessHandle);
    }

    if (NULL != pOldSD)
    {
        AccFree(pOldSD);
    }

    if (NULL != pParentSD)
    {
        AccFree(pParentSD);
    }

    if ((NULL != pNewSD) && (pNewSD != pSD))
    {
        DestroyPrivateObjectSecurity(&pNewSD);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaEqualAce                                                    //
//                                                                            //
// Description: Compare an ace from child to an ace from parent to determine  //
//              if the child ace has been inherited from its parent.          //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pParentAce]          The ace for the parent object                //
//     [IN  pChildAce]           The ace for the child object                 //
//     [IN  bIsChildContainer]   Whether the child object is a Container      //
//                                                                            //
// Returns: TRUE    if the two aces are equal                                 //
//          FALSE   otherwise                                                 //
//                                                                            //
// Notes: No ace should contain generic bits and the parent ace should not    //
//        have INHERIT_ONLY bit.                                              //
//        Inherit flags are ignored.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaEqualAce(
    IN PACE_HEADER pParentAce,
    IN PACE_HEADER pChildAce,
    IN BOOL        bIsChildContainer
    )
{
    PSID        pSid1   = NULL;
    PSID        pSid2   = NULL;
    ACCESS_MASK Access1 = 0;
    ACCESS_MASK Access2 = 0;
    ULONG       Length1 = 0;
    ULONG       Length2 = 0;

    if ((NULL == pParentAce) || (NULL == pChildAce))
    {
        return FALSE;
    }

    //
    // Compare ACE type.
    //

    if (pParentAce->AceType != pChildAce->AceType)
    {
        return FALSE;
    }

    if ((pParentAce->AceFlags & ~INHERITED_ACE) != (pChildAce->AceFlags))
    {
        return FALSE;
    }

    if (bIsChildContainer)
    {
        //
        // Note: the flag shouldn't be compared because
        // it will be different even for the "equal" ace
        //
        // then we have a bug here, for example
        //      parentSD is Admin CI F
        //      childSD is Admin CIOI F
        // these two SDs should be marked as "different" but from
        // this routine, it will mark them "equal".
        //
    }

    //
    // Get access mask and SID pointer.
    //

    switch (pParentAce->AceType) {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:

        pSid1   = (PSID) &((PKNOWN_ACE) pParentAce)->SidStart;
        pSid2   = (PSID) &((PKNOWN_ACE) pChildAce)->SidStart;
        Access1 = ((PKNOWN_ACE) pParentAce)->Mask;
        Access2 = ((PKNOWN_ACE) pChildAce)->Mask;
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        if (((PKNOWN_OBJECT_ACE) pParentAce)->Flags !=
             ((PKNOWN_OBJECT_ACE) pChildAce)->Flags )
        {
            return FALSE;
        }

        if (((PKNOWN_OBJECT_ACE) pParentAce)->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            if (!RtlpIsEqualGuid(
                     RtlObjectAceObjectType(pParentAce),
                     RtlObjectAceObjectType(pChildAce)))
            {
                return FALSE;
            }
        }

        if (((PKNOWN_OBJECT_ACE) pParentAce)->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            if (!RtlpIsEqualGuid(
                     RtlObjectAceInheritedObjectType(pParentAce),
                     RtlObjectAceInheritedObjectType(pChildAce)))
            {
                return FALSE;
            }
        }

        pSid1 = RtlObjectAceSid(pParentAce);
        pSid2 = RtlObjectAceSid(pChildAce);

        Access1 = ((PKNOWN_OBJECT_ACE) pParentAce)->Mask;
        Access2 = ((PKNOWN_OBJECT_ACE) pChildAce)->Mask;

        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

        if (((PKNOWN_COMPOUND_ACE) pParentAce)->CompoundAceType !=
            ((PKNOWN_COMPOUND_ACE) pChildAce)->CompoundAceType)
        {
            return FALSE;
        }

        pSid1 = (PSID) &((PKNOWN_COMPOUND_ACE) pParentAce)->SidStart;
        pSid2 = (PSID) &((PKNOWN_COMPOUND_ACE) pParentAce)->SidStart;

        if ((!RtlValidSid(pSid1)) || (!RtlValidSid(pSid2)))
        {
            return FALSE;
        }

        if (!RtlEqualSid(pSid1, pSid2))
        {
            return FALSE;
        }

        Length1 = RtlLengthSid(pSid1);
        Length2 = RtlLengthSid(pSid2);

        pSid1 = (PSID) (((PUCHAR) pSid1) + Length1);
        pSid2 = (PSID) (((PUCHAR) pSid2) + Length2);

        Access1 = ((PKNOWN_COMPOUND_ACE) pParentAce)->Mask;
        Access2 = ((PKNOWN_COMPOUND_ACE) pChildAce)->Mask;
        break;

    default:
        return FALSE;
    }

    //
    // Compare access mask. There should be no generic mask and both the parent
    // object and the child object should have the same object type.
    //

    if (Access1 != Access2) {
        return FALSE;
    }

    //
    // Compare the Sids.
    //

    if ((!RtlValidSid(pSid1)) || (!RtlValidSid(pSid2)))
    {
        return FALSE;
    }

    if (!RtlEqualSid(pSid1, pSid2))
    {
        return FALSE;
    }

    return TRUE;

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: CompareAndMarkInheritedAces                                      //
//                                                                            //
// Description: Compare the parent acl with the child. If all the effective   //
//              aces from parent are present in the child then mark those     //
//              aces in the child with INHERITED_ACE bit.                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pParentAcl]          The acl for the parent object                //
//     [IN  OUT pChildAcl]       The acl for the child object                 //
//     [IN  bIsChildContainer]   Whether the child object is a Container      //
//                                                                            //
//     [OUT  pCompareStatus]  To return the Security Descriptor               //
//                                                                            //
// Returns: TRUE    if the all effective parent aces are present in the child //
//          FALSE   otherwise                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaCompareAndMarkInheritedAces(
    IN      PACL    pParentAcl,
    IN  OUT PACL    pChildAcl,
    IN      BOOL    bIsChildContainer,
    OUT     PBOOL   pCompareStatus
    )
{
    DWORD       dwErr                 = ERROR_SUCCESS;
    LONG        ParentAceCnt          = 0;
    LONG        ChildAceCnt           = 0;
    LONG        i                     = 0;
    LONG        j                     = 0;
    LONG        LastDenyAce           = -1;
    LONG        LastExplicitAce       = -1;
    LONG        LastInheritedDenyAce  = -1;
    LONG        FirstAllowAce         = ChildAceCnt;
    LONG        FirstInheritedAce     = ChildAceCnt;
    LONG        FirstExplicitAllowAce = ChildAceCnt;
    PACE_HEADER pParentAce            = NULL;
    PACE_HEADER pChildAce             = NULL;
    PBOOL       Flags                 = NULL;
    PUCHAR      Buffer                = NULL;
    PUCHAR      CurrentBuffer         = NULL;

    //
    // If the ChildAcl is NULL then it is a superset of the parent ACL.
    //

    if (NULL == pChildAcl)
    {
        *pCompareStatus = FALSE;
        goto End;
    }

    //
    // If the ParentAcl is NULL then it is a superset of the child ACL.
    // Since Child Acl is non-null at this point return TRUE.
    //

    if (NULL == pParentAcl)
    {
        *pCompareStatus = TRUE;
        goto End;
    }

    //
    // If the parent has no aces that could have been inherited then all the
    // child aces must be explicit.
    //

    ParentAceCnt = pParentAcl->AceCount;

    if (0 == ParentAceCnt)
    {
        *pCompareStatus = TRUE;
        goto End;
    }

    //
    // If the parent has one/more inheritable aces but the child has none then
    // the acl must be protected.
    //

    ChildAceCnt  = pChildAcl->AceCount;

    if (0 == ChildAceCnt)
    {
        *pCompareStatus = FALSE;
        goto End;
    }

    Flags = (PBOOL) AccAlloc(sizeof(BOOL) * ChildAceCnt);

    if (NULL == Flags)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    for (i = 0; i < ChildAceCnt; i++)
    {
        Flags[i] = FALSE;
    }

    //
    // For all aces present in ParentAcl
    //     If the ace is not present in ChildAcl
    //         return FALSE
    //     else
    //         Mark the position of the this ace in Child Acl in fFlags.
    //         These will later be marked as INHERITED if the acl can be
    //         rearranged to be canonical.
    //

    i = 0;
    pParentAce = (PACE_HEADER) FirstAce(pParentAcl);

    for (; i < ParentAceCnt; i++, pParentAce = (PACE_HEADER) NextAce(pParentAce))
    {
        j = 0;
        pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

        for (; j < ChildAceCnt; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
        {
            if (TRUE == MartaEqualAce(pParentAce, pChildAce, bIsChildContainer))
            {
                Flags[j] = TRUE;
                break;
            }
        }

        if (ChildAceCnt == j)
        {
            *pCompareStatus = FALSE;
            goto End;
        }
    }

    //
    // Mark all the aces that we had marked as INHERITED.
    // This will make sure that they are not DUPLICATED.
    //

    LastDenyAce           = -1;
    LastExplicitAce       = -1;
    LastInheritedDenyAce  = -1;

    FirstAllowAce         = ChildAceCnt;
    FirstInheritedAce     = ChildAceCnt;
    FirstExplicitAllowAce = ChildAceCnt;

    //
    // Run thru the acl and mark the positions of aces. These will be later used
    // to dtermine what should be done with the acl.
    //

    j = 0;
    pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

    for (; j < ChildAceCnt; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
    {
        switch (pChildAce->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (FALSE == Flags[j])
            {
                if (ChildAceCnt == FirstExplicitAllowAce)
                {
                    FirstExplicitAllowAce = j;
                }
            }

            if (ChildAceCnt == FirstAllowAce)
            {
                FirstAllowAce = j;
            }

            break;

        case ACCESS_DENIED_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            if (TRUE == Flags[j])
            {
                LastInheritedDenyAce = j;
            }

            LastDenyAce = j;

            break;

        default:
            break;
        }

        if (FALSE == Flags[j])
        {
            LastExplicitAce = j;
        }
        else
        {
            if (ChildAceCnt == FirstInheritedAce)
            {
                FirstInheritedAce = j;
            }
        }
    }

    //
    // This a non-canonical acl. Do not try to correct it.
    //

    if ((ChildAceCnt != FirstAllowAce) && (LastDenyAce > FirstAllowAce))
    {
        *pCompareStatus = FALSE;
        goto End;
    }

    //
    // Do not try to rearrange the acl if
    //     1. an inherited deny ace exists AND
    //     2. an explicit allow ace exists.
    //

    if ((-1 != LastInheritedDenyAce) && (ChildAceCnt != FirstExplicitAllowAce))
    {
        *pCompareStatus = FALSE;
        goto End;
    }

    //
    // The acl need not be rearranged since all the explicit aces are ahead of
    // the inherited ones.
    //

    if (LastExplicitAce < FirstInheritedAce)
    {
        j = 0;
        pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

        for (; j < ChildAceCnt; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
        {
            if (TRUE == Flags[j])
            {
                pChildAce->AceFlags |= INHERITED_ACE;
            }
        }
    }

    //
    // At least one inherited ace exists before an explicit one.
    // Rearrange the acl to get it in canonical form.
    //

    else
    {
        Buffer = (PUCHAR) AccAlloc(pChildAcl->AclSize - sizeof(ACL));
        CurrentBuffer = Buffer;

        if (NULL == Buffer)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto End;
        }

        j = 0;
        pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

        for (; j <= LastExplicitAce; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
        {
            if (FALSE == Flags[j])
            {
                memcpy(CurrentBuffer, (PUCHAR) pChildAce, pChildAce->AceSize);
                CurrentBuffer += pChildAce->AceSize;
            }
        }

        j = 0;
        pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

        for (; j < ChildAceCnt; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
        {
            if (TRUE == Flags[j])
            {
                memcpy(CurrentBuffer, (PUCHAR) pChildAce, pChildAce->AceSize);
                ((PACE_HEADER) CurrentBuffer)->AceFlags |= INHERITED_ACE;
                CurrentBuffer += pChildAce->AceSize;
            }
        }

        memcpy(
            ((PUCHAR) pChildAcl) + sizeof(ACL),
            Buffer,
            pChildAcl->AclSize - sizeof(ACL)
            );
    }

    *pCompareStatus = TRUE;

End:

    if (NULL != Flags)
    {
        AccFree(Flags);
    }

    if (NULL != Buffer)
    {
        AccFree(Buffer);
    }

    return dwErr;;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetNT4NodeSD                                                //
//                                                                            //
// Description: Converts the child security descriptor NT4 ACL into NT5 ACL   //
//              by comparing it to the parent ACL.                            //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pOldSD]              Old parent security descriptor               //
//     [IN  OUT pOldChildSD]     Old child security descriptor                //
//     [IN  Processhandle]       Process Handle                               //
//     [IN  bIsChildContainer]   Whether the child object is a Container      //
//     [IN  pGenMap]             Generic mapping of the object rights         //
//     [IN  SecurityInfo]        Security Information requested               //
//                                                                            //
// Algorithm:                                                                 //
//     if child acl and parent acl differ then                                //
//         mark the child acl PROTECTED                                       //
//                                                                            //
// Returns: ERROR_SUCCESS on successful completion of the routine             //
//          ERROR_XXXX    Otherwise                                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetNT4NodeSD(
    IN     PSECURITY_DESCRIPTOR pOldSD,
    IN OUT PSECURITY_DESCRIPTOR pOldChildSD,
    IN     HANDLE               ProcessHandle,
    IN     BOOL                 bIsChildContainer,
    IN     PGENERIC_MAPPING     pGenMap,
    IN     SECURITY_INFORMATION SecurityInfo
    )
{
    SECURITY_DESCRIPTOR  NullSD;

    DWORD                dwErr         = ERROR_SUCCESS;
    BOOL                 CompareStatus = FALSE;
    PACL                 pChildAcl     = NULL;
    PACL                 pParentAcl    = NULL;
    HANDLE               ThreadHandle  = NULL;
    PSECURITY_DESCRIPTOR pTmpSD        = NULL;
    UCHAR                Buffer[2 * sizeof(ACL)];
    PACL                 pDacl         = (PACL) Buffer;
    PACL                 pSacl         = (PACL) (Buffer + sizeof(ACL));

    if (!FLAG_ON(SecurityInfo, (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)))
    {
        return ERROR_SUCCESS;
    }

    InitializeSecurityDescriptor(&NullSD, SECURITY_DESCRIPTOR_REVISION);

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if (FALSE == InitializeAcl(pDacl, sizeof(ACL), ACL_REVISION))
        {
            return ERROR_ACCESS_DENIED;
        }

        if (FALSE == SetSecurityDescriptorDacl(
                         &NullSD,
                         TRUE,
                         pDacl,
                         FALSE))
        {
            return GetLastError();
        }
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (FALSE == InitializeAcl(pSacl, sizeof(ACL), ACL_REVISION))
        {
            return ERROR_ACCESS_DENIED;
        }

        if (FALSE == SetSecurityDescriptorSacl(
                         &NullSD,
                         TRUE,
                         pSacl,
                         FALSE))
        {
            return GetLastError();
        }
    }

    if (FALSE == SetSecurityDescriptorOwner(
                     &NullSD,
                     RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD),
                     FALSE))
    {
        return GetLastError();
    }

    if (FALSE == SetSecurityDescriptorGroup(
                     &NullSD,
                     RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD),
                     FALSE))
    {
        return GetLastError();
    }

    MARTA_TURN_OFF_IMPERSONATION;

    if (FALSE == CreatePrivateObjectSecurityEx(
                     pOldSD,
                     &NullSD,
                     &pTmpSD,
                     NULL,
                     bIsChildContainer,
                     (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT | SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                     ProcessHandle,
                     pGenMap
                     ))
    {
        dwErr = GetLastError();
    }

    MARTA_TURN_ON_IMPERSONATION;

    CONDITIONAL_EXIT(dwErr, End);

    //
    // Mark the aces from the child DACL, which are present in the parent.
    //

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        pChildAcl  = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD);
        pParentAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pTmpSD);

        dwErr = MartaCompareAndMarkInheritedAces(
                    pParentAcl,
                    pChildAcl,
                    bIsChildContainer,
                    &CompareStatus
                    );

        CONDITIONAL_EXIT(dwErr, End);

        if (FALSE == CompareStatus)
        {
            ((PISECURITY_DESCRIPTOR) pOldChildSD)->Control |= SE_DACL_PROTECTED;

        }
    }

    //
    // Mark the aces from the child SACL, which are present in the parent.
    //

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        pChildAcl  = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD);
        pParentAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pTmpSD);

        dwErr = MartaCompareAndMarkInheritedAces(
                    pParentAcl,
                    pChildAcl,
                    bIsChildContainer,
                    &CompareStatus
                    );

        CONDITIONAL_EXIT(dwErr, End);

        if (FALSE == CompareStatus)
        {
            ((PISECURITY_DESCRIPTOR) pOldChildSD)->Control |= SE_SACL_PROTECTED;

        }

        CONDITIONAL_EXIT(dwErr, End);
    }

End:
    if (NULL != pTmpSD)
    {
        DestroyPrivateObjectSecurity(&pTmpSD);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaUpdateTree                                                  //
//                                                                            //
// Description: Propagate the inheritable aces to the children.               //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  SecurityInfo]           Security Information requested            //
//     [IN  pNewSD]                 New parent security descriptor            //
//     [IN  pOldSD]                 Old parent security descriptor            //
//     [IN  Context]                Context structure for the object          //
//     [IN  Processhandle]          Process Handle                            //
//     [IN  pSetFunctionContext]    Structure holding the function pointers   //
//     [IN  pGenMap]                Generic mapping of the object rights      //
//                                                                            //
// Algorithm:                                                                 //
//     For all children that are not "Protected"                              //
//         if OldChildSD = NT4 style                                          //
//            Convert it into NT5 style                                       //
//         NewChildSD = Merge(ParentSD, OldChildSD)                           //
//         UpdateTree(Child)                                                  //
//         Stamp NewChildSD on Child                                          //
//                                                                            //
// Note: An error in the propagation is ignored.                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaUpdateTree(
    IN SECURITY_INFORMATION        SecurityInfo,
    IN PSECURITY_DESCRIPTOR        pNewSD,
    IN PSECURITY_DESCRIPTOR        pOldSD,
    IN MARTA_CONTEXT               Context,
    IN HANDLE                      ProcessHandle,
    IN PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN PGENERIC_MAPPING            pGenMap
    )
{
    MARTA_OBJECT_PROPERTIES ObjectProperties;

    DWORD                dwErr             = ERROR_SUCCESS;
    BOOL                 bIsChildContainer = FALSE;
    BOOL                 bRetryPropagation = FALSE;
    BOOL                 bDoPropagate      = TRUE;
    HANDLE               ThreadHandle      = NULL;
    PSECURITY_DESCRIPTOR pOldChildSD       = NULL;
    PSECURITY_DESCRIPTOR pNewChildSD       = NULL;
    MARTA_CONTEXT        ChildContext      = NULL_MARTA_CONTEXT;

    //
    // Get the first child to update.
    //

    dwErr = (*(pMartaSetFunctionContext->fFindFirst))(
                   Context,
                   (*(pMartaSetFunctionContext->fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, TRUE, SecurityInfo),
                   &ChildContext
                   );

    if (ERROR_SUCCESS != dwErr)
    {
        if (NULL == ChildContext)
        {
            dwErr = (*(pMartaSetFunctionContext->fFindFirst))(
                           Context,
                           (*(pMartaSetFunctionContext->fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo),
                           &ChildContext
                           );
        }
        else
        {
            dwErr = (*(pMartaSetFunctionContext->fReopenContext))(
                           ChildContext,
                           (*(pMartaSetFunctionContext->fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo)
                           );
        }

        bDoPropagate = FALSE;
    }

    if (NULL == ChildContext)
    {
        return TRUE;
    }

    CONDITIONAL_EXIT(dwErr, EndOfWhile);

    //
    // Note: On any intermediate error the current child is skipped.
    //

    while (ChildContext)
    {

        ObjectProperties.cbSize  = sizeof(ObjectProperties);
        ObjectProperties.dwFlags = 0;

        dwErr = (*(pMartaSetFunctionContext->fGetProperties))(
                       ChildContext,
                       &ObjectProperties
                       );

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

        bIsChildContainer = FLAG_ON(ObjectProperties.dwFlags, MARTA_OBJECT_IS_CONTAINER);

        dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                       ChildContext,
                       (SecurityInfo | OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION),
                       &pOldChildSD
                       );

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

        //
        // Skip the children that are protected.
        //

        if (!MARTA_SD_NOT_PROTECTED((PISECURITY_DESCRIPTOR) pOldChildSD, SecurityInfo))
        {
            goto EndOfWhile;

        }

        //
        // Convert NT4 SD to NT5 style.
        //

        if (FALSE == MartaIsSDNT5Style(pOldChildSD))
        {
            //
            // Note that this modifies OldChildSD in one of the two ways:
            //     1. If any of the inheritable aces from the OldSD are missing
            //        from OldChild then
            //            Mark the acl PROTECTED.
            //     2. else
            //            Mark the common aces in ChildSD as INHERITED.
            //

            dwErr = MartaGetNT4NodeSD(
                        pOldSD,
                        pOldChildSD,
                        ProcessHandle,
                        bIsChildContainer,
                        pGenMap,
                        SecurityInfo
                        );

            CONDITIONAL_EXIT(dwErr, EndOfWhile);
        }

        MARTA_TURN_OFF_IMPERSONATION;

        //
        // Merge the NewParentSD and the OldChildSD to create NewChildSD.
        //

        if (FALSE == CreatePrivateObjectSecurityEx(
                         pNewSD,
                         pOldChildSD,
                         &pNewChildSD,
                         NULL,
                         bIsChildContainer,
                         (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT |
                          SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                         ProcessHandle,
                         pGenMap
                         ))
        {
            dwErr = GetLastError();
        }

        MARTA_TURN_ON_IMPERSONATION;

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

        //
        // Update the subtree undrneath this child.
        //

        if (bIsChildContainer)
        {
            if (bDoPropagate)
            {
                bRetryPropagation = MartaUpdateTree(
                                        SecurityInfo,
                                        pNewChildSD,
                                        pOldChildSD,
                                        ChildContext,
                                        ProcessHandle,
                                        pMartaSetFunctionContext,
                                        pGenMap
                                        );
            }
            else
            {
                bRetryPropagation = TRUE;
            }
        }

        //
        // Stamp NewChildSD on child.
        //

        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pNewChildSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pNewChildSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
        }

        dwErr = (*(pMartaSetFunctionContext->fSetRights))(
                       ChildContext,
                       SecurityInfo,
                       pNewChildSD
                       );

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

        //
        // If propagation had failed in the first attept then try again. This is to
        // cover the case when the container can be enumerated after setting the new
        // security.

        if (bRetryPropagation && (SecurityInfo & DACL_SECURITY_INFORMATION))
        {
            ACCESS_MASK Access = (*(pMartaSetFunctionContext->fGetDesiredAccess))(
                                        NO_ACCESS_RIGHTS,
                                        TRUE,
                                        SecurityInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)
                                        );

            dwErr = (*(pMartaSetFunctionContext->fReopenContext))(
                           ChildContext,
                           Access
                           );

            CONDITIONAL_EXIT(dwErr, EndOfWhile);

            (VOID) MartaUpdateTree(
                       SecurityInfo,
                       pNewChildSD,
                       pOldChildSD,
                       ChildContext,
                       ProcessHandle,
                       pMartaSetFunctionContext,
                       pGenMap
                       );
        }

EndOfWhile:

        bRetryPropagation = FALSE;

        if (NULL != pOldChildSD)
        {
            AccFree(pOldChildSD);
            pOldChildSD = NULL;
        }

        